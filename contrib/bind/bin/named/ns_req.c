begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_req.c	4.47 (Berkeley) 7/1/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_req.c,v 8.138.2.4 2001/08/10 03:00:14 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_struct
struct|struct
name|addinfo
block|{
name|char
modifier|*
name|a_dname
decl_stmt|;
comment|/* domain name */
name|char
modifier|*
name|a_rname
decl_stmt|;
comment|/* referred by */
name|u_int16_t
name|a_rtype
decl_stmt|;
comment|/* referred by */
name|u_int16_t
name|a_type
decl_stmt|;
comment|/* type for data */
name|u_int16_t
name|a_class
decl_stmt|;
comment|/* class for data */
block|}
struct|;
end_struct

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_enum
enum|enum
name|req_action
block|{
name|Finish
block|,
name|Refuse
block|,
name|Return
block|}
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|addinfo
name|addinfo
index|[
name|NADDRECS
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|addname
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|,
name|u_int16_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|copyCharString
parameter_list|(
name|u_char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|req_action
name|req_query
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|int
modifier|*
name|msglenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|dfd
parameter_list|,
name|int
modifier|*
name|ra
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|struct
name|tsig_record
modifier|*
name|in_tsig
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|req_action
name|req_iquery
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function_decl
specifier|static
name|enum
name|req_action
name|req_notify
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Process request using database; assemble and send response.  */
end_comment

begin_function
name|void
name|ns_req
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|int
name|buflen
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
name|dfd
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
name|enum
name|req_action
name|action
decl_stmt|;
name|int
name|n
decl_stmt|,
name|ra
decl_stmt|,
name|has_tsig
decl_stmt|,
name|tsig_size
decl_stmt|,
name|sig2len
decl_stmt|;
name|u_char
modifier|*
name|tsigstart
decl_stmt|;
name|u_char
name|sig
index|[
name|TSIG_SIG_SIZE
index|]
decl_stmt|,
name|sig2
index|[
name|TSIG_SIG_SIZE
index|]
decl_stmt|;
name|struct
name|tsig_record
modifier|*
name|in_tsig
init|=
name|NULL
decl_stmt|;
name|int
name|error
init|=
name|NOERROR
decl_stmt|;
name|int
name|msglen_orig
init|=
name|msglen
decl_stmt|;
name|int
name|buflen_orig
init|=
name|buflen
decl_stmt|;
name|int
name|siglen
init|=
sizeof|sizeof
name|sig
decl_stmt|;
name|DST_KEY
modifier|*
name|key
decl_stmt|;
name|time_t
name|tsig_time
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|3
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_packet
argument_list|,
literal|3
argument_list|,
literal|"ns_req(from %s)"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|fp_nquery
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|tsigstart
operator|=
name|ns_find_tsig
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsigstart
operator|==
name|NULL
condition|)
name|has_tsig
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|char
name|buf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|has_tsig
operator|=
literal|1
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|tsigstart
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: bad TSIG key name"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ns_r_formerr
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
name|key
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|key
operator|=
name|find_key
argument_list|(
name|buf
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ns_r_badkey
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_notauth
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: TSIG verify failed - unknown key %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LOG_TSIG_BUG
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|key
operator|==
name|NULL
condition|)
name|ns_error
argument_list|(
name|ns_log_security
argument_list|,
literal|"SECURITY: POSSIBLE ATTEMPT TO EXERCISE \"TSIG BUG\" FROM %s: %s%s%s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
literal|"bad key (formerr)"
else|:
literal|"unknown key ("
argument_list|,
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
literal|""
else|:
operator|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|buf
else|:
literal|"."
operator|)
argument_list|,
operator|(
name|n
operator|<
literal|0
operator|)
condition|?
literal|""
else|:
literal|")"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|has_tsig
operator|&&
name|key
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|ns_verify
argument_list|(
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
operator|&
name|tsig_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_notauth
expr_stmt|;
comment|/* A query should never have an error code set */
if|if
condition|(
name|n
operator|==
name|ns_r_badsig
operator|||
name|n
operator|==
name|ns_r_badkey
operator|||
name|n
operator|==
name|ns_r_badtime
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: TSIG verify failed - query had error %s (%d) set"
argument_list|,
name|p_rcode
argument_list|(
name|n
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|error
operator|=
name|n
expr_stmt|;
name|action
operator|=
name|Return
expr_stmt|;
block|}
comment|/* If there's a processing error just respond */
elseif|else
if|if
condition|(
name|n
operator|==
operator|-
name|ns_r_badsig
operator|||
name|n
operator|==
operator|-
name|ns_r_badkey
operator|||
name|n
operator|==
operator|-
name|ns_r_badtime
condition|)
block|{
name|n
operator|=
operator|-
name|n
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: TSIG verify failed - %s (%d)"
argument_list|,
name|p_rcode
argument_list|(
name|n
argument_list|)
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|error
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: TSIG verify failed - FORMERR"
argument_list|)
expr_stmt|;
name|error
operator|=
name|ns_r_formerr
expr_stmt|;
block|}
name|action
operator|=
name|Finish
expr_stmt|;
block|}
name|in_tsig
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tsig_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_tsig
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"memget failed"
argument_list|)
expr_stmt|;
name|in_tsig
operator|->
name|key
operator|=
name|key
expr_stmt|;
name|in_tsig
operator|->
name|siglen
operator|=
name|siglen
expr_stmt|;
name|memcpy
argument_list|(
name|in_tsig
operator|->
name|sig
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
name|tsig_size
operator|=
name|msglen_orig
operator|-
name|msglen
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_tsig
condition|)
block|{
name|action
operator|=
name|Finish
expr_stmt|;
name|in_tsig
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|tsig_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_tsig
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"memget failed"
argument_list|)
expr_stmt|;
name|in_tsig
operator|->
name|key
operator|=
name|NULL
expr_stmt|;
name|in_tsig
operator|->
name|siglen
operator|=
literal|0
expr_stmt|;
name|tsig_size
operator|=
name|msg
operator|+
name|msglen
operator|-
name|tsigstart
expr_stmt|;
name|msglen
operator|=
name|tsigstart
operator|-
name|msg
expr_stmt|;
block|}
comment|/* Hash some stuff so it's nice and random */
name|nsid_hash
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tt
argument_list|,
sizeof|sizeof
argument_list|(
name|tt
argument_list|)
argument_list|)
expr_stmt|;
name|nsid_hash
argument_list|(
name|msg
argument_list|,
operator|(
name|msglen
operator|>
literal|512
operator|)
condition|?
literal|512
else|:
name|msglen
argument_list|)
expr_stmt|;
comment|/* 	 * It's not a response so these bits have no business 	 * being set. will later simplify work if we can 	 * safely assume these are always 0 when a query 	 * comes in. 	 */
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|hp
operator|->
name|opcode
operator|!=
name|ns_o_notify
condition|)
endif|#
directive|endif
name|hp
operator|->
name|aa
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NOERROR
condition|)
name|hp
operator|->
name|rcode
operator|=
name|ns_r_noerror
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
name|buflen
operator|-=
name|HFIXEDSZ
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|dnptrs
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|NOERROR
condition|)
block|{
switch|switch
condition|(
name|hp
operator|->
name|opcode
condition|)
block|{
case|case
name|ns_o_query
case|:
name|action
operator|=
name|req_query
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
name|qsp
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|msglen
argument_list|,
name|msg
argument_list|,
name|dfd
argument_list|,
operator|&
name|ra
argument_list|,
name|from
argument_list|,
name|in_tsig
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_o_iquery
case|:
name|action
operator|=
name|req_iquery
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
operator|&
name|buflen
argument_list|,
name|msg
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
case|case
name|ns_o_notify
case|:
name|action
operator|=
name|req_notify
argument_list|(
name|hp
argument_list|,
operator|&
name|cp
argument_list|,
name|eom
argument_list|,
name|msg
argument_list|,
name|from
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIND_UPDATE
case|case
name|ns_o_update
case|:
name|action
operator|=
name|req_update
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|eom
argument_list|,
name|msg
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
name|from
argument_list|,
name|in_tsig
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* BIND_UPDATE */
default|default:
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: Opcode %d not implemented"
argument_list|,
name|hp
operator|->
name|opcode
argument_list|)
expr_stmt|;
comment|/* XXX - should syslog, limited by haveComplained */
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_notimpl
expr_stmt|;
name|action
operator|=
name|Finish
expr_stmt|;
block|}
block|}
if|if
condition|(
name|in_tsig
operator|!=
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|in_tsig
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsig_record
argument_list|)
argument_list|)
expr_stmt|;
name|in_tsig
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Vector via internal opcode. 	 */
switch|switch
condition|(
name|action
condition|)
block|{
case|case
name|Return
case|:
return|return;
case|case
name|Refuse
case|:
name|hp
operator|->
name|rcode
operator|=
name|ns_r_refused
expr_stmt|;
name|cp
operator|=
name|eom
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|Finish
case|:
comment|/* rest of the function handles this case */
break|break;
default|default:
name|panic
argument_list|(
literal|"ns_req: bad action variable"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* 	 * Apply final polish. 	 */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
comment|/* set Response flag */
name|hp
operator|->
name|ra
operator|=
name|ra
expr_stmt|;
comment|/* init above, may be modified by req_query */
if|if
condition|(
operator|!
name|hp
operator|->
name|tc
operator|&&
name|has_tsig
operator|>
literal|0
operator|&&
name|buflen
operator|<
name|tsig_size
condition|)
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
comment|/* 	 * If there was a format error, then we don't know what the msg has. 	 */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|ns_r_formerr
condition|)
block|{
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
block|}
comment|/* 	 * If the query had a TSIG and the message is truncated or there was 	 * a TSIG error, build a new message with no data and a TSIG. 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|tc
operator|||
name|error
operator|!=
name|NOERROR
operator|)
operator|&&
name|has_tsig
operator|>
literal|0
condition|)
block|{
name|sign_again
label|:
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|cp
operator|+=
name|ns_skiprr
argument_list|(
name|cp
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|ns_s_qd
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
argument_list|)
expr_stmt|;
name|sig2len
operator|=
sizeof|sizeof
name|sig2
expr_stmt|;
name|msglen
operator|=
name|cp
operator|-
name|msg
expr_stmt|;
name|buflen
operator|=
name|buflen_orig
operator|-
name|msglen
expr_stmt|;
name|n
operator|=
name|ns_sign
argument_list|(
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|msglen
operator|+
name|buflen
argument_list|,
name|error
argument_list|,
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|sig2
argument_list|,
operator|&
name|sig2len
argument_list|,
name|tsig_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NS_TSIG_ERROR_NO_SPACE
operator|&&
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|sign_again
goto|;
block|}
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_req: unable to sign response"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
block|}
comment|/* Either the message is not truncated or there was no TSIG */
else|else
block|{
comment|/* 		 * Reserve space for tsig if required. 		 */
if|if
condition|(
name|has_tsig
operator|>
literal|0
condition|)
name|buflen
operator|-=
name|tsig_size
expr_stmt|;
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|has_tsig
operator|>
literal|0
condition|)
block|{
name|buflen
operator|+=
name|tsig_size
expr_stmt|;
name|sig2len
operator|=
sizeof|sizeof
name|sig2
expr_stmt|;
name|msglen
operator|=
name|cp
operator|-
name|msg
expr_stmt|;
name|n
operator|=
name|ns_sign
argument_list|(
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|msglen
operator|+
name|buflen
argument_list|,
name|error
argument_list|,
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|sig2
argument_list|,
operator|&
name|sig2len
argument_list|,
name|tsig_time
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_req: answer -> %s fd=%d id=%d size=%d rc=%d"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|(
name|qsp
operator|==
name|NULL
operator|)
condition|?
name|dfd
else|:
name|qsp
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*DEBUG*/
if|if
condition|(
name|qsp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|sendto
argument_list|(
name|dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
sizeof|sizeof
name|from
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|sendtoStr
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_req: sendto(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSentAns
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|ns_r_nxdomain
condition|)
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSentNXD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssSentNaAns
argument_list|)
expr_stmt|;
block|}
else|else
name|writestream
argument_list|(
name|qsp
argument_list|,
name|msg
argument_list|,
name|cp
operator|-
name|msg
argument_list|)
expr_stmt|;
comment|/* Is now a safe time? */
if|if
condition|(
name|needs_prime_cache
condition|)
name|prime_cache
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function
name|int
name|findZonePri
parameter_list|(
specifier|const
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ina
operator|=
name|from
operator|.
name|sin_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|i
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|zp
operator|->
name|z_addr
index|[
name|i
index|]
argument_list|,
name|ina
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|req_action
name|req_notify
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
comment|/* valid notify's are authoritative */
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Notify request without AA"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|not_yet
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
endif|#
directive|endif
block|}
name|hp
operator|->
name|aa
operator|=
literal|0
expr_stmt|;
comment|/* valid notify's have one question */
if|if
condition|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Notify header counts wrong"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"FORMERR notify too short"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"rcvd NOTIFY(%s, %s, %s) from %s"
argument_list|,
name|dnbuf
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX - when answers are allowed, we'll need to do compression 	 * correctly here, and we will need to check for packet underflow. 	 */
comment|/* 	 * We are ignoring the other field, make sure the header reflects 	 * *cpp. 	 */
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Find the zone this NOTIFY refers to. */
name|zp
operator|=
name|find_auth_zone
argument_list|(
name|dnbuf
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"rcvd NOTIFY for \"%s\", name not one of our zones"
argument_list|,
name|dnbuf
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_servfail
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* Access control. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_SOA
case|:
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_slave
condition|)
block|{
comment|/* 			 * This can come if a user did an AXFR of some zone 			 * somewhere and that zone's server now wants to 			 * tell us that the SOA has changed.  AXFR's always 			 * come from nonpriv ports so it isn't possible to 			 * know whether it was the server or just "dig". 			 * This condition can be avoided by using secure 			 * zones since that way only real secondaries can 			 * AXFR from you. 			 */
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"NOTIFY(SOA) for non-slave zone (%s), from %s"
argument_list|,
name|dnbuf
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
name|ns_samename
argument_list|(
name|dnbuf
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"NOTIFY(SOA) for non-origin (%s), from %s"
argument_list|,
name|dnbuf
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
if|if
condition|(
name|findZonePri
argument_list|(
name|zp
argument_list|,
name|from
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|1
argument_list|,
literal|"NOTIFY(SOA) from non-master server (zone %s), from %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|refuse
goto|;
block|}
break|break;
default|default:
comment|/* No access requirements defined for other types. */
break|break;
block|}
comment|/* The work occurs here. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_SOA
case|:
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_NEED_RELOAD
operator||
name|Z_NEED_XFER
operator||
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"NOTIFY(SOA) for zone already xferring (%s)"
argument_list|,
name|dnbuf
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_NEEDREFRESH
expr_stmt|;
goto|goto
name|noerror
goto|;
block|}
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|qserial_query
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 		 * Unimplemented, but it's not a protocol error, just 		 * something to be ignored. 		 */
name|hp
operator|->
name|rcode
operator|=
name|ns_r_notimpl
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|noerror
label|:
name|hp
operator|->
name|rcode
operator|=
name|ns_r_noerror
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
name|refuse
label|:
name|hp
operator|->
name|rcode
operator|=
name|ns_r_refused
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*BIND_NOTIFY*/
end_comment

begin_function
specifier|static
name|enum
name|req_action
name|req_query
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|int
modifier|*
name|msglenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|dfd
parameter_list|,
name|int
modifier|*
name|ra
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|struct
name|tsig_record
modifier|*
name|in_tsig
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|count
decl_stmt|,
name|zone
decl_stmt|,
name|foundname
decl_stmt|,
name|founddata
decl_stmt|,
name|omsglen
decl_stmt|,
name|cname
decl_stmt|;
name|int
name|recursion_blocked_by_acl
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|u_int32_t
name|serial_ixfr
decl_stmt|;
name|int
name|ixfr_found
decl_stmt|;
name|int
name|ixfr_error
init|=
literal|0
decl_stmt|;
name|char
name|dnbuf2
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|omsg
decl_stmt|,
modifier|*
name|answers
decl_stmt|,
modifier|*
name|afterq
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|anp
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|DST_KEY
modifier|*
name|in_key
init|=
operator|(
name|in_tsig
operator|!=
name|NULL
operator|)
condition|?
name|in_tsig
operator|->
name|key
else|:
name|NULL
decl_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdQ
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Make gcc happy. 	 */
name|omsglen
operator|=
literal|0
expr_stmt|;
name|omsg
operator|=
name|NULL
expr_stmt|;
name|id
operator|=
literal|0
expr_stmt|;
name|recursion_blocked_by_acl
operator|=
literal|0
expr_stmt|;
comment|/* valid queries have one question and zero answers */
if|if
condition|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|1
operator|)
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query header counts wrong"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * Get domain name, class, and type. 	 */
if|if
condition|(
operator|(
operator|*
operator|*
name|cpp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
operator|*
name|cpp
expr_stmt|;
comment|/* remember name for compression */
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
name|answers
operator|=
operator|*
name|cpp
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query message length short"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|<
name|eom
operator|&&
name|type
operator|!=
name|ns_t_ixfr
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|6
argument_list|,
literal|"message length> received message"
argument_list|)
expr_stmt|;
operator|*
name|msglenp
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|type
operator|!=
name|ns_t_ixfr
operator|)
operator|)
operator|||
operator|(
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|!=
literal|1
operator|)
operator|&&
operator|(
name|type
operator|==
name|ns_t_ixfr
operator|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query nscount wrong"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|afterq
operator|=
operator|*
name|cpp
expr_stmt|;
name|qtypeIncr
argument_list|(
name|type
argument_list|)
expr_stmt|;
comment|/* 	 * Process query. 	 */
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"Request %s from %s"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* Force IXFR queries to be non recursive. */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
operator|*
name|cpp
argument_list|,
name|dnbuf2
argument_list|,
sizeof|sizeof
name|dnbuf2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ran out of data in IXFR query"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|n
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|ns_t_soa
operator|||
name|ns_samename
argument_list|(
name|dnbuf
argument_list|,
name|dnbuf2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR SOA record expected"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|INT32SZ
operator|+
name|INT16SZ
operator|*
literal|2
expr_stmt|;
comment|/* skip class, ttl, dlen */
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
operator|*
name|cpp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
comment|/* mname */
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
operator|*
name|cpp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR Query expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
comment|/* rname */
if|if
condition|(
operator|*
name|cpp
operator|+
literal|5
operator|*
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ran out of data in IXFR query"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETLONG
argument_list|(
name|serial_ixfr
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
comment|/* ignore other soa counters */
if|if
condition|(
operator|(
operator|*
name|cpp
operator|+
operator|(
literal|4
operator|*
name|INT32SZ
operator|)
operator|)
operator|<
name|eom
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|6
argument_list|,
literal|"ixfr: message length> received message"
argument_list|)
expr_stmt|;
comment|/* Reset msglenp to cover just the question. */
operator|*
name|msglenp
operator|=
name|afterq
operator|-
name|msg
expr_stmt|;
block|}
operator|*
name|cpp
operator|=
name|afterq
expr_stmt|;
if|if
condition|(
operator|!
name|ns_t_udp_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* Refuse request if not a TCP connection. */
if|if
condition|(
name|qsp
operator|==
name|NULL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"rejected UDP %s from %s for \"%s\""
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dnbuf
condition|?
name|dnbuf
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* The position of this is subtle. */
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdAXFR
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* Recursion not possible. */
block|}
operator|*
name|buflenp
operator|-=
operator|(
operator|*
name|msglenp
operator|-
name|HFIXEDSZ
operator|)
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_queries
argument_list|,
literal|"%s/%s/%s/%s/%s"
argument_list|,
operator|(
name|hp
operator|->
name|rd
operator|)
condition|?
literal|"XX+"
else|:
literal|"XX "
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|dname
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
name|try_again
label|:
name|foundname
operator|=
literal|0
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"req: nlookup(%s) id %d type=%d class=%d"
argument_list|,
name|dname
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
if|if
condition|(
operator|(
name|anp
operator|=
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fname
operator|=
literal|""
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"req: %s '%s' as '%s' (cname=%d)"
argument_list|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
name|cname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|YPKLUDGE
comment|/* Some braindamaged resolver software will not  	   recognize internet addresses in dot notation and  	   send out address  queries for "names" such as  	   128.93.8.1.  This kludge will prevent those  	   from flooding higher level servers. 	   We simply claim to be authoritative and that 	   the domain doesn't exist. 	   Note that we could return the address but we 	   don't do that in order to encourage that broken 	   software is fixed. 	*/
if|if
condition|(
operator|!
name|np
operator|&&
name|type
operator|==
name|T_A
operator|&&
name|class
operator|==
name|C_IN
operator|&&
name|dname
condition|)
block|{
name|struct
name|in_addr
name|ina
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|dname
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_nxdomain
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ypkludge: hit as '%s'"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
endif|#
directive|endif
comment|/*YPKLUDGE*/
comment|/* 	 * Don't accept in a query names which would be rejected in responses. 	 * (This is primarily in case we have to forward it, but it's also a 	 * matter of architectural symmetry.) 	 */
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"bad name in query"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* 	 * Begin Access Control Point 	 */
name|zone
operator|=
name|DB_Z_CACHE
expr_stmt|;
if|if
condition|(
name|np
condition|)
block|{
name|struct
name|namebuf
modifier|*
name|access_np
decl_stmt|;
comment|/* 		 * Find out which zone this will be answered from.  Note 		 * that we look for a zone with the same class as ours. 		 * The np that we found in the database might not be the 		 * one we asked for (i.e. dname might not equal fname).  This 		 * is OK, since if a name doesn't exist, we need to go up 		 * the tree until we find the closest enclosing zone that 		 * is of the same class. 		 */
for|for
control|(
name|access_np
operator|=
name|np
init|;
name|access_np
operator|!=
name|NULL
condition|;
name|access_np
operator|=
name|np_parent
argument_list|(
name|access_np
argument_list|)
control|)
block|{
name|dp
operator|=
name|access_np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|&&
name|dp
operator|->
name|d_class
operator|!=
name|class
condition|)
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|zone
operator|=
name|dp
operator|->
name|d_zone
expr_stmt|;
break|break;
block|}
block|}
block|}
name|zp
operator|=
operator|&
name|zones
index|[
name|zone
index|]
expr_stmt|;
name|ixfr_found
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
operator|&&
name|zone
operator|!=
name|DB_Z_CACHE
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|serial_ixfr
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
condition|)
name|ixfr_found
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|ixfr_error
operator|=
name|ixfr_have_log
argument_list|(
name|zp
argument_list|,
name|serial_ixfr
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfr_error
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"No %s log from %d for \"%s\""
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|serial_ixfr
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ixfr_have_log(%d %d) failed %d"
argument_list|,
name|serial_ixfr
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|,
name|ixfr_error
argument_list|)
expr_stmt|;
name|ixfr_found
operator|=
literal|0
expr_stmt|;
comment|/* Refuse IXFR and send AXFR */
block|}
elseif|else
if|if
condition|(
name|ixfr_error
operator|==
literal|1
condition|)
block|{
name|ixfr_found
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"IXFR log lowest serial: %d"
argument_list|,
name|zp
operator|->
name|z_serial_ixfr_start
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If recursion is turned on, we need to check recursion ACL 	 * if it exists - and return result to caller. 	 */
block|{
name|ip_match_list
name|recursion_acl
decl_stmt|;
name|recursion_acl
operator|=
name|server_options
operator|->
name|recursion_acl
expr_stmt|;
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|&&
name|recursion_acl
operator|!=
name|NULL
operator|&&
operator|!
name|ip_address_allowed
argument_list|(
name|recursion_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|recursion_blocked_by_acl
operator|=
literal|1
expr_stmt|;
operator|*
name|ra
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Are queries allowed from this host? 	 */
if|if
condition|(
operator|!
name|ns_t_xfr_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|ip_match_list
name|query_acl
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_query_acl
operator|!=
name|NULL
condition|)
name|query_acl
operator|=
name|zp
operator|->
name|z_query_acl
expr_stmt|;
else|else
name|query_acl
operator|=
name|server_options
operator|->
name|query_acl
expr_stmt|;
if|if
condition|(
name|query_acl
operator|!=
name|NULL
operator|&&
operator|!
name|ip_addr_or_key_allowed
argument_list|(
name|query_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|,
name|in_key
argument_list|)
condition|)
block|{
comment|/* 			 * If this is *not* a zone acl and we would not 			 * have recursed and we have some answer return 			 * what we have with a referral. 			 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_query_acl
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|!
name|hp
operator|->
name|rd
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|||
name|recursion_blocked_by_acl
operator|)
operator|&&
operator|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
goto|goto
name|fetchns
goto|;
block|}
comment|/* 			 * See if we would have made a referral from  			 * an enclosing zone if we are actually in the 			 * cache. 			 */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_cache
operator|&&
name|np
operator|!=
name|NULL
condition|)
block|{
name|struct
name|namebuf
modifier|*
name|access_np
decl_stmt|;
name|zone
operator|=
name|DB_Z_CACHE
expr_stmt|;
for|for
control|(
name|access_np
operator|=
name|np
init|;
name|access_np
operator|!=
name|NULL
condition|;
name|access_np
operator|=
name|np_parent
argument_list|(
name|access_np
argument_list|)
control|)
block|{
name|dp
operator|=
name|access_np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|&&
operator|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|||
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|)
condition|)
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|zone
operator|=
name|dp
operator|->
name|d_zone
expr_stmt|;
name|np
operator|=
name|access_np
expr_stmt|;
break|break;
block|}
block|}
name|zp
operator|=
operator|&
name|zones
index|[
name|zone
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_cache
operator|&&
name|zp
operator|->
name|z_query_acl
operator|!=
name|NULL
operator|&&
name|ip_addr_or_key_allowed
argument_list|(
name|zp
operator|->
name|z_query_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|,
name|in_key
argument_list|)
operator|&&
operator|(
operator|!
name|hp
operator|->
name|rd
operator|||
name|recursion_blocked_by_acl
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|fetchns
goto|;
block|}
block|}
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"denied query from %s for \"%s\" %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdUQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
block|}
else|else
block|{
name|ip_match_list
name|transfer_acl
decl_stmt|;
comment|/* Do they have permission to do a zone transfer? */
if|if
condition|(
name|zp
operator|->
name|z_transfer_acl
operator|!=
name|NULL
condition|)
name|transfer_acl
operator|=
name|zp
operator|->
name|z_transfer_acl
expr_stmt|;
else|else
name|transfer_acl
operator|=
name|server_options
operator|->
name|transfer_acl
expr_stmt|;
if|if
condition|(
name|transfer_acl
operator|!=
name|NULL
operator|&&
operator|!
name|ip_addr_or_key_allowed
argument_list|(
name|transfer_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|,
name|in_key
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"denied %s from %s for \"%s\" %s (acl)"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdUXFR
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_refused
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* Are we master or slave? */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_master
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|z_slave
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"denied %s from %s for \"%s\" (not master/slave)"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdUXFR
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_refused
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* Are we authoritative? */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|==
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"denied %s from %s for \"%s\" %s (not authoritative)"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdUXFR
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_refused
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* Is the name at a zone cut? */
if|if
condition|(
name|ns_samename
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|dname
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"denied %s from %s for \"%s\" %s (not zone top)"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdUXFR
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_refused
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"approved %s from %s for \"%s\""
argument_list|,
operator|(
name|ixfr_found
operator|)
condition|?
name|p_type
argument_list|(
name|type
argument_list|)
else|:
literal|"IXFR/AXFR"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
block|}
else|else
name|ns_info
argument_list|(
name|ns_log_security
argument_list|,
literal|"approved %s from %s for \"%s\""
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * End Access Control Point 	 */
comment|/* 	 * Yow! 	 */
if|if
condition|(
name|class
operator|==
name|ns_c_chaos
operator|&&
name|type
operator|==
name|ns_t_txt
operator|&&
name|ns_samename
argument_list|(
name|dnbuf
argument_list|,
literal|"VERSION.BIND"
argument_list|)
operator|==
literal|1
condition|)
block|{
name|u_char
modifier|*
name|tp
decl_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_noerror
expr_stmt|;
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
literal|0
expr_stmt|;
name|copyCharString
argument_list|(
name|cpp
argument_list|,
literal|"VERSION"
argument_list|)
expr_stmt|;
comment|/* Name */
name|copyCharString
argument_list|(
name|cpp
argument_list|,
literal|"BIND"
argument_list|)
expr_stmt|;
operator|*
operator|(
operator|*
name|cpp
operator|)
operator|++
operator|=
literal|0x00
expr_stmt|;
name|PUTSHORT
argument_list|(
name|T_TXT
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
comment|/* Type */
name|PUTSHORT
argument_list|(
name|C_CHAOS
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
comment|/* Class */
name|PUTLONG
argument_list|(
literal|0
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
comment|/* TTL */
name|tp
operator|=
operator|*
name|cpp
expr_stmt|;
comment|/* Temp RdLength */
name|PUTSHORT
argument_list|(
literal|0
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|copyCharString
argument_list|(
name|cpp
argument_list|,
name|server_options
operator|->
name|version
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
operator|*
name|cpp
operator|)
operator|-
operator|(
name|tp
operator|+
name|INT16SZ
operator|)
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* Real RdLength */
operator|*
name|msglenp
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
comment|/* Total message length */
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * If we don't know anything about the requested name, 	 * go look for nameservers. 	 */
if|if
condition|(
operator|!
name|np
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetchns
goto|;
name|foundname
operator|++
expr_stmt|;
name|answers
operator|=
operator|*
name|cpp
expr_stmt|;
name|count
operator|=
operator|*
name|cpp
operator|-
name|msg
expr_stmt|;
comment|/* The response is authoritative until we add insecure data */
name|hp
operator|->
name|ad
operator|=
literal|1
expr_stmt|;
comment|/* Look for NXDOMAIN record with appropriate class 	 * if found return immediately 	 */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|stale
argument_list|(
name|dp
argument_list|)
operator|&&
operator|(
name|dp
operator|->
name|d_rcode
operator|==
name|ns_r_nxdomain
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_class
operator|==
name|class
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RETURNSOA
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
comment|/* this should not occur */
name|hp
operator|->
name|rcode
operator|=
name|ns_r_noerror
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
else|#
directive|else
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|ns_r_nxdomain
expr_stmt|;
comment|/*  			 * XXX forcing AA all the time isn't right, but 			 * we have to work that way by default 			 * for compatibility with older servers. 			 */
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NONAUTH_NXDOMAIN
argument_list|)
condition|)
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"NXDOMAIN aa = %d"
argument_list|,
name|hp
operator|->
name|aa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORFC2308_TYPE1
argument_list|)
condition|)
return|return
operator|(
name|Finish
operator|)
return|;
name|founddata
operator|=
literal|1
expr_stmt|;
goto|goto
name|fetchns
goto|;
block|}
block|}
comment|/* 	 * If not NXDOMAIN, the NOERROR_NODATA record might be 	 * anywhere in the chain.  Have to go through the grind. 	 */
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
comment|/* 		 * NO data available.  Refuse transfer requests, or 		 * look for better servers for other requests. 		 */
if|if
condition|(
name|ns_t_xfr_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"transfer refused: no data"
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
goto|goto
name|fetchns
goto|;
block|}
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_noerror
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURNSOA
if|if
condition|(
name|count
condition|)
block|{
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|founddata
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"count = %d"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORFC2308_TYPE1
argument_list|)
condition|)
return|return
operator|(
name|Finish
operator|)
return|;
goto|goto
name|fetchns
goto|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
operator|*
name|msglenp
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|+
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|type
operator|!=
name|T_CNAME
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
if|if
condition|(
name|cname
operator|++
operator|>=
name|MAXCNAMES
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: leaving, MAXCNAMES exceeded"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_servfail
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"req: foundname=%d, count=%d, founddata=%d, cname=%d"
argument_list|,
name|foundname
argument_list|,
name|count
argument_list|,
name|founddata
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_t_xfr_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|incr_serial
argument_list|(
name|zp
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"error updating serial number for %s from %d"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Just return SOA if "up to date". 		 */
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|SEQ_GT
argument_list|(
name|serial_ixfr
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
operator|||
name|serial_ixfr
operator|==
name|zp
operator|->
name|z_serial
operator|)
condition|)
block|{
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
comment|/* 		 * We don't handle UDP based IXFR queries (yet). 		 * Tell client to retry with TCP by returning SOA. 		 */
if|if
condition|(
name|qsp
operator|==
name|NULL
condition|)
return|return
operator|(
name|Finish
operator|)
return|;
else|else
block|{
if|if
condition|(
operator|!
name|ixfr_found
operator|&&
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|qsp
operator|->
name|flags
operator||=
name|STREAM_AXFRIXFR
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ns_xfr
argument_list|(
name|qsp
argument_list|,
name|np
argument_list|,
name|zone
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|hp
operator|->
name|opcode
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|,
name|serial_ixfr
argument_list|,
name|in_tsig
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|Return
operator|)
return|;
block|}
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
name|type
operator|==
name|T_A
operator|&&
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|&&
name|hp
operator|->
name|rd
condition|)
name|sort_response
argument_list|(
name|answers
argument_list|,
operator|*
name|cpp
argument_list|,
name|count
argument_list|,
operator|&
name|from
argument_list|)
expr_stmt|;
name|fetchns
label|:
comment|/* 	 * If we're already out of room in the response, we're done. 	 */
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
return|return
operator|(
name|Finish
operator|)
return|;
if|if
condition|(
name|hp
operator|->
name|ancount
operator|==
literal|0
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* We are authoritative for this np. */
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|ns_r_nxdomain
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"req: leaving (%s, rcode %d)"
argument_list|,
name|dname
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|&&
operator|(
operator|!
name|foundname
operator|||
operator|!
name|founddata
operator|)
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
ifdef|#
directive|ifdef
name|ADDAUTH
block|}
elseif|else
if|if
condition|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* don't add NS records for NOERROR NODATA 				   as some servers can get confused */
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|1
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
break|break;
default|default:
if|if
condition|(
name|np
operator|&&
operator|(
name|type
operator|!=
name|T_NS
operator|||
name|np
operator|!=
name|anp
operator|)
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/*ADDAUTH*/
block|}
block|}
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
case|case
name|SERVFAIL
case|:
comment|/* We're authoritative but the zone isn't loaded. */
if|if
condition|(
operator|!
name|founddata
operator|&&
operator|!
operator|(
name|NS_ZOPTION_P
argument_list|(
name|zp
argument_list|,
name|OPTION_FORWARD_ONLY
argument_list|)
operator|&&
name|NS_ZFWDTAB
argument_list|(
name|zp
argument_list|)
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|ns_r_servfail
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|founddata
operator|&&
name|hp
operator|->
name|rd
operator|&&
name|recursion_blocked_by_acl
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"denied recursion for query from %s for %s %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdURQ
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  If we successfully found the answer in the cache, 	 *  or this is not a recursive query, or we are purposely 	 *  never recursing, or recursion is prohibited by ACL, then 	 *  add the nameserver references("authority section") here 	 *  and we're done. 	 */
if|if
condition|(
name|founddata
operator|||
operator|!
name|hp
operator|->
name|rd
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|||
name|recursion_blocked_by_acl
condition|)
block|{
comment|/* 		 * If the qtype was NS, and the np of the authority is 		 * the same as the np of the data, we don't need to add 		 * another copy of the answer here in the authority 		 * section. 		 */
if|if
condition|(
operator|!
name|founddata
operator|||
name|type
operator|!=
name|T_NS
operator|||
name|anp
operator|!=
name|np
condition|)
block|{
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|+
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
comment|/* Our caller will handle the Additional section. */
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 *  At this point, we don't have the answer, but we do 	 *  have some NS's to try.  If the user would like us 	 *  to recurse, create the initial query.  If a cname 	 *  is involved, we need to build a new query and save 	 *  the old one in cmsg/cmsglen. 	 */
if|if
condition|(
name|cname
condition|)
block|{
name|omsg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
operator|(
name|unsigned
operator|)
operator|*
name|msglenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|omsg
operator|==
name|NULL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_req: Out Of Memory"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_servfail
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
name|omsglen
operator|=
operator|*
name|msglenp
expr_stmt|;
name|memcpy
argument_list|(
name|omsg
argument_list|,
name|msg
argument_list|,
name|omsglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|msg
argument_list|,
operator|*
name|msglenp
operator|+
operator|*
name|buflenp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_servfail
expr_stmt|;
name|memput
argument_list|(
name|omsg
argument_list|,
name|omsglen
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|msglenp
operator|=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
operator|*
name|msglenp
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
operator|&
name|qp
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|np
argument_list|,
literal|0
argument_list|,
name|in_tsig
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|FW_OK
operator|&&
name|cname
condition|)
block|{
name|memput
argument_list|(
name|omsg
argument_list|,
name|omsglen
argument_list|)
expr_stmt|;
name|omsg
operator|=
name|NULL
expr_stmt|;
block|}
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|FW_OK
case|:
if|if
condition|(
name|cname
condition|)
block|{
name|qp
operator|->
name|q_cname
operator|=
name|cname
expr_stmt|;
name|qp
operator|->
name|q_cmsg
operator|=
name|omsg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|omsglen
expr_stmt|;
name|qp
operator|->
name|q_cmsgsize
operator|=
name|omsglen
expr_stmt|;
name|qp
operator|->
name|q_id
operator|=
name|id
expr_stmt|;
block|}
break|break;
case|case
name|FW_DUP
case|:
break|break;
comment|/* Duplicate request dropped */
case|case
name|FW_NOSERVER
case|:
comment|/*  		 * Don't go into an infinite loop if  		 * the admin gave root NS records in the cache 		 * file without giving address records 		 * for the root servers. 		 */
if|if
condition|(
name|np
condition|)
block|{
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_req: no address for root server"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_servfail
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
break|break;
if|if
condition|(
name|dp
condition|)
block|{
comment|/* 				 * we know the child zone exists but are 				 * missing glue. 				 * 				 * nslookup has called sysquery() to get the 				 * missing glue. 				 * 				 * for UDP, drop the response and let the 				 * client retry.  for TCP, we should probably 				 * (XXX) hold open the TCP connection for a 				 * while in case the sysquery() comes back 				 * soon.  meanwhile we SERVFAIL. 				 */
if|if
condition|(
name|qsp
condition|)
goto|goto
name|do_servfail
goto|;
break|break;
block|}
name|np
operator|=
name|np_parent
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
goto|goto
name|fetchns
goto|;
comment|/* Try again. */
case|case
name|FW_SERVFAIL
case|:
name|do_servfail
label|:
name|hp
operator|->
name|rcode
operator|=
name|ns_r_servfail
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|Return
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|req_action
name|req_iquery
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
modifier|*
name|cpp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|int
modifier|*
name|buflenp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|u_int
name|rdata_offset
decl_stmt|;
name|size_t
name|alen
decl_stmt|;
name|int
name|dlen
decl_stmt|,
name|n
decl_stmt|;
name|ns_type
name|type
decl_stmt|;
name|ns_class
name|class
decl_stmt|;
name|u_char
name|anbuf
index|[
name|PACKETSZ
index|]
decl_stmt|,
modifier|*
name|anptr
decl_stmt|;
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdIQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|!=
literal|1
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|!=
literal|0
operator|||
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery header counts wrong"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * Skip domain name, get class, and type. 	 */
name|anptr
operator|=
operator|*
name|cpp
expr_stmt|;
name|n
operator|=
name|dn_skipname
argument_list|(
operator|*
name|cpp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery packet name problem"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery message too short"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cpp
operator|+
name|dlen
operator|!=
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"FORMERR IQuery message length off"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|ns_r_formerr
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|rdata_offset
operator|=
operator|*
name|cpp
operator|-
name|anptr
expr_stmt|;
operator|*
name|cpp
operator|+=
name|dlen
expr_stmt|;
name|INSIST
argument_list|(
operator|*
name|cpp
operator|==
name|eom
argument_list|)
expr_stmt|;
comment|/* 	 * Not all inverse queries are handled. 	 */
if|if
condition|(
name|type
operator|!=
name|ns_t_a
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_security
argument_list|,
literal|"unsupported iquery type from %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
if|if
condition|(
name|dlen
operator|!=
name|INT32SZ
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_security
argument_list|,
literal|"bad iquery from %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_FAKE_IQUERY
argument_list|)
condition|)
return|return
operator|(
name|Refuse
operator|)
return|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"req: IQuery class %d type %d"
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|alen
operator|=
name|eom
operator|-
name|anptr
expr_stmt|;
if|if
condition|(
name|alen
operator|>
sizeof|sizeof
name|anbuf
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_security
argument_list|,
literal|"bad iquery from %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|anbuf
argument_list|,
name|anptr
argument_list|,
name|alen
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|=
name|anptr
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|HFIXEDSZ
expr_stmt|;
ifdef|#
directive|ifdef
name|QRYLOG
if|if
condition|(
name|qrylog
condition|)
block|{
name|char
name|tmp
index|[
sizeof|sizeof
expr|"255.255.255.255"]
expr_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_queries
argument_list|,
literal|"XX /%s/%s/-%s"
argument_list|,
name|tmp
argument_list|,
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
operator|&
name|anbuf
index|[
name|rdata_offset
index|]
argument_list|)
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/*QRYLOG*/
comment|/* 	 * We can only get here if the option "fake-iquery" is on in the boot 	 * file. 	 * 	 * What we do here is send back a bogus response of "[dottedquad]". 	 * A better strategy would be to turn this into a PTR query, but that 	 * would legitimize inverse queries in a way they do not deserve. 	 */
name|sprintf
argument_list|(
name|dnbuf
argument_list|,
literal|"[%s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
operator|&
name|anbuf
index|[
name|rdata_offset
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|QFIXEDSZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
name|dnbuf
argument_list|,
operator|*
name|cpp
argument_list|,
operator|*
name|buflenp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
operator|*
name|cpp
operator|+=
name|n
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|type
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|INT16SZ
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|class
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|INT16SZ
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|alen
operator|>
operator|*
name|buflenp
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|*
name|cpp
argument_list|,
name|anbuf
argument_list|,
name|alen
argument_list|)
expr_stmt|;
operator|*
name|cpp
operator|+=
name|alen
expr_stmt|;
operator|*
name|buflenp
operator|-=
name|alen
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Test a datum for validity and return non-zero if it is out of date.  */
end_comment

begin_function
name|int
name|stale
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
decl_stmt|;
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|z_master
case|:
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|STUBS
case|case
name|z_stub
case|:
comment|/* root stub zones have DB_F_HINT set */
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* FALLTROUGH */
endif|#
directive|endif
case|case
name|z_slave
case|:
comment|/* 		 * Check to see whether a slave zone has expired or 		 * time warped; if so clear authority flag for zone, 		 * schedule the zone for immediate maintenance, and 		 * return true. 		 */
if|if
condition|(
call|(
name|int32_t
call|)
argument_list|(
name|tt
operator|.
name|tv_sec
operator|-
name|zp
operator|->
name|z_lastupdate
argument_list|)
operator|>
operator|(
name|int32_t
operator|)
name|zp
operator|->
name|z_expire
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"stale: slave zone %s expired"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|zp
argument_list|,
operator|(
name|u_long
operator|)
name|stale
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"slave zone \"%s\" expired"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_lastupdate
operator|>
name|tt
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|zp
argument_list|,
operator|(
name|u_long
operator|)
name|stale
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"slave zone \"%s\" time warp"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|z_hint
case|:
case|case
name|z_cache
case|:
if|if
condition|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|||
name|dp
operator|->
name|d_ttl
operator|>=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"stale: ttl %d %ld (x%lx)"
argument_list|,
name|dp
operator|->
name|d_ttl
argument_list|,
call|(
name|long
call|)
argument_list|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|dp
operator|->
name|d_flags
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
default|default:
comment|/* FALLTHROUGH */
empty_stmt|;
block|}
name|panic
argument_list|(
literal|"stale: impossible condition"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make gcc happy. */
block|}
end_function

begin_comment
comment|/*  * Copy databuf into a resource record for replies.  * Return size of RR if OK, -1 if buffer is full.  */
end_comment

begin_function
name|int
name|make_rr
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|u_char
modifier|*
name|buf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
name|doadd
parameter_list|,
name|u_char
modifier|*
modifier|*
name|comp_ptrs
parameter_list|,
name|u_char
modifier|*
modifier|*
name|edp
parameter_list|,
name|int
name|use_minimum
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|int32_t
name|n
decl_stmt|;
name|int16_t
name|type
init|=
name|dp
operator|->
name|d_type
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"make_rr(%s, %lx, %lx, %d, %d) %d zone %d ttl %lu"
argument_list|,
name|name
argument_list|,
operator|(
name|u_long
operator|)
name|dp
argument_list|,
operator|(
name|u_long
operator|)
name|buf
argument_list|,
name|buflen
argument_list|,
name|doadd
argument_list|,
name|dp
operator|->
name|d_size
argument_list|,
name|dp
operator|->
name|d_zone
argument_list|,
operator|(
name|u_long
operator|)
name|dp
operator|->
name|d_ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|&&
name|dp
operator|->
name|d_size
operator|==
literal|0
condition|)
name|panic
argument_list|(
literal|"make_rr: impossible d_rcode value"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
expr_stmt|;
comment|/* check for outdated RR before updating comp_ptrs[] by dn_comp() */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|!=
literal|0
operator|||
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
operator|-
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|!=
name|USE_MINIMUM
operator|&&
operator|!
name|use_minimum
condition|)
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
else|else
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
comment|/* really default */
block|}
name|buflen
operator|-=
name|RRFIXEDSZ
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
ifdef|#
directive|ifdef
name|RETURNSOA
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|name
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|+=
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|+=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|type
operator|=
name|T_SOA
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|n
operator|=
name|dn_comp
argument_list|(
name|name
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|=
name|buf
operator|+
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_CNAME
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_MB
case|:
case|case
name|T_NS
case|:
comment|/* Store domain name in answer */
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
block|{
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|T_A
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
name|addname
argument_list|(
name|name
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|T_KEY
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|type
operator|==
name|T_SOA
condition|?
name|n
operator|+
literal|5
operator|*
name|INT32SZ
else|:
name|n
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
condition|)
if|if
condition|(
name|incr_serial
argument_list|(
name|zp
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"error updating serial number for %s from %d"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|n
operator|=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
name|name
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|T_KEY
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NAPTR
case|:
comment|/* cp1 == our data/ cp == data of RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
comment|/* copy order */
name|buflen
operator|-=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* copy preference */
name|buflen
operator|-=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Flags */
name|n
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"size of n at flags = %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|buflen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Service */
name|n
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|buflen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Regexp */
name|n
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|buflen
operator|-=
name|n
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"current size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Replacement */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Replacement = %s"
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dn_comp's n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"saved size n = %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
comment|/* cp1 == our data/ cp == data of RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|-=
name|INT16SZ
operator|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* copy preference */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SRV
condition|)
block|{
name|buflen
operator|-=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|buflen
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
block|}
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
operator|(
name|type
operator|==
name|ns_t_mx
operator|)
condition|?
name|comp_ptrs
else|:
name|NULL
argument_list|,
operator|(
name|type
operator|==
name|ns_t_mx
operator|)
condition|?
name|edp
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doadd
condition|)
name|addname
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|T_A
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|(
name|buflen
operator|-=
name|INT16SZ
operator|)
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
comment|/* copy preference */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|comp_ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SIG
case|:
comment|/* cp1 == our data; cp == data of target RR */
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
comment|/* first just copy over the type_covered, algorithm, */
comment|/* labels, orig ttl, two timestamps, and the footprint */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_size
operator|-
literal|18
operator|)
operator|>
name|buflen
condition|)
goto|goto
name|cleanup
goto|;
comment|/* out of room! */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|18
expr_stmt|;
name|cp1
operator|+=
literal|18
expr_stmt|;
name|buflen
operator|-=
literal|18
expr_stmt|;
comment|/* then the signer's name */
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* finally, we copy over the variable-length signature */
name|n
operator|=
name|dp
operator|->
name|d_size
operator|-
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp1
operator|-
name|dp
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|buflen
condition|)
goto|goto
name|cleanup
goto|;
comment|/* out of room! */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* save data length& return */
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NXT
case|:
name|cp1
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|cleanup
goto|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* copy nxt bit map */
name|n
operator|=
name|dp
operator|->
name|d_size
operator|-
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp1
operator|-
name|dp
operator|->
name|d_data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|buflen
condition|)
goto|goto
name|cleanup
goto|;
comment|/* out of room! */
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|n
operator|=
call|(
name|u_int16_t
call|)
argument_list|(
operator|(
name|cp
operator|-
name|sp
operator|)
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|sp
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|(
name|type
operator|==
name|T_A
operator|||
name|type
operator|==
name|T_AAAA
operator|)
operator|&&
name|doadd
condition|)
name|addname
argument_list|(
name|name
argument_list|,
name|name
argument_list|,
name|type
argument_list|,
name|T_KEY
argument_list|,
name|dp
operator|->
name|d_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|>
name|buflen
condition|)
goto|goto
name|cleanup
goto|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|dp
operator|->
name|d_size
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dp
operator|->
name|d_size
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|-
name|buf
operator|)
return|;
name|cleanup
label|:
comment|/* Rollback RR. */
name|ns_name_rollback
argument_list|(
name|buf
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|*
operator|)
name|comp_ptrs
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|*
operator|)
name|edp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|addname
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
specifier|const
name|char
modifier|*
name|rname
parameter_list|,
name|u_int16_t
name|rtype
parameter_list|,
name|u_int16_t
name|type
parameter_list|,
name|u_int16_t
name|class
parameter_list|)
block|{
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
operator|,
name|n
operator|=
name|addcount
init|;
operator|--
name|n
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
if|if
condition|(
name|ns_samename
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dname
argument_list|)
operator|==
literal|1
operator|&&
name|ap
operator|->
name|a_type
operator|==
name|type
condition|)
return|return;
comment|/* add domain name to additional section */
if|if
condition|(
name|addcount
operator|<
name|NADDRECS
condition|)
block|{
name|addcount
operator|++
expr_stmt|;
name|ap
operator|->
name|a_dname
operator|=
name|savestr
argument_list|(
name|dname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_rname
operator|=
name|savestr
argument_list|(
name|rname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ap
operator|->
name|a_rtype
operator|=
name|rtype
expr_stmt|;
name|ap
operator|->
name|a_type
operator|=
name|type
expr_stmt|;
name|ap
operator|->
name|a_class
operator|=
name|class
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Lookup addresses/keys for names in addinfo and put into the message's  * additional section.  */
end_comment

begin_function
name|int
name|doaddinfo
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|)
block|{
specifier|register
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|register
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|register
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|register
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|int
name|ns_logging
decl_stmt|;
name|int
name|finishedA
init|=
literal|0
decl_stmt|;
name|int
name|save_addcount
init|=
name|addcount
decl_stmt|;
if|if
condition|(
operator|!
name|addcount
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ns_logging
operator|=
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_logging
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"doaddinfo() addcount = %d"
argument_list|,
name|addcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"doaddinfo(): tc already set, bailing"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|count
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|msg
expr_stmt|;
name|loop
label|:
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|int
name|foundany
init|=
literal|0
decl_stmt|,
name|foundcname
init|=
literal|0
decl_stmt|,
name|save_count
init|=
name|count
decl_stmt|,
name|save_msglen
init|=
name|msglen
decl_stmt|;
name|u_char
modifier|*
name|save_cp
init|=
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|finishedA
operator|==
literal|1
operator|&&
name|ap
operator|->
name|a_type
operator|==
name|T_A
operator|)
operator|||
operator|(
name|finishedA
operator|==
literal|0
operator|&&
name|ap
operator|->
name|a_type
operator|==
name|T_KEY
operator|)
condition|)
continue|continue;
if|if
condition|(
name|ns_logging
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"do additional \"%s\" (from \"%s\")"
argument_list|,
name|ap
operator|->
name|a_dname
argument_list|,
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* because "nlookup" stomps on arg. */
name|np
operator|=
name|nlookup
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|ap
operator|->
name|a_dname
condition|)
goto|goto
name|next_rr
goto|;
if|if
condition|(
name|ns_logging
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"found it"
argument_list|)
expr_stmt|;
comment|/* look for the data */
operator|(
name|void
operator|)
name|delete_stale
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
if|if
condition|(
operator|(
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_CNAME
argument_list|)
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
operator|)
operator|||
operator|(
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_CNAME
argument_list|)
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
operator|)
condition|)
block|{
name|foundcname
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ap
operator|->
name|a_type
operator|==
name|T_A
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_A
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_A
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_AAAA
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_AAAA
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|ns_t_a6
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|ns_t_a6
argument_list|)
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|ap
operator|->
name|a_type
operator|==
name|T_KEY
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|T_KEY
argument_list|)
operator|&&
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|C_IN
argument_list|,
name|T_KEY
argument_list|)
condition|)
continue|continue;
name|foundany
operator|++
expr_stmt|;
comment|/* 			 *  Should be smart and eliminate duplicate 			 *  data here.	XXX 			 */
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* truncation in the additional-data section 				 * is not all that serious.  we do not set TC, 				 * since the answer and authority sections are 				 * OK; however, since we're not setting TC we 				 * have to make sure that none of the RR's for 				 * this name go out (!TC implies that all 				 * {name,type} appearances are complete -- and 				 * since we only do A RR's here, the name is 				 * the key).	vixie, 23apr93 				 */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"addinfo: not enough room, remaining msglen = %d"
argument_list|,
name|save_msglen
argument_list|)
expr_stmt|;
comment|/* Rollback RRset. */
name|ns_name_rollback
argument_list|(
name|save_cp
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|*
operator|)
name|dnptrs
argument_list|,
operator|(
specifier|const
name|u_char
operator|*
operator|*
operator|)
name|dnptrs_end
argument_list|)
expr_stmt|;
name|cp
operator|=
name|save_cp
expr_stmt|;
name|msglen
operator|=
name|save_msglen
expr_stmt|;
name|count
operator|=
name|save_count
expr_stmt|;
break|break;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"addinfo: adding address data n = %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|msglen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
name|next_rr
label|:
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NOFETCHGLUE
argument_list|)
operator|&&
operator|!
name|foundcname
operator|&&
operator|!
name|foundany
operator|&&
operator|(
name|ap
operator|->
name|a_type
operator|==
name|T_A
operator|||
name|ap
operator|->
name|a_type
operator|==
name|T_AAAA
operator|)
condition|)
block|{
comment|/* ask a real server for this info */
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|,
operator|(
name|int
operator|)
name|ap
operator|->
name|a_class
argument_list|,
name|ap
operator|->
name|a_type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ns_port
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foundcname
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|nhash
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
argument_list|,
name|nhash
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_cname
argument_list|,
literal|"\"%s %s %s\" points to a CNAME (%s)"
argument_list|,
name|ap
operator|->
name|a_rname
argument_list|,
name|p_class
argument_list|(
name|ap
operator|->
name|a_class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|ap
operator|->
name|a_rtype
argument_list|)
argument_list|,
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
block|}
block|}
name|freestr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|finishedA
operator|==
literal|0
condition|)
block|{
name|finishedA
operator|=
literal|1
expr_stmt|;
name|addcount
operator|=
name|save_addcount
expr_stmt|;
goto|goto
name|loop
goto|;
comment|/* now do the KEYs... */
block|}
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|msg
operator|)
return|;
block|}
end_function

begin_function
name|int
name|doaddauth
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|int
name|buflen
parameter_list|,
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"doaddauth: can't add stale '%s' (%d)"
argument_list|,
name|dnbuf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|=
name|make_rr
argument_list|(
name|dnbuf
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"doaddauth: can't add oversize '%s' (%d) (n=%d)"
argument_list|,
name|dnbuf
argument_list|,
name|buflen
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_addinfo
parameter_list|()
block|{
name|struct
name|addinfo
modifier|*
name|ap
decl_stmt|;
for|for
control|(
name|ap
operator|=
name|addinfo
init|;
operator|--
name|addcount
operator|>=
literal|0
condition|;
name|ap
operator|++
control|)
block|{
name|freestr
argument_list|(
name|ap
operator|->
name|a_dname
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|ap
operator|->
name|a_rname
argument_list|)
expr_stmt|;
block|}
name|addcount
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_nsp
parameter_list|(
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
parameter_list|)
block|{
while|while
condition|(
operator|*
name|nsp
condition|)
block|{
name|DRCNTDEC
argument_list|(
operator|*
name|nsp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"free_nsp: %s rcnt %d"
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
argument_list|)
expr_stmt|;
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"free_nsp: %s rcnt %d delayed"
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_data
argument_list|,
operator|(
operator|*
name|nsp
operator|)
operator|->
name|d_rcnt
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
operator|*
name|nsp
argument_list|)
expr_stmt|;
comment|/* delayed free */
block|}
operator|*
name|nsp
operator|++
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|copyCharString
parameter_list|(
name|u_char
modifier|*
modifier|*
name|dst
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|src
argument_list|)
operator|&
literal|0xff
decl_stmt|;
operator|*
operator|(
operator|*
name|dst
operator|)
operator|++
operator|=
operator|(
name|u_char
operator|)
name|len
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|+=
name|len
expr_stmt|;
block|}
end_function

end_unit

