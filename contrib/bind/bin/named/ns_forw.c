begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_forw.c	4.32 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_forw.c,v 8.78 2000/12/23 08:14:37 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_struct
struct|struct
name|complaint
block|{
name|u_long
name|tag1
decl_stmt|,
name|tag2
decl_stmt|;
name|time_t
name|expire
decl_stmt|;
name|struct
name|complaint
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|complaint
modifier|*
name|complaints
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|retry_timer_set
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Forward the query to get the answer since its not in the database.  * Returns FW_OK if a request struct is allocated and the query sent.  * Returns FW_DUP if this is a duplicate of a pending request.   * Returns FW_NOSERVER if there were no addresses for the nameservers.  * Returns FW_SERVFAIL on memory allocation error or if asked to do something  *	dangerous, such as fwd to ourselves or fwd to the host that asked us.  *  * (no action is taken on errors and qpp is not filled in.)  */
end_comment

begin_function
name|int
name|ns_forw
parameter_list|(
name|struct
name|databuf
modifier|*
name|nsp
index|[]
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|int
name|dfd
parameter_list|,
name|struct
name|qinfo
modifier|*
modifier|*
name|qpp
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|int
name|use_tcp
parameter_list|,
name|struct
name|tsig_record
modifier|*
name|in_tsig
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|char
name|tmpdomain
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_int16_t
name|id
decl_stmt|;
name|int
name|sendto_errno
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|has_tsig
decl_stmt|,
name|oldqlen
decl_stmt|;
name|u_char
modifier|*
name|oldqbuf
decl_stmt|;
name|u_char
modifier|*
name|smsg
decl_stmt|;
name|int
name|smsglen
decl_stmt|,
name|smsgsize
decl_stmt|,
name|siglen
decl_stmt|;
name|u_char
name|sig
index|[
name|TSIG_SIG_SIZE
index|]
decl_stmt|;
name|DST_KEY
modifier|*
name|key
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ns_forw()"
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
name|id
operator|=
name|hp
operator|->
name|id
expr_stmt|;
comment|/* Look at them all */
for|for
control|(
name|qp
operator|=
name|nsqhead
init|;
name|qp
operator|!=
name|NULL
condition|;
name|qp
operator|=
name|qp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_id
operator|==
name|id
operator|&&
name|memcmp
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|,
operator|&
name|from
argument_list|,
sizeof|sizeof
name|qp
operator|->
name|q_from
argument_list|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|qp
operator|->
name|q_cmsglen
operator|==
literal|0
operator|&&
name|qp
operator|->
name|q_msglen
operator|==
name|msglen
operator|&&
name|memcmp
argument_list|(
name|qp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|msg
operator|+
literal|2
argument_list|,
name|msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|qp
operator|->
name|q_cmsglen
operator|==
name|msglen
operator|&&
name|memcmp
argument_list|(
name|qp
operator|->
name|q_cmsg
operator|+
literal|2
argument_list|,
name|msg
operator|+
literal|2
argument_list|,
name|msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"forw: dropped DUP id=%d"
argument_list|,
name|ntohs
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdDupQ
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_DUP
operator|)
return|;
block|}
block|}
name|qp
operator|=
name|qnew
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|tmpdomain
argument_list|,
sizeof|sizeof
name|tmpdomain
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_domain
operator|=
name|savestr
argument_list|(
name|tmpdomain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_from
operator|=
name|from
expr_stmt|;
comment|/* nslookup wants to know this */
if|if
condition|(
name|NS_ZFWDTAB
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|)
condition|)
name|nsfwdadd
argument_list|(
name|qp
argument_list|,
name|NS_ZFWDTAB
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_ZOPTION_P
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|,
name|OPTION_FORWARD_ONLY
argument_list|)
condition|)
name|n
operator|=
literal|0
expr_stmt|;
else|else
name|n
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"ns_forw"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"forw: nslookup reports danger"
argument_list|)
expr_stmt|;
name|ns_freeqry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_SERVFAIL
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|!
name|NS_ZFWDTAB
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"forw: no nameservers found"
argument_list|)
expr_stmt|;
name|ns_freeqry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_NOSERVER
operator|)
return|;
block|}
name|qp
operator|->
name|q_stream
operator|=
name|qsp
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_dfd
operator|=
name|dfd
expr_stmt|;
name|qp
operator|->
name|q_id
operator|=
name|id
expr_stmt|;
name|qp
operator|->
name|q_expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|RETRY_TIMEOUT
operator|*
literal|2
expr_stmt|;
if|if
condition|(
name|in_tsig
operator|!=
name|NULL
condition|)
name|qp
operator|->
name|q_tsig
operator|=
name|new_tsig
argument_list|(
name|in_tsig
operator|->
name|key
argument_list|,
name|in_tsig
operator|->
name|sig
argument_list|,
name|in_tsig
operator|->
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_tcp
condition|)
name|qp
operator|->
name|q_flags
operator||=
name|Q_USEVC
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
operator|(
name|unsigned
operator|)
name|msglen
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"forw: memget: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|ns_freeqry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|FW_SERVFAIL
operator|)
return|;
block|}
name|qp
operator|->
name|q_msgsize
operator|=
name|msglen
expr_stmt|;
name|memcpy
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|msg
argument_list|,
name|qp
operator|->
name|q_msglen
operator|=
name|msglen
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|forwarder
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"forw: forw -> [%s].%d ds=%d nsid=%d id=%d %dms retry %dsec"
argument_list|,
name|inet_ntoa
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|nsa
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ds
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|,
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|!=
name|NULL
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|-
literal|1
argument_list|,
call|(
name|int
call|)
argument_list|(
name|qp
operator|->
name|q_time
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|key
operator|=
name|tsig_key_from_addr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|smsgsize
operator|=
name|qp
operator|->
name|q_msglen
operator|+
name|TSIG_BUF_SIZE
expr_stmt|;
name|smsg
operator|=
name|memget
argument_list|(
name|smsgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|smsg
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"ns_forw: memget failed"
argument_list|)
expr_stmt|;
name|smsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|smsg
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_sign
argument_list|(
name|smsg
argument_list|,
operator|&
name|smsglen
argument_list|,
name|smsgsize
argument_list|,
name|NOERROR
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|oldqbuf
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|oldqlen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|smsglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|smsg
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|has_tsig
operator|=
literal|1
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|new_tsig
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_USEVC
condition|)
block|{
if|if
condition|(
name|tcp_send
argument_list|(
name|qp
argument_list|)
operator|!=
name|NOERROR
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|tcpsendStr
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_forw: tcp_send(%s) failed: %s"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sendto_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|sendtoStr
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_forw: sendto(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_tsig
operator|==
literal|1
condition|)
block|{
name|memput
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|smsgsize
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|oldqbuf
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|oldqlen
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFwdQ
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentFwdQ
argument_list|)
expr_stmt|;
if|if
condition|(
name|qpp
condition|)
operator|*
name|qpp
operator|=
name|qp
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|sendto_errno
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* haveComplained(tag1, tag2)  *	check to see if we have complained about (tag1,tag2) recently  * returns:  *	boolean: have we complained recently?  * side-effects:  *	outdated complaint records removed from our static list  * author:  *	Paul Vixie (DECWRL) April 1991  */
end_comment

begin_function
name|int
name|haveComplained
parameter_list|(
name|u_long
name|tag1
parameter_list|,
name|u_long
name|tag2
parameter_list|)
block|{
name|struct
name|complaint
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|int
name|r
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|complaints
operator|,
name|prev
operator|=
name|NULL
init|;
name|cur
operator|!=
name|NULL
condition|;
name|prev
operator|=
name|cur
operator|,
name|cur
operator|=
name|next
control|)
block|{
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|tt
operator|.
name|tv_sec
operator|>
name|cur
operator|->
name|expire
condition|)
block|{
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|next
expr_stmt|;
else|else
name|complaints
operator|=
name|next
expr_stmt|;
name|memput
argument_list|(
name|cur
argument_list|,
sizeof|sizeof
expr|*
name|cur
argument_list|)
expr_stmt|;
name|cur
operator|=
name|prev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tag1
operator|==
name|cur
operator|->
name|tag1
operator|&&
name|tag2
operator|==
name|cur
operator|->
name|tag2
condition|)
name|r
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|r
condition|)
block|{
name|cur
operator|=
operator|(
expr|struct
name|complaint
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|complaint
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cur
condition|)
block|{
name|cur
operator|->
name|tag1
operator|=
name|tag1
expr_stmt|;
name|cur
operator|->
name|tag2
operator|=
name|tag2
expr_stmt|;
name|cur
operator|->
name|expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|INIT_REFRESH
expr_stmt|;
comment|/* "10:00" */
name|cur
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|cur
expr_stmt|;
else|else
name|complaints
operator|=
name|cur
expr_stmt|;
block|}
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_function
name|void
name|freeComplaints
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|complaint
modifier|*
name|cur
decl_stmt|,
modifier|*
name|next
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|complaints
init|;
name|cur
operator|!=
name|NULL
condition|;
name|cur
operator|=
name|next
control|)
block|{
name|next
operator|=
name|cur
operator|->
name|next
expr_stmt|;
name|memput
argument_list|(
name|cur
argument_list|,
sizeof|sizeof
expr|*
name|cur
argument_list|)
expr_stmt|;
block|}
name|complaints
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* void  * nslookupComplain(sysloginfo, queryname, complaint, dname, a_rr)  *	Issue a complaint about a dangerous situation found by nslookup().  * params:  *	sysloginfo is a string identifying the complainant.  *	queryname is the domain name associated with the problem.  *	complaint is a string describing what is wrong.  *	dname and a_rr are the problematic other name server.  */
end_comment

begin_function
specifier|static
name|void
name|nslookupComplain
parameter_list|(
specifier|const
name|char
modifier|*
name|sysloginfo
parameter_list|,
specifier|const
name|char
modifier|*
name|queryname
parameter_list|,
specifier|const
name|char
modifier|*
name|complaint
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
specifier|const
name|struct
name|databuf
modifier|*
name|a_rr
parameter_list|,
specifier|const
name|struct
name|databuf
modifier|*
name|nsdp
parameter_list|)
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|ns
decl_stmt|;
specifier|const
name|char
modifier|*
name|a_type
decl_stmt|;
name|int
name|print_a
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"NS '%s' %s"
argument_list|,
name|dname
argument_list|,
name|complaint
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysloginfo
operator|&&
name|queryname
operator|&&
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|queryname
argument_list|,
operator|(
name|u_long
operator|)
name|complaint
argument_list|)
condition|)
block|{
name|char
name|nsbuf
index|[
literal|20
index|]
decl_stmt|,
name|abuf
index|[
literal|20
index|]
decl_stmt|;
name|a
operator|=
name|ns
operator|=
operator|(
name|char
operator|*
operator|)
name|NULL
expr_stmt|;
name|print_a
operator|=
operator|(
name|a_rr
operator|->
name|d_type
operator|==
name|T_A
operator|)
expr_stmt|;
name|a_type
operator|=
name|p_type
argument_list|(
name|a_rr
operator|->
name|d_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|a_rr
operator|->
name|d_rcode
condition|)
block|{
name|print_a
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|a_rr
operator|->
name|d_rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
name|a_type
operator|=
literal|"NXDOMAIN"
expr_stmt|;
break|break;
case|case
name|NOERROR_NODATA
case|:
name|a_type
operator|=
literal|"NODATA"
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|nsdp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nsdp
operator|->
name|d_addr
operator|.
name|s_addr
operator|!=
name|htonl
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|nsbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|nsdp
operator|->
name|d_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|nsbuf
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|zones
index|[
name|nsdp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
block|}
if|if
condition|(
name|a_rr
operator|->
name|d_addr
operator|.
name|s_addr
operator|!=
name|htonl
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|abuf
argument_list|,
name|inet_ntoa
argument_list|(
name|a_rr
operator|->
name|d_addr
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|abuf
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|zones
index|[
name|a_rr
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
if|if
condition|(
name|a
operator|!=
name|NULL
operator|||
name|ns
operator|!=
name|NULL
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"%s: query(%s) %s (%s:%s) learnt (%s=%s:NS=%s)"
argument_list|,
name|sysloginfo
argument_list|,
name|queryname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|print_a
condition|?
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
name|a_rr
operator|->
name|d_data
argument_list|)
argument_list|)
else|:
literal|""
argument_list|,
name|a_type
argument_list|,
name|a
condition|?
name|a
else|:
literal|"<Not Available>"
argument_list|,
name|ns
condition|?
name|ns
else|:
literal|"<Not Available>"
argument_list|)
expr_stmt|;
else|else
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"%s: query(%s) %s (%s:%s)"
argument_list|,
name|sysloginfo
argument_list|,
name|queryname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|print_a
condition|?
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
name|a_rr
operator|->
name|d_data
argument_list|)
argument_list|)
else|:
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * nslookup(nsp, qp, syslogdname, sysloginfo)  *	Lookup the address for each nameserver in `nsp' and add it to  * 	the list saved in the qinfo structure pointed to by `qp'.  *	Omits information about nameservers that we shouldn't ask.  *	Detects the following dangerous operations:  *		One of the A records for one of the nameservers in nsp  *		refers to the address of one of our own interfaces;  *		One of the A records refers to the nameserver port on  *		the host that asked us this question.  * returns: the number of addresses added, or -1 if a dangerous operation  *	is detected.  * side effects:  *	logs if a dangerous situation is detected and  *	(syslogdname&& sysloginfo)  */
end_comment

begin_function
name|int
name|nslookup
parameter_list|(
name|struct
name|databuf
modifier|*
name|nsp
index|[]
parameter_list|,
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
specifier|const
name|char
modifier|*
name|syslogdname
parameter_list|,
specifier|const
name|char
modifier|*
name|sysloginfo
parameter_list|)
block|{
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|nsdp
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
name|int
name|n
decl_stmt|;
name|u_int
name|i
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|tmphtp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|oldn
decl_stmt|,
name|naddr
decl_stmt|,
name|class
decl_stmt|,
name|found_arr
decl_stmt|,
name|potential_ns
decl_stmt|,
name|lame_ns
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"nslookup(nsp=%#x, qp=%#x, \"%s\")"
argument_list|,
name|nsp
argument_list|,
name|qp
argument_list|,
name|syslogdname
argument_list|)
expr_stmt|;
name|lame_ns
operator|=
name|potential_ns
operator|=
literal|0
expr_stmt|;
name|naddr
operator|=
name|n
operator|=
name|qp
operator|->
name|q_naddr
expr_stmt|;
name|curtime
operator|=
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
while|while
condition|(
operator|(
name|nsdp
operator|=
operator|*
name|nsp
operator|++
operator|)
operator|!=
name|NULL
operator|&&
name|n
operator|<
name|NSMAX
condition|)
block|{
name|class
operator|=
name|nsdp
operator|->
name|d_class
expr_stmt|;
name|dname
operator|=
operator|(
name|char
operator|*
operator|)
name|nsdp
operator|->
name|d_data
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"nslookup: NS \"%s\" c=%d t=%d (flags 0x%lu)"
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|nsdp
operator|->
name|d_type
argument_list|,
operator|(
name|u_long
operator|)
name|nsdp
operator|->
name|d_flags
argument_list|)
expr_stmt|;
comment|/* don't put in servers we have tried */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|qp
operator|->
name|q_nusedns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_usedns
index|[
name|i
index|]
operator|==
name|nsdp
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"skipping used NS w/name %s"
argument_list|,
name|nsdp
operator|->
name|d_data
argument_list|)
expr_stmt|;
goto|goto
name|skipserver
goto|;
block|}
block|}
comment|/* skip lame servers */
if|if
condition|(
operator|(
name|nsdp
operator|->
name|d_flags
operator|&
name|DB_F_LAME
operator|)
operator|!=
literal|0
condition|)
block|{
name|time_t
name|when
decl_stmt|;
name|when
operator|=
name|db_lame_find
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|when
operator|!=
literal|0
operator|&&
name|when
operator|>
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"skipping lame NS"
argument_list|)
expr_stmt|;
name|lame_ns
operator|++
expr_stmt|;
goto|goto
name|skipserver
goto|;
block|}
block|}
name|tmphtp
operator|=
operator|(
operator|(
name|nsdp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|?
name|fcachetab
else|:
name|hashtab
operator|)
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|tmphtp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"%s: not found %s %#x"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
goto|goto
name|need_sysquery
goto|;
block|}
if|if
condition|(
name|fname
operator|!=
name|dname
condition|)
block|{
name|found_arr
operator|=
literal|0
expr_stmt|;
goto|goto
name|need_sysquery
goto|;
block|}
name|found_arr
operator|=
literal|0
expr_stmt|;
name|oldn
operator|=
name|n
expr_stmt|;
comment|/* look for name server addresses */
operator|(
name|void
operator|)
name|delete_stale
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
name|struct
name|in_addr
name|nsa
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
operator|&&
name|dp
operator|->
name|d_class
operator|==
name|class
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|complaint
init|=
literal|"NS points to CNAME"
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
goto|goto
name|skipserver
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|dp
operator|->
name|d_class
operator|!=
name|class
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
block|{
comment|/* Negative caching element. */
goto|goto
name|skipserver
goto|;
block|}
if|if
condition|(
name|ina_hlong
argument_list|(
name|ina_get
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
argument_list|)
operator|==
name|INADDR_ANY
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|complaint
init|=
literal|"Bogus (0.0.0.0) A RR"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|INADDR_LOOPBACK
if|if
condition|(
name|ina_hlong
argument_list|(
name|ina_get
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
argument_list|)
operator|==
name|INADDR_LOOPBACK
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|complaint
init|=
literal|"Bogus LOOPBACK A RR"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|INADDR_BROADCAST
if|if
condition|(
name|ina_hlong
argument_list|(
name|ina_get
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
argument_list|)
operator|==
name|INADDR_BROADCAST
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|complaint
init|=
literal|"Bogus BROADCAST A RR"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|IN_MULTICAST
if|if
condition|(
name|IN_MULTICAST
argument_list|(
name|ina_hlong
argument_list|(
name|ina_get
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|complaint
init|=
literal|"Bogus MULTICAST A RR"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* 			 * Don't use records that may become invalid to 			 * reference later when we do the rtt computation. 			 * Never delete our safety-belt information! 			 */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|u_int32_t
operator|)
name|curtime
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"nslookup: stale '%s'"
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|oldn
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
goto|goto
name|need_sysquery
goto|;
block|}
name|found_arr
operator|++
expr_stmt|;
name|nsa
operator|=
name|ina_get
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
comment|/* don't put in duplicates */
name|qs
operator|=
name|qp
operator|->
name|q_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_int
operator|)
name|n
condition|;
name|i
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|nsa
argument_list|)
condition|)
goto|goto
name|skipaddr
goto|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_port
operator|=
name|ns_port
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|=
name|nsa
expr_stmt|;
name|qs
operator|->
name|ns
operator|=
name|nsdp
expr_stmt|;
name|qs
operator|->
name|nsdata
operator|=
name|dp
expr_stmt|;
name|qs
operator|->
name|forwarder
operator|=
literal|0
expr_stmt|;
name|qs
operator|->
name|nretry
operator|=
literal|0
expr_stmt|;
comment|/* 			 * If this A RR has no RTT, initialize its RTT to a 			 * small random value. 			 */
if|if
condition|(
name|dp
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|dp
operator|->
name|d_nstime
operator|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
literal|25.0
operator|*
name|rand
argument_list|()
operator|/
operator|(
name|RAND_MAX
operator|+
literal|1.0
operator|)
argument_list|)
expr_stmt|;
comment|/* 			 * if we are being asked to fwd a query whose 			 * nameserver list includes our own name/address(es), 			 * then we have detected a lame delegation and rather 			 * than melt down the network and hose down the other 			 * servers (who will hose us in return), we'll return 			 * -1 here which will cause SERVFAIL to be sent to 			 * the client's resolver which will hopefully then 			 * shut up. 			 * 			 * (originally done in nsContainsUs by vix@dec mar92; 			 * moved into nslookup by apb@und jan1993) 			 * 			 * try to limp along instead of denying service 			 * gdonl mar96 			 */
if|if
condition|(
name|aIsUs
argument_list|(
name|nsa
argument_list|)
condition|)
block|{
specifier|static
name|char
modifier|*
name|complaint
init|=
literal|"contains our address"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we want to forward to a host that asked us 			 * this question then either we or they are sick 			 * (unless they asked from some port other than 			 * their nameserver port).  (apb@und jan1993) 			 * 			 * try to limp along instead of denying service 			 * gdonl mar96 			 */
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|qp
operator|->
name|q_from
argument_list|,
operator|&
name|qs
operator|->
name|ns_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|static
name|char
modifier|*
name|complaint
init|=
literal|"forwarding loop"
decl_stmt|;
name|nslookupComplain
argument_list|(
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|,
name|dname
argument_list|,
name|dp
argument_list|,
name|nsdp
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|BOGUSNS
comment|/* 			 * Don't forward queries to bogus servers.  Note 			 * that this is unlike the previous tests, which 			 * are fatal to the query.  Here we just skip the 			 * server, which is only fatal if it's the last 			 * server.  Note also that we antialias here -- all 			 * A RR's of a server are considered the same server, 			 * and if any of them is bogus we skip the whole 			 * server.  Those of you using multiple A RR's to 			 * load-balance your servers will (rightfully) lose 			 * here.  But (unfortunately) only if they are bogus. 			 */
if|if
condition|(
name|ip_match_address
argument_list|(
name|bogus_nameservers
argument_list|,
name|nsa
argument_list|)
operator|>
literal|0
condition|)
goto|goto
name|skipserver
goto|;
endif|#
directive|endif
if|if
condition|(
name|server_options
operator|->
name|blackhole_acl
operator|!=
name|NULL
operator|&&
name|ip_match_address
argument_list|(
name|server_options
operator|->
name|blackhole_acl
argument_list|,
name|nsa
argument_list|)
operator|==
literal|1
condition|)
continue|continue;
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|>=
name|NSMAX
condition|)
break|break;
name|skipaddr
label|:
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|8
argument_list|,
literal|"nslookup: %d ns addrs"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|need_sysquery
label|:
if|if
condition|(
name|found_arr
operator|==
literal|0
condition|)
block|{
name|potential_ns
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|)
operator|(
name|void
operator|)
name|sysquery
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ns_port
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
name|skipserver
label|:
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"nslookup: %d ns addrs total"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_naddr
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|potential_ns
operator|==
literal|0
operator|&&
operator|!
name|NS_ZFWDTAB
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|)
condition|)
block|{
specifier|static
name|char
modifier|*
name|complaint
init|=
literal|"No possible A RRs"
decl_stmt|;
if|if
condition|(
name|lame_ns
operator|!=
literal|0
condition|)
name|complaint
operator|=
literal|"All possible A RR's lame"
expr_stmt|;
if|if
condition|(
name|sysloginfo
operator|&&
name|syslogdname
operator|&&
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|syslogdname
argument_list|,
operator|(
name|u_long
operator|)
name|complaint
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"%s: query(%s) %s"
argument_list|,
name|sysloginfo
argument_list|,
name|syslogdname
argument_list|,
name|complaint
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|lame_ns
operator|==
literal|0
operator|)
condition|?
operator|-
literal|1
else|:
operator|-
literal|2
operator|)
return|;
block|}
comment|/* Update the refcounts before the sort. */
for|for
control|(
name|i
operator|=
name|naddr
init|;
name|i
operator|<
operator|(
name|u_int
operator|)
name|n
condition|;
name|i
operator|++
control|)
block|{
name|DRCNTINC
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
argument_list|)
expr_stmt|;
name|DRCNTINC
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
argument_list|)
expr_stmt|;
block|}
comment|/* Just sort the NS RR's we added, since the forwarders may 	 * be ahead of us (naddr> 0) 	 */
if|if
condition|(
name|n
operator|>
name|naddr
condition|)
block|{
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_addr
operator|+
name|naddr
operator|)
argument_list|,
name|n
operator|-
name|naddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qserv
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|qcomp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|-
name|naddr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * qcomp - compare two NS addresses, and return a negative, zero, or  *	   positive value depending on whether the first NS address is  *	   "better than", "equally good as", or "inferior to" the second  *	   NS address.  *  * How "goodness" is defined (for the purposes of this routine):  *  - If the estimated round trip times differ by an amount deemed significant  *    then the one with the smaller estimate is preferred; else  *  - If we can determine which one is topologically closer then the  *    closer one is preferred; else  *  - The one with the smaller estimated round trip time is preferred  *    (zero is returned if the two estimates are identical).  *  * How "topological closeness" is defined (for the purposes of this routine):  *    Ideally, named could consult some magic map of the Internet and  *    determine the length of the path to an arbitrary destination.  Sadly,  *    no such magic map exists.  However, named does have a little bit of  *    topological information in the form of the sortlist (which includes  *    the directly connected subnet(s), the directly connected net(s), and  *    any additional nets that the administrator has added using the "sortlist"  *    directive in the bootfile.  Thus, if only one of the addresses matches  *    something in the sortlist then it is considered to be topologically  *    closer.  If both match, but match different entries in the sortlist,  *    then the one that matches the entry closer to the beginning of the  *    sorlist is considered to be topologically closer.  In all other cases,  *    topological closeness is ignored because it's either indeterminate or  *    equal.  *  * How times are compared:  *    Both times are rounded to the closest multiple of the NOISE constant  *    defined below and then compared.  If the rounded values are equal  *    then the difference in the times is deemed insignificant.  Rounding  *    is used instead of merely taking the absolute value of the difference  *    because doing the latter would make the ordering defined by this  *    routine be incomplete in the mathematical sense (e.g. A> B and  *    B> C would not imply A> C).  The mathematics are important in  *    practice to avoid core dumps in qsort().  *  * XXX: this doesn't solve the European root nameserver problem very well.  * XXX: we should detect and mark as inferior nameservers that give bogus  *      answers  *  * (this was originally vixie's stuff but almquist fixed fatal bugs in it  * and wrote the above documentation)  */
end_comment

begin_comment
comment|/*  * RTT delta deemed to be significant, in milliseconds.  With the current  * definition of RTTROUND it must be a power of 2.  */
end_comment

begin_define
define|#
directive|define
name|NOISE
value|64
end_define

begin_define
define|#
directive|define
name|RTTROUND
parameter_list|(
name|rtt
parameter_list|)
value|(((rtt) + (NOISE>> 1))& ~(NOISE - 1))
end_define

begin_function
name|int
name|qcomp
parameter_list|(
name|struct
name|qserv
modifier|*
name|qs1
parameter_list|,
name|struct
name|qserv
modifier|*
name|qs2
parameter_list|)
block|{
name|u_int
name|rtt1
decl_stmt|,
name|rtt2
decl_stmt|,
name|rttr1
decl_stmt|,
name|rttr2
decl_stmt|;
if|if
condition|(
name|qs1
operator|->
name|nsdata
operator|==
name|NULL
condition|)
block|{
name|rtt1
operator|=
literal|0
expr_stmt|;
name|rttr1
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rtt1
operator|=
name|qs1
operator|->
name|nsdata
operator|->
name|d_nstime
expr_stmt|;
name|rttr1
operator|=
name|RTTROUND
argument_list|(
name|rtt1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qs2
operator|->
name|nsdata
operator|==
name|NULL
condition|)
block|{
name|rtt2
operator|=
literal|0
expr_stmt|;
name|rttr2
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|rtt2
operator|=
name|qs2
operator|->
name|nsdata
operator|->
name|d_nstime
expr_stmt|;
name|rttr2
operator|=
name|RTTROUND
argument_list|(
name|rtt2
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
block|{
name|char
name|t
index|[
sizeof|sizeof
expr|"255.255.255.255"]
expr_stmt|;
name|strcpy
argument_list|(
name|t
argument_list|,
name|inet_ntoa
argument_list|(
name|qs1
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|10
argument_list|,
literal|"qcomp(%s, %s) %lu (%lu) - %lu (%lu) = %lu"
argument_list|,
name|t
argument_list|,
name|inet_ntoa
argument_list|(
name|qs2
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|rtt1
argument_list|,
name|rttr1
argument_list|,
name|rtt2
argument_list|,
name|rttr2
argument_list|,
name|rtt1
operator|-
name|rtt2
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|rttr1
operator|==
name|rttr2
condition|)
block|{
name|int
name|pos1
decl_stmt|,
name|pos2
decl_stmt|,
name|pdiff
decl_stmt|;
name|pos1
operator|=
name|distance_of_address
argument_list|(
name|server_options
operator|->
name|topology
argument_list|,
name|qs1
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
name|pos2
operator|=
name|distance_of_address
argument_list|(
name|server_options
operator|->
name|topology
argument_list|,
name|qs2
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
name|pdiff
operator|=
name|pos1
operator|-
name|pos2
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|10
argument_list|,
literal|"\tpos1=%d, pos2=%d"
argument_list|,
name|pos1
argument_list|,
name|pos2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdiff
operator|!=
literal|0
condition|)
return|return
operator|(
name|pdiff
operator|)
return|;
block|}
return|return
operator|(
name|rtt1
operator|-
name|rtt2
operator|)
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|RTTROUND
end_undef

begin_comment
comment|/*  * Arrange that forwarded query (qp) is retried after t seconds.  * Query list will be sorted after z_time is updated.  */
end_comment

begin_function
name|void
name|schedretry
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|time_t
name|t
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|qp1
decl_stmt|,
modifier|*
name|qp2
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"schedretry(%#x, %ld sec)"
argument_list|,
name|qp
argument_list|,
operator|(
name|long
operator|)
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_time
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"WARNING: schedretry(%#lx, %ld) q_time already %ld"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
operator|(
name|long
operator|)
name|t
argument_list|,
operator|(
name|long
operator|)
name|qp
operator|->
name|q_time
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|t
operator|+=
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|qp
operator|->
name|q_time
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|(
name|qp1
operator|=
name|retryqp
operator|)
operator|==
name|NULL
condition|)
block|{
name|retryqp
operator|=
name|qp
expr_stmt|;
name|qp
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|t
operator|<
name|qp1
operator|->
name|q_time
condition|)
block|{
name|qp
operator|->
name|q_next
operator|=
name|qp1
expr_stmt|;
name|retryqp
operator|=
name|qp
expr_stmt|;
goto|goto
name|done
goto|;
block|}
while|while
condition|(
operator|(
name|qp2
operator|=
name|qp1
operator|->
name|q_next
operator|)
operator|!=
name|NULL
operator|&&
name|qp2
operator|->
name|q_time
operator|<
name|t
condition|)
name|qp1
operator|=
name|qp2
expr_stmt|;
name|qp1
operator|->
name|q_next
operator|=
name|qp
expr_stmt|;
name|qp
operator|->
name|q_next
operator|=
name|qp2
expr_stmt|;
name|done
label|:
name|reset_retrytimer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Unsched is called to remove a forwarded query entry.  */
end_comment

begin_function
name|void
name|unsched
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|np
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"unsched(%#lx, %d)"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retryqp
operator|==
name|qp
condition|)
block|{
name|retryqp
operator|=
name|qp
operator|->
name|q_next
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|np
operator|=
name|retryqp
init|;
name|np
operator|->
name|q_next
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|q_next
control|)
block|{
if|if
condition|(
name|np
operator|->
name|q_next
operator|!=
name|qp
condition|)
continue|continue;
name|np
operator|->
name|q_next
operator|=
name|qp
operator|->
name|q_next
expr_stmt|;
comment|/* dequeue */
break|break;
block|}
block|}
name|qp
operator|->
name|q_next
operator|=
name|NULL
expr_stmt|;
comment|/* sanity check */
name|qp
operator|->
name|q_time
operator|=
literal|0
expr_stmt|;
name|reset_retrytimer
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|reset_retrytimer
parameter_list|()
block|{
specifier|static
name|evTimerID
name|id
decl_stmt|;
if|if
condition|(
name|retry_timer_set
condition|)
block|{
operator|(
name|void
operator|)
name|evClearTimer
argument_list|(
name|ev
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|retry_timer_set
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|retryqp
condition|)
block|{
name|evSetTimer
argument_list|(
name|ev
argument_list|,
name|retrytimer
argument_list|,
name|NULL
argument_list|,
name|evConsTime
argument_list|(
name|retryqp
operator|->
name|q_time
argument_list|,
literal|0
argument_list|)
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
name|retry_timer_set
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|memset
argument_list|(
operator|&
name|id
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|retrytimer
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|ival
parameter_list|)
block|{
name|retry_timer_set
operator|=
literal|0
expr_stmt|;
name|retry
argument_list|(
name|retryqp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Retry is called to retransmit query 'qp'.  */
end_comment

begin_function
name|void
name|retry
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|has_tsig
decl_stmt|,
name|oldqlen
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
name|int
name|sendto_errno
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|oldqbuf
decl_stmt|;
name|u_char
modifier|*
name|smsg
decl_stmt|;
name|int
name|smsglen
decl_stmt|,
name|smsgsize
decl_stmt|,
name|siglen
decl_stmt|;
name|u_char
name|sig
index|[
name|TSIG_SIG_SIZE
index|]
decl_stmt|;
name|DST_KEY
modifier|*
name|key
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"retry(%#lx) id=%d"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|==
name|NULL
condition|)
block|{
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qp
operator|->
name|q_expire
operator|<
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"retry(%#lx): expired @ %lu (%d secs before now (%lu))"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_expire
argument_list|,
call|(
name|int
call|)
argument_list|(
name|tt
operator|.
name|tv_sec
operator|-
name|qp
operator|->
name|q_expire
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
goto|goto
name|fail
goto|;
block|}
comment|/* Try next address. */
name|n
operator|=
name|qp
operator|->
name|q_curaddr
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_naddr
operator|>
literal|0
condition|)
block|{
operator|++
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|++
name|n
operator|>=
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|)
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
operator|!=
literal|0
operator|&&
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|serial
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
operator|<
name|MAXRETRY
condition|)
goto|goto
name|found
goto|;
block|}
do|while
condition|(
name|n
operator|!=
name|qp
operator|->
name|q_curaddr
condition|)
do|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
operator|!=
literal|0
condition|)
block|{
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|fail
label|:
comment|/* 	 * Give up. Can't reach destination. 	 */
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_cmsg
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Can't give up priming */
if|if
condition|(
name|qp
operator|->
name|q_expire
operator|<
name|tt
operator|.
name|tv_sec
condition|)
block|{
comment|/* 			 * The query has expired.  Reset it and retry from 			 * the beginning. 			 */
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
name|hp
operator|->
name|aa
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
operator|=
literal|0
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|RETRY_TIMEOUT
operator|*
literal|2
expr_stmt|;
goto|goto
name|found
goto|;
block|}
comment|/* 		 * The query hasn't expired yet; it probably ran out 		 * of servers or forwarders.  Wait up to 60 seconds 		 * past the expire time. 		 */
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
call|(
name|time_t
call|)
argument_list|(
name|qp
operator|->
name|q_expire
operator|-
name|tt
operator|.
name|tv_sec
operator|+
literal|60
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"give up"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
operator|==
literal|0
condition|)
block|{
name|n
operator|=
operator|(
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_cmsg
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|n
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|send_msg
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|hp
argument_list|,
name|n
argument_list|,
name|qp
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"gave up retry(%#lx) nsid=%d id=%d"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_HOSTSTATS
argument_list|)
condition|)
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFail
argument_list|)
expr_stmt|;
block|}
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
name|found
label|:
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
operator|==
literal|0
condition|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|forwarder
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"%s(addr=%d n=%d) -> [%s].%d ds=%d nsid=%d id=%d %dms"
argument_list|,
operator|(
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|forwarder
condition|?
literal|"reforw"
else|:
literal|"resend"
operator|)
argument_list|,
name|n
argument_list|,
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nretry
argument_list|,
name|inet_ntoa
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|nsa
operator|->
name|sin_port
argument_list|)
argument_list|,
name|ds
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|,
operator|(
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nsdata
operator|!=
literal|0
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|(
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|key
operator|=
name|tsig_key_from_addr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|smsgsize
operator|=
name|qp
operator|->
name|q_msglen
operator|+
name|TSIG_BUF_SIZE
expr_stmt|;
name|smsg
operator|=
name|memget
argument_list|(
name|smsgsize
argument_list|)
expr_stmt|;
name|smsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|smsg
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_sign
argument_list|(
name|smsg
argument_list|,
operator|&
name|smsglen
argument_list|,
name|smsgsize
argument_list|,
name|NOERROR
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|oldqbuf
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|oldqlen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|smsglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|smsg
expr_stmt|;
name|has_tsig
operator|=
literal|1
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|new_tsig
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_USEVC
condition|)
block|{
if|if
condition|(
name|tcp_send
argument_list|(
name|qp
argument_list|)
operator|!=
name|NOERROR
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"error resending tcp msg: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sendto_errno
operator|=
name|errno
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"error resending msg: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_tsig
operator|==
literal|1
condition|)
block|{
name|memput
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|smsgsize
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|oldqbuf
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|oldqlen
expr_stmt|;
block|}
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
comment|/* leave set to 1 for dup detection */
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentDupQ
argument_list|)
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sendto_errno
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|schedretry
argument_list|(
name|qp
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute retry time for the next server for a query.  * Use a minimum time of RETRYBASE (4 sec.) or twice the estimated  * service time; * back off exponentially on retries, but place a 45-sec.  * ceiling on retry times for now.  (This is because we don't hold a reference  * on servers or their addresses, and we have to finish before they time out.)  */
end_comment

begin_function
name|time_t
name|retrytime
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|time_t
name|t
decl_stmt|,
name|u
decl_stmt|,
name|v
decl_stmt|;
name|struct
name|qserv
modifier|*
name|ns
init|=
operator|&
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
decl_stmt|;
if|if
condition|(
name|ns
operator|->
name|nsdata
operator|!=
name|NULL
condition|)
name|t
operator|=
operator|(
name|time_t
operator|)
name|MAX
argument_list|(
name|RETRYBASE
argument_list|,
literal|2
operator|*
name|ns
operator|->
name|nsdata
operator|->
name|d_nstime
operator|/
literal|1000
argument_list|)
expr_stmt|;
else|else
name|t
operator|=
operator|(
name|time_t
operator|)
name|RETRYBASE
expr_stmt|;
name|u
operator|=
name|t
operator|<<
name|ns
operator|->
name|nretry
expr_stmt|;
name|v
operator|=
name|MIN
argument_list|(
name|u
argument_list|,
name|RETRY_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* max. retry timeout for now */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"retrytime: nstime%ldms t%ld nretry%ld u%ld : v%ld"
argument_list|,
name|ns
operator|->
name|nsdata
condition|?
call|(
name|long
call|)
argument_list|(
name|ns
operator|->
name|nsdata
operator|->
name|d_nstime
operator|/
literal|1000
argument_list|)
else|:
operator|(
name|long
operator|)
operator|-
literal|1
argument_list|,
operator|(
name|long
operator|)
name|t
argument_list|,
operator|(
name|long
operator|)
name|ns
operator|->
name|nretry
argument_list|,
operator|(
name|long
operator|)
name|u
argument_list|,
operator|(
name|long
operator|)
name|v
argument_list|)
expr_stmt|;
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_function
name|void
name|qflush
parameter_list|()
block|{
while|while
condition|(
name|nsqhead
condition|)
name|qremove
argument_list|(
name|nsqhead
argument_list|)
expr_stmt|;
name|nsqhead
operator|=
name|NULL
expr_stmt|;
name|priming
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|qremove
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"qremove(%#lx)"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
operator|!=
literal|0
condition|)
name|qserial_answer
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|ns_freeqry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|qinfo
modifier|*
name|qfindid
parameter_list|(
name|u_int16_t
name|id
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
for|for
control|(
name|qp
operator|=
name|nsqhead
init|;
name|qp
operator|!=
name|NULL
condition|;
name|qp
operator|=
name|qp
operator|->
name|q_link
control|)
if|if
condition|(
name|qp
operator|->
name|q_nsid
operator|==
name|id
condition|)
break|break;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"qfindid(%d) -> %#lx"
argument_list|,
name|ntohs
argument_list|(
name|id
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|qinfo
modifier|*
name|qnew
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|forward
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|escape
init|=
literal|0
decl_stmt|;
name|qp
operator|=
operator|(
expr|struct
name|qinfo
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"qnew: memget failed"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|qp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"qnew(%#lx)"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|qp
operator|->
name|q_notifyzone
operator|=
name|DB_Z_CACHE
expr_stmt|;
endif|#
directive|endif
name|qp
operator|->
name|q_link
operator|=
name|nsqhead
expr_stmt|;
name|nsqhead
operator|=
name|qp
expr_stmt|;
name|qp
operator|->
name|q_name
operator|=
name|savestr
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_class
operator|=
operator|(
name|u_int16_t
operator|)
name|class
expr_stmt|;
name|qp
operator|->
name|q_type
operator|=
operator|(
name|u_int16_t
operator|)
name|type
expr_stmt|;
name|qp
operator|->
name|q_flags
operator|=
literal|0
expr_stmt|;
name|s
operator|=
name|name
expr_stmt|;
name|qp
operator|->
name|q_fzone
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|forward
condition|;
control|)
block|{
comment|/* find forwarding zone, if any */
if|if
condition|(
operator|(
name|qp
operator|->
name|q_fzone
operator|=
name|find_zone
argument_list|(
name|s
argument_list|,
name|class
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|qp
operator|->
name|q_fzone
operator|->
name|z_flags
operator|&
name|Z_FORWARD_SET
operator|)
operator|!=
literal|0
condition|)
break|break;
name|qp
operator|->
name|q_fzone
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
condition|)
break|break;
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|(
name|escape
operator|||
operator|*
name|s
operator|!=
literal|'.'
operator|)
condition|)
block|{
name|escape
operator|=
name|escape
condition|?
literal|0
else|:
operator|(
operator|*
name|s
operator|==
literal|'\\'
operator|)
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s
operator|!=
literal|'\0'
condition|)
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ns_freeqns
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|char
modifier|*
name|where
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|freed
index|[]
init|=
literal|"freed"
decl_stmt|,
name|busy
index|[]
init|=
literal|"busy"
decl_stmt|;
specifier|const
name|char
modifier|*
name|result
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
name|DRCNTDEC
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|dp
operator|->
name|d_rcnt
operator|)
condition|?
name|busy
else|:
name|freed
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"%s: ns %s rcnt %d (%s)"
argument_list|,
name|where
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|dp
operator|->
name|d_rcnt
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|freed
condition|)
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|dp
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
expr_stmt|;
if|if
condition|(
name|dp
condition|)
block|{
name|DRCNTDEC
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|dp
operator|->
name|d_rcnt
operator|)
condition|?
name|busy
else|:
name|freed
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"%s: nsdata %s rcnt %d (%s)"
argument_list|,
name|where
argument_list|,
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
argument_list|)
argument_list|,
name|dp
operator|->
name|d_rcnt
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|freed
condition|)
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|ns_freeqry
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|np
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ns_freeqry(%#lx)"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_next
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"WARNING: ns_freeqry of linked ptr %#lx"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_cmsg
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|qp
operator|->
name|q_cmsg
argument_list|,
name|qp
operator|->
name|q_cmsgsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_domain
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_name
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|qp
operator|->
name|q_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_tsig
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|qp
operator|->
name|q_tsig
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsig_record
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_nstsig
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|tsig_record
argument_list|)
argument_list|)
expr_stmt|;
name|ns_freeqns
argument_list|(
name|qp
argument_list|,
literal|"ns_freeqry"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nsqhead
operator|==
name|qp
condition|)
name|nsqhead
operator|=
name|qp
operator|->
name|q_link
expr_stmt|;
else|else
block|{
for|for
control|(
name|np
operator|=
name|nsqhead
init|;
name|np
operator|->
name|q_link
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|q_link
control|)
block|{
if|if
condition|(
name|np
operator|->
name|q_link
operator|!=
name|qp
condition|)
continue|continue;
name|np
operator|->
name|q_link
operator|=
name|qp
operator|->
name|q_link
expr_stmt|;
comment|/* dequeue */
break|break;
block|}
block|}
name|memput
argument_list|(
name|qp
argument_list|,
sizeof|sizeof
expr|*
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|nsfwdadd
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|fwdinfo
modifier|*
name|fwd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|n
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
name|n
operator|=
name|qp
operator|->
name|q_naddr
expr_stmt|;
while|while
condition|(
name|fwd
operator|!=
name|NULL
operator|&&
name|n
operator|<
name|NSMAX
condition|)
block|{
name|qs
operator|=
name|qp
operator|->
name|q_addr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|u_int
operator|)
name|n
condition|;
name|i
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|fwd
operator|->
name|fwddata
operator|->
name|fwdaddr
operator|.
name|sin_addr
argument_list|)
condition|)
goto|goto
name|nextfwd
goto|;
name|qs
operator|->
name|ns_addr
operator|=
name|fwd
operator|->
name|fwddata
operator|->
name|fwdaddr
expr_stmt|;
name|qs
operator|->
name|ns
operator|=
name|fwd
operator|->
name|fwddata
operator|->
name|ns
expr_stmt|;
name|qs
operator|->
name|nsdata
operator|=
name|fwd
operator|->
name|fwddata
operator|->
name|nsdata
expr_stmt|;
name|qs
operator|->
name|forwarder
operator|=
literal|1
expr_stmt|;
name|qs
operator|->
name|nretry
operator|=
literal|0
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|nextfwd
label|:
name|fwd
operator|=
name|fwd
operator|->
name|next
expr_stmt|;
block|}
comment|/* Update the refcounts before the sort. */
for|for
control|(
name|i
operator|=
name|qp
operator|->
name|q_naddr
init|;
name|i
operator|<
operator|(
name|u_int
operator|)
name|n
condition|;
name|i
operator|++
control|)
block|{
name|DRCNTINC
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
argument_list|)
expr_stmt|;
name|DRCNTINC
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
argument_list|)
expr_stmt|;
block|}
name|qp
operator|->
name|q_naddr
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|1
condition|)
block|{
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
argument_list|,
name|n
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qserv
argument_list|)
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|qcomp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

