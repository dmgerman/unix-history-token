begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: db_sec.c,v 8.36 2002/11/17 14:51:50 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/tree.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_struct
struct|struct
name|zpubkey
block|{
name|struct
name|dst_key
modifier|*
name|zpk_key
decl_stmt|;
comment|/* Should be DST_KEY */
name|char
modifier|*
name|zpk_name
decl_stmt|;
name|struct
name|zpubkey
modifier|*
name|zpk_next
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|zpubkey
modifier|*
name|zpubkey_list
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|nxt_match_rrset
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * A converted databuf is a stripped down databuf after converting the   * data to wire format.  */
end_comment

begin_struct
struct|struct
name|converted_databuf
block|{
name|struct
name|converted_databuf
modifier|*
name|cd_next
decl_stmt|;
name|u_char
modifier|*
name|cd_data
decl_stmt|;
name|int
name|cd_size
decl_stmt|,
name|cd_alloc
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* All of the trusted keys and zone keys */
end_comment

begin_decl_stmt
specifier|static
name|tree
modifier|*
name|trusted_keys
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|compare_pubkey
parameter_list|(
name|struct
name|zpubkey
modifier|*
name|zpk1
parameter_list|,
name|struct
name|zpubkey
modifier|*
name|zpk2
parameter_list|)
block|{
name|char
name|ta
index|[
name|NS_MAXDNAME
index|]
decl_stmt|,
name|tb
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
if|if
condition|(
name|ns_makecanon
argument_list|(
name|zpk1
operator|->
name|zpk_name
argument_list|,
name|ta
argument_list|,
sizeof|sizeof
name|ta
argument_list|)
operator|<
literal|0
operator|||
name|ns_makecanon
argument_list|(
name|zpk2
operator|->
name|zpk_name
argument_list|,
name|tb
argument_list|,
sizeof|sizeof
name|tb
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|strcasecmp
argument_list|(
name|ta
argument_list|,
name|tb
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|zpubkey
modifier|*
name|tree_srch_pubkey
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|zpubkey
name|tkey
decl_stmt|,
modifier|*
name|key
decl_stmt|;
name|DE_CONST
argument_list|(
name|name
argument_list|,
name|tkey
operator|.
name|zpk_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|trusted_keys
operator|==
name|NULL
condition|)
block|{
name|tree_init
argument_list|(
operator|&
name|trusted_keys
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|key
operator|=
operator|(
expr|struct
name|zpubkey
operator|*
operator|)
name|tree_srch
argument_list|(
operator|&
name|trusted_keys
argument_list|,
name|compare_pubkey
argument_list|,
operator|&
name|tkey
argument_list|)
expr_stmt|;
return|return
operator|(
name|key
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|DST_KEY
modifier|*
name|find_public_key
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int16_t
name|key_id
parameter_list|)
block|{
name|struct
name|namebuf
modifier|*
name|knp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|DST_KEY
modifier|*
name|key
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"find_public_key(%s, %d)"
argument_list|,
name|name
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|knp
operator|=
name|nlookup
argument_list|(
name|name
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|name
condition|)
comment|/* The name doesn't exist, so there's no key */
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|dp
operator|=
name|knp
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|ns_t_key
operator|||
name|dp
operator|->
name|d_secure
operator|<
name|DB_S_SECURE
condition|)
continue|continue;
name|key
operator|=
name|dst_dnskey_to_key
argument_list|(
name|name
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
comment|/* XXX what about multiple keys with same footprint? */
if|if
condition|(
name|key
condition|)
block|{
if|if
condition|(
name|key
operator|->
name|dk_id
operator|==
name|ntohs
argument_list|(
name|key_id
argument_list|)
condition|)
return|return
operator|(
name|key
operator|)
return|;
else|else
name|dst_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|DST_KEY
modifier|*
name|find_trusted_key
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|u_int16_t
name|key_id
parameter_list|)
block|{
name|struct
name|zpubkey
modifier|*
name|zpk
decl_stmt|;
name|zpubkey_list
name|keylist
init|=
name|tree_srch_pubkey
argument_list|(
name|name
argument_list|)
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"find_trusted_key(%s, %d)"
argument_list|,
name|name
argument_list|,
name|key_id
argument_list|)
expr_stmt|;
for|for
control|(
name|zpk
operator|=
name|keylist
init|;
name|zpk
condition|;
name|zpk
operator|=
name|zpk
operator|->
name|zpk_next
control|)
if|if
condition|(
name|zpk
operator|->
name|zpk_key
operator|->
name|dk_id
operator|==
name|ntohs
argument_list|(
name|key_id
argument_list|)
condition|)
return|return
operator|(
name|zpk
operator|->
name|zpk_key
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|add_trusted_key
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|,
specifier|const
name|int
name|proto
parameter_list|,
specifier|const
name|int
name|alg
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|zpubkey_list
name|keylist
decl_stmt|;
name|struct
name|zpubkey
modifier|*
name|zpk
decl_stmt|;
name|u_char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|keylist
operator|=
name|tree_srch_pubkey
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|zpk
operator|=
operator|(
expr|struct
name|zpubkey
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zpubkey
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpk
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"add_trusted_key: memget failed(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
name|b64_pton
argument_list|(
name|str
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
goto|goto
name|failure
goto|;
name|zpk
operator|->
name|zpk_key
operator|=
name|dst_buffer_to_key
argument_list|(
name|name
argument_list|,
name|alg
argument_list|,
name|flags
argument_list|,
name|proto
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|zpk
operator|->
name|zpk_key
operator|==
name|NULL
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"add_trusted_key: dst_buffer_to_key(%s) failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|failure
goto|;
block|}
name|zpk
operator|->
name|zpk_name
operator|=
name|zpk
operator|->
name|zpk_key
operator|->
name|dk_key_name
expr_stmt|;
name|zpk
operator|->
name|zpk_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|keylist
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|tree_add
argument_list|(
operator|&
name|trusted_keys
argument_list|,
name|compare_pubkey
argument_list|,
name|zpk
argument_list|,
name|NULL
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|failure
goto|;
block|}
else|else
block|{
name|struct
name|zpubkey
modifier|*
name|tkey
init|=
name|keylist
decl_stmt|;
while|while
condition|(
name|tkey
operator|->
name|zpk_next
condition|)
name|tkey
operator|=
name|tkey
operator|->
name|zpk_next
expr_stmt|;
name|tkey
operator|->
name|zpk_next
operator|=
name|zpk
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
name|failure
label|:
name|memput
argument_list|(
name|zpk
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zpubkey
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Can the signer sign records for this name?  This is a heuristic. */
end_comment

begin_function
specifier|static
name|int
name|can_sign
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|signer
parameter_list|)
block|{
return|return
operator|(
name|ns_samedomain
argument_list|(
name|name
argument_list|,
name|signer
argument_list|)
operator|&&
name|dn_count_labels
argument_list|(
name|name
argument_list|)
operator|-
name|dn_count_labels
argument_list|(
name|signer
argument_list|)
operator|<=
literal|2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rrset_set_security
parameter_list|(
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|,
name|int
name|slev
parameter_list|)
block|{
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|;
for|for
control|(
name|dnp
operator|=
name|rrset
operator|->
name|rr_list
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_next
control|)
name|dnp
operator|->
name|dp
operator|->
name|d_secure
operator|=
name|slev
expr_stmt|;
for|for
control|(
name|dnp
operator|=
name|rrset
operator|->
name|rr_sigs
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_next
control|)
name|dnp
operator|->
name|dp
operator|->
name|d_secure
operator|=
name|slev
expr_stmt|;
return|return
operator|(
name|slev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|convert_databuf
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|struct
name|converted_databuf
modifier|*
name|cdp
parameter_list|)
block|{
name|u_char
modifier|*
name|bp
init|=
name|cdp
operator|->
name|cd_data
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
name|dp
operator|->
name|d_data
decl_stmt|;
name|u_char
modifier|*
name|eob
init|=
name|cdp
operator|->
name|cd_data
operator|+
name|cdp
operator|->
name|cd_alloc
decl_stmt|;
name|int
name|len
decl_stmt|;
name|u_char
name|buf
index|[
name|MAXDNAME
index|]
decl_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|ns_t_soa
case|:
case|case
name|ns_t_minfo
case|:
case|case
name|ns_t_rp
case|:
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ns_name_pton
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|len
operator|=
name|ns_name_ntol
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|,
name|eob
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|+=
name|len
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ns_name_pton
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|len
operator|=
name|ns_name_ntol
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|,
name|eob
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|+=
name|len
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_soa
condition|)
block|{
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
literal|5
operator|*
name|INT32SZ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|,
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|bp
operator|+=
operator|(
literal|5
operator|*
name|INT32SZ
operator|)
expr_stmt|;
name|cp
operator|+=
operator|(
literal|5
operator|*
name|INT32SZ
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|ns_t_ns
case|:
case|case
name|ns_t_cname
case|:
case|case
name|ns_t_mb
case|:
case|case
name|ns_t_mg
case|:
case|case
name|ns_t_mr
case|:
case|case
name|ns_t_ptr
case|:
case|case
name|ns_t_nxt
case|:
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ns_name_pton
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|len
operator|=
name|ns_name_ntol
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|,
name|eob
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|+=
name|len
expr_stmt|;
name|cp
operator|+=
operator|(
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_nxt
condition|)
block|{
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
name|dp
operator|->
name|d_size
operator|-
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|,
name|dp
operator|->
name|d_size
operator|-
name|len
argument_list|)
expr_stmt|;
name|bp
operator|+=
operator|(
name|dp
operator|->
name|d_size
operator|-
name|len
operator|)
expr_stmt|;
name|cp
operator|+=
operator|(
name|dp
operator|->
name|d_size
operator|-
name|len
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|ns_t_srv
case|:
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
literal|2
operator|*
name|INT16SZ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|,
literal|2
operator|*
name|INT16SZ
argument_list|)
expr_stmt|;
name|bp
operator|+=
operator|(
literal|2
operator|*
name|INT16SZ
operator|)
expr_stmt|;
name|cp
operator|+=
operator|(
literal|2
operator|*
name|INT16SZ
operator|)
expr_stmt|;
comment|/* no break */
case|case
name|ns_t_rt
case|:
case|case
name|ns_t_mx
case|:
case|case
name|ns_t_afsdb
case|:
case|case
name|ns_t_px
case|:
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
name|INT16SZ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ns_name_pton
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|len
operator|=
name|ns_name_ntol
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|,
name|eob
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|+=
name|len
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_px
condition|)
block|{
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ns_name_pton
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|len
operator|=
name|ns_name_ntol
argument_list|(
name|buf
argument_list|,
name|bp
argument_list|,
name|eob
operator|-
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|bp
operator|+=
name|len
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
name|dp
operator|->
name|d_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|cp
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|dp
operator|->
name|d_size
expr_stmt|;
block|}
name|cdp
operator|->
name|cd_size
operator|=
name|bp
operator|-
name|cdp
operator|->
name|cd_data
expr_stmt|;
return|return
operator|(
name|cdp
operator|->
name|cd_size
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|digest_rr
parameter_list|(
name|char
modifier|*
name|envelope
parameter_list|,
name|int
name|elen
parameter_list|,
name|struct
name|converted_databuf
modifier|*
name|cdp
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|blen
parameter_list|)
block|{
name|char
modifier|*
name|bp
init|=
name|buffer
decl_stmt|,
modifier|*
name|eob
init|=
name|buffer
operator|+
name|blen
decl_stmt|;
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
name|elen
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|envelope
argument_list|,
name|elen
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|elen
expr_stmt|;
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
name|INT16SZ
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|PUTSHORT
argument_list|(
name|cdp
operator|->
name|cd_size
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eob
operator|-
name|bp
operator|<
name|cdp
operator|->
name|cd_size
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|bp
argument_list|,
name|cdp
operator|->
name|cd_data
argument_list|,
name|cdp
operator|->
name|cd_size
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|cdp
operator|->
name|cd_size
expr_stmt|;
return|return
operator|(
name|bp
operator|-
name|buffer
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Sorts the converted databuf in the list */
end_comment

begin_function
specifier|static
name|void
name|insert_converted_databuf
parameter_list|(
name|struct
name|converted_databuf
modifier|*
name|cdp
parameter_list|,
name|struct
name|converted_databuf
modifier|*
modifier|*
name|clist
parameter_list|)
block|{
name|struct
name|converted_databuf
modifier|*
name|tcdp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|t
decl_stmt|;
define|#
directive|define
name|compare_cdatabuf
parameter_list|(
name|c1
parameter_list|,
name|c2
parameter_list|,
name|t
parameter_list|)
define|\
value|(t = memcmp(c1->cd_data, c2->cd_data, MIN(c1->cd_size, c2->cd_size)), \ 	 t == 0 ? c1->cd_size - c2->cd_size : t)
if|if
condition|(
operator|*
name|clist
operator|==
name|NULL
condition|)
block|{
operator|*
name|clist
operator|=
name|cdp
expr_stmt|;
return|return;
block|}
name|tcdp
operator|=
operator|*
name|clist
expr_stmt|;
if|if
condition|(
name|compare_cdatabuf
argument_list|(
name|cdp
argument_list|,
name|tcdp
argument_list|,
name|t
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cdp
operator|->
name|cd_next
operator|=
name|tcdp
expr_stmt|;
operator|*
name|clist
operator|=
name|cdp
expr_stmt|;
return|return;
block|}
name|next
operator|=
name|tcdp
operator|->
name|cd_next
expr_stmt|;
while|while
condition|(
name|next
condition|)
block|{
if|if
condition|(
name|compare_cdatabuf
argument_list|(
name|cdp
argument_list|,
name|next
argument_list|,
name|t
argument_list|)
operator|<
literal|0
condition|)
block|{
name|cdp
operator|->
name|cd_next
operator|=
name|next
expr_stmt|;
name|tcdp
operator|->
name|cd_next
operator|=
name|cdp
expr_stmt|;
return|return;
block|}
name|tcdp
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|cd_next
expr_stmt|;
block|}
name|tcdp
operator|->
name|cd_next
operator|=
name|cdp
expr_stmt|;
undef|#
directive|undef
name|compare_cdatabuf
block|}
end_function

begin_function
specifier|static
name|void
name|free_clist
parameter_list|(
name|struct
name|converted_databuf
modifier|*
name|clist
parameter_list|)
block|{
name|struct
name|converted_databuf
modifier|*
name|cdp
decl_stmt|;
while|while
condition|(
name|clist
operator|!=
name|NULL
condition|)
block|{
name|cdp
operator|=
name|clist
expr_stmt|;
name|clist
operator|=
name|clist
operator|->
name|cd_next
expr_stmt|;
name|memput
argument_list|(
name|cdp
operator|->
name|cd_data
argument_list|,
name|cdp
operator|->
name|cd_alloc
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|cdp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|converted_databuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Removes all empty nodes from an rrset's SIG list. */
end_comment

begin_function
specifier|static
name|void
name|rrset_trim_sigs
parameter_list|(
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|,
modifier|*
name|odnp
decl_stmt|,
modifier|*
name|ndnp
decl_stmt|;
name|odnp
operator|=
name|NULL
expr_stmt|;
name|dnp
operator|=
name|rrset
operator|->
name|rr_sigs
expr_stmt|;
while|while
condition|(
name|dnp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dp
operator|!=
name|NULL
condition|)
block|{
name|odnp
operator|=
name|dnp
expr_stmt|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_next
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|odnp
operator|!=
name|NULL
condition|)
name|odnp
operator|->
name|dn_next
operator|=
name|dnp
operator|->
name|dn_next
expr_stmt|;
else|else
name|rrset
operator|->
name|rr_sigs
operator|=
name|dnp
operator|->
name|dn_next
expr_stmt|;
name|ndnp
operator|=
name|dnp
operator|->
name|dn_next
expr_stmt|;
name|memput
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnode
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|=
name|ndnp
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|verify_set
parameter_list|(
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|)
block|{
name|DST_KEY
modifier|*
name|key
init|=
name|NULL
decl_stmt|;
name|struct
name|sig_record
modifier|*
name|sigdata
decl_stmt|;
name|struct
name|dnode
modifier|*
name|sigdn
decl_stmt|;
name|struct
name|databuf
modifier|*
name|sigdp
decl_stmt|;
name|u_int32_t
name|now
decl_stmt|;
name|u_int32_t
name|exptime
decl_stmt|;
name|u_int32_t
name|signtime
decl_stmt|;
name|char
modifier|*
name|signer
decl_stmt|;
name|u_char
name|name_n
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
name|sig
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
name|int
name|trustedkey
init|=
literal|0
decl_stmt|,
name|siglen
decl_stmt|,
name|labels
decl_stmt|,
name|len
init|=
literal|0
decl_stmt|,
name|ret
decl_stmt|;
name|u_char
modifier|*
name|buffer
init|=
name|NULL
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|u_char
name|envelope
index|[
name|MAXDNAME
operator|+
literal|32
index|]
decl_stmt|,
modifier|*
name|ep
decl_stmt|;
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|;
name|int
name|bufsize
init|=
literal|2048
decl_stmt|;
comment|/* Large enough for MAXDNAME + SIG_HDR_SIZE */
name|struct
name|converted_databuf
modifier|*
name|clist
init|=
name|NULL
decl_stmt|,
modifier|*
name|cdp
decl_stmt|;
name|int
name|dnssec_failed
init|=
literal|0
decl_stmt|,
name|dnssec_succeeded
init|=
literal|0
decl_stmt|;
name|int
name|return_value
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|expired
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rrset
operator|==
name|NULL
operator|||
name|rrset
operator|->
name|rr_name
operator|==
name|NULL
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"verify_set: missing rrset/name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|rrset_set_security
argument_list|(
name|rrset
argument_list|,
name|DB_S_FAILED
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|rrset
operator|->
name|rr_sigs
operator|==
name|NULL
condition|)
return|return
operator|(
name|rrset_set_security
argument_list|(
name|rrset
argument_list|,
name|DB_S_INSECURE
argument_list|)
operator|)
return|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"verify_set(%s, %s, %s)"
argument_list|,
name|rrset
operator|->
name|rr_name
argument_list|,
name|p_type
argument_list|(
name|rrset
operator|->
name|rr_type
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|rrset
operator|->
name|rr_class
argument_list|)
argument_list|)
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|sigdn
operator|=
name|rrset
operator|->
name|rr_sigs
init|;
name|sigdn
operator|!=
name|NULL
condition|;
name|sigdn
operator|=
name|sigdn
operator|->
name|dn_next
control|)
block|{
name|u_int32_t
name|namefield
decl_stmt|;
name|struct
name|sig_record
name|sigrec
decl_stmt|;
name|sigdp
operator|=
name|sigdn
operator|->
name|dp
expr_stmt|;
name|eom
operator|=
name|sigdp
operator|->
name|d_data
operator|+
name|sigdp
operator|->
name|d_size
expr_stmt|;
if|if
condition|(
name|sigdp
operator|->
name|d_size
operator|<
name|SIG_HDR_SIZE
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|memcpy
argument_list|(
operator|&
name|sigrec
argument_list|,
name|sigdp
operator|->
name|d_data
argument_list|,
name|SIG_HDR_SIZE
argument_list|)
expr_stmt|;
name|sigdata
operator|=
operator|&
name|sigrec
expr_stmt|;
name|signer
operator|=
operator|(
name|char
operator|*
operator|)
name|sigdp
operator|->
name|d_data
operator|+
name|SIG_HDR_SIZE
expr_stmt|;
name|sig
operator|=
operator|(
name|u_char
operator|*
operator|)
name|signer
operator|+
name|strlen
argument_list|(
name|signer
argument_list|)
operator|+
literal|1
expr_stmt|;
name|siglen
operator|=
name|eom
operator|-
name|sig
expr_stmt|;
comment|/* 		 * Don't verify a set if the SIG inception time is in 		 * the future.  This should be fixed before 2038 (BEW) 		 */
name|signtime
operator|=
name|ntohl
argument_list|(
name|sigdata
operator|->
name|sig_time_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|signtime
argument_list|,
name|now
argument_list|)
condition|)
continue|continue;
comment|/* An expired set is dropped, but the data is not. */
name|exptime
operator|=
name|ntohl
argument_list|(
name|sigdata
operator|->
name|sig_exp_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|now
argument_list|,
name|exptime
argument_list|)
condition|)
block|{
name|expired
operator|++
expr_stmt|;
name|db_detach
argument_list|(
operator|&
name|sigdn
operator|->
name|dp
argument_list|)
expr_stmt|;
name|sigdp
operator|=
name|NULL
expr_stmt|;
continue|continue;
block|}
comment|/* Cleanup from the last iteration if we continue'd */
if|if
condition|(
name|trustedkey
operator|==
literal|0
operator|&&
name|key
operator|!=
name|NULL
condition|)
name|dst_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
name|key
operator|=
name|find_trusted_key
argument_list|(
name|signer
argument_list|,
name|sigdata
operator|->
name|sig_keyid_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|trustedkey
operator|=
literal|0
expr_stmt|;
name|key
operator|=
name|find_public_key
argument_list|(
name|signer
argument_list|,
name|sigdata
operator|->
name|sig_keyid_n
argument_list|)
expr_stmt|;
block|}
else|else
name|trustedkey
operator|=
literal|1
expr_stmt|;
comment|/* if we don't have the key, either 		 *   - the data should be considered insecure 		 *   - the sig is not a dnssec signature 		 */
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Can a key with this name sign the data? */
if|if
condition|(
operator|!
name|can_sign
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|,
name|signer
argument_list|)
condition|)
continue|continue;
comment|/* Check the protocol and flags of the key */
if|if
condition|(
name|key
operator|->
name|dk_proto
operator|!=
name|NS_KEY_PROT_DNSSEC
operator|&&
name|key
operator|->
name|dk_proto
operator|!=
name|NS_KEY_PROT_ANY
condition|)
continue|continue;
if|if
condition|(
name|key
operator|->
name|dk_flags
operator|&
name|NS_KEY_NO_AUTH
condition|)
continue|continue;
name|namefield
operator|=
name|key
operator|->
name|dk_flags
operator|&
name|NS_KEY_NAME_TYPE
expr_stmt|;
if|if
condition|(
name|namefield
operator|==
name|NS_KEY_NAME_USER
operator|||
name|namefield
operator|==
name|NS_KEY_NAME_RESERVED
condition|)
continue|continue;
if|if
condition|(
name|namefield
operator|==
name|NS_KEY_NAME_ENTITY
operator|&&
operator|(
name|key
operator|->
name|dk_flags
operator|&
name|NS_KEY_SIGNATORYMASK
operator|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * If we're still here, we have a non-null key that's either 		 * a zone key or an entity key with signing authority. 		 */
if|if
condition|(
name|buffer
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
name|buffer
operator|=
name|memget
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
else|else
name|bp
operator|=
name|buffer
expr_stmt|;
comment|/* Digest the fixed portion of the SIG record */
name|memcpy
argument_list|(
name|bp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sigdata
argument_list|,
name|SIG_HDR_SIZE
argument_list|)
expr_stmt|;
name|bp
operator|+=
name|SIG_HDR_SIZE
expr_stmt|;
comment|/* Digest the signer's name, canonicalized */
if|if
condition|(
name|ns_name_pton
argument_list|(
name|signer
argument_list|,
name|name_n
argument_list|,
sizeof|sizeof
name|name_n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|i
operator|=
name|ns_name_ntol
argument_list|(
name|name_n
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|bp
argument_list|,
name|bufsize
operator|-
name|SIG_HDR_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|bp
operator|+=
name|i
expr_stmt|;
comment|/* create the dns record envelope: 		 *<name><type><class><Original TTL> 		 */
if|if
condition|(
name|ns_name_pton
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|,
name|name_n
argument_list|,
sizeof|sizeof
name|name_n
argument_list|)
operator|<
literal|0
operator|||
name|ns_name_ntol
argument_list|(
name|name_n
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|envelope
argument_list|,
sizeof|sizeof
name|envelope
argument_list|)
operator|<
literal|0
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|labels
operator|=
name|dn_count_labels
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|labels
operator|>
name|sigdata
operator|->
name|sig_labels_n
condition|)
block|{
name|ep
operator|=
name|envelope
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|labels
operator|-
literal|1
operator|-
name|sigdata
operator|->
name|sig_labels_n
operator|)
condition|;
name|i
operator|++
control|)
name|ep
operator|+=
operator|(
operator|*
name|ep
operator|+
literal|1
operator|)
expr_stmt|;
name|i
operator|=
name|dn_skipname
argument_list|(
name|ep
argument_list|,
name|envelope
operator|+
sizeof|sizeof
name|envelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|envelope
index|[
literal|0
index|]
operator|=
literal|'\001'
expr_stmt|;
name|envelope
index|[
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
name|memmove
argument_list|(
name|envelope
operator|+
literal|2
argument_list|,
name|ep
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|dn_skipname
argument_list|(
name|envelope
argument_list|,
name|envelope
operator|+
sizeof|sizeof
name|envelope
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ep
operator|=
name|envelope
operator|+
name|i
expr_stmt|;
name|PUTSHORT
argument_list|(
name|rrset
operator|->
name|rr_type
argument_list|,
name|ep
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|rrset
operator|->
name|rr_class
argument_list|,
name|ep
argument_list|)
expr_stmt|;
if|if
condition|(
name|envelope
operator|+
sizeof|sizeof
argument_list|(
name|envelope
argument_list|)
operator|-
name|ep
operator|<
name|INT32SZ
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|memcpy
argument_list|(
name|ep
argument_list|,
operator|&
name|sigdata
operator|->
name|sig_ottl_n
argument_list|,
name|INT32SZ
argument_list|)
expr_stmt|;
name|ep
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|clist
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|dnp
operator|=
name|rrset
operator|->
name|rr_list
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_next
control|)
block|{
name|struct
name|databuf
modifier|*
name|dp
init|=
name|dnp
operator|->
name|dp
decl_stmt|;
name|cdp
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|converted_databuf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|==
name|NULL
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|memset
argument_list|(
name|cdp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cdp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should be large enough... */
name|cdp
operator|->
name|cd_alloc
operator|=
name|dp
operator|->
name|d_size
operator|+
literal|8
expr_stmt|;
name|cdp
operator|->
name|cd_data
operator|=
name|memget
argument_list|(
name|cdp
operator|->
name|cd_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|cd_data
operator|==
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|cdp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cdp
argument_list|)
argument_list|)
expr_stmt|;
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
while|while
condition|(
name|convert_databuf
argument_list|(
name|dp
argument_list|,
name|cdp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|memput
argument_list|(
name|cdp
operator|->
name|cd_data
argument_list|,
name|cdp
operator|->
name|cd_alloc
argument_list|)
expr_stmt|;
name|cdp
operator|->
name|cd_alloc
operator|*=
literal|2
expr_stmt|;
name|cdp
operator|->
name|cd_data
operator|=
name|memget
argument_list|(
name|cdp
operator|->
name|cd_alloc
argument_list|)
expr_stmt|;
if|if
condition|(
name|cdp
operator|->
name|cd_data
operator|==
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|cdp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cdp
argument_list|)
argument_list|)
expr_stmt|;
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
block|}
name|insert_converted_databuf
argument_list|(
name|cdp
argument_list|,
operator|&
name|clist
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|cdp
operator|=
name|clist
init|;
name|cdp
operator|!=
name|NULL
condition|;
name|cdp
operator|=
name|cdp
operator|->
name|cd_next
control|)
block|{
name|len
operator|=
name|digest_rr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envelope
argument_list|,
name|ep
operator|-
name|envelope
argument_list|,
name|cdp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|bufsize
operator|-
operator|(
name|bp
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|u_char
modifier|*
name|newbuf
decl_stmt|;
comment|/* Double the buffer size */
name|newbuf
operator|=
name|memget
argument_list|(
name|bufsize
operator|*
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|newbuf
operator|==
name|NULL
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|memcpy
argument_list|(
name|newbuf
argument_list|,
name|buffer
argument_list|,
name|bp
operator|-
name|buffer
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|(
name|bp
operator|-
name|buffer
operator|)
operator|+
name|newbuf
expr_stmt|;
name|memput
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|buffer
operator|=
name|newbuf
expr_stmt|;
name|bufsize
operator|*=
literal|2
expr_stmt|;
name|len
operator|=
name|digest_rr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|envelope
argument_list|,
name|ep
operator|-
name|envelope
argument_list|,
name|cdp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|,
name|bufsize
operator|-
operator|(
name|bp
operator|-
name|buffer
operator|)
argument_list|)
expr_stmt|;
block|}
name|bp
operator|+=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
goto|goto
name|end
goto|;
block|}
name|ret
operator|=
name|dst_verify_data
argument_list|(
name|SIG_MODE_ALL
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|buffer
argument_list|,
name|bp
operator|-
name|buffer
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|dnssec_failed
operator|++
expr_stmt|;
name|db_detach
argument_list|(
operator|&
name|sigdn
operator|->
name|dp
argument_list|)
expr_stmt|;
name|sigdp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|dnssec_succeeded
operator|++
expr_stmt|;
block|}
name|end
label|:
if|if
condition|(
name|dnssec_failed
operator|>
literal|0
operator|||
name|expired
operator|>
literal|0
condition|)
name|rrset_trim_sigs
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
if|if
condition|(
name|trustedkey
operator|==
literal|0
operator|&&
name|key
operator|!=
name|NULL
condition|)
name|dst_free_key
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnssec_failed
operator|>
literal|0
operator|&&
name|dnssec_succeeded
operator|==
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"verify_set(%s, %s, %s) failed"
argument_list|,
name|rrset
operator|->
name|rr_name
argument_list|,
name|p_type
argument_list|(
name|rrset
operator|->
name|rr_type
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|rrset
operator|->
name|rr_class
argument_list|)
argument_list|)
expr_stmt|;
name|return_value
operator|=
name|DB_S_FAILED
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dnssec_succeeded
operator|>
literal|0
condition|)
name|return_value
operator|=
name|DB_S_SECURE
expr_stmt|;
else|else
name|return_value
operator|=
name|DB_S_INSECURE
expr_stmt|;
name|free_clist
argument_list|(
name|clist
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffer
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|rrset_set_security
argument_list|(
name|rrset
argument_list|,
name|return_value
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rrset_free
parameter_list|(
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|)
block|{
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"rrset_free(%s)"
argument_list|,
name|rrset
operator|->
name|rr_name
argument_list|)
expr_stmt|;
while|while
condition|(
name|rrset
operator|->
name|rr_list
condition|)
block|{
name|dnp
operator|=
name|rrset
operator|->
name|rr_list
expr_stmt|;
name|rrset
operator|->
name|rr_list
operator|=
name|rrset
operator|->
name|rr_list
operator|->
name|dn_next
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dp
operator|!=
name|NULL
condition|)
name|db_detach
argument_list|(
operator|&
name|dnp
operator|->
name|dp
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnode
argument_list|)
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|rrset
operator|->
name|rr_sigs
condition|)
block|{
name|dnp
operator|=
name|rrset
operator|->
name|rr_sigs
expr_stmt|;
name|rrset
operator|->
name|rr_sigs
operator|=
name|rrset
operator|->
name|rr_sigs
operator|->
name|dn_next
expr_stmt|;
if|if
condition|(
name|dnp
operator|->
name|dp
operator|!=
name|NULL
condition|)
name|db_detach
argument_list|(
operator|&
name|dnp
operator|->
name|dp
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|dnp
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnode
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is called when we have an rrset with SIGs and no other data.  * Returns 1 if we either found the necessary data or if the SIG can be added  * with no other data.  0 indicates that the SIG cannot be added.  */
end_comment

begin_function
specifier|static
name|int
name|attach_data
parameter_list|(
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|newdp
decl_stmt|,
modifier|*
name|sigdp
decl_stmt|;
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|signer
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|name
init|=
name|rrset
operator|->
name|rr_name
decl_stmt|;
name|sigdp
operator|=
name|rrset
operator|->
name|rr_sigs
operator|->
name|dp
expr_stmt|;
name|type
operator|=
name|SIG_COVERS
argument_list|(
name|sigdp
argument_list|)
expr_stmt|;
name|class
operator|=
name|sigdp
operator|->
name|d_class
expr_stmt|;
name|signer
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|sigdp
operator|+
name|SIG_HDR_SIZE
operator|)
expr_stmt|;
comment|/* First, see if the signer can sign data for the name.  If not, 	 * it's not a DNSSEC signature, so we can insert it with no 	 * corresponding data. 	 */
if|if
condition|(
operator|!
name|can_sign
argument_list|(
name|name
argument_list|,
name|signer
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|name
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|name
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|type
operator|&&
name|dp
operator|->
name|d_class
operator|==
name|class
condition|)
block|{
name|newdp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|dp
operator|->
name|d_ttl
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|dp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|dnp
operator|=
operator|(
expr|struct
name|dnode
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dnode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"attach_data: memget failed"
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dp
operator|=
name|newdp
expr_stmt|;
name|dnp
operator|->
name|dn_next
operator|=
name|rrset
operator|->
name|rr_list
expr_stmt|;
name|rrset
operator|->
name|rr_list
operator|=
name|dnp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|rrset
operator|->
name|rr_list
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rrset_db_update
parameter_list|(
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|hashbuf
modifier|*
modifier|*
name|htpp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
modifier|*
name|rrcount
parameter_list|)
block|{
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* If we have any unattached SIG records that are DNSSEC signatures, 	 * don't cache them unless we already have the corresponding data. 	 * If we do cache unattached SIGs, we run into problems later if we 	 * have a SIG X and get a query for type X. 	 */
if|if
condition|(
name|rrset
operator|->
name|rr_list
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|attach_data
argument_list|(
name|rrset
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rrset_free
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
if|if
condition|(
name|rrset
operator|->
name|rr_list
operator|!=
name|NULL
operator|&&
name|verify_set
argument_list|(
name|rrset
argument_list|)
operator|==
name|DB_S_FAILED
condition|)
block|{
name|rrset_free
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
block|}
for|for
control|(
name|dnp
operator|=
name|rrset
operator|->
name|rr_list
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_next
control|)
block|{
name|ret
operator|=
name|db_update
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|,
name|dnp
operator|->
name|dp
argument_list|,
name|dnp
operator|->
name|dp
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
operator|(
operator|*
name|htpp
operator|)
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|OK
condition|)
block|{
comment|/* XXX Probably should do rollback.  */
name|db_err
argument_list|(
name|ret
argument_list|,
name|rrset
operator|->
name|rr_name
argument_list|,
name|dnp
operator|->
name|dp
operator|->
name|d_type
argument_list|,
name|dnp
operator|->
name|file
argument_list|,
name|dnp
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|DATAEXISTS
condition|)
block|{
name|rrset_free
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
if|if
condition|(
name|rrcount
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|rrcount
operator|)
operator|++
expr_stmt|;
block|}
for|for
control|(
name|dnp
operator|=
name|rrset
operator|->
name|rr_sigs
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_next
control|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dp
operator|==
name|NULL
condition|)
comment|/* verifyset() can remove sigs */
continue|continue;
name|ret
operator|=
name|db_update
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|,
name|dnp
operator|->
name|dp
argument_list|,
name|dnp
operator|->
name|dp
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|,
operator|(
operator|*
name|htpp
operator|)
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|OK
condition|)
block|{
comment|/* XXX Probably should do rollback.  */
name|db_err
argument_list|(
name|ret
argument_list|,
name|rrset
operator|->
name|rr_name
argument_list|,
name|dnp
operator|->
name|dp
operator|->
name|d_type
argument_list|,
name|dnp
operator|->
name|file
argument_list|,
name|dnp
operator|->
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|DATAEXISTS
condition|)
block|{
name|rrset_free
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
if|if
condition|(
name|rrcount
operator|!=
name|NULL
condition|)
operator|(
operator|*
name|rrcount
operator|)
operator|++
expr_stmt|;
block|}
name|rrset_free
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|rr_in_set
parameter_list|(
name|struct
name|databuf
modifier|*
name|rr
parameter_list|,
name|struct
name|dnode
modifier|*
name|set
parameter_list|)
block|{
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|;
if|if
condition|(
name|set
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|dnp
operator|=
name|set
init|;
name|dnp
operator|!=
name|NULL
condition|;
name|dnp
operator|=
name|dnp
operator|->
name|dn_next
control|)
block|{
if|if
condition|(
name|dnp
operator|->
name|dp
operator|->
name|d_size
operator|==
name|rr
operator|->
name|d_size
operator|&&
name|memcmp
argument_list|(
name|dnp
operator|->
name|dp
operator|->
name|d_data
argument_list|,
name|rr
operator|->
name|d_data
argument_list|,
name|dnp
operator|->
name|dp
operator|->
name|d_size
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|add_to_rrset_list
parameter_list|(
name|struct
name|db_rrset
modifier|*
modifier|*
name|rrsets
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|db_rrset
modifier|*
name|rrset
init|=
operator|*
name|rrsets
decl_stmt|;
name|struct
name|dnode
modifier|*
name|dnp
decl_stmt|;
while|while
condition|(
name|rrset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rr_type
operator|!=
name|ns_t_nxt
operator|||
name|dp
operator|->
name|d_type
operator|!=
name|ns_t_nxt
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_sig
condition|)
block|{
if|if
condition|(
operator|(
name|int
operator|)
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|rrset
operator|->
name|rr_type
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|rrset
operator|->
name|rr_type
condition|)
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|nxt_match_rrset
argument_list|(
name|dp
argument_list|,
name|rrset
argument_list|)
condition|)
break|break;
name|rrset
operator|=
name|rrset
operator|->
name|rr_next
expr_stmt|;
block|}
if|if
condition|(
name|rrset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_sig
operator|&&
name|rr_in_set
argument_list|(
name|dp
argument_list|,
name|rrset
operator|->
name|rr_sigs
argument_list|)
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|!=
name|ns_t_sig
operator|&&
name|rr_in_set
argument_list|(
name|dp
argument_list|,
name|rrset
operator|->
name|rr_list
argument_list|)
operator|)
condition|)
return|return
operator|(
name|DATAEXISTS
operator|)
return|;
block|}
else|else
block|{
name|rrset
operator|=
operator|(
expr|struct
name|db_rrset
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|db_rrset
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrset
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"add_to_rrset_list: memget failed(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|rrset
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|db_rrset
argument_list|)
argument_list|)
expr_stmt|;
name|rrset
operator|->
name|rr_name
operator|=
name|savestr
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|rrset
operator|->
name|rr_class
operator|=
name|dp
operator|->
name|d_class
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_sig
condition|)
name|rrset
operator|->
name|rr_type
operator|=
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
expr_stmt|;
else|else
name|rrset
operator|->
name|rr_type
operator|=
name|dp
operator|->
name|d_type
expr_stmt|;
name|rrset
operator|->
name|rr_next
operator|=
operator|*
name|rrsets
expr_stmt|;
operator|*
name|rrsets
operator|=
name|rrset
expr_stmt|;
block|}
name|dnp
operator|=
operator|(
expr|struct
name|dnode
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dnode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"add_to_rrset_list: memget failed(%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|dnp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dnode
argument_list|)
argument_list|)
expr_stmt|;
name|dnp
operator|->
name|dp
operator|=
name|dp
expr_stmt|;
name|DRCNTINC
argument_list|(
name|dnp
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_sig
condition|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rr_sigs
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dnode
modifier|*
name|fdnp
decl_stmt|;
comment|/* Preserve the order of the RRs */
comment|/* Add this one to the end of the list */
for|for
control|(
name|fdnp
operator|=
name|rrset
operator|->
name|rr_sigs
init|;
name|fdnp
operator|->
name|dn_next
operator|!=
name|NULL
condition|;
name|fdnp
operator|=
name|fdnp
operator|->
name|dn_next
control|)
comment|/* NULL */
empty_stmt|;
name|fdnp
operator|->
name|dn_next
operator|=
name|dnp
expr_stmt|;
block|}
else|else
name|rrset
operator|->
name|rr_sigs
operator|=
name|dnp
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|rrset
operator|->
name|rr_list
operator|!=
name|NULL
condition|)
block|{
name|struct
name|dnode
modifier|*
name|fdnp
decl_stmt|;
comment|/* Preserve the order of the RRs */
comment|/* Add this one to the end of the list */
for|for
control|(
name|fdnp
operator|=
name|rrset
operator|->
name|rr_list
init|;
name|fdnp
operator|->
name|dn_next
operator|!=
name|NULL
condition|;
name|fdnp
operator|=
name|fdnp
operator|->
name|dn_next
control|)
comment|/* NULL */
empty_stmt|;
name|fdnp
operator|->
name|dn_next
operator|=
name|dnp
expr_stmt|;
block|}
else|else
name|rrset
operator|->
name|rr_list
operator|=
name|dnp
expr_stmt|;
block|}
name|dnp
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|dnp
operator|->
name|line
operator|=
name|line
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|update_rrset_list
parameter_list|(
name|struct
name|db_rrset
modifier|*
modifier|*
name|rrsets
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|hashbuf
modifier|*
modifier|*
name|htpp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
modifier|*
name|rrcount
parameter_list|)
block|{
name|struct
name|db_rrset
modifier|*
name|rrset
init|=
operator|*
name|rrsets
decl_stmt|,
modifier|*
name|next
init|=
name|NULL
decl_stmt|,
modifier|*
name|last
init|=
name|NULL
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|,
name|tresult
decl_stmt|,
name|cnameandother
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|rrset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rr_type
operator|==
name|ns_t_key
condition|)
break|break;
name|last
operator|=
name|rrset
expr_stmt|;
name|rrset
operator|=
name|rrset
operator|->
name|rr_next
expr_stmt|;
block|}
if|if
condition|(
name|rrset
operator|!=
name|NULL
operator|&&
name|last
operator|!=
name|NULL
condition|)
block|{
name|last
operator|->
name|rr_next
operator|=
name|rrset
operator|->
name|rr_next
expr_stmt|;
name|rrset
operator|->
name|rr_next
operator|=
operator|*
name|rrsets
expr_stmt|;
operator|*
name|rrsets
operator|=
name|rrset
expr_stmt|;
block|}
name|rrset
operator|=
operator|*
name|rrsets
expr_stmt|;
while|while
condition|(
name|rrset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|verify_set
argument_list|(
name|rrset
argument_list|)
operator|>
name|DB_S_FAILED
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|10
argument_list|,
literal|"update_rrset_list(%s, %s): set verified"
argument_list|,
name|rrset
operator|->
name|rr_name
argument_list|,
name|p_type
argument_list|(
name|rrset
operator|->
name|rr_type
argument_list|)
argument_list|)
expr_stmt|;
name|tresult
operator|=
name|rrset_db_update
argument_list|(
name|rrset
argument_list|,
name|flags
argument_list|,
name|htpp
argument_list|,
name|from
argument_list|,
name|rrcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|tresult
operator|==
name|CNAMEANDOTHER
condition|)
name|cnameandother
operator|++
expr_stmt|;
if|if
condition|(
name|tresult
operator|!=
name|OK
condition|)
name|result
operator|=
name|tresult
expr_stmt|;
block|}
else|else
block|{
name|rrset_free
argument_list|(
name|rrset
argument_list|)
expr_stmt|;
name|result
operator|=
name|DNSSECFAIL
expr_stmt|;
block|}
name|rrset
operator|->
name|rr_name
operator|=
name|freestr
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|)
expr_stmt|;
name|next
operator|=
name|rrset
operator|->
name|rr_next
expr_stmt|;
name|memput
argument_list|(
name|rrset
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|db_rrset
argument_list|)
argument_list|)
expr_stmt|;
name|rrset
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|rrsets
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|cnameandother
operator|!=
literal|0
condition|)
return|return
operator|(
name|CNAMEANDOTHER
operator|)
return|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|int
name|db_set_update
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
modifier|*
name|state
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|hashbuf
modifier|*
modifier|*
name|htpp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
modifier|*
name|rrcount
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|struct
name|db_rrset
modifier|*
modifier|*
name|rrsets
decl_stmt|;
name|struct
name|db_rrset
modifier|*
name|rrset
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"db_set_update(%s)"
argument_list|,
operator|(
name|name
operator|==
name|NULL
operator|)
condition|?
literal|"<NULL>"
else|:
operator|(
operator|*
name|name
operator|==
literal|0
operator|)
condition|?
literal|"."
else|:
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Called db_set_update with state == NULL"
argument_list|)
expr_stmt|;
name|rrsets
operator|=
operator|(
expr|struct
name|db_rrset
operator|*
operator|*
operator|)
name|state
expr_stmt|;
if|if
condition|(
operator|*
name|rrsets
operator|!=
name|NULL
condition|)
block|{
name|rrset
operator|=
operator|*
name|rrsets
expr_stmt|;
if|if
condition|(
name|rrset
operator|->
name|rr_name
operator|!=
name|NULL
operator|&&
name|dp
operator|!=
name|NULL
operator|&&
name|name
operator|!=
name|NULL
operator|&&
name|ns_samename
argument_list|(
name|name
argument_list|,
name|rrset
operator|->
name|rr_name
argument_list|)
operator|==
literal|1
operator|&&
name|dp
operator|->
name|d_class
operator|==
name|rrset
operator|->
name|rr_class
condition|)
return|return
operator|(
name|add_to_rrset_list
argument_list|(
name|rrsets
argument_list|,
name|name
argument_list|,
name|dp
argument_list|,
name|line
argument_list|,
name|file
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|rrsets
operator|!=
name|NULL
condition|)
name|result
operator|=
name|update_rrset_list
argument_list|(
name|rrsets
argument_list|,
name|flags
argument_list|,
name|htpp
argument_list|,
name|from
argument_list|,
name|rrcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|10
argument_list|,
literal|"db_set_update(%s), creating new list"
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|add_to_rrset_list
argument_list|(
name|rrsets
argument_list|,
name|name
argument_list|,
name|dp
argument_list|,
name|line
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|nxt_match_rrset
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|struct
name|db_rrset
modifier|*
name|rrset
parameter_list|)
block|{
if|if
condition|(
name|rrset
operator|->
name|rr_list
operator|!=
name|NULL
condition|)
return|return
operator|(
name|nxtmatch
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|,
name|dp
argument_list|,
name|rrset
operator|->
name|rr_list
operator|->
name|dp
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|nxtmatch
argument_list|(
name|rrset
operator|->
name|rr_name
argument_list|,
name|dp
argument_list|,
name|rrset
operator|->
name|rr_sigs
operator|->
name|dp
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

