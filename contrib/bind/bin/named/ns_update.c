begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_update.c,v 8.26 1998/05/05 19:45:10 halley Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996, 1997 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Based on the Dynamic DNS reference implementation by Viraj Bais  *<viraj_bais@ccm.fm.intel.com>  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_define
define|#
directive|define
name|WRITEABLE_MASK
value|(S_IWUSR | S_IWGRP | S_IWOTH)
end_define

begin_comment
comment|/* XXXRTH almost all funcs. in here should be static!    map rdata_dump to db_to_textual    map rdata_expand to wire_to_db    make a textual_to_db and use it in merge_logs?    replace all this "map" stuff with the new routines (from 4.9.5 I think)  */
end_comment

begin_comment
comment|/* from ns_req.c */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|map
name|m_opcode
index|[]
init|=
block|{
block|{
literal|"nxdomain"
block|,
name|NXDOMAIN
block|}
block|,
block|{
literal|"yxdomain"
block|,
name|YXDOMAIN
block|}
block|,
block|{
literal|"nxrrset"
block|,
name|NXRRSET
block|}
block|,
block|{
literal|"yxrrset"
block|,
name|YXRRSET
block|}
block|,
block|{
literal|"delete"
block|,
name|DELETE
block|}
block|,
block|{
literal|"add"
block|,
name|ADD
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_OPCODE_CNT
value|(sizeof(m_opcode) / sizeof(struct map))
end_define

begin_comment
comment|/* XXXRTH workaround map difficulties */
end_comment

begin_define
define|#
directive|define
name|M_CLASS_CNT
value|m_class_cnt
end_define

begin_define
define|#
directive|define
name|M_TYPE_CNT
value|m_type_cnt
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|opcodes
index|[]
init|=
block|{
literal|"delete"
block|,
literal|"add"
block|,
literal|""
block|,
literal|"nxdomain"
block|,
literal|""
block|,
literal|""
block|,
literal|"yxdomain"
block|,
literal|"yxrrset"
block|,
literal|"nxrrset"
block|,
literal|""
block|,
literal|""
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from db_load.c */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|map
name|m_section
index|[]
init|=
block|{
block|{
literal|"zone"
block|,
name|S_ZONE
block|}
block|,
block|{
literal|"prereq"
block|,
name|S_PREREQ
block|}
block|,
block|{
literal|"update"
block|,
name|S_UPDATE
block|}
block|,
block|{
literal|"reserved"
block|,
name|S_ADDT
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_SECTION_CNT
value|(sizeof(m_section) / sizeof(struct map))
end_define

begin_comment
comment|/* from ns_req.c */
end_comment

begin_decl_stmt
specifier|static
name|ns_updrec
modifier|*
name|rrecp_start
init|=
name|NULL
decl_stmt|,
modifier|*
name|rrecp_last
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward */
end_comment

begin_function_decl
specifier|static
name|int
name|findzone
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|rdata_expand
parameter_list|(
specifier|const
name|u_char
modifier|*
parameter_list|,
specifier|const
name|u_char
modifier|*
parameter_list|,
specifier|const
name|u_char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
name|size_t
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|FILE
modifier|*
name|open_transaction_log
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|,
literal|"a+"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"can't open %s: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ftell
argument_list|(
name|fp
argument_list|)
operator|==
literal|0L
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|LogSignature
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|close_transaction_log
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fflush() of %s failed: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fsync
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fsync() of %s failed: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fclose() of %s failed: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * printupdatelog(srcaddr, firstp, hp, zp, old_serial)  *	append an ascii form to the zone's transaction log file.  */
end_comment

begin_function
specifier|static
name|void
name|printupdatelog
parameter_list|(
name|struct
name|sockaddr_in
name|srcaddr
parameter_list|,
name|ns_updrec
modifier|*
name|firstp
parameter_list|,
name|HEADER
modifier|*
name|hp
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|u_int32_t
name|old_serial
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|map
modifier|*
name|mp
decl_stmt|;
name|ns_updrec
modifier|*
name|rrecp
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|char
name|time
index|[
literal|25
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
operator|!
name|firstp
condition|)
return|return;
name|fp
operator|=
name|open_transaction_log
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
name|sprintf
argument_list|(
name|time
argument_list|,
literal|"at %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"[DYNAMIC_UPDATE] id %u from %s %s (named pid %ld):\n"
argument_list|,
name|hp
operator|->
name|id
argument_list|,
name|sin_ntoa
argument_list|(
name|srcaddr
argument_list|)
argument_list|,
name|time
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|rrecp
operator|=
name|firstp
init|;
name|rrecp
condition|;
name|rrecp
operator|=
name|rrecp
operator|->
name|r_next
control|)
block|{
name|INSIST
argument_list|(
name|zp
operator|==
operator|&
name|zones
index|[
name|rrecp
operator|->
name|r_zone
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|rrecp
operator|->
name|r_section
condition|)
block|{
case|case
name|S_ZONE
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"zone:\torigin %s class %s serial %u\n"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
name|old_serial
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_PREREQ
case|:
name|opcode
operator|=
name|rrecp
operator|->
name|r_opcode
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"prereq:\t{%s} %s. %s "
argument_list|,
name|opcodes
index|[
name|opcode
index|]
argument_list|,
name|rrecp
operator|->
name|r_dname
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NXRRSET
operator|||
name|opcode
operator|==
name|YXRRSET
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|p_type
argument_list|(
name|rrecp
operator|->
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|rrecp
operator|->
name|r_dp
operator|)
operator|&&
name|dp
operator|->
name|d_size
operator|>
literal|0
condition|)
block|{
name|dp
operator|->
name|d_class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
operator|(
name|void
operator|)
name|rdata_dump
argument_list|(
name|dp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_UPDATE
case|:
name|opcode
operator|=
name|rrecp
operator|->
name|r_opcode
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"update:\t{%s} %s. "
argument_list|,
name|opcodes
index|[
name|opcode
index|]
argument_list|,
name|rrecp
operator|->
name|r_dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|ADD
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u "
argument_list|,
name|rrecp
operator|->
name|r_ttl
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rrecp
operator|->
name|r_type
operator|!=
name|T_ANY
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|p_type
argument_list|(
name|rrecp
operator|->
name|r_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|rrecp
operator|->
name|r_dp
operator|)
operator|&&
name|dp
operator|->
name|d_size
operator|>
literal|0
condition|)
block|{
name|dp
operator|->
name|d_class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
operator|(
name|void
operator|)
name|rdata_dump
argument_list|(
name|dp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_ADDT
case|:
break|break;
default|default:
name|ns_panic
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"printupdatelog - impossible condition"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close_transaction_log
argument_list|(
name|zp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|cancel_soa_update
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"cancel_soa_update for %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_NEED_SOAUPDATE
expr_stmt|;
name|zp
operator|->
name|z_soaincrtime
operator|=
literal|0
expr_stmt|;
name|zp
operator|->
name|z_updatecnt
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Figure out when a SOA serial number update should happen.  * Returns non-zero if the caller should call sched_zone_maint(zp).  */
end_comment

begin_function
name|int
name|schedule_soa_update
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|int
name|numupdated
parameter_list|)
block|{
operator|(
name|void
operator|)
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_NEED_SOAUPDATE
expr_stmt|;
comment|/* 	 * Only z_deferupdcnt updates are allowed before we force 	 * a serial update. 	 */
name|zp
operator|->
name|z_updatecnt
operator|+=
name|numupdated
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_updatecnt
operator|>=
name|zp
operator|->
name|z_deferupdcnt
condition|)
block|{
if|if
condition|(
name|incr_serial
argument_list|(
name|zp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"error updating serial number for %s from %d"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 		 * Note we continue scheduling if for some reason 		 * incr_serial fails. 		 */
block|}
if|if
condition|(
name|zp
operator|->
name|z_soaincrintvl
operator|>
literal|0
condition|)
block|{
comment|/* We want automatic updates in this zone. */
if|if
condition|(
name|zp
operator|->
name|z_soaincrtime
operator|>
literal|0
condition|)
block|{
comment|/* Already scheduled. */
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"schedule_soa_update('%s'): already scheduled"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* First update since the soa was last incremented. */
name|zp
operator|->
name|z_updatecnt
operator|=
name|numupdated
expr_stmt|;
name|zp
operator|->
name|z_soaincrtime
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|zp
operator|->
name|z_soaincrintvl
expr_stmt|;
comment|/* 			 * Never schedule soaincrtime to occur after 			 * dumptime. 			 */
if|if
condition|(
name|zp
operator|->
name|z_soaincrtime
operator|>
name|zp
operator|->
name|z_dumptime
condition|)
name|zp
operator|->
name|z_soaincrtime
operator|=
name|zp
operator|->
name|z_dumptime
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"schedule_soa_update('%s'): scheduled for %lu"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_soaincrtime
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Figure out when a zone dump should happen.  * Returns non-zero if the caller should call sched_zone_maint(zp).  */
end_comment

begin_function
name|int
name|schedule_dump
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|time_t
name|half
decl_stmt|;
operator|(
name|void
operator|)
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_NEED_DUMP
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_dumpintvl
operator|>
literal|0
condition|)
block|{
comment|/* We want automatic dumping in this zone. */
if|if
condition|(
name|zp
operator|->
name|z_dumptime
operator|>
literal|0
condition|)
block|{
comment|/* Already scheduled. */
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"schedule_dump('%s'): already scheduled"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Set new dump time for dynamic zone.  Use a random 			 * number in the last half of the dump limit; we want 			 * it to be substantially correct while still 			 * preventing dump synchronization among various 			 * dynamic zones. 			 */
name|half
operator|=
operator|(
name|zp
operator|->
name|z_dumpintvl
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|zp
operator|->
name|z_dumptime
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|half
operator|+
operator|(
name|rand
argument_list|()
operator|%
name|half
operator|)
expr_stmt|;
comment|/* 			 * Never schedule soaincrtime to occur after 			 * dumptime. 			 */
if|if
condition|(
name|zp
operator|->
name|z_soaincrtime
operator|>
name|zp
operator|->
name|z_dumptime
condition|)
name|zp
operator|->
name|z_soaincrtime
operator|=
name|zp
operator|->
name|z_dumptime
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"schedule_dump('%s'): scheduled for %lu"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_dumptime
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * process_prereq(rec, rcodep)  *	Process one prerequisite.  * returns:  *>0 prerequisite was satisfied.  *	=0 prerequisite was not satisfied, or an error occurred.  * side effects:  *	sets *rcodep if an error occurs or prerequisite isn't satisfied.  */
end_comment

begin_function
specifier|static
name|int
name|process_prereq
parameter_list|(
name|ns_updrec
modifier|*
name|ur
parameter_list|,
name|int
modifier|*
name|rcodep
parameter_list|,
name|u_int16_t
name|zclass
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dname
init|=
name|ur
operator|->
name|r_dname
decl_stmt|;
name|u_int16_t
name|class
init|=
name|ur
operator|->
name|r_class
decl_stmt|;
name|u_int16_t
name|type
init|=
name|ur
operator|->
name|r_type
decl_stmt|;
name|u_int32_t
name|ttl
init|=
name|ur
operator|->
name|r_ttl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|rdp
init|=
name|ur
operator|->
name|r_dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
comment|/* 	 * An element in the list might have already been 	 * processed if it is in the same RRset as a previous 	 * RRset Exists (value dependent) prerequisite. 	 */
if|if
condition|(
name|rdp
operator|&&
operator|(
name|rdp
operator|->
name|d_mark
operator|&
name|D_MARK_FOUND
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* Already processed. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ttl
operator|!=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: ttl!=0 in prereq section"
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
condition|)
name|np
operator|=
name|NULL
expr_stmt|;
comment|/* Matching by wildcard not allowed here. */
if|if
condition|(
name|class
operator|==
name|C_ANY
condition|)
block|{
if|if
condition|(
name|rdp
operator|->
name|d_size
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: empty rdata required in prereq section with class=ANY"
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|T_ANY
condition|)
block|{
comment|/* Name is in use. */
name|ur
operator|->
name|r_opcode
operator|=
name|YXDOMAIN
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|np
operator|->
name|n_data
operator|==
name|NULL
condition|)
block|{
comment|/* 				 * Name does not exist or is 				 * an empty nonterminal. 				 */
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: %s not in use"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|NXDOMAIN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* RRset exists (value independent). */
name|int
name|found
init|=
literal|0
decl_stmt|;
name|ur
operator|->
name|r_opcode
operator|=
name|YXRRSET
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|&&
operator|!
name|found
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: RRset (%s,%s,%s) does not exist"
argument_list|,
name|dname
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|zclass
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|NXRRSET
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|C_NONE
condition|)
block|{
if|if
condition|(
name|rdp
operator|->
name|d_size
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: empty rdata required in prereq section with class=NONE"
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|T_ANY
condition|)
block|{
comment|/* Name is not in use. */
name|ur
operator|->
name|r_opcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
operator|&&
name|np
operator|->
name|n_data
operator|!=
name|NULL
condition|)
block|{
comment|/* 				 * Name exists and is not an 				 * empty nonterminal. 				 */
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: %s exists"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|YXDOMAIN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* RRset does not exist. */
name|int
name|found
init|=
literal|0
decl_stmt|;
name|ur
operator|->
name|r_opcode
operator|=
name|NXRRSET
expr_stmt|;
name|class
operator|=
name|zclass
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
condition|)
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|&&
operator|!
name|found
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: RRset (%s,%s) exists"
argument_list|,
name|dname
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|YXRRSET
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|zclass
condition|)
block|{
comment|/* 		 * RRset exists (value dependent). 		 * 		 * Check for RRset equality also. 		 */
name|ns_updrec
modifier|*
name|tmp
decl_stmt|;
name|ur
operator|->
name|r_opcode
operator|=
name|YXRRSET
expr_stmt|;
if|if
condition|(
operator|!
name|rdp
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: nonempty rdata required in prereq section with class=%s"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
operator|*
name|rcodep
operator|=
name|NXRRSET
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|int
name|found
init|=
literal|0
decl_stmt|;
for|for
control|(
name|tmp
operator|=
name|ur
init|;
name|tmp
operator|&&
operator|!
name|found
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|r_next
control|)
block|{
if|if
condition|(
name|tmp
operator|->
name|r_section
operator|!=
name|S_PREREQ
condition|)
break|break;
if|if
condition|(
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|tmp
operator|->
name|r_dp
argument_list|)
condition|)
block|{
name|tmp
operator|->
name|r_dp
operator|->
name|d_mark
operator||=
name|D_MARK_FOUND
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
operator|*
name|rcodep
operator|=
name|NXRRSET
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
for|for
control|(
name|tmp
operator|=
name|ur
init|;
name|tmp
condition|;
name|tmp
operator|=
name|tmp
operator|->
name|r_next
control|)
if|if
condition|(
name|tmp
operator|->
name|r_section
operator|==
name|S_PREREQ
operator|&&
operator|!
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|tmp
operator|->
name|r_dname
argument_list|)
operator|&&
name|tmp
operator|->
name|r_class
operator|==
name|class
operator|&&
name|tmp
operator|->
name|r_type
operator|==
name|type
operator|&&
operator|(
name|ur
operator|->
name|r_dp
operator|->
name|d_mark
operator|&
name|D_MARK_FOUND
operator|)
operator|==
literal|0
condition|)
block|{
operator|*
name|rcodep
operator|=
name|NXRRSET
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|tmp
operator|->
name|r_opcode
operator|=
name|YXRRSET
expr_stmt|;
block|}
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_prereq: incorrect class %s"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Through the gauntlet, and out. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * prescan_update(ur, rcodep)  *	Process one prerequisite.  * returns:  *>0 update looks OK (format wise; who knows if it will succeed?)  *	=0 update has something wrong with it.  * side effects:  *	sets *rcodep if an error occurs or prerequisite isn't satisfied.  */
end_comment

begin_function
specifier|static
name|int
name|prescan_update
parameter_list|(
name|ns_updrec
modifier|*
name|ur
parameter_list|,
name|int
modifier|*
name|rcodep
parameter_list|,
name|u_int16_t
name|zclass
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dname
init|=
name|ur
operator|->
name|r_dname
decl_stmt|;
name|u_int16_t
name|class
init|=
name|ur
operator|->
name|r_class
decl_stmt|;
name|u_int16_t
name|type
init|=
name|ur
operator|->
name|r_type
decl_stmt|;
name|u_int32_t
name|ttl
init|=
name|ur
operator|->
name|r_ttl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|rdp
init|=
name|ur
operator|->
name|r_dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
if|if
condition|(
name|class
operator|==
name|zclass
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|||
name|type
operator|==
name|T_AXFR
operator|||
name|type
operator|==
name|T_IXFR
operator|||
name|type
operator|==
name|T_MAILA
operator|||
name|type
operator|==
name|T_MAILB
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"prescan_update: invalid type (%s)"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|C_ANY
condition|)
block|{
if|if
condition|(
name|ttl
operator|!=
literal|0
operator|||
name|rdp
operator|->
name|d_size
operator|||
name|type
operator|==
name|T_AXFR
operator|||
name|type
operator|==
name|T_IXFR
operator|||
name|type
operator|==
name|T_MAILA
operator|||
name|type
operator|==
name|T_MAILB
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"prescan_update: formerr(#2)"
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|C_NONE
condition|)
block|{
if|if
condition|(
name|ttl
operator|!=
literal|0
operator|||
name|type
operator|==
name|T_ANY
operator|||
name|type
operator|==
name|T_AXFR
operator|||
name|type
operator|==
name|T_IXFR
operator|||
name|type
operator|==
name|T_MAILA
operator|||
name|type
operator|==
name|T_MAILB
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"prescan_update: formerr(#3)"
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"prescan_update: invalid class (%s)"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* No format errors found. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * process_updates(firstp, rcodep, from)  *	Process prerequisites and apply updates from the list to the database.  * returns:  *	number of successful updates, 0 if none were successful.  * side effects:  *	*rcodep gets the transaction return code.  *	can schedule maintainance for zone dumps and soa.serial# increments.  */
end_comment

begin_function
specifier|static
name|int
name|process_updates
parameter_list|(
name|ns_updrec
modifier|*
name|firstp
parameter_list|,
name|int
modifier|*
name|rcodep
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|,
name|dbflags
decl_stmt|,
name|matches
decl_stmt|,
name|zonenum
decl_stmt|;
name|int
name|numupdated
init|=
literal|0
decl_stmt|,
name|soaupdated
init|=
literal|0
decl_stmt|,
name|schedmaint
init|=
literal|0
decl_stmt|;
name|u_int16_t
name|zclass
decl_stmt|;
name|ns_updrec
modifier|*
name|ur
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|savedp
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|int
name|zonelist
index|[
name|MAXDNAME
index|]
decl_stmt|;
operator|*
name|rcodep
operator|=
name|SERVFAIL
expr_stmt|;
if|if
condition|(
operator|!
name|firstp
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|firstp
operator|->
name|r_section
operator|==
name|S_ZONE
condition|)
block|{
name|zclass
operator|=
name|firstp
operator|->
name|r_class
expr_stmt|;
name|zonenum
operator|=
name|firstp
operator|->
name|r_zone
expr_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|zonenum
index|]
expr_stmt|;
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_updates: missing zone record"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Process prereq records and prescan update records. */
for|for
control|(
name|ur
operator|=
name|firstp
init|;
name|ur
operator|!=
name|NULL
condition|;
name|ur
operator|=
name|ur
operator|->
name|r_next
control|)
block|{
specifier|const
name|char
modifier|*
name|dname
init|=
name|ur
operator|->
name|r_dname
decl_stmt|;
name|u_int16_t
name|class
init|=
name|ur
operator|->
name|r_class
decl_stmt|;
name|u_int16_t
name|type
init|=
name|ur
operator|->
name|r_type
decl_stmt|;
name|u_int32_t
name|ttl
init|=
name|ur
operator|->
name|r_ttl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|rdp
init|=
name|ur
operator|->
name|r_dp
decl_stmt|;
name|u_int
name|section
init|=
name|ur
operator|->
name|r_section
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"process_update: record section=%s, dname=%s, \ class=%s, type=%s, ttl=%d, dp=0x%0x"
argument_list|,
name|p_section
argument_list|(
name|section
argument_list|,
name|ns_o_update
argument_list|)
argument_list|,
name|dname
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|rdp
argument_list|)
expr_stmt|;
name|matches
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|zclass
argument_list|,
name|MAXDNAME
argument_list|,
name|zonelist
argument_list|,
name|MAXDNAME
argument_list|)
expr_stmt|;
name|ur
operator|->
name|r_zone
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|matches
operator|&&
operator|!
name|ur
operator|->
name|r_zone
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|zonelist
index|[
name|j
index|]
operator|==
name|zonenum
condition|)
name|ur
operator|->
name|r_zone
operator|=
name|zonelist
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|ur
operator|->
name|r_zone
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_updates: record does not belong to the zone %s"
argument_list|,
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
operator|*
name|rcodep
operator|=
name|NOTZONE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
switch|switch
condition|(
name|section
condition|)
block|{
case|case
name|S_ZONE
case|:
break|break;
case|case
name|S_PREREQ
case|:
if|if
condition|(
operator|!
name|process_prereq
argument_list|(
name|ur
argument_list|,
name|rcodep
argument_list|,
name|zclass
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* *rcodep has been set. */
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"prerequisite satisfied"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_UPDATE
case|:
if|if
condition|(
operator|!
name|prescan_update
argument_list|(
name|ur
argument_list|,
name|rcodep
argument_list|,
name|zclass
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* *rcodep has been set. */
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"update prescan succeeded"
argument_list|)
expr_stmt|;
break|break;
case|case
name|S_ADDT
case|:
break|break;
default|default:
name|ns_panic
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"process_updates: impossible section"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
comment|/* Now process the records in update section. */
for|for
control|(
name|ur
operator|=
name|firstp
init|;
name|ur
operator|!=
name|NULL
condition|;
name|ur
operator|=
name|ur
operator|->
name|r_next
control|)
block|{
specifier|const
name|char
modifier|*
name|dname
init|=
name|ur
operator|->
name|r_dname
decl_stmt|;
name|u_int16_t
name|class
init|=
name|ur
operator|->
name|r_class
decl_stmt|;
if|if
condition|(
name|ur
operator|->
name|r_section
operator|!=
name|S_UPDATE
condition|)
continue|continue;
name|dbflags
operator|=
literal|0
expr_stmt|;
name|savedp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|ur
operator|->
name|r_dp
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|zp
operator|->
name|z_class
condition|)
block|{
comment|/* ADD databuf dp to hash table */
comment|/* 			 * Handling of various SOA/WKS/CNAME scenarios 			 * is done in db_update(). 			 */
name|ur
operator|->
name|r_opcode
operator|=
name|ADD
expr_stmt|;
name|dbflags
operator||=
name|DB_NODATA
expr_stmt|;
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
operator|&
name|savedp
argument_list|,
name|dbflags
argument_list|,
name|hashtab
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"process_updates: failed to add databuf (%d)"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"process_updates: added databuf 0x%0x"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_mark
operator|=
name|D_MARK_ADDED
expr_stmt|;
name|numupdated
operator|++
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
name|soaupdated
operator|=
literal|1
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|class
operator|==
name|C_ANY
operator|||
name|class
operator|==
name|C_NONE
condition|)
block|{
comment|/* 			 * DELETE databuf's matching dp from the hash table. 			 * 			 * handling of various SOA/NS scenarios done 			 * in db_update(). 			 */
name|ur
operator|->
name|r_opcode
operator|=
name|DELETE
expr_stmt|;
comment|/* 			 * we know we're deleting now, and db_update won't 			 * match with class==C_NONE, so we use the zone's 			 * class. 			 */
if|if
condition|(
name|class
operator|==
name|C_NONE
condition|)
name|ur
operator|->
name|r_dp
operator|->
name|d_class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|dbflags
operator||=
name|DB_DELETE
expr_stmt|;
name|n
operator|=
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
operator|&
name|savedp
argument_list|,
name|dbflags
argument_list|,
name|hashtab
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|OK
condition|)
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"process_updates: delete failed"
argument_list|)
expr_stmt|;
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"process_updates: delete succeeded"
argument_list|)
expr_stmt|;
name|numupdated
operator|++
expr_stmt|;
block|}
block|}
comment|/* 		 * Even an addition could have caused some deletions like 		 * replacing old SOA or CNAME or WKS record or records of 		 * lower cred/clev. 		 * 		 * We need to save the deleted databuf's in case we wish to 		 * abort this update transaction and roll back all updates 		 * applied from this packet. 		 */
name|ur
operator|->
name|r_deldp
operator|=
name|savedp
expr_stmt|;
block|}
comment|/* 	 * If we got here, things are OK, so set rcodep to indicate so. 	 */
operator|*
name|rcodep
operator|=
name|NOERROR
expr_stmt|;
if|if
condition|(
operator|!
name|numupdated
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * schedule maintenance for dumps and SOA.serial# increment  	 * (this also sets Z_NEED_DUMP and Z_NEED_SOAUPDATE appropriately) 	 */
name|schedmaint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|schedule_dump
argument_list|(
name|zp
argument_list|)
condition|)
name|schedmaint
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|soaupdated
condition|)
block|{
comment|/* 		 * SOA updated by this update transaction, so 		 * we need to set the zone serial number, stop any 		 * automatic updates that may be pending, and send out 		 * a NOTIFY message. 		 */
name|zp
operator|->
name|z_serial
operator|=
name|get_serial_unchecked
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|cancel_soa_update
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|schedmaint
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
operator|!
name|loading
condition|)
name|sysnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|T_SOA
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|if
condition|(
name|schedule_soa_update
argument_list|(
name|zp
argument_list|,
name|numupdated
argument_list|)
condition|)
name|schedmaint
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|schedmaint
condition|)
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
return|return
operator|(
name|numupdated
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|enum
name|req_action
name|req_update_private
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|int
name|dfd
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|char
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
modifier|*
name|dname
decl_stmt|;
name|u_int
name|zocount
decl_stmt|,
name|prcount
decl_stmt|,
name|upcount
decl_stmt|,
name|adcount
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|cnt
decl_stmt|,
name|found
decl_stmt|,
name|matches
decl_stmt|,
name|zonenum
decl_stmt|,
name|numupdated
init|=
literal|0
decl_stmt|;
name|int
name|rcode
init|=
name|NOERROR
decl_stmt|;
name|u_int
name|c
decl_stmt|,
name|section
decl_stmt|;
name|u_char
name|rdata
index|[
name|MAXDATA
index|]
decl_stmt|;
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
init|=
operator|&
name|nsp
index|[
literal|0
index|]
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|ns_updrec
modifier|*
name|rrecp
decl_stmt|;
name|int
name|zonelist
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|should_use_tcp
decl_stmt|;
name|u_int32_t
name|old_serial
decl_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|zocount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|prcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|upcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|adcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
comment|/* Process zone section. */
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"req_update: section ZONE, count %d"
argument_list|,
name|zocount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: too short"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zocount
operator|!=
literal|1
operator|||
name|type
operator|!=
name|T_SOA
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: incorrect count or type for zone section: %d"
argument_list|,
name|zocount
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|matches
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|zonelist
argument_list|,
name|MAXDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
operator|==
literal|1
condition|)
block|{
name|zonenum
operator|=
name|zonelist
index|[
literal|0
index|]
expr_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|zonenum
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_class
operator|!=
operator|(
name|int
operator|)
name|class
operator|||
operator|(
name|zp
operator|->
name|z_type
operator|!=
name|z_master
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|z_slave
operator|)
condition|)
name|matches
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|matches
operator|!=
literal|1
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: non-authoritative server for %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTAUTH
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* 	 * Begin Access Control Point 	 */
if|if
condition|(
operator|!
name|ip_address_allowed
argument_list|(
name|zp
operator|->
name|z_update_acl
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_security
argument_list|,
literal|"unapproved update from %s for %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
comment|/* 	 * End Access Control Point 	 */
comment|/* XXXVIX should check update key when we have one. */
comment|/* we should be authoritative */
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_AUTH
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: zone %s: Z_AUTH not set"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTAUTH
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
condition|)
block|{
comment|/* 		 * XXX the code below is broken.  Until fixed, we just 		 * refuse. 		 */
return|return
operator|(
name|Refuse
operator|)
return|;
comment|/* We are a slave for this zone, forward it to the master. */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|cnt
operator|++
control|)
operator|*
name|nspp
operator|++
operator|=
name|savedata
argument_list|(
name|zp
operator|->
name|z_class
argument_list|,
name|T_A
argument_list|,
name|USE_MINIMUM
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_addr
index|[
name|cnt
index|]
operator|.
name|s_addr
argument_list|,
name|INT32SZ
argument_list|)
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
comment|/* 		 * If the request came in over TCP, forward it over TCP 		 */
name|should_use_tcp
operator|=
operator|(
name|qsp
operator|!=
name|NULL
operator|)
expr_stmt|;
name|n
operator|=
name|ns_forw
argument_list|(
name|nsp
argument_list|,
name|msg
argument_list|,
name|eom
operator|-
name|msg
argument_list|,
name|from
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
operator|&
name|qp
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
name|should_use_tcp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|FW_OK
case|:
case|case
name|FW_DUP
case|:
return|return
operator|(
name|Return
operator|)
return|;
case|case
name|FW_NOSERVER
case|:
comment|/* should not happen */
case|case
name|FW_SERVFAIL
case|:
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
comment|/* 	 * We are the primary master server for this zone, 	 * proceed further and process update packet 	 */
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: dynamic flag not set for zone %s"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
return|return
operator|(
name|Refuse
operator|)
return|;
block|}
name|old_serial
operator|=
name|get_serial
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"req_update: update request for zone %s, class %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|rrecp_start
operator|=
name|res_mkupdrec
argument_list|(
name|S_ZONE
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|rrecp_start
operator|->
name|r_zone
operator|=
name|zonenum
expr_stmt|;
name|rrecp_start
operator|->
name|r_prev
operator|=
name|NULL
expr_stmt|;
name|rrecp_start
operator|->
name|r_next
operator|=
name|NULL
expr_stmt|;
name|rrecp_last
operator|=
name|rrecp_start
expr_stmt|;
comment|/* 	 * Parse the prerequisite and update sections for format errors. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|i
operator|<
name|prcount
operator|+
name|upcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|dnbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|dnbuf
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: expand name failed"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|RRFIXEDSZ
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: overrun in answer"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dlen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|cp
operator|+
name|dlen
operator|>
name|eom
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: bad dlen"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|n
operator|=
name|rdata_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|type
argument_list|,
name|dlen
argument_list|,
name|rdata
argument_list|,
sizeof|sizeof
name|rdata
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|||
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"req_update: failed to expand record"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
name|section
operator|=
operator|(
operator|(
name|u_int
operator|)
name|i
operator|<
name|prcount
operator|)
condition|?
name|S_PREREQ
else|:
name|S_UPDATE
expr_stmt|;
name|rrecp
operator|=
name|res_mkupdrec
argument_list|(
name|section
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|rdata
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_ZONE
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|nlabels
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
comment|/* XXX - also record in dp->d_ns, which host this came from */
name|rrecp
operator|->
name|r_dp
operator|=
name|dp
expr_stmt|;
comment|/* Append the current record to the end of list of records. */
name|rrecp_last
operator|->
name|r_next
operator|=
name|rrecp
expr_stmt|;
name|rrecp
operator|->
name|r_prev
operator|=
name|rrecp_last
expr_stmt|;
name|rrecp
operator|->
name|r_next
operator|=
name|NULL
expr_stmt|;
name|rrecp_last
operator|=
name|rrecp
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_update
argument_list|,
literal|"Malformed response from %s (overrun)"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
block|}
comment|/* Now process all parsed records in the prereq and update sections. */
name|numupdated
operator|=
name|process_updates
argument_list|(
name|rrecp_start
argument_list|,
operator|&
name|rcode
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|rcode
expr_stmt|;
if|if
condition|(
name|numupdated
operator|<=
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"error processing update packet id %d from %s"
argument_list|,
name|hp
operator|->
name|id
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
comment|/* Make a log of the update. */
operator|(
name|void
operator|)
name|printupdatelog
argument_list|(
name|from
argument_list|,
name|rrecp_start
argument_list|,
name|hp
argument_list|,
name|zp
argument_list|,
name|old_serial
argument_list|)
expr_stmt|;
return|return
operator|(
name|Finish
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_rrecp
parameter_list|(
name|ns_updrec
modifier|*
modifier|*
name|startpp
parameter_list|,
name|ns_updrec
modifier|*
modifier|*
name|lastpp
parameter_list|,
name|int
name|rcode
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|ns_updrec
modifier|*
name|rrecp
decl_stmt|,
modifier|*
name|first_rrecp
decl_stmt|,
modifier|*
name|next_rrecp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tmpdp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|msg
decl_stmt|;
name|REQUIRE
argument_list|(
name|startpp
operator|!=
name|NULL
operator|&&
name|lastpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|NOERROR
condition|)
block|{
name|first_rrecp
operator|=
operator|*
name|startpp
expr_stmt|;
name|msg
operator|=
literal|"free_rrecp: update transaction succeeded, cleaning up"
expr_stmt|;
block|}
else|else
block|{
name|first_rrecp
operator|=
operator|*
name|lastpp
expr_stmt|;
name|msg
operator|=
literal|"free_rrecp: update transaction aborted, rolling back"
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
name|msg
argument_list|)
expr_stmt|;
for|for
control|(
name|rrecp
operator|=
name|first_rrecp
init|;
name|rrecp
operator|!=
name|NULL
condition|;
name|rrecp
operator|=
name|next_rrecp
control|)
block|{
if|if
condition|(
name|rcode
operator|==
name|NOERROR
condition|)
name|next_rrecp
operator|=
name|rrecp
operator|->
name|r_next
expr_stmt|;
else|else
name|next_rrecp
operator|=
name|rrecp
operator|->
name|r_prev
expr_stmt|;
if|if
condition|(
name|rrecp
operator|->
name|r_section
operator|!=
name|S_UPDATE
condition|)
block|{
if|if
condition|(
name|rrecp
operator|->
name|r_dp
condition|)
name|db_freedata
argument_list|(
name|rrecp
operator|->
name|r_dp
argument_list|)
expr_stmt|;
name|res_freeupdrec
argument_list|(
name|rrecp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dname
operator|=
name|rrecp
operator|->
name|r_dname
expr_stmt|;
name|dp
operator|=
name|rrecp
operator|->
name|r_dp
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|->
name|d_mark
operator|&
name|D_MARK_ADDED
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|rcode
operator|==
name|NOERROR
condition|)
block|{
comment|/* 				 * This databuf is now a part of hashtab, 				 * or has been deleted by a subsequent update. 				 * Either way, we must not free it. 				 */
name|dp
operator|->
name|d_mark
operator|&=
operator|~
name|D_MARK_ADDED
expr_stmt|;
block|}
else|else
block|{
comment|/* Delete the databuf. */
if|if
condition|(
name|db_update
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|,
name|from
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"free_rrecp: failed to delete databuf: dname=%s, type=%s"
argument_list|,
name|dname
argument_list|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"free_rrecp: deleted databuf 0x%0x"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/*  					 * XXXRTH  					 * 					 * We used to db_freedata() here, 					 * but I removed it because 'dp' was 					 * part of a hashtab before we called 					 * db_update(), and since our delete 					 * has succeeded, it should have been 					 * freed. 					 */
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * Databuf's matching this were deleted by this 			 * update, or were never executed (because we bailed 			 * out early). 			 */
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
comment|/* Process deleted databuf's. */
name|dp
operator|=
name|rrecp
operator|->
name|r_deldp
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
name|tmpdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
if|if
condition|(
name|rcode
operator|==
name|NOERROR
condition|)
block|{
if|if
condition|(
name|tmpdp
operator|->
name|d_rcnt
condition|)
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"free_rrecp: type = %d, rcnt = %d"
argument_list|,
name|p_type
argument_list|(
name|tmpdp
operator|->
name|d_type
argument_list|)
argument_list|,
name|tmpdp
operator|->
name|d_rcnt
argument_list|)
expr_stmt|;
else|else
block|{
name|tmpdp
operator|->
name|d_next
operator|=
name|NULL
expr_stmt|;
name|db_freedata
argument_list|(
name|tmpdp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Add the databuf back. */
name|tmpdp
operator|->
name|d_mark
operator|&=
operator|~
name|D_MARK_DELETED
expr_stmt|;
if|if
condition|(
name|db_update
argument_list|(
name|dname
argument_list|,
name|tmpdp
argument_list|,
name|tmpdp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|hashtab
argument_list|,
name|from
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"free_rrecp: failed to add back databuf: dname=%s, type=%s"
argument_list|,
name|dname
argument_list|,
name|p_type
argument_list|(
name|tmpdp
operator|->
name|d_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"free_rrecp: added back databuf 0x%0x"
argument_list|,
name|tmpdp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|res_freeupdrec
argument_list|(
name|rrecp
argument_list|)
expr_stmt|;
block|}
operator|*
name|startpp
operator|=
name|NULL
expr_stmt|;
operator|*
name|lastpp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|enum
name|req_action
name|req_update
parameter_list|(
name|HEADER
modifier|*
name|hp
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|int
name|dfd
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|enum
name|req_action
name|ret
decl_stmt|;
name|ret
operator|=
name|req_update_private
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|eom
argument_list|,
name|msg
argument_list|,
name|qsp
argument_list|,
name|dfd
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|free_rrecp
argument_list|(
operator|&
name|rrecp_start
argument_list|,
operator|&
name|rrecp_last
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|Finish
condition|)
block|{
name|hp
operator|->
name|qdcount
operator|=
name|hp
operator|->
name|ancount
operator|=
name|hp
operator|->
name|nscount
operator|=
name|hp
operator|->
name|arcount
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|msg
operator|+
name|HFIXEDSZ
argument_list|,
literal|0
argument_list|,
operator|(
name|eom
operator|-
name|msg
operator|)
operator|-
name|HFIXEDSZ
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * expand rdata portion of a compressed resource record at cp into cp1  * and return the length of the expanded rdata (length of the compressed  * rdata is "dlen").  */
end_comment

begin_function
specifier|static
name|int
name|rdata_expand
parameter_list|(
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
specifier|const
name|u_char
modifier|*
name|eom
parameter_list|,
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_int
name|type
parameter_list|,
name|size_t
name|dlen
parameter_list|,
name|u_char
modifier|*
name|cp1
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|cpinit
init|=
name|cp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp1init
init|=
name|cp1
decl_stmt|;
name|int
name|n
decl_stmt|,
name|i
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
name|dlen
operator|!=
name|INT32SZ
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/*FALLTHROUGH*/
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_NSAP
case|:
case|case
name|T_LOC
case|:
if|if
condition|(
name|size
operator|<
name|dlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|dlen
operator|)
return|;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
operator|(
name|u_int
operator|)
name|n
operator|!=
name|dlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
operator|)
return|;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
comment|/* Get two compressed domain names. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|size
operator|-=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|n
operator|=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|size
operator|<
operator|(
name|size_t
operator|)
name|n
operator|||
name|cp
operator|+
name|n
operator|>
name|eom
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|-=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|cpinit
operator|+
name|dlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cp1
operator|-
name|cp1init
operator|)
return|;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
comment|/* Grab preference. */
if|if
condition|(
name|size
operator|<
name|INT16SZ
operator|||
name|cp
operator|+
name|INT16SZ
operator|>
name|eom
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|-=
name|INT16SZ
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SRV
condition|)
block|{
if|if
condition|(
name|size
operator|<
name|INT16SZ
operator|*
literal|2
operator|||
name|cp
operator|+
name|INT16SZ
operator|*
literal|2
operator|>
name|eom
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|-=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
comment|/* Grab weight and port. */
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
block|}
comment|/* Get name. */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|cpinit
operator|+
name|dlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cp1
operator|-
name|cp1init
operator|)
return|;
case|case
name|T_PX
case|:
comment|/* Grab preference. */
if|if
condition|(
name|size
operator|<
name|INT16SZ
operator|||
name|cp
operator|+
name|INT16SZ
operator|>
name|eom
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|size
operator|-=
name|INT16SZ
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* Get MAP822 name. */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
name|size
operator|-=
name|n
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|cpinit
operator|+
name|dlen
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|cp1
operator|-
name|cp1init
operator|)
return|;
default|default:
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"unknown type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Print out rdata portion of a resource record from a databuf into a file.  *  * XXX - similar code in db_dump() should be replaced by a call to this  * function.  */
end_comment

begin_function
name|void
name|rdata_dump
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|u_int32_t
name|n
decl_stmt|,
name|addr
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_A
case|:
switch|switch
condition|(
name|dp
operator|->
name|d_class
condition|)
block|{
case|case
name|C_IN
case|:
case|case
name|C_HS
case|:
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|htonl
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|n
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|dp
operator|->
name|d_nstime
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|";\tNT=%d"
argument_list|,
name|dp
operator|->
name|d_nstime
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|".\t"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
case|case
name|T_ISDN
case|:
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\"%.*s\""
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" \"%.*s\""
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" \"\""
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s. ( "
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RETURNSOA
argument_list|)
operator|&&
name|defined
argument_list|(
name|NCACHE
argument_list|)
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
name|fputs
argument_list|(
literal|";"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %u )"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|RETURNSOA
argument_list|)
operator|&&
name|defined
argument_list|(
name|NCACHE
argument_list|)
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|";%s.;NXDOMAIN;\t-$"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%u"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
name|end
operator|=
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
operator|+
name|dp
operator|->
name|d_size
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|end
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|j
operator|=
name|n
init|;
name|j
operator|>
literal|0
operator|&&
name|cp
operator|<
name|end
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* XXXVIX need to keep the segmentation (see 4.9.5). */
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\""
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NSAP
case|:
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|inet_nsap_ntoa
argument_list|(
name|dp
operator|->
name|d_size
argument_list|,
name|dp
operator|->
name|d_data
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_LOC
case|:
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|loc_ntoa
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_WKS
case|:
name|GETLONG
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addr
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|proto
operator|=
name|protocolname
argument_list|(
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s "
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
operator|(
name|u_char
operator|*
operator|)
name|dp
operator|->
name|d_data
operator|+
name|dp
operator|->
name|d_size
condition|)
block|{
name|j
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|j
operator|&
literal|0200
condition|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s"
argument_list|,
name|servicename
argument_list|(
name|i
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|&
literal|07
condition|)
do|;
block|}
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|" %s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"\t;?d_type=%d?"
argument_list|,
name|dp
operator|->
name|d_type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the number of authoritative zones that "dname" could belong to by  * stripping up to "depth" labels from dname.  Up to the first "maxzones"  * authoritative zone numbers will be stored in "zonelist", ordered  * deepest match first.  */
end_comment

begin_function
specifier|static
name|int
name|findzone
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|depth
parameter_list|,
name|int
modifier|*
name|zonelist
parameter_list|,
name|int
name|maxzones
parameter_list|)
block|{
name|char
modifier|*
name|tmpdname
decl_stmt|;
name|char
name|tmpdnamebuf
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
modifier|*
name|zonename
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|tmpdnamelen
decl_stmt|,
name|zonenamelen
decl_stmt|,
name|zonenum
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|c
decl_stmt|;
name|int
name|matches
init|=
literal|0
decl_stmt|;
name|int
name|escaped
decl_stmt|,
name|found
decl_stmt|,
name|done
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|4
argument_list|,
literal|"findzone(dname=%s, class=%d, depth=%d, \ zonelist=0x%x, maxzones=%d)"
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|depth
argument_list|,
name|zonelist
argument_list|,
name|maxzones
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|5
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|5
argument_list|,
literal|"zone dump:"
argument_list|)
expr_stmt|;
for|for
control|(
name|zonenum
operator|=
literal|1
init|;
name|zonenum
operator|<
name|nzones
condition|;
name|zonenum
operator|++
control|)
name|printzoneinfo
argument_list|(
name|zonenum
argument_list|,
name|ns_log_update
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|strcpy
argument_list|(
name|tmpdnamebuf
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|tmpdname
operator|=
name|tmpdnamebuf
expr_stmt|;
comment|/* 	 * The code to handle trailing dots and escapes is adapted 	 * from samedomain(). 	 */
name|tmpdnamelen
operator|=
name|strlen
argument_list|(
name|tmpdname
argument_list|)
expr_stmt|;
comment|/*  	 * Ignore a trailing label separator (i.e. an unescaped dot) 	 * in 'tmpdname'. 	 */
if|if
condition|(
name|tmpdnamelen
operator|&&
name|tmpdname
index|[
name|tmpdnamelen
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|escaped
operator|=
literal|0
expr_stmt|;
comment|/* note this loop doesn't get executed if tmpdnamelen==1 */
for|for
control|(
name|j
operator|=
name|tmpdnamelen
operator|-
literal|2
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|tmpdname
index|[
name|j
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
name|escaped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|escaped
condition|)
block|{
name|tmpdnamelen
operator|--
expr_stmt|;
name|tmpdname
index|[
name|tmpdnamelen
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
for|for
control|(
name|done
operator|=
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|depth
operator|&&
operator|!
name|done
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|zonenum
operator|=
literal|1
init|;
name|zonenum
operator|<
name|nzones
condition|;
name|zonenum
operator|++
control|)
block|{
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_type
operator|==
name|z_nil
condition|)
continue|continue;
if|if
condition|(
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_class
operator|!=
name|class
condition|)
continue|continue;
name|zonename
operator|=
name|zones
index|[
name|zonenum
index|]
operator|.
name|z_origin
expr_stmt|;
name|zonenamelen
operator|=
name|strlen
argument_list|(
name|zonename
argument_list|)
expr_stmt|;
comment|/*  			 * Ignore a trailing label separator  			 * (i.e. an unescaped dot) in 'zonename'. 			 */
if|if
condition|(
name|zonenamelen
operator|&&
name|zonename
index|[
name|zonenamelen
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
name|escaped
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|zonenamelen
operator|-
literal|2
init|;
name|j
operator|>=
literal|0
condition|;
name|j
operator|--
control|)
if|if
condition|(
name|zonename
index|[
name|j
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
name|escaped
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|escaped
condition|)
name|zonenamelen
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|tmpdnamelen
operator|!=
name|zonenamelen
condition|)
continue|continue;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|5
argument_list|,
literal|"about to strncasecmp('%s', '%s', %d)"
argument_list|,
name|tmpdname
argument_list|,
name|zonename
argument_list|,
name|tmpdnamelen
argument_list|)
expr_stmt|;
comment|/* XXXRTH I'm doing a special test for zonenamelen == 0 			   because I worry that some implementations of  			   strncasecmp might not handle comparisions where 			   n==0 correctly */
if|if
condition|(
name|zonenamelen
operator|==
literal|0
operator|||
operator|!
name|strncasecmp
argument_list|(
name|tmpdname
argument_list|,
name|zonename
argument_list|,
name|tmpdnamelen
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|5
argument_list|,
literal|"match"
argument_list|)
expr_stmt|;
name|zonelist
index|[
name|matches
operator|++
index|]
operator|=
name|zonenum
expr_stmt|;
if|if
condition|(
name|matches
operator|==
name|maxzones
condition|)
block|{
comment|/* XXX should signal error */
return|return
operator|(
name|matches
operator|)
return|;
block|}
block|}
block|}
comment|/* 		 * Strip off the first label if we're not already at 		 * the root label. 		 */
if|if
condition|(
operator|*
name|tmpdname
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|escaped
operator|=
name|found
operator|=
literal|0
init|;
operator|(
name|c
operator|=
operator|*
name|tmpdname
operator|)
operator|&&
operator|!
name|found
condition|;
name|tmpdname
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
name|c
operator|==
literal|'.'
operator|)
condition|)
comment|/* 					 * Note the loop increment will 					 * make tmpdname point past the '.' 					 * before the '!found' test causes 					 * us to exit the loop. 					 */
name|found
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
block|}
block|}
else|else
name|done
operator|=
literal|1
expr_stmt|;
name|tmpdnamelen
operator|=
name|strlen
argument_list|(
name|tmpdname
argument_list|)
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|4
argument_list|,
literal|"findzone: returning %d match(es)"
argument_list|,
name|matches
argument_list|)
expr_stmt|;
return|return
operator|(
name|matches
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * reapply lost updates from log file for the zone to the zone  *  * returns -1 on error, 0 on success, 1 if dump reload needed  */
end_comment

begin_function
name|int
name|merge_logs
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|char
name|origin
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|data
index|[
name|MAXDATA
index|]
decl_stmt|,
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|sclass
index|[
literal|3
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|buf2
index|[
literal|100
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|,
name|ttl
decl_stmt|,
name|old_serial
decl_stmt|,
name|new_serial
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|section
decl_stmt|,
name|opcode
decl_stmt|,
name|matches
decl_stmt|,
name|zonenum
decl_stmt|,
name|err
decl_stmt|,
name|multiline
decl_stmt|;
name|int
name|nonempty_lineno
init|=
operator|-
literal|1
decl_stmt|,
name|prev_pktdone
init|=
literal|0
decl_stmt|,
name|cont
init|=
literal|0
decl_stmt|,
name|inside_next
init|=
literal|0
decl_stmt|;
name|int
name|id
decl_stmt|,
name|rcode
init|=
name|NOERROR
decl_stmt|;
name|u_int32_t
name|n
decl_stmt|;
name|struct
name|map
modifier|*
name|mp
decl_stmt|;
name|ns_updrec
modifier|*
name|rrecp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|int
name|zonelist
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|u_char
modifier|*
name|serialp
decl_stmt|;
name|struct
name|sockaddr_in
name|empty_from
decl_stmt|;
name|int
name|datasize
decl_stmt|;
name|empty_from
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|empty_from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|empty_from
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX - much of this stuff is similar to that in nsupdate.c 	 * getword_str() was used in nsupdate.c for reasons described there 	 * getword() is used here just to be consistent with db_load() 	 */
comment|/* If there is no log file, just return. */
if|if
condition|(
name|stat
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"unexpected stat(%s) failure: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fp
operator|=
name|fopen
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fopen(%s) failed: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * See if we really have a log file -- it might be a zone dump 	 * that was in the process of being renamed, or it might 	 * be garbage! 	 */
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fgets() from %s failed: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|DumpSignature
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* It's a dump; finish rename that was interrupted. */
name|ns_info
argument_list|(
name|ns_log_update
argument_list|,
literal|"completing interrupted dump rename for %s"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"rename(%s,%s) failed: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|zp
operator|->
name|z_source
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Finally, tell caller to reload zone. */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|LogSignature
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Not a dump and not a log; complain and then bail out. */
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"invalid log file %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|3
argument_list|,
literal|"merging logs for %s from %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|rrecp_start
operator|=
name|NULL
expr_stmt|;
name|rrecp_last
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|lineno
operator|==
operator|(
name|nonempty_lineno
operator|+
literal|1
operator|)
condition|)
block|{
comment|/* 				 * End of a nonempty line inside an update 				 * packet or not inside an update packet. 				 */
continue|continue;
block|}
comment|/* 			 * Empty line or EOF. 			 * 			 * Marks completion of current update packet. 			 */
name|inside_next
operator|=
literal|0
expr_stmt|;
name|prev_pktdone
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nonempty_lineno
operator|=
name|lineno
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[DYNAMIC_UPDATE]"
argument_list|)
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|!
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"id %d"
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|id
operator|=
operator|-
literal|1
expr_stmt|;
name|inside_next
operator|=
literal|1
expr_stmt|;
name|prev_pktdone
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[INCR_SERIAL]"
argument_list|)
condition|)
block|{
comment|/* XXXRTH not enough error checking here */
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|!
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"from %u to %u"
argument_list|,
operator|&
name|old_serial
argument_list|,
operator|&
name|new_serial
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"incr_serial problem with %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serial
operator|=
name|get_serial
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial
operator|!=
name|old_serial
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"serial number mismatch (log=%u, zone=%u) in %s"
argument_list|,
name|old_serial
argument_list|,
name|serial
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_serial
argument_list|(
name|zp
argument_list|,
name|new_serial
argument_list|)
expr_stmt|;
comment|/* 					 * The zone has changed; make sure 					 * a dump is scheduled. 					 */
operator|(
name|void
operator|)
name|schedule_dump
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_update
argument_list|,
literal|"set serial to %u (log file %s)"
argument_list|,
name|new_serial
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
block|}
block|}
name|prev_pktdone
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|prev_pktdone
condition|)
block|{
if|if
condition|(
name|rrecp_start
condition|)
block|{
name|n
operator|=
name|process_updates
argument_list|(
name|rrecp_start
argument_list|,
operator|&
name|rcode
argument_list|,
name|empty_from
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_update
argument_list|,
literal|"successfully merged update id %d from log file %s"
argument_list|,
name|id
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
else|else
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"error merging update id %d from log file %s"
argument_list|,
name|id
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|free_rrecp
argument_list|(
operator|&
name|rrecp_start
argument_list|,
operator|&
name|rrecp_last
argument_list|,
name|rcode
argument_list|,
name|empty_from
argument_list|)
expr_stmt|;
block|}
name|prev_pktdone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|cont
condition|)
block|{
name|cont
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|inside_next
condition|)
continue|continue;
comment|/* 		 * inside the same update packet, 		 * continue accumulating records. 		 */
name|section
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|buf
index|[
operator|--
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m_section
init|;
name|mp
operator|<
name|m_section
operator|+
name|M_SECTION_CNT
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
name|mp
operator|->
name|token
argument_list|)
condition|)
block|{
name|section
operator|=
name|mp
operator|->
name|val
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
literal|0
expr_stmt|;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|section
condition|)
block|{
case|case
name|S_ZONE
case|:
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"origin %s class %s serial %ul"
argument_list|,
name|origin
argument_list|,
name|sclass
argument_list|,
operator|&
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|3
operator|||
name|strcasecmp
argument_list|(
name|origin
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
condition|)
name|err
operator|++
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|serial
operator|!=
name|zp
operator|->
name|z_serial
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"serial number mismatch in update id %d (log=%u, zone=%u) in %s"
argument_list|,
name|id
argument_list|,
name|serial
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|inside_next
operator|=
literal|0
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|err
operator|&&
name|inside_next
condition|)
block|{
name|int
name|success
decl_stmt|;
name|dname
operator|=
name|origin
expr_stmt|;
name|type
operator|=
name|T_SOA
expr_stmt|;
name|class
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
name|sclass
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|matches
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|zonelist
argument_list|,
name|MAXDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
condition|)
name|zonenum
operator|=
name|zonelist
index|[
literal|0
index|]
expr_stmt|;
else|else
name|err
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|S_PREREQ
case|:
case|case
name|S_UPDATE
case|:
comment|/* Operation code. */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|opcode
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'{'
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int32_t
operator|)
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|n
operator|-
literal|2
index|]
operator|==
literal|'}'
condition|)
name|buf
index|[
name|n
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|mp
operator|=
name|m_opcode
init|;
name|mp
operator|<
name|m_opcode
operator|+
name|M_OPCODE_CNT
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
name|mp
operator|->
name|token
argument_list|)
condition|)
block|{
name|opcode
operator|=
name|mp
operator|->
name|val
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opcode
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Owner's domain name. */
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dnbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dnbuf
index|[
name|n
index|]
operator|==
literal|'.'
condition|)
name|dnbuf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* ttl */
name|ttl
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|&&
name|ttl
operator|==
name|ULONG_MAX
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* possibly class */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|success
decl_stmt|;
name|int
name|maybe_class
decl_stmt|;
name|maybe_class
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|class
operator|=
name|maybe_class
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* possibly type */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|success
decl_stmt|;
name|int
name|maybe_type
decl_stmt|;
name|maybe_type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|type
operator|=
name|maybe_type
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* possibly rdata */
comment|/* 				 * Convert the ascii data 'buf' to the proper 				 * format based on the type and pack into 				 * 'data'. 				 * 				 * XXX - same as in db_load(), 				 * consolidation needed 				 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|ntohl
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|INT32SZ
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
case|case
name|T_ISDN
case|:
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|data
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
operator|+
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp
operator|-
name|data
operator|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|T_SOA
condition|)
block|{
name|n
operator|=
name|cp
operator|-
name|data
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|!=
name|zp
operator|->
name|z_class
operator|||
name|strcasecmp
argument_list|(
name|dname
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|multiline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|multiline
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|5
condition|;
name|i
operator|++
control|)
block|{
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|GETNUM_SERIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multiline
operator|&&
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
operator|!=
literal|')'
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_WKS
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|ntohl
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|char
operator|)
name|getprotocol
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|n
operator|=
name|INT32SZ
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|n
operator|=
name|getservices
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|,
name|data
argument_list|,
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|makename
argument_list|(
name|data
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
name|cp
operator|=
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|makename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|data
operator|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|n
operator|=
name|cp
operator|-
name|data
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|datasize
operator|=
sizeof|sizeof
name|data
expr_stmt|;
name|cp1
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|255
condition|)
block|{
if|if
condition|(
name|datasize
operator|<
literal|256
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"record too big"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|datasize
operator|-=
literal|255
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
literal|255
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
literal|255
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|255
expr_stmt|;
name|cp1
operator|+=
literal|255
expr_stmt|;
name|i
operator|-=
literal|255
expr_stmt|;
block|}
if|if
condition|(
name|datasize
operator|<
name|i
operator|+
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"record too big"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|cp
operator|++
operator|=
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|i
expr_stmt|;
name|n
operator|=
name|cp
operator|-
name|data
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* XXXVIX: segmented texts 4.9.5 */
break|break;
case|case
name|T_NSAP
case|:
name|n
operator|=
name|inet_nsap_addr
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_LOC
case|:
name|cp
operator|=
name|buf
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|,
operator|*
name|cp
operator|=
name|i
operator|,
name|i
operator|!=
name|EOF
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|(
name|n
operator|<
name|MAXDATA
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|ungetc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|loc_aton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|==
name|S_PREREQ
condition|)
block|{
name|ttl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NXDOMAIN
condition|)
block|{
name|class
operator|=
name|C_NONE
expr_stmt|;
name|type
operator|=
name|T_ANY
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|YXDOMAIN
condition|)
block|{
name|class
operator|=
name|C_ANY
expr_stmt|;
name|type
operator|=
name|T_ANY
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|NXRRSET
condition|)
block|{
name|class
operator|=
name|C_NONE
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|YXRRSET
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|class
operator|=
name|C_ANY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* section == S_UPDATE */
if|if
condition|(
name|opcode
operator|==
name|DELETE
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|class
operator|=
name|C_ANY
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
name|type
operator|=
name|T_ANY
expr_stmt|;
block|}
else|else
block|{
name|class
operator|=
name|C_NONE
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|S_ADDT
case|:
default|default:
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"cannot interpret section: %d"
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|inside_next
operator|=
literal|0
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|inside_next
operator|=
literal|0
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"merge of update id %d failed due to error at line %d"
argument_list|,
name|id
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|free_rrecp
argument_list|(
operator|&
name|rrecp_start
argument_list|,
operator|&
name|rrecp_last
argument_list|,
name|rcode
argument_list|,
name|empty_from
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|rrecp
operator|=
name|res_mkupdrec
argument_list|(
name|section
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|S_ZONE
condition|)
block|{
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_ZONE
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|nlabels
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|rrecp
operator|->
name|r_dp
operator|=
name|dp
expr_stmt|;
block|}
else|else
block|{
name|rrecp
operator|->
name|r_zone
operator|=
name|zonenum
expr_stmt|;
block|}
if|if
condition|(
name|rrecp_start
operator|==
name|NULL
condition|)
block|{
name|rrecp_start
operator|=
name|rrecp
expr_stmt|;
name|rrecp_last
operator|=
name|rrecp
expr_stmt|;
name|rrecp
operator|->
name|r_prev
operator|=
name|NULL
expr_stmt|;
name|rrecp
operator|->
name|r_next
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|rrecp_last
operator|->
name|r_next
operator|=
name|rrecp
expr_stmt|;
name|rrecp
operator|->
name|r_prev
operator|=
name|rrecp_last
expr_stmt|;
name|rrecp
operator|->
name|r_next
operator|=
name|NULL
expr_stmt|;
name|rrecp_last
operator|=
name|rrecp
expr_stmt|;
block|}
block|}
comment|/* for (;;) */
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a disk database to back up zones   */
end_comment

begin_function
name|int
name|zonedump
parameter_list|(
name|zp
parameter_list|)
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|op
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|char
name|tmp_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|int
name|escaped
decl_stmt|;
name|char
name|c
decl_stmt|;
comment|/* 	 * We must check to see if Z_NEED_SOAUPDATE is set, and if so 	 * we must do it.  This won't be the case normally 	 * (when called from ns_maint()), but it is possible if we're  	 * exiting named.  	 */
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
condition|)
block|{
name|u_int32_t
name|serial
decl_stmt|,
name|old_serial
decl_stmt|;
name|old_serial
operator|=
name|get_serial
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|serial
operator|=
name|old_serial
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|serial
operator|==
literal|0
condition|)
name|serial
operator|=
literal|1
expr_stmt|;
name|set_serial
argument_list|(
name|zp
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
comment|/* Only dump zone if there is a cache specified */
if|if
condition|(
name|zp
operator|->
name|z_source
operator|&&
operator|*
operator|(
name|zp
operator|->
name|z_source
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"zonedump(%s)"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
operator|+
name|strlen
argument_list|(
name|DumpSuffix
argument_list|)
operator|>=
name|MAXPATHLEN
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"filename %s too long in zonedump"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
comment|/*  			 * This problem won't ever get better, so we 			 * clear the "need dump" flag. 			 */
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_NEED_DUMP
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp_name
argument_list|,
literal|"%s%s"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|,
name|DumpSuffix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|write_open
argument_list|(
name|tmp_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fopen() of %s failed: %s"
argument_list|,
name|tmp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s"
argument_list|,
name|DumpSignature
argument_list|)
expr_stmt|;
name|op
operator|=
name|zp
operator|->
name|z_origin
expr_stmt|;
name|escaped
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|op
operator|&&
operator|(
operator|(
operator|(
name|c
operator|=
operator|*
name|op
operator|++
operator|)
operator|!=
literal|'.'
operator|)
operator|||
name|escaped
operator|)
condition|)
name|escaped
operator|=
operator|(
name|c
operator|==
literal|'\\'
operator|)
operator|&&
operator|!
name|escaped
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
if|if
condition|(
name|nlookup
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|db_dump
argument_list|(
name|htp
argument_list|,
name|fp
argument_list|,
name|zp
operator|-
name|zones
argument_list|,
name|op
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"error dumping zone file %s"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|fflush
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fflush() of %s failed: %s"
argument_list|,
name|tmp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fsync
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fsync() of %s failed: %s"
argument_list|,
name|tmp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fclose
argument_list|(
name|fp
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fclose() of %s failed: %s"
argument_list|,
name|tmp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 		 * Try to make read only, so people will be less likely to 		 * edit dynamic domains. 		 */
if|if
condition|(
name|stat
argument_list|(
name|tmp_name
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"stat(%s) failed, pressing on: %s"
argument_list|,
name|tmp_name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zp
operator|->
name|z_ftime
operator|=
name|st
operator|.
name|st_mtime
expr_stmt|;
name|st
operator|.
name|st_mode
operator|&=
operator|~
name|WRITEABLE_MASK
expr_stmt|;
if|if
condition|(
name|chmod
argument_list|(
name|tmp_name
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"chmod(%s,%o) failed, pressing on: %s"
argument_list|,
name|tmp_name
argument_list|,
name|st
operator|.
name|st_mode
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rename
argument_list|(
name|tmp_name
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"rename(%s,%s) failed: %s"
argument_list|,
name|tmp_name
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|rename
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"rename(%s,%s) failed: %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|zp
operator|->
name|z_source
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
else|else
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"zonedump: no zone to dump"
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_NEED_DUMP
expr_stmt|;
name|zp
operator|->
name|z_dumptime
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|struct
name|databuf
modifier|*
name|findzonesoa
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|zp
operator|->
name|z_origin
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|foreach_rr
argument_list|(
argument|dp
argument_list|,
argument|np
argument_list|,
argument|T_SOA
argument_list|,
argument|zp->z_class
argument_list|,
argument|zp - zones
argument_list|)
return|return
operator|(
name|dp
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|u_char
modifier|*
name|findsoaserial
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
operator|(
name|char
operator|*
operator|)
name|data
decl_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Nameserver. */
name|cp
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Mailbox. */
return|return
operator|(
operator|(
name|u_char
operator|*
operator|)
name|cp
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|get_serial_unchecked
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_int32_t
name|ret
decl_stmt|;
name|dp
operator|=
name|findzonesoa
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
name|ns_panic
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"get_serial_unchecked(%s): can't locate zone SOA"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|cp
operator|=
name|findsoaserial
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ret
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|u_int32_t
name|get_serial
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|u_int32_t
name|ret
decl_stmt|;
name|ret
operator|=
name|get_serial_unchecked
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|zp
operator|->
name|z_serial
condition|)
name|ns_panic
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"get_serial(%s): db and zone serial numbers differ"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|set_serial
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|u_int32_t
name|serial
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|dp
operator|=
name|findzonesoa
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
name|ns_panic
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"set_serial(%s): can't locate zone SOA"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|cp
operator|=
name|findsoaserial
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
name|serial
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_serial
operator|=
name|serial
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_NEED_SOAUPDATE
expr_stmt|;
name|zp
operator|->
name|z_soaincrtime
operator|=
literal|0
expr_stmt|;
name|zp
operator|->
name|z_updatecnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
operator|!
name|loading
condition|)
name|sysnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|T_SOA
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Note: caller is responsible for scheduling a dump 	 */
block|}
end_function

begin_comment
comment|/*  * Increment serial number in zoneinfo structure and hash table SOA databuf  */
end_comment

begin_function
name|int
name|incr_serial
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|u_int32_t
name|serial
decl_stmt|,
name|old_serial
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|old_serial
operator|=
name|get_serial
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|serial
operator|=
name|old_serial
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|serial
operator|==
literal|0
condition|)
name|serial
operator|=
literal|1
expr_stmt|;
name|set_serial
argument_list|(
name|zp
argument_list|,
name|serial
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|t
operator|=
operator|(
name|time_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|fp
operator|=
name|open_transaction_log
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"[INCR_SERIAL] from %u to %u %s\n"
argument_list|,
name|old_serial
argument_list|,
name|serial
argument_list|,
name|checked_ctime
argument_list|(
operator|&
name|t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|close_transaction_log
argument_list|(
name|zp
argument_list|,
name|fp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * This shouldn't happen, but we check to be sure. 	 */
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_DUMP
operator|)
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_update
argument_list|,
literal|"incr_serial: Z_NEED_DUMP not set for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|schedule_dump
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dynamic_about_to_exit
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"shutting down; dumping zones that need it"
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|zones
init|;
name|zp
operator|<
operator|&
name|zones
index|[
name|nzones
index|]
condition|;
name|zp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|&&
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_DUMP
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|zonedump
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

