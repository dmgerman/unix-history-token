begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)db_load.c	4.38 (Berkeley) 3/2/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: db_load.c,v 8.41 1998/02/13 20:02:28 halley Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996, 1997 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Load zone from ASCII file on local host.  Format similar to RFC 883.  */
end_comment

begin_comment
comment|/* Import. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|int
name|gettoken
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getttl
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getcharstring
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|makename_ok
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|class
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|enum
name|transport
name|transport
parameter_list|,
name|enum
name|context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getmlword
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getallwords
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|wordtouint32
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|datepart
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|datetosecs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_nxt_types
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_soa
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function_decl
specifier|static
name|void
name|notify_after_delay
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|wordtouint32_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|empty_token
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getmlword_nesting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a zone deeper in a hierarchy has more credibility */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_decl_stmt
specifier|static
name|notify_info_list
name|pending_notifies
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Parser token values  */
end_comment

begin_define
define|#
directive|define
name|CURRENT
value|1
end_define

begin_define
define|#
directive|define
name|DOT
value|2
end_define

begin_define
define|#
directive|define
name|AT
value|3
end_define

begin_define
define|#
directive|define
name|DNAME
value|4
end_define

begin_define
define|#
directive|define
name|INCLUDE
value|5
end_define

begin_define
define|#
directive|define
name|ORIGIN
value|6
end_define

begin_define
define|#
directive|define
name|ERROR
value|7
end_define

begin_define
define|#
directive|define
name|MAKENAME_OK
parameter_list|(
name|N
parameter_list|)
define|\
value|do { \ 		if (!makename_ok(N, origin, class, zp, \ 				 transport, context, \ 				 domain, filename, lineno, \ 				 sizeof(data) - ((u_char*)N - data))) { \ 			errs++; \ 			sprintf(buf, "bad name \"%s\"", N); \ 		        goto err; \ 		} \ 	} while (0)
end_define

begin_comment
comment|/* Public. */
end_comment

begin_comment
comment|/* int  * db_load(filename, in_origin, zp, def_domain)  *	load a database from `filename' into zone `zp'.  append `in_origin'  *	to all nonterminal domain names in the file.  `def_domain' is the  *	default domain for include files or NULL for zone base files.  * returns:  *	-1 = can't open file  *	0 = success  *>0 = number of errors encountered  */
end_comment

begin_function
name|int
name|db_load
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|in_origin
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
specifier|const
name|char
modifier|*
name|def_domain
parameter_list|)
block|{
specifier|static
name|int
name|read_soa
decl_stmt|,
name|read_ns
decl_stmt|,
name|rrcount
decl_stmt|;
specifier|const
name|char
modifier|*
name|errtype
init|=
literal|"Database"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|domain
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|origin
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|tmporigin
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXDATA
index|]
decl_stmt|;
name|u_char
name|data
index|[
name|MAXDATA
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
name|int
name|c
decl_stmt|,
name|someclass
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dbflags
decl_stmt|,
name|dataflags
decl_stmt|,
name|multiline
decl_stmt|;
name|int
name|slineno
decl_stmt|,
name|i
decl_stmt|,
name|errs
decl_stmt|,
name|didinclude
decl_stmt|,
name|escape
decl_stmt|,
name|success
decl_stmt|,
name|dateerror
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|,
name|n
decl_stmt|,
name|serial
decl_stmt|;
name|u_long
name|tmplong
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|enum
name|transport
name|transport
decl_stmt|;
name|enum
name|context
name|context
decl_stmt|;
name|u_int32_t
name|sig_type
decl_stmt|;
name|u_int32_t
name|keyflags
decl_stmt|;
name|struct
name|sockaddr_in
name|empty_from
decl_stmt|;
name|empty_from
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|empty_from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|empty_from
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*  * We use an 'if' inside of the 'do' below because otherwise the Solaris  * compiler detects that the 'while' is never executed because of the 'goto'  * and complains.  */
define|#
directive|define
name|ERRTO
parameter_list|(
name|msg
parameter_list|)
value|do { if (1) { errtype = msg; goto err; } } while (0)
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_PRIMARY
case|:
case|case
name|Z_CACHE
case|:
name|transport
operator|=
name|primary_trans
expr_stmt|;
break|break;
case|case
name|Z_SECONDARY
case|:
case|case
name|Z_STUB
case|:
name|transport
operator|=
name|secondary_trans
expr_stmt|;
break|break;
default|default:
name|transport
operator|=
name|response_trans
expr_stmt|;
comment|/*guessing*/
break|break;
block|}
name|errs
operator|=
literal|0
expr_stmt|;
name|didinclude
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|def_domain
condition|)
block|{
comment|/* This is not the result of a $INCLUDE. */
name|rrcount
operator|=
literal|0
expr_stmt|;
name|read_soa
operator|=
literal|0
expr_stmt|;
name|read_ns
operator|=
literal|0
expr_stmt|;
name|clev
operator|=
name|nlabels
argument_list|(
name|in_origin
argument_list|)
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|1
argument_list|,
literal|"db_load(%s, %s, %d, %s)"
argument_list|,
name|filename
argument_list|,
name|in_origin
argument_list|,
name|zp
operator|-
name|zones
argument_list|,
name|def_domain
condition|?
name|def_domain
else|:
literal|"Nil"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|origin
argument_list|,
name|in_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
name|dbflags
operator|=
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|dataflags
operator|=
name|DB_F_HINT
expr_stmt|;
ifdef|#
directive|ifdef
name|STUBS
block|}
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
operator|&&
name|clev
operator|==
literal|0
condition|)
block|{
name|dbflags
operator|=
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|dataflags
operator|=
name|DB_F_HINT
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|dbflags
operator|=
name|DB_NODATA
expr_stmt|;
name|dataflags
operator|=
literal|0
expr_stmt|;
block|}
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|int
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
block|}
name|slineno
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|def_domain
condition|)
name|strcpy
argument_list|(
name|domain
argument_list|,
name|def_domain
argument_list|)
expr_stmt|;
else|else
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
operator|(
name|Z_INCLUDE
operator||
name|Z_DB_BAD
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gettoken
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|INCLUDE
case|:
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* file name*/
break|break;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|tmporigin
argument_list|,
sizeof|sizeof
argument_list|(
name|tmporigin
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|tmporigin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|makename
argument_list|(
name|tmporigin
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|tmporigin
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"$INCLUDE makename failed"
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|didinclude
operator|=
literal|1
expr_stmt|;
name|errs
operator|+=
name|db_load
argument_list|(
name|buf
argument_list|,
name|tmporigin
argument_list|,
name|zp
argument_list|,
name|domain
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|ORIGIN
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|3
argument_list|,
literal|"db_load: origin %s, buf %s"
argument_list|,
name|origin
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|makename
argument_list|(
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"$ORIGIN makename failed"
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|3
argument_list|,
literal|"db_load: origin now %s"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DNAME
case|:
if|if
condition|(
operator|!
name|getword
argument_list|(
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|makename
argument_list|(
name|domain
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"ownername makename failed"
argument_list|)
expr_stmt|;
goto|goto
name|gotdomain
goto|;
case|case
name|AT
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|domain
argument_list|,
name|origin
argument_list|)
expr_stmt|;
goto|goto
name|gotdomain
goto|;
case|case
name|DOT
case|:
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CURRENT
case|:
name|gotdomain
label|:
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CURRENT
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|ns_parse_ttl
argument_list|(
name|buf
argument_list|,
operator|&
name|tmplong
argument_list|)
operator|<
literal|0
condition|)
name|ttl
operator|=
name|USE_MINIMUM
expr_stmt|;
else|else
block|{
name|ttl
operator|=
operator|(
name|u_int32_t
operator|)
name|tmplong
expr_stmt|;
if|if
condition|(
name|ttl
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: TTL> %u; converted to 0"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|MAXIMUM_TTL
argument_list|)
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
comment|/* 					 * This allows the cache entry to age 					 * while sitting on disk (powered off). 					 */
if|if
condition|(
name|ttl
operator|>
name|max_cache_ttl
condition|)
name|ttl
operator|=
name|max_cache_ttl
expr_stmt|;
name|ttl
operator|+=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
comment|/* Parse class (IN, etc) */
name|someclass
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
name|someclass
operator|!=
name|C_ANY
condition|)
block|{
name|class
operator|=
name|someclass
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Parse RR type (A, MX, etc) */
name|type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|0
operator|||
name|type
operator|==
name|ns_t_any
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: Unknown type: %s."
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
break|break;
block|}
name|context
operator|=
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|domain
argument_list|,
name|class
argument_list|,
name|zp
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|domain
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: owner name error"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
name|context
operator|=
name|domain_ctx
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_key
case|:
case|case
name|ns_t_sig
case|:
case|case
name|ns_t_nxt
case|:
comment|/* 				 * Don't do anything here for these types -- 				 * they read their own input separately later. 				 */
goto|goto
name|dont_get_word
goto|;
case|case
name|ns_t_soa
case|:
case|case
name|ns_t_minfo
case|:
case|case
name|ns_t_rp
case|:
case|case
name|ns_t_ns
case|:
case|case
name|ns_t_cname
case|:
case|case
name|ns_t_mb
case|:
case|case
name|ns_t_mg
case|:
case|case
name|ns_t_mr
case|:
case|case
name|ns_t_ptr
case|:
name|escape
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|escape
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
name|escape
argument_list|)
condition|)
break|break;
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|3
argument_list|,
literal|"d='%s', c=%d, t=%d, ttl=%u, data='%s'"
argument_list|,
name|domain
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 			 * Convert the ascii data 'buf' to the proper format 			 * based on the type and pack into 'data'. 			 */
name|dont_get_word
label|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_a
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"IP Address"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ina_put
argument_list|(
name|ina
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|NS_INT32SZ
expr_stmt|;
break|break;
case|case
name|ns_t_soa
case|:
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|soa_rp_minfo
goto|;
case|case
name|ns_t_rp
case|:
case|case
name|ns_t_minfo
case|:
name|context
operator|=
name|mailname_ctx
expr_stmt|;
comment|/* FALLTHROUGH */
name|soa_rp_minfo
label|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|cp
argument_list|,
operator|(
sizeof|sizeof
name|data
operator|)
operator|-
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Domain Name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_rp
condition|)
name|context
operator|=
name|domain_ctx
expr_stmt|;
else|else
name|context
operator|=
name|mailname_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ns_t_soa
condition|)
block|{
name|n
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|!=
name|zp
operator|->
name|z_class
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: %s"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
literal|"SOA class not same as zone's"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcasecmp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|domain
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_error
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: SOA for \"%s\" not at zone top \"%s\""
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|multiline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|multiline
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|serial
operator|=
name|zp
operator|->
name|z_serial
expr_stmt|;
name|zp
operator|->
name|z_serial
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_SERIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
name|errs
operator|++
expr_stmt|;
name|n
operator|=
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_serial
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial
operator|!=
literal|0
operator|&&
name|SEQ_GT
argument_list|(
name|serial
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: WARNING: new serial number< old (%lu< %lu)"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|n
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_refresh
operator|=
name|MAX
argument_list|(
name|n
argument_list|,
name|MIN_REFRESH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
if|#
directive|if
name|defined
argument_list|(
name|STUBS
argument_list|)
operator|||
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
endif|#
directive|endif
condition|)
block|{
name|ns_refreshtime
argument_list|(
name|zp
argument_list|,
name|MIN
argument_list|(
name|sb
operator|.
name|st_mtime
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
operator|(
name|zp
operator|->
name|z_type
operator|==
name|Z_PRIMARY
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
condition|)
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_soaincrintvl
operator|>
name|zp
operator|->
name|z_refresh
operator|/
literal|3
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"zone soa update time truncated to 1/3rd of refresh time"
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_soaincrintvl
operator|=
name|zp
operator|->
name|z_refresh
operator|/
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|n
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_retry
operator|=
name|MAX
argument_list|(
name|n
argument_list|,
name|MIN_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|zp
operator|->
name|z_expire
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|zp
operator|->
name|z_expire
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|n
operator|=
name|zp
operator|->
name|z_expire
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|n
operator|=
literal|120
expr_stmt|;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: SOA minimum TTL> %u; converted to 0"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|MAXIMUM_TTL
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_minimum
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|zp
operator|->
name|z_minimum
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|multiline
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|')'
condition|)
name|ERRTO
argument_list|(
literal|"SOA \")\""
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|read_soa
operator|++
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_PRIMARY
condition|)
name|fixup_soa
argument_list|(
name|filename
argument_list|,
name|zp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_wks
case|:
comment|/* Address */
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"WKS IP Address"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ina_put
argument_list|(
name|ina
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Protocol */
name|data
index|[
name|INADDRSZ
index|]
operator|=
name|getprotocol
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Services */
name|n
operator|=
name|getservices
argument_list|(
name|NS_INT32SZ
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_ns
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|domain
argument_list|)
operator|==
literal|0
condition|)
name|read_ns
operator|++
expr_stmt|;
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|cname_etc
goto|;
case|case
name|ns_t_cname
case|:
case|case
name|ns_t_mb
case|:
case|case
name|ns_t_mg
case|:
case|case
name|ns_t_mr
case|:
name|context
operator|=
name|domain_ctx
expr_stmt|;
goto|goto
name|cname_etc
goto|;
case|case
name|ns_t_ptr
case|:
name|context
operator|=
name|ns_ptrcontext
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|cname_etc
label|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|ns_t_naptr
case|:
comment|/* Order Preference Flags Service Replacement Regexp */
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
comment|/* Order */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
name|cp
operator|==
name|buf
operator|||
name|n
operator|>
literal|65535
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Order"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Preference */
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Preference"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Flags */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Flags"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Service Classes */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Service Classes"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Pattern */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Pattern"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Replacement */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Replacement"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|ns_t_mx
case|:
case|case
name|ns_t_afsdb
case|:
case|case
name|ns_t_rt
case|:
case|case
name|ns_t_srv
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
operator|(
name|cp
operator|==
name|buf
operator|)
operator|||
operator|(
name|n
operator|>
literal|65535
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"Priority"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_srv
condition|)
block|{
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
name|ERRTO
argument_list|(
literal|"SRV RR"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
name|ERRTO
argument_list|(
literal|"SRV RR"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Domain Name"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|hostname_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|ns_t_px
case|:
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
operator|(
name|cp
operator|==
name|buf
operator|)
operator|||
operator|(
name|n
operator|>
literal|65535
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"PX Priority"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"PX Domain1"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to next field */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"PX Domain2"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|ns_t_hinfo
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"HINFO RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_isdn
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"ISDN RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_txt
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"TXT RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_x25
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"X25 RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_nsap
case|:
name|n
operator|=
name|inet_nsap_addr
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"NSAP RR"
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_aaaa
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|buf
argument_list|,
name|data
argument_list|)
operator|<=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"IPv4 Address"
argument_list|)
expr_stmt|;
name|n
operator|=
name|NS_IN6ADDRSZ
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_key
case|:
block|{
comment|/* The KEY record looks like this in the db file: 	 *	Name  Cl KEY Flags  Proto  Algid  PublicKeyData 	 * where: 	 *	Name,Cl per usual 	 *	KEY	RR type 	 *	Flags	4 digit hex value (unsigned_16) 	 *	Proto	8 bit u_int 	 *	Algid	8 bit u_int 	 *	PublicKeyData 	 *		a string of base64 digits, 	 *		skipping any embedded whitespace. 	 */
name|u_int32_t
name|al
decl_stmt|,
name|pr
decl_stmt|;
name|int
name|nk
decl_stmt|,
name|klen
decl_stmt|;
name|char
modifier|*
name|expstart
decl_stmt|;
name|u_int
name|expbytes
decl_stmt|,
name|modbytes
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recov. */
comment|/*>>> Flags (unsigned_16)  */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"KEY Flags Field"
argument_list|)
expr_stmt|;
name|keyflags
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|0xFFFF
operator|<
name|keyflags
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|keyflags
operator|&
name|NS_KEY_RESERVED_BITMASK
condition|)
name|ERRTO
argument_list|(
literal|"KEY Reserved Flag Bit"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|keyflags
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/*>>> Protocol (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"KEY Protocol Field"
argument_list|)
expr_stmt|;
name|pr
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|255
operator|<
name|pr
condition|)
name|ERRTO
argument_list|(
literal|"KEY Protocol Field"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|u_char
operator|)
name|pr
expr_stmt|;
comment|/*>>> Algorithm id (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"KEY Algorithm ID"
argument_list|)
expr_stmt|;
name|al
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|0
operator|==
name|al
operator|||
literal|255
operator|==
name|al
operator|||
literal|255
operator|<
name|al
condition|)
name|ERRTO
argument_list|(
literal|"KEY Algorithm ID"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|u_char
operator|)
name|al
expr_stmt|;
comment|/*>>> Public Key data is in BASE64. 			 *	We don't care what algorithm it uses or what 			 *	the internal structure of the BASE64 data is. 			 */
if|if
condition|(
operator|!
name|getallwords
argument_list|(
name|buf
argument_list|,
name|MAXDATA
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|klen
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Convert from BASE64 to binary. */
name|klen
operator|=
name|b64_pton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|klen
operator|<
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Public Key"
argument_list|)
expr_stmt|;
block|}
comment|/* set total length */
name|n
operator|=
name|cp
operator|+
name|klen
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* 			 * Now check for valid key flags& algs& etc, 			 * from the RFC. 			 */
if|if
condition|(
name|keyflags
operator|&
operator|(
name|NS_KEY_ZONEKEY
operator||
name|NS_KEY_IPSEC
operator||
name|NS_KEY_EMAIL
operator|)
condition|)
name|pr
operator||=
literal|1
expr_stmt|;
comment|/* A nonzero proto. */
if|if
condition|(
name|NS_KEY_TYPE_NO_KEY
operator|==
operator|(
name|keyflags
operator|&
name|NS_KEY_TYPEMASK
operator|)
condition|)
name|nk
operator|=
literal|1
expr_stmt|;
comment|/* No-key */
else|else
name|nk
operator|=
literal|0
expr_stmt|;
comment|/* have a key */
if|if
condition|(
operator|(
name|keyflags
operator|&
name|NS_KEY_ZONEKEY
operator|)
operator|&&
operator|(
name|NS_KEY_TYPE_CONF_ONLY
operator|==
operator|(
name|keyflags
operator|&
name|NS_KEY_TYPEMASK
operator|)
operator|)
condition|)
comment|/* Zone key must have Auth bit set. */
name|ERRTO
argument_list|(
literal|"KEY Zone Key Auth. bit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
operator|&&
name|nk
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Algorithm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|!=
literal|0
operator|&&
name|pr
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Protocols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|==
literal|1
operator|&&
name|klen
operator|!=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY No-Key Flags Set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|==
literal|0
operator|&&
name|klen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Type Spec'd"
argument_list|)
expr_stmt|;
comment|/* Check algorithm-ID and key structure, for 				   the algorithm-ID's that we know about. */
switch|switch
condition|(
name|al
condition|)
block|{
case|case
name|NS_ALG_MD5RSA
case|:
if|if
condition|(
name|klen
operator|==
literal|0
condition|)
break|break;
name|expstart
operator|=
name|cp
expr_stmt|;
name|expbytes
operator|=
operator|*
name|expstart
operator|++
expr_stmt|;
if|if
condition|(
name|expbytes
operator|==
literal|0
condition|)
name|GETSHORT
argument_list|(
name|expbytes
argument_list|,
name|expstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|expbytes
operator|<
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"Exponent too short"
argument_list|)
expr_stmt|;
if|if
condition|(
name|expbytes
operator|>
operator|(
name|NS_MD5RSA_MAX_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Exponent too long"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expstart
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Exponent w/ 0"
argument_list|)
expr_stmt|;
name|modbytes
operator|=
name|klen
operator|-
operator|(
name|expbytes
operator|+
operator|(
name|expstart
operator|-
name|cp
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|modbytes
operator|<
operator|(
name|NS_MD5RSA_MIN_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Modulus too short"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modbytes
operator|>
operator|(
name|NS_MD5RSA_MAX_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Modulus too long"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|expstart
operator|+
name|expbytes
operator|)
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Modulus starts w/ 0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ALG_EXPIRE_ONLY
case|:
if|if
condition|(
name|klen
operator|!=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Key provided for expire-only algorithm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ALG_PRIVATE_OID
case|:
if|if
condition|(
name|klen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"No ObjectID in key"
argument_list|)
expr_stmt|;
break|break;
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* flush the rest of the line */
break|break;
block|}
comment|/*T_KEY*/
case|case
name|ns_t_sig
case|:
block|{
comment|/* The SIG record looks like this in the db file: 		   Name Cl SIG RRtype Algid [OTTL] Texp Tsig Kfoot Signer Sig 		      		   where:  Name and Cl are as usual 			   SIG     is a keyword 			   RRtype  is a char string  			   ALGid   is  8 bit u_int 			   OTTL    is 32 bit u_int (optionally present) 			   Texp    is YYYYMMDDHHMMSS 			   Tsig    is YYYYMMDDHHMMSS 			   Kfoot   is 16-bit unsigned decimal integer 			   Signer  is a char string 			   Sig     is 64 to 319 base-64 digits 		   A missing OTTL is detected by the magnitude of the Texp value 		   that follows it, which is larger than any u_int. 		   The Labels field in the binary RR does not appear in the 		   text RR.  		   It's too crazy to run these pages of SIG code at the right 		   margin.  I'm exdenting them for readability. 		 */
name|int
name|siglen
decl_stmt|;
name|u_int32_t
name|al
decl_stmt|;
name|u_int32_t
name|signtime
decl_stmt|,
name|exptime
decl_stmt|,
name|timetilexp
decl_stmt|;
name|u_int32_t
name|origTTL
decl_stmt|;
name|time_t
name|now
decl_stmt|;
comment|/* The TTL gets checked against the Original TTL, 		   and bounded by the signature expiration time, which  		   are both under the signature.  We can't let TTL drift 		   based on the SOA record.  If defaulted, fix it now.  		   (It's not clear to me why USE_MINIMUM isn't eliminated 		   before putting ALL RR's into the database.  -gnu@toad.com) */
if|if
condition|(
name|ttl
operator|==
name|USE_MINIMUM
condition|)
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recovery */
comment|/* RRtype (char *) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"SIG record doesn't specify type"
argument_list|)
expr_stmt|;
name|sig_type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
operator|||
name|sig_type
operator|==
name|ns_t_any
condition|)
block|{
comment|/* 			 * We'll also accept a numeric RR type, 			 * for signing RR types that this version 			 * of named doesn't yet understand. 			 * In the ns_t_any case, we rely on wordtouint32 			 * to fail when scanning the string "ANY". 			 */
name|sig_type
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|sig_type
operator|>
literal|0xFFFF
condition|)
name|ERRTO
argument_list|(
literal|"Unknown RR type in SIG record"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|sig_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Algorithm id (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing algorithm ID"
argument_list|)
expr_stmt|;
name|al
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|al
operator|||
name|wordtouint32_error
operator|||
literal|255
operator|<=
name|al
condition|)
goto|goto
name|err
goto|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|al
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* 		 * Labels (8-bit decimal) 		 *	Not given in the file.  Must compute. 		 */
name|n
operator|=
name|dn_count_labels
argument_list|(
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>=
name|n
operator|||
literal|255
operator|<
name|n
condition|)
name|ERRTO
argument_list|(
literal|"SIG label count invalid"
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|n
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* 		 * OTTL (optional u_int32_t) and 		 * Texp (u_int32_t date) 		 */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"OTTL and expiration time missing"
argument_list|)
expr_stmt|;
comment|/* 		 * See if OTTL is missing and this is a date. 		 * This relies on good, silent error checking 		 * in datetosecs. 		 */
name|exptime
operator|=
name|datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dateerror
condition|)
block|{
comment|/* Output TTL as OTTL */
name|origTTL
operator|=
name|ttl
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|origTTL
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse and output OTTL; scan TEXP */
name|origTTL
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|>=
name|origTTL
operator|||
name|wordtouint32_error
operator|||
operator|(
name|origTTL
operator|>
literal|0x7fffffff
operator|)
condition|)
goto|goto
name|err
goto|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|origTTL
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Expiration time missing"
argument_list|)
expr_stmt|;
name|exptime
operator|=
name|datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dateerror
operator|||
name|exptime
operator|>
literal|0x7fffffff
operator|||
name|exptime
operator|<=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Invalid expiration time"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|exptime
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
comment|/* Tsig (u_int32_t) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing signature time"
argument_list|)
expr_stmt|;
name|signtime
operator|=
name|datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|signtime
operator|||
name|dateerror
condition|)
name|ERRTO
argument_list|(
literal|"Invalid signature time"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|signtime
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
comment|/* Kfootprint (unsigned_16) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing key footprint"
argument_list|)
expr_stmt|;
name|n
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|n
operator|>=
literal|0x0ffff
condition|)
name|ERRTO
argument_list|(
literal|"Invalid key footprint"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Signer's Name */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing signer's name"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|strcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Signature (base64 of any length) 		 * We don't care what algorithm it uses or what 		 * the internal structure of the BASE64 data is. 		 */
if|if
condition|(
operator|!
name|getallwords
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|siglen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|siglen
operator|=
name|b64_pton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
sizeof|sizeof
name|data
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|<
literal|0
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* set total length and we're done! */
name|n
operator|=
name|i
operator|+
name|siglen
expr_stmt|;
comment|/* 		 * Check signature time, expiration, and adjust TTL.  Note 		 * that all time values are in GMT (UTC), *not* local time. 		 */
name|now
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Don't let bogus name servers increase the signed TTL */
if|if
condition|(
name|ttl
operator|>
name|origTTL
condition|)
name|ERRTO
argument_list|(
literal|"TTL is greater than signed original TTL"
argument_list|)
expr_stmt|;
comment|/* Don't let bogus signers "sign" in the future.  */
if|if
condition|(
name|signtime
operator|>
operator|(
name|u_int32_t
operator|)
name|now
condition|)
name|ERRTO
argument_list|(
literal|"signature time is in the future"
argument_list|)
expr_stmt|;
comment|/* Ignore received SIG RR's that are already expired.  */
if|if
condition|(
name|exptime
operator|<=
operator|(
name|u_int32_t
operator|)
name|now
condition|)
name|ERRTO
argument_list|(
literal|"expiration time is in the past"
argument_list|)
expr_stmt|;
comment|/* Lop off the TTL at the expiration time.  */
name|timetilexp
operator|=
name|exptime
operator|-
name|now
expr_stmt|;
if|if
condition|(
name|timetilexp
operator|<
name|ttl
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|1
argument_list|,
literal|"shrinking expiring %s SIG TTL from %d to %d"
argument_list|,
name|p_secstodate
argument_list|(
name|exptime
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|timetilexp
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|timetilexp
expr_stmt|;
block|}
comment|/* 		 * Check algorithm-ID and key structure, for 		 * the algorithm-ID's that we know about. 		 */
switch|switch
condition|(
name|al
condition|)
block|{
case|case
name|NS_ALG_MD5RSA
case|:
if|if
condition|(
name|siglen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"No key for RSA algorithm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|<
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"Signature too short"
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|>
operator|(
name|NS_MD5RSA_MAX_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Signature too long"
argument_list|)
expr_stmt|;
comment|/* We rely on  cp  from parse */
if|if
condition|(
operator|*
name|cp
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Signature starts with zeroes"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ALG_EXPIRE_ONLY
case|:
if|if
condition|(
name|siglen
operator|!=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Signature supplied to expire-only algorithm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ALG_PRIVATE_OID
case|:
if|if
condition|(
name|siglen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"No ObjectID in key"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Should we complain about algorithm-ID's that we	 		   don't understand?  It may help debug some obscure 		   cases, but in general we should accept any RR whether 		   we could cryptographically process it or not; it 		   may be being published for some newer DNS clients 		   to validate themselves.  */
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* flush the rest of the line */
break|break;
comment|/* Accept this RR. */
block|}
case|case
name|ns_t_nxt
case|:
comment|/* The NXT record looks like: 				   Name Cl NXT nextname RRT1 RRT2 MX A SOA ... 				     				   where:  Name and Cl are as usual 					   NXT     is a keyword 					   nextname is the next valid name in 						   the zone after "Name".  All 						   names between the two are 						   known to be nonexistent. 					   RRT's... are a series of RR type 						   names, which indicate that 						   RR's of these types are 						   published for "Name", and 						   that no RR's of any other 						   types are published for 						   "Name".  				   When a NXT record is cryptographically 				   signed, it proves the nonexistence of an 				   RR (actually a whole set of RR's).  */
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recov. */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|err
goto|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|n
operator|+
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|n
operator|+=
name|get_nxt_types
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_loc
case|:
name|cp
operator|=
name|buf
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|,
operator|*
name|cp
operator|=
name|i
operator|,
name|i
operator|!=
name|EOF
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|(
name|n
operator|<
name|MAXDATA
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
comment|/* leave \n for getword */
name|ungetc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* now process the whole line */
name|n
operator|=
name|loc_aton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|err
goto|;
block|}
comment|/* 			 * Ignore data outside the zone. 			 */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_CACHE
operator|&&
operator|!
name|samedomain
argument_list|(
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: data \"%s\" outside zone \"%s\" (ignored)"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ttl
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zp
operator|-
name|zones
expr_stmt|;
name|dp
operator|->
name|d_flags
operator|=
name|dataflags
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_ZONE
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|clev
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|db_update
argument_list|(
name|domain
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|dbflags
argument_list|,
operator|(
name|dataflags
operator|&
name|DB_F_HINT
operator|)
condition|?
name|fcachetab
else|:
name|hashtab
argument_list|,
name|empty_from
argument_list|)
operator|)
operator|!=
name|OK
condition|)
block|{
if|if
condition|(
name|c
operator|!=
name|DATAEXISTS
condition|)
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|1
argument_list|,
literal|"update failed %s %d"
argument_list|,
name|domain
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|rrcount
operator|++
expr_stmt|;
block|}
continue|continue;
case|case
name|ERROR
case|:
break|break;
block|}
name|err
label|:
name|errs
operator|++
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: %s error (%s)"
argument_list|,
name|filename
argument_list|,
name|empty_token
condition|?
operator|(
name|lineno
operator|-
literal|1
operator|)
else|:
name|lineno
argument_list|,
name|errtype
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty_token
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|slineno
expr_stmt|;
if|if
condition|(
operator|!
name|def_domain
condition|)
block|{
if|if
condition|(
name|didinclude
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_INCLUDE
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|zp
operator|->
name|z_ftime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
name|zp
operator|->
name|z_lastupdate
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_CACHE
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|read_soa
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"no SOA RR found"
expr_stmt|;
elseif|else
if|if
condition|(
name|read_soa
operator|!=
literal|1
condition|)
name|msg
operator|=
literal|"multiple SOA RRs found"
expr_stmt|;
elseif|else
if|if
condition|(
name|read_ns
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"no NS RRs found at zone top"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rrcount
condition|)
name|msg
operator|=
literal|"no relevant RRs found"
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"Zone \"%s\" (file %s): %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|filename
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|def_domain
condition|)
block|{
if|if
condition|(
name|errs
condition|)
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s zone \"%s\" (%s) rejected due to errors (serial %u)"
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
else|else
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s zone \"%s\" (%s) loaded (serial %u)"
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_DB_BAD
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
operator|!
name|errs
operator|&&
operator|!
name|def_domain
operator|&&
operator|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_slave
operator|)
condition|)
block|{
specifier|static
specifier|const
name|char
name|no_room
index|[]
init|=
literal|"%s failed, cannot notify for zone %s"
decl_stmt|;
name|notify_info
name|ni
decl_stmt|;
name|ni
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|ni
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
name|no_room
argument_list|,
literal|"memget"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
else|else
block|{
name|ni
operator|->
name|name
operator|=
name|savestr
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|->
name|name
operator|==
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|ni
argument_list|,
sizeof|sizeof
expr|*
name|ni
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
name|no_room
argument_list|,
literal|"memget"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ni
operator|->
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|ni
operator|->
name|state
operator|=
name|notify_info_waitfor
expr_stmt|;
if|if
condition|(
name|evWaitFor
argument_list|(
name|ev
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|)
name|notify_after_load
argument_list|,
name|notify_after_load
argument_list|,
name|ni
argument_list|,
operator|&
name|ni
operator|->
name|wait_id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_load
argument_list|,
literal|"evWaitFor() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|ni
operator|->
name|name
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ni
argument_list|,
sizeof|sizeof
expr|*
name|ni
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|APPEND
argument_list|(
name|pending_notifies
argument_list|,
name|ni
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ns_need
argument_list|(
name|MAIN_NEED_NOTIFY
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
endif|#
directive|endif
return|return
operator|(
name|errs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gettoken
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
name|op
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|top
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
return|return
operator|(
name|EOF
operator|)
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|getword
argument_list|(
name|op
argument_list|,
sizeof|sizeof
name|op
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"include"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|INCLUDE
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"origin"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|ORIGIN
operator|)
return|;
block|}
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: Unknown $ option: $%s"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
case|case
literal|';'
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|top
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
return|return
operator|(
name|CURRENT
operator|)
return|;
case|case
literal|'.'
case|:
return|return
operator|(
name|DOT
operator|)
return|;
case|case
literal|'@'
case|:
return|return
operator|(
name|AT
operator|)
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
continue|continue;
default|default:
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNAME
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* int  * getword(buf, size, fp, preserve)  *	get next word, skipping blanks& comments.  *	'\' '\n' outside of "quotes" is considered a blank.  * parameters:  *	buf - destination  *	size - of destination  *	fp - file to read from  *	preserve - should we preserve \ before \\ and \.?  * return value:  *	0 = no word; perhaps EOL or EOF; lineno was incremented.  *	1 = word was read  */
end_comment

begin_function
name|int
name|getword
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|preserve
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|int
name|c
decl_stmt|,
name|spaceok
decl_stmt|;
name|empty_token
operator|=
literal|0
expr_stmt|;
comment|/* XXX global side effect. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
comment|/* Comment.  Skip to end of line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* 			 * Unescaped newline.  It's a terminator unless we're 			 * already midway into a token. 			 */
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|/* "Quoted string."  Gather the whole string here. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|preserve
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* 			 * Newline string terminators are 			 * not token terminators. 			 */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Sample following character, check for terminator. */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
continue|continue;
block|}
name|spaceok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Do escape processing. */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|preserve
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|spaceok
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|spaceok
condition|)
block|{
comment|/* Blank of some kind.  Skip run. */
while|while
condition|(
name|isspace
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Blank means terminator if the token is nonempty. */
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
comment|/* Trailing whitespace */
break|break;
continue|continue;
comment|/* Leading whitespace */
block|}
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
name|empty_token
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|cp
operator|!=
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * getttl(fp, fn, ln, ttl, multiline)  *	read a word from the file and parse it as a TTL.  * return:  *	1 ttl found  *	0 word not read (EOF or EOL?)  *	-1 word read but it wasn't a ttl  * side effects:  *	*ttl is written if the return value is to be 1.  */
end_comment

begin_function
specifier|static
name|int
name|getttl
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|int
name|lineno
parameter_list|,
name|u_int32_t
modifier|*
name|ttl
parameter_list|,
name|int
modifier|*
name|multiline
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXDATA
index|]
decl_stmt|;
name|u_long
name|tmp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|*
name|multiline
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|multiline
operator|&&
name|len
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|multiline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ns_parse_ttl
argument_list|(
name|buf
argument_list|,
operator|&
name|tmp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: expected a TTL, got \"%s\""
argument_list|,
name|fn
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|multiline
condition|)
block|{
name|ch
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ch
operator|==
literal|';'
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
operator|*
name|ttl
operator|=
operator|(
name|u_int32_t
operator|)
name|tmp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get multiline words.  Same parameters as getword.  Handles any    number of leading ('s or )'s in the words it sees.    FIXME:  We kludge recognition of ( and ) for multiline input.    Each paren must appear at the start of a (blank-separated) word,    which is particularly counter-intuitive for ).  Good enough for now,    until Paul rewrites the parser.  (gnu@toad.com, oct96) */
end_comment

begin_function
specifier|static
name|int
name|getmlword
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|preserve
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
do|do
block|{
while|while
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|fp
argument_list|,
name|preserve
argument_list|)
condition|)
block|{
comment|/* No more words on this line.  See if doing the 			   multiline thing. */
if|if
condition|(
operator|!
name|getmlword_nesting
condition|)
block|{
comment|/* Nope... */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Push back newline */
name|lineno
operator|--
expr_stmt|;
comment|/* Unbump the lineno */
name|empty_token
operator|=
literal|0
expr_stmt|;
comment|/* Undo this botch */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Error, no terminating ')' */
comment|/* Continue reading til we get a word... */
block|}
while|while
condition|(
literal|'('
operator|==
operator|*
name|buf
condition|)
block|{
comment|/* Word starts with paren.  Multiline mode. 			   Move the rest of the word down over the paren.  */
name|getmlword_nesting
operator|++
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
literal|')'
operator|==
operator|*
name|buf
condition|)
block|{
name|getmlword_nesting
operator|--
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
do|;
comment|/* loop til we get a non-( non-) word */
return|return
literal|1
return|;
comment|/* Got a word... */
block|}
end_function

begin_comment
comment|/* Get all the remaining words on a line, concatenated into one big    long (not too long!) string, with the whitespace squeezed out.    This routine, like getword(), does not swallow the newline if words seen.    This routine, unlike getword(), never swallows the newline if no words.    Parameters are the same as getword().  Result is: 	 0	got no words at all 	 1 	got one or more words 	-1	got too many words, they don't all fit; or missing close paren */
end_comment

begin_function
specifier|static
name|int
name|getallwords
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|preserve
parameter_list|)
block|{
name|char
modifier|*
name|runningbuf
init|=
name|buf
decl_stmt|;
name|int
name|runningsize
init|=
name|size
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
name|runningsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|runningbuf
argument_list|,
name|runningsize
argument_list|,
name|fp
argument_list|,
name|preserve
argument_list|)
condition|)
block|{
return|return
name|runningbuf
operator|!=
name|buf
return|;
comment|/* 1 or 0 */
block|}
name|len
operator|=
name|strlen
argument_list|(
name|runningbuf
argument_list|)
expr_stmt|;
name|runningbuf
operator|+=
name|len
expr_stmt|;
name|runningsize
operator|-=
name|len
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Error, String too long */
block|}
end_function

begin_function
name|int
name|getnum
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|opt
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|seendigit
init|=
literal|0
decl_stmt|;
name|int
name|seendecimal
init|=
literal|0
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|allow_dots
init|=
literal|0
decl_stmt|;
name|getnum_error
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DOTTED_SERIAL
if|if
condition|(
name|opt
operator|&
name|GETNUM_SERIAL
condition|)
name|allow_dots
operator|++
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|seendigit
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|seendigit
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|getnum_error
condition|)
continue|continue;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|')'
operator|&&
name|seendigit
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|seendigit
operator|&&
operator|(
name|opt
operator|&
name|GETNUM_SCALED
operator|)
operator|&&
name|strchr
argument_list|(
literal|"KkMmGg"
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'K'
case|:
case|case
literal|'k'
case|:
name|n
operator|*=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|n
operator|*=
operator|(
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
name|n
operator|*=
operator|(
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|seendecimal
operator|||
name|c
operator|!=
literal|'.'
operator|||
operator|!
name|allow_dots
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: expected a number"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|getnum_error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seendigit
condition|)
name|n
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SENSIBLE_DOTS
name|n
operator|*=
literal|10000
expr_stmt|;
else|#
directive|else
name|n
operator|*=
literal|1000
expr_stmt|;
endif|#
directive|endif
name|seendigit
operator|=
literal|1
expr_stmt|;
name|seendecimal
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SENSIBLE_DOTS
if|if
condition|(
name|seendecimal
condition|)
name|m
operator|=
name|m
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
endif|#
directive|endif
name|seendigit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|getnum_error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|m
operator|>
literal|9999
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: number after the decimal point exceeds 9999"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|getnum_error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|seendecimal
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: decimal serial number interpreted as %d"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|n
operator|+
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|+
name|m
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|getnonblank
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
continue|continue;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: unexpected EOF"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take name and fix it according to following rules:  * "." means root.  * "@" means current origin.  * "name." means no changes.  * "name" means append origin.  */
end_comment

begin_function
name|int
name|makename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|u_char
name|domain
index|[
name|MAXCDNAME
index|]
decl_stmt|;
switch|switch
condition|(
name|ns_name_pton
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|1
case|:
comment|/* FULLY QUALIFIED */
break|break;
case|case
literal|0
case|:
comment|/* UNQUALIFIED */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
operator|==
literal|0
condition|)
comment|/* must test raw name */
name|domain
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|domain
argument_list|,
name|domain
operator|+
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* step back over root, append origin */
switch|switch
condition|(
name|ns_name_pton
argument_list|(
name|origin
argument_list|,
name|domain
operator|+
name|n
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
name|n
operator|+
literal|1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|ns_name_ntop
argument_list|(
name|domain
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
comment|/* root */
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|makename_ok
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|class
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|enum
name|transport
name|transport
parameter_list|,
name|enum
name|context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|makename
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: makename failed"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|name
argument_list|,
name|class
argument_list|,
name|zp
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|owner
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: database naming error"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|endline
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAXPORT
value|1024
end_define

begin_define
define|#
directive|define
name|MAXLEN
value|24
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|char
name|getprotocol
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|char
name|b
index|[
name|MAXLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|protocolnumber
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: unknown protocol: %s."
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|)
name|k
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|getservices
parameter_list|(
name|int
name|offset
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|ch
decl_stmt|,
name|k
decl_stmt|,
name|maxl
decl_stmt|,
name|bracket
decl_stmt|;
name|char
name|bm
index|[
name|MAXPORT
operator|/
literal|8
index|]
decl_stmt|;
name|char
name|b
index|[
name|MAXLEN
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXPORT
operator|/
literal|8
condition|;
name|j
operator|++
control|)
name|bm
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
name|bracket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|||
name|bracket
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
name|bracket
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|')'
condition|)
block|{
name|bracket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|servicenumber
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: Unknown service '%s'"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|k
operator|<
name|MAXPORT
operator|)
operator|&&
operator|(
name|k
operator|)
condition|)
block|{
name|bm
index|[
name|k
operator|/
literal|8
index|]
operator||=
operator|(
literal|0x80
operator|>>
operator|(
name|k
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: port no. (%d) too big"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bracket
condition|)
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: missing close paren"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|maxl
operator|=
name|maxl
operator|/
literal|8
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|offset
argument_list|,
name|bm
argument_list|,
name|maxl
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxl
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Converts a word to a u_int32_t.  Error if any non-numeric  * characters in the word, except leading or trailing white space.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|wordtouint32
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|u_long
name|result
decl_stmt|;
name|u_int32_t
name|res2
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|wordtouint32_error
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufend
operator|==
name|buf
condition|)
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
else|else
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|bufend
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|bufend
argument_list|)
condition|)
name|bufend
operator|++
expr_stmt|;
else|else
block|{
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for truncation between u_long and u_int32_t */
name|res2
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|res2
operator|!=
name|result
condition|)
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|res2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Parse part of a date.  Set error flag if any error.  * Don't reset the flag if there is no error.  */
end_comment

begin_function
specifier|static
name|int
name|datepart
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|,
name|int
name|min
parameter_list|,
name|int
name|max
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|int
name|result
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|buf
index|[
name|i
index|]
argument_list|)
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
name|result
operator|=
operator|(
name|result
operator|*
literal|10
operator|)
operator|+
name|buf
index|[
name|i
index|]
operator|-
literal|'0'
expr_stmt|;
block|}
if|if
condition|(
name|result
operator|<
name|min
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|result
operator|>
name|max
condition|)
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Convert a date in ASCII into the number of seconds since    1 January 1970 (GMT assumed).  Format is yyyymmddhhmmss, all    digits required, no spaces allowed.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|datetosecs
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|,
name|int
modifier|*
name|errp
parameter_list|)
block|{
name|struct
name|tm
name|time
decl_stmt|;
name|u_int32_t
name|result
decl_stmt|;
name|int
name|mdays
decl_stmt|,
name|i
decl_stmt|;
specifier|static
specifier|const
name|int
name|days_per_month
index|[
literal|12
index|]
init|=
block|{
literal|31
block|,
literal|28
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|,
literal|30
block|,
literal|31
block|}
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|cp
argument_list|)
operator|!=
literal|14
condition|)
block|{
operator|*
name|errp
operator|=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
operator|*
name|errp
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|&
name|time
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|time
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_year
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|0
argument_list|,
literal|4
argument_list|,
literal|1990
argument_list|,
literal|9999
argument_list|,
name|errp
argument_list|)
operator|-
literal|1900
expr_stmt|;
name|time
operator|.
name|tm_mon
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|4
argument_list|,
literal|2
argument_list|,
literal|01
argument_list|,
literal|12
argument_list|,
name|errp
argument_list|)
operator|-
literal|1
expr_stmt|;
name|time
operator|.
name|tm_mday
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|6
argument_list|,
literal|2
argument_list|,
literal|01
argument_list|,
literal|31
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_hour
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|8
argument_list|,
literal|2
argument_list|,
literal|00
argument_list|,
literal|23
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_min
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|10
argument_list|,
literal|2
argument_list|,
literal|00
argument_list|,
literal|59
argument_list|,
name|errp
argument_list|)
expr_stmt|;
name|time
operator|.
name|tm_sec
operator|=
name|datepart
argument_list|(
name|cp
operator|+
literal|12
argument_list|,
literal|2
argument_list|,
literal|00
argument_list|,
literal|59
argument_list|,
name|errp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|errp
condition|)
comment|/* Any parse errors? */
return|return
operator|(
literal|0
operator|)
return|;
comment|/*  	 * OK, now because timegm() is not available in all environments, 	 * we will do it by hand.  Roll up sleeves, curse the gods, begin! 	 */
define|#
directive|define
name|SECS_PER_DAY
value|((u_int32_t)24*60*60)
define|#
directive|define
name|isleap
parameter_list|(
name|y
parameter_list|)
value|((((y) % 4) == 0&& ((y) % 100) != 0) || ((y) % 400) == 0)
name|result
operator|=
name|time
operator|.
name|tm_sec
expr_stmt|;
comment|/* Seconds */
name|result
operator|+=
name|time
operator|.
name|tm_min
operator|*
literal|60
expr_stmt|;
comment|/* Minutes */
name|result
operator|+=
name|time
operator|.
name|tm_hour
operator|*
operator|(
literal|60
operator|*
literal|60
operator|)
expr_stmt|;
comment|/* Hours */
name|result
operator|+=
operator|(
name|time
operator|.
name|tm_mday
operator|-
literal|1
operator|)
operator|*
name|SECS_PER_DAY
expr_stmt|;
comment|/* Days */
comment|/* Months are trickier.  Look without leaping, then leap */
name|mdays
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|time
operator|.
name|tm_mon
condition|;
name|i
operator|++
control|)
name|mdays
operator|+=
name|days_per_month
index|[
name|i
index|]
expr_stmt|;
name|result
operator|+=
name|mdays
operator|*
name|SECS_PER_DAY
expr_stmt|;
comment|/* Months */
if|if
condition|(
name|time
operator|.
name|tm_mon
operator|>
literal|1
operator|&&
name|isleap
argument_list|(
literal|1900
operator|+
name|time
operator|.
name|tm_year
argument_list|)
condition|)
name|result
operator|+=
name|SECS_PER_DAY
expr_stmt|;
comment|/* Add leapday for this year */
comment|/* First figure years without leapdays, then add them in.  */
comment|/* The loop is slow, FIXME, but simple and accurate.  */
name|result
operator|+=
operator|(
name|time
operator|.
name|tm_year
operator|-
literal|70
operator|)
operator|*
operator|(
name|SECS_PER_DAY
operator|*
literal|365
operator|)
expr_stmt|;
comment|/* Years */
for|for
control|(
name|i
operator|=
literal|70
init|;
name|i
operator|<
name|time
operator|.
name|tm_year
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isleap
argument_list|(
literal|1900
operator|+
name|i
argument_list|)
condition|)
name|result
operator|+=
name|SECS_PER_DAY
expr_stmt|;
comment|/* Add leapday for prev year */
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|MAXCHARSTRING
value|255
end_define

begin_function
specifier|static
name|int
name|getcharstring
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|minfields
parameter_list|,
name|int
name|maxfields
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|nfield
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
do|do
block|{
name|nfield
operator|++
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_LONG_TXT_RDATA
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_txt
operator|||
name|type
operator|==
name|ns_t_x25
condition|)
block|{
while|while
condition|(
name|i
operator|>
name|MAXCHARSTRING
operator|&&
name|n
operator|+
name|MAXCHARSTRING
operator|+
literal|1
operator|<
name|MAXDATA
condition|)
block|{
name|data
index|[
name|n
index|]
operator|=
name|MAXCHARSTRING
expr_stmt|;
name|memmove
argument_list|(
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
name|b
argument_list|,
name|MAXCHARSTRING
argument_list|)
expr_stmt|;
name|n
operator|+=
name|MAXCHARSTRING
operator|+
literal|1
expr_stmt|;
name|b
operator|+=
name|MAXCHARSTRING
expr_stmt|;
name|i
operator|-=
name|MAXCHARSTRING
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ALLOW_LONG_TXT_RDATA */
if|if
condition|(
name|i
operator|>
name|MAXCHARSTRING
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: RDATA field %d too long"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|nfield
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|+
name|i
operator|+
literal|1
operator|>
name|MAXDATA
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: total RDATA too long"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|data
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|memmove
argument_list|(
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
name|b
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|n
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
name|done
operator|=
operator|(
name|maxfields
operator|&&
name|nfield
operator|>=
name|maxfields
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
operator|&&
name|getword
argument_list|(
name|buf
argument_list|,
name|MAXDATA
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
do|;
if|if
condition|(
name|nfield
operator|<
name|minfields
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: expected %d RDATA fields, only saw %d"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|minfields
argument_list|,
name|nfield
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|done
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * get_nxt_types(): Read the list of types in the NXT record.  *  * Data is the array where the bit flags are stored; it must  * contain at least ns_t_any/NS_NXT_BITS bytes.   * FP is the input FILE *.  * Filename is the sourcefile   *  * The result is how many bytes are significant in the result.  * ogud@tis.com 1995  */
end_comment

begin_function
specifier|static
name|int
name|get_nxt_types
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
name|b
index|[
name|MAXLABEL
index|]
decl_stmt|;
comment|/* Not quite the right size, but good enough */
name|int
name|maxtype
init|=
literal|0
decl_stmt|;
name|int
name|success
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|ns_t_any
operator|/
name|NS_NXT_BITS
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|getmlword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|b
argument_list|)
operator|==
literal|0
operator|||
name|b
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* Parse RR type (A, MX, etc) */
name|type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|success
operator|)
operator|||
name|type
operator|==
name|ns_t_any
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: Line %d: Unknown type: %s in NXT record."
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|NS_NXT_BIT_SET
argument_list|(
name|type
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>
name|maxtype
condition|)
name|maxtype
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|maxtype
operator|/
name|NS_NXT_BITS
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sanity checks PRIMARY ONLY */
end_comment

begin_function
specifier|static
name|void
name|fixup_soa
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
comment|/* Sanity: give enough time for the zone to transfer (retry). */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
name|zp
operator|->
name|z_refresh
operator|+
name|zp
operator|->
name|z_retry
operator|)
condition|)
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is less than SOA refresh+retry (%u< %u+%u)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
comment|/* Sanity. */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
name|zp
operator|->
name|z_refresh
operator|+
literal|10
operator|*
name|zp
operator|->
name|z_retry
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is less than refresh + 10 * retry \ (%u< (%u + 10 * %u))"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity: most hardware/telco faults are detected and fixed within  	 * a week, secondaries should continue to operate for this time. 	 * (minimum of 4 days for long weekends) 	 */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
literal|7
operator|*
literal|24
operator|*
literal|3600
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is less than 7 days (%u)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity: maximum down time if we havn't talked for six months  	 * war must have broken out. 	 */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|>
operator|(
literal|183
operator|*
literal|24
operator|*
literal|3600
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is greater than 6 months (%u)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|)
expr_stmt|;
comment|/* Sanity. */
if|if
condition|(
name|zp
operator|->
name|z_refresh
operator|<
operator|(
name|zp
operator|->
name|z_retry
operator|*
literal|2
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA refresh value is less than 2 * retry (%u< %u * 2)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_NOTIFY
end_ifdef

begin_function
specifier|static
name|void
name|free_notify_info
parameter_list|(
name|notify_info
name|ni
parameter_list|)
block|{
if|if
condition|(
name|ni
operator|->
name|state
operator|==
name|notify_info_waitfor
condition|)
name|evUnwait
argument_list|(
name|ev
argument_list|,
name|ni
operator|->
name|wait_id
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ni
operator|->
name|state
operator|==
name|notify_info_delay
condition|)
name|evClearTimer
argument_list|(
name|ev
argument_list|,
name|ni
operator|->
name|timer_id
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|ni
operator|->
name|name
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ni
argument_list|,
sizeof|sizeof
expr|*
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|notify_after_load
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
specifier|const
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|delay
decl_stmt|,
name|max_delay
decl_stmt|;
name|notify_info
name|ni
init|=
name|uap
decl_stmt|;
name|INSIST
argument_list|(
name|tag
operator|==
operator|(
specifier|const
name|void
operator|*
operator|)
name|notify_after_load
argument_list|)
expr_stmt|;
comment|/* delay notification for from five seconds up to fifteen minutes */
name|max_delay
operator|=
name|MIN
argument_list|(
name|nzones
operator|/
literal|5
argument_list|,
literal|895
argument_list|)
expr_stmt|;
name|max_delay
operator|=
name|MAX
argument_list|(
name|max_delay
argument_list|,
literal|25
argument_list|)
expr_stmt|;
name|delay
operator|=
literal|5
operator|+
operator|(
name|rand
argument_list|()
operator|%
name|max_delay
operator|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_notify
argument_list|,
literal|3
argument_list|,
literal|"notify_after_load: uap %p tag %p delay %d"
argument_list|,
name|uap
argument_list|,
name|tag
argument_list|,
name|delay
argument_list|)
expr_stmt|;
if|if
condition|(
name|evSetTimer
argument_list|(
name|ctx
argument_list|,
name|notify_after_delay
argument_list|,
name|ni
argument_list|,
name|evAddTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
name|delay
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|ni
operator|->
name|timer_id
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_notify
argument_list|,
literal|"evSetTimer() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|pending_notifies
argument_list|,
name|ni
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ni
operator|->
name|state
operator|=
name|notify_info_error
expr_stmt|;
name|free_notify_info
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|ni
operator|->
name|state
operator|=
name|notify_info_delay
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|notify_after_delay
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
block|{
name|notify_info
name|ni
init|=
name|uap
decl_stmt|;
name|UNLINK
argument_list|(
name|pending_notifies
argument_list|,
name|ni
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|ni
operator|->
name|state
operator|=
name|notify_info_done
expr_stmt|;
name|sysnotify
argument_list|(
name|ni
operator|->
name|name
argument_list|,
name|ni
operator|->
name|class
argument_list|,
name|ns_t_soa
argument_list|)
expr_stmt|;
name|free_notify_info
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|db_cancel_pending_notifies
parameter_list|(
name|void
parameter_list|)
block|{
name|notify_info
name|ni
decl_stmt|,
name|ni_next
decl_stmt|;
for|for
control|(
name|ni
operator|=
name|HEAD
argument_list|(
name|pending_notifies
argument_list|)
init|;
name|ni
operator|!=
name|NULL
condition|;
name|ni
operator|=
name|ni_next
control|)
block|{
name|ni_next
operator|=
name|NEXT
argument_list|(
name|ni
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free_notify_info
argument_list|(
name|ni
argument_list|)
expr_stmt|;
block|}
name|INIT_LIST
argument_list|(
name|pending_notifies
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

