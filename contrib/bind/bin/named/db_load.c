begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)db_load.c	4.38 (Berkeley) 3/2/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: db_load.c,v 8.110 2001/01/25 05:50:53 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Load zone from ASCII file on local host.  Format similar to RFC 883.  */
end_comment

begin_comment
comment|/* Import. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|int
name|gettoken
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getcharstring
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|genname
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getmlword
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getallwords
parameter_list|(
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int32_t
name|wordtouint32
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fixup_soa
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|get_nxt_types
parameter_list|(
name|u_char
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_sig_rr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|struct
name|zoneinfo
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|u_int32_t
parameter_list|,
name|enum
name|context
parameter_list|,
name|enum
name|transport
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_key_rr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|struct
name|zoneinfo
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|context
parameter_list|,
name|enum
name|transport
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_cert_rr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parse_nxt_rr
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|u_char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|FILE
modifier|*
parameter_list|,
name|struct
name|zoneinfo
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|enum
name|context
parameter_list|,
name|enum
name|transport
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|wordtouint32_error
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|empty_token
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getmlword_nesting
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clev
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a zone deeper in a hierarchy has more credibility */
end_comment

begin_comment
comment|/*  * Parser token values  */
end_comment

begin_define
define|#
directive|define
name|CURRENT
value|1
end_define

begin_define
define|#
directive|define
name|DOT
value|2
end_define

begin_define
define|#
directive|define
name|AT
value|3
end_define

begin_define
define|#
directive|define
name|DNAME
value|4
end_define

begin_define
define|#
directive|define
name|INCLUDE
value|5
end_define

begin_define
define|#
directive|define
name|ORIGIN
value|6
end_define

begin_define
define|#
directive|define
name|GENERATE
value|7
end_define

begin_define
define|#
directive|define
name|DEFAULTTTL
value|8
end_define

begin_define
define|#
directive|define
name|ERRTOK
value|9
end_define

begin_define
define|#
directive|define
name|MAKENAME_OK
parameter_list|(
name|N
parameter_list|)
define|\
value|do { \ 		if (!makename_ok(N, origin, class, zp, \ 		   		 transport, context, \ 				 domain, filename, lineno, \ 				 data_size - ((u_char*)N - data))) { \ 			errs++; \ 			sprintf(buf, "bad name \"%s\"", N); \ 		        goto err; \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|MAKENAME_OKZP
parameter_list|(
name|N
parameter_list|,
name|SI
parameter_list|)
define|\
value|do { \ 		if (!makename_ok(N, zp->z_origin, zp->z_class, zp, \ 		   		 transport, context, \ 				 domain, zp->z_source, lineno, \ 				 SI - ((u_char*)N - data))) { \ 			errs++; \ 			sprintf(buf, "bad name \"%s\"", N); \ 		        goto err; \ 		} \ 	} while (0)
end_define

begin_define
define|#
directive|define
name|RANGE
parameter_list|(
name|x
parameter_list|,
name|min
parameter_list|,
name|max
parameter_list|)
define|\
value|(((x)> (max)) ? (max) : (((x)< (min)) ? (min) : (x)))
end_define

begin_comment
comment|/* Public. */
end_comment

begin_comment
comment|/* int  * db_load(filename, in_origin, zp, def_domain, isixfr)  *	load a database from `filename' into zone `zp'.  append `in_origin'  *	to all nonterminal domain names in the file.  `def_domain' is the  *	default domain for include files or NULL for zone base files.  * returns:  *	-1 = can't open file  *	0 = success  *>0 = number of errors encountered  */
end_comment

begin_function
name|int
name|db_load
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|in_origin
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
specifier|const
name|char
modifier|*
name|def_domain
parameter_list|,
name|int
name|isixfr
parameter_list|)
block|{
specifier|static
name|int
name|read_soa
decl_stmt|,
name|read_ns
decl_stmt|,
name|rrcount
decl_stmt|;
specifier|static
name|u_int32_t
name|default_ttl
decl_stmt|,
name|default_warn
decl_stmt|;
specifier|static
struct|struct
name|filenames
block|{
name|struct
name|filenames
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|}
modifier|*
name|filenames
struct|,
modifier|*
name|fn
struct|;
specifier|const
name|char
modifier|*
name|errtype
init|=
literal|"Database"
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|domain
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|origin
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|tmporigin
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|buf
index|[
name|MAXDATA
index|]
decl_stmt|;
name|char
name|genlhs
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|genrhs
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|u_char
name|data
index|[
name|MAXDATA
index|]
decl_stmt|;
name|int
name|data_size
init|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
decl_stmt|;
name|int
name|c
decl_stmt|,
name|someclass
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dbflags
decl_stmt|,
name|dataflags
decl_stmt|,
name|multiline
init|=
literal|0
decl_stmt|;
name|int
name|slineno
decl_stmt|,
name|i
decl_stmt|,
name|errs
decl_stmt|,
name|didinclude
decl_stmt|,
name|ininclude
decl_stmt|,
name|escape
decl_stmt|,
name|success
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|,
name|n
decl_stmt|,
name|serial
decl_stmt|;
name|u_long
name|tmplong
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|enum
name|transport
name|transport
decl_stmt|;
name|enum
name|context
name|context
decl_stmt|;
name|struct
name|sockaddr_in
name|empty_from
decl_stmt|;
name|int
name|genstart
decl_stmt|,
name|genend
decl_stmt|,
name|genstep
decl_stmt|;
name|char
modifier|*
name|thisfile
decl_stmt|;
name|void
modifier|*
name|state
init|=
name|NULL
decl_stmt|;
name|int
name|loggenerr
decl_stmt|;
name|empty_from
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|empty_from
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|empty_from
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*  * We use an 'if' inside of the 'do' below because otherwise the Solaris  * compiler detects that the 'while' is never executed because of the 'goto'  * and complains.  */
define|#
directive|define
name|ERRTO
parameter_list|(
name|msg
parameter_list|)
value|do { if (1) { errtype = msg; goto err; } } while (0)
define|#
directive|define
name|ERRTOZ
parameter_list|(
name|msg
parameter_list|)
value|do { if (1) { errtype = msg; buf[0] = '\0'; goto err; } } while (0)
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_PRIMARY
case|:
comment|/* Any updates should be saved before we attempt to reload. */
name|INSIST
argument_list|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_NEED_DUMP
operator||
name|Z_NEED_SOAUPDATE
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
case|case
name|Z_HINT
case|:
if|if
condition|(
name|filename
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_load
argument_list|,
literal|"Required filename not specified for Hint zone"
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_DB_BAD
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|transport
operator|=
name|primary_trans
expr_stmt|;
break|break;
case|case
name|Z_SECONDARY
case|:
case|case
name|Z_STUB
case|:
name|transport
operator|=
name|secondary_trans
expr_stmt|;
break|break;
case|case
name|Z_CACHE
case|:
name|transport
operator|=
name|response_trans
expr_stmt|;
break|break;
default|default:
name|transport
operator|=
name|response_trans
expr_stmt|;
comment|/*guessing*/
break|break;
block|}
name|errs
operator|=
literal|0
expr_stmt|;
name|didinclude
operator|=
literal|0
expr_stmt|;
name|ininclude
operator|=
operator|(
name|def_domain
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ininclude
condition|)
block|{
name|rrcount
operator|=
literal|0
expr_stmt|;
name|read_soa
operator|=
literal|0
expr_stmt|;
name|read_ns
operator|=
literal|0
expr_stmt|;
name|default_ttl
operator|=
name|USE_MINIMUM
expr_stmt|;
name|default_warn
operator|=
literal|1
expr_stmt|;
name|clev
operator|=
name|nlabels
argument_list|(
name|in_origin
argument_list|)
expr_stmt|;
name|filenames
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_minimum
operator|=
name|USE_MINIMUM
expr_stmt|;
block|}
name|ttl
operator|=
name|default_ttl
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|1
argument_list|,
literal|"db_load(%s, %s, %d, %s, %s)"
argument_list|,
name|filename
argument_list|,
name|in_origin
argument_list|,
name|zp
operator|-
name|zones
argument_list|,
name|def_domain
condition|?
name|def_domain
else|:
literal|"Nil"
argument_list|,
name|isixfr
condition|?
literal|"IXFR"
else|:
literal|"Normal"
argument_list|)
expr_stmt|;
name|fn
operator|=
operator|(
expr|struct
name|filenames
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|filenames
argument_list|)
expr_stmt|;
if|if
condition|(
name|fn
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_db
argument_list|,
literal|0
argument_list|,
literal|"db_load: memget failed"
argument_list|)
expr_stmt|;
name|thisfile
operator|=
name|fn
operator|->
name|name
operator|=
name|savestr
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fn
operator|->
name|next
operator|=
name|filenames
expr_stmt|;
name|filenames
operator|=
name|fn
expr_stmt|;
name|strcpy
argument_list|(
name|origin
argument_list|,
name|in_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"db_load could not open: %s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ininclude
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|errs
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_HINT
condition|)
block|{
name|dbflags
operator|=
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|dataflags
operator|=
name|DB_F_HINT
expr_stmt|;
ifdef|#
directive|ifdef
name|STUBS
block|}
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
operator|&&
name|clev
operator|==
literal|0
condition|)
block|{
name|dbflags
operator|=
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|dataflags
operator|=
name|DB_F_HINT
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|dbflags
operator|=
name|DB_NODATA
expr_stmt|;
name|dataflags
operator|=
literal|0
expr_stmt|;
block|}
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fp
argument_list|)
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"fstat failed: %s: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|sb
operator|.
name|st_mtime
operator|=
operator|(
name|int
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
block|}
name|slineno
operator|=
name|lineno
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|def_domain
condition|)
name|strcpy
argument_list|(
name|domain
argument_list|,
name|def_domain
argument_list|)
expr_stmt|;
else|else
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
operator|(
name|Z_INCLUDE
operator||
name|Z_DB_BAD
operator|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|gettoken
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|INCLUDE
case|:
if|if
condition|(
name|isixfr
condition|)
block|{
name|c
operator|=
name|ERRTOK
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
comment|/* file name*/
break|break;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|tmporigin
argument_list|,
sizeof|sizeof
argument_list|(
name|tmporigin
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|strcpy
argument_list|(
name|tmporigin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|makename
argument_list|(
name|tmporigin
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|tmporigin
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"$INCLUDE makename failed"
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|didinclude
operator|=
literal|1
expr_stmt|;
name|i
operator|=
name|db_load
argument_list|(
name|buf
argument_list|,
name|tmporigin
argument_list|,
name|zp
argument_list|,
name|domain
argument_list|,
name|ISNOTIXFR
argument_list|)
expr_stmt|;
name|errs
operator|+=
operator|(
name|i
operator|==
operator|-
literal|1
operator|)
condition|?
literal|1
else|:
name|i
expr_stmt|;
continue|continue;
case|case
name|ORIGIN
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|buf
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|3
argument_list|,
literal|"db_load: origin %s, buf %s"
argument_list|,
name|origin
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|makename
argument_list|(
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|origin
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"$ORIGIN makename failed"
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|3
argument_list|,
literal|"db_load: origin now %s"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|GENERATE
case|:
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTOZ
argument_list|(
literal|"$GENERATE missing RANGE"
argument_list|)
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%d-%d/%d"
argument_list|,
operator|&
name|genstart
argument_list|,
operator|&
name|genend
argument_list|,
operator|&
name|genstep
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|2
operator|&&
name|n
operator|!=
literal|3
condition|)
name|ERRTO
argument_list|(
literal|"$GENERATE invalid range"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|2
condition|)
name|genstep
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|genend
operator|<
name|genstart
operator|)
operator|||
operator|(
name|genstart
operator|<
literal|0
operator|)
operator|||
operator|(
name|genstep
operator|<
literal|0
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"$GENERATE invalid range"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|genlhs
argument_list|,
sizeof|sizeof
argument_list|(
name|genlhs
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|2
argument_list|)
condition|)
name|ERRTOZ
argument_list|(
literal|"$GENERATE missing LHS"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTOZ
argument_list|(
literal|"GENERATE missing TYPE"
argument_list|)
expr_stmt|;
name|type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|0
operator|||
name|type
operator|==
name|ns_t_any
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: $GENERATE unknown type: %s."
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_ns
case|:
case|case
name|ns_t_ptr
case|:
case|case
name|ns_t_cname
case|:
case|case
name|ns_t_a
case|:
case|case
name|ns_t_aaaa
case|:
break|break;
default|default:
name|ERRTO
argument_list|(
literal|"$GENERATE unsupported type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|genrhs
argument_list|,
sizeof|sizeof
argument_list|(
name|genrhs
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|2
argument_list|)
condition|)
name|ERRTOZ
argument_list|(
literal|"$GENERATE missing RHS"
argument_list|)
expr_stmt|;
name|loggenerr
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
name|genstart
init|;
name|i
operator|<=
name|genend
condition|;
name|i
operator|+=
name|genstep
control|)
block|{
if|if
condition|(
name|genname
argument_list|(
name|genlhs
argument_list|,
name|i
argument_list|,
name|origin
argument_list|,
name|domain
argument_list|,
sizeof|sizeof
name|domain
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTOZ
argument_list|(
literal|"$GENERATE genname LHS failed"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_samedomain
argument_list|(
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
condition|)
block|{
comment|/* Log first per $GENERATE. */
if|if
condition|(
name|loggenerr
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: $GENERATE LHS out of zone (ignored)"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|loggenerr
operator|=
literal|0
expr_stmt|;
block|}
continue|continue;
block|}
name|context
operator|=
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
name|domain
argument_list|,
name|class
argument_list|,
name|zp
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|domain
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|ERRTO
argument_list|(
literal|"$GENERATE owner name error"
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_ns
case|:
case|case
name|ns_t_ptr
case|:
case|case
name|ns_t_cname
case|:
if|if
condition|(
name|genname
argument_list|(
name|genrhs
argument_list|,
name|i
argument_list|,
name|origin
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTOZ
argument_list|(
literal|"$GENERATE genname RHS failed"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_ns
case|:
name|context
operator|=
name|hostname_ctx
expr_stmt|;
break|break;
case|case
name|ns_t_ptr
case|:
name|context
operator|=
name|ns_ptrcontext
argument_list|(
name|domain
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_cname
case|:
name|context
operator|=
name|domain_ctx
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|class
argument_list|,
name|zp
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|domain
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|strncpy
argument_list|(
name|buf
argument_list|,
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ERRTO
argument_list|(
literal|"$GENERATE name error"
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|ns_t_a
case|:
case|case
name|ns_t_aaaa
case|:
if|if
condition|(
name|genname
argument_list|(
name|genrhs
argument_list|,
name|i
argument_list|,
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTOZ
argument_list|(
literal|"$GENERATE genname RHS failed"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_a
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"IP Address"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ina_put
argument_list|(
name|ina
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|NS_INT32SZ
expr_stmt|;
break|break;
case|case
name|ns_t_aaaa
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|buf
argument_list|,
name|data
argument_list|)
operator|<=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"IPv6 Address"
argument_list|)
expr_stmt|;
name|n
operator|=
name|NS_IN6ADDRSZ
expr_stmt|;
break|break;
block|}
break|break;
default|default:
name|ERRTOZ
argument_list|(
literal|"$GENERATE unsupported context"
argument_list|)
expr_stmt|;
block|}
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ttl
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zp
operator|-
name|zones
expr_stmt|;
name|dp
operator|->
name|d_flags
operator|=
name|dataflags
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_ZONE
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|clev
expr_stmt|;
name|c
operator|=
name|db_set_update
argument_list|(
name|domain
argument_list|,
name|dp
argument_list|,
operator|&
name|state
argument_list|,
name|dbflags
argument_list|,
operator|(
name|dataflags
operator|&
name|DB_F_HINT
operator|)
operator|!=
literal|0
condition|?
operator|&
name|fcachetab
else|:
operator|&
name|hashtab
argument_list|,
name|empty_from
argument_list|,
operator|&
name|rrcount
argument_list|,
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|OK
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CNAMEANDOTHER
condition|)
name|errs
operator|++
expr_stmt|;
block|}
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
continue|continue;
case|case
name|DNAME
case|:
if|if
condition|(
operator|!
name|getword
argument_list|(
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
break|break;
if|if
condition|(
name|makename
argument_list|(
name|domain
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"ownername makename failed"
argument_list|)
expr_stmt|;
goto|goto
name|gotdomain
goto|;
case|case
name|DEFAULTTTL
case|:
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
operator|||
name|n
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|ERRTO
argument_list|(
literal|"$TTL bad TTL value"
argument_list|)
expr_stmt|;
block|}
name|ttl
operator|=
name|default_ttl
operator|=
name|n
expr_stmt|;
continue|continue;
case|case
name|AT
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|domain
argument_list|,
name|origin
argument_list|)
expr_stmt|;
goto|goto
name|gotdomain
goto|;
case|case
name|DOT
case|:
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|CURRENT
case|:
name|gotdomain
label|:
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CURRENT
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|ns_parse_ttl
argument_list|(
name|buf
argument_list|,
operator|&
name|tmplong
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|&&
name|default_warn
operator|&&
operator|(
name|default_ttl
operator|==
name|USE_MINIMUM
operator|)
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"Zone \"%s\" (file %s): %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|filename
argument_list|,
literal|"No default TTL ($TTL<value>) set, using SOA minimum instead"
argument_list|)
expr_stmt|;
name|default_warn
operator|=
literal|0
expr_stmt|;
block|}
name|ttl
operator|=
operator|(
name|u_int32_t
operator|)
name|default_ttl
expr_stmt|;
block|}
else|else
block|{
name|ttl
operator|=
name|tmplong
expr_stmt|;
if|if
condition|(
name|ttl
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: TTL> %u; converted to 0"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|MAXIMUM_TTL
argument_list|)
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_CACHE
condition|)
block|{
comment|/* 					 * This allows the cache entry to age 					 * while sitting on disk (powered off). 					 */
if|if
condition|(
name|ttl
operator|>
name|max_cache_ttl
condition|)
name|ttl
operator|=
name|max_cache_ttl
expr_stmt|;
name|ttl
operator|+=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
break|break;
block|}
comment|/* Parse class (IN, etc) */
name|someclass
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|&&
name|someclass
operator|!=
name|zp
operator|->
name|z_class
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: wrong class: %s."
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|p_class
argument_list|(
name|someclass
argument_list|)
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|success
operator|&&
name|someclass
operator|!=
name|C_ANY
condition|)
block|{
name|class
operator|=
name|someclass
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Parse RR type (A, MX, etc) */
name|type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
literal|0
operator|||
name|type
operator|==
name|ns_t_any
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: Unknown type: %s."
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ttl
operator|==
name|USE_MINIMUM
condition|)
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
name|context
operator|=
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|transport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
name|domain
argument_list|,
name|class
argument_list|,
name|zp
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|domain
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: owner name error"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
break|break;
block|}
name|context
operator|=
name|domain_ctx
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_key
case|:
case|case
name|ns_t_sig
case|:
case|case
name|ns_t_nxt
case|:
case|case
name|ns_t_cert
case|:
comment|/* 				 * Don't do anything here for these types -- 				 * they read their own input separately later. 				 */
goto|goto
name|dont_get_word
goto|;
case|case
name|ns_t_soa
case|:
case|case
name|ns_t_minfo
case|:
case|case
name|ns_t_rp
case|:
case|case
name|ns_t_ns
case|:
case|case
name|ns_t_cname
case|:
case|case
name|ns_t_mb
case|:
case|case
name|ns_t_mg
case|:
case|case
name|ns_t_mr
case|:
case|case
name|ns_t_ptr
case|:
name|escape
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|escape
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
name|escape
argument_list|)
condition|)
break|break;
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|3
argument_list|,
literal|"d='%s', c=%d, t=%d, ttl=%u, data='%s'"
argument_list|,
name|domain
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* 			 * Convert the ascii data 'buf' to the proper format 			 * based on the type and pack into 'data'. 			 */
name|dont_get_word
label|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_a
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"IP Address"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ina_put
argument_list|(
name|ina
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|NS_INT32SZ
expr_stmt|;
break|break;
case|case
name|ns_t_soa
case|:
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|soa_rp_minfo
goto|;
case|case
name|ns_t_rp
case|:
case|case
name|ns_t_minfo
case|:
name|context
operator|=
name|mailname_ctx
expr_stmt|;
comment|/* FALLTHROUGH */
name|soa_rp_minfo
label|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|cp
argument_list|,
operator|(
sizeof|sizeof
name|data
operator|)
operator|-
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Domain Name"
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_rp
condition|)
name|context
operator|=
name|domain_ctx
expr_stmt|;
else|else
name|context
operator|=
name|mailname_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ns_t_soa
condition|)
block|{
name|n
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ns_samename
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|domain
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_error
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: SOA for \"%s\" not at zone top \"%s\""
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|multiline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|multiline
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|serial
operator|=
name|zp
operator|->
name|z_serial
expr_stmt|;
name|zp
operator|->
name|z_serial
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_SERIAL
argument_list|,
operator|&
name|multiline
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
name|errs
operator|++
expr_stmt|;
name|n
operator|=
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_serial
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial
operator|!=
literal|0
operator|&&
name|SEQ_GT
argument_list|(
name|serial
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: WARNING: new serial number< old (%lu< %lu)"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|,
name|serial
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|n
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_refresh
operator|=
name|RANGE
argument_list|(
name|n
argument_list|,
name|MIN_REFRESH
argument_list|,
name|MAX_REFRESH
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_SECONDARY
if|#
directive|if
name|defined
argument_list|(
name|STUBS
argument_list|)
operator|||
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
endif|#
directive|endif
condition|)
block|{
name|ns_refreshtime
argument_list|(
name|zp
argument_list|,
name|MIN
argument_list|(
name|sb
operator|.
name|st_mtime
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
operator|(
name|zp
operator|->
name|z_type
operator|==
name|Z_PRIMARY
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
condition|)
if|if
condition|(
operator|(
name|u_int32_t
operator|)
name|zp
operator|->
name|z_soaincrintvl
operator|>
name|zp
operator|->
name|z_refresh
operator|/
literal|3
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"zone soa update time truncated to 1/3rd of refresh time"
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_soaincrintvl
operator|=
name|zp
operator|->
name|z_refresh
operator|/
literal|3
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|n
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_retry
operator|=
name|RANGE
argument_list|(
name|n
argument_list|,
name|MIN_RETRY
argument_list|,
name|MAX_RETRY
argument_list|)
expr_stmt|;
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|n
operator|=
name|INIT_REFRESH
expr_stmt|;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_expire
operator|=
name|RANGE
argument_list|(
name|n
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|MAX_EXPIRE
argument_list|)
expr_stmt|;
if|if
condition|(
name|getttl
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|multiline
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|n
operator|=
literal|120
expr_stmt|;
block|}
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s: Line %d: SOA minimum TTL> %u; converted to 0"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|MAXIMUM_TTL
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_minimum
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|zp
operator|->
name|z_minimum
operator|=
name|n
expr_stmt|;
if|if
condition|(
name|ttl
operator|==
name|USE_MINIMUM
condition|)
name|ttl
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
if|if
condition|(
name|multiline
condition|)
block|{
name|buf
index|[
literal|0
index|]
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|buf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|')'
condition|)
name|ERRTO
argument_list|(
literal|"SOA \")\""
argument_list|)
expr_stmt|;
name|multiline
operator|=
literal|0
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|read_soa
operator|++
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_PRIMARY
condition|)
name|fixup_soa
argument_list|(
name|filename
argument_list|,
name|zp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_wks
case|:
comment|/* Address */
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"WKS IP Address"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ina_put
argument_list|(
name|ina
argument_list|,
name|data
argument_list|)
expr_stmt|;
comment|/* Protocol */
name|data
index|[
name|INADDRSZ
index|]
operator|=
name|getprotocol
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* Services */
name|n
operator|=
name|getservices
argument_list|(
name|NS_INT32SZ
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_ns
case|:
if|if
condition|(
name|ns_samename
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|domain
argument_list|)
operator|==
literal|1
condition|)
name|read_ns
operator|++
expr_stmt|;
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|cname_etc
goto|;
case|case
name|ns_t_cname
case|:
case|case
name|ns_t_mb
case|:
case|case
name|ns_t_mg
case|:
case|case
name|ns_t_mr
case|:
name|context
operator|=
name|domain_ctx
expr_stmt|;
goto|goto
name|cname_etc
goto|;
case|case
name|ns_t_ptr
case|:
name|context
operator|=
name|ns_ptrcontext
argument_list|(
name|domain
argument_list|)
expr_stmt|;
name|cname_etc
label|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|ns_t_naptr
case|:
comment|/* Order Preference Flags Service Replacement Regexp */
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
comment|/* Order */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
name|cp
operator|==
name|buf
operator|||
name|n
operator|>
literal|65535
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Order"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Preference */
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|,
operator|&
name|multiline
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Preference"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* Flags */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Flags"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|255
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Flags too big"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Service Classes */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Service Classes"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|255
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Service Classes too big"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Pattern */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Pattern"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|255
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Pattern too big"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|buf
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Replacement */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Replacement"
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|data_size
operator|-
operator|(
operator|(
name|u_char
operator|*
operator|)
name|cp
operator|-
name|data
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"NAPTR Replacement too big"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|ns_t_mx
case|:
case|case
name|ns_t_afsdb
case|:
case|case
name|ns_t_rt
case|:
case|case
name|ns_t_srv
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
operator|(
name|cp
operator|==
name|buf
operator|)
operator|||
operator|(
name|n
operator|>
literal|65535
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"Priority"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_srv
condition|)
block|{
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|,
operator|&
name|multiline
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
name|ERRTO
argument_list|(
literal|"SRV RR"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|filename
argument_list|,
name|GETNUM_NONE
argument_list|,
operator|&
name|multiline
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
operator|||
name|n
operator|>
literal|65536
condition|)
name|ERRTO
argument_list|(
literal|"SRV RR"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Domain Name"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|hostname_ctx
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|ns_t_px
case|:
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
if|if
condition|(
operator|(
name|cp
operator|==
name|buf
operator|)
operator|||
operator|(
name|n
operator|>
literal|65535
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"PX Priority"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"PX Domain1"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to next field */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"PX Domain2"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OK
argument_list|(
name|cp
argument_list|)
expr_stmt|;
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
operator|(
name|char
operator|*
operator|)
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|ns_t_hinfo
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"HINFO RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_isdn
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|2
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"ISDN RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_txt
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"TXT RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_x25
case|:
name|n
operator|=
name|getcharstring
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|type
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|fp
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"X25 RR"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_nsap
case|:
name|n
operator|=
name|inet_nsap_addr
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"NSAP RR"
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_aaaa
case|:
if|if
condition|(
name|inet_pton
argument_list|(
name|AF_INET6
argument_list|,
name|buf
argument_list|,
name|data
argument_list|)
operator|<=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"IPv4 Address"
argument_list|)
expr_stmt|;
name|n
operator|=
name|NS_IN6ADDRSZ
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_nxt
case|:
case|case
name|ns_t_key
case|:
case|case
name|ns_t_cert
case|:
case|case
name|ns_t_sig
case|:
block|{
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|ttl
operator|==
name|USE_MINIMUM
condition|)
comment|/* no ttl set */
name|ttl
operator|=
literal|0
expr_stmt|;
name|ret
operator|=
name|parse_sec_rdata
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|0
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|,
name|fp
argument_list|,
name|zp
argument_list|,
name|domain
argument_list|,
name|ttl
argument_list|,
name|type
argument_list|,
name|domain_ctx
argument_list|,
name|transport
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
name|errtype
operator|=
name|errmsg
expr_stmt|;
goto|goto
name|err
goto|;
block|}
else|else
name|n
operator|=
name|ret
expr_stmt|;
break|break;
block|}
case|case
name|ns_t_loc
case|:
name|cp
operator|=
name|buf
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|,
operator|*
name|cp
operator|=
name|i
operator|,
name|i
operator|!=
name|EOF
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|(
name|n
operator|<
name|MAXDATA
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
comment|/* leave \n for getword */
name|ungetc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
comment|/* now process the whole line */
name|n
operator|=
name|loc_aton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|err
goto|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
default|default:
goto|goto
name|err
goto|;
block|}
comment|/* 			 * Ignore data outside the zone. 			 */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_CACHE
operator|&&
operator|!
name|ns_samedomain
argument_list|(
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: data \"%s\" outside zone \"%s\" (ignored)"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|domain
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ttl
operator|==
name|USE_MINIMUM
condition|)
comment|/* no ttl set */
name|ttl
operator|=
literal|0
expr_stmt|;
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ttl
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zp
operator|-
name|zones
expr_stmt|;
name|dp
operator|->
name|d_flags
operator|=
name|dataflags
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_ZONE
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|clev
expr_stmt|;
name|c
operator|=
name|db_set_update
argument_list|(
name|domain
argument_list|,
name|dp
argument_list|,
operator|&
name|state
argument_list|,
name|dbflags
argument_list|,
operator|(
name|dataflags
operator|&
name|DB_F_HINT
operator|)
operator|!=
literal|0
condition|?
operator|&
name|fcachetab
else|:
operator|&
name|hashtab
argument_list|,
name|empty_from
argument_list|,
operator|&
name|rrcount
argument_list|,
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|CNAMEANDOTHER
condition|)
name|errs
operator|++
expr_stmt|;
continue|continue;
case|case
name|ERRTOK
case|:
break|break;
block|}
name|err
label|:
name|errs
operator|++
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d: %s error near (%s)"
argument_list|,
name|filename
argument_list|,
name|empty_token
condition|?
operator|(
name|lineno
operator|-
literal|1
operator|)
else|:
name|lineno
argument_list|,
name|errtype
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|empty_token
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|db_set_update
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|state
argument_list|,
name|dbflags
argument_list|,
operator|(
name|dataflags
operator|&
name|DB_F_HINT
operator|)
condition|?
operator|&
name|fcachetab
else|:
operator|&
name|hashtab
argument_list|,
name|empty_from
argument_list|,
operator|&
name|rrcount
argument_list|,
name|lineno
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|OK
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|CNAMEANDOTHER
condition|)
name|errs
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|lineno
operator|=
name|slineno
expr_stmt|;
if|if
condition|(
operator|!
name|ininclude
condition|)
block|{
if|if
condition|(
name|didinclude
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_INCLUDE
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|zp
operator|->
name|z_ftime
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
name|zp
operator|->
name|z_lastupdate
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|Z_CACHE
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|Z_HINT
condition|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|read_soa
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"no SOA RR found"
expr_stmt|;
elseif|else
if|if
condition|(
name|read_soa
operator|!=
literal|1
condition|)
name|msg
operator|=
literal|"multiple SOA RRs found"
expr_stmt|;
elseif|else
if|if
condition|(
name|read_ns
operator|==
literal|0
condition|)
name|msg
operator|=
literal|"no NS RRs found at zone top"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rrcount
condition|)
name|msg
operator|=
literal|"no relevant RRs found"
expr_stmt|;
if|if
condition|(
name|msg
operator|!=
name|NULL
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"Zone \"%s\" (file %s): %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|filename
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
name|errs
operator|+=
name|purge_nonglue
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|dataflags
operator|&
name|DB_F_HINT
operator|)
condition|?
name|fcachetab
else|:
name|hashtab
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|zp
operator|->
name|z_type
operator|==
name|z_master
argument_list|)
expr_stmt|;
name|cleanup
label|:
while|while
condition|(
name|filenames
condition|)
block|{
name|fn
operator|=
name|filenames
expr_stmt|;
name|filenames
operator|=
name|filenames
operator|->
name|next
expr_stmt|;
name|freestr
argument_list|(
name|fn
operator|->
name|name
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|fn
argument_list|,
sizeof|sizeof
expr|*
name|fn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|errs
operator|!=
operator|-
literal|1
condition|)
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s zone \"%s\" (%s) rejected due to errors (serial %u)"
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
operator|->
name|z_type
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NOTIFY
operator|)
operator|!=
literal|0
condition|)
name|ns_stopnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
name|do_reload
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_type
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|loading
argument_list|)
expr_stmt|;
block|}
else|else
name|ns_info
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s zone \"%s\" (%s) loaded (serial %u)"
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
operator|->
name|z_type
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errs
operator|!=
literal|0
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_DB_BAD
expr_stmt|;
name|zp
operator|->
name|z_ftime
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|errs
operator|==
literal|0
operator|&&
operator|(
operator|!
name|ininclude
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_slave
operator|)
condition|)
name|ns_notify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|ns_t_soa
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|errs
operator|)
return|;
block|}
end_function

begin_function
name|void
name|db_err
parameter_list|(
name|int
name|err
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|)
block|{
if|if
condition|(
name|filename
operator|!=
name|NULL
operator|&&
name|err
operator|==
name|CNAMEANDOTHER
condition|)
name|ns_warning
argument_list|(
name|ns_log_load
argument_list|,
literal|"%s:%d:%s: CNAME and OTHER data error"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|DATAEXISTS
condition|)
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|1
argument_list|,
literal|"update failed %s %d"
argument_list|,
name|domain
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|gettoken
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|char
name|op
index|[
literal|32
index|]
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|top
label|:
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
return|return
operator|(
name|EOF
operator|)
return|;
case|case
literal|'$'
case|:
if|if
condition|(
name|getword
argument_list|(
name|op
argument_list|,
sizeof|sizeof
name|op
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"include"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|INCLUDE
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"origin"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|ORIGIN
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"generate"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|GENERATE
operator|)
return|;
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
literal|"ttl"
argument_list|,
name|op
argument_list|)
condition|)
return|return
operator|(
name|DEFAULTTTL
operator|)
return|;
block|}
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: Unknown $ option: $%s"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERRTOK
operator|)
return|;
case|case
literal|';'
case|:
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
goto|goto
name|top
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
return|return
operator|(
name|CURRENT
operator|)
return|;
case|case
literal|'.'
case|:
return|return
operator|(
name|DOT
operator|)
return|;
case|case
literal|'@'
case|:
return|return
operator|(
name|AT
operator|)
return|;
case|case
literal|'\n'
case|:
name|lineno
operator|++
expr_stmt|;
continue|continue;
case|case
literal|'\r'
case|:
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_TREAT_CR_AS_SPACE
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|CURRENT
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|DNAME
operator|)
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* int  * getword(buf, size, fp, preserve)  *	get next word, skipping blanks& comments.  *	'\' '\n' outside of "quotes" is considered a blank.  * parameters:  *	buf - destination  *	size - of destination  *	fp - file to read from  *	preserve - should we preserve \ before \\ and \.?  *   if preserve == 2, then keep all \  * return value:  *	0 = no word; perhaps EOL or EOF; lineno was incremented.  *	1 = word was read  */
end_comment

begin_function
name|int
name|getword
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|preserve
parameter_list|)
block|{
name|char
modifier|*
name|cp
init|=
name|buf
decl_stmt|;
name|int
name|c
decl_stmt|,
name|spaceok
decl_stmt|,
name|once
decl_stmt|;
name|empty_token
operator|=
literal|0
expr_stmt|;
comment|/* XXX global side effect. */
name|once
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|once
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
comment|/* Comment.  Skip to end of line. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
name|c
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
comment|/* 			 * Unescaped newline.  It's a terminator unless we're 			 * already midway into a token. 			 */
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
else|else
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'"'
condition|)
block|{
comment|/* "Quoted string."  Gather the whole string here. */
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'"'
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|preserve
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
if|if
condition|(
name|preserve
operator|==
literal|1
condition|)
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
comment|/* 			 * Newline string terminators are 			 * not token terminators. 			 */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Sample following character, check for terminator. */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
continue|continue;
block|}
name|spaceok
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
comment|/* Do escape processing. */
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
name|EOF
condition|)
name|c
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|preserve
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
default|default:
if|if
condition|(
name|preserve
operator|==
literal|1
condition|)
break|break;
case|case
literal|'\\'
case|:
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
condition|)
name|spaceok
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
operator|&&
operator|!
name|spaceok
condition|)
block|{
comment|/* Blank of some kind.  Skip run. */
while|while
condition|(
name|isspace
argument_list|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
argument_list|)
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Blank means terminator if the token is nonempty. */
if|if
condition|(
name|cp
operator|!=
name|buf
condition|)
comment|/* Trailing whitespace */
break|break;
continue|continue;
comment|/* Leading whitespace */
block|}
if|if
condition|(
name|cp
operator|>=
name|buf
operator|+
name|size
operator|-
literal|1
condition|)
break|break;
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|c
expr_stmt|;
block|}
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|buf
condition|)
name|empty_token
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|once
condition|)
name|lineno
operator|++
expr_stmt|;
return|return
operator|(
name|cp
operator|!=
name|buf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * getttl(fp, fn, ln, ttl, multiline)  *	read a word from the file and parse it as a TTL.  * return:  *	1 ttl found  *	0 word not read (EOF or EOL?)  *	-1 word read but it wasn't a ttl  * side effects:  *	*ttl is written if the return value is to be 1.  */
end_comment

begin_function
name|int
name|getttl
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|int
name|lineno
parameter_list|,
name|u_int32_t
modifier|*
name|ttl
parameter_list|,
name|int
modifier|*
name|multiline
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXDATA
index|]
decl_stmt|;
name|u_long
name|tmp
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
operator|!
name|feof
argument_list|(
name|fp
argument_list|)
operator|&&
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|&&
operator|*
name|multiline
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|multiline
operator|&&
name|len
operator|&&
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|')'
condition|)
block|{
name|buf
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|multiline
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|ns_parse_ttl
argument_list|(
name|buf
argument_list|,
operator|&
name|tmp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: expected a TTL, got \"%s\""
argument_list|,
name|fn
argument_list|,
name|lineno
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|multiline
condition|)
block|{
name|ch
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|fn
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ch
operator|==
literal|';'
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
else|else
name|ungetc
argument_list|(
name|ch
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
operator|*
name|ttl
operator|=
operator|(
name|u_int32_t
operator|)
name|tmp
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Get multiline words.  Same parameters as getword.  Handles any    number of leading ('s or )'s in the words it sees.    FIXME:  We kludge recognition of ( and ) for multiline input.    Each paren must appear at the start of a (blank-separated) word,    which is particularly counter-intuitive for ).  Good enough for now,    until Paul rewrites the parser.  (gnu@toad.com, oct96) */
end_comment

begin_function
specifier|static
name|int
name|getmlword
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|preserve
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
do|do
block|{
while|while
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
name|size
argument_list|,
name|fp
argument_list|,
name|preserve
argument_list|)
condition|)
block|{
comment|/* No more words on this line.  See if doing the 			   multiline thing. */
if|if
condition|(
operator|!
name|getmlword_nesting
condition|)
block|{
comment|/* Nope... */
name|ungetc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
comment|/* Push back newline */
name|lineno
operator|--
expr_stmt|;
comment|/* Unbump the lineno */
name|empty_token
operator|=
literal|0
expr_stmt|;
comment|/* Undo this botch */
return|return
literal|0
return|;
block|}
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* Error, no terminating ')' */
comment|/* Continue reading til we get a word... */
block|}
while|while
condition|(
literal|'('
operator|==
operator|*
name|buf
condition|)
block|{
comment|/* Word starts with paren.  Multiline mode. 			   Move the rest of the word down over the paren.  */
name|getmlword_nesting
operator|++
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
while|while
condition|(
literal|')'
operator|==
operator|*
name|buf
condition|)
block|{
name|getmlword_nesting
operator|--
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|1
index|]
operator|)
condition|)
name|p
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|0
condition|)
do|;
comment|/* loop til we get a non-( non-) word */
return|return
literal|1
return|;
comment|/* Got a word... */
block|}
end_function

begin_comment
comment|/* Get all the remaining words on a line, concatenated into one big    long (not too long!) string, with the whitespace squeezed out.    This routine, like getword(), does not swallow the newline if words seen.    This routine, unlike getword(), never swallows the newline if no words.    Parameters are the same as getword().  Result is: 	 0	got no words at all 	 1 	got one or more words 	-1	got too many words, they don't all fit; or missing close paren */
end_comment

begin_function
specifier|static
name|int
name|getallwords
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|int
name|preserve
parameter_list|)
block|{
name|char
modifier|*
name|runningbuf
init|=
name|buf
decl_stmt|;
name|int
name|runningsize
init|=
name|size
decl_stmt|;
name|int
name|len
decl_stmt|;
while|while
condition|(
name|runningsize
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|runningbuf
argument_list|,
name|runningsize
argument_list|,
name|fp
argument_list|,
name|preserve
argument_list|)
condition|)
block|{
return|return
name|runningbuf
operator|!=
name|buf
return|;
comment|/* 1 or 0 */
block|}
name|len
operator|=
name|strlen
argument_list|(
name|runningbuf
argument_list|)
expr_stmt|;
name|runningbuf
operator|+=
name|len
expr_stmt|;
name|runningsize
operator|-=
name|len
expr_stmt|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* Error, String too long */
block|}
end_function

begin_function
name|int
name|getnum
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|opt
parameter_list|,
name|int
modifier|*
name|multiline
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|seendigit
init|=
literal|0
decl_stmt|;
name|int
name|seendecimal
init|=
literal|0
decl_stmt|;
name|int
name|m
init|=
literal|0
decl_stmt|;
name|int
name|allow_dots
init|=
literal|0
decl_stmt|;
name|getnum_error
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DOTTED_SERIAL
if|if
condition|(
name|opt
operator|&
name|GETNUM_SERIAL
condition|)
name|allow_dots
operator|++
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
control|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|multiline
condition|)
name|lineno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|seendigit
condition|)
goto|goto
name|eol
goto|;
block|}
if|if
condition|(
name|seendigit
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|*
name|multiline
condition|)
name|lineno
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|seendigit
condition|)
goto|goto
name|eol
goto|;
block|}
if|if
condition|(
name|seendigit
condition|)
break|break;
continue|continue;
block|}
if|if
condition|(
name|getnum_error
condition|)
continue|continue;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|')'
operator|&&
name|seendigit
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|seendigit
operator|&&
operator|(
name|opt
operator|&
name|GETNUM_SCALED
operator|)
operator|&&
name|strchr
argument_list|(
literal|"KkMmGg"
argument_list|,
name|c
argument_list|)
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'K'
case|:
case|case
literal|'k'
case|:
name|n
operator|*=
literal|1024
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
case|case
literal|'m'
case|:
name|n
operator|*=
operator|(
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
case|case
literal|'g'
case|:
name|n
operator|*=
operator|(
literal|1024
operator|*
literal|1024
operator|*
literal|1024
operator|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|seendecimal
operator|||
name|c
operator|!=
literal|'.'
operator|||
operator|!
name|allow_dots
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: expected a number"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|getnum_error
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|seendigit
condition|)
name|n
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|SENSIBLE_DOTS
name|n
operator|*=
literal|10000
expr_stmt|;
else|#
directive|else
name|n
operator|*=
literal|1000
expr_stmt|;
endif|#
directive|endif
name|seendigit
operator|=
literal|1
expr_stmt|;
name|seendecimal
operator|=
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
ifdef|#
directive|ifdef
name|SENSIBLE_DOTS
if|if
condition|(
name|seendecimal
condition|)
name|m
operator|=
name|m
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|else
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
else|#
directive|else
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
endif|#
directive|endif
name|seendigit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|getnum_error
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|m
operator|>
literal|9999
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: number after the decimal point exceeds 9999"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|getnum_error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|seendecimal
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: decimal serial number interpreted as %d"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|n
operator|+
name|m
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|n
operator|+
name|m
operator|)
return|;
name|eol
label|:
name|ns_error
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: unexpected end of line"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|getnum_error
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|getnonblank
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
name|int
name|multiline
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
name|c
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|multiline
condition|)
name|lineno
operator|++
expr_stmt|;
else|else
goto|goto
name|eol
goto|;
block|}
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|';'
condition|)
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
empty_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|multiline
condition|)
name|lineno
operator|++
expr_stmt|;
else|else
goto|goto
name|eol
goto|;
block|}
continue|continue;
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: unexpected EOF"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
name|EOF
operator|)
return|;
name|eol
label|:
name|ns_error
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: unexpected end of line"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
comment|/* don't ungetc(c, fp); as the caller will do this. */
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replace all single "$"'s in "name" with "it".  * ${delta} will add delta to "it" before printing.  * ${delta,width} will change print width as well, zero fill is implied  * ${delta,width,radix} will change radix as well, can be d, o, x, X.  * i.e. ${0,2,X} will produce a two digit hex (upper case) with zero fill.  * Append "origin" to name if required and validate result with makename.  * To get a "$" or "{" in the output use \ before it.  * Return 0 on no error or -1 on error.  * Resulting name stored in "buf".  */
end_comment

begin_function
specifier|static
name|int
name|genname
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|it
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|char
modifier|*
name|bp
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|eom
init|=
name|buf
operator|+
name|size
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|char
name|numbuf
index|[
literal|32
index|]
decl_stmt|;
name|char
name|fmt
index|[
literal|32
index|]
decl_stmt|;
name|int
name|delta
init|=
literal|0
decl_stmt|;
name|int
name|width
decl_stmt|;
while|while
condition|(
operator|*
name|name
condition|)
block|{
if|if
condition|(
operator|*
name|name
operator|==
literal|'$'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|name
operator|)
operator|==
literal|'$'
condition|)
block|{
comment|/* should be deprecated.  how? */
if|if
condition|(
name|bp
operator|>=
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|fmt
argument_list|,
literal|"%d"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'{'
condition|)
block|{
switch|switch
condition|(
name|sscanf
argument_list|(
name|name
argument_list|,
literal|"{%d,%d,%1[doxX]}"
argument_list|,
operator|&
name|delta
argument_list|,
operator|&
name|width
argument_list|,
name|numbuf
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
break|break;
case|case
literal|2
case|:
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%0%dd"
argument_list|,
name|width
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"%%0%d%c"
argument_list|,
name|width
argument_list|,
name|numbuf
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|name
operator|&&
operator|*
name|name
operator|++
operator|!=
literal|'}'
condition|)
block|{
continue|continue;
block|}
block|}
name|sprintf
argument_list|(
name|numbuf
argument_list|,
name|fmt
argument_list|,
name|it
operator|+
name|delta
argument_list|)
expr_stmt|;
name|cp
operator|=
name|numbuf
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
if|if
condition|(
name|bp
operator|>=
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
operator|++
name|name
operator|)
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|bp
operator|>=
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
operator|*
name|name
condition|)
block|{
case|case
literal|'\\'
case|:
case|case
literal|'.'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|bp
operator|>=
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
default|default:
if|if
condition|(
name|bp
operator|>=
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|bp
operator|>=
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|bp
operator|++
operator|=
operator|*
name|name
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bp
operator|>=
name|eom
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|origin
operator|==
name|NULL
condition|?
literal|0
else|:
name|makename
argument_list|(
name|buf
argument_list|,
name|origin
argument_list|,
name|size
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Take name and fix it according to following rules:  * "." means root.  * "@" means current origin.  * "name." means no changes.  * "name" means append origin.  */
end_comment

begin_function
name|int
name|makename
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|u_char
name|domain
index|[
name|MAXCDNAME
index|]
decl_stmt|;
switch|switch
condition|(
name|ns_name_pton
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|1
case|:
comment|/* FULLY QUALIFIED */
break|break;
case|case
literal|0
case|:
comment|/* UNQUALIFIED */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
operator|==
literal|0
condition|)
comment|/* must test raw name */
name|domain
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|domain
argument_list|,
name|domain
operator|+
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* step back over root, append origin */
switch|switch
condition|(
name|ns_name_pton
argument_list|(
name|origin
argument_list|,
name|domain
operator|+
name|n
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
name|n
operator|+
literal|1
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
case|case
literal|0
case|:
case|case
literal|1
case|:
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|ns_name_ntop
argument_list|(
name|domain
argument_list|,
name|name
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
comment|/* root */
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|makename_ok
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|,
name|int
name|class
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|enum
name|transport
name|transport
parameter_list|,
name|enum
name|context
name|context
parameter_list|,
specifier|const
name|char
modifier|*
name|owner
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|lineno
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|ret
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|makename
argument_list|(
name|name
argument_list|,
name|origin
argument_list|,
name|size
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: makename failed"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|zp
argument_list|,
name|transport
argument_list|,
name|context
argument_list|,
name|owner
argument_list|,
name|inaddr_any
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: database naming error"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|endline
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
break|break;
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|MAXPORT
value|1024
end_define

begin_define
define|#
directive|define
name|MAXLEN
value|24
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|char
name|getprotocol
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|k
decl_stmt|;
name|char
name|b
index|[
name|MAXLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|k
operator|=
name|protocolnumber
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: unknown protocol: %s."
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|char
operator|)
name|k
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|BIND_UPDATE
end_ifndef

begin_function
specifier|static
endif|#
directive|endif
name|int
name|getservices
parameter_list|(
name|int
name|offset
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|j
decl_stmt|,
name|ch
decl_stmt|,
name|k
decl_stmt|,
name|maxl
decl_stmt|,
name|bracket
decl_stmt|;
name|char
name|bm
index|[
name|MAXPORT
operator|/
literal|8
index|]
decl_stmt|;
name|char
name|b
index|[
name|MAXLEN
index|]
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|MAXPORT
operator|/
literal|8
condition|;
name|j
operator|++
control|)
name|bm
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
name|maxl
operator|=
literal|0
expr_stmt|;
name|bracket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|getword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
operator|||
name|bracket
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|b
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|'('
condition|)
block|{
name|bracket
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|b
index|[
literal|0
index|]
operator|==
literal|')'
condition|)
block|{
name|bracket
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
name|lineno
operator|++
expr_stmt|;
break|break;
block|}
name|k
operator|=
name|servicenumber
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: Unknown service '%s'"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|k
operator|<
name|MAXPORT
operator|)
operator|&&
operator|(
name|k
operator|)
condition|)
block|{
name|bm
index|[
name|k
operator|/
literal|8
index|]
operator||=
operator|(
literal|0x80
operator|>>
operator|(
name|k
operator|%
literal|8
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|k
operator|>
name|maxl
condition|)
name|maxl
operator|=
name|k
expr_stmt|;
block|}
else|else
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: port no. (%d) too big"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|,
name|k
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|bracket
condition|)
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: missing close paren"
argument_list|,
name|src
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|maxl
operator|=
name|maxl
operator|/
literal|8
operator|+
literal|1
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|offset
argument_list|,
name|bm
argument_list|,
name|maxl
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxl
operator|+
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Converts a word to a u_int32_t.  Error if any non-numeric  * characters in the word, except leading or trailing white space.  */
end_comment

begin_function
specifier|static
name|u_int32_t
name|wordtouint32
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
name|u_long
name|result
decl_stmt|;
name|u_int32_t
name|res2
decl_stmt|;
name|char
modifier|*
name|bufend
decl_stmt|;
name|wordtouint32_error
operator|=
literal|0
expr_stmt|;
name|result
operator|=
name|strtoul
argument_list|(
name|buf
argument_list|,
operator|&
name|bufend
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bufend
operator|==
name|buf
condition|)
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
else|else
while|while
condition|(
literal|'\0'
operator|!=
operator|*
name|bufend
condition|)
block|{
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|bufend
argument_list|)
condition|)
name|bufend
operator|++
expr_stmt|;
else|else
block|{
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* Check for truncation between u_long and u_int32_t */
name|res2
operator|=
name|result
expr_stmt|;
if|if
condition|(
name|res2
operator|!=
name|result
condition|)
name|wordtouint32_error
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|res2
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getcharstring
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|char
modifier|*
name|data
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|minfields
parameter_list|,
name|int
name|maxfields
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|)
block|{
name|int
name|nfield
init|=
literal|0
decl_stmt|,
name|done
init|=
literal|0
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|b
init|=
name|buf
decl_stmt|;
do|do
block|{
name|nfield
operator|++
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ALLOW_LONG_TXT_RDATA
name|b
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ns_t_txt
operator|||
name|type
operator|==
name|ns_t_x25
condition|)
block|{
while|while
condition|(
name|i
operator|>
name|MAXCHARSTRING
operator|&&
name|n
operator|+
name|MAXCHARSTRING
operator|+
literal|1
operator|<
name|MAXDATA
condition|)
block|{
name|data
index|[
name|n
index|]
operator|=
operator|(
name|char
operator|)
name|MAXCHARSTRING
expr_stmt|;
name|memmove
argument_list|(
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
name|b
argument_list|,
name|MAXCHARSTRING
argument_list|)
expr_stmt|;
name|n
operator|+=
name|MAXCHARSTRING
operator|+
literal|1
expr_stmt|;
name|b
operator|+=
name|MAXCHARSTRING
expr_stmt|;
name|i
operator|-=
name|MAXCHARSTRING
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* ALLOW_LONG_TXT_RDATA */
if|if
condition|(
name|i
operator|>
name|MAXCHARSTRING
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: RDATA field %d too long"
argument_list|,
name|src
argument_list|,
name|lineno
operator|-
literal|1
argument_list|,
name|nfield
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|+
name|i
operator|+
literal|1
operator|>
name|MAXDATA
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: total RDATA too long"
argument_list|,
name|src
argument_list|,
name|lineno
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|data
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|memmove
argument_list|(
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
name|b
argument_list|,
operator|(
name|int
operator|)
name|i
argument_list|)
expr_stmt|;
name|n
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
name|done
operator|=
operator|(
name|maxfields
operator|&&
name|nfield
operator|>=
name|maxfields
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|done
operator|&&
name|getword
argument_list|(
name|buf
argument_list|,
name|MAXDATA
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
do|;
if|if
condition|(
name|nfield
operator|<
name|minfields
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s:%d: expected %d RDATA fields, only saw %d"
argument_list|,
name|src
argument_list|,
name|lineno
operator|-
literal|1
argument_list|,
name|minfields
argument_list|,
name|nfield
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|done
condition|)
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

begin_comment
comment|/*   * get_nxt_types(): Read the list of types in the NXT record.  *  * Data is the array where the bit flags are stored; it must  * contain at least ns_t_any/NS_NXT_BITS bytes.   * FP is the input FILE *.  * Filename is the sourcefile   *  * The result is how many bytes are significant in the result.  * ogud@tis.com 1995  */
end_comment

begin_function
specifier|static
name|int
name|get_nxt_types
parameter_list|(
name|u_char
modifier|*
name|data
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|char
name|b
index|[
name|MAXLABEL
index|]
decl_stmt|;
comment|/* Not quite the right size, but good enough */
name|int
name|maxtype
init|=
literal|0
decl_stmt|;
name|int
name|success
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
name|NS_NXT_MAX
operator|/
name|NS_NXT_BITS
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
name|getmlword
argument_list|(
name|b
argument_list|,
sizeof|sizeof
argument_list|(
name|b
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|||
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|strlen
argument_list|(
name|b
argument_list|)
operator|==
literal|0
operator|||
name|b
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|)
continue|continue;
comment|/* Parse RR type (A, MX, etc) */
name|type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
operator|(
name|char
operator|*
operator|)
name|b
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|success
operator|)
operator|||
name|type
operator|==
name|ns_t_any
condition|)
block|{
name|errs
operator|++
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: Line %d: Unknown type: %s in NXT record."
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|b
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|NS_NXT_BIT_SET
argument_list|(
name|type
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|>
name|maxtype
condition|)
name|maxtype
operator|=
name|type
expr_stmt|;
block|}
if|if
condition|(
name|errs
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|maxtype
operator|/
name|NS_NXT_BITS
operator|+
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* sanity checks PRIMARY ONLY */
end_comment

begin_function
specifier|static
name|void
name|fixup_soa
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
comment|/* Sanity: give enough time for the zone to transfer (retry). */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
name|zp
operator|->
name|z_refresh
operator|+
name|zp
operator|->
name|z_retry
operator|)
condition|)
name|ns_notice
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is less than SOA refresh+retry (%u< %u+%u)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
comment|/* Sanity. */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
name|zp
operator|->
name|z_refresh
operator|+
literal|10
operator|*
name|zp
operator|->
name|z_retry
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is less than refresh + 10 * retry \ (%u< (%u + 10 * %u))"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity: most hardware/telco faults are detected and fixed within  	 * a week, secondaries should continue to operate for this time. 	 * (minimum of 4 days for long weekends) 	 */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|<
operator|(
literal|7
operator|*
literal|24
operator|*
literal|3600
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is less than 7 days (%u)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|)
expr_stmt|;
comment|/* 	 * Sanity: maximum down time if we havn't talked for six months  	 * war must have broken out. 	 */
if|if
condition|(
name|zp
operator|->
name|z_expire
operator|>
operator|(
literal|183
operator|*
literal|24
operator|*
literal|3600
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA expire value is greater than 6 months (%u)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|)
expr_stmt|;
comment|/* Sanity. */
if|if
condition|(
name|zp
operator|->
name|z_refresh
operator|<
operator|(
name|zp
operator|->
name|z_retry
operator|*
literal|2
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: WARNING SOA refresh value is less than 2 * retry (%u< %u * 2)"
argument_list|,
name|fn
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* this function reads in the sig record rdata from the input file and  * returns the following codes  *> 0     length of the recrod  * ERR_EOF  end of file  *  */
end_comment

begin_function
specifier|static
name|int
name|parse_sig_rr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|data_size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|u_int32_t
name|ttl
parameter_list|,
name|enum
name|context
name|domain_ctx
parameter_list|,
name|enum
name|transport
name|transport
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
comment|/* The SIG record looks like this in the db file:    Name Cl SIG RRtype Algid [OTTL] Texp Tsig Kfoot Signer Sig       where:  Name and Cl are as usual    SIG     is a keyword    RRtype  is a char string    ALGid   is  8 bit u_int    Labels  is  8 bit u_int    OTTL    is 32 bit u_int (optionally present)    Texp    is YYYYMMDDHHMMSS    Tsig    is YYYYMMDDHHMMSS    Kfoot   is 16-bit unsigned decimal integer    Signer  is a char string    Sig     is 64 to 319 base-64 digits    A missing OTTL is detected by the magnitude of the Texp value    that follows it, which is larger than any u_int.    The Labels field in the binary RR does not appear in the    text RR.       It's too crazy to run these pages of SIG code at the right    margin.  I'm exdenting them for readability. */
name|u_int32_t
name|sig_type
decl_stmt|;
name|int
name|dateerror
decl_stmt|;
name|int
name|siglen
decl_stmt|,
name|success
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_int32_t
name|al
decl_stmt|,
name|la
decl_stmt|,
name|n
decl_stmt|;
name|u_int32_t
name|signtime
decl_stmt|,
name|exptime
decl_stmt|,
name|timetilexp
decl_stmt|;
name|u_int32_t
name|origTTL
decl_stmt|;
name|enum
name|context
name|context
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|char
modifier|*
name|errtype
init|=
literal|"SIG error"
decl_stmt|;
name|int
name|i
decl_stmt|,
name|my_buf_size
init|=
name|MAXDATA
decl_stmt|,
name|errs
init|=
literal|0
decl_stmt|;
comment|/* The TTL gets checked against the Original TTL,                    and bounded by the signature expiration time, which                     are both under the signature.  We can't let TTL drift                    based on the SOA record.  If defaulted, fix it now.                     (It's not clear to me why USE_MINIMUM isn't eliminated                    before putting ALL RR's into the database.  -gnu@toad.com) */
if|if
condition|(
name|ttl
operator|==
name|USE_MINIMUM
condition|)
name|ttl
operator|=
name|zp
operator|->
name|z_minimum
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recovery */
comment|/* RRtype (char *) 	 * if old style inp will contain the next token 	 *copy that into buffer, otherwise read from file 	 */
if|if
condition|(
name|buf
operator|&&
name|buf_len
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"SIG record doesn't specify type"
argument_list|)
expr_stmt|;
name|sig_type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
operator|||
name|sig_type
operator|==
name|ns_t_any
condition|)
block|{
comment|/* 		 * We'll also accept a numeric RR type, 		 * for signing RR types that this version 		 * of named doesn't yet understand. 		 * In the ns_t_any case, we rely on wordtouint32 		 * to fail when scanning the string "ANY". 		 */
name|sig_type
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|sig_type
operator|>
literal|0xFFFF
condition|)
name|ERRTO
argument_list|(
literal|"Unknown RR type in SIG record"
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|sig_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Algorithm id (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing algorithm ID"
argument_list|)
expr_stmt|;
name|al
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|al
operator|||
name|wordtouint32_error
operator|||
literal|255
operator|<=
name|al
condition|)
name|ERRTO
argument_list|(
literal|"Bad algorithm number"
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|al
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* 	 * Labels (8-bit decimal) 	 */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing label count"
argument_list|)
expr_stmt|;
name|la
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|255
operator|<=
name|la
operator|||
operator|(
literal|0
operator|==
name|la
operator|&&
operator|*
name|domain
operator|!=
literal|'\0'
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"Bad label count number"
argument_list|)
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
operator|(
name|u_char
operator|)
name|la
expr_stmt|;
name|i
operator|++
expr_stmt|;
comment|/* 	 * OTTL (optional u_int32_t) and 	 * Texp (u_int32_t date) 	 */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"OTTL and expiration time missing"
argument_list|)
expr_stmt|;
comment|/* 	 * See if OTTL is missing and this is a date. 	 * This relies on good, silent error checking 	 * in ns_datetosecs. 	 */
name|exptime
operator|=
name|ns_datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dateerror
condition|)
block|{
comment|/* Output TTL as OTTL */
name|origTTL
operator|=
name|ttl
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|origTTL
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
block|}
else|else
block|{
comment|/* Parse and output OTTL; scan TEXP */
name|origTTL
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|origTTL
operator|>=
literal|0
operator|||
name|wordtouint32_error
operator|||
operator|(
name|origTTL
operator|>
literal|0x7fffffff
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"Original TTL value bad"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|origTTL
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Expiration time missing"
argument_list|)
expr_stmt|;
name|exptime
operator|=
name|ns_datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dateerror
operator|||
name|exptime
operator|>
literal|0x7fffffff
operator|||
name|exptime
operator|<=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Invalid expiration time"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|exptime
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
comment|/* Tsig (u_int32_t) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing signature time"
argument_list|)
expr_stmt|;
name|signtime
operator|=
name|ns_datetosecs
argument_list|(
name|buf
argument_list|,
operator|&
name|dateerror
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|==
name|signtime
operator|||
name|dateerror
condition|)
name|ERRTO
argument_list|(
literal|"Invalid signature time"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTLONG
argument_list|(
name|signtime
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|4
expr_stmt|;
comment|/* Kfootprint (unsigned_16) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing key footprint"
argument_list|)
expr_stmt|;
name|n
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|n
operator|>=
literal|0x0ffff
condition|)
name|ERRTO
argument_list|(
literal|"Invalid key footprint"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
literal|2
expr_stmt|;
comment|/* Signer's Name */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"Missing signer's name"
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|context
operator|=
name|domain_ctx
expr_stmt|;
name|MAKENAME_OKZP
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
name|i
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* 	 * Signature (base64 of any length) 	 * We don't care what algorithm it uses or what 	 * the internal structure of the BASE64 data is. 	 */
if|if
condition|(
operator|!
name|getallwords
argument_list|(
name|buf
argument_list|,
name|my_buf_size
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|siglen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|siglen
operator|=
name|b64_pton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|data_size
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|<
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Signature block bad"
argument_list|)
expr_stmt|;
block|}
comment|/* set total length and we're done! */
name|n
operator|=
name|i
operator|+
name|siglen
expr_stmt|;
comment|/* 	 * Check signature time, expiration, and adjust TTL.  Note 	 * that all time values are in GMT (UTC), *not* local time. 	 */
name|now
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* need to find a better place for this  XXX ogud */
comment|/* Don't let bogus name servers increase the signed TTL */
if|if
condition|(
name|ttl
operator|>
name|origTTL
condition|)
name|ERRTO
argument_list|(
literal|"TTL is greater than signed original TTL"
argument_list|)
expr_stmt|;
comment|/* Don't let bogus signers "sign" in the future.  */
if|if
condition|(
name|signtime
operator|>
operator|(
name|u_int32_t
operator|)
name|now
condition|)
name|ERRTO
argument_list|(
literal|"signature time is in the future"
argument_list|)
expr_stmt|;
comment|/* Ignore received SIG RR's that are already expired.  */
if|if
condition|(
name|exptime
operator|<=
operator|(
name|u_int32_t
operator|)
name|now
condition|)
name|ERRTO
argument_list|(
literal|"expiration time is in the past"
argument_list|)
expr_stmt|;
comment|/* Lop off the TTL at the expiration time.  */
name|timetilexp
operator|=
name|exptime
operator|-
name|now
expr_stmt|;
if|if
condition|(
name|timetilexp
operator|<
name|ttl
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_load
argument_list|,
literal|1
argument_list|,
literal|"shrinking expiring %s SIG TTL from %d to %d"
argument_list|,
name|p_secstodate
argument_list|(
name|exptime
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|timetilexp
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|timetilexp
expr_stmt|;
block|}
comment|/* 	 * Check algorithm-ID and key structure, for 	 * the algorithm-ID's that we know about. 	 */
switch|switch
condition|(
name|al
condition|)
block|{
case|case
name|NS_ALG_MD5RSA
case|:
if|if
condition|(
name|siglen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"No key for RSA algorithm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|<
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"Signature too short"
argument_list|)
expr_stmt|;
if|if
condition|(
name|siglen
operator|>
operator|(
name|NS_MD5RSA_MAX_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Signature too long"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ALG_DH
case|:
if|if
condition|(
name|siglen
operator|<
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"DH Signature too short"
argument_list|)
expr_stmt|;
break|break;
comment|/* need more tests here */
case|case
name|NS_ALG_DSA
case|:
if|if
condition|(
name|siglen
operator|<
name|NS_DSA_SIG_SIZE
condition|)
name|ERRTO
argument_list|(
literal|"DSS Signature too short"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|siglen
operator|>
name|NS_DSA_SIG_SIZE
condition|)
name|ERRTO
argument_list|(
literal|"DSS Signature too long "
argument_list|)
expr_stmt|;
break|break;
comment|/* need more tests here */
case|case
name|NS_ALG_EXPIRE_ONLY
case|:
if|if
condition|(
name|siglen
operator|!=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Signature supplied to expire-only algorithm"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ALG_PRIVATE_OID
case|:
if|if
condition|(
name|siglen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"No ObjectID in key"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERRTO
argument_list|(
literal|"UNKOWN SIG algorithm"
argument_list|)
expr_stmt|;
block|}
comment|/* Should we complain about algorithm-ID's that we	 	   don't understand?  It may help debug some obscure 	   cases, but in general we should accept any RR whether 	   we could cryptographically process it or not; it 	   may be being published for some newer DNS clients 	   to validate themselves.  */
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* flush the rest of the line */
return|return
operator|(
name|n
operator|)
return|;
name|err
label|:
operator|*
name|errmsg
operator|=
name|errtype
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_nxt_rr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|data_size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|enum
name|context
name|context
parameter_list|,
name|enum
name|transport
name|transport
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
comment|/* The NXT record looks like: 	   Name Cl NXT nextname RRT1 RRT2 MX A SOA ... 	   	   where:  Name and Cl are as usual 	   NXT     is a keyword 	   nextname is the next valid name in the zone after "Name". 	   All   names between the two are  known to be nonexistent. 	   RRT's... are a series of RR type  names, which indicate that 	   RR's of these types are published for "Name", and 	   	that no RR's of any other types are published for "Name".  	   When a NXT record is cryptographically signed, it proves the 	   nonexistence of an RR (actually a whole set of RR's).  	*/
name|int
name|n
decl_stmt|,
name|errs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|;
comment|/*	char *origin = zp->z_origin; 	int class    = zp->z_class; */
operator|*
name|errmsg
operator|=
literal|"NXT name error"
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|MAKENAME_OKZP
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|=
name|n
operator|+
name|data
expr_stmt|;
name|i
operator|=
name|get_nxt_types
argument_list|(
name|cp
argument_list|,
name|fp
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
return|return
operator|(
name|n
operator|+
name|i
operator|)
return|;
operator|*
name|errmsg
operator|=
literal|"NXT type error"
expr_stmt|;
name|err
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_cert_rr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|data_size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
comment|/* Cert record looks like: 	 *   Type Key_tag Alg Cert 	 *   Type: certification type number (16) 	 *   Key_tag: tag of corresponding KEY RR (16) 	 *   Alg: algorithm of the KEY RR (8) 	 *   Cert: base64 enocded block 	 */
name|u_char
modifier|*
name|cp
decl_stmt|;
name|u_int32_t
name|cert_type
decl_stmt|,
name|key_tag
decl_stmt|,
name|alg
decl_stmt|;
name|char
modifier|*
name|errtype
init|=
literal|"CERT parse error"
decl_stmt|;
name|int
name|certlen
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|,
name|success
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|cert_type
operator|=
name|sym_ston
argument_list|(
name|__p_cert_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|cert_type
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|cert_type
operator|>
literal|0xFFFF
condition|)
name|ERRTO
argument_list|(
literal|"CERT type out of range"
argument_list|)
expr_stmt|;
block|}
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|cert_type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|buf_len
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"CERT doesn't specify type"
argument_list|)
expr_stmt|;
name|key_tag
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|key_tag
operator|>
literal|0xFFFF
condition|)
name|ERRTO
argument_list|(
literal|"CERT KEY tag out of range"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|key_tag
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|i
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"CERT missing algorithm ID"
argument_list|)
expr_stmt|;
name|alg
operator|=
name|sym_ston
argument_list|(
name|__p_key_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|alg
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
name|alg
operator|>
literal|0xFF
condition|)
name|ERRTO
argument_list|(
literal|"CERT KEY alg out of range"
argument_list|)
expr_stmt|;
block|}
name|data
index|[
name|i
operator|++
index|]
operator|=
operator|(
name|u_char
operator|)
name|alg
expr_stmt|;
if|if
condition|(
operator|!
name|getallwords
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|certlen
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
operator|&
name|data
index|[
name|i
index|]
expr_stmt|;
name|certlen
operator|=
name|b64_pton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|certlen
operator|<
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"CERT blob has encoding error"
argument_list|)
expr_stmt|;
block|}
comment|/* set total length */
name|n
operator|=
name|i
operator|+
name|certlen
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
name|err
label|:
operator|*
name|errmsg
operator|=
name|errtype
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|parse_key_rr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|data_size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|enum
name|context
name|context
parameter_list|,
name|enum
name|transport
name|transport
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
comment|/* The KEY record looks like this in the db file: 	 *	Name  Cl KEY Flags  Proto  Algid  PublicKeyData 	 * where: 	 *	Name,Cl per usual 	 *	KEY	RR type 	 *	Flags	4 digit hex value (unsigned_16) 	 *	Proto	8 bit u_int 	 *	Algid	8 bit u_int 	 *	PublicKeyData 	 *		a string of base64 digits, 	 *		skipping any embedded whitespace. 	 */
name|u_int32_t
name|al
decl_stmt|,
name|pr
decl_stmt|;
name|int
name|nk
decl_stmt|,
name|klen
decl_stmt|,
name|i
decl_stmt|,
name|n
decl_stmt|;
name|u_int32_t
name|keyflags
decl_stmt|;
name|char
modifier|*
name|errtype
init|=
literal|"KEY error"
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|expstart
decl_stmt|;
name|u_int
name|expbytes
decl_stmt|,
name|modbytes
decl_stmt|;
name|i
operator|=
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recov. */
comment|/*>>> Flags (unsigned_16)  */
name|keyflags
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|0xFFFF
operator|<
name|keyflags
condition|)
name|ERRTO
argument_list|(
literal|"KEY flags error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyflags
operator|&
name|NS_KEY_RESERVED_BITMASK
condition|)
name|ERRTO
argument_list|(
literal|"KEY Reserved Flag Bit"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|keyflags
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/*>>> Protocol (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|buf_len
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"KEY Protocol Field"
argument_list|)
expr_stmt|;
name|pr
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|255
operator|<
name|pr
condition|)
name|ERRTO
argument_list|(
literal|"KEY Protocol Field"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|u_char
operator|)
name|pr
expr_stmt|;
comment|/*>>> Algorithm id (8-bit decimal) */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|buf_len
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"KEY Algorithm ID"
argument_list|)
expr_stmt|;
name|al
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|0
operator|==
name|al
operator|||
literal|255
operator|==
name|al
operator|||
literal|255
operator|<
name|al
condition|)
name|ERRTO
argument_list|(
literal|"KEY Algorithm ID"
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|u_char
operator|)
name|al
expr_stmt|;
comment|/*>>> Extended KEY flag field in bytes 5 and 6 */
if|if
condition|(
name|NS_KEY_EXTENDED_FLAGS
operator|&
name|keyflags
condition|)
block|{
name|u_int32_t
name|keyflags2
decl_stmt|;
if|if
condition|(
operator|!
name|getmlword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|buf_len
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|ERRTO
argument_list|(
literal|"KEY Flags Field"
argument_list|)
expr_stmt|;
name|keyflags2
operator|=
name|wordtouint32
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|wordtouint32_error
operator|||
literal|0xFFFF
operator|<
name|keyflags2
condition|)
name|ERRTO
argument_list|(
literal|"Extended key flags error"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyflags2
operator|&
name|NS_KEY_RESERVED_BITMASK2
condition|)
name|ERRTO
argument_list|(
literal|"KEY Reserved Flag2 Bit"
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
name|keyflags2
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
comment|/*>>> Public Key data is in BASE64. 	 *	We don't care what algorithm it uses or what 	 *	the internal structure of the BASE64 data is. 	 */
if|if
condition|(
operator|!
name|getallwords
argument_list|(
name|buf
argument_list|,
name|MAXDATA
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
name|klen
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* Convert from BASE64 to binary. */
name|klen
operator|=
name|b64_pton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|data_size
operator|-
operator|(
name|cp
operator|-
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|klen
operator|<
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Public Key"
argument_list|)
expr_stmt|;
block|}
comment|/* set total length */
name|n
operator|=
name|klen
operator|+
operator|(
name|cp
operator|-
name|data
operator|)
expr_stmt|;
comment|/* 	 * Now check for valid key flags& algs& etc, from the RFC. 	 */
if|if
condition|(
name|NS_KEY_TYPE_NO_KEY
operator|==
operator|(
name|keyflags
operator|&
name|NS_KEY_TYPEMASK
operator|)
condition|)
name|nk
operator|=
literal|1
expr_stmt|;
comment|/* No-key */
else|else
name|nk
operator|=
literal|0
expr_stmt|;
comment|/* have a key */
if|if
condition|(
operator|(
name|keyflags
operator|&
operator|(
name|NS_KEY_NAME_TYPE
operator||
name|NS_KEY_TYPEMASK
operator|)
operator|)
operator|==
operator|(
name|NS_KEY_NAME_ZONE
operator||
name|NS_KEY_TYPE_CONF_ONLY
operator|)
condition|)
comment|/* Zone key must have Auth bit set. */
name|ERRTO
argument_list|(
literal|"KEY Zone Key Auth. bit"
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|==
literal|0
operator|&&
name|nk
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Algorithm"
argument_list|)
expr_stmt|;
if|if
condition|(
name|al
operator|!=
literal|0
operator|&&
name|pr
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Protocols"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|==
literal|1
operator|&&
name|klen
operator|!=
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY No-Key Flags Set"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nk
operator|==
literal|0
operator|&&
name|klen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"KEY Type Spec'd"
argument_list|)
expr_stmt|;
comment|/*  	 *  Check algorithm-ID and key structure, for the algorithm-ID's  	 * that we know about.  	 */
switch|switch
condition|(
name|al
condition|)
block|{
case|case
name|NS_ALG_MD5RSA
case|:
if|if
condition|(
name|klen
operator|==
literal|0
condition|)
break|break;
name|expstart
operator|=
name|cp
expr_stmt|;
name|expbytes
operator|=
operator|*
name|expstart
operator|++
expr_stmt|;
if|if
condition|(
name|expbytes
operator|==
literal|0
condition|)
name|GETSHORT
argument_list|(
name|expbytes
argument_list|,
name|expstart
argument_list|)
expr_stmt|;
if|if
condition|(
name|expbytes
operator|<
literal|1
condition|)
name|ERRTO
argument_list|(
literal|"Exponent too short"
argument_list|)
expr_stmt|;
if|if
condition|(
name|expbytes
operator|>
operator|(
name|NS_MD5RSA_MAX_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Exponent too long"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|expstart
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Exponent w/ 0"
argument_list|)
expr_stmt|;
name|modbytes
operator|=
name|klen
operator|-
operator|(
name|expbytes
operator|+
operator|(
name|expstart
operator|-
name|cp
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|modbytes
operator|<
operator|(
name|NS_MD5RSA_MIN_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Modulus too short"
argument_list|)
expr_stmt|;
if|if
condition|(
name|modbytes
operator|>
operator|(
name|NS_MD5RSA_MAX_BITS
operator|+
literal|7
operator|)
operator|/
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"Modulus too long"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|expstart
operator|+
name|expbytes
operator|)
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"Modulus starts w/ 0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NS_ALG_DH
case|:
block|{
name|u_char
modifier|*
name|dh_cp
decl_stmt|;
name|u_int16_t
name|dh_len
decl_stmt|,
name|plen
decl_stmt|,
name|glen
decl_stmt|,
name|ulen
decl_stmt|;
name|dh_cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cp
expr_stmt|;
name|GETSHORT
argument_list|(
name|plen
argument_list|,
name|dh_cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|<
literal|16
condition|)
name|ERRTO
argument_list|(
literal|"DH short plen"
argument_list|)
expr_stmt|;
name|dh_len
operator|=
literal|2
operator|+
name|plen
expr_stmt|;
if|if
condition|(
name|dh_len
operator|>
name|klen
condition|)
name|ERRTO
argument_list|(
literal|"DH plen> klen"
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|glen
argument_list|,
name|dh_cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|glen
operator|<=
literal|0
operator|||
name|glen
operator|>
name|plen
condition|)
name|ERRTO
argument_list|(
literal|"DH glen bad"
argument_list|)
expr_stmt|;
name|dh_len
operator|=
literal|2
operator|+
name|glen
expr_stmt|;
if|if
condition|(
name|dh_len
operator|>
name|klen
condition|)
name|ERRTO
argument_list|(
literal|"DH glen> klen"
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|ulen
argument_list|,
name|dh_cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ulen
operator|<=
literal|0
operator|||
name|ulen
operator|>
name|plen
condition|)
name|ERRTO
argument_list|(
literal|"DH ulen bad"
argument_list|)
expr_stmt|;
name|dh_len
operator|=
literal|2
operator|+
name|ulen
expr_stmt|;
if|if
condition|(
name|dh_len
operator|>
name|klen
condition|)
name|ERRTO
argument_list|(
literal|"DH ulen> klen"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dh_len
operator|<
name|klen
condition|)
name|ERRTO
argument_list|(
literal|"DH *len< klen"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NS_ALG_DSA
case|:
block|{
name|u_int8_t
name|t
decl_stmt|;
if|if
condition|(
name|klen
operator|==
literal|0
condition|)
break|break;
name|t
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|8
condition|)
name|ERRTO
argument_list|(
literal|"DSA T value"
argument_list|)
expr_stmt|;
if|if
condition|(
name|klen
operator|!=
operator|(
literal|1
operator|+
literal|20
operator|+
literal|3
operator|*
operator|(
literal|64
operator|+
literal|8
operator|*
name|t
operator|)
operator|)
condition|)
name|ERRTO
argument_list|(
literal|"DSA length"
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|NS_ALG_PRIVATE_OID
case|:
if|if
condition|(
name|klen
operator|==
literal|0
condition|)
name|ERRTO
argument_list|(
literal|"No ObjectID in key"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ERRTO
argument_list|(
literal|"Unknown Key algorithm"
argument_list|)
expr_stmt|;
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* flush the rest of the line */
return|return
operator|(
name|n
operator|)
return|;
name|err
label|:
operator|*
name|errmsg
operator|=
name|errtype
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*T_KEY*/
end_comment

begin_comment
comment|/*  * function to invoke DNSSEC specific parsing routines.  * this is simpler than copying these complicated blocks into the  * multiple souce files that read files (ixfr, nsupdate etc..).  * this code should be in a library rather than in this file but  * what the heck for now (ogud@tislabs.com)  */
end_comment

begin_function
name|int
name|parse_sec_rdata
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|buf_len
parameter_list|,
name|int
name|buf_full
parameter_list|,
name|u_char
modifier|*
name|data
parameter_list|,
name|int
name|data_size
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|u_int32_t
name|ttl
parameter_list|,
name|int
name|type
parameter_list|,
name|enum
name|context
name|context
parameter_list|,
name|enum
name|transport
name|transport
parameter_list|,
name|char
modifier|*
modifier|*
name|errmsg
parameter_list|)
block|{
name|int
name|ret
init|=
operator|-
literal|1
decl_stmt|;
name|getmlword_nesting
operator|=
literal|0
expr_stmt|;
comment|/* KLUDGE err recov. */
if|if
condition|(
operator|!
name|buf_full
operator|&&
name|buf
operator|&&
name|buf_len
operator|!=
literal|0
condition|)
comment|/* check if any data in buf */
if|if
condition|(
operator|!
name|getmlword
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
operator|*
name|errmsg
operator|=
literal|"unexpected end of input"
expr_stmt|;
goto|goto
name|err
goto|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_sig
case|:
name|ret
operator|=
name|parse_sig_rr
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|,
name|fp
argument_list|,
name|zp
argument_list|,
name|domain
argument_list|,
name|ttl
argument_list|,
name|context
argument_list|,
name|transport
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_key
case|:
name|ret
operator|=
name|parse_key_rr
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|,
name|fp
argument_list|,
name|zp
argument_list|,
name|domain
argument_list|,
name|context
argument_list|,
name|transport
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_nxt
case|:
name|ret
operator|=
name|parse_nxt_rr
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|,
name|fp
argument_list|,
name|zp
argument_list|,
name|domain
argument_list|,
name|context
argument_list|,
name|transport
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_cert
case|:
name|ret
operator|=
name|parse_cert_rr
argument_list|(
name|buf
argument_list|,
name|buf_len
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|,
name|fp
argument_list|,
name|errmsg
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
operator|*
name|errmsg
operator|=
literal|"parse_sec_rdata():Unsupported SEC type type"
expr_stmt|;
goto|goto
name|err
goto|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
name|err
label|:
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

end_unit

