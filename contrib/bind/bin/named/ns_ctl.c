begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_ctl.c,v 8.46 2001/12/19 11:53:48 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1997-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/* Extern. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_comment
comment|/* Defs. */
end_comment

begin_define
define|#
directive|define
name|CONTROL_FOUND
value|0x0001
end_define

begin_comment
comment|/* for mark and sweep. */
end_comment

begin_define
define|#
directive|define
name|MAX_STR_LEN
value|500
end_define

begin_struct
struct|struct
name|control
block|{
name|LINK
argument_list|(
argument|struct control
argument_list|)
name|link
expr_stmt|;
enum|enum
block|{
name|t_dead
block|,
name|t_inet
block|,
name|t_unix
block|}
name|type
enum|;
name|struct
name|ctl_sctx
modifier|*
name|sctx
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
union|union
block|{
struct|struct
block|{
name|struct
name|sockaddr_in
name|in
decl_stmt|;
name|ip_match_list
name|allow
decl_stmt|;
block|}
name|v_inet
struct|;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
struct|struct
block|{
name|struct
name|sockaddr_un
name|un
decl_stmt|;
name|mode_t
name|mode
decl_stmt|;
name|uid_t
name|owner
decl_stmt|;
name|gid_t
name|group
decl_stmt|;
block|}
name|v_unix
struct|;
endif|#
directive|endif
block|}
name|var
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|struct
name|ctl_sctx
modifier|*
name|mksrvr
parameter_list|(
name|control
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|control
name|new_control
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_control
parameter_list|(
name|controls
modifier|*
parameter_list|,
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_controls
parameter_list|(
name|controls
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|match_control
parameter_list|(
name|control
parameter_list|,
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|control
name|find_control
parameter_list|(
name|controls
parameter_list|,
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|propagate_changes
parameter_list|(
specifier|const
name|control
parameter_list|,
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install
parameter_list|(
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_inet
parameter_list|(
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|install_unix
parameter_list|(
name|control
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|logger
parameter_list|(
name|enum
name|ctl_severity
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|ISC_FORMAT_PRINTF
parameter_list|(
function_decl|2
operator|,
function_decl|3
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
specifier|static
name|void
name|verb_connect
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_getpid
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getpid_closure
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_status
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|status_closure
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_stop
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_exec
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_reload
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_reconfig
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_dumpdb
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_stats
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_trace
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|trace_closure
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_notrace
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_querylog
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_help
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|verb_quit
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
parameter_list|,
name|struct
name|ctl_sess
modifier|*
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|u_int
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Private data. */
end_comment

begin_decl_stmt
specifier|static
name|controls
name|server_controls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|ctl_verb
name|verbs
index|[]
init|=
block|{
block|{
literal|""
block|,
name|verb_connect
block|,
literal|""
block|}
block|,
block|{
literal|"getpid"
block|,
name|verb_getpid
block|,
literal|"getpid"
block|}
block|,
block|{
literal|"status"
block|,
name|verb_status
block|,
literal|"status"
block|}
block|,
block|{
literal|"stop"
block|,
name|verb_stop
block|,
literal|"stop"
block|}
block|,
block|{
literal|"exec"
block|,
name|verb_exec
block|,
literal|"exec"
block|}
block|,
block|{
literal|"reload"
block|,
name|verb_reload
block|,
literal|"reload [zone] ..."
block|}
block|,
block|{
literal|"reconfig"
block|,
name|verb_reconfig
block|,
literal|"reconfig [-noexpired] (just sees new/gone zones)"
block|}
block|,
block|{
literal|"dumpdb"
block|,
name|verb_dumpdb
block|,
literal|"dumpdb"
block|}
block|,
block|{
literal|"stats"
block|,
name|verb_stats
block|,
literal|"stats [clear]"
block|}
block|,
block|{
literal|"trace"
block|,
name|verb_trace
block|,
literal|"trace [level]"
block|}
block|,
block|{
literal|"notrace"
block|,
name|verb_notrace
block|,
literal|"notrace"
block|}
block|,
block|{
literal|"querylog"
block|,
name|verb_querylog
block|,
literal|"querylog"
block|}
block|,
block|{
literal|"qrylog"
block|,
name|verb_querylog
block|,
literal|"qrylog"
block|}
block|,
block|{
literal|"help"
block|,
name|verb_help
block|,
literal|"help"
block|}
block|,
block|{
literal|"quit"
block|,
name|verb_quit
block|,
literal|"quit"
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Public functions. */
end_comment

begin_function
name|void
name|ns_ctl_initialize
parameter_list|(
name|void
parameter_list|)
block|{
name|INIT_LIST
argument_list|(
name|server_controls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_ctl_shutdown
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|server_controls
argument_list|)
condition|)
name|free_controls
argument_list|(
operator|&
name|server_controls
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_ctl_defaults
parameter_list|(
name|controls
modifier|*
name|list
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|NO_SOCKADDR_UN
name|struct
name|in_addr
name|saddr
decl_stmt|;
name|ip_match_list
name|iml
decl_stmt|;
name|ip_match_element
name|ime
decl_stmt|;
comment|/* 	 * If the operating system does not support local domain sockets,  	 * connect with ndc on 127.0.0.1, port 101, and only allow 	 * connections from 127.0.0.1. 	 */
name|saddr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_LOOPBACK
argument_list|)
expr_stmt|;
name|iml
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|saddr
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|iml
argument_list|,
name|ime
argument_list|)
expr_stmt|;
name|ns_ctl_add
argument_list|(
name|list
argument_list|,
name|ns_ctl_new_inet
argument_list|(
name|saddr
argument_list|,
name|htons
argument_list|(
literal|101
argument_list|)
argument_list|,
name|iml
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|NEED_SECURE_DIRECTORY
name|ns_ctl_add
argument_list|(
name|list
argument_list|,
name|ns_ctl_new_unix
argument_list|(
name|_PATH_NDCSOCK
argument_list|,
literal|0700
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ns_ctl_add
argument_list|(
name|list
argument_list|,
name|ns_ctl_new_unix
argument_list|(
name|_PATH_NDCSOCK
argument_list|,
literal|0600
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/*NO_SOCKADDR_UN*/
block|}
end_function

begin_function
name|void
name|ns_ctl_add
parameter_list|(
name|controls
modifier|*
name|list
parameter_list|,
name|control
name|new
parameter_list|)
block|{
if|if
condition|(
operator|!
name|find_control
argument_list|(
operator|*
name|list
argument_list|,
name|new
argument_list|)
condition|)
name|APPEND
argument_list|(
operator|*
name|list
argument_list|,
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|control
name|ns_ctl_new_inet
parameter_list|(
name|struct
name|in_addr
name|saddr
parameter_list|,
name|u_int
name|sport
parameter_list|,
name|ip_match_list
name|allow
parameter_list|)
block|{
name|control
name|new
init|=
name|new_control
argument_list|()
decl_stmt|;
name|INIT_LINK
argument_list|(
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|t_inet
expr_stmt|;
name|memset
argument_list|(
operator|&
name|new
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|new
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
argument_list|)
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_addr
operator|=
name|saddr
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_port
operator|=
name|sport
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
operator|=
name|allow
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
end_ifndef

begin_function
name|control
name|ns_ctl_new_unix
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|mode_t
name|mode
parameter_list|,
name|uid_t
name|owner
parameter_list|,
name|gid_t
name|group
parameter_list|)
block|{
name|control
name|new
init|=
name|new_control
argument_list|()
decl_stmt|;
name|INIT_LINK
argument_list|(
name|new
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|t_unix
expr_stmt|;
name|memset
argument_list|(
operator|&
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
argument_list|)
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|strncpy
argument_list|(
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|path
argument_list|,
sizeof|sizeof
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
operator|-
literal|1
argument_list|)
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|owner
operator|=
name|owner
expr_stmt|;
name|new
operator|->
name|var
operator|.
name|v_unix
operator|.
name|group
operator|=
name|group
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|ns_ctl_install
parameter_list|(
name|controls
modifier|*
name|new
parameter_list|)
block|{
name|control
name|ctl
decl_stmt|,
name|old
decl_stmt|,
name|next
decl_stmt|;
comment|/* Find all the controls which aren't new or deleted. */
for|for
control|(
name|ctl
operator|=
name|HEAD
argument_list|(
name|server_controls
argument_list|)
init|;
name|ctl
operator|!=
name|NULL
condition|;
name|ctl
operator|=
name|NEXT
argument_list|(
name|ctl
argument_list|,
name|link
argument_list|)
control|)
name|ctl
operator|->
name|flags
operator|&=
operator|~
name|CONTROL_FOUND
expr_stmt|;
for|for
control|(
name|ctl
operator|=
name|HEAD
argument_list|(
operator|*
name|new
argument_list|)
init|;
name|ctl
operator|!=
name|NULL
condition|;
name|ctl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|ctl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|old
operator|=
name|find_control
argument_list|(
name|server_controls
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|!=
name|NULL
condition|)
block|{
name|old
operator|->
name|flags
operator||=
name|CONTROL_FOUND
expr_stmt|;
name|propagate_changes
argument_list|(
name|ctl
argument_list|,
name|old
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|->
name|sctx
operator|==
name|NULL
condition|)
name|free_control
argument_list|(
operator|&
name|server_controls
argument_list|,
name|old
argument_list|)
expr_stmt|;
name|free_control
argument_list|(
name|new
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Destroy any old controls which weren't found. */
for|for
control|(
name|ctl
operator|=
name|HEAD
argument_list|(
name|server_controls
argument_list|)
init|;
name|ctl
operator|!=
name|NULL
condition|;
name|ctl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|ctl
argument_list|,
name|link
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ctl
operator|->
name|flags
operator|&
name|CONTROL_FOUND
operator|)
operator|==
literal|0
condition|)
name|free_control
argument_list|(
operator|&
name|server_controls
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
comment|/* Add any new controls which were found. */
for|for
control|(
name|ctl
operator|=
name|HEAD
argument_list|(
operator|*
name|new
argument_list|)
init|;
name|ctl
operator|!=
name|NULL
condition|;
name|ctl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|ctl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
operator|*
name|new
argument_list|,
name|ctl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|server_controls
argument_list|,
name|ctl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|install
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctl
operator|->
name|sctx
operator|==
name|NULL
condition|)
name|free_control
argument_list|(
operator|&
name|server_controls
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Private functions. */
end_comment

begin_function
specifier|static
name|struct
name|ctl_sctx
modifier|*
name|mksrvr
parameter_list|(
name|control
name|ctl
parameter_list|,
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
parameter_list|,
name|size_t
name|salen
parameter_list|)
block|{
return|return
operator|(
name|ctl_server
argument_list|(
name|ev
argument_list|,
name|sa
argument_list|,
name|salen
argument_list|,
name|verbs
argument_list|,
literal|500
argument_list|,
literal|222
argument_list|,
literal|600
argument_list|,
literal|5
argument_list|,
literal|10
argument_list|,
name|logger
argument_list|,
name|ctl
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|control
name|new_control
parameter_list|(
name|void
parameter_list|)
block|{
name|control
name|new
init|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
decl_stmt|;
if|if
condition|(
name|new
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_control()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|t_dead
expr_stmt|;
name|new
operator|->
name|sctx
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_control
parameter_list|(
name|controls
modifier|*
name|list
parameter_list|,
name|control
name|this
parameter_list|)
block|{
name|int
name|was_live
init|=
literal|0
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|this
operator|->
name|sctx
operator|!=
name|NULL
condition|)
block|{
name|ctl_endserver
argument_list|(
name|this
operator|->
name|sctx
argument_list|)
expr_stmt|;
name|this
operator|->
name|sctx
operator|=
name|NULL
expr_stmt|;
name|was_live
operator|=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|this
operator|->
name|type
condition|)
block|{
case|case
name|t_inet
case|:
if|if
condition|(
name|this
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
operator|!=
name|NULL
condition|)
block|{
name|free_ip_match_list
argument_list|(
name|this
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
argument_list|)
expr_stmt|;
name|this
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
case|case
name|t_unix
case|:
comment|/* XXX Race condition. */
if|if
condition|(
name|was_live
operator|&&
name|stat
argument_list|(
name|this
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|S_ISSOCK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISFIFO
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
comment|/* XXX Race condition. */
name|unlink
argument_list|(
name|this
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"impossible type in free_control"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|UNLINK
argument_list|(
operator|*
name|list
argument_list|,
name|this
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|this
argument_list|,
sizeof|sizeof
expr|*
name|this
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_controls
parameter_list|(
name|controls
modifier|*
name|list
parameter_list|)
block|{
name|control
name|ctl
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|ctl
operator|=
name|HEAD
argument_list|(
operator|*
name|list
argument_list|)
init|;
name|ctl
operator|!=
name|NULL
condition|;
name|ctl
operator|=
name|next
control|)
block|{
name|next
operator|=
name|NEXT
argument_list|(
name|ctl
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|free_control
argument_list|(
name|list
argument_list|,
name|ctl
argument_list|)
expr_stmt|;
block|}
name|INIT_LIST
argument_list|(
operator|*
name|list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|match_control
parameter_list|(
name|control
name|l
parameter_list|,
name|control
name|r
parameter_list|)
block|{
name|int
name|match
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|l
operator|->
name|type
operator|!=
name|r
operator|->
name|type
condition|)
name|match
operator|=
literal|0
expr_stmt|;
else|else
switch|switch
condition|(
name|l
operator|->
name|type
condition|)
block|{
case|case
name|t_inet
case|:
if|if
condition|(
name|l
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_family
operator|!=
name|r
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_family
operator|||
name|l
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_port
operator|!=
name|r
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_port
operator|||
name|l
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
name|r
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
name|match
operator|=
literal|0
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
case|case
name|t_unix
case|:
if|if
condition|(
name|l
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_family
operator|!=
name|r
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_family
operator|||
name|strcmp
argument_list|(
name|l
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|r
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|)
operator|!=
literal|0
condition|)
name|match
operator|=
literal|0
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"impossible type in match_control"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|20
argument_list|,
literal|"match_control(): %d"
argument_list|,
name|match
argument_list|)
expr_stmt|;
return|return
operator|(
name|match
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|control
name|find_control
parameter_list|(
name|controls
name|list
parameter_list|,
name|control
name|new
parameter_list|)
block|{
name|control
name|ctl
decl_stmt|;
for|for
control|(
name|ctl
operator|=
name|HEAD
argument_list|(
name|list
argument_list|)
init|;
name|ctl
operator|!=
name|NULL
condition|;
name|ctl
operator|=
name|NEXT
argument_list|(
name|ctl
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|match_control
argument_list|(
name|ctl
argument_list|,
name|new
argument_list|)
condition|)
return|return
operator|(
name|ctl
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|propagate_changes
parameter_list|(
specifier|const
name|control
name|diff
parameter_list|,
name|control
name|base
parameter_list|)
block|{
name|int
name|need_install
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|base
operator|->
name|type
condition|)
block|{
case|case
name|t_inet
case|:
if|if
condition|(
name|base
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|base
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
argument_list|)
expr_stmt|;
name|base
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
operator|=
name|diff
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
expr_stmt|;
name|diff
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
operator|=
name|NULL
expr_stmt|;
name|need_install
operator|++
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
case|case
name|t_unix
case|:
if|if
condition|(
name|base
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
operator|!=
name|diff
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
condition|)
block|{
name|base
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
operator|=
name|diff
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
expr_stmt|;
name|need_install
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|var
operator|.
name|v_unix
operator|.
name|owner
operator|!=
name|diff
operator|->
name|var
operator|.
name|v_unix
operator|.
name|owner
condition|)
block|{
name|base
operator|->
name|var
operator|.
name|v_unix
operator|.
name|owner
operator|=
name|diff
operator|->
name|var
operator|.
name|v_unix
operator|.
name|owner
expr_stmt|;
name|need_install
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|base
operator|->
name|var
operator|.
name|v_unix
operator|.
name|group
operator|!=
name|diff
operator|->
name|var
operator|.
name|v_unix
operator|.
name|group
condition|)
block|{
name|base
operator|->
name|var
operator|.
name|v_unix
operator|.
name|group
operator|=
name|diff
operator|->
name|var
operator|.
name|v_unix
operator|.
name|group
expr_stmt|;
name|need_install
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"impossible type in ns_ctl::propagate_changes"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|need_install
condition|)
name|install
argument_list|(
name|base
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|install
parameter_list|(
name|control
name|ctl
parameter_list|)
block|{
switch|switch
condition|(
name|ctl
operator|->
name|type
condition|)
block|{
case|case
name|t_inet
case|:
name|install_inet
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
case|case
name|t_unix
case|:
name|install_unix
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|panic
argument_list|(
literal|"impossible type in ns_ctl::install"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|install_inet
parameter_list|(
name|control
name|ctl
parameter_list|)
block|{
if|if
condition|(
name|ctl
operator|->
name|sctx
operator|==
name|NULL
condition|)
block|{
name|ctl
operator|->
name|sctx
operator|=
name|mksrvr
argument_list|(
name|ctl
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ctl
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
argument_list|,
sizeof|sizeof
name|ctl
operator|->
name|var
operator|.
name|v_inet
operator|.
name|in
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SOCKADDR_UN
end_ifndef

begin_comment
comment|/*  * Unattach an old unix domain socket if it exists.  */
end_comment

begin_function
specifier|static
name|void
name|unattach
parameter_list|(
name|control
name|ctl
parameter_list|)
block|{
name|int
name|s
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"unix control \"%s\" socket failed: %s"
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
argument_list|(
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENOENT
case|:
comment|/* We exited cleanly last time */
break|break;
default|default:
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"unix control \"%s\" stat failed: %s"
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
operator|!
operator|(
name|S_ISSOCK
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|||
name|S_ISFIFO
argument_list|(
name|sb
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"unix control \"%s\" not socket"
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
argument_list|,
sizeof|sizeof
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
argument_list|)
operator|<
literal|0
condition|)
block|{
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ECONNREFUSED
case|:
case|case
name|ECONNRESET
case|:
if|if
condition|(
name|unlink
argument_list|(
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|)
operator|<
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"unix control \"%s\" unlink failed: %s"
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"unix control \"%s\" connect failed: %s"
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|cleanup
label|:
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|install_unix
parameter_list|(
name|control
name|ctl
parameter_list|)
block|{
name|char
modifier|*
name|path
decl_stmt|;
ifdef|#
directive|ifdef
name|NEED_SECURE_DIRECTORY
name|char
modifier|*
name|slash
decl_stmt|;
name|path
operator|=
name|savestr
argument_list|(
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|slash
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|slash
operator|!=
name|path
condition|)
operator|*
name|slash
operator|=
literal|'\0'
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|freestr
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|savestr
argument_list|(
literal|"/"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
operator|(
name|void
operator|)
name|freestr
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|path
operator|=
name|savestr
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mkdir
argument_list|(
name|path
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EEXIST
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"unix control \"%s\" mkdir failed: %s"
argument_list|,
name|path
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|#
directive|else
name|path
operator|=
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ctl
operator|->
name|sctx
operator|==
name|NULL
condition|)
block|{
name|unattach
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|ctl
operator|->
name|sctx
operator|=
name|mksrvr
argument_list|(
name|ctl
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
argument_list|,
sizeof|sizeof
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctl
operator|->
name|sctx
operator|!=
name|NULL
condition|)
block|{
comment|/* XXX Race condition. */
if|if
condition|(
name|chmod
argument_list|(
name|path
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"chmod(\"%s\", 0%03o): %s"
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|mode
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chown
argument_list|(
name|path
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|owner
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|group
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"chown(\"%s\", %d, %d): %s"
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|un
operator|.
name|sun_path
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|owner
argument_list|,
name|ctl
operator|->
name|var
operator|.
name|v_unix
operator|.
name|group
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|NEED_SECURE_DIRECTORY
operator|(
name|void
operator|)
name|freestr
argument_list|(
name|path
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|logger
parameter_list|(
name|enum
name|ctl_severity
name|ctlsev
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|args
decl_stmt|;
name|int
name|logsev
decl_stmt|;
switch|switch
condition|(
name|ctlsev
condition|)
block|{
case|case
name|ctl_debug
case|:
name|logsev
operator|=
name|log_debug
argument_list|(
literal|5
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctl_warning
case|:
name|logsev
operator|=
name|log_warning
expr_stmt|;
break|break;
case|case
name|ctl_error
case|:
name|logsev
operator|=
name|log_error
expr_stmt|;
break|break;
default|default:
name|logsev
operator|=
literal|0
expr_stmt|;
name|panic
argument_list|(
literal|"invalid ctlsev in logger"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|log_ctx_valid
condition|)
return|return;
name|va_start
argument_list|(
name|args
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|log_vwrite
argument_list|(
name|log_ctx
argument_list|,
name|ns_log_control
argument_list|,
name|logsev
argument_list|,
name|format
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_connect
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
specifier|const
name|struct
name|sockaddr
modifier|*
name|sa
init|=
operator|(
specifier|const
expr|struct
name|sockaddr
operator|*
operator|)
name|respctx
decl_stmt|;
name|control
name|nsctl
init|=
operator|(
name|control
operator|)
name|uctx
decl_stmt|;
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|->
name|sa_family
operator|==
name|AF_INET
condition|)
block|{
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|in
init|=
operator|(
specifier|const
expr|struct
name|sockaddr_in
operator|*
operator|)
name|sa
decl_stmt|;
specifier|const
name|ip_match_list
name|acl
init|=
name|nsctl
operator|->
name|var
operator|.
name|v_inet
operator|.
name|allow
decl_stmt|;
if|if
condition|(
operator|!
name|ip_address_allowed
argument_list|(
name|acl
argument_list|,
name|in
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|502
argument_list|,
literal|"Permission denied."
argument_list|,
name|CTL_EXIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|220
argument_list|,
name|server_options
operator|->
name|version
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_getpid
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
name|memget
argument_list|(
name|MAX_STR_LEN
argument_list|)
decl_stmt|;
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|503
argument_list|,
literal|"(out of memory)"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"my pid is<%ld>"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|getpid_closure
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|getpid_closure
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|sctx
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
name|uap
decl_stmt|;
name|UNUSED
argument_list|(
name|sctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sess
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|msg
argument_list|,
name|MAX_STR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_enum
enum|enum
name|state
block|{
name|e_version
init|=
literal|0
block|,
name|e_config
block|,
name|e_nzones
block|,
name|e_debug
block|,
name|e_xfersrun
block|,
name|e_xfersdfr
block|,
name|e_qserials
block|,
name|e_qrylog
block|,
name|e_priming
block|,
name|e_finito
block|}
enum|;
end_enum

begin_struct
struct|struct
name|pvt_status
block|{
name|enum
name|state
name|state
decl_stmt|;
name|char
name|text
index|[
name|MAX_STR_LEN
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|verb_status
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|struct
name|pvt_status
modifier|*
name|pvt
init|=
name|ctl_getcsctx
argument_list|(
name|sess
argument_list|)
decl_stmt|;
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvt
operator|==
name|NULL
condition|)
block|{
name|pvt
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|pvt
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvt
operator|==
name|NULL
condition|)
block|{
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|505
argument_list|,
literal|"(out of memory)"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|pvt
operator|->
name|state
operator|=
operator|(
expr|enum
name|state
operator|)
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|ctl_setcsctx
argument_list|(
name|sess
argument_list|,
name|pvt
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|pvt
operator|->
name|state
operator|++
condition|)
block|{
case|case
name|e_version
case|:
name|strncpy
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
name|Version
argument_list|,
sizeof|sizeof
name|pvt
operator|->
name|text
argument_list|)
expr_stmt|;
name|pvt
operator|->
name|text
index|[
sizeof|sizeof
name|pvt
operator|->
name|text
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
name|e_config
case|:
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"config (%s) last loaded at age: %24s"
argument_list|,
name|conffile
argument_list|,
name|ctime
argument_list|(
operator|&
name|confmtime
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_nzones
case|:
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"number of zones allocated: %d"
argument_list|,
name|nzones
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_debug
case|:
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"debug level: %d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_xfersrun
case|:
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"xfers running: %d"
argument_list|,
name|xfers_running
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_xfersdfr
case|:
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"xfers deferred: %d"
argument_list|,
name|xfers_deferred
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_qserials
case|:
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"soa queries in progress: %d"
argument_list|,
name|qserials_running
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_qrylog
case|:
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"query logging is %s"
argument_list|,
name|qrylog
condition|?
literal|"ON"
else|:
literal|"OFF"
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_priming
case|:
if|if
condition|(
name|priming
condition|)
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"server is initialising itself"
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|pvt
operator|->
name|text
argument_list|,
literal|"server is up and running"
argument_list|)
expr_stmt|;
break|break;
case|case
name|e_finito
case|:
return|return;
block|}
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
name|pvt
operator|->
name|text
argument_list|,
operator|(
name|pvt
operator|->
name|state
operator|==
name|e_finito
operator|)
condition|?
literal|0
else|:
name|CTL_MORE
argument_list|,
name|NULL
argument_list|,
name|status_closure
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|status_closure
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|sctx
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|struct
name|pvt_status
modifier|*
name|pvt
init|=
name|ctl_getcsctx
argument_list|(
name|sess
argument_list|)
decl_stmt|;
name|UNUSED
argument_list|(
name|sctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uap
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|pvt
argument_list|,
sizeof|sizeof
expr|*
name|pvt
argument_list|)
expr_stmt|;
name|ctl_setcsctx
argument_list|(
name|sess
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_stop
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
name|ns_need
argument_list|(
name|main_need_exit
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
literal|"Shutdown initiated."
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_exec
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest
operator|!=
name|NULL
operator|&&
operator|*
name|rest
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|rest
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|503
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|saved_argv
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|rest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* Never strfreed. */
block|}
if|if
condition|(
name|stat
argument_list|(
name|saved_argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|save
init|=
name|strerror
argument_list|(
name|errno
argument_list|)
decl_stmt|;
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"can't exec, %s: %s"
argument_list|,
name|saved_argv
index|[
literal|0
index|]
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|502
argument_list|,
name|save
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_need
argument_list|(
name|main_need_restart
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
literal|"Restart initiated."
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|verb_reload
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|spaces
index|[]
init|=
literal|" \t"
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|NULL
decl_stmt|,
modifier|*
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|cl
decl_stmt|;
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
name|int
name|class
decl_stmt|,
name|code
decl_stmt|,
name|success
decl_stmt|;
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
comment|/* If there are no args, this is a classic reload of the config. */
if|if
condition|(
name|rest
operator|==
name|NULL
operator|||
operator|*
name|rest
operator|==
literal|'\0'
condition|)
block|{
name|ns_need
argument_list|(
name|main_need_reload
argument_list|)
expr_stmt|;
name|code
operator|=
literal|250
expr_stmt|;
name|msg
operator|=
literal|"Reload initiated."
expr_stmt|;
goto|goto
name|respond
goto|;
block|}
comment|/* Look for optional zclass argument.  Default is "in". */
name|tmp
operator|=
name|savestr
argument_list|(
name|rest
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|x
operator|=
name|tmp
operator|+
name|strcspn
argument_list|(
name|tmp
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|x
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|x
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|x
operator|+=
name|strspn
argument_list|(
name|x
argument_list|,
name|spaces
argument_list|)
expr_stmt|;
block|}
name|cl
operator|=
operator|(
name|x
operator|==
name|NULL
operator|||
operator|*
name|x
operator|==
literal|'\0'
operator|)
condition|?
literal|"in"
else|:
name|x
expr_stmt|;
name|class
operator|=
name|res_nametoclass
argument_list|(
name|cl
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|code
operator|=
literal|507
expr_stmt|;
name|msg
operator|=
literal|"unrecognized class"
expr_stmt|;
goto|goto
name|respond
goto|;
block|}
comment|/* Look for the zone, and do the right thing to it. */
name|zp
operator|=
name|find_zone
argument_list|(
name|tmp
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
block|{
name|code
operator|=
literal|506
expr_stmt|;
name|msg
operator|=
literal|"Zone not found."
expr_stmt|;
goto|goto
name|respond
goto|;
block|}
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|z_master
case|:
name|ns_stopxfrs
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|z_hint
case|:
name|block_signals
argument_list|()
expr_stmt|;
name|code
operator|=
literal|251
expr_stmt|;
name|msg
operator|=
name|deferred_reload_unsafe
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|unblock_signals
argument_list|()
expr_stmt|;
break|break;
case|case
name|z_slave
case|:
case|case
name|z_stub
case|:
name|ns_stopxfrs
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonefile_changed_p
argument_list|(
name|zp
argument_list|)
condition|)
name|zp
operator|->
name|z_serial
operator|=
literal|0
expr_stmt|;
comment|/* force xfer */
name|addxfer
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|code
operator|=
literal|251
expr_stmt|;
name|msg
operator|=
literal|"Slave transfer queued."
expr_stmt|;
goto|goto
name|respond
goto|;
case|case
name|z_forward
case|:
case|case
name|z_cache
case|:
default|default:
name|msg
operator|=
literal|"Non reloadable zone."
expr_stmt|;
name|code
operator|=
literal|507
expr_stmt|;
break|break;
block|}
name|respond
label|:
name|ctl_response
argument_list|(
name|sess
argument_list|,
name|code
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|freestr
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_reconfig
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|rest
argument_list|,
literal|"-noexpired"
argument_list|)
operator|!=
literal|0
condition|)
name|ns_need
argument_list|(
name|main_need_reconfig
argument_list|)
expr_stmt|;
else|else
name|ns_need
argument_list|(
name|main_need_noexpired
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
literal|"Reconfig initiated."
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_dumpdb
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
name|ns_need
argument_list|(
name|main_need_dump
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
literal|"Database dump initiated."
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_stats
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rest
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|rest
argument_list|,
literal|"clear"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ns_need
argument_list|(
name|main_need_statsdumpandclear
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
literal|"Statistics dump and clear initiated."
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_need
argument_list|(
name|main_need_statsdump
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
literal|"Statistics dump initiated."
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|verb_trace
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|int
name|i
init|=
name|atoi
argument_list|(
name|rest
argument_list|)
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|memget
argument_list|(
name|MAX_STR_LEN
argument_list|)
decl_stmt|;
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|==
name|NULL
condition|)
block|{
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|503
argument_list|,
literal|"(out of memory)"
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|rest
argument_list|)
operator|&&
name|i
operator|>=
literal|0
condition|)
name|desired_debug
operator|=
name|i
expr_stmt|;
else|else
name|desired_debug
operator|++
expr_stmt|;
name|ns_need
argument_list|(
name|main_need_debug
argument_list|)
expr_stmt|;
if|if
condition|(
name|desired_debug
operator|==
literal|0
condition|)
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Debugging turned off."
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|msg
argument_list|,
literal|"Debug level: %d"
argument_list|,
name|desired_debug
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
name|msg
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|trace_closure
argument_list|,
name|msg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|trace_closure
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|sctx
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|)
block|{
name|char
modifier|*
name|msg
init|=
name|uap
decl_stmt|;
name|UNUSED
argument_list|(
name|sctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|sess
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|msg
argument_list|,
name|MAX_STR_LEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_notrace
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
name|desired_debug
operator|=
literal|0
expr_stmt|;
name|ns_need
argument_list|(
name|main_need_debug
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
literal|"Debugging turned off."
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_querylog
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|on
index|[]
init|=
literal|"Query logging is now on."
decl_stmt|,
name|off
index|[]
init|=
literal|"Query logging is now off."
decl_stmt|;
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
name|toggle_qrylog
argument_list|()
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|250
argument_list|,
name|qrylog
condition|?
name|on
else|:
name|off
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_help
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
name|ctl_sendhelp
argument_list|(
name|sess
argument_list|,
literal|214
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|verb_quit
parameter_list|(
name|struct
name|ctl_sctx
modifier|*
name|ctl
parameter_list|,
name|struct
name|ctl_sess
modifier|*
name|sess
parameter_list|,
specifier|const
name|struct
name|ctl_verb
modifier|*
name|verb
parameter_list|,
specifier|const
name|char
modifier|*
name|rest
parameter_list|,
name|u_int
name|respflags
parameter_list|,
specifier|const
name|void
modifier|*
name|respctx
parameter_list|,
name|void
modifier|*
name|uctx
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ctl
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|verb
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|rest
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respflags
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|respctx
argument_list|)
expr_stmt|;
name|UNUSED
argument_list|(
name|uctx
argument_list|)
expr_stmt|;
name|ctl_response
argument_list|(
name|sess
argument_list|,
literal|221
argument_list|,
literal|"End of control session."
argument_list|,
name|CTL_EXIT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

