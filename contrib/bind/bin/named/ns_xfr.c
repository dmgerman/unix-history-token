begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_xfr.c,v 8.64 2001/02/15 00:18:46 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<res_update.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_function_decl
specifier|static
name|struct
name|qs_x_lev
modifier|*
name|sx_freelev
parameter_list|(
name|struct
name|qs_x_lev
modifier|*
name|lev
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|sx_flush
argument_list|(
expr|struct
name|qstream
operator|*
name|qsp
argument_list|)
decl_stmt|,
name|sx_addrr
argument_list|(
expr|struct
name|qstream
operator|*
name|qsp
argument_list|,
specifier|const
name|char
operator|*
name|dname
argument_list|,
expr|struct
name|databuf
operator|*
name|dp
argument_list|)
decl_stmt|,
name|sx_nsrrs
argument_list|(
expr|struct
name|qstream
operator|*
name|qsp
argument_list|)
decl_stmt|,
name|sx_allrrs
argument_list|(
expr|struct
name|qstream
operator|*
name|qsp
argument_list|)
decl_stmt|,
name|sx_pushlev
argument_list|(
expr|struct
name|qstream
operator|*
name|qsp
argument_list|,
expr|struct
name|namebuf
operator|*
name|np
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|databuf
modifier|*
name|db_next
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * void  * ns_xfr(qsp, znp, zone, class, type, opcode, id, serial_ixfr, in_tsig)  *	Initiate a concurrent (event driven) outgoing zone transfer.  */
end_comment

begin_function
name|void
name|ns_xfr
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|struct
name|namebuf
modifier|*
name|znp
parameter_list|,
name|int
name|zone
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|opcode
parameter_list|,
name|int
name|id
parameter_list|,
name|u_int32_t
name|serial_ixfr
parameter_list|,
name|struct
name|tsig_record
modifier|*
name|in_tsig
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
ifdef|#
directive|ifdef
name|SO_SNDBUF
specifier|static
specifier|const
name|int
name|sndbuf
init|=
name|XFER_BUFSIZE
operator|*
literal|2
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_SNDLOWAT
specifier|static
specifier|const
name|int
name|sndlowat
init|=
name|XFER_BUFSIZE
decl_stmt|;
endif|#
directive|endif
name|ns_deltalist
modifier|*
name|changes
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_axfr
case|:
comment|/*FALLTHROUGH*/
case|case
name|ns_t_ixfr
case|:
ifdef|#
directive|ifdef
name|BIND_ZXFR
case|case
name|ns_t_zxfr
case|:
endif|#
directive|endif
name|ns_info
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"zone transfer (%s) of \"%s\" (%s) to %s"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|zones
index|[
name|zone
index|]
operator|.
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|qsp
operator|->
name|s_from
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ns_warning
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"unsupported XFR (type %s) of \"%s\" (%s) to %s"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|zones
index|[
name|zone
index|]
operator|.
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|qsp
operator|->
name|s_from
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
ifdef|#
directive|ifdef
name|SO_SNDBUF
comment|/* 	 * The default seems to be 4K, and we'd like it to have enough room 	 * to parallelize sending the pushed data with accumulating more 	 * write() data from us. 	 */
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDBUF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sndbuf
argument_list|,
sizeof|sizeof
name|sndbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SO_SNDLOWAT
comment|/* 	 * We don't want select() to show writability 'til we can write 	 * an XFER_BUFSIZE block of data. 	 */
operator|(
name|void
operator|)
name|setsockopt
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_SNDLOWAT
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sndlowat
argument_list|,
sizeof|sizeof
name|sndlowat
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|sq_openw
argument_list|(
name|qsp
argument_list|,
literal|64
operator|*
literal|1024
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"ns_xfr: out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|memset
argument_list|(
operator|&
name|qsp
operator|->
name|xfr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|qsp
operator|->
name|xfr
argument_list|)
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|axfr
operator|=
name|znp
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|zone
operator|=
name|zone
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|class
operator|=
name|class
expr_stmt|;
if|if
condition|(
name|qsp
operator|->
name|flags
operator|&
name|STREAM_AXFRIXFR
condition|)
name|type
operator|=
name|ns_t_axfr
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|type
operator|=
name|type
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|opcode
operator|=
name|opcode
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|msg
operator|=
name|memget
argument_list|(
name|XFER_BUFSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qsp
operator|->
name|xfr
operator|.
name|msg
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"ns_xfr: out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|qsp
operator|->
name|xfr
operator|.
name|eom
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|msg
operator|+
name|XFER_BUFSIZE
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|=
name|NULL
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|=
name|s_x_firstsoa
expr_stmt|;
name|zones
index|[
name|zone
index|]
operator|.
name|z_numxfrs
operator|++
expr_stmt|;
name|qsp
operator|->
name|flags
operator||=
name|STREAM_AXFR
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_ZXFR
if|if
condition|(
name|type
operator|==
name|ns_t_zxfr
condition|)
block|{
enum|enum
block|{
name|rd
init|=
literal|0
block|,
name|wr
init|=
literal|1
block|}
enum|;
name|int
name|z
index|[
literal|2
index|]
decl_stmt|;
name|pid_t
name|p
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|z
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"pipe: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
name|p
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"vfork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
comment|/* Child. */
name|dup2
argument_list|(
name|z
index|[
name|rd
index|]
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"gzip"
argument_list|,
literal|"gzip"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"execlp: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|ns_info
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"zxfr gzip pid %lu"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* Parent. */
name|dup2
argument_list|(
name|z
index|[
name|wr
index|]
argument_list|,
name|qsp
operator|->
name|s_rfd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|z
index|[
name|wr
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|z
index|[
name|rd
index|]
argument_list|)
expr_stmt|;
comment|/* When a ZXFR completes, there can be no more requests. */
name|qsp
operator|->
name|flags
operator||=
name|STREAM_DONE_CLOSE
expr_stmt|;
block|}
endif|#
directive|endif
name|si
operator|=
name|find_server
argument_list|(
name|qsp
operator|->
name|s_from
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|!=
name|NULL
operator|&&
name|si
operator|->
name|transfer_format
operator|!=
name|axfr_use_default
condition|)
name|qsp
operator|->
name|xfr
operator|.
name|transfer_format
operator|=
name|si
operator|->
name|transfer_format
expr_stmt|;
else|else
name|qsp
operator|->
name|xfr
operator|.
name|transfer_format
operator|=
name|server_options
operator|->
name|transfer_format
expr_stmt|;
if|if
condition|(
name|in_tsig
operator|==
name|NULL
condition|)
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
operator|=
name|NULL
expr_stmt|;
else|else
block|{
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
name|ns_tcp_tsig_state
argument_list|)
argument_list|)
expr_stmt|;
name|ns_sign_tcp_init
argument_list|(
name|in_tsig
operator|->
name|key
argument_list|,
name|in_tsig
operator|->
name|sig
argument_list|,
name|in_tsig
operator|->
name|siglen
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
argument_list|)
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|tsig_skip
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|ns_t_ixfr
condition|)
block|{
name|changes
operator|=
name|ixfr_get_change_list
argument_list|(
operator|&
name|zones
index|[
name|zone
index|]
argument_list|,
name|serial_ixfr
argument_list|,
name|zones
index|[
name|zone
index|]
operator|.
name|z_serial
argument_list|)
expr_stmt|;
name|ixfr_log_maint
argument_list|(
operator|&
name|zones
index|[
name|zone
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|changes
operator|!=
name|NULL
condition|)
block|{
name|qsp
operator|->
name|xfr
operator|.
name|serial
operator|=
name|serial_ixfr
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
operator|=
name|changes
expr_stmt|;
block|}
else|else
block|{
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
operator|=
name|NULL
expr_stmt|;
goto|goto
name|abort
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sx_pushlev
argument_list|(
name|qsp
argument_list|,
name|znp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|"ns_xfr: out of memory"
argument_list|)
expr_stmt|;
name|abort
label|:
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
if|if
condition|(
name|type
operator|!=
name|ns_t_ixfr
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"sq_writeh sx_sendsoa (%s)"
argument_list|,
name|zones
index|[
name|zone
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sq_writeh
argument_list|(
name|qsp
argument_list|,
name|sx_sendsoa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"sq_writeh sx_send_ixfr (%s)"
argument_list|,
name|zones
index|[
name|zone
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sq_writeh
argument_list|(
name|qsp
argument_list|,
name|sx_send_ixfr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * void  * ns_stopxfrs(zp)  *	Stop (abort, reset) all transfers of the zone specified by 'zp'.  */
end_comment

begin_function
name|void
name|ns_stopxfrs
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|struct
name|qstream
modifier|*
name|this
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|u_int
name|zone
init|=
call|(
name|u_int
call|)
argument_list|(
name|zp
operator|-
name|zones
argument_list|)
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ns_stopxfrs (%s)"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
for|for
control|(
name|this
operator|=
name|streamq
init|;
name|this
condition|;
name|this
operator|=
name|next
control|)
block|{
name|next
operator|=
name|this
operator|->
name|s_next
expr_stmt|;
if|if
condition|(
name|this
operator|->
name|xfr
operator|.
name|zone
operator|==
name|zone
condition|)
block|{
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|this
operator|->
name|s_rfd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|this
argument_list|)
expr_stmt|;
block|}
block|}
name|INSIST
argument_list|(
name|zp
operator|->
name|z_numxfrs
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * void  * ns_freexfr(qsp)  *	Free all xfr-related dynamic data associated with qsp.  */
end_comment

begin_function
name|void
name|ns_freexfr
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|ns_delta
modifier|*
name|dp
decl_stmt|;
name|ns_updrec
modifier|*
name|rp
decl_stmt|;
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|msg
operator|!=
name|NULL
condition|)
block|{
name|memput
argument_list|(
name|qsp
operator|->
name|xfr
operator|.
name|msg
argument_list|,
name|XFER_BUFSIZE
argument_list|)
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|msg
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|type
operator|==
name|ns_t_ixfr
operator|&&
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|dp
operator|=
name|HEAD
argument_list|(
operator|*
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UNLINK
argument_list|(
operator|*
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
argument_list|,
name|dp
argument_list|,
name|d_link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|rp
operator|=
name|HEAD
argument_list|(
name|dp
operator|->
name|d_changes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UNLINK
argument_list|(
name|dp
operator|->
name|d_changes
argument_list|,
name|rp
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|r_dp
operator|!=
name|NULL
condition|)
name|db_freedata
argument_list|(
name|rp
operator|->
name|r_dp
argument_list|)
expr_stmt|;
name|rp
operator|->
name|r_dp
operator|=
name|NULL
expr_stmt|;
name|res_freeupdrec
argument_list|(
name|rp
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
expr|*
name|dp
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
argument_list|,
sizeof|sizeof
expr|*
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
argument_list|)
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|ixfr
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|lev
condition|)
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|=
name|sx_freelev
argument_list|(
name|qsp
operator|->
name|xfr
operator|.
name|lev
argument_list|)
expr_stmt|;
name|zones
index|[
name|qsp
operator|->
name|xfr
operator|.
name|zone
index|]
operator|.
name|z_numxfrs
operator|--
expr_stmt|;
name|qsp
operator|->
name|flags
operator|&=
operator|~
operator|(
name|STREAM_AXFR
operator||
name|STREAM_AXFRIXFR
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * u_char *  * sx_newmsg(msg)  *	init the header of a message, reset the compression pointers, and  *	reset the write pointer to the first byte following the header.  */
end_comment

begin_function
name|void
name|sx_newmsg
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|qsp
operator|->
name|xfr
operator|.
name|msg
decl_stmt|;
name|memset
argument_list|(
name|hp
argument_list|,
literal|0
argument_list|,
name|HFIXEDSZ
argument_list|)
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|htons
argument_list|(
name|qsp
operator|->
name|xfr
operator|.
name|id
argument_list|)
expr_stmt|;
name|hp
operator|->
name|opcode
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|opcode
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|ptrs
index|[
literal|0
index|]
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|msg
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|ptrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|eom
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|msg
operator|+
name|XFER_BUFSIZE
expr_stmt|;
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
operator|!=
name|NULL
condition|)
name|qsp
operator|->
name|xfr
operator|.
name|eom
operator|-=
name|TSIG_BUF_SIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * int  * sx_flush(qsp)  *	flush the intermediate buffer out to the stream IO system.  * return:  *	passed through from sq_write().  */
end_comment

begin_function
specifier|static
name|int
name|sx_flush
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|msg
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|-
name|qsp
operator|->
name|xfr
operator|.
name|msg
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
operator|!=
name|NULL
operator|&&
name|qsp
operator|->
name|xfr
operator|.
name|tsig_skip
operator|==
literal|0
condition|)
block|{
name|int
name|msglen
init|=
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|-
name|qsp
operator|->
name|xfr
operator|.
name|msg
decl_stmt|;
name|ns_sign_tcp
argument_list|(
name|qsp
operator|->
name|xfr
operator|.
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|eom
operator|-
name|qsp
operator|->
name|xfr
operator|.
name|msg
argument_list|,
name|NOERROR
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|==
name|s_x_done
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|==
name|s_x_done
condition|)
block|{
name|memput
argument_list|(
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
argument_list|,
sizeof|sizeof
argument_list|(
name|ns_tcp_tsig_state
argument_list|)
argument_list|)
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|tsig_state
operator|=
name|NULL
expr_stmt|;
block|}
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|msg
operator|+
name|msglen
expr_stmt|;
block|}
name|ret
operator|=
name|sq_write
argument_list|(
name|qsp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|msg
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|-
name|qsp
operator|->
name|xfr
operator|.
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|=
name|NULL
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|tsig_skip
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|qsp
operator|->
name|xfr
operator|.
name|tsig_skip
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * sx_addrr(qsp, name, dp)  *	add name/dp's RR to the current assembly message.  if it won't fit,  *	write current message out, renew the message, and then RR *must* fit.  * return:  *	-1 = the sx_flush() failed so we could not queue the full message.  *	0 = one way or another, everything is fine.  * side effects:  *	on success, the ANCOUNT is incremented and the pointers are advanced.  */
end_comment

begin_function
specifier|static
name|int
name|sx_addrr
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|qsp
operator|->
name|xfr
operator|.
name|msg
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|edp
init|=
name|qsp
operator|->
name|xfr
operator|.
name|ptrs
operator|+
sizeof|sizeof
name|qsp
operator|->
name|xfr
operator|.
name|ptrs
operator|/
sizeof|sizeof
argument_list|(
name|u_char
operator|*
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|,
name|type
decl_stmt|;
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|transfer_format
operator|==
name|axfr_one_answer
operator|&&
name|sx_flush
argument_list|(
name|qsp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|==
name|NULL
condition|)
name|sx_newmsg
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
comment|/* 	 * Add question to first answer. 	 */
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|==
name|s_x_firstsoa
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
block|{
name|n
operator|=
name|dn_comp
argument_list|(
name|dname
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|eom
operator|-
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|ptrs
argument_list|,
name|edp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
operator|&&
operator|(
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|+
name|n
operator|+
name|INT16SZ
operator|*
literal|2
operator|)
operator|<=
name|qsp
operator|->
name|xfr
operator|.
name|eom
condition|)
block|{
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|type
operator|==
name|ns_t_zxfr
condition|)
name|type
operator|=
name|ns_t_axfr
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|qsp
operator|->
name|flags
operator|&
name|STREAM_AXFRIXFR
operator|)
operator|!=
literal|0
condition|)
name|type
operator|=
name|ns_t_ixfr
expr_stmt|;
else|else
name|type
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|type
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|type
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|)
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|qsp
operator|->
name|xfr
operator|.
name|class
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|)
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|eom
operator|-
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|,
literal|0
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|ptrs
argument_list|,
name|edp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|sx_flush
argument_list|(
name|qsp
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|==
name|NULL
condition|)
name|sx_newmsg
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|eom
operator|-
name|qsp
operator|->
name|xfr
operator|.
name|cp
argument_list|,
literal|0
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|ptrs
argument_list|,
name|edp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|n
operator|>=
literal|0
argument_list|)
expr_stmt|;
block|}
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|cp
operator|+=
name|n
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * sx_soarr(qsp)  *	add the SOA RR's at the current level's top np to the assembly message.  * return:  *	0 = success  *	-1 = write buffer full, cannot continue at this time  * side effects:  *	if progress was made, header and pointers will be advanced.  */
end_comment

begin_function
name|int
name|sx_soarr
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|added_soa
init|=
literal|0
decl_stmt|;
name|foreach_rr
argument_list|(
argument|dp
argument_list|,
argument|qsp->xfr.top.axfr
argument_list|,
argument|T_SOA
argument_list|,
argument|qsp->xfr.class
argument_list|,
argument|qsp->xfr.zone
argument_list|)
block|{
if|if
condition|(
name|sx_addrr
argument_list|(
name|qsp
argument_list|,
name|zones
index|[
name|qsp
operator|->
name|xfr
operator|.
name|zone
index|]
operator|.
name|z_origin
argument_list|,
name|dp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* RR wouldn't fit. Bail out. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|added_soa
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|added_soa
operator|==
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|1
argument_list|,
literal|"no SOA at zone top"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|==
name|s_x_firstsoa
condition|)
block|{
name|foreach_rr
argument_list|(
argument|dp
argument_list|,
argument|qsp->xfr.top.axfr
argument_list|,
argument|T_SIG
argument_list|,
argument|qsp->xfr.class
argument_list|,
argument|qsp->xfr.zone
argument_list|)
block|{
if|if
condition|(
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|!=
name|T_SOA
condition|)
continue|continue;
if|if
condition|(
name|sx_addrr
argument_list|(
name|qsp
argument_list|,
name|zones
index|[
name|qsp
operator|->
name|xfr
operator|.
name|zone
index|]
operator|.
name|z_origin
argument_list|,
name|dp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* RR wouldn't fit. Bail out. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * sx_nsrrs(qsp)  *	add the NS RR's at the current level's current np to the assembly msg.  *      This function also adds the SIG(NS), KEY, SIG(KEY), NXT, SIG(NXT),  *      since these records are also part of the delegation (see DNSSEC).  * return:  *>1 = number of NS RRs added, note that there may be more  *	0 = success, there are no more NS RRs at this level  *	-1 = write buffer full, cannot continue at this time  * side effects:  *	if progress was made, header and pointers will be advanced.  * note:  *	this is meant for AXFR, which includes glue as part of the answer  *	sections.  this is different from and incompatible with the additional  *	data of a referral response.  */
end_comment

begin_function
specifier|static
name|int
name|sx_nsrrs
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|,
modifier|*
name|gdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|gnp
decl_stmt|,
modifier|*
name|tnp
decl_stmt|,
modifier|*
name|top
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|class
decl_stmt|;
name|class
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|class
expr_stmt|;
name|top
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|axfr
expr_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
operator|(
name|dp
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|dp
operator|)
operator|!=
name|NULL
condition|;
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|dp
operator|=
name|db_next
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
comment|/* 		 * It might not be in the same zone, if we are authoritative 		 * for both parent and child, but it does have to be a zone. 		 * 		 * XXX: this is sort of a bug, since it means we merge the 		 *	@ NS RRset into our parent's zone.  But that is what 		 *	db_load() does, so for now we have no choice. 		 */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_KEY
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_NXT
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_SIG
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SIG
operator|&&
operator|(
operator|(
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|!=
name|T_NS
operator|)
operator|&&
operator|(
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|!=
name|T_KEY
operator|)
operator|&&
operator|(
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|!=
name|T_NXT
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
operator|(
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|flags
operator|&
name|SXL_GLUING
operator|)
condition|)
block|{
if|if
condition|(
name|sx_addrr
argument_list|(
name|qsp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|dname
argument_list|,
name|dp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* RR wouldn't fit. Bail out. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
condition|)
comment|/* no glue processing */
continue|continue;
comment|/* Remember we have found a zone cut */
if|if
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|axfr
operator|!=
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|np
condition|)
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|flags
operator||=
name|SXL_ZONECUT
expr_stmt|;
block|}
comment|/* 		 * Glue the sub domains together by sending the address 		 * records for the sub domain name servers along if necessary. 		 * Glue is necessary if the server is in any zone delegated 		 * from the current (top) zone.  Such a delegated zone might 		 * or might not be that referred to by the NS record now 		 * being handled. 		 */
name|htp
operator|=
name|hashtab
expr_stmt|;
name|gnp
operator|=
name|nlookup
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|gnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
condition|)
continue|continue;
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|NULL
operator|&&
name|tnp
operator|!=
name|top
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
operator|(
name|void
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|tnp
operator|==
name|NULL
operator|&&
name|NAME
argument_list|(
operator|*
name|top
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
continue|continue;
comment|/* name server is not below top domain */
for|for
control|(
name|tnp
operator|=
name|gnp
init|;
name|tnp
operator|!=
name|NULL
operator|&&
name|tnp
operator|!=
name|top
condition|;
name|tnp
operator|=
name|tnp
operator|->
name|n_parent
control|)
block|{
name|foreach_rr
argument_list|(
argument|tdp
argument_list|,
argument|tnp
argument_list|,
argument|T_NS
argument_list|,
argument|class
argument_list|,
argument|DB_Z_CACHE
argument_list|)
break|break;
comment|/* If we found a zone cut, we're outta here. */
if|if
condition|(
name|tdp
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* If name server is not in a delegated zone, skip it. */
if|if
condition|(
name|tnp
operator|==
name|top
operator|||
operator|(
name|tnp
operator|==
name|NULL
operator|&&
name|NAME
argument_list|(
operator|*
name|top
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
continue|continue;
comment|/* Now we know glue records are needed.  Send them. */
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|flags
operator||=
name|SXL_GLUING
expr_stmt|;
name|foreach_rr
argument_list|(
argument|gdp
argument_list|,
argument|gnp
argument_list|,
argument|T_A
argument_list|,
argument|class
argument_list|,
argument|DB_Z_CACHE
argument_list|)
if|if
condition|(
name|sx_addrr
argument_list|(
name|qsp
argument_list|,
name|fname
argument_list|,
name|gdp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 				 * Rats.  We already sent the NS RR, too. 				 * Note that SXL_GLUING is being left on. 				 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* for IPv6 glue AAAA record transfer */
comment|/* patched by yasuhiro@nic.ad.jp, 1999/5/23 */
name|foreach_rr
argument_list|(
argument|gdp
argument_list|,
argument|gnp
argument_list|,
argument|T_AAAA
argument_list|,
argument|class
argument_list|,
argument|DB_Z_CACHE
argument_list|)
if|if
condition|(
name|sx_addrr
argument_list|(
name|qsp
argument_list|,
name|fname
argument_list|,
name|gdp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 				 * Rats.  We already sent the NS RR, too. 				 * Note that SXL_GLUING is being left on. 				 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|foreach_rr
argument_list|(
argument|gdp
argument_list|,
argument|gnp
argument_list|,
argument|ns_t_a6
argument_list|,
argument|class
argument_list|,
argument|DB_Z_CACHE
argument_list|)
if|if
condition|(
name|sx_addrr
argument_list|(
name|qsp
argument_list|,
name|fname
argument_list|,
name|gdp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 				 * Rats.  We already sent the NS RR, too. 				 * Note that SXL_GLUING is being left on. 				 */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|flags
operator|&=
operator|~
name|SXL_GLUING
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int  * sx_allrrs(qsp)  *	add the non-(SOA,NS) RR's at the current level's current np,  *	to the assembly message  *      do not add the DNSSEC types KEY and NXT as the delegation check   *	wrote these types out.  * return:  *>0 = number of RR's added, note that there may be more  *	0 = success, there are no more RRs at this level  *	-1 = write buffer full, cannot continue at this time  * side effects:  *	if progress was made, header and pointers will be advanced.  * note:  *	this is meant for AXFR, which includes glue as part of the answer  *	sections.  this is different from and incompatible with the additional  *	data of a referral response.  */
end_comment

begin_function
specifier|static
name|int
name|sx_allrrs
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|top
decl_stmt|;
name|int
name|rrcount
decl_stmt|,
name|class
decl_stmt|;
name|u_int
name|zone
decl_stmt|;
name|class
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|class
expr_stmt|;
name|top
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|top
operator|.
name|axfr
expr_stmt|;
name|zone
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|zone
expr_stmt|;
name|rrcount
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
operator|(
name|dp
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|dp
operator|)
operator|!=
name|NULL
condition|;
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|dp
operator|=
name|db_next
argument_list|(
name|dp
argument_list|)
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
name|zone
operator|||
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|||
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|||
name|dp
operator|->
name|d_type
operator|==
name|T_NXT
operator|||
name|dp
operator|->
name|d_type
operator|==
name|T_KEY
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SIG
operator|&&
operator|(
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|T_SOA
operator|||
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|T_NS
operator|||
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|T_KEY
operator|||
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|T_NXT
operator|)
condition|)
continue|continue;
name|INSIST
argument_list|(
operator|!
operator|(
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|flags
operator|&
name|SXL_GLUING
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sx_addrr
argument_list|(
name|qsp
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|->
name|dname
argument_list|,
name|dp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* RR wouldn't fit. Bail out. */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|rrcount
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|rrcount
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * void  * sx_sendlev(qsp)  *	send all the RRs at the current level (really a domain name), and  *	do a decomposed recursion to get all subdomains up to and including  *	but not exceeding bottom zone cuts.  * side effects:  *	advances qsp->xfr pointers.  changes qsp->xfr.lev quite often.  *	causes messages to be sent to a remote TCP client.  changes the  *	qsp->xfr.state at the end of the topmost level.  changes the  *	qsp->xfr.lev->state several times per domain name.  */
end_comment

begin_function
name|void
name|sx_sendlev
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|struct
name|qs_x_lev
modifier|*
name|lev
decl_stmt|;
name|again
label|:
name|lev
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|lev
expr_stmt|;
switch|switch
condition|(
name|lev
operator|->
name|state
condition|)
block|{
case|case
name|sxl_ns
case|:
block|{
while|while
condition|(
name|lev
operator|->
name|dp
condition|)
block|{
comment|/* Was the child zone reloaded under us? */
if|if
condition|(
operator|(
name|lev
operator|->
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we can't pack this one in, come back later. */
if|if
condition|(
name|sx_nsrrs
argument_list|(
name|qsp
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
comment|/* No more DP's for the NS RR pass on this NP. */
if|if
condition|(
name|lev
operator|->
name|flags
operator|&
name|SXL_ZONECUT
condition|)
block|{
comment|/* Zone cut, so go directly to end of level. */
break|break;
block|}
comment|/* No NS RR's, so it's safe to send other types. */
name|lev
operator|->
name|state
operator|=
name|sxl_all
expr_stmt|;
name|lev
operator|->
name|dp
operator|=
name|lev
operator|->
name|np
operator|->
name|n_data
expr_stmt|;
if|if
condition|(
name|lev
operator|->
name|dp
condition|)
name|DRCNTINC
argument_list|(
name|lev
operator|->
name|dp
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
case|case
name|sxl_all
case|:
block|{
while|while
condition|(
name|lev
operator|->
name|dp
condition|)
block|{
comment|/* Was a record updated under us? */
if|if
condition|(
operator|(
name|lev
operator|->
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_ACTIVE
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|qsp
operator|->
name|s_rfd
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|sq_remove
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If we can't pack this one in, come back later. */
if|if
condition|(
name|sx_allrrs
argument_list|(
name|qsp
argument_list|)
operator|<
literal|0
condition|)
return|return;
block|}
comment|/* No more non-NS DP's for this NP, do subdomains. */
name|lev
operator|->
name|state
operator|=
name|sxl_sub
expr_stmt|;
goto|goto
name|again
goto|;
block|}
case|case
name|sxl_sub
case|:
block|{
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
comment|/* Get next in-use hash chain if we're not following one. */
while|while
condition|(
name|lev
operator|->
name|nnp
operator|==
name|NULL
condition|)
block|{
comment|/* If no, or no more subdomains, end of level. */
if|if
condition|(
name|lev
operator|->
name|npp
operator|==
name|NULL
operator|||
name|lev
operator|->
name|npp
operator|==
name|lev
operator|->
name|npe
condition|)
break|break;
name|lev
operator|->
name|nnp
operator|=
operator|*
name|lev
operator|->
name|npp
operator|++
expr_stmt|;
block|}
comment|/* If we encountered the end of the level, we're outta here. */
if|if
condition|(
operator|(
name|np
operator|=
name|lev
operator|->
name|nnp
operator|)
operator|==
name|NULL
condition|)
break|break;
comment|/* Next time, we'll do the following NP, or the next chain. */
name|lev
operator|->
name|nnp
operator|=
name|np
operator|->
name|n_next
expr_stmt|;
comment|/* Skip our own NP if it appears as a subdom (as in root). */
if|if
condition|(
name|np
operator|!=
name|lev
operator|->
name|np
condition|)
name|sx_pushlev
argument_list|(
name|qsp
argument_list|,
name|np
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* End of level. Pop it off the stack. */
if|if
condition|(
operator|(
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|=
name|sx_freelev
argument_list|(
name|lev
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* End of topmost level. */
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|=
name|s_x_lastsoa
expr_stmt|;
name|sq_writeh
argument_list|(
name|qsp
argument_list|,
name|sx_sendsoa
argument_list|)
expr_stmt|;
return|return;
block|}
goto|goto
name|again
goto|;
block|}
end_function

begin_comment
comment|/*  * void  * sx_sendsoa(qsp)  *	send either the first or last SOA needed for an AXFR.  * side effects:  *	changes qsp->xfr.state.  adds RR to output buffer.  */
end_comment

begin_function
name|void
name|sx_sendsoa
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|qsp
operator|->
name|xfr
operator|.
name|msg
decl_stmt|;
if|if
condition|(
name|sx_soarr
argument_list|(
name|qsp
argument_list|)
operator|==
operator|-
literal|1
condition|)
return|return;
comment|/* No state change, come back here later. */
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
switch|switch
condition|(
name|qsp
operator|->
name|xfr
operator|.
name|state
condition|)
block|{
case|case
name|s_x_firstsoa
case|:
block|{
comment|/* Next thing to do is send the zone. */
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|=
name|s_x_zone
expr_stmt|;
name|sq_writeh
argument_list|(
name|qsp
argument_list|,
name|sx_sendlev
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|s_x_lastsoa
case|:
block|{
comment|/* Next thing to do is go back and wait for another query. */
name|qsp
operator|->
name|xfr
operator|.
name|state
operator|=
name|s_x_done
expr_stmt|;
operator|(
name|void
operator|)
name|sx_flush
argument_list|(
name|qsp
argument_list|)
expr_stmt|;
name|sq_writeh
argument_list|(
name|qsp
argument_list|,
name|sq_flushw
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
block|{
name|ns_panic
argument_list|(
name|ns_log_xfer_out
argument_list|,
literal|1
argument_list|,
literal|"unexpected state %d in sx_sendsoa"
argument_list|,
name|qsp
operator|->
name|xfr
operator|.
name|state
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* int  * sx_pushlev(qsp, np)  *	manage the decomposed recursion.  set up for a new level (domain).  * returns:  *	0 = success  *	-1 = failure (check errno)  */
end_comment

begin_function
specifier|static
name|int
name|sx_pushlev
parameter_list|(
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|,
name|struct
name|namebuf
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|qs_x_lev
modifier|*
name|new
init|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
if|if
condition|(
operator|!
name|new
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memset
argument_list|(
name|new
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|new
argument_list|)
expr_stmt|;
name|new
operator|->
name|state
operator|=
name|sxl_ns
expr_stmt|;
name|new
operator|->
name|np
operator|=
name|np
expr_stmt|;
name|new
operator|->
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|dp
condition|)
name|DRCNTINC
argument_list|(
name|new
operator|->
name|dp
argument_list|)
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|new
operator|->
name|dname
argument_list|,
sizeof|sizeof
name|new
operator|->
name|dname
argument_list|)
expr_stmt|;
comment|/* 	 * We find the subdomains by looking in the hash table for this 	 * domain, but the root domain needs special treatment, because 	 * of the following wart in the database design: 	 * 	 * The top level hash table (pointed to by the global `hashtab' 	 * variable) contains pointers to the namebuf's for the root as 	 * well as for the top-level domains below the root, in contrast 	 * to the usual situation where a hash table contains entries 	 * for domains at the same level.  The n_hash member of the 	 * namebuf for the root domain is NULL instead of pointing to a 	 * hashbuf for the top-level domains.  The n_parent members of 	 * the namebufs for the top-level domains are NULL instead of 	 * pointing to the namebuf for the root. 	 * 	 * We work around the wart as follows: 	 * 	 * If we are not dealing with the root zone then we just set 	 * htp = np->n_hash, pointing to the hash table for the current 	 * domain, and we walk through the hash table as usual, 	 * processing the namebufs for all the subdomains. 	 * 	 * If we are dealing with the root zone, then we set 	 * htp = hashtab, pointing to the global hash table (because 	 * there is no hash table associated with the root domain's 	 * namebuf.  While we walk this hash table, we take care not to 	 * recursively process the entry for the root namebuf. 	 * 	 * (apb@und nov1990) 	 */
name|htp
operator|=
operator|(
operator|(
name|new
operator|->
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
name|hashtab
else|:
name|np
operator|->
name|n_hash
operator|)
expr_stmt|;
if|if
condition|(
name|htp
condition|)
block|{
name|new
operator|->
name|npp
operator|=
name|htp
operator|->
name|h_tab
expr_stmt|;
name|new
operator|->
name|npe
operator|=
name|htp
operator|->
name|h_tab
operator|+
name|htp
operator|->
name|h_size
expr_stmt|;
block|}
else|else
block|{
name|new
operator|->
name|npp
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|npe
operator|=
name|NULL
expr_stmt|;
block|}
name|new
operator|->
name|nnp
operator|=
name|NULL
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|qsp
operator|->
name|xfr
operator|.
name|lev
expr_stmt|;
name|qsp
operator|->
name|xfr
operator|.
name|lev
operator|=
name|new
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * qs_x_lev *  * sx_freelev(lev)  *	free the memory occupied by a level descriptor  * return:  *	pointer to "next" level descriptor  */
end_comment

begin_function
specifier|static
name|struct
name|qs_x_lev
modifier|*
name|sx_freelev
parameter_list|(
name|struct
name|qs_x_lev
modifier|*
name|lev
parameter_list|)
block|{
name|struct
name|qs_x_lev
modifier|*
name|next
init|=
name|lev
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|lev
operator|->
name|dp
condition|)
block|{
name|DRCNTDEC
argument_list|(
name|lev
operator|->
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lev
operator|->
name|dp
operator|->
name|d_rcnt
operator|==
literal|0
condition|)
name|db_freedata
argument_list|(
name|lev
operator|->
name|dp
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|lev
argument_list|,
sizeof|sizeof
expr|*
name|lev
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|databuf
modifier|*
name|db_next
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|next
init|=
name|dp
operator|->
name|d_next
decl_stmt|;
name|DRCNTDEC
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_rcnt
operator|==
literal|0
condition|)
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|next
condition|)
name|DRCNTINC
argument_list|(
name|next
argument_list|)
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

end_unit

