begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: db_ixfr.c,v 8.23.2.2 2001/05/03 03:53:18 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Portions Copyright (c) 1999 by Check Point Software Technologies, Inc.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Check Point Software Technologies Incorporated not be used   * in advertising or publicity pertaining to distribution of the document   * or software without specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND CHECK POINT SOFTWARE TECHNOLOGIES   * INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,   * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.     * IN NO EVENT SHALL CHECK POINT SOFTWARE TECHNOLOGIES INCORPRATED  * BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR   * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Manage ixfr transaction log  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<res_update.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_define
define|#
directive|define
name|DBIXFR_ERROR
value|(-1)
end_define

begin_define
define|#
directive|define
name|DBIXFR_FOUND_RR
value|2
end_define

begin_define
define|#
directive|define
name|DBIXFR_END
value|3
end_define

begin_function_decl
specifier|static
name|int
name|ixfr_getdelta
parameter_list|(
name|struct
name|zoneinfo
modifier|*
parameter_list|,
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|ns_updque
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|,
name|u_int32_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|ns_deltalist
modifier|*
name|ixfr_get_change_list
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|u_int32_t
name|from_serial
parameter_list|,
name|u_int32_t
name|to_serial
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|old_serial
decl_stmt|,
name|new_serial
decl_stmt|;
name|char
name|origin
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|ns_deltalist
modifier|*
name|dlhead
init|=
name|NULL
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ns_updrec
modifier|*
name|uprec
decl_stmt|;
name|ns_delta
modifier|*
name|dl
decl_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|from_serial
argument_list|,
name|to_serial
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|dlhead
operator|=
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|dlhead
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dlhead
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|INIT_LIST
argument_list|(
operator|*
name|dlhead
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|strcpy
argument_list|(
name|origin
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
name|old_serial
operator|=
name|new_serial
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|dl
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|==
name|NULL
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"ixfr_get_change_list: out of memory"
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|INIT_LINK
argument_list|(
name|dl
argument_list|,
name|d_link
argument_list|)
expr_stmt|;
name|INIT_LIST
argument_list|(
name|dl
operator|->
name|d_changes
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ixfr_getdelta
argument_list|(
name|zp
argument_list|,
name|fp
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|,
name|origin
argument_list|,
operator|&
name|dl
operator|->
name|d_changes
argument_list|,
operator|&
name|old_serial
argument_list|,
operator|&
name|new_serial
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ret
condition|)
block|{
case|case
name|DBIXFR_ERROR
case|:
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"Logical error in %s: unlinking"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
case|case
name|DBIXFR_FOUND_RR
case|:
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"ixfr_getdelta DBIXFR_FOUND_RR (%s)"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|EMPTY
argument_list|(
operator|*
name|dlhead
argument_list|)
condition|)
block|{
comment|/* skip updates prior to the one we want */
name|uprec
operator|=
name|HEAD
argument_list|(
name|dl
operator|->
name|d_changes
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|uprec
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uprec
operator|->
name|r_zone
operator|<
name|from_serial
operator|)
operator|||
operator|(
name|uprec
operator|->
name|r_zone
operator|>
name|to_serial
operator|)
condition|)
block|{
while|while
condition|(
operator|(
name|uprec
operator|=
name|HEAD
argument_list|(
name|dl
operator|->
name|d_changes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UNLINK
argument_list|(
name|dl
operator|->
name|d_changes
argument_list|,
name|uprec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|uprec
operator|->
name|r_dp
operator|!=
name|NULL
condition|)
name|db_freedata
argument_list|(
name|uprec
operator|->
name|r_dp
argument_list|)
expr_stmt|;
name|uprec
operator|->
name|r_dp
operator|=
name|NULL
expr_stmt|;
name|res_freeupdrec
argument_list|(
name|uprec
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|dl
argument_list|,
sizeof|sizeof
expr|*
name|dl
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|uprec
operator|->
name|r_zone
operator|>
name|from_serial
condition|)
block|{
comment|/* missed the boat */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ixfr_getdelta first SOA is %d, asked for %d (%s)"
argument_list|,
name|uprec
operator|->
name|r_zone
argument_list|,
name|from_serial
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"adding to change list (%s)"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
operator|*
name|dlhead
argument_list|,
name|dl
argument_list|,
name|d_link
argument_list|)
expr_stmt|;
break|break;
case|case
name|DBIXFR_END
case|:
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"ixfr_getdelta DBIXFR_END (%s)"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|dl
argument_list|,
sizeof|sizeof
expr|*
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|dlhead
operator|)
return|;
default|default:
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dl
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|dl
argument_list|,
sizeof|sizeof
expr|*
name|dl
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
name|cleanup
label|:
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dl
operator|=
name|HEAD
argument_list|(
operator|*
name|dlhead
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UNLINK
argument_list|(
operator|*
name|dlhead
argument_list|,
name|dl
argument_list|,
name|d_link
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|uprec
operator|=
name|HEAD
argument_list|(
name|dl
operator|->
name|d_changes
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|UNLINK
argument_list|(
name|dl
operator|->
name|d_changes
argument_list|,
name|uprec
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
if|if
condition|(
name|uprec
operator|->
name|r_dp
operator|!=
name|NULL
condition|)
name|db_freedata
argument_list|(
name|uprec
operator|->
name|r_dp
argument_list|)
expr_stmt|;
name|uprec
operator|->
name|r_dp
operator|=
name|NULL
expr_stmt|;
name|res_freeupdrec
argument_list|(
name|uprec
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|dl
argument_list|,
sizeof|sizeof
expr|*
name|dl
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|dlhead
argument_list|,
sizeof|sizeof
expr|*
name|dlhead
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * int ixfr_have_log(struct zoneinfo *zp,u_int32_t from_serial,  *                   u_int32_t to_serial)  *   * verify that ixfr transaction log contains changes    * from from_serial to to_serial  *   * returns:   *         0 = serial number is up to date  *         1 = transmission is possible   *        -1 = error while opening the ixfr transaction log  *        -2 = error in parameters  *        -3 = logical error in the history file   */
end_comment

begin_function
name|int
name|ixfr_have_log
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|u_int32_t
name|from_serial
parameter_list|,
name|u_int32_t
name|to_serial
parameter_list|)
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|u_int32_t
name|old_serial
init|=
literal|0
decl_stmt|,
name|new_serial
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|last_serial
init|=
literal|0
decl_stmt|;
name|u_int32_t
name|first_serial
init|=
literal|0
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|nonempty_lineno
init|=
operator|-
literal|1
decl_stmt|,
name|prev_pktdone
init|=
literal|0
decl_stmt|,
name|cont
init|=
literal|0
decl_stmt|,
name|inside_next
init|=
literal|0
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|first
init|=
literal|0
decl_stmt|;
name|int
name|rval
init|=
literal|0
decl_stmt|;
name|int
name|id
decl_stmt|,
name|rcode
init|=
name|NOERROR
decl_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|from_serial
argument_list|,
name|to_serial
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|2
operator|)
return|;
if|if
condition|(
name|from_serial
operator|==
name|to_serial
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* If there is no log file, just return. */
if|if
condition|(
name|zp
operator|->
name|z_ixfr_base
operator|==
name|NULL
operator|||
name|zp
operator|->
name|z_updatelog
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|zp
operator|->
name|z_serial_ixfr_start
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|from_serial
operator|>=
name|zp
operator|->
name|z_serial_ixfr_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|stat
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|ns_error
argument_list|(
name|ns_log_db
argument_list|,
literal|"unexpected stat(%s) failure: %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"fgets() from %s failed: %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buf
argument_list|,
name|LogSignature
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"invalid log file %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|3
operator|)
return|;
block|}
name|lineno
operator|=
literal|1
expr_stmt|;
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|nonempty_lineno
operator|=
name|lineno
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lineno
operator|==
operator|(
name|nonempty_lineno
operator|+
literal|1
operator|)
condition|)
continue|continue;
name|inside_next
operator|=
literal|0
expr_stmt|;
name|prev_pktdone
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[DYNAMIC_UPDATE]"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[IXFR_UPDATE]"
argument_list|)
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|!
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"id %d"
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|id
operator|=
operator|-
literal|1
expr_stmt|;
name|inside_next
operator|=
literal|1
expr_stmt|;
name|prev_pktdone
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"serial"
argument_list|)
condition|)
block|{
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"%u"
argument_list|,
operator|&
name|old_serial
argument_list|)
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|1
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|first_serial
operator|=
name|old_serial
expr_stmt|;
block|}
name|last_serial
operator|=
name|old_serial
expr_stmt|;
if|if
condition|(
name|from_serial
operator|>=
name|old_serial
condition|)
block|{
name|rval
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|prev_pktdone
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[INCR_SERIAL]"
argument_list|)
condition|)
block|{
comment|/* XXXRTH not enough error checking here */
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"from %u to %u"
argument_list|,
operator|&
name|old_serial
argument_list|,
operator|&
name|new_serial
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|rval
operator|=
operator|-
literal|3
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|from_serial
operator|>=
name|old_serial
condition|)
block|{
if|if
condition|(
name|first
operator|==
literal|1
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
name|first_serial
operator|=
name|old_serial
expr_stmt|;
block|}
name|last_serial
operator|=
name|old_serial
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|prev_pktdone
condition|)
block|{
name|prev_pktdone
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
block|}
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_serial
operator|+
literal|1
operator|<
name|zp
operator|->
name|z_serial
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s: File Deleted. Found gap between serial:"
literal|" %d and current serial: %d"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|,
name|last_serial
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|rval
operator|=
operator|-
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|from_serial
operator|<
name|first_serial
operator|||
name|from_serial
operator|>
name|last_serial
condition|)
name|rval
operator|=
operator|-
literal|3
expr_stmt|;
if|if
condition|(
name|rval
operator|==
literal|1
condition|)
name|zp
operator|->
name|z_serial_ixfr_start
operator|=
name|first_serial
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
end_function

begin_comment
comment|/* from db_load.c */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|map
name|m_section
index|[]
init|=
block|{
block|{
literal|"zone"
block|,
name|S_ZONE
block|}
block|,
block|{
literal|"prereq"
block|,
name|S_PREREQ
block|}
block|,
block|{
literal|"update"
block|,
name|S_UPDATE
block|}
block|,
block|{
literal|"reserved"
block|,
name|S_ADDT
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_SECTION_CNT
value|(sizeof(m_section) / sizeof(struct map))
end_define

begin_comment
comment|/* from ns_req.c */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|map
name|m_opcode
index|[]
init|=
block|{
block|{
literal|"nxdomain"
block|,
name|NXDOMAIN
block|}
block|,
block|{
literal|"yxdomain"
block|,
name|YXDOMAIN
block|}
block|,
block|{
literal|"nxrrset"
block|,
name|NXRRSET
block|}
block|,
block|{
literal|"yxrrset"
block|,
name|YXRRSET
block|}
block|,
block|{
literal|"delete"
block|,
name|DELETE
block|}
block|,
block|{
literal|"add"
block|,
name|ADD
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|M_OPCODE_CNT
value|(sizeof(m_opcode) / sizeof(struct map))
end_define

begin_comment
comment|/* XXXRTH workaround map difficulties */
end_comment

begin_define
define|#
directive|define
name|M_CLASS_CNT
value|m_class_cnt
end_define

begin_define
define|#
directive|define
name|M_TYPE_CNT
value|m_type_cnt
end_define

begin_comment
comment|/*  * read a line from the history of a zone.  *   * returns:  *   *         DBIXFR_ERROR = an error occured   *         DBIXFR_FOUND_RR = a rr encountered   *         DBIXFR_END = end of file  */
end_comment

begin_function
specifier|static
name|int
name|ixfr_getdelta
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|char
modifier|*
name|origin
parameter_list|,
name|ns_updque
modifier|*
name|listuprec
parameter_list|,
name|u_int32_t
modifier|*
name|old_serial
parameter_list|,
name|u_int32_t
modifier|*
name|new_serial
parameter_list|)
block|{
name|char
name|data
index|[
name|MAXDATA
index|]
decl_stmt|,
name|dnbuf
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|sclass
index|[
literal|3
index|]
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|;
name|char
name|buf
index|[
name|MAXDATA
index|]
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|,
name|ttl
decl_stmt|;
name|u_int32_t
name|current_serial
decl_stmt|;
name|int
name|nonempty_lineno
init|=
operator|-
literal|1
decl_stmt|,
name|prev_pktdone
init|=
literal|0
decl_stmt|,
name|cont
init|=
literal|0
decl_stmt|,
name|inside_next
init|=
literal|0
decl_stmt|;
name|int
name|id
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|section
decl_stmt|,
name|opcode
decl_stmt|,
name|matches
decl_stmt|,
name|zonenum
decl_stmt|,
name|err
decl_stmt|,
name|multiline
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
name|u_int32_t
name|n
decl_stmt|;
name|enum
name|transport
name|transport
decl_stmt|;
name|struct
name|map
modifier|*
name|mp
decl_stmt|;
name|int
name|zonelist
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|in_addr
name|ina
decl_stmt|;
name|int
name|datasize
decl_stmt|;
name|ns_updrec
modifier|*
name|rrecp
decl_stmt|;
name|u_long
name|l
decl_stmt|;
define|#
directive|define
name|ERRTO
parameter_list|(
name|msg
parameter_list|)
value|if (1) { errtype = msg; goto err; } else (void)NULL
name|err
operator|=
literal|0
expr_stmt|;
name|transport
operator|=
name|primary_trans
expr_stmt|;
name|lineno
operator|=
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|lineno
operator|==
operator|(
name|nonempty_lineno
operator|+
literal|1
operator|)
operator|&&
operator|!
operator|(
name|feof
argument_list|(
name|fp
argument_list|)
operator|)
condition|)
block|{
comment|/* 				 * End of a nonempty line inside an update 				 * packet or not inside an update packet. 				 */
continue|continue;
block|}
comment|/* 			 * Empty line or EOF. 			 */
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
break|break;
name|inside_next
operator|=
literal|0
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nonempty_lineno
operator|=
name|lineno
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[DYNAMIC_UPDATE]"
argument_list|)
operator|||
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[IXFR_UPDATE]"
argument_list|)
condition|)
block|{
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
operator|!
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"id %d"
argument_list|,
operator|&
name|id
argument_list|)
condition|)
name|id
operator|=
operator|-
literal|1
expr_stmt|;
name|inside_next
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[INCR_SERIAL]"
argument_list|)
condition|)
block|{
comment|/* XXXRTH not enough error checking here */
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
operator|||
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
literal|"from %u to %u"
argument_list|,
name|old_serial
argument_list|,
name|new_serial
argument_list|)
operator|!=
literal|2
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"incr_serial problem with %s"
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|serial
operator|=
name|get_serial
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
name|cont
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
literal|"[END_DELTA]"
argument_list|)
condition|)
block|{
name|prev_pktdone
operator|=
literal|1
expr_stmt|;
name|cont
operator|=
literal|1
expr_stmt|;
name|lineno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|prev_pktdone
condition|)
block|{
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
operator|*
name|listuprec
argument_list|)
condition|)
block|{
name|n
operator|++
expr_stmt|;
return|return
operator|(
name|DBIXFR_FOUND_RR
operator|)
return|;
block|}
name|prev_pktdone
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cont
condition|)
block|{
name|cont
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|inside_next
condition|)
continue|continue;
comment|/* 		 * inside the same update packet, continue accumulating 		 * records. 		 */
name|section
operator|=
operator|-
literal|1
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|n
operator|-
literal|1
index|]
operator|==
literal|':'
condition|)
name|buf
index|[
operator|--
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|mp
operator|=
name|m_section
init|;
name|mp
operator|<
name|m_section
operator|+
name|M_SECTION_CNT
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
name|mp
operator|->
name|token
argument_list|)
condition|)
block|{
name|section
operator|=
name|mp
operator|->
name|val
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
literal|0
expr_stmt|;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|section
condition|)
block|{
case|case
name|S_ZONE
case|:
name|cp
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cp
condition|)
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"origin %s class %s serial %lu"
argument_list|,
name|origin
argument_list|,
name|sclass
argument_list|,
operator|&
name|serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_serial
operator|==
literal|0
condition|)
name|current_serial
operator|=
name|serial
expr_stmt|;
elseif|else
if|if
condition|(
name|current_serial
operator|!=
name|serial
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"%s:line %d serial # askew %d %d"
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|,
name|serial
argument_list|,
name|current_serial
argument_list|)
expr_stmt|;
name|current_serial
operator|=
name|serial
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
literal|3
operator|||
name|ns_samename
argument_list|(
name|origin
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
operator|!=
literal|1
condition|)
name|err
operator|++
expr_stmt|;
if|if
condition|(
name|cp
condition|)
name|lineno
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|inside_next
condition|)
block|{
name|int
name|success
decl_stmt|;
name|dname
operator|=
name|origin
expr_stmt|;
name|type
operator|=
name|T_SOA
expr_stmt|;
name|class
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
name|sclass
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|success
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|matches
operator|=
name|findzone
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|zonelist
argument_list|,
name|MAXDNAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|matches
condition|)
name|zonenum
operator|=
name|zonelist
index|[
literal|0
index|]
expr_stmt|;
else|else
name|err
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|S_PREREQ
case|:
case|case
name|S_UPDATE
case|:
comment|/* Operation code. */
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|opcode
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'{'
condition|)
block|{
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int32_t
operator|)
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
name|buf
index|[
name|i
index|]
operator|=
name|buf
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|buf
index|[
name|n
operator|-
literal|2
index|]
operator|==
literal|'}'
condition|)
name|buf
index|[
name|n
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
for|for
control|(
name|mp
operator|=
name|m_opcode
init|;
name|mp
operator|<
name|m_opcode
operator|+
name|M_OPCODE_CNT
condition|;
name|mp
operator|++
control|)
if|if
condition|(
operator|!
name|strcasecmp
argument_list|(
name|buf
argument_list|,
name|mp
operator|->
name|token
argument_list|)
condition|)
block|{
name|opcode
operator|=
name|mp
operator|->
name|val
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opcode
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
comment|/* Owner's domain name. */
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dnbuf
argument_list|,
sizeof|sizeof
name|dnbuf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dnbuf
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|dnbuf
index|[
name|n
index|]
operator|==
literal|'.'
condition|)
name|dnbuf
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
name|dname
operator|=
name|dnbuf
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
name|type
operator|=
operator|-
literal|1
expr_stmt|;
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|buf
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
comment|/* ttl */
if|if
condition|(
name|ns_parse_ttl
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|ttl
operator|=
name|l
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* possibly class */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|success
decl_stmt|;
name|int
name|maybe_class
decl_stmt|;
name|maybe_class
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|class
operator|=
name|maybe_class
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* possibly type */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|int
name|success
decl_stmt|;
name|int
name|maybe_type
decl_stmt|;
name|maybe_type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|buf
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
block|{
name|type
operator|=
name|maybe_type
expr_stmt|;
operator|(
name|void
operator|)
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
comment|/* possibly rdata */
comment|/* 			 * Convert the ascii data 'buf' to the proper 			 * format based on the type and pack into 			 * 'data'. 			 *  			 * XXX - same as in db_load(), consolidation 			 * needed 			 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|ntohl
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|INT32SZ
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
case|case
name|T_ISDN
case|:
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|n
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|data
index|[
name|n
index|]
operator|=
name|i
expr_stmt|;
name|n
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|data
operator|+
name|n
operator|+
literal|1
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|n
operator|+=
name|i
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
operator|+
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp
operator|-
name|data
operator|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|T_SOA
condition|)
block|{
name|n
operator|=
name|cp
operator|-
name|data
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|class
operator|!=
name|zp
operator|->
name|z_class
operator|||
name|ns_samename
argument_list|(
name|dname
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|c
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'('
condition|)
block|{
name|multiline
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|multiline
operator|=
literal|0
expr_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
name|getnum
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
name|GETNUM_SERIAL
argument_list|,
operator|&
name|multiline
argument_list|)
expr_stmt|;
if|if
condition|(
name|getnum_error
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opcode
operator|==
name|ADD
condition|)
operator|*
name|new_serial
operator|=
name|n
expr_stmt|;
name|current_serial
operator|=
name|n
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ns_parse_ttl
argument_list|(
name|buf
argument_list|,
operator|&
name|l
argument_list|)
operator|<
literal|0
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|l
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|multiline
condition|)
block|{
name|c
operator|=
name|getnonblank
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|')'
condition|)
block|{
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|err
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|n
operator|=
name|cp
operator|-
name|data
expr_stmt|;
break|break;
case|case
name|T_WKS
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|ina
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|ntohl
argument_list|(
name|ina
operator|.
name|s_addr
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|char
operator|)
name|getprotocol
argument_list|(
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|n
operator|=
name|INT32SZ
operator|+
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
name|n
operator|=
name|getservices
argument_list|(
operator|(
name|int
operator|)
name|n
argument_list|,
name|data
argument_list|,
name|fp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|data
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|makename
argument_list|(
name|data
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|n
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
comment|/* catch bad values */
name|cp
operator|=
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|makename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|origin
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|data
operator|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
comment|/* advance pointer to end of data */
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* now save length */
name|n
operator|=
operator|(
name|cp
operator|-
name|data
operator|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|n
operator|=
literal|0
expr_stmt|;
name|data
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|n
operator|=
name|n
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|PUTSHORT
argument_list|(
operator|(
name|u_int16_t
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|getword
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|n
operator|=
name|cp
operator|-
name|data
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
name|i
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|data
expr_stmt|;
name|datasize
operator|=
sizeof|sizeof
name|data
expr_stmt|;
name|cp1
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|i
operator|>
name|MAXCHARSTRING
condition|)
block|{
if|if
condition|(
name|datasize
operator|<=
name|MAXCHARSTRING
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"record too big"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|datasize
operator|-=
name|MAXCHARSTRING
expr_stmt|;
operator|*
name|cp
operator|++
operator|=
operator|(
name|char
operator|)
name|MAXCHARSTRING
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|MAXCHARSTRING
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|MAXCHARSTRING
expr_stmt|;
name|cp1
operator|+=
name|MAXCHARSTRING
expr_stmt|;
name|i
operator|-=
name|MAXCHARSTRING
expr_stmt|;
block|}
if|if
condition|(
name|datasize
operator|<
name|i
operator|+
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_update
argument_list|,
literal|"record too big"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|*
name|cp
operator|++
operator|=
name|i
expr_stmt|;
name|memcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|i
expr_stmt|;
name|n
operator|=
name|cp
operator|-
name|data
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* XXXVIX: segmented texts 4.9.5 */
break|break;
case|case
name|T_NSAP
case|:
name|n
operator|=
name|inet_nsap_addr
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_LOC
case|:
name|cp
operator|=
name|buf
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
operator|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|' '
expr_stmt|;
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|,
operator|*
name|cp
operator|=
name|i
operator|,
name|i
operator|!=
name|EOF
operator|)
operator|&&
operator|*
name|cp
operator|!=
literal|'\n'
operator|&&
operator|(
name|n
operator|<
name|MAXDATA
operator|)
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|ungetc
argument_list|(
operator|*
name|cp
argument_list|,
name|fp
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|n
operator|=
name|loc_aton
argument_list|(
name|buf
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|err
operator|++
expr_stmt|;
break|break;
block|}
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_sig
case|:
case|case
name|ns_t_nxt
case|:
case|case
name|ns_t_key
case|:
case|case
name|ns_t_cert
case|:
block|{
name|char
modifier|*
name|errmsg
init|=
name|NULL
decl_stmt|;
name|n
operator|=
name|parse_sec_rdata
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|,
name|fp
argument_list|,
name|zp
argument_list|,
name|dname
argument_list|,
name|ttl
argument_list|,
name|type
argument_list|,
name|domain_ctx
argument_list|,
name|transport
argument_list|,
operator|&
name|errmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|errmsg
condition|)
block|{
name|err
operator|++
expr_stmt|;
name|endline
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
default|default:
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|section
operator|==
name|S_PREREQ
condition|)
block|{
name|ttl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|NXDOMAIN
condition|)
block|{
name|class
operator|=
name|C_NONE
expr_stmt|;
name|type
operator|=
name|T_ANY
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|YXDOMAIN
condition|)
block|{
name|class
operator|=
name|C_ANY
expr_stmt|;
name|type
operator|=
name|T_ANY
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|NXRRSET
condition|)
block|{
name|class
operator|=
name|C_NONE
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|YXRRSET
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|class
operator|=
name|C_ANY
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* section == S_UPDATE */
if|if
condition|(
name|opcode
operator|==
name|DELETE
condition|)
block|{
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|class
operator|=
name|C_ANY
expr_stmt|;
if|if
condition|(
name|type
operator|==
operator|-
literal|1
condition|)
name|type
operator|=
name|T_ANY
expr_stmt|;
block|}
else|else
block|{
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
name|S_ADDT
case|:
default|default:
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"cannot interpret section: %d"
argument_list|,
name|section
argument_list|)
expr_stmt|;
name|inside_next
operator|=
literal|0
expr_stmt|;
name|err
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|inside_next
operator|=
literal|0
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_update
argument_list|,
literal|1
argument_list|,
literal|"merge of update id %d failed due to error at line %d"
argument_list|,
name|id
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
return|return
operator|(
name|DBIXFR_ERROR
operator|)
return|;
block|}
name|rrecp
operator|=
name|res_mkupdrec
argument_list|(
name|section
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|!=
name|S_ZONE
condition|)
block|{
name|dp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|zonenum
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_ZONE
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
name|nlabels
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|rrecp
operator|->
name|r_dp
operator|=
name|dp
expr_stmt|;
name|rrecp
operator|->
name|r_opcode
operator|=
name|opcode
expr_stmt|;
block|}
else|else
block|{
name|rrecp
operator|->
name|r_zone
operator|=
name|zonenum
expr_stmt|;
name|rrecp
operator|->
name|r_opcode
operator|=
name|opcode
expr_stmt|;
block|}
comment|/* remove add/delete pairs */
if|if
condition|(
name|section
operator|==
name|S_UPDATE
condition|)
block|{
name|ns_updrec
modifier|*
name|arp
decl_stmt|;
name|int
name|foundmatch
decl_stmt|;
name|arp
operator|=
name|TAIL
argument_list|(
operator|*
name|listuprec
argument_list|)
expr_stmt|;
name|foundmatch
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|arp
condition|)
block|{
if|if
condition|(
name|arp
operator|->
name|r_section
operator|==
name|S_UPDATE
operator|&&
operator|(
operator|(
name|arp
operator|->
name|r_opcode
operator|==
name|DELETE
operator|&&
name|opcode
operator|==
name|ADD
operator|)
operator|||
operator|(
name|opcode
operator|==
name|DELETE
operator|&&
name|arp
operator|->
name|r_opcode
operator|==
name|ADD
operator|)
operator|)
operator|&&
name|arp
operator|->
name|r_dp
operator|->
name|d_type
operator|==
name|dp
operator|->
name|d_type
operator|&&
name|arp
operator|->
name|r_dp
operator|->
name|d_class
operator|==
name|dp
operator|->
name|d_class
operator|&&
name|arp
operator|->
name|r_dp
operator|->
name|d_ttl
operator|==
name|dp
operator|->
name|d_ttl
operator|&&
name|ns_samename
argument_list|(
name|arp
operator|->
name|r_dname
argument_list|,
name|dname
argument_list|)
operator|==
literal|1
operator|&&
name|db_cmp
argument_list|(
name|arp
operator|->
name|r_dp
argument_list|,
name|dp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|arp
operator|->
name|r_dp
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
operator|*
name|listuprec
argument_list|,
name|arp
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
name|res_freeupdrec
argument_list|(
name|arp
argument_list|)
expr_stmt|;
name|res_freeupdrec
argument_list|(
name|rrecp
argument_list|)
expr_stmt|;
name|foundmatch
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|arp
operator|=
name|PREV
argument_list|(
name|arp
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|foundmatch
condition|)
continue|continue;
block|}
name|APPEND
argument_list|(
operator|*
name|listuprec
argument_list|,
name|rrecp
argument_list|,
name|r_link
argument_list|)
expr_stmt|;
comment|/* Override zone number with current zone serial number */
name|rrecp
operator|->
name|r_zone
operator|=
name|serial
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|DBIXFR_ERROR
operator|)
return|;
return|return
operator|(
name|DBIXFR_END
operator|)
return|;
block|}
end_function

end_unit

