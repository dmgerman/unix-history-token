begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)db_update.c	4.28 (Berkeley) 3/21/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: db_update.c,v 8.46 2001/02/08 02:05:51 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_comment
comment|/* int  * isRefByNS(name, htp)  *	recurse through all of `htp' looking for NS RR's that refer to `name'.  * returns:  *	nonzero if at least one such NS RR exists  * cautions:  *	this is very expensive; probably you only want to use on fcachetab.  */
end_comment

begin_function
specifier|static
name|int
name|isRefByNS
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|)
block|{
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|(
name|dp
operator|->
name|d_class
operator|==
name|C_ANY
operator|||
name|dp
operator|->
name|d_class
operator|==
name|C_IN
operator|||
name|dp
operator|->
name|d_class
operator|==
name|C_HS
operator|)
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|&&
operator|!
name|dp
operator|->
name|d_rcode
operator|&&
name|ns_samename
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|)
operator|==
literal|1
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_hash
operator|&&
name|isRefByNS
argument_list|(
name|name
argument_list|,
name|np
operator|->
name|n_hash
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int  * findMyZone(struct namebuf *np, int class)  *	surf the zone cuts and find this zone the hard way  * return value:  *	zone number or DB_Z_CACHE if it's outside a zone  * interesting cases:  *	    DEC.COM SOA (primary)  *	CRL.DEC.COM NS  (in primary)  *		if you start at CRL.. here, you find the DEC.COM zone  *		if you start at NS.CRL.. here, you're in the cache  *	    DEC.COM SOA (primary)  *	CRL.DEC.COM NS  (in primary)  *	CRL.DEC.COM SOA (slave)  *	CRL.DEC.COM NS  (in slave)  *		if you start at CRL.. here, you find the CRL.DEC.COM zone  *		if you start at NS.CRL.. here, you're in the CRL.. zone  */
end_comment

begin_function
name|int
name|findMyZone
parameter_list|(
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|int
name|class
parameter_list|)
block|{
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|np
condition|;
name|np
operator|=
name|np_parent
argument_list|(
name|np
argument_list|)
control|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
comment|/* if we encounter an SOA, we're in its zone (which can be 		 * the cache or an authoritative zone, depending). 		 */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
return|return
operator|(
name|dp
operator|->
name|d_zone
operator|)
return|;
comment|/* if we find an NS at some node without having seen an SOA 		 * (above), then we're out in the cache somewhere. 		 */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
return|return
operator|(
name|DB_Z_CACHE
operator|)
return|;
block|}
comment|/* The cache has not yet been primed. */
return|return
operator|(
name|DB_Z_CACHE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int  * db_update(name, odp, newdp, savedpp, flags, htp, from)  *	update data base node at `name'.  `flags' controls the action.  * side effects:  *	inverse query tables modified, if we're using them.  * return value:  *	OK - success  *	NONAME - name doesn't exist  *	AUTH - you can't do that  *	DATAEXISTS - there's something there and DB_NODATA was specified  *	NODATA - there's no data, and (DB_DELETE or DB_MEXIST) was spec'd  *  *	Policy: How to add data if one more RR is -ve data  *  *	NEND	NOERROR_NODATA  *	NXD	NXDOMAIN  *  *				match  *				old  *			Data	NEND	NXD  *		Data	Merge	Data	Data  *	new	NEND	NEND	NEND	NEND  *		NXD	NXD	NXD	NXD  *  *			     no match  *				old  *			Data	NEND	NXD  *		Data	Merge	Merge	Data  *	new	NEND	Merge	Merge	NEND  *		NXD	NXD	NXD	NXD  *  */
end_comment

begin_comment
comment|/* XXX:	this code calls nlookup, which can create namebuf's.  if this code  *	has to exit with a fatal error, it should scan from the new np upward  *	and for each node which has no children and no data it should remove  *	the namebuf.  design notes: (1) there's no harm in doing this even if  *	success occurred; (2) stopping on the first nonremovable np is optimal;  *	the code for removal should be taken out of clean_cache() and made  *	general enough for this use, and for clean_cache()'s continued use.  *							vix, 21jul94  */
end_comment

begin_function
name|int
name|db_update
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|databuf
modifier|*
name|odp
parameter_list|,
name|struct
name|databuf
modifier|*
name|newdp
parameter_list|,
name|struct
name|databuf
modifier|*
modifier|*
name|savedpp
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|zn
decl_stmt|,
name|isHintNS
decl_stmt|;
name|int
name|check_ttl
init|=
literal|0
decl_stmt|;
name|int
name|deleted_something
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
name|int
name|found_other_ns
init|=
literal|0
decl_stmt|;
name|struct
name|databuf
modifier|*
name|tmpdp
decl_stmt|;
endif|#
directive|endif
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|3
argument_list|,
literal|"db_update(%s, %#x, %#x, %#x, 0%o, %#x)%s"
argument_list|,
name|name
argument_list|,
name|odp
argument_list|,
name|newdp
argument_list|,
name|savedpp
argument_list|,
name|flags
argument_list|,
name|htp
argument_list|,
operator|(
name|odp
operator|&&
operator|(
name|odp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|)
condition|?
literal|" hint"
else|:
literal|""
argument_list|)
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|name
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
name|newdp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|name
condition|)
return|return
operator|(
name|NONAME
operator|)
return|;
if|if
condition|(
name|newdp
operator|&&
name|zones
index|[
name|newdp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_PRIMARY
condition|)
name|check_ttl
operator|=
literal|1
expr_stmt|;
comment|/* don't let nonauthoritative updates write in authority zones */
if|if
condition|(
name|newdp
operator|&&
operator|(
operator|(
name|zn
operator|=
name|findMyZone
argument_list|(
name|np
argument_list|,
name|newdp
operator|->
name|d_class
argument_list|)
operator|)
operator|!=
name|DB_Z_CACHE
operator|)
operator|&&
ifdef|#
directive|ifdef
name|STUBS
operator|(
name|zones
index|[
name|zn
index|]
operator|.
name|z_type
operator|!=
name|Z_STUB
operator|)
operator|&&
endif|#
directive|endif
operator|(
name|flags
operator|&
name|DB_NOTAUTH
operator|)
condition|)
block|{
name|int
name|foundRR
init|=
literal|0
decl_stmt|;
comment|/* 		 * Don't generate the warning if the update 		 * would have been harmless (identical data). 		 */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|newdp
argument_list|)
condition|)
block|{
name|foundRR
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|foundRR
condition|)
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|5
argument_list|,
literal|"[%s].%d update? to auth zone \"%s\" (%s)"
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|from
operator|.
name|sin_port
argument_list|)
argument_list|,
name|zones
index|[
name|zn
index|]
operator|.
name|z_origin
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|AUTH
operator|)
return|;
block|}
if|if
condition|(
name|newdp
operator|&&
name|zn
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DB_NOTAUTH
operator|)
condition|)
block|{
if|if
condition|(
name|nlabels
argument_list|(
name|zones
index|[
name|zn
index|]
operator|.
name|z_origin
argument_list|)
operator|>
name|newdp
operator|->
name|d_clev
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|5
argument_list|,
literal|"attempted update child zone %s, %s"
argument_list|,
name|zones
index|[
name|zn
index|]
operator|.
name|z_origin
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|AUTH
operator|)
return|;
block|}
block|}
comment|/* some special checks for root NS' A RR's */
name|isHintNS
operator|=
name|isRefByNS
argument_list|(
name|name
argument_list|,
name|fcachetab
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEPRECATED
if|if
condition|(
name|newdp
operator|&&
name|isHintNS
operator|&&
name|newdp
operator|->
name|d_type
operator|==
name|T_A
condition|)
block|{
comment|/* upgrade credibility of additional data for rootsrv addrs */
if|if
condition|(
name|newdp
operator|->
name|d_cred
operator|==
name|DB_C_ADDITIONAL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|3
argument_list|,
literal|"upgrading credibility for A RR (%s)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* XXX:	should copy NS RR's, but we really just want 			 *	to prevent deprecation later so this will do. 			 */
name|newdp
operator|->
name|d_cred
operator|=
name|DB_C_ANSWER
expr_stmt|;
name|newdp
operator|->
name|d_clev
operator|=
literal|0
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* Reflect certain updates in hint cache also... */
comment|/* Don't stick data we are authoritative for in hints. */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|DB_NOHINTS
operator|)
operator|&&
operator|(
name|flags
operator|&
name|DB_PRIMING
operator|)
operator|&&
operator|(
name|odp
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|htp
operator|!=
name|fcachetab
operator|)
operator|&&
operator|(
name|DB_Z_SPECIAL
argument_list|(
name|odp
operator|->
name|d_zone
argument_list|)
operator|)
operator|&&
operator|!
operator|(
name|odp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|&&
operator|(
operator|!
name|newdp
operator|||
operator|!
name|newdp
operator|->
name|d_rcode
operator|)
operator|&&
operator|(
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|odp
operator|->
name|d_type
operator|==
name|T_NS
operator|)
operator|||
operator|(
name|odp
operator|->
name|d_type
operator|==
name|T_A
operator|&&
name|isHintNS
operator|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|3
argument_list|,
literal|"db_update: hint '%s' %u"
argument_list|,
name|name
argument_list|,
name|odp
operator|->
name|d_ttl
argument_list|)
expr_stmt|;
name|dp
operator|=
name|savedata
argument_list|(
name|odp
operator|->
name|d_class
argument_list|,
name|odp
operator|->
name|d_type
argument_list|,
name|odp
operator|->
name|d_ttl
argument_list|,
name|odp
operator|->
name|d_data
argument_list|,
name|odp
operator|->
name|d_size
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|DB_Z_CACHE
expr_stmt|;
name|dp
operator|->
name|d_flags
operator|=
name|DB_F_HINT
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|DB_C_CACHE
expr_stmt|;
name|dp
operator|->
name|d_secure
operator|=
name|odp
operator|->
name|d_secure
expr_stmt|;
comment|/* BEW - this should be ok */
name|dp
operator|->
name|d_clev
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|db_update
argument_list|(
name|name
argument_list|,
name|dp
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
operator|(
name|flags
operator||
name|DB_NOHINTS
operator|)
argument_list|,
name|fcachetab
argument_list|,
name|from
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|3
argument_list|,
literal|"db_update: hint %#x freed"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|odp
operator|!=
name|NULL
condition|)
block|{
name|int
name|foundRR
init|=
literal|0
decl_stmt|;
name|pdp
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|rrmatch
argument_list|(
name|name
argument_list|,
name|dp
argument_list|,
name|odp
argument_list|)
condition|)
block|{
comment|/* {class,type} doesn't match.  these are 				 * the aggregation cases. 				 */
comment|/* Check that CNAMEs are only accompanied by 				 * Secure DNS RR's (KEY, SIG, and NXT). 				 */
if|if
condition|(
operator|(
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
operator|&&
name|odp
operator|->
name|d_type
operator|!=
name|T_KEY
operator|&&
name|odp
operator|->
name|d_type
operator|!=
name|T_SIG
operator|&&
name|odp
operator|->
name|d_type
operator|!=
name|T_NXT
operator|)
operator|||
operator|(
name|odp
operator|->
name|d_type
operator|==
name|T_CNAME
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_KEY
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_SIG
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_NXT
operator|)
operator|)
operator|&&
name|odp
operator|->
name|d_class
operator|==
name|dp
operator|->
name|d_class
operator|&&
comment|/* XXXRTH d_mark removed in 4.9.5, 				       but still here for dynamic 				       update */
name|odp
operator|->
name|d_mark
operator|==
name|dp
operator|->
name|d_mark
operator|&&
operator|!
name|dp
operator|->
name|d_rcode
operator|&&
operator|!
name|odp
operator|->
name|d_rcode
operator|&&
ifdef|#
directive|ifdef
name|BIND_UPDATE
comment|/* updating a CNAME with another CNAME is permitted */
operator|(
name|dp
operator|->
name|d_type
operator|!=
name|T_CNAME
operator|||
name|odp
operator|->
name|d_type
operator|!=
name|T_CNAME
operator|)
operator|&&
endif|#
directive|endif
name|zones
index|[
name|odp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|!=
name|Z_CACHE
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s has CNAME and other data (invalid)"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
index|[
name|odp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_PRIMARY
condition|)
return|return
operator|(
name|CNAMEANDOTHER
operator|)
return|;
goto|goto
name|skip
goto|;
block|}
if|if
condition|(
operator|!
name|newdp
operator|||
name|newdp
operator|->
name|d_class
operator|!=
name|dp
operator|->
name|d_class
condition|)
goto|goto
name|skip
goto|;
comment|/* if the new data is authorative  				 * remove any data for this domain with 				 * the same class that isn't as credable 				 */
if|if
condition|(
name|newdp
operator|->
name|d_cred
operator|==
name|DB_C_ZONE
operator|&&
name|newdp
operator|->
name|d_cred
operator|>
name|dp
operator|->
name|d_cred
condition|)
comment|/* better credibility and the old datum 					 * was not from a zone file.  remove 					 * the old datum. 					 */
goto|goto
name|delete
goto|;
if|#
directive|if
literal|0
comment|/* caught by findMyZone() now. */
comment|/* if we have authoritative data for a 				 * node, don't add in other data. 				 */
block|if (dp->d_cred == DB_C_ZONE&& 				    newdp->d_cred< dp->d_cred) 					return (AUTH);
endif|#
directive|endif
comment|/* if the new data is authoritative 				 * but isn't as credible, reject it. 				 */
if|if
condition|(
name|newdp
operator|->
name|d_cred
operator|==
name|DB_C_ZONE
operator|&&
name|dp
operator|->
name|d_cred
operator|==
name|DB_C_ZONE
condition|)
block|{
comment|/* Both records are from a zone file. 					 * If their credibility levels differ, 					 * we're dealing with a zone cut.  The 					 * record with lower clev is from the 					 * upper zone's file and is therefore  					 * glue. 					 */
comment|/* BEW/OG: we see no reason to override 					 * these rules with new security based 					 * rules. 					 */
if|if
condition|(
name|newdp
operator|->
name|d_clev
operator|<
name|dp
operator|->
name|d_clev
condition|)
block|{
if|if
condition|(
operator|!
name|ISVALIDGLUE
argument_list|(
name|newdp
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"domain %s %s record in zone %s should be in zone %s, ignored"
argument_list|,
name|name
argument_list|,
name|p_type
argument_list|(
name|newdp
operator|->
name|d_type
argument_list|)
argument_list|,
name|zones
index|[
name|newdp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|,
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AUTH
operator|)
return|;
block|}
if|if
condition|(
name|newdp
operator|->
name|d_clev
operator|>
name|dp
operator|->
name|d_clev
condition|)
block|{
if|if
condition|(
operator|!
name|ISVALIDGLUE
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"domain %s %s record in zone %s should be in zone %s, deleted"
argument_list|,
name|name
argument_list|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
argument_list|,
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|,
name|zones
index|[
name|newdp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
block|}
goto|goto
name|delete
goto|;
block|}
block|}
comment|/* process NXDOMAIN */
comment|/* policy */
if|if
condition|(
name|newdp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_cred
operator|<
name|DB_C_AUTH
operator|&&
name|newdp
operator|->
name|d_secure
operator|>=
name|dp
operator|->
name|d_secure
condition|)
goto|goto
name|delete
goto|;
else|else
return|return
operator|(
name|DATAEXISTS
operator|)
return|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
goto|goto
name|delete
goto|;
comment|/* process NOERROR_NODATA */
comment|/* NO PROCESSING REQUIRED */
goto|goto
name|skip
goto|;
block|}
comment|/*if {class,type} did not match*/
comment|/* 			 * {type,class} did match.  This is the replace case. 			 */
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|5
argument_list|,
literal|"db_update: flags = %#x, sizes = %d, %d (cmp %d)"
argument_list|,
name|flags
argument_list|,
name|odp
operator|->
name|d_size
argument_list|,
name|dp
operator|->
name|d_size
argument_list|,
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|odp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdp
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|4
argument_list|,
literal|"credibility for %s is %d(%d)(sec %d) from [%s].%d, is %d(%d)(sec %d) in cache"
argument_list|,
operator|*
name|name
condition|?
name|name
else|:
literal|"."
argument_list|,
name|newdp
operator|->
name|d_cred
argument_list|,
name|newdp
operator|->
name|d_clev
argument_list|,
name|newdp
operator|->
name|d_secure
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|from
operator|.
name|sin_port
argument_list|)
argument_list|,
name|dp
operator|->
name|d_cred
argument_list|,
name|dp
operator|->
name|d_secure
argument_list|,
name|dp
operator|->
name|d_clev
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|newdp
operator|->
name|d_secure
operator|>
name|dp
operator|->
name|d_secure
operator|)
operator|||
operator|(
name|newdp
operator|->
name|d_secure
operator|==
name|dp
operator|->
name|d_secure
operator|&&
operator|(
name|newdp
operator|->
name|d_cred
operator|>
name|dp
operator|->
name|d_cred
operator|)
operator|)
condition|)
block|{
comment|/* better credibility / security. 					 * remove the old datum. 					 */
goto|goto
name|delete
goto|;
block|}
if|if
condition|(
operator|(
name|newdp
operator|->
name|d_secure
operator|<
name|dp
operator|->
name|d_secure
operator|)
operator|||
operator|(
name|newdp
operator|->
name|d_secure
operator|==
name|dp
operator|->
name|d_secure
operator|&&
operator|(
name|newdp
operator|->
name|d_cred
operator|<
name|dp
operator|->
name|d_cred
operator|)
operator|)
condition|)
block|{
comment|/* credibility / security is worse. 					 * ignore it. 					 */
return|return
operator|(
name|AUTH
operator|)
return|;
block|}
comment|/* BEW/OG: from above, we know the security 				 * levels are the same. 				 */
if|if
condition|(
name|newdp
operator|->
name|d_cred
operator|==
name|DB_C_ZONE
operator|&&
name|dp
operator|->
name|d_cred
operator|==
name|DB_C_ZONE
condition|)
block|{
comment|/* Both records are from a zone file. 					 * If their credibility levels differ, 					 * we're dealing with a zone cut.  The 					 * record with lower clev is from the 					 * upper zone's file and is therefore  					 * glue. 					 */
comment|/* XXX - Tricky situation here is you 					 * have 2 zones a.b.c and sub.a.b.c 					 * being served by the same server. 					 * named will send NS records for 					 * sub.a.b.c during zone transfer of 					 * a.b.c zone.  If we're slave for 					 * both zones, and we reload zone 					 * a.b.c, we'll get the NS records 					 * (and possibly A records to go with 					 * them?) for sub.a.b.c as part of the 					 * a.b.c zone transfer.  But we've 					 * already got a more credible record 					 * from the sub.a.b.c zone.  So we want 					 * to ignore the new record, but we 					 * shouldn't syslog because there's 					 * nothing the user can do to prevent 					 * the situation.  Perhaps we should 					 * only complain when we are primary? 	 				 */
if|if
condition|(
name|newdp
operator|->
name|d_clev
operator|<
name|dp
operator|->
name|d_clev
condition|)
block|{
if|if
condition|(
operator|!
name|ISVALIDGLUE
argument_list|(
name|newdp
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"domain %s %s record in zone %s should be in zone %s, ignored"
argument_list|,
name|name
argument_list|,
name|p_type
argument_list|(
name|newdp
operator|->
name|d_type
argument_list|)
argument_list|,
name|zones
index|[
name|newdp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|,
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|AUTH
operator|)
return|;
block|}
if|if
condition|(
name|newdp
operator|->
name|d_clev
operator|>
name|dp
operator|->
name|d_clev
condition|)
block|{
if|if
condition|(
operator|!
name|ISVALIDGLUE
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_db
argument_list|,
literal|"domain %s %s record in zone %s should be in zone %s, deleted"
argument_list|,
name|name
argument_list|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
argument_list|,
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|,
name|zones
index|[
name|newdp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|)
expr_stmt|;
block|}
goto|goto
name|delete
goto|;
block|}
block|}
comment|/* credibility is the same. 				 * let it aggregate in the normal way. 				 */
comment|/* 				 * if the new or old RR is -ve, delete old. 				 */
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|||
name|newdp
operator|->
name|d_rcode
condition|)
block|{
comment|/* XXX: how can a zone rr be neg? */
if|if
condition|(
name|dp
operator|->
name|d_cred
operator|!=
name|DB_C_ZONE
condition|)
goto|goto
name|delete
goto|;
else|else
return|return
operator|(
name|DATAEXISTS
operator|)
return|;
block|}
comment|/* 				 *  Some RR types should not be aggregated. 				 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
block|{
ifdef|#
directive|ifdef
name|BIND_UPDATE
name|u_int32_t
name|dp_ser
decl_stmt|,
name|ndp_ser
decl_stmt|;
name|u_char
modifier|*
name|dp_cp
decl_stmt|,
modifier|*
name|ndp_cp
decl_stmt|;
name|dp_cp
operator|=
name|findsoaserial
argument_list|(
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
name|ndp_cp
operator|=
name|findsoaserial
argument_list|(
name|newdp
operator|->
name|d_data
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|dp_ser
argument_list|,
name|dp_cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ndp_ser
argument_list|,
name|ndp_cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|SEQ_GT
argument_list|(
name|ndp_ser
argument_list|,
name|dp_ser
argument_list|)
condition|)
goto|goto
name|delete
goto|;
else|else
return|return
operator|(
name|SERIAL
operator|)
return|;
else|#
directive|else
goto|goto
name|delete
goto|;
endif|#
directive|endif
comment|/*BIND_UPDATE*/
block|}
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_WKS
operator|&&
operator|!
name|memcmp
argument_list|(
name|dp
operator|->
name|d_data
argument_list|,
name|newdp
operator|->
name|d_data
argument_list|,
name|INT32SZ
operator|+
sizeof|sizeof
argument_list|(
name|u_char
argument_list|)
argument_list|)
condition|)
goto|goto
name|delete
goto|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
operator|&&
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_MULTIPLE_CNAMES
argument_list|)
operator|&&
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|odp
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|DB_REPLACE
operator|)
operator|==
literal|0
operator|&&
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_PRIMARY
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s has multiple CNAMES"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|CNAMEANDOTHER
operator|)
return|;
block|}
else|else
goto|goto
name|delete
goto|;
block|}
if|#
directive|if
literal|0
comment|/* BEW - this _seriously_ breaks DNSSEC.  Is it necessary for dynamic update? */
ifdef|#
directive|ifdef
name|BIND_UPDATE
block|if (dp->d_type == T_SIG)
comment|/*  					 * Type covered has already been 					 * checked. 					 */
block|goto delete;
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NXT
condition|)
block|{
goto|goto
name|delete
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_SIG
operator|&&
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|T_NXT
condition|)
block|{
name|struct
name|sig_record
modifier|*
name|sr1
decl_stmt|,
modifier|*
name|sr2
decl_stmt|;
name|sr1
operator|=
operator|(
expr|struct
name|sig_record
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|sr2
operator|=
operator|(
expr|struct
name|sig_record
operator|*
operator|)
name|newdp
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
name|sr1
operator|->
name|sig_alg_n
operator|==
name|sr2
operator|->
name|sig_alg_n
condition|)
goto|goto
name|delete
goto|;
block|}
if|if
condition|(
name|check_ttl
condition|)
block|{
if|if
condition|(
name|newdp
operator|->
name|d_ttl
operator|!=
name|dp
operator|->
name|d_ttl
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"%s %s %s differing ttls: corrected"
argument_list|,
name|name
index|[
literal|0
index|]
condition|?
name|name
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|dp
operator|->
name|d_class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdp
operator|->
name|d_ttl
operator|>
name|dp
operator|->
name|d_ttl
condition|)
block|{
name|newdp
operator|->
name|d_ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|d_ttl
operator|=
name|newdp
operator|->
name|d_ttl
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DB_NODATA
operator|)
operator|&&
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|odp
argument_list|)
condition|)
block|{
comment|/* Refresh ttl if cache entry. */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
condition|)
block|{
if|if
condition|(
name|odp
operator|->
name|d_zone
operator|!=
name|DB_Z_CACHE
condition|)
block|{
comment|/* Changing cache->auth. */
name|dp
operator|->
name|d_zone
operator|=
name|odp
operator|->
name|d_zone
expr_stmt|;
name|dp
operator|->
name|d_ttl
operator|=
name|odp
operator|->
name|d_ttl
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|4
argument_list|,
literal|"db_update: cache entry now in auth zone"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DATAEXISTS
operator|)
return|;
block|}
name|fixttl
argument_list|(
name|odp
argument_list|)
expr_stmt|;
if|if
condition|(
name|odp
operator|->
name|d_ttl
operator|>
name|dp
operator|->
name|d_ttl
condition|)
name|dp
operator|->
name|d_ttl
operator|=
name|odp
operator|->
name|d_ttl
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|3
argument_list|,
literal|"db_update: new ttl %u +%lu"
argument_list|,
name|dp
operator|->
name|d_ttl
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|DATAEXISTS
operator|)
return|;
block|}
comment|/* 			 * If the old databuf has some data, check that the 			 * data matches that in the new databuf. 			 */
if|if
condition|(
name|odp
operator|->
name|d_size
operator|>
literal|0
condition|)
if|if
condition|(
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|odp
argument_list|)
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|odp
operator|->
name|d_clev
operator|<
name|dp
operator|->
name|d_clev
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
operator|(
name|odp
operator|->
name|d_secure
operator|<
name|dp
operator|->
name|d_secure
operator|)
operator|||
operator|(
operator|(
name|odp
operator|->
name|d_secure
operator|==
name|dp
operator|->
name|d_secure
operator|)
operator|&&
operator|(
name|odp
operator|->
name|d_cred
operator|<
name|dp
operator|->
name|d_cred
operator|)
operator|)
condition|)
goto|goto
name|skip
goto|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|ns_samename
argument_list|(
name|name
argument_list|,
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|)
operator|==
literal|1
operator|&&
name|newdp
operator|==
name|NULL
condition|)
block|{
comment|/* do not delete SOA or NS records as a set */
comment|/* XXXRTH isn't testing d_size unnecessary? */
if|if
condition|(
operator|(
name|odp
operator|->
name|d_size
operator|==
literal|0
operator|)
operator|&&
operator|(
name|odp
operator|->
name|d_class
operator|==
name|C_ANY
operator|)
operator|&&
operator|(
name|odp
operator|->
name|d_type
operator|==
name|T_ANY
operator|||
name|odp
operator|->
name|d_type
operator|==
name|T_SOA
operator|||
name|odp
operator|->
name|d_type
operator|==
name|T_NS
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|||
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|)
condition|)
goto|goto
name|skip
goto|;
comment|/* XXXRTH I added this to prevent SOA deletion 				   I'm using the same style of comparison as 				   the other code in this section.  Do we 				   really need to look at dp->d_type here? 				   We're in the "match" section... */
if|if
condition|(
operator|(
name|odp
operator|->
name|d_type
operator|==
name|T_SOA
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
operator|)
condition|)
goto|goto
name|skip
goto|;
comment|/* do not delete the last NS record 				   for the zone */
if|if
condition|(
operator|(
name|odp
operator|->
name|d_type
operator|==
name|T_NS
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|)
condition|)
block|{
name|found_other_ns
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|tmpdp
operator|=
name|np
operator|->
name|n_data
init|;
name|tmpdp
operator|&&
operator|!
name|found_other_ns
condition|;
name|tmpdp
operator|=
name|tmpdp
operator|->
name|d_next
control|)
if|if
condition|(
operator|(
name|tmpdp
operator|->
name|d_type
operator|==
name|T_NS
operator|)
operator|&&
operator|(
name|tmpdp
operator|!=
name|dp
operator|)
condition|)
name|found_other_ns
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|found_other_ns
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|3
argument_list|,
literal|"cannot delete last remaining NS record for zone %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
goto|goto
name|skip
goto|;
block|}
block|}
block|}
endif|#
directive|endif
name|foundRR
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|DB_DELETE
condition|)
block|{
name|delete
label|:
ifdef|#
directive|ifdef
name|BIND_UPDATE
comment|/* 			 * XXX	assume here that savedpp!=NULL iff. db_update 			 *	has been called by the dyanmic update code. 			 *	Maybe a new flag is more appropriate? 			 */
if|if
condition|(
name|savedpp
operator|!=
name|NULL
condition|)
name|foundRR
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|deleted_something
operator|=
literal|1
expr_stmt|;
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|savedpp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|skip
label|:
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|foundRR
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|DB_DELETE
condition|)
return|return
operator|(
name|NODATA
operator|)
return|;
if|if
condition|(
name|flags
operator|&
name|DB_MEXIST
condition|)
return|return
operator|(
name|NODATA
operator|)
return|;
block|}
block|}
if|if
condition|(
name|newdp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|deleted_something
condition|)
block|{
while|while
condition|(
name|np
operator|->
name|n_data
operator|==
name|NULL
operator|&&
name|np
operator|->
name|n_hash
operator|==
name|NULL
condition|)
block|{
name|np
operator|=
name|purge_node
argument_list|(
name|htp
argument_list|,
name|np
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
break|break;
block|}
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
comment|/* XXX:	empty nodes bypass credibility checks above; should check 	 *	response source address here if flags&NOTAUTH. 	 */
name|fixttl
argument_list|(
name|newdp
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_db
argument_list|,
literal|3
argument_list|,
literal|"db_update: adding%s %#x"
argument_list|,
operator|(
name|newdp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|?
literal|" hint"
else|:
literal|""
argument_list|,
name|newdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|&&
operator|(
name|newdp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|==
literal|0
condition|)
name|newdp
operator|->
name|d_addr
operator|=
name|from
operator|.
name|sin_addr
expr_stmt|;
comment|/* Add to end of list, generally preserving order */
name|newdp
operator|->
name|d_next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|np
operator|->
name|n_data
operator|)
operator|==
name|NULL
condition|)
block|{
name|DRCNTINC
argument_list|(
name|newdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdp
operator|->
name|d_flags
operator|&
name|DB_F_ACTIVE
condition|)
name|panic
argument_list|(
literal|"db_update: DB_F_ACTIVE set"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newdp
operator|->
name|d_flags
operator||=
name|DB_F_ACTIVE
expr_stmt|;
name|np
operator|->
name|n_data
operator|=
name|newdp
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
while|while
condition|(
name|dp
operator|->
name|d_next
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|DB_NODATA
operator|)
operator|&&
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|newdp
argument_list|)
condition|)
return|return
operator|(
name|DATAEXISTS
operator|)
return|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|flags
operator|&
name|DB_NODATA
operator|)
operator|&&
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|newdp
argument_list|)
condition|)
return|return
operator|(
name|DATAEXISTS
operator|)
return|;
name|DRCNTINC
argument_list|(
name|newdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|newdp
operator|->
name|d_flags
operator|&
name|DB_F_ACTIVE
condition|)
name|panic
argument_list|(
literal|"db_update: DB_F_ACTIVE set"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|newdp
operator|->
name|d_flags
operator||=
name|DB_F_ACTIVE
expr_stmt|;
name|dp
operator|->
name|d_next
operator|=
name|newdp
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fixttl
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|&&
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|<=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
condition|)
return|return;
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
operator|+
name|min_cache_ttl
condition|)
name|dp
operator|->
name|d_ttl
operator|=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
operator|+
name|min_cache_ttl
expr_stmt|;
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|>
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
operator|+
name|max_cache_ttl
condition|)
name|dp
operator|->
name|d_ttl
operator|=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
operator|+
name|max_cache_ttl
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare type, class and data from databufs for equivalence.  * All domain names in RR's must be compared case-insensitively.  * Return 0 if equivalent, nonzero otherwise.  */
end_comment

begin_function
name|int
name|db_cmp
parameter_list|(
specifier|const
name|struct
name|databuf
modifier|*
name|dp1
parameter_list|,
specifier|const
name|struct
name|databuf
modifier|*
name|dp2
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|len
decl_stmt|,
name|len2
decl_stmt|;
comment|/* XXXDYNUP- should be changed to  	   if (!match(dp1, dp2->d_type, dp2->d_class) */
if|if
condition|(
name|dp1
operator|->
name|d_type
operator|!=
name|dp2
operator|->
name|d_type
operator|||
name|dp1
operator|->
name|d_class
operator|!=
name|dp2
operator|->
name|d_class
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* XXXDYNUP - should be changed to (dp1->d_size != dp2->d_size&& 	   dp1->d_size != 0&& dp2->d_size != 0) */
if|if
condition|(
name|dp1
operator|->
name|d_size
operator|!=
name|dp2
operator|->
name|d_size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* d_mark is only used for dynamic updates currently */
ifndef|#
directive|ifndef
name|BIND_UPDATE
if|if
condition|(
name|dp1
operator|->
name|d_mark
operator|!=
name|dp2
operator|->
name|d_mark
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* old and new RR's are distinct */
endif|#
directive|endif
if|if
condition|(
name|dp1
operator|->
name|d_rcode
operator|&&
name|dp2
operator|->
name|d_rcode
condition|)
return|return
operator|(
operator|(
name|dp1
operator|->
name|d_rcode
operator|==
name|dp1
operator|->
name|d_rcode
operator|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
if|if
condition|(
name|dp1
operator|->
name|d_rcode
operator|||
name|dp2
operator|->
name|d_rcode
condition|)
return|return
operator|(
literal|1
operator|)
return|;
switch|switch
condition|(
name|dp1
operator|->
name|d_type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_NULL
case|:
case|case
name|T_NSAP
case|:
case|case
name|T_AAAA
case|:
case|case
name|T_LOC
case|:
case|case
name|T_KEY
case|:
comment|/* Only binary data */
return|return
operator|(
name|memcmp
argument_list|(
name|dp1
operator|->
name|d_data
argument_list|,
name|dp2
operator|->
name|d_data
argument_list|,
name|dp1
operator|->
name|d_size
argument_list|)
operator|)
return|;
case|case
name|T_NS
case|:
case|case
name|T_CNAME
case|:
case|case
name|T_PTR
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
comment|/* Only a domain name */
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp1
operator|->
name|d_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp2
operator|->
name|d_data
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_SIG
case|:
comment|/* Binary data, a domain name, more binary data */
if|if
condition|(
name|dp1
operator|->
name|d_size
operator|<
name|NS_SIG_SIGNER
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|memcmp
argument_list|(
name|dp1
operator|->
name|d_data
argument_list|,
name|dp2
operator|->
name|d_data
argument_list|,
name|NS_SIG_SIGNER
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|len
operator|=
name|NS_SIG_SIGNER
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp1
operator|->
name|d_data
operator|+
name|NS_SIG_SIGNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp1
operator|->
name|d_data
operator|+
name|NS_SIG_SIGNER
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp2
operator|->
name|d_data
operator|+
name|NS_SIG_SIGNER
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|memcmp
argument_list|(
name|dp1
operator|->
name|d_data
operator|+
name|len
argument_list|,
name|dp2
operator|->
name|d_data
operator|+
name|len
argument_list|,
name|dp1
operator|->
name|d_size
operator|-
name|len
argument_list|)
operator|)
return|;
case|case
name|T_NXT
case|:
comment|/* First a domain name, then binary data */
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp1
operator|->
name|d_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp2
operator|->
name|d_data
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|len
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp1
operator|->
name|d_data
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|memcmp
argument_list|(
name|dp1
operator|->
name|d_data
operator|+
name|len
argument_list|,
name|dp2
operator|->
name|d_data
operator|+
name|len
argument_list|,
name|dp1
operator|->
name|d_size
operator|-
name|len
argument_list|)
operator|)
return|;
case|case
name|T_HINFO
case|:
case|case
name|T_ISDN
case|:
name|cp1
operator|=
name|dp1
operator|->
name|d_data
expr_stmt|;
name|cp2
operator|=
name|dp2
operator|->
name|d_data
expr_stmt|;
name|len
operator|=
operator|*
name|cp1
expr_stmt|;
name|len2
operator|=
operator|*
name|cp2
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|len2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|++
name|cp1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|++
name|cp2
argument_list|,
name|len
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cp1
operator|+=
name|len
expr_stmt|;
name|cp2
operator|+=
name|len
expr_stmt|;
name|len
operator|=
operator|*
name|cp1
expr_stmt|;
name|len2
operator|=
operator|*
name|cp2
expr_stmt|;
if|if
condition|(
name|len
operator|!=
name|len2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|strncasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|++
name|cp1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|++
name|cp2
argument_list|,
name|len
argument_list|)
operator|)
return|;
case|case
name|T_SOA
case|:
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp1
operator|->
name|d_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp2
operator|->
name|d_data
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cp1
operator|=
name|dp1
operator|->
name|d_data
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp1
operator|->
name|d_data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp2
operator|=
name|dp2
operator|->
name|d_data
operator|+
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp2
operator|->
name|d_data
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp2
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|dp1
operator|->
name|d_type
operator|!=
name|T_SOA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp2
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp2
argument_list|)
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|memcmp
argument_list|(
name|cp1
argument_list|,
name|cp2
argument_list|,
name|INT32SZ
operator|*
literal|5
argument_list|)
operator|)
return|;
case|case
name|T_NAPTR
case|:
block|{
name|int
name|t1
decl_stmt|,
name|t2
decl_stmt|;
if|if
condition|(
name|dp1
operator|->
name|d_size
operator|!=
name|dp2
operator|->
name|d_size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cp1
operator|=
name|dp1
operator|->
name|d_data
expr_stmt|;
name|cp2
operator|=
name|dp2
operator|->
name|d_data
expr_stmt|;
comment|/* Order */
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
operator|||
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Preference */
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
operator|||
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Flags */
name|t1
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|t2
operator|=
operator|*
name|cp2
operator|++
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
operator|||
name|memcmp
argument_list|(
name|cp1
argument_list|,
name|cp2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cp1
operator|+=
name|t1
expr_stmt|;
name|cp2
operator|+=
name|t2
expr_stmt|;
comment|/* Services */
name|t1
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|t2
operator|=
operator|*
name|cp2
operator|++
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
operator|||
name|memcmp
argument_list|(
name|cp1
argument_list|,
name|cp2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cp1
operator|+=
name|t1
expr_stmt|;
name|cp2
operator|+=
name|t2
expr_stmt|;
comment|/* Regexp */
name|t1
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|t2
operator|=
operator|*
name|cp2
operator|++
expr_stmt|;
if|if
condition|(
name|t1
operator|!=
name|t2
operator|||
name|memcmp
argument_list|(
name|cp1
argument_list|,
name|cp2
argument_list|,
name|t1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cp1
operator|+=
name|t1
expr_stmt|;
name|cp2
operator|+=
name|t2
expr_stmt|;
comment|/* Replacement */
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp2
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* they all checked out! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
name|cp1
operator|=
name|dp1
operator|->
name|d_data
expr_stmt|;
name|cp2
operator|=
name|dp2
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
operator|||
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
condition|)
comment|/* cmp prio */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|dp1
operator|->
name|d_type
operator|==
name|T_SRV
condition|)
block|{
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
operator|||
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
condition|)
comment|/* weight */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
operator|||
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
condition|)
comment|/* port */
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp2
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|T_PX
case|:
name|cp1
operator|=
name|dp1
operator|->
name|d_data
expr_stmt|;
name|cp2
operator|=
name|dp2
operator|->
name|d_data
expr_stmt|;
if|if
condition|(
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
operator|||
operator|*
name|cp1
operator|++
operator|!=
operator|*
name|cp2
operator|++
condition|)
comment|/* cmp prio */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp2
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp2
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp2
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp2
argument_list|)
operator|!=
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
if|if
condition|(
name|dp1
operator|->
name|d_size
operator|!=
name|dp2
operator|->
name|d_size
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
name|memcmp
argument_list|(
name|dp1
operator|->
name|d_data
argument_list|,
name|dp2
operator|->
name|d_data
argument_list|,
name|dp1
operator|->
name|d_size
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
end_function

end_unit

