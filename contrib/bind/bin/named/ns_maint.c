begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_maint.c	4.39 (Berkeley) 3/2/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_maint.c,v 8.122 2001/03/01 06:26:31 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1988  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1999 by Check Point Software Technologies, Inc.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Check Point Software Technologies Incorporated not be used   * in advertising or publicity pertaining to distribution of the document   * or software without specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND CHECK POINT SOFTWARE TECHNOLOGIES   * INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,   * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.     * IN NO EVENT SHALL CHECK POINT SOFTWARE TECHNOLOGIES INCORPRATED  * BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR   * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|<isc/misc.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|nxfers
argument_list|(
expr|struct
name|zoneinfo
operator|*
argument_list|)
decl_stmt|,
name|bottom_of_zone
argument_list|(
expr|struct
name|databuf
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|startxfer
argument_list|(
expr|struct
name|zoneinfo
operator|*
argument_list|)
decl_stmt|,
name|abortxfer
argument_list|(
expr|struct
name|zoneinfo
operator|*
argument_list|)
decl_stmt|,
name|tryxfer
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|purge_z_2
argument_list|(
expr|struct
name|hashbuf
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|purge_nonglue_2
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|struct
name|hashbuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SPAWNXFER
end_ifndef

begin_function_decl
specifier|static
name|pid_t
name|spawnxfer
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|zoneinfo
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* State of all running zone transfers */
end_comment

begin_struct
specifier|static
struct|struct
block|{
name|pid_t
name|xfer_pid
decl_stmt|;
name|int
name|xfer_state
decl_stmt|;
comment|/* see below */
name|WAIT_T
name|xfer_status
decl_stmt|;
name|struct
name|in_addr
name|xfer_addr
decl_stmt|;
block|}
name|xferstatus
index|[
name|MAX_XFERS_RUNNING
index|]
struct|;
end_struct

begin_define
define|#
directive|define
name|XFER_IDLE
value|0
end_define

begin_define
define|#
directive|define
name|XFER_RUNNING
value|1
end_define

begin_define
define|#
directive|define
name|XFER_DONE
value|2
end_define

begin_comment
comment|/*  * Perform routine zone maintenance.  */
end_comment

begin_function
name|void
name|zone_maint
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_maint
argument_list|,
literal|1
argument_list|,
literal|"zone_maint('%s'); now %lu"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
name|printzoneinfo
argument_list|(
operator|(
name|zp
operator|-
name|zones
operator|)
argument_list|,
name|ns_log_maint
argument_list|,
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_SECONDARY
case|:
comment|/*FALLTHROUGH*/
ifdef|#
directive|ifdef
name|STUBS
case|case
name|Z_STUB
case|:
endif|#
directive|endif
if|if
condition|(
name|zp
operator|->
name|z_serial
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|zp
operator|->
name|z_lastupdate
operator|+
name|zp
operator|->
name|z_expire
operator|)
operator|<
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NOTIFY
operator|)
operator|!=
literal|0
condition|)
name|ns_stopnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
comment|/* calls purge_zone */
name|do_reload
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_type
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* reset zone state */
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|zp
argument_list|,
operator|(
name|u_long
operator|)
name|stale
argument_list|)
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"%s zone \"%s\" expired"
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
operator|->
name|z_type
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_EXPIRED
expr_stmt|;
name|zp
operator|->
name|z_refresh
operator|=
name|INIT_REFRESH
expr_stmt|;
name|zp
operator|->
name|z_retry
operator|=
name|INIT_REFRESH
expr_stmt|;
name|zp
operator|->
name|z_serial
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_NEED_RELOAD
operator||
name|Z_NEED_XFER
operator||
name|Z_QSERIAL
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ns_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_XFER_RUNNING
condition|)
block|{
name|abortxfer
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 			 * Check again in 30 seconds in case the first 			 * abort doesn't work. 			 */
if|if
condition|(
name|zp
operator|->
name|z_time
operator|!=
literal|0
operator|&&
name|zp
operator|->
name|z_time
operator|<=
name|tt
operator|.
name|tv_sec
condition|)
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|30
expr_stmt|;
break|break;
block|}
comment|/* 		 * If we don't have the zone loaded or dialup is off  		 * or we attempted a qserial_query before and the queue was 		 * full attempt to verify / load the zone. 		 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_serial
operator|==
literal|0
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_QSERIAL
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_dialup
operator|==
name|zdialup_no
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_dialup
operator|==
name|zdialup_use_default
operator|&&
name|NS_OPTION_P
argument_list|(
name|OPTION_NODIALUP
argument_list|)
operator|)
condition|)
name|qserial_query
argument_list|(
name|zp
argument_list|)
expr_stmt|;
else|else
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"Suppressed qserial_query(%s)"
argument_list|,
operator|*
operator|(
name|zp
operator|->
name|z_origin
operator|)
condition|?
name|zp
operator|->
name|z_origin
else|:
literal|"."
argument_list|)
expr_stmt|;
name|ns_refreshtime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|BIND_UPDATE
case|case
name|Z_PRIMARY
case|:
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|tt
operator|.
name|tv_sec
operator|>=
name|zp
operator|->
name|z_soaincrtime
operator|&&
name|zp
operator|->
name|z_soaincrintvl
operator|>
literal|0
operator|&&
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
condition|)
block|{
if|if
condition|(
name|incr_serial
argument_list|(
name|zp
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Try again later. */
name|ns_error
argument_list|(
name|ns_log_maint
argument_list|,
literal|"error updating serial number for %s from %d"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_soaincrtime
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|schedule_soa_update
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tt
operator|.
name|tv_sec
operator|>=
name|zp
operator|->
name|z_dumptime
operator|&&
name|zp
operator|->
name|z_dumpintvl
operator|>
literal|0
operator|&&
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_DUMP
condition|)
block|{
if|if
condition|(
name|zonedump
argument_list|(
name|zp
argument_list|,
name|ISNOTIXFR
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Try again later. */
name|ns_error
argument_list|(
name|ns_log_maint
argument_list|,
literal|"zone dump for '%s' failed, rescheduling"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_dumptime
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|schedule_dump
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zp
operator|->
name|z_maintain_ixfr_base
condition|)
name|ixfr_log_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* BIND_UPDATE */
default|default:
break|break;
block|}
comment|/* 	 * It is essential that we never try to set a timer in the past 	 * or for now because doing so could cause an infinite loop. 	 */
name|INSIST
argument_list|(
name|zp
operator|->
name|z_time
operator|==
literal|0
operator|||
name|zp
operator|->
name|z_time
operator|>
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|do_zone_maint
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
block|{
name|ztimer_info
name|zti
init|=
name|uap
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|INSIST
argument_list|(
name|zti
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_maint
argument_list|,
literal|1
argument_list|,
literal|"do_zone_maint for zone %s (class %s)"
argument_list|,
name|zti
operator|->
name|name
argument_list|,
name|p_class
argument_list|(
name|zti
operator|->
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|=
name|find_zone
argument_list|(
name|zti
operator|->
name|name
argument_list|,
name|zti
operator|->
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_maint
argument_list|,
literal|"do_zone_maint: %s zone '%s' (class %s) is not authoritative"
argument_list|,
name|zoneTypeString
argument_list|(
name|zti
operator|->
name|type
argument_list|)
argument_list|,
name|zti
operator|->
name|name
argument_list|,
name|p_class
argument_list|(
name|zti
operator|->
name|class
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|zti
operator|->
name|type
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_maint
argument_list|,
literal|"do_zone_maint: %s zone '%s' (class %s) has changed its type"
argument_list|,
name|zoneTypeString
argument_list|(
name|zti
operator|->
name|type
argument_list|)
argument_list|,
name|zti
operator|->
name|name
argument_list|,
name|p_class
argument_list|(
name|zti
operator|->
name|class
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|free_zone_timerinfo
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_TIMER_SET
expr_stmt|;
name|zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Figure out the next maintenance time for the zone and set a timer.  */
end_comment

begin_function
name|void
name|sched_zone_maint
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|time_t
name|next_maint
init|=
operator|(
name|time_t
operator|)
literal|0
decl_stmt|;
name|ztimer_info
name|zti
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_time
operator|!=
literal|0
condition|)
name|next_maint
operator|=
name|zp
operator|->
name|z_time
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|&&
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_soaincrintvl
operator|>
literal|0
operator|&&
operator|(
name|next_maint
operator|==
literal|0
operator|||
name|next_maint
operator|>
name|zp
operator|->
name|z_soaincrtime
operator|)
condition|)
name|next_maint
operator|=
name|zp
operator|->
name|z_soaincrtime
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_dumpintvl
operator|>
literal|0
operator|&&
operator|(
name|next_maint
operator|==
literal|0
operator|||
name|next_maint
operator|>
name|zp
operator|->
name|z_dumptime
operator|)
condition|)
name|next_maint
operator|=
name|zp
operator|->
name|z_dumptime
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|next_maint
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|next_maint
operator|<
name|tt
operator|.
name|tv_sec
condition|)
name|next_maint
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_TIMER_SET
condition|)
block|{
if|if
condition|(
name|next_maint
operator|==
name|zp
operator|->
name|z_nextmaint
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_maint
argument_list|,
literal|1
argument_list|,
literal|"no schedule change for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|evResetTimer
argument_list|(
name|ev
argument_list|,
name|zp
operator|->
name|z_timer
argument_list|,
name|do_zone_maint
argument_list|,
name|zp
operator|->
name|z_timerinfo
argument_list|,
name|evConsTime
argument_list|(
name|next_maint
argument_list|,
literal|0
argument_list|)
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_maint
argument_list|,
literal|"evChangeTimer failed in sched_zone_maint for zone '%s': %s"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
else|else
block|{
name|zti
operator|=
operator|(
name|ztimer_info
operator|)
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|zti
argument_list|)
expr_stmt|;
if|if
condition|(
name|zti
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_maint
argument_list|,
literal|1
argument_list|,
literal|"memget failed in sched_zone_maint"
argument_list|)
expr_stmt|;
name|zti
operator|->
name|name
operator|=
name|savestr
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|zti
operator|->
name|class
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
name|zti
operator|->
name|type
operator|=
name|zp
operator|->
name|z_type
expr_stmt|;
if|if
condition|(
name|evSetTimer
argument_list|(
name|ev
argument_list|,
name|do_zone_maint
argument_list|,
name|zti
argument_list|,
name|evConsTime
argument_list|(
name|next_maint
argument_list|,
literal|0
argument_list|)
argument_list|,
name|evConsTime
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|zp
operator|->
name|z_timer
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_maint
argument_list|,
literal|"evSetTimer failed in sched_zone_maint for zone '%s': %s"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|zp
operator|->
name|z_flags
operator||=
name|Z_TIMER_SET
expr_stmt|;
name|zp
operator|->
name|z_timerinfo
operator|=
name|zti
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_maint
argument_list|,
literal|1
argument_list|,
literal|"next maintenance for zone '%s' in %lu sec"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|next_maint
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_TIMER_SET
condition|)
block|{
name|free_zone_timerinfo
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|evClearTimer
argument_list|(
name|ev
argument_list|,
name|zp
operator|->
name|z_timer
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_maint
argument_list|,
literal|"evClearTimer failed in sched_zone_maint for zone '%s': %s"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_TIMER_SET
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_maint
argument_list|,
literal|1
argument_list|,
literal|"no scheduled maintenance for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_nextmaint
operator|=
name|next_maint
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_cleancache
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
block|{
name|int
name|deleted
decl_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|uap
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|deleted
operator|=
name|clean_cache
argument_list|(
name|hashtab
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_maint
argument_list|,
literal|"Cleaned cache of %d RRset%s"
argument_list|,
name|deleted
argument_list|,
operator|(
name|deleted
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ns_heartbeat
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|uap
operator|==
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|zones
init|;
name|zp
operator|<
operator|&
name|zones
index|[
name|nzones
index|]
condition|;
name|zp
operator|++
control|)
block|{
name|enum
name|zonetype
name|zt
init|=
name|zp
operator|->
name|z_type
decl_stmt|;
if|if
condition|(
operator|(
name|zt
operator|==
name|z_nil
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_dialup
operator|==
name|zdialup_no
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_dialup
operator|==
name|zdialup_use_default
operator|&&
name|NS_OPTION_P
argument_list|(
name|OPTION_NODIALUP
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* 		 * Perform the refresh query that was suppressed. 		 */
if|if
condition|(
operator|(
name|zt
operator|==
name|z_slave
operator|||
name|zt
operator|==
name|z_stub
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_NEED_RELOAD
operator||
name|Z_NEED_XFER
operator||
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
operator|)
operator|==
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"Heartbeat: qserial \"%s\""
argument_list|,
operator|*
operator|(
name|zp
operator|->
name|z_origin
operator|)
condition|?
name|zp
operator|->
name|z_origin
else|:
literal|"."
argument_list|)
expr_stmt|;
name|qserial_query
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* 		 * Trigger a refresh query while the link is up by 		 * sending a notify. 		 */
if|if
condition|(
operator|(
operator|(
name|zp
operator|->
name|z_notify
operator|==
name|znotify_yes
operator|)
operator|||
operator|(
operator|(
name|zp
operator|->
name|z_notify
operator|==
name|znotify_use_default
operator|)
operator|&&
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NONOTIFY
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|zt
operator|==
name|z_master
operator|||
name|zt
operator|==
name|z_slave
operator|)
operator|&&
operator|!
name|loading
operator|&&
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|!=
literal|0
operator|)
condition|)
name|ns_notify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|ns_t_soa
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/*  * Mark a zone "up to date" after named-xfer tells us this or we  * discover it through the qserial_*() logic.  * The caller is responsible for calling sched_zone_maint(zp).  */
end_comment

begin_function
specifier|static
name|void
name|markUpToDate
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|struct
name|stat
name|f_time
decl_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_SYSLOGGED
expr_stmt|;
name|zp
operator|->
name|z_lastupdate
operator|=
name|tt
operator|.
name|tv_sec
expr_stmt|;
name|ns_refreshtime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
comment|/* 	 * Restore Z_AUTH in case expired, 	 * but only if there were no errors 	 * in the zone file. 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DB_BAD
operator|)
operator|==
literal|0
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_AUTH
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_EXPIRED
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_source
condition|)
block|{
name|struct
name|timeval
name|t
index|[
literal|2
index|]
decl_stmt|;
name|t
index|[
literal|0
index|]
operator|=
name|tt
expr_stmt|;
name|t
index|[
literal|1
index|]
operator|=
name|tt
expr_stmt|;
operator|(
name|void
operator|)
name|utimes
argument_list|(
name|zp
operator|->
name|z_source
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
comment|/* we use "stat" to set zp->z_ftime instead of just 	   setting it to tt.tv_sec in order to avoid any 	   possible rounding problems in utimes(). */
if|if
condition|(
name|stat
argument_list|(
name|zp
operator|->
name|z_source
argument_list|,
operator|&
name|f_time
argument_list|)
operator|!=
operator|-
literal|1
condition|)
name|zp
operator|->
name|z_ftime
operator|=
name|f_time
operator|.
name|st_mtime
expr_stmt|;
comment|/* XXX log if stat fails? */
block|}
end_function

begin_function
name|void
name|qserial_retrytime
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|time_t
name|timebase
parameter_list|)
block|{
name|zp
operator|->
name|z_time
operator|=
name|timebase
operator|+
literal|5
operator|+
operator|(
name|rand
argument_list|()
operator|%
literal|25
operator|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Query for the serial number of a zone, so that we can check to see if  * we need to transfer it.  If there are too many outstanding serial  * number queries, we'll try again later.  * The caller is responsible for calling sched_zone_maint(zp).  */
end_comment

begin_function
name|void
name|qserial_query
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"qserial_query(%s)"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|qserials_running
operator|>=
name|server_options
operator|->
name|serial_queries
condition|)
block|{
name|qserial_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_NEED_QSERIAL
expr_stmt|;
return|return;
block|}
name|qp
operator|=
name|sysquery
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|T_SOA
argument_list|,
name|zp
operator|->
name|z_addr
argument_list|,
name|zp
operator|->
name|z_addrcnt
argument_list|,
name|ntohs
argument_list|(
name|zp
operator|->
name|z_port
argument_list|)
condition|?
name|zp
operator|->
name|z_port
else|:
name|ns_port
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|==
name|NULL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"qserial_query(%s): sysquery FAILED"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
comment|/* XXX - this is bad, we should do something */
name|qserial_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_NEED_QSERIAL
expr_stmt|;
return|return;
block|}
name|qp
operator|->
name|q_flags
operator||=
name|Q_ZSERIAL
expr_stmt|;
name|qp
operator|->
name|q_zquery
operator|=
name|zp
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_QSERIAL
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_NEED_QSERIAL
expr_stmt|;
name|zp
operator|->
name|z_xaddrcnt
operator|=
literal|0
expr_stmt|;
name|ns_refreshtime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|qserials_running
operator|++
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"qserial_query(%s) QUEUED"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|qserv_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|struct
name|qserv
modifier|*
name|qs1
init|=
name|a
decl_stmt|,
modifier|*
name|qs2
init|=
name|b
decl_stmt|;
name|u_int32_t
name|s1
init|=
name|qs1
operator|->
name|serial
decl_stmt|,
name|s2
init|=
name|qs2
operator|->
name|serial
decl_stmt|;
comment|/* Note that we sort the "best" serial numbers to the front. */
if|if
condition|(
name|s1
operator|==
name|s2
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|s1
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|s2
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|SEQ_GT
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|assert
argument_list|(
name|SEQ_GT
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|qserial_answer
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
name|qp
operator|->
name|q_zquery
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|serial
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|cnt
init|=
literal|0
decl_stmt|;
comment|/* Take this query out of the global quotas. */
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_QSERIAL
expr_stmt|;
name|qp
operator|->
name|q_flags
operator|&=
operator|~
name|Q_ZSERIAL
expr_stmt|;
comment|/* keeps us from being called twice */
name|qserials_running
operator|--
expr_stmt|;
comment|/* Find best serial among those returned. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"qserial_answer(%s): [%s] -> %lu"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|qs
operator|->
name|serial
argument_list|)
expr_stmt|;
comment|/* Don't consider serials which weren't set by a response. */
if|if
condition|(
name|qs
operator|->
name|serial
operator|==
literal|0
condition|)
continue|continue;
comment|/* Count valid answers. */
name|cnt
operator|++
expr_stmt|;
comment|/* Remove from consideration serials which aren't "better." */
if|if
condition|(
name|zp
operator|->
name|z_serial
operator|!=
literal|0
operator|&&
operator|!
name|SEQ_GT
argument_list|(
name|qs
operator|->
name|serial
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
condition|)
block|{
if|if
condition|(
name|serial
operator|==
literal|0
operator|&&
name|qs
operator|->
name|serial
operator|==
name|zp
operator|->
name|z_serial
condition|)
name|serial
operator|=
name|qs
operator|->
name|serial
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|serial
operator|!=
name|zp
operator|->
name|z_serial
condition|)
name|ns_notice
argument_list|(
name|ns_log_xfer_in
argument_list|,
literal|"Zone \"%s\" (%s) SOA serial# (%lu) rcvd from [%s] is< ours (%lu)%s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|qs
operator|->
name|serial
argument_list|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_serial
argument_list|,
name|qp
operator|->
name|q_naddr
operator|!=
literal|1
condition|?
literal|": skipping"
else|:
literal|""
argument_list|)
expr_stmt|;
name|qs
operator|->
name|serial
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|serial
operator|==
literal|0
operator|||
name|SEQ_GT
argument_list|(
name|qs
operator|->
name|serial
argument_list|,
name|serial
argument_list|)
condition|)
name|serial
operator|=
name|qs
operator|->
name|serial
expr_stmt|;
block|}
comment|/* If we have an existing serial number, then sort by "better." */
if|if
condition|(
name|zp
operator|->
name|z_serial
operator|!=
literal|0
condition|)
block|{
name|qsort
argument_list|(
name|qp
operator|->
name|q_addr
argument_list|,
name|qp
operator|->
name|q_naddr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|qserv
argument_list|)
argument_list|,
name|qserv_compare
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"qserial_answer after sort: [%s] -> %lu"
argument_list|,
name|inet_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|qs
operator|->
name|serial
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now see about kicking off an inbound transfer. */
if|if
condition|(
name|serial
operator|==
literal|0
condition|)
block|{
comment|/* An error occurred, or the all queries timed out. */
if|if
condition|(
name|qp
operator|->
name|q_naddr
operator|!=
name|cnt
condition|)
name|ns_info
argument_list|(
name|ns_log_xfer_in
argument_list|,
literal|"Err/TO getting serial# for \"%s\""
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|addxfer
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_serial
operator|==
literal|0
operator|||
name|SEQ_GT
argument_list|(
name|serial
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_xfer_in
argument_list|,
literal|1
argument_list|,
literal|"qserial_answer: zone is out of date"
argument_list|)
expr_stmt|;
comment|/* Use all servers whose serials are better than ours. */
name|zp
operator|->
name|z_xaddrcnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
block|{
name|qs
operator|=
operator|&
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
expr_stmt|;
if|if
condition|(
name|qs
operator|->
name|serial
operator|!=
literal|0
condition|)
name|zp
operator|->
name|z_xaddr
index|[
name|zp
operator|->
name|z_xaddrcnt
operator|++
index|]
operator|=
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
expr_stmt|;
block|}
name|addxfer
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_serial
operator|==
name|serial
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_xfer_in
argument_list|,
literal|1
argument_list|,
literal|"qserial_answer: zone serial is still OK"
argument_list|)
expr_stmt|;
name|markUpToDate
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Writes TSIG key info for an address to a file, optionally opening it first.  * Returns:  *	-1:	Error.  *	 0:	No action taken.  *	 1:	Tsig info successfully written.  */
end_comment

begin_function
specifier|static
name|int
name|write_tsig_info
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|fd
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
name|DST_KEY
modifier|*
name|dst_key
decl_stmt|;
name|int
name|tsig_fd
init|=
operator|*
name|fd
decl_stmt|;
name|char
name|tsig_str
index|[
literal|1024
index|]
decl_stmt|,
name|secret_buf64
index|[
literal|172
index|]
decl_stmt|;
name|u_char
name|secret_buf
index|[
literal|128
index|]
decl_stmt|;
name|int
name|secret_len
decl_stmt|,
name|len
decl_stmt|;
name|si
operator|=
name|find_server
argument_list|(
name|addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|==
name|NULL
operator|||
name|si
operator|->
name|key_list
operator|==
name|NULL
operator|||
name|si
operator|->
name|key_list
operator|->
name|first
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dst_key
operator|=
name|si
operator|->
name|key_list
operator|->
name|first
operator|->
name|key
expr_stmt|;
if|if
condition|(
name|tsig_fd
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|fd
operator|=
name|tsig_fd
operator|=
name|mkstemp
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsig_fd
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"write_tsig_info: mkstemp(%s) for TSIG info failed"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|tsig_fd
argument_list|,
name|user_id
argument_list|,
name|group_id
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
name|secret_buf
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|secret_buf
argument_list|)
argument_list|)
expr_stmt|;
name|secret_len
operator|=
name|dst_key_to_buffer
argument_list|(
name|dst_key
argument_list|,
name|secret_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|secret_buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|secret_len
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|len
operator|=
name|b64_ntop
argument_list|(
name|secret_buf
argument_list|,
name|secret_len
argument_list|,
name|secret_buf64
argument_list|,
sizeof|sizeof
argument_list|(
name|secret_buf64
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* We need snprintf! */
if|if
condition|(
name|strlen
argument_list|(
name|dst_key
operator|->
name|dk_key_name
argument_list|)
operator|+
name|len
operator|+
sizeof|sizeof
argument_list|(
literal|"XXX.XXX.XXX.XXX"
argument_list|)
operator|,
sizeof|sizeof
argument_list|(
literal|"123"
argument_list|)
operator|+
literal|5
operator|>
sizeof|sizeof
argument_list|(
name|tsig_str
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|sprintf
argument_list|(
name|tsig_str
argument_list|,
literal|"%s\n%s\n%d\n%s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|addr
argument_list|)
argument_list|,
name|dst_key
operator|->
name|dk_key_name
argument_list|,
name|dst_key
operator|->
name|dk_alg
argument_list|,
name|secret_buf64
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|tsig_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|tsig_fd
argument_list|,
name|tsig_str
argument_list|,
name|strlen
argument_list|(
name|tsig_str
argument_list|)
argument_list|)
operator|!=
name|len
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns number of tsigs written or -1.  */
end_comment

begin_function
specifier|static
name|int
name|write_tsigs
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|char
modifier|*
name|tsig_name
parameter_list|)
block|{
name|struct
name|in_addr
name|a
decl_stmt|;
name|int
name|tsig_ret
decl_stmt|;
name|int
name|tsig_fd
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|int
name|records
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_xaddrcnt
condition|;
name|cnt
operator|++
control|)
block|{
name|a
operator|=
name|zp
operator|->
name|z_xaddr
index|[
name|cnt
index|]
expr_stmt|;
if|if
condition|(
name|aIsUs
argument_list|(
name|a
argument_list|)
operator|&&
name|ns_port
operator|==
name|zp
operator|->
name|z_port
condition|)
continue|continue;
name|tsig_ret
operator|=
name|write_tsig_info
argument_list|(
name|a
argument_list|,
name|tsig_name
argument_list|,
operator|&
name|tsig_fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tsig_ret
condition|)
block|{
case|case
operator|-
literal|1
case|:
goto|goto
name|error
goto|;
case|case
literal|0
case|:
break|break;
case|case
literal|1
case|:
name|records
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|tsig_fd
operator|!=
operator|-
literal|1
condition|)
name|close
argument_list|(
name|tsig_fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|records
operator|)
return|;
name|error
label|:
if|if
condition|(
name|tsig_fd
operator|!=
operator|-
literal|1
condition|)
block|{
name|unlink
argument_list|(
name|tsig_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tsig_fd
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BIND_IXFR
end_ifdef

begin_function
specifier|static
name|int
name|supports_ixfr
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|int
name|cnt
init|=
literal|0
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_xaddrcnt
condition|;
name|cnt
operator|++
control|)
block|{
name|struct
name|in_addr
name|a
decl_stmt|;
name|server_info
name|si
decl_stmt|;
name|a
operator|=
name|zp
operator|->
name|z_xaddr
index|[
name|cnt
index|]
expr_stmt|;
if|if
condition|(
name|aIsUs
argument_list|(
name|a
argument_list|)
operator|&&
name|ns_port
operator|==
name|zp
operator|->
name|z_port
condition|)
continue|continue;
name|si
operator|=
name|find_server
argument_list|(
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|!=
name|NULL
operator|&&
operator|(
name|si
operator|->
name|flags
operator|&
name|SERVER_INFO_SUPPORT_IXFR
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Start an asynchronous zone transfer for a zone.  Depends on current time  * being in tt.  Caller must do a sched_zone_maint(zp) after we return.  */
end_comment

begin_function
specifier|static
name|void
name|startxfer
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|char
modifier|*
name|argv
index|[
name|NSMAX
operator|*
literal|2
operator|+
literal|20
index|]
decl_stmt|,
name|argv_ns
index|[
name|NSMAX
index|]
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|argc
init|=
literal|0
decl_stmt|,
name|argc_ns
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
name|char
name|debug_str
index|[
literal|10
index|]
decl_stmt|;
name|char
name|serial_str
index|[
literal|10
index|]
decl_stmt|;
name|char
name|port_str
index|[
literal|10
index|]
decl_stmt|;
name|char
name|class_str
index|[
literal|10
index|]
decl_stmt|;
name|char
name|src_str
index|[
literal|20
index|]
decl_stmt|;
name|char
name|tsig_name
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|tsig_ret
init|=
literal|0
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"startxfer() %s"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|zp
operator|->
name|z_origin
else|:
literal|"."
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|server_options
operator|->
name|named_xfer
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-z"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|zp
operator|->
name|z_origin
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-f"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|zp
operator|->
name|z_source
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_IXFR
if|if
condition|(
name|supports_ixfr
argument_list|(
name|zp
argument_list|)
operator|&&
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-i"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|zp
operator|->
name|z_ixfr_tmp
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|zp
operator|->
name|z_serial
operator|!=
literal|0
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-s"
expr_stmt|;
name|sprintf
argument_list|(
name|serial_str
argument_list|,
literal|"%u"
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|serial_str
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_axfr_src
operator|.
name|s_addr
operator|!=
literal|0
operator|||
name|server_options
operator|->
name|axfr_src
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-x"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|strcpy
argument_list|(
name|src_str
argument_list|,
name|inet_ntoa
argument_list|(
operator|(
name|zp
operator|->
name|z_axfr_src
operator|.
name|s_addr
operator|!=
literal|0
operator|)
condition|?
name|zp
operator|->
name|z_axfr_src
else|:
name|server_options
operator|->
name|axfr_src
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-C"
expr_stmt|;
name|sprintf
argument_list|(
name|class_str
argument_list|,
literal|"%d"
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|class_str
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_SYSLOGGED
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-q"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-P"
expr_stmt|;
name|sprintf
argument_list|(
name|port_str
argument_list|,
literal|"%d"
argument_list|,
name|ntohs
argument_list|(
name|zp
operator|->
name|z_port
argument_list|)
operator|!=
literal|0
condition|?
name|zp
operator|->
name|z_port
else|:
name|ns_port
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|port_str
expr_stmt|;
ifdef|#
directive|ifdef
name|STUBS
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-S"
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-d"
expr_stmt|;
name|sprintf
argument_list|(
name|debug_str
argument_list|,
literal|"%d"
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|debug_str
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-l"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|_PATH_XFERDDT
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|5
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-t"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|_PATH_XFERTRACE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|zp
operator|->
name|z_xaddrcnt
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|zp
operator|->
name|z_xaddrcnt
operator|=
literal|0
init|;
name|zp
operator|->
name|z_xaddrcnt
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|zp
operator|->
name|z_xaddrcnt
operator|++
control|)
name|zp
operator|->
name|z_xaddr
index|[
name|zp
operator|->
name|z_xaddrcnt
index|]
operator|=
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_xaddrcnt
index|]
expr_stmt|;
block|}
comment|/* 	 * Store TSIG keys if we have them. 	 */
name|strcpy
argument_list|(
name|tsig_name
argument_list|,
literal|"tsigs.XXXXXX"
argument_list|)
expr_stmt|;
name|tsig_ret
operator|=
name|write_tsigs
argument_list|(
name|zp
argument_list|,
name|tsig_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsig_ret
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_xfer_in
argument_list|,
literal|"unable to write tsig info: '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|tsig_ret
operator|!=
literal|0
condition|)
block|{
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"-T"
expr_stmt|;
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|tsig_name
expr_stmt|;
block|}
comment|/* 	 * Copy the server ip addresses into argv, after converting 	 * to ascii and saving the static inet_ntoa result. 	 * Also, send TSIG key info into a file for the child. 	 */
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_xaddrcnt
condition|;
name|cnt
operator|++
control|)
block|{
name|struct
name|in_addr
name|a
decl_stmt|;
name|a
operator|=
name|zp
operator|->
name|z_xaddr
index|[
name|cnt
index|]
expr_stmt|;
if|if
condition|(
name|aIsUs
argument_list|(
name|a
argument_list|)
operator|&&
name|ns_port
operator|==
name|zp
operator|->
name|z_port
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
operator|(
name|u_long
operator|)
name|zp
argument_list|,
operator|(
name|u_long
operator|)
name|startxfer
argument_list|)
condition|)
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"attempted to fetch zone %s from self (%s)"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|inet_ntoa
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|argv
index|[
name|argc
operator|++
index|]
operator|=
name|strcpy
argument_list|(
name|argv_ns
index|[
name|argc_ns
operator|++
index|]
argument_list|,
name|inet_ntoa
argument_list|(
name|a
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_IXFR
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
condition|)
block|{
name|server_info
name|si
init|=
name|find_server
argument_list|(
name|a
argument_list|)
decl_stmt|;
if|if
condition|(
name|si
operator|!=
name|NULL
operator|&&
operator|(
name|si
operator|->
name|flags
operator|&
name|SERVER_INFO_SUPPORT_IXFR
operator|)
operator|!=
literal|0
condition|)
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"ixfr"
expr_stmt|;
else|else
name|argv
index|[
name|argc
operator|++
index|]
operator|=
literal|"axfr"
expr_stmt|;
block|}
endif|#
directive|endif
block|}
name|argv
index|[
name|argc
index|]
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|1
condition|)
block|{
name|char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|char
modifier|*
name|curr
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|int
name|len
decl_stmt|;
name|curr
operator|=
name|buffer
expr_stmt|;
name|last
operator|=
operator|&
name|buffer
index|[
sizeof|sizeof
name|buffer
operator|-
literal|1
index|]
expr_stmt|;
comment|/* leave room for \0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|curr
operator|+
name|len
operator|+
literal|1
operator|>=
name|last
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_xfer_in
argument_list|,
literal|1
argument_list|,
literal|"xfer args debug printout truncated"
argument_list|)
expr_stmt|;
break|break;
block|}
name|strncpy
argument_list|(
name|curr
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|curr
operator|+=
name|len
expr_stmt|;
operator|*
name|curr
operator|=
literal|' '
expr_stmt|;
name|curr
operator|++
expr_stmt|;
block|}
operator|*
name|curr
operator|=
literal|'\0'
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_xfer_in
argument_list|,
literal|1
argument_list|,
name|buffer
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_XFERS_RUNNING
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_pid
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|MAX_XFERS_RUNNING
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"startxfer: too many xfers running"
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|10
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|pid
operator|=
name|spawnxfer
argument_list|(
name|argv
argument_list|,
name|zp
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|unlink
argument_list|(
name|tsig_name
argument_list|)
expr_stmt|;
return|return;
block|}
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_state
operator|=
name|XFER_RUNNING
expr_stmt|;
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_pid
operator|=
name|pid
expr_stmt|;
comment|/* XXX - small race condition here if we 					* can't hold signals */
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_addr
operator|=
name|zp
operator|->
name|z_xaddr
index|[
literal|0
index|]
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"started xfer child %d"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_NEED_XFER
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_XFER_RUNNING
expr_stmt|;
name|zp
operator|->
name|z_xferpid
operator|=
name|pid
expr_stmt|;
name|xfers_running
operator|++
expr_stmt|;
name|xfers_deferred
operator|--
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_max_transfer_time_in
condition|)
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|zp
operator|->
name|z_max_transfer_time_in
expr_stmt|;
else|else
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|server_options
operator|->
name|max_transfer_time_in
expr_stmt|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|zoneTypeString
parameter_list|(
name|u_int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|ret
index|[
sizeof|sizeof
expr|"(4294967296?)"]
expr_stmt|;
comment|/* 2^32 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|Z_MASTER
case|:
return|return
operator|(
literal|"master"
operator|)
return|;
case|case
name|Z_SLAVE
case|:
return|return
operator|(
literal|"slave"
operator|)
return|;
ifdef|#
directive|ifdef
name|STUBS
case|case
name|Z_STUB
case|:
return|return
operator|(
literal|"stub"
operator|)
return|;
endif|#
directive|endif
case|case
name|Z_HINT
case|:
return|return
operator|(
literal|"hint"
operator|)
return|;
case|case
name|Z_CACHE
case|:
return|return
operator|(
literal|"cache"
operator|)
return|;
case|case
name|Z_FORWARD
case|:
return|return
operator|(
literal|"forward"
operator|)
return|;
default|default:
name|sprintf
argument_list|(
name|ret
argument_list|,
literal|"(%u?)"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_function
name|void
name|printzoneinfo
parameter_list|(
name|int
name|zonenum
parameter_list|,
name|int
name|category
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|struct
name|timeval
name|tt
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|zonenum
index|]
decl_stmt|;
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_origin
condition|)
return|return;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"zone %d: %s, class %s, type %s"
argument_list|,
name|zonenum
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
condition|?
name|zp
operator|->
name|z_origin
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
operator|->
name|z_type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_source
condition|)
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tsource %s"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tflags %lx, serial %u, minimum %u"
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_flags
argument_list|,
name|zp
operator|->
name|z_serial
argument_list|,
name|zp
operator|->
name|z_minimum
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\trefresh %u, retry %u, expire %u"
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|,
name|zp
operator|->
name|z_retry
argument_list|,
name|zp
operator|->
name|z_expire
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_time
condition|)
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tz_time %lu (now %lu, left: %lu)"
argument_list|,
name|zp
operator|->
name|z_time
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|zp
operator|->
name|z_time
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tz_time %lu"
argument_list|,
name|zp
operator|->
name|z_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|&&
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tdumpintvl %lu, soaincrintvl %lu deferupdcnt %lu"
argument_list|,
name|zp
operator|->
name|z_dumpintvl
argument_list|,
name|zp
operator|->
name|z_soaincrintvl
argument_list|,
name|zp
operator|->
name|z_deferupdcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_soaincrtime
condition|)
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tz_soaincrtime %lu (now %lu, left: %lu)"
argument_list|,
name|zp
operator|->
name|z_soaincrtime
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|zp
operator|->
name|z_soaincrtime
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tz_soaincrtime %lu"
argument_list|,
name|zp
operator|->
name|z_soaincrtime
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_dumptime
condition|)
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tz_dumptime %lu (now %lu, left: %lu)"
argument_list|,
name|zp
operator|->
name|z_dumptime
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|zp
operator|->
name|z_dumptime
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_debug
argument_list|(
name|category
argument_list|,
name|level
argument_list|,
literal|"\tz_dumptime %lu"
argument_list|,
name|zp
operator|->
name|z_dumptime
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DEBUG */
end_comment

begin_comment
comment|/*  * Remove all cached data below dname, class independent.  */
end_comment

begin_function
name|void
name|clean_cache_from
parameter_list|(
name|char
modifier|*
name|dname
parameter_list|,
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|phtp
init|=
name|htp
decl_stmt|;
name|int
name|root_zone
init|=
literal|0
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"clean_cache_from(%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|phtp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|dname
operator|==
name|fname
operator|&&
operator|!
name|ns_wildcard
argument_list|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|pdp
operator|=
name|NULL
operator|,
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
operator|(
name|void
operator|)
name|NULL
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
condition|)
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|dname
operator|==
literal|'\0'
condition|)
name|root_zone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_hash
operator|!=
name|NULL
operator|||
name|root_zone
condition|)
block|{
name|struct
name|hashbuf
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|root_zone
condition|)
name|h
operator|=
name|htp
expr_stmt|;
else|else
name|h
operator|=
name|np
operator|->
name|n_hash
expr_stmt|;
operator|(
name|void
operator|)
name|clean_cache
argument_list|(
name|h
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_cnt
operator|==
literal|0
operator|&&
operator|!
name|root_zone
condition|)
block|{
name|rm_hash
argument_list|(
name|np
operator|->
name|n_hash
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_hash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|root_zone
operator|&&
name|np
operator|->
name|n_hash
operator|==
name|NULL
operator|&&
name|np
operator|->
name|n_data
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|purge_node
argument_list|(
name|htp
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* clean_cache(htp, all)  *	Scan the entire cache looking for expired TTL's on nonauthoritative  *	data, and remove it.  if `all' is true, ignore TTL and rm everything.  * notes:  *	this should be lazy and eventlib driven.  * return:  *	number of deleted RRs (all=1) or RRsets (all=0).  */
end_comment

begin_function
name|int
name|clean_cache
parameter_list|(
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|pnp
decl_stmt|,
modifier|*
name|npn
decl_stmt|;
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|,
modifier|*
modifier|*
name|nppend
decl_stmt|;
name|int
name|deleted
init|=
literal|0
decl_stmt|;
name|nppend
operator|=
name|htp
operator|->
name|h_tab
operator|+
name|htp
operator|->
name|h_size
expr_stmt|;
for|for
control|(
name|npp
operator|=
name|htp
operator|->
name|h_tab
init|;
name|npp
operator|<
name|nppend
condition|;
name|npp
operator|++
control|)
block|{
for|for
control|(
name|pnp
operator|=
name|NULL
operator|,
name|np
operator|=
operator|*
name|npp
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|npn
control|)
block|{
name|again
label|:
for|for
control|(
name|pdp
operator|=
name|NULL
operator|,
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
operator|(
name|void
operator|)
name|NULL
control|)
block|{
if|if
condition|(
name|all
operator|&&
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
condition|)
block|{
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|&&
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|delete_all
argument_list|(
name|np
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|dp
operator|->
name|d_type
argument_list|)
expr_stmt|;
name|deleted
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
else|else
block|{
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
comment|/*for(pdp)*/
if|if
condition|(
name|np
operator|->
name|n_hash
condition|)
block|{
comment|/* Call recursively to remove subdomains. */
name|deleted
operator|+=
name|clean_cache
argument_list|(
name|np
operator|->
name|n_hash
argument_list|,
name|all
argument_list|)
expr_stmt|;
comment|/* If now empty, free it */
if|if
condition|(
name|np
operator|->
name|n_hash
operator|->
name|h_cnt
operator|==
literal|0
condition|)
block|{
name|rm_hash
argument_list|(
name|np
operator|->
name|n_hash
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_hash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_hash
operator|==
name|NULL
operator|&&
name|np
operator|->
name|n_data
operator|==
name|NULL
condition|)
block|{
name|npn
operator|=
name|rm_name
argument_list|(
name|np
argument_list|,
name|npp
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
name|htp
operator|->
name|h_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|npn
operator|=
name|np
operator|->
name|n_next
expr_stmt|;
name|pnp
operator|=
name|np
expr_stmt|;
block|}
block|}
comment|/*for(pnp)*/
block|}
comment|/*for(npp)*/
return|return
operator|(
name|deleted
operator|)
return|;
block|}
end_function

begin_comment
comment|/* struct namebuf *  * purge_node(htp, np)  *	Remove entry from cache.  * Prerequisites:  *	Node is empty and has no children.  * Paramters:  *	htp - root of recursive hash table this node is part of.  *	np - the node to be deleted.  * Return:  *	pointer to parent.  */
end_comment

begin_function
name|struct
name|namebuf
modifier|*
name|purge_node
parameter_list|(
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|,
name|struct
name|namebuf
modifier|*
name|np
parameter_list|)
block|{
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|,
modifier|*
modifier|*
name|nppend
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|npn
decl_stmt|,
modifier|*
name|pnp
decl_stmt|,
modifier|*
name|nnp
decl_stmt|,
modifier|*
name|parent
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|phtp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"purge_node: cleaning cache"
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|np
operator|->
name|n_hash
operator|==
name|NULL
operator|&&
name|np
operator|->
name|n_data
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Walk parent hashtable looking for ourself. */
name|parent
operator|=
name|np
operator|->
name|n_parent
expr_stmt|;
if|if
condition|(
name|parent
operator|!=
name|NULL
condition|)
name|phtp
operator|=
name|parent
operator|->
name|n_hash
expr_stmt|;
else|else
name|phtp
operator|=
name|htp
expr_stmt|;
if|if
condition|(
name|phtp
operator|==
name|NULL
condition|)
block|{
comment|/* XXX why shouldn't we panic? */
block|}
else|else
block|{
name|nppend
operator|=
name|phtp
operator|->
name|h_tab
operator|+
name|phtp
operator|->
name|h_size
expr_stmt|;
for|for
control|(
name|npp
operator|=
name|phtp
operator|->
name|h_tab
init|;
name|npp
operator|<
name|nppend
condition|;
name|npp
operator|++
control|)
block|{
for|for
control|(
name|pnp
operator|=
name|NULL
operator|,
name|nnp
operator|=
operator|*
name|npp
init|;
name|nnp
operator|!=
name|NULL
condition|;
name|nnp
operator|=
name|npn
control|)
block|{
if|if
condition|(
name|nnp
operator|==
name|np
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"purge_node: found ourself"
argument_list|)
expr_stmt|;
name|npn
operator|=
name|rm_name
argument_list|(
name|nnp
argument_list|,
name|npp
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
name|phtp
operator|->
name|h_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|npn
operator|=
name|nnp
operator|->
name|n_next
expr_stmt|;
name|pnp
operator|=
name|nnp
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
operator|(
name|parent
operator|)
return|;
block|}
end_function

begin_function
name|void
name|remove_zone
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
specifier|const
name|char
modifier|*
name|verb
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIND_UPDATE
comment|/* 	 * A dynamic zone might have changed, so we 	 * need to dump it before removing it. 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_DUMP
operator|)
operator|!=
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|zonedump
argument_list|(
name|zp
argument_list|,
name|ISNOTIXFR
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NOTIFY
operator|)
operator|!=
literal|0
condition|)
name|ns_stopnotify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_XFER
operator|)
operator|!=
literal|0
condition|)
block|{
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_NEED_XFER
expr_stmt|;
name|xfers_deferred
operator|--
expr_stmt|;
block|}
name|ns_stopxfrs
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|do_reload
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_type
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_config
argument_list|,
literal|"%s zone \"%s\" (%s) %s"
argument_list|,
name|zoneTypeString
argument_list|(
name|zp
operator|->
name|z_type
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|,
name|verb
argument_list|)
expr_stmt|;
name|free_zone_contents
argument_list|(
name|zp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_type
operator|=
name|z_nil
expr_stmt|;
comment|/* Pedantic; memset() did it. */
name|INIT_LINK
argument_list|(
name|zp
argument_list|,
name|z_reloadlink
argument_list|)
expr_stmt|;
name|INIT_LINK
argument_list|(
name|zp
argument_list|,
name|z_freelink
argument_list|)
expr_stmt|;
name|free_zone
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|purge_nonglue
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|log
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|phtp
init|=
name|htp
decl_stmt|;
name|int
name|root_zone
init|=
literal|0
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"purge_zone(%s,%d)"
argument_list|,
name|dname
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|phtp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|dname
operator|==
name|fname
operator|&&
operator|!
name|ns_wildcard
argument_list|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|dname
operator|==
literal|'\0'
condition|)
name|root_zone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_hash
operator|!=
name|NULL
operator|||
name|root_zone
condition|)
block|{
name|struct
name|hashbuf
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|root_zone
condition|)
name|h
operator|=
name|htp
expr_stmt|;
else|else
name|h
operator|=
name|np
operator|->
name|n_hash
expr_stmt|;
name|errs
operator|+=
name|purge_nonglue_2
argument_list|(
name|dname
argument_list|,
name|h
argument_list|,
name|class
argument_list|,
literal|0
argument_list|,
name|log
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_cnt
operator|==
literal|0
operator|&&
operator|!
name|root_zone
condition|)
block|{
name|rm_hash
argument_list|(
name|np
operator|->
name|n_hash
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_hash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|errs
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|valid_glue
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|belowcut
parameter_list|)
block|{
comment|/* NS records are only valid glue at the zone cut */
if|if
condition|(
name|belowcut
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ISVALIDGLUE
argument_list|(
name|dp
argument_list|)
condition|)
comment|/* T_NS/T_A/T_AAAA/T_A6 */
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|belowcut
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Parent NXT record? */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NXT
operator|&&
operator|!
name|ns_samedomain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|name
argument_list|)
operator|&&
name|ns_samedomain
argument_list|(
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|,
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_origin
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* NOKEY is in parent zone otherwise child zone */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_KEY
operator|&&
name|dp
operator|->
name|d_size
operator|==
literal|4
operator|&&
operator|(
name|dp
operator|->
name|d_data
index|[
literal|0
index|]
operator|&
literal|0xc3
operator|)
operator|==
literal|0xc1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* NXT& KEY records may be signed */
if|if
condition|(
operator|!
name|belowcut
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_SIG
operator|&&
operator|(
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|T_NXT
operator|||
name|SIG_COVERS
argument_list|(
name|dp
argument_list|)
operator|==
name|T_KEY
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|purge_nonglue_2
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|belowcut
parameter_list|,
name|int
name|log
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|pnp
decl_stmt|,
modifier|*
name|npn
decl_stmt|;
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|,
modifier|*
modifier|*
name|nppend
decl_stmt|;
name|int
name|errs
init|=
literal|0
decl_stmt|;
name|int
name|zonecut
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|nppend
operator|=
name|htp
operator|->
name|h_tab
operator|+
name|htp
operator|->
name|h_size
expr_stmt|;
for|for
control|(
name|npp
operator|=
name|htp
operator|->
name|h_tab
init|;
name|npp
operator|<
name|nppend
condition|;
name|npp
operator|++
control|)
block|{
for|for
control|(
name|pnp
operator|=
name|NULL
operator|,
name|np
operator|=
operator|*
name|npp
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|npn
control|)
block|{
if|if
condition|(
operator|!
name|bottom_of_zone
argument_list|(
name|np
operator|->
name|n_data
argument_list|,
name|class
argument_list|)
condition|)
block|{
name|zonecut
operator|=
name|belowcut
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|ns_t_ns
argument_list|)
condition|)
block|{
name|zonecut
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|getname
argument_list|(
name|np
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|pdp
operator|=
name|NULL
operator|,
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
operator|(
name|void
operator|)
name|NULL
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_class
operator|==
name|class
operator|&&
name|zonecut
operator|&&
operator|!
name|valid_glue
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|belowcut
argument_list|)
condition|)
block|{
if|if
condition|(
name|log
condition|)
name|ns_error
argument_list|(
name|ns_log_load
argument_list|,
literal|"zone: %s/%s: non-glue record %s bottom of zone: %s/%s"
argument_list|,
operator|*
name|dname
condition|?
name|dname
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|dp
operator|->
name|d_class
argument_list|)
argument_list|,
name|belowcut
condition|?
literal|"below"
else|:
literal|"at"
argument_list|,
operator|*
name|name
condition|?
name|name
else|:
literal|"."
argument_list|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|log
condition|)
name|errs
operator|++
expr_stmt|;
block|}
else|else
block|{
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_hash
condition|)
block|{
comment|/* 					 * call recursively to clean 					 * subdomains 					 */
name|errs
operator|+=
name|purge_nonglue_2
argument_list|(
name|dname
argument_list|,
name|np
operator|->
name|n_hash
argument_list|,
name|class
argument_list|,
name|zonecut
operator|||
name|belowcut
argument_list|,
name|log
argument_list|)
expr_stmt|;
comment|/* if now empty, free it */
if|if
condition|(
name|np
operator|->
name|n_hash
operator|->
name|h_cnt
operator|==
literal|0
condition|)
block|{
name|rm_hash
argument_list|(
name|np
operator|->
name|n_hash
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_hash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_hash
operator|==
name|NULL
operator|&&
name|np
operator|->
name|n_data
operator|==
name|NULL
condition|)
block|{
name|npn
operator|=
name|rm_name
argument_list|(
name|np
argument_list|,
name|npp
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
name|htp
operator|->
name|h_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|npn
operator|=
name|np
operator|->
name|n_next
expr_stmt|;
name|pnp
operator|=
name|np
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|errs
operator|)
return|;
block|}
end_function

begin_function
name|void
name|purge_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|struct
name|hashbuf
modifier|*
name|htp
parameter_list|,
name|int
name|class
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|phtp
init|=
name|htp
decl_stmt|;
name|int
name|root_zone
init|=
literal|0
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"purge_zone(%s,%d)"
argument_list|,
name|dname
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|phtp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
name|dname
operator|==
name|fname
operator|&&
operator|!
name|ns_wildcard
argument_list|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
block|{
for|for
control|(
name|pdp
operator|=
name|NULL
operator|,
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
operator|(
name|void
operator|)
name|NULL
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_class
operator|==
name|class
condition|)
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|dname
operator|==
literal|'\0'
condition|)
name|root_zone
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|n_hash
operator|!=
name|NULL
operator|||
name|root_zone
condition|)
block|{
name|struct
name|hashbuf
modifier|*
name|h
decl_stmt|;
if|if
condition|(
name|root_zone
condition|)
name|h
operator|=
name|htp
expr_stmt|;
else|else
name|h
operator|=
name|np
operator|->
name|n_hash
expr_stmt|;
name|purge_z_2
argument_list|(
name|h
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|h
operator|->
name|h_cnt
operator|==
literal|0
operator|&&
operator|!
name|root_zone
condition|)
block|{
name|rm_hash
argument_list|(
name|np
operator|->
name|n_hash
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_hash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|root_zone
operator|&&
name|np
operator|->
name|n_hash
operator|==
name|NULL
operator|&&
name|np
operator|->
name|n_data
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|purge_node
argument_list|(
name|htp
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|purge_z_2
parameter_list|(
name|htp
parameter_list|,
name|class
parameter_list|)
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|int
name|class
decl_stmt|;
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|pnp
decl_stmt|,
modifier|*
name|npn
decl_stmt|;
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
decl_stmt|,
modifier|*
modifier|*
name|nppend
decl_stmt|;
name|nppend
operator|=
name|htp
operator|->
name|h_tab
operator|+
name|htp
operator|->
name|h_size
expr_stmt|;
for|for
control|(
name|npp
operator|=
name|htp
operator|->
name|h_tab
init|;
name|npp
operator|<
name|nppend
condition|;
name|npp
operator|++
control|)
block|{
for|for
control|(
name|pnp
operator|=
name|NULL
operator|,
name|np
operator|=
operator|*
name|npp
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|npn
control|)
block|{
if|if
condition|(
operator|!
name|bottom_of_zone
argument_list|(
name|np
operator|->
name|n_data
argument_list|,
name|class
argument_list|)
condition|)
block|{
for|for
control|(
name|pdp
operator|=
name|NULL
operator|,
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
operator|(
name|void
operator|)
name|NULL
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_class
operator|==
name|class
condition|)
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
block|{
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_hash
condition|)
block|{
comment|/* call recursively to rm subdomains */
name|purge_z_2
argument_list|(
name|np
operator|->
name|n_hash
argument_list|,
name|class
argument_list|)
expr_stmt|;
comment|/* if now empty, free it */
if|if
condition|(
name|np
operator|->
name|n_hash
operator|->
name|h_cnt
operator|==
literal|0
condition|)
block|{
name|rm_hash
argument_list|(
name|np
operator|->
name|n_hash
argument_list|)
expr_stmt|;
name|np
operator|->
name|n_hash
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|np
operator|->
name|n_hash
operator|==
name|NULL
operator|&&
name|np
operator|->
name|n_data
operator|==
name|NULL
condition|)
block|{
name|npn
operator|=
name|rm_name
argument_list|(
name|np
argument_list|,
name|npp
argument_list|,
name|pnp
argument_list|)
expr_stmt|;
name|htp
operator|->
name|h_cnt
operator|--
expr_stmt|;
block|}
else|else
block|{
name|npn
operator|=
name|np
operator|->
name|n_next
expr_stmt|;
name|pnp
operator|=
name|np
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|bottom_of_zone
parameter_list|(
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|int
name|class
parameter_list|)
block|{
name|int
name|ret
init|=
literal|0
decl_stmt|;
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
comment|/* This should not occur. */
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_SOA
condition|)
continue|continue;
name|ret
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"bottom_of_zone() == %d"
argument_list|,
name|ret
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle XFER limit for a nameserver.  */
end_comment

begin_function
specifier|static
name|int
name|nxfers
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|struct
name|in_addr
name|nsa
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_xaddrcnt
operator|!=
literal|0
condition|)
name|nsa
operator|=
name|zp
operator|->
name|z_xaddr
index|[
literal|0
index|]
expr_stmt|;
comment|/* first ns holds zone's xfer limit */
elseif|else
if|if
condition|(
name|zp
operator|->
name|z_addrcnt
operator|!=
literal|0
condition|)
name|nsa
operator|=
name|zp
operator|->
name|z_addr
index|[
literal|0
index|]
expr_stmt|;
comment|/* first ns holds zone's xfer limit */
else|else
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|ret
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_XFERS_RUNNING
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_status
operator|==
name|XFER_RUNNING
operator|&&
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_addr
operator|.
name|s_addr
operator|==
name|nsa
operator|.
name|s_addr
condition|)
name|ret
operator|++
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Abort an xfer that has taken too long.  */
end_comment

begin_function
specifier|static
name|void
name|abortxfer
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_XFER_GONE
operator||
name|Z_XFER_ABORTED
operator|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_XFERS_RUNNING
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_pid
operator|==
name|zp
operator|->
name|z_xferpid
condition|)
block|{
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_pid
operator|=
literal|0
expr_stmt|;
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_state
operator|=
name|XFER_IDLE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_XFER_GONE
condition|)
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"zone transfer timeout for \"%s\"; pid %lu missing"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_xferpid
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kill
argument_list|(
name|zp
operator|->
name|z_xferpid
argument_list|,
name|SIGKILL
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"zone transfer timeout for \"%s\"; kill pid %lu: %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_xferpid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"zone transfer timeout for \"%s\"; second kill \ pid %lu - forgetting, processes may accumulate"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_xferpid
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_xferpid
operator|=
literal|0
expr_stmt|;
name|xfers_running
operator|--
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
operator|(
name|Z_XFER_RUNNING
operator||
name|Z_XFER_ABORTED
operator||
name|Z_XFER_GONE
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kill
argument_list|(
name|zp
operator|->
name|z_xferpid
argument_list|,
name|SIGTERM
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|ESRCH
condition|)
comment|/* No warning on first time, it may have just exited */
name|zp
operator|->
name|z_flags
operator||=
name|Z_XFER_GONE
expr_stmt|;
else|else
block|{
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"zone transfer timeout for \"%s\"; pid %lu kill failed %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_xferpid
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_XFER_ABORTED
expr_stmt|;
block|}
block|}
else|else
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"zone transfer timeout for \"%s\"; pid %lu killed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_xferpid
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_XFER_ABORTED
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Process exit of xfer's.  */
end_comment

begin_function
name|void
name|reapchild
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|WAIT_T
name|status
decl_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pid
operator|=
operator|(
name|pid_t
operator|)
name|waitpid
argument_list|(
operator|-
literal|1
argument_list|,
operator|&
name|status
argument_list|,
name|WNOHANG
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_XFERS_RUNNING
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_pid
operator|==
name|pid
condition|)
block|{
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_status
operator|=
name|status
expr_stmt|;
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_state
operator|=
name|XFER_DONE
expr_stmt|;
name|ns_need
argument_list|(
name|main_need_endxfer
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Finish processing of of finished xfers  */
end_comment

begin_function
name|void
name|endxfer
parameter_list|()
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|int
name|exitstatus
decl_stmt|,
name|i
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|WAIT_T
name|status
decl_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_XFERS_RUNNING
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_state
operator|!=
name|XFER_DONE
condition|)
continue|continue;
name|pid
operator|=
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_pid
expr_stmt|;
name|status
operator|=
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_status
expr_stmt|;
name|exitstatus
operator|=
name|WIFEXITED
argument_list|(
name|status
argument_list|)
condition|?
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
else|:
literal|0
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|zones
init|;
name|zp
operator|<
operator|&
name|zones
index|[
name|nzones
index|]
condition|;
name|zp
operator|++
control|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_xferpid
operator|!=
name|pid
condition|)
continue|continue;
name|xfers_running
operator|--
expr_stmt|;
name|zp
operator|->
name|z_xferpid
operator|=
literal|0
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
operator|(
name|Z_XFER_RUNNING
operator||
name|Z_XFER_ABORTED
operator||
name|Z_XFER_GONE
operator|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"\nendxfer: child %d zone %s returned status=%d termsig=%d"
argument_list|,
name|pid
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|exitstatus
argument_list|,
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|?
name|WTERMSIG
argument_list|(
name|status
argument_list|)
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|)
block|{
if|if
condition|(
name|WTERMSIG
argument_list|(
name|status
argument_list|)
operator|!=
name|SIGKILL
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"named-xfer \"%s\" exited with signal %d"
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
condition|?
name|zp
operator|->
name|z_origin
else|:
literal|"."
argument_list|,
name|WTERMSIG
argument_list|(
name|status
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ns_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|exitstatus
condition|)
block|{
case|case
name|XFER_UPTODATE
case|:
name|markUpToDate
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFER_SUCCESSAXFR
case|:
case|case
name|XFER_SUCCESSAXFRIXFRFILE
case|:
name|zp
operator|->
name|z_xferpid
operator|=
name|XFER_ISAXFR
expr_stmt|;
if|if
condition|(
name|exitstatus
operator|==
name|XFER_SUCCESSAXFRIXFRFILE
condition|)
block|{
name|zp
operator|->
name|z_xferpid
operator|=
name|XFER_ISAXFRIXFR
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
condition|)
name|isc_movefile
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
comment|/* XXX should incorporate loadxfer() */
name|zp
operator|->
name|z_flags
operator||=
name|Z_NEED_RELOAD
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_SYSLOGGED
expr_stmt|;
name|ns_need
argument_list|(
name|main_need_zoneload
argument_list|)
expr_stmt|;
break|break;
case|case
name|XFER_SUCCESSIXFR
case|:
name|zp
operator|->
name|z_flags
operator||=
name|Z_XFER_RUNNING
expr_stmt|;
name|zp
operator|->
name|z_xferpid
operator|=
name|XFER_ISIXFR
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"IXFR Success %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_logs
argument_list|(
name|zp
argument_list|,
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"IXFR Merge success %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|isc_movefile
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonedump
argument_list|(
name|zp
argument_list|,
name|ISIXFR
argument_list|)
operator|<
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"error in write ixfr updates to zone file %s"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|ns_refreshtime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"IXFR Merge failed %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
name|ns_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|XFER_TIMEOUT
case|:
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_SYSLOGGED
operator|)
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_SYSLOGGED
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"zoneref: Masters for slave zone \"%s\" unreachable"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
name|ns_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_SYSLOGGED
operator|)
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_SYSLOGGED
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"named-xfer for \"%s\" exited %d"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|exitstatus
argument_list|)
expr_stmt|;
block|}
comment|/* FALLTHROUGH */
case|case
name|XFER_FAIL
case|:
name|zp
operator|->
name|z_flags
operator||=
name|Z_SYSLOGGED
expr_stmt|;
name|ns_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_state
operator|=
name|XFER_IDLE
expr_stmt|;
name|xferstatus
index|[
name|i
index|]
operator|.
name|xfer_pid
operator|=
literal|0
expr_stmt|;
block|}
name|tryxfer
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Try to start some xfers - new "fair scheduler" by Bob Halley @DEC (1995)  */
end_comment

begin_function
specifier|static
name|void
name|tryxfer
parameter_list|()
block|{
specifier|static
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|zoneinfo
modifier|*
name|lastzones
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|lastnzones
init|=
literal|0
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|startzp
decl_stmt|,
modifier|*
name|stopzp
decl_stmt|;
comment|/* initialize, and watch out for changes in zones! */
if|if
condition|(
name|lastzones
operator|!=
name|zones
condition|)
block|{
if|if
condition|(
name|lastzones
operator|!=
name|NULL
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"zones changed: %p != %p"
argument_list|,
name|lastzones
argument_list|,
name|zones
argument_list|)
expr_stmt|;
name|lastzones
operator|=
name|zones
expr_stmt|;
name|zp
operator|=
name|zones
expr_stmt|;
block|}
comment|/* did zones shrink? */
if|if
condition|(
name|lastnzones
operator|>
name|nzones
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"zones shrunk"
argument_list|)
expr_stmt|;
name|zp
operator|=
name|zones
expr_stmt|;
block|}
name|lastnzones
operator|=
name|nzones
expr_stmt|;
if|if
condition|(
name|zp
operator|==
name|zones
condition|)
name|stopzp
operator|=
operator|&
name|zones
index|[
name|nzones
operator|-
literal|1
index|]
expr_stmt|;
else|else
name|stopzp
operator|=
name|zp
operator|-
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"tryxfer start zp=%p stopzp=%p def=%d running=%d"
argument_list|,
name|zp
argument_list|,
name|stopzp
argument_list|,
name|xfers_deferred
argument_list|,
name|xfers_running
argument_list|)
expr_stmt|;
name|startzp
operator|=
name|zp
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|xfers
decl_stmt|;
if|if
condition|(
operator|!
name|xfers_deferred
operator|||
name|xfers_running
operator|>=
name|server_options
operator|->
name|transfers_in
condition|)
break|break;
if|if
condition|(
operator|(
name|xfers
operator|=
name|nxfers
argument_list|(
name|zp
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|&&
name|xfers
operator|<
name|server_options
operator|->
name|transfers_per_ns
operator|&&
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_XFER
operator|)
condition|)
block|{
name|startxfer
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|==
name|stopzp
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"tryxfer stop mark"
argument_list|)
expr_stmt|;
name|zp
operator|=
name|startzp
expr_stmt|;
break|break;
block|}
name|zp
operator|++
expr_stmt|;
comment|/* wrap around? */
if|if
condition|(
name|zp
operator|==
operator|&
name|zones
index|[
name|nzones
index|]
condition|)
name|zp
operator|=
name|zones
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"tryxfer stop zp=%p"
argument_list|,
name|zp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reload zones whose transfers have completed.  */
end_comment

begin_function
name|void
name|loadxfer
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|u_int32_t
name|old_serial
decl_stmt|,
name|new_serial
decl_stmt|;
name|char
modifier|*
name|tmpnom
decl_stmt|;
name|int
name|isixfr
decl_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|zones
init|;
name|zp
operator|<
operator|&
name|zones
index|[
name|nzones
index|]
condition|;
name|zp
operator|++
control|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_RELOAD
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"loadxfer() \"%s\""
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
condition|?
name|zp
operator|->
name|z_origin
else|:
literal|"."
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
operator|(
name|Z_NEED_RELOAD
operator||
name|Z_AUTH
operator|)
expr_stmt|;
comment|/* XXX this is bad, should be done in ns_zreload() for primary changes. */
name|ns_stopxfrs
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|old_serial
operator|=
name|zp
operator|->
name|z_serial
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_xferpid
operator|==
name|XFER_ISIXFR
condition|)
block|{
name|tmpnom
operator|=
name|zp
operator|->
name|z_ixfr_tmp
expr_stmt|;
name|isixfr
operator|=
name|ISIXFR
expr_stmt|;
block|}
else|else
block|{
name|tmpnom
operator|=
name|zp
operator|->
name|z_source
expr_stmt|;
name|purge_zone
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|hashtab
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
name|isixfr
operator|=
name|ISNOTIXFR
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_xferpid
operator|==
name|XFER_ISAXFRIXFR
condition|)
block|{
name|tmpnom
operator|=
name|zp
operator|->
name|z_source
expr_stmt|;
name|purge_zone
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|hashtab
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
name|isixfr
operator|=
name|ISNOTIXFR
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|db_load
argument_list|(
name|tmpnom
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
argument_list|,
name|NULL
argument_list|,
name|isixfr
argument_list|)
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_AUTH
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_EXPIRED
expr_stmt|;
if|if
condition|(
name|isixfr
operator|==
name|ISIXFR
condition|)
block|{
name|new_serial
operator|=
name|zp
operator|->
name|z_serial
expr_stmt|;
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"ISIXFR"
argument_list|)
expr_stmt|;
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"error in updating ixfr data base file %s from %s"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|,
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zonedump
argument_list|(
name|zp
argument_list|,
name|ISIXFR
argument_list|)
operator|<
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_db
argument_list|,
literal|"error in write ixfr updates to zone file %s"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
block|}
block|}
name|zp
operator|->
name|z_xferpid
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_TMP_FILE
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add this zone to the set of those needing transfers.  */
end_comment

begin_function
name|void
name|addxfer
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_XFER
operator|)
condition|)
block|{
name|zp
operator|->
name|z_flags
operator||=
name|Z_NEED_XFER
expr_stmt|;
name|xfers_deferred
operator|++
expr_stmt|;
name|tryxfer
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark one zone as requiring a reload.  * Note that it should be called with signals blocked,  * and should not allocate memory (since it can be called from a sighandler).  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|deferred_reload_unsafe
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|INSIST
argument_list|(
name|zp
operator|->
name|z_type
operator|!=
name|z_nil
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zonefile_changed_p
argument_list|(
name|zp
argument_list|)
condition|)
return|return
operator|(
literal|"Zone file has not changed."
operator|)
return|;
if|if
condition|(
name|LINKED
argument_list|(
name|zp
argument_list|,
name|z_reloadlink
argument_list|)
condition|)
return|return
operator|(
literal|"Zone is already scheduled for reloading."
operator|)
return|;
name|APPEND
argument_list|(
name|reloadingzones
argument_list|,
name|zp
argument_list|,
name|z_reloadlink
argument_list|)
expr_stmt|;
name|ns_need_unsafe
argument_list|(
name|main_need_zreload
argument_list|)
expr_stmt|;
return|return
operator|(
literal|"Zone is now scheduled for reloading."
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we've loaded this file, and the file has not been modified and contains  * no $INCLUDE, then there's no need to reload.  */
end_comment

begin_function
name|int
name|zonefile_changed_p
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
name|INSIST
argument_list|(
name|zp
operator|->
name|z_type
operator|!=
name|z_nil
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_INCLUDE
operator|)
operator|!=
literal|0
operator|||
name|stat
argument_list|(
name|zp
operator|->
name|z_source
argument_list|,
operator|&
name|sb
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|zp
operator|->
name|z_ftime
operator|!=
name|sb
operator|.
name|st_mtime
operator|)
return|;
block|}
end_function

begin_function
name|int
name|reload_master
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|INSIST
argument_list|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
name|ns_stopxfrs
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* XXX what about parent zones? */
ifdef|#
directive|ifdef
name|BIND_UPDATE
comment|/* 	 * A dynamic zone might have changed, so we 	 * need to dump it before reloading it. 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|!=
literal|0
operator|&&
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
operator|)
operator|!=
literal|0
operator|||
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_DUMP
operator|)
operator|!=
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|zonedump
argument_list|(
name|zp
argument_list|,
name|ISNOTIXFR
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|purge_zone
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|hashtab
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"reloading zone"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|!=
literal|0
condition|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|zp
operator|->
name|z_source
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"stat(%s) failed: %s"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|(
name|sb
operator|.
name|st_mode
operator|&
operator|(
name|S_IWUSR
operator||
name|S_IWGRP
operator||
name|S_IWOTH
operator|)
operator|)
operator|!=
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"dynamic zone file '%s' is writable"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|db_load
argument_list|(
name|zp
operator|->
name|z_source
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
argument_list|,
name|NULL
argument_list|,
name|ISNOTIXFR
argument_list|)
condition|)
name|zp
operator|->
name|z_flags
operator||=
name|Z_AUTH
expr_stmt|;
name|zp
operator|->
name|z_refresh
operator|=
literal|0
expr_stmt|;
comment|/* no maintenance needed */
name|zp
operator|->
name|z_time
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
name|zp
operator|->
name|z_lastupdate
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|merge_logs
argument_list|(
name|zp
argument_list|,
name|zp
operator|->
name|z_updatelog
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by main() when main_need_zreload has been set.  Should pull one  * zone off of the reloadingzones list and reload it, then if the list is  * not then empty, should turn main_need_zreload on again for the next call.  * It is not an error to call this when the reloadingzones list is empty.  */
end_comment

begin_function
name|void
name|ns_zreload
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|block_signals
argument_list|()
expr_stmt|;
if|if
condition|(
name|EMPTY
argument_list|(
name|reloadingzones
argument_list|)
condition|)
block|{
name|unblock_signals
argument_list|()
expr_stmt|;
return|return;
block|}
name|zp
operator|=
name|HEAD
argument_list|(
name|reloadingzones
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|reloadingzones
argument_list|,
name|zp
argument_list|,
name|z_reloadlink
argument_list|)
expr_stmt|;
name|unblock_signals
argument_list|()
expr_stmt|;
name|reload_master
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|block_signals
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|EMPTY
argument_list|(
name|reloadingzones
argument_list|)
condition|)
name|ns_need_unsafe
argument_list|(
name|main_need_zreload
argument_list|)
expr_stmt|;
name|unblock_signals
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush and reload configuration file and data base.  */
end_comment

begin_function
name|void
name|ns_reload
parameter_list|(
name|void
parameter_list|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"%s %snameserver"
argument_list|,
operator|(
name|reconfiging
operator|!=
literal|0
operator|)
condition|?
literal|"reconfiguring"
else|:
literal|"reloading"
argument_list|,
operator|(
name|noexpired
operator|==
literal|1
operator|)
condition|?
literal|"(-noexpired) "
else|:
literal|""
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|reloading
operator|==
literal|0
argument_list|)
expr_stmt|;
name|qflush
argument_list|()
expr_stmt|;
name|sq_flush
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|reloading
operator|++
expr_stmt|;
comment|/* To force transfer if slave and backing up. */
name|confmtime
operator|=
name|ns_init
argument_list|(
name|conffile
argument_list|)
expr_stmt|;
name|time
argument_list|(
operator|&
name|resettime
argument_list|)
expr_stmt|;
name|reloading
operator|--
expr_stmt|;
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"Ready to answer queries."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reload configuration, look for new or deleted zones, not changed ones  * also ignore expired zones.  */
end_comment

begin_function
name|void
name|ns_noexpired
parameter_list|(
name|void
parameter_list|)
block|{
name|INSIST
argument_list|(
name|noexpired
operator|==
literal|0
argument_list|)
expr_stmt|;
name|noexpired
operator|++
expr_stmt|;
comment|/* To ignore zones which are expired */
name|ns_reconfig
argument_list|()
expr_stmt|;
name|noexpired
operator|--
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reload configuration, look for new or deleted zones, not changed ones.  */
end_comment

begin_function
name|void
name|ns_reconfig
parameter_list|(
name|void
parameter_list|)
block|{
name|INSIST
argument_list|(
name|reconfiging
operator|==
literal|0
argument_list|)
expr_stmt|;
name|reconfiging
operator|++
expr_stmt|;
comment|/* To ignore zones which aren't new or deleted. */
name|ns_reload
argument_list|()
expr_stmt|;
name|reconfiging
operator|--
expr_stmt|;
block|}
end_function

begin_function
name|void
name|make_new_zones
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|newzones
init|=
operator|(
name|nzones
operator|==
literal|0
operator|)
condition|?
name|INITIALZONES
else|:
name|NEWZONES
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"Adding %d template zones"
argument_list|,
name|NEWZONES
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|(
expr|struct
name|zoneinfo
operator|*
operator|)
name|memget
argument_list|(
operator|(
name|nzones
operator|+
name|newzones
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|zoneinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"no memory for more zones"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
operator|(
name|nzones
operator|+
name|newzones
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|zoneinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
operator|!=
name|NULL
condition|)
block|{
name|memcpy
argument_list|(
name|zp
argument_list|,
name|zones
argument_list|,
name|nzones
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|zoneinfo
argument_list|)
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|zones
argument_list|,
name|nzones
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|zoneinfo
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zones
operator|=
name|zp
expr_stmt|;
name|block_signals
argument_list|()
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|newzones
condition|;
name|n
operator|++
control|)
block|{
name|INIT_LINK
argument_list|(
operator|&
name|zones
index|[
name|nzones
index|]
argument_list|,
name|z_reloadlink
argument_list|)
expr_stmt|;
name|INIT_LINK
argument_list|(
operator|&
name|zones
index|[
name|nzones
index|]
argument_list|,
name|z_freelink
argument_list|)
expr_stmt|;
if|if
condition|(
name|nzones
operator|!=
literal|0
condition|)
name|free_zone
argument_list|(
operator|&
name|zones
index|[
name|nzones
index|]
argument_list|)
expr_stmt|;
name|nzones
operator|++
expr_stmt|;
block|}
name|unblock_signals
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_zone
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
if|if
condition|(
name|LINKED
argument_list|(
name|zp
argument_list|,
name|z_reloadlink
argument_list|)
condition|)
name|panic
argument_list|(
literal|"freeing reloading zone"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_nil
condition|)
name|panic
argument_list|(
literal|"freeing unfree zone"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|freezones
argument_list|,
name|zp
argument_list|,
name|z_freelink
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|HAVE_SPAWNXFER
end_ifndef

begin_function
specifier|static
name|pid_t
name|spawnxfer
parameter_list|(
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|pid_t
name|pid
init|=
operator|(
name|pid_t
operator|)
name|vfork
argument_list|()
decl_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"xfer vfork: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|10
expr_stmt|;
return|return
operator|(
name|pid
operator|)
return|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
comment|/* Child. */
name|execv
argument_list|(
name|server_options
operator|->
name|named_xfer
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"can't exec %s: %s"
argument_list|,
name|server_options
operator|->
name|named_xfer
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
comment|/* Avoid duplicate buffer flushes. */
block|}
return|return
operator|(
name|pid
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|struct
name|zoneinfo
modifier|*
name|find_auth_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|zname
parameter_list|,
name|ns_class
name|zclass
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|zn
decl_stmt|;
name|zp
operator|=
name|find_zone
argument_list|(
name|zname
argument_list|,
name|zclass
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|!=
name|NULL
operator|&&
operator|(
name|zp
operator|->
name|z_type
operator|==
name|z_slave
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_stub
operator|)
condition|)
return|return
operator|(
name|zp
operator|)
return|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|zname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|!=
name|NULL
operator|&&
operator|(
name|zn
operator|=
name|findMyZone
argument_list|(
name|np
argument_list|,
name|zclass
argument_list|)
operator|)
operator|!=
name|DB_Z_CACHE
condition|)
return|return
operator|(
operator|&
name|zones
index|[
name|zn
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

