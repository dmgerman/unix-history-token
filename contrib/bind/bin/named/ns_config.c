begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_config.c,v 8.121 2001/02/08 02:05:53 marka Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1996-2000 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1999 by Check Point Software Technologies, Inc.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Check Point Software Technologies Incorporated not be used   * in advertising or publicity pertaining to distribution of the document   * or software without specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND CHECK POINT SOFTWARE TECHNOLOGIES   * INCORPORATED DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,   * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.     * IN NO EVENT SHALL CHECK POINT SOFTWARE TECHNOLOGIES INCORPRATED  * BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR   * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
end_ifdef

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_include
include|#
directive|include
file|"ns_parseutil.h"
end_include

begin_comment
comment|/* Private. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tmpnum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|config_initialized
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|need_logging_free
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_logging_installed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|options_installed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|logging_installed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|default_options_installed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|initial_configuration
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|logging_categories
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|current_pid_filename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZONE_SYM_TABLE_SIZE
value|4973
end_define

begin_decl_stmt
specifier|static
name|symbol_table
name|zone_symbol_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Zones */
end_comment

begin_function
name|void
name|free_zone_timerinfo
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_timerinfo
operator|!=
name|NULL
condition|)
block|{
name|freestr
argument_list|(
name|zp
operator|->
name|z_timerinfo
operator|->
name|name
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|zp
operator|->
name|z_timerinfo
argument_list|,
sizeof|sizeof
expr|*
name|zp
operator|->
name|z_timerinfo
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_timerinfo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"timer for zone '%s' had no timerinfo"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_zone_contents
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|int
name|undefine_sym
parameter_list|)
block|{
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|undefine_sym
condition|)
name|undefine_symbol
argument_list|(
name|zone_symbol_table
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_TIMER_SET
condition|)
block|{
name|free_zone_timerinfo
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|evClearTimer
argument_list|(
name|ev
argument_list|,
name|zp
operator|->
name|z_timer
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"evClearTimer for zone '%s' failed in ns_init: %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_origin
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_origin
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_source
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_base
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_tmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_update_acl
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|zp
operator|->
name|z_update_acl
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_update_acl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_query_acl
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|zp
operator|->
name|z_query_acl
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_query_acl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_transfer_acl
operator|!=
name|NULL
condition|)
name|free_ip_match_list
argument_list|(
name|zp
operator|->
name|z_transfer_acl
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_transfer_acl
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|zp
operator|->
name|z_updatelog
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_updatelog
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* BIND_UPDATE */
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|zp
operator|->
name|z_also_notify
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|zp
operator|->
name|z_also_notify
argument_list|,
name|zp
operator|->
name|z_notify_count
operator|*
sizeof|sizeof
expr|*
name|zp
operator|->
name|z_also_notify
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_also_notify
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|block_signals
argument_list|()
expr_stmt|;
if|if
condition|(
name|LINKED
argument_list|(
name|zp
argument_list|,
name|z_reloadlink
argument_list|)
condition|)
name|UNLINK
argument_list|(
name|reloadingzones
argument_list|,
name|zp
argument_list|,
name|z_reloadlink
argument_list|)
expr_stmt|;
name|unblock_signals
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_zone
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|free_zone_contents
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|zp
argument_list|,
sizeof|sizeof
expr|*
name|zp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|zoneinfo
modifier|*
name|find_zone
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|class
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|symbol_value
name|value
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"find_zone(%s, %d)"
argument_list|,
operator|*
name|name
condition|?
name|name
else|:
literal|"."
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|lookup_symbol
argument_list|(
name|zone_symbol_table
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
operator|&
name|value
argument_list|)
condition|)
block|{
name|INSIST
argument_list|(
name|value
operator|.
name|integer
operator|>=
literal|0
operator|&&
name|value
operator|.
name|integer
operator|<
name|nzones
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"find_zone: existing zone %d"
argument_list|,
name|value
operator|.
name|integer
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|&
name|zones
index|[
name|value
operator|.
name|integer
index|]
expr_stmt|;
return|return
operator|(
name|zp
operator|)
return|;
block|}
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"find_zone: unknown zone"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|zoneinfo
modifier|*
name|new_zone
parameter_list|(
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
if|if
condition|(
name|EMPTY
argument_list|(
name|freezones
argument_list|)
condition|)
name|make_new_zones
argument_list|()
expr_stmt|;
name|zp
operator|=
name|HEAD
argument_list|(
name|freezones
argument_list|)
expr_stmt|;
name|UNLINK
argument_list|(
name|freezones
argument_list|,
name|zp
argument_list|,
name|z_freelink
argument_list|)
expr_stmt|;
return|return
operator|(
name|zp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check out a zoneinfo structure and return non-zero if it's OK.  */
end_comment

begin_function
specifier|static
name|int
name|validate_zone
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|)
block|{
name|char
name|filename
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
comment|/* Check name */
if|if
condition|(
operator|!
name|res_dnok
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"invalid zone name '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check class */
if|if
condition|(
name|zp
operator|->
name|z_class
operator|==
name|C_ANY
operator|||
name|zp
operator|->
name|z_class
operator|==
name|C_NONE
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"invalid class %d for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check type. */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"no type specified for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_cache
operator|&&
name|ns_samename
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
literal|""
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"only the root zone may be a cache zone (zone '%s')"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_hint
operator|&&
name|ns_samename
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
literal|""
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"only the root zone may be a hint zone (zone '%s')"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check filename. */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|&&
name|zp
operator|->
name|z_source
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'file' statement missing for master zone %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * XXX  We should run filename through an OS-specific 	 *      validator here. 	 */
if|if
condition|(
name|zp
operator|->
name|z_source
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"filename too long for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_ixfr_base
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"ixfr filename too long for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
operator|&&
name|strlen
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"tmp ixfr filename too long for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* Check masters */
if|if
condition|(
name|zp
operator|->
name|z_addrcnt
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_hint
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_cache
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'masters' statement present for %s zone '%s'"
argument_list|,
operator|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|)
condition|?
literal|"master"
else|:
operator|(
name|zp
operator|->
name|z_type
operator|==
name|z_hint
operator|)
condition|?
literal|"hint"
else|:
literal|"cache"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_slave
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_stub
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"no 'masters' statement for non-master zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Check allow-update and allow-transfer. */
if|if
condition|(
name|zp
operator|->
name|z_update_acl
operator|||
name|zp
operator|->
name|z_transfer_acl
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_master
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|z_slave
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'allow-{update,transfer}' option for non-{master,slave} zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Check allow-query. */
if|if
condition|(
name|zp
operator|->
name|z_query_acl
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_master
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|z_slave
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|z_stub
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'allow-query' option for non-{master,slave,stub} zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* Check notify */
if|if
condition|(
name|zp
operator|->
name|z_notify
operator|!=
name|znotify_use_default
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_master
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|z_slave
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'notify' given for non-master, non-slave zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Check also-notify */
if|if
condition|(
name|zp
operator|->
name|z_notify_count
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
name|z_master
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|z_slave
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'also-notify' given for non-master, non-slave zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|BIND_UPDATE
comment|/* XXX need more checking here */
if|if
condition|(
operator|!
name|zp
operator|->
name|z_updatelog
operator|&&
name|zp
operator|->
name|z_source
condition|)
block|{
comment|/* XXX OS-specific filename validation here */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
operator|+
operator|(
sizeof|sizeof
expr|".log"
operator|-
literal|1
operator|)
operator|)
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"filename too long for dynamic zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* this sprintf() is now safe */
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s.log"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_updatelog
operator|=
name|savestr
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Check forward */
if|if
condition|(
name|zp
operator|->
name|z_optset
operator|&
name|OPTION_FORWARD_ONLY
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_hint
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'forward' given for hint zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* Check forwarders */
if|if
condition|(
name|zp
operator|->
name|z_fwdtab
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_hint
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"'forwarders' given for hint zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
condition|)
block|{
if|if
condition|(
operator|!
name|zp
operator|->
name|z_soaincrintvl
condition|)
name|zp
operator|->
name|z_soaincrintvl
operator|=
name|SOAINCRINTVL
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_dumpintvl
condition|)
name|zp
operator|->
name|z_dumpintvl
operator|=
name|DUMPINTVL
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_deferupdcnt
condition|)
name|zp
operator|->
name|z_deferupdcnt
operator|=
name|DEFERUPDCNT
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* BIND_UPDATE */
if|if
condition|(
operator|!
name|zp
operator|->
name|z_ixfr_base
operator|&&
name|zp
operator|->
name|z_source
condition|)
block|{
comment|/* XXX OS-specific filename validation here */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
operator|+
operator|(
sizeof|sizeof
expr|".ixfr"
operator|-
literal|1
operator|)
operator|)
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"filename too long for dynamic zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* this sprintf() is now safe */
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s.ixfr"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_base
operator|=
name|savestr
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zp
operator|->
name|z_ixfr_tmp
operator|&&
name|zp
operator|->
name|z_source
condition|)
block|{
comment|/* XXX OS-specific filename validation here */
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
operator|+
operator|(
sizeof|sizeof
expr|".ixfr.tmp"
operator|-
literal|1
operator|)
operator|)
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"filename too long for dynamic zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* this sprintf() is now safe */
name|sprintf
argument_list|(
name|filename
argument_list|,
literal|"%s.ixfr.tmp"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_tmp
operator|=
name|savestr
argument_list|(
name|filename
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Start building a new zoneinfo structure.  Returns an opaque  * zone_config suitable for use by the parser.  */
end_comment

begin_function
name|zone_config
name|begin_zone
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|class
parameter_list|)
block|{
name|zone_config
name|zh
decl_stmt|;
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
comment|/* 	 * require: name is canonical, class is a valid class 	 */
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"begin_zone('%s', %d)"
argument_list|,
operator|(
operator|*
name|name
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|name
argument_list|,
name|class
argument_list|)
expr_stmt|;
name|zp
operator|=
operator|(
expr|struct
name|zoneinfo
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|zoneinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in begin_zone"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|zoneinfo
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_origin
operator|=
name|name
expr_stmt|;
name|zp
operator|->
name|z_class
operator|=
name|class
expr_stmt|;
name|zp
operator|->
name|z_checknames
operator|=
name|not_set
expr_stmt|;
if|if
condition|(
name|server_options
operator|->
name|flags
operator|&
name|OPTION_MAINTAIN_IXFR_BASE
condition|)
name|zp
operator|->
name|z_maintain_ixfr_base
operator|=
literal|1
expr_stmt|;
else|else
name|zp
operator|->
name|z_maintain_ixfr_base
operator|=
literal|0
expr_stmt|;
name|zp
operator|->
name|z_max_log_size_ixfr
operator|=
name|server_options
operator|->
name|max_log_size_ixfr
expr_stmt|;
name|zh
operator|.
name|opaque
operator|=
name|zp
expr_stmt|;
return|return
operator|(
name|zh
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Merge new configuration information into an existing zone.  The  * new zoneinfo must be valid.  */
end_comment

begin_function
specifier|static
name|void
name|update_zone_info
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|struct
name|zoneinfo
modifier|*
name|new_zp
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|new_zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"update_zone_info('%s', %d)"
argument_list|,
operator|(
operator|*
name|new_zp
operator|->
name|z_origin
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|new_zp
operator|->
name|z_origin
argument_list|,
name|new_zp
operator|->
name|z_type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
comment|/* 	 * A dynamic master zone that's becoming non-dynamic may need to be 	 * dumped before we start the update. 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|&&
operator|!
operator|(
name|new_zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
operator|&&
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_SOAUPDATE
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_NEED_DUMP
operator|)
operator|)
condition|)
operator|(
name|void
operator|)
name|zonedump
argument_list|(
name|zp
argument_list|,
name|ISNOTIXFR
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * First do the simple stuff, making sure to free 	 * any data that was dynamically allocated. 	 */
if|if
condition|(
name|zp
operator|->
name|z_origin
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_origin
operator|=
name|new_zp
operator|->
name|z_origin
expr_stmt|;
name|new_zp
operator|->
name|z_origin
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_maintain_ixfr_base
operator|=
name|new_zp
operator|->
name|z_maintain_ixfr_base
expr_stmt|;
name|zp
operator|->
name|z_max_log_size_ixfr
operator|=
name|new_zp
operator|->
name|z_max_log_size_ixfr
expr_stmt|;
name|zp
operator|->
name|z_class
operator|=
name|new_zp
operator|->
name|z_class
expr_stmt|;
name|zp
operator|->
name|z_type
operator|=
name|new_zp
operator|->
name|z_type
expr_stmt|;
name|zp
operator|->
name|z_checknames
operator|=
name|new_zp
operator|->
name|z_checknames
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_zp
operator|->
name|z_addrcnt
condition|;
name|i
operator|++
control|)
name|zp
operator|->
name|z_addr
index|[
name|i
index|]
operator|=
name|new_zp
operator|->
name|z_addr
index|[
name|i
index|]
expr_stmt|;
name|zp
operator|->
name|z_addrcnt
operator|=
name|new_zp
operator|->
name|z_addrcnt
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_update_acl
condition|)
name|free_ip_match_list
argument_list|(
name|zp
operator|->
name|z_update_acl
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_update_acl
operator|=
name|new_zp
operator|->
name|z_update_acl
expr_stmt|;
name|new_zp
operator|->
name|z_update_acl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_query_acl
condition|)
name|free_ip_match_list
argument_list|(
name|zp
operator|->
name|z_query_acl
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_query_acl
operator|=
name|new_zp
operator|->
name|z_query_acl
expr_stmt|;
name|new_zp
operator|->
name|z_query_acl
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_axfr_src
operator|=
name|new_zp
operator|->
name|z_axfr_src
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_transfer_acl
condition|)
name|free_ip_match_list
argument_list|(
name|zp
operator|->
name|z_transfer_acl
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_transfer_acl
operator|=
name|new_zp
operator|->
name|z_transfer_acl
expr_stmt|;
name|new_zp
operator|->
name|z_transfer_acl
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_max_transfer_time_in
operator|=
name|new_zp
operator|->
name|z_max_transfer_time_in
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|zp
operator|->
name|z_notify
operator|=
name|new_zp
operator|->
name|z_notify
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_also_notify
condition|)
name|memput
argument_list|(
name|zp
operator|->
name|z_also_notify
argument_list|,
name|zp
operator|->
name|z_notify_count
operator|*
sizeof|sizeof
expr|*
name|zp
operator|->
name|z_also_notify
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_also_notify
operator|=
name|new_zp
operator|->
name|z_also_notify
expr_stmt|;
name|zp
operator|->
name|z_notify_count
operator|=
name|new_zp
operator|->
name|z_notify_count
expr_stmt|;
name|new_zp
operator|->
name|z_also_notify
operator|=
name|NULL
expr_stmt|;
name|new_zp
operator|->
name|z_notify_count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|(
name|new_zp
operator|->
name|z_flags
operator|&
name|Z_FORWARD_SET
operator|)
operator|!=
literal|0
condition|)
name|zp
operator|->
name|z_flags
operator||=
name|Z_FORWARD_SET
expr_stmt|;
else|else
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_FORWARD_SET
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_fwdtab
operator|!=
name|NULL
condition|)
name|free_forwarders
argument_list|(
name|zp
operator|->
name|z_fwdtab
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_fwdtab
operator|=
name|new_zp
operator|->
name|z_fwdtab
expr_stmt|;
name|new_zp
operator|->
name|z_fwdtab
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_dialup
operator|=
name|new_zp
operator|->
name|z_dialup
expr_stmt|;
name|zp
operator|->
name|z_options
operator|=
name|new_zp
operator|->
name|z_options
expr_stmt|;
name|zp
operator|->
name|z_optset
operator|=
name|new_zp
operator|->
name|z_optset
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|new_zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
condition|)
name|zp
operator|->
name|z_flags
operator||=
name|Z_DYNAMIC
expr_stmt|;
else|else
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_DYNAMIC
expr_stmt|;
name|zp
operator|->
name|z_soaincrintvl
operator|=
name|new_zp
operator|->
name|z_soaincrintvl
expr_stmt|;
name|zp
operator|->
name|z_dumpintvl
operator|=
name|new_zp
operator|->
name|z_dumpintvl
expr_stmt|;
name|zp
operator|->
name|z_deferupdcnt
operator|=
name|new_zp
operator|->
name|z_deferupdcnt
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_updatelog
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_updatelog
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_updatelog
operator|=
name|new_zp
operator|->
name|z_updatelog
expr_stmt|;
name|new_zp
operator|->
name|z_updatelog
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
comment|/* BIND_UPDATE */
name|zp
operator|->
name|z_port
operator|=
name|new_zp
operator|->
name|z_port
expr_stmt|;
comment|/* 	 * Now deal with files. 	 */
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|z_cache
case|:
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"impossible condition"
argument_list|)
expr_stmt|;
break|break;
case|case
name|z_hint
case|:
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"source = %s"
argument_list|,
name|new_zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_refresh
operator|=
literal|0
expr_stmt|;
comment|/* No dumping. */
if|if
condition|(
name|zp
operator|->
name|z_source
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|new_zp
operator|->
name|z_source
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|reconfiging
operator|||
operator|!
name|zonefile_changed_p
argument_list|(
name|zp
argument_list|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"cache is up to date"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* File has changed, or hasn't been loaded yet. */
if|if
condition|(
name|zp
operator|->
name|z_source
condition|)
block|{
name|freestr
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|ns_stopxfrs
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|purge_zone
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|fcachetab
argument_list|,
name|zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
block|}
name|zp
operator|->
name|z_source
operator|=
name|new_zp
operator|->
name|z_source
expr_stmt|;
name|new_zp
operator|->
name|z_source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_base
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_base
operator|=
name|new_zp
operator|->
name|z_ixfr_base
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_tmp
operator|=
name|new_zp
operator|->
name|z_ixfr_tmp
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_tmp
operator|=
name|NULL
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"reloading hint zone"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|db_load
argument_list|(
name|zp
operator|->
name|z_source
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
argument_list|,
name|NULL
argument_list|,
name|ISNOTIXFR
argument_list|)
expr_stmt|;
break|break;
case|case
name|z_master
case|:
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"source = %s"
argument_list|,
name|new_zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
comment|/* 		 * If we've loaded this file, and the file hasn't changed 		 * then there's no need to reload. 		 */
if|if
condition|(
name|zp
operator|->
name|z_source
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|new_zp
operator|->
name|z_source
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|reconfiging
operator|||
operator|!
name|zonefile_changed_p
argument_list|(
name|zp
argument_list|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"zone is up to date"
argument_list|)
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
name|zp
operator|->
name|z_source
operator|&&
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_DYNAMIC
operator|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"source file of dynamic zone '%s' has changed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|primary_reload
label|:
endif|#
directive|endif
comment|/* BIND_UPDATE */
if|if
condition|(
name|zp
operator|->
name|z_source
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_source
operator|=
name|new_zp
operator|->
name|z_source
expr_stmt|;
name|new_zp
operator|->
name|z_source
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_base
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_base
operator|=
name|new_zp
operator|->
name|z_ixfr_base
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_tmp
operator|=
name|new_zp
operator|->
name|z_ixfr_tmp
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_tmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|reload_master
argument_list|(
name|zp
argument_list|)
operator|==
literal|1
condition|)
block|{
comment|/* 			 * Note that going to primary_reload 			 * unconditionally reloads the zone. 			 */
name|new_zp
operator|->
name|z_source
operator|=
name|savestr
argument_list|(
name|zp
operator|->
name|z_source
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_base
operator|=
name|savestr
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_tmp
operator|=
name|savestr
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|primary_reload
goto|;
block|}
break|break;
case|case
name|z_slave
case|:
ifdef|#
directive|ifdef
name|STUBS
case|case
name|z_stub
case|:
endif|#
directive|endif
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"addrcnt = %d"
argument_list|,
name|zp
operator|->
name|z_addrcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_zp
operator|->
name|z_source
condition|)
block|{
comment|/* 			 * We will always transfer this zone again 			 * after a reload. 			 */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"NsTmp%ld.%d"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|,
name|tmpnum
operator|++
argument_list|)
expr_stmt|;
name|new_zp
operator|->
name|z_source
operator|=
name|savestr
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_TMP_FILE
expr_stmt|;
block|}
else|else
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_TMP_FILE
expr_stmt|;
comment|/* 		 * If we had a backup file name, and it was changed, 		 * free old zone and start over.  If we don't have 		 * current zone contents, try again now in case 		 * we have a new server on the list. 		 */
if|if
condition|(
name|zp
operator|->
name|z_source
operator|!=
name|NULL
operator|&&
operator|(
name|strcmp
argument_list|(
name|new_zp
operator|->
name|z_source
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
operator|!=
literal|0
operator|||
operator|(
operator|(
operator|!
name|reconfiging
operator|)
operator|&&
name|zonefile_changed_p
argument_list|(
name|zp
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"backup file changed or missing"
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_source
operator|=
name|NULL
expr_stmt|;
name|zp
operator|->
name|z_serial
operator|=
literal|0
expr_stmt|;
comment|/* force xfer */
name|ns_stopxfrs
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 			 * We only need to reload if we have ever 			 * successfully transferred the zone. 			 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|!=
literal|0
condition|)
block|{
name|zp
operator|->
name|z_flags
operator|&=
operator|~
name|Z_AUTH
expr_stmt|;
comment|/* 				 * Purge old data and mark the parent for 				 * reloading so that NS records are present 				 * during the zone transfer. 				 */
name|do_reload
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_type
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zp
operator|->
name|z_source
operator|==
name|NULL
condition|)
block|{
name|zp
operator|->
name|z_source
operator|=
name|new_zp
operator|->
name|z_source
expr_stmt|;
name|new_zp
operator|->
name|z_source
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_ixfr_base
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_base
operator|=
name|new_zp
operator|->
name|z_ixfr_base
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_base
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|zp
operator|->
name|z_ixfr_tmp
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_tmp
operator|=
name|new_zp
operator|->
name|z_ixfr_tmp
expr_stmt|;
name|new_zp
operator|->
name|z_ixfr_tmp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|noexpired
operator|||
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_EXPIRED
operator|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_AUTH
operator|)
operator|==
literal|0
operator|)
condition|)
name|zoneinit
argument_list|(
name|zp
argument_list|)
expr_stmt|;
else|else
block|{
comment|/*  			** Force slave to try transfer soon after SIGHUP. 			*/
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
operator|(
name|Z_QSERIAL
operator||
name|Z_XFER_RUNNING
operator|)
operator|)
operator|==
literal|0
operator|&&
name|reloading
operator|&&
operator|!
name|reconfiging
condition|)
block|{
name|qserial_retrytime
argument_list|(
name|zp
argument_list|,
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|sched_zone_maint
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|z_forward
case|:
comment|/* 		 * We don't know if the forwarder's list has changed 		 * so just purge the cache.  In the future we may want 		 * see if the forwarders list has changed and only 		 * do this then. 		 */
name|clean_cache_from
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|hashtab
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|zp
operator|->
name|z_flags
operator|&
name|Z_FOUND
operator|)
operator|!=
literal|0
operator|&&
comment|/* already found? */
operator|(
name|zp
operator|-
name|zones
operator|)
operator|!=
name|DB_Z_CACHE
condition|)
comment|/* cache never sets Z_FOUND */
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"Zone \"%s\" declared more than once"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_FOUND
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"zone[%d] type %d: '%s' z_time %lu, z_refresh %u"
argument_list|,
name|zp
operator|-
name|zones
argument_list|,
name|zp
operator|->
name|z_type
argument_list|,
operator|*
operator|(
name|zp
operator|->
name|z_origin
operator|)
operator|==
literal|'\0'
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|,
operator|(
name|u_long
operator|)
name|zp
operator|->
name|z_time
argument_list|,
name|zp
operator|->
name|z_refresh
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Finish constructing a new zone.  If valid, the constructed zone is  * merged into the zone database.  The zone_config used is invalid after  * end_zone() completes.  */
end_comment

begin_function
name|void
name|end_zone
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|int
name|should_install
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|,
modifier|*
name|new_zp
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
name|symbol_value
name|value
decl_stmt|;
name|new_zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|new_zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zname
operator|=
operator|(
name|new_zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|new_zp
operator|->
name|z_origin
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"end_zone('%s', %d)"
argument_list|,
name|zname
argument_list|,
name|should_install
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|should_install
condition|)
block|{
name|release_zone
argument_list|(
name|new_zp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|validate_zone
argument_list|(
name|new_zp
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"zone '%s' did not validate, skipping"
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|release_zone
argument_list|(
name|new_zp
argument_list|)
expr_stmt|;
return|return;
block|}
name|zp
operator|=
name|find_zone
argument_list|(
name|new_zp
operator|->
name|z_origin
argument_list|,
name|new_zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|!=
name|NULL
operator|&&
name|zp
operator|->
name|z_type
operator|!=
name|new_zp
operator|->
name|z_type
condition|)
block|{
name|remove_zone
argument_list|(
name|zp
argument_list|,
literal|"redefined"
argument_list|)
expr_stmt|;
name|zp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
block|{
name|zp
operator|=
name|new_zone
argument_list|(
name|new_zp
operator|->
name|z_class
argument_list|,
name|new_zp
operator|->
name|z_type
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|.
name|integer
operator|=
operator|(
name|zp
operator|-
name|zones
operator|)
expr_stmt|;
name|define_symbol
argument_list|(
name|zone_symbol_table
argument_list|,
name|savestr
argument_list|(
name|new_zp
operator|->
name|z_origin
argument_list|,
literal|1
argument_list|)
argument_list|,
name|new_zp
operator|->
name|z_class
argument_list|,
name|value
argument_list|,
name|SYMBOL_FREE_KEY
argument_list|)
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|5
argument_list|,
literal|"zone '%s', type = %d, class = %d"
argument_list|,
name|zname
argument_list|,
name|new_zp
operator|->
name|z_type
argument_list|,
name|new_zp
operator|->
name|z_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_zp
operator|->
name|z_source
operator|!=
name|NULL
condition|)
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|5
argument_list|,
literal|"  file = %s"
argument_list|,
name|new_zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|5
argument_list|,
literal|"  checknames = %d"
argument_list|,
name|new_zp
operator|->
name|z_checknames
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_zp
operator|->
name|z_addrcnt
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|5
argument_list|,
literal|"  masters:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_zp
operator|->
name|z_addrcnt
condition|;
name|i
operator|++
control|)
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|5
argument_list|,
literal|"    %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|new_zp
operator|->
name|z_addr
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|update_zone_info
argument_list|(
name|zp
argument_list|,
name|new_zp
argument_list|)
expr_stmt|;
name|release_zone
argument_list|(
name|new_zp
argument_list|)
expr_stmt|;
name|zh
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|set_zone_type
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if type already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_type
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_type
operator|=
name|type
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_filename
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if filename already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_source
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_source
operator|=
name|filename
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_checknames
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|enum
name|severity
name|s
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if checknames already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_checknames
operator|!=
name|not_set
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_checknames
operator|=
name|s
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_ixfr_file
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if filename already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_ixfr_base
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_ixfr_base
operator|=
name|filename
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|==
name|NULL
condition|)
block|{
name|int
name|len
init|=
name|strlen
argument_list|(
name|zp
operator|->
name|z_ixfr_base
argument_list|)
operator|+
operator|(
sizeof|sizeof
expr|".tmp"
operator|)
decl_stmt|;
name|char
modifier|*
name|str
init|=
operator|(
name|char
operator|*
operator|)
name|memget
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s.tmp"
argument_list|,
name|zp
operator|->
name|z_ixfr_base
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_ixfr_tmp
operator|=
name|savestr
argument_list|(
name|str
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_ixfr_tmp
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if filename already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_ixfr_tmp
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_ixfr_tmp
operator|=
name|filename
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_dialup
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|zp
operator|->
name|z_dialup
operator|=
name|zdialup_yes
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|zp
operator|->
name|z_notify
operator|=
name|znotify_yes
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|zp
operator|->
name|z_dialup
operator|=
name|zdialup_no
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_notify
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|int
name|value
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|zp
operator|->
name|z_notify
operator|=
name|znotify_yes
expr_stmt|;
else|else
name|zp
operator|->
name|z_notify
operator|=
name|znotify_no
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_maintain_ixfr_base
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_maintain_ixfr_base
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_update_acl
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|ip_match_list
name|iml
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if update_acl already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_update_acl
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_update_acl
operator|=
name|iml
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_UPDATE
if|if
condition|(
operator|!
name|ip_match_is_none
argument_list|(
name|iml
argument_list|)
condition|)
name|zp
operator|->
name|z_flags
operator||=
name|Z_DYNAMIC
expr_stmt|;
else|else
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"update acl is none for '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_query_acl
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|ip_match_list
name|iml
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if checknames already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_query_acl
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_query_acl
operator|=
name|iml
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_master_port
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|u_short
name|port
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
name|zh
operator|.
name|opaque
decl_stmt|;
name|zp
operator|->
name|z_port
operator|=
name|port
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_transfer_source
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|struct
name|in_addr
name|ina
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
name|zh
operator|.
name|opaque
decl_stmt|;
name|zp
operator|->
name|z_axfr_src
operator|=
name|ina
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_transfer_acl
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|ip_match_list
name|iml
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if checknames already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_transfer_acl
operator|!=
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_transfer_acl
operator|=
name|iml
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_transfer_time_in
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|long
name|max_time
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Fail if checknames already set for this zone */
if|if
condition|(
name|zp
operator|->
name|z_max_transfer_time_in
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zp
operator|->
name|z_max_transfer_time_in
operator|=
name|max_time
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_max_log_size_ixfr
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_max_log_size_ixfr
operator|=
name|size
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_zone_pubkey
parameter_list|(
name|zone_config
name|zh
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|,
specifier|const
name|int
name|proto
parameter_list|,
specifier|const
name|int
name|alg
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
operator|&&
name|zp
operator|->
name|z_origin
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|add_trusted_key
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|flags
argument_list|,
name|proto
argument_list|,
name|alg
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|set_trusted_key
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|int
name|flags
parameter_list|,
specifier|const
name|int
name|proto
parameter_list|,
specifier|const
name|int
name|alg
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|INSIST
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|add_trusted_key
argument_list|(
name|name
argument_list|,
name|flags
argument_list|,
name|proto
argument_list|,
name|alg
argument_list|,
name|str
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|add_zone_master
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
operator|=
name|address
expr_stmt|;
name|zp
operator|->
name|z_addrcnt
operator|++
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_addrcnt
operator|>=
name|NSMAX
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"NSMAX reached for zone '%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_addrcnt
operator|=
name|NSMAX
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|add_zone_notify
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|int
name|i
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Check for duplicates. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|zp
operator|->
name|z_notify_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|zp
operator|->
name|z_also_notify
operator|+
name|i
argument_list|,
operator|&
name|address
argument_list|,
sizeof|sizeof
name|address
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"duplicate also-notify address ignored [%s] for zone '%s'"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_also_notify
operator|==
name|NULL
condition|)
block|{
name|zp
operator|->
name|z_also_notify
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|zp
operator|->
name|z_also_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_also_notify
operator|==
name|NULL
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|struct
name|in_addr
modifier|*
name|an_tmp
decl_stmt|;
name|size
operator|=
name|zp
operator|->
name|z_notify_count
operator|*
sizeof|sizeof
expr|*
name|zp
operator|->
name|z_also_notify
expr_stmt|;
name|an_tmp
operator|=
name|memget
argument_list|(
name|size
operator|+
sizeof|sizeof
expr|*
name|zp
operator|->
name|z_also_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_tmp
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|an_tmp
argument_list|,
name|zp
operator|->
name|z_also_notify
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|zp
operator|->
name|z_also_notify
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_also_notify
operator|=
name|an_tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|zp
operator|->
name|z_also_notify
index|[
name|zp
operator|->
name|z_notify_count
index|]
operator|=
name|address
expr_stmt|;
name|zp
operator|->
name|z_notify_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"also-notify add failed (memget) [%s] for zone '%s'"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Options */
end_comment

begin_function
name|options
name|new_options
parameter_list|()
block|{
name|options
name|op
decl_stmt|;
name|op
operator|=
operator|(
name|options
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|options
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_options()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|->
name|version
operator|=
name|savestr
argument_list|(
name|ShortVersion
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|directory
operator|=
name|savestr
argument_list|(
literal|"."
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|pid_filename
operator|=
name|savestr
argument_list|(
name|_PATH_PIDFILE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|named_xfer
operator|=
name|savestr
argument_list|(
name|_PATH_XFER
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|dump_filename
operator|=
name|savestr
argument_list|(
name|_PATH_DUMPFILE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|stats_filename
operator|=
name|savestr
argument_list|(
name|_PATH_STATS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|memstats_filename
operator|=
name|savestr
argument_list|(
name|_PATH_MEMSTATS
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|op
operator|->
name|flags
operator|=
name|DEFAULT_OPTION_FLAGS
expr_stmt|;
name|op
operator|->
name|transfers_in
operator|=
name|DEFAULT_XFERS_RUNNING
expr_stmt|;
name|op
operator|->
name|transfers_per_ns
operator|=
name|DEFAULT_XFERS_PER_NS
expr_stmt|;
name|op
operator|->
name|transfers_out
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|serial_queries
operator|=
name|MAXQSERIAL
expr_stmt|;
name|op
operator|->
name|transfer_format
operator|=
name|axfr_one_answer
expr_stmt|;
name|op
operator|->
name|max_transfer_time_in
operator|=
name|MAX_XFER_TIME
expr_stmt|;
name|memset
argument_list|(
operator|&
name|op
operator|->
name|query_source
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|op
operator|->
name|query_source
argument_list|)
expr_stmt|;
name|op
operator|->
name|query_source
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|op
operator|->
name|query_source
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|op
operator|->
name|query_source
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* INPORT_ANY */
name|op
operator|->
name|axfr_src
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|op
operator|->
name|notify_count
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|also_notify
operator|=
name|NULL
expr_stmt|;
endif|#
directive|endif
name|op
operator|->
name|blackhole_acl
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|query_acl
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|transfer_acl
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|recursion_acl
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|sortlist
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|topology
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|data_size
operator|=
literal|0UL
expr_stmt|;
comment|/* use system default */
name|op
operator|->
name|stack_size
operator|=
literal|0UL
expr_stmt|;
comment|/* use system default */
name|op
operator|->
name|core_size
operator|=
literal|0UL
expr_stmt|;
comment|/* use system default */
name|op
operator|->
name|files
operator|=
name|ULONG_MAX
expr_stmt|;
comment|/* unlimited */
name|op
operator|->
name|check_names
index|[
name|primary_trans
index|]
operator|=
name|fail
expr_stmt|;
name|op
operator|->
name|check_names
index|[
name|secondary_trans
index|]
operator|=
name|warn
expr_stmt|;
name|op
operator|->
name|check_names
index|[
name|response_trans
index|]
operator|=
name|ignore
expr_stmt|;
name|op
operator|->
name|listen_list
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|fwdtab
operator|=
name|NULL
expr_stmt|;
comment|/* XXX init forwarding */
name|op
operator|->
name|clean_interval
operator|=
literal|3600
expr_stmt|;
name|op
operator|->
name|interface_interval
operator|=
literal|3600
expr_stmt|;
name|op
operator|->
name|stats_interval
operator|=
literal|3600
expr_stmt|;
name|op
operator|->
name|ordering
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|max_ncache_ttl
operator|=
name|DEFAULT_MAX_NCACHE_TTL
expr_stmt|;
name|op
operator|->
name|max_host_stats
operator|=
literal|0
expr_stmt|;
name|op
operator|->
name|lame_ttl
operator|=
name|NTTL
expr_stmt|;
name|op
operator|->
name|heartbeat_interval
operator|=
literal|3600
expr_stmt|;
name|op
operator|->
name|max_log_size_ixfr
operator|=
literal|20
expr_stmt|;
name|op
operator|->
name|minroots
operator|=
name|MINROOTS
expr_stmt|;
return|return
operator|(
name|op
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_options
parameter_list|(
name|options
name|op
parameter_list|)
block|{
name|INSIST
argument_list|(
name|op
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|version
condition|)
name|freestr
argument_list|(
name|op
operator|->
name|version
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|directory
condition|)
name|freestr
argument_list|(
name|op
operator|->
name|directory
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|pid_filename
condition|)
name|freestr
argument_list|(
name|op
operator|->
name|pid_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|named_xfer
condition|)
name|freestr
argument_list|(
name|op
operator|->
name|named_xfer
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|dump_filename
condition|)
name|freestr
argument_list|(
name|op
operator|->
name|dump_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|stats_filename
condition|)
name|freestr
argument_list|(
name|op
operator|->
name|stats_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|memstats_filename
condition|)
name|freestr
argument_list|(
name|op
operator|->
name|memstats_filename
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|op
operator|->
name|also_notify
condition|)
name|free_also_notify
argument_list|(
name|op
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|op
operator|->
name|blackhole_acl
condition|)
name|free_ip_match_list
argument_list|(
name|op
operator|->
name|blackhole_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|query_acl
condition|)
name|free_ip_match_list
argument_list|(
name|op
operator|->
name|query_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|recursion_acl
condition|)
name|free_ip_match_list
argument_list|(
name|op
operator|->
name|recursion_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|transfer_acl
condition|)
name|free_ip_match_list
argument_list|(
name|op
operator|->
name|transfer_acl
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|sortlist
condition|)
name|free_ip_match_list
argument_list|(
name|op
operator|->
name|sortlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|ordering
condition|)
name|free_rrset_order_list
argument_list|(
name|op
operator|->
name|ordering
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|topology
condition|)
name|free_ip_match_list
argument_list|(
name|op
operator|->
name|topology
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|listen_list
condition|)
name|free_listen_info_list
argument_list|(
name|op
operator|->
name|listen_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|fwdtab
condition|)
name|free_forwarders
argument_list|(
name|op
operator|->
name|fwdtab
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|op
argument_list|,
sizeof|sizeof
expr|*
name|op
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_boolean_option
parameter_list|(
name|u_int
modifier|*
name|op_flags
parameter_list|,
name|int
name|bool_opt
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|INSIST
argument_list|(
name|op_flags
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bool_opt
condition|)
block|{
ifdef|#
directive|ifdef
name|HITCOUNTS
case|case
name|OPTION_HITCOUNT
case|:
endif|#
directive|endif
comment|/* HITCOUNTS */
case|case
name|OPTION_NORECURSE
case|:
case|case
name|OPTION_NOFETCHGLUE
case|:
case|case
name|OPTION_FORWARD_ONLY
case|:
case|case
name|OPTION_FAKE_IQUERY
case|:
case|case
name|OPTION_NONOTIFY
case|:
case|case
name|OPTION_NONAUTH_NXDOMAIN
case|:
case|case
name|OPTION_MULTIPLE_CNAMES
case|:
case|case
name|OPTION_USE_IXFR
case|:
case|case
name|OPTION_MAINTAIN_IXFR_BASE
case|:
case|case
name|OPTION_HOSTSTATS
case|:
case|case
name|OPTION_DEALLOC_ON_EXIT
case|:
case|case
name|OPTION_USE_ID_POOL
case|:
case|case
name|OPTION_NORFC2308_TYPE1
case|:
case|case
name|OPTION_NODIALUP
case|:
case|case
name|OPTION_TREAT_CR_AS_SPACE
case|:
if|if
condition|(
name|value
condition|)
operator|*
name|op_flags
operator||=
name|bool_opt
expr_stmt|;
else|else
operator|*
name|op_flags
operator|&=
operator|~
name|bool_opt
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unexpected option in set_boolean_option"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_global_boolean_option
parameter_list|(
name|options
name|op
parameter_list|,
name|int
name|bool_opt
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|INSIST
argument_list|(
name|op
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|set_boolean_option
argument_list|(
operator|&
name|op
operator|->
name|flags
argument_list|,
name|bool_opt
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_zone_boolean_option
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|int
name|bool_opt
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|set_boolean_option
argument_list|(
operator|&
name|zp
operator|->
name|z_options
argument_list|,
name|bool_opt
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Flag that zone option overrides corresponding global option */
name|zp
operator|->
name|z_optset
operator||=
name|bool_opt
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
end_ifdef

begin_enum
enum|enum
name|limit
block|{
name|Datasize
block|,
name|Stacksize
block|,
name|Coresize
block|,
name|Files
block|}
enum|;
end_enum

begin_decl_stmt
specifier|static
name|struct
name|rlimit
name|initial_data_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rlimit
name|initial_stack_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rlimit
name|initial_core_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|rlimit
name|initial_num_files
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|get_initial_limits
parameter_list|()
block|{
name|int
name|fdlimit
init|=
name|evHighestFD
argument_list|(
name|ev
argument_list|)
operator|+
literal|1
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_DATA
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_DATA
argument_list|,
operator|&
name|initial_data_size
argument_list|)
operator|<
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"getrlimit(DATA): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_STACK
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|initial_stack_size
argument_list|)
operator|<
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"getrlimit(STACK): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_CORE
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_CORE
argument_list|,
operator|&
name|initial_core_size
argument_list|)
operator|<
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"getrlimit(CORE): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
if|if
condition|(
name|getrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|initial_num_files
argument_list|)
operator|<
literal|0
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"getrlimit(NOFILE): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|initial_num_files
operator|.
name|rlim_cur
operator|>
name|fdlimit
condition|)
block|{
name|initial_num_files
operator|.
name|rlim_cur
operator|=
name|fdlimit
expr_stmt|;
if|if
condition|(
name|initial_num_files
operator|.
name|rlim_cur
operator|>
name|initial_num_files
operator|.
name|rlim_max
condition|)
name|initial_num_files
operator|.
name|rlim_max
operator|=
name|fdlimit
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|RLIMIT_NOFILE
argument_list|,
operator|&
name|initial_num_files
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"setrlimit(files): %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"limit files set to fdlimit (%d)"
argument_list|,
name|fdlimit
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
end_function

begin_function
specifier|static
name|void
name|ns_rlimit
parameter_list|(
name|enum
name|limit
name|limit
parameter_list|,
name|u_long
name|limit_value
parameter_list|)
block|{
name|struct
name|rlimit
name|limits
decl_stmt|,
name|old_limits
decl_stmt|;
name|int
name|rlimit
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|fdlimit
init|=
name|evHighestFD
argument_list|(
name|ev
argument_list|)
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|rlimit_type
name|value
decl_stmt|;
if|if
condition|(
name|limit_value
operator|==
name|ULONG_MAX
condition|)
block|{
ifndef|#
directive|ifndef
name|RLIMIT_FILE_INFINITY
if|if
condition|(
name|limit
operator|==
name|Files
condition|)
name|value
operator|=
name|MIN
argument_list|(
operator|(
name|rlimit_type
operator|)
name|evHighestFD
argument_list|(
name|ev
argument_list|)
operator|+
literal|1
argument_list|,
name|initial_num_files
operator|.
name|rlim_max
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|value
operator|=
operator|(
name|rlimit_type
operator|)
name|RLIM_INFINITY
expr_stmt|;
block|}
else|else
name|value
operator|=
operator|(
name|rlimit_type
operator|)
name|limit_value
expr_stmt|;
name|limits
operator|.
name|rlim_cur
operator|=
name|limits
operator|.
name|rlim_max
operator|=
name|value
expr_stmt|;
switch|switch
condition|(
name|limit
condition|)
block|{
case|case
name|Datasize
case|:
ifdef|#
directive|ifdef
name|RLIMIT_DATA
name|rlimit
operator|=
name|RLIMIT_DATA
expr_stmt|;
endif|#
directive|endif
name|name
operator|=
literal|"max data size"
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|limits
operator|=
name|initial_data_size
expr_stmt|;
break|break;
case|case
name|Stacksize
case|:
ifdef|#
directive|ifdef
name|RLIMIT_STACK
name|rlimit
operator|=
name|RLIMIT_STACK
expr_stmt|;
endif|#
directive|endif
name|name
operator|=
literal|"max stack size"
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|limits
operator|=
name|initial_stack_size
expr_stmt|;
break|break;
case|case
name|Coresize
case|:
ifdef|#
directive|ifdef
name|RLIMIT_CORE
name|rlimit
operator|=
name|RLIMIT_CORE
expr_stmt|;
endif|#
directive|endif
name|name
operator|=
literal|"max core size"
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|limits
operator|=
name|initial_core_size
expr_stmt|;
break|break;
case|case
name|Files
case|:
ifdef|#
directive|ifdef
name|RLIMIT_NOFILE
name|rlimit
operator|=
name|RLIMIT_NOFILE
expr_stmt|;
endif|#
directive|endif
name|name
operator|=
literal|"max number of open files"
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|limits
operator|=
name|initial_num_files
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|fdlimit
condition|)
name|limits
operator|.
name|rlim_cur
operator|=
name|limits
operator|.
name|rlim_max
operator|=
name|value
operator|=
name|fdlimit
expr_stmt|;
break|break;
default|default:
name|name
operator|=
name|NULL
expr_stmt|;
comment|/* Make gcc happy. */
name|panic
argument_list|(
literal|"impossible condition in ns_rlimit()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rlimit
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"limit \"%s\" not supported on this system - ignored"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|getrlimit
argument_list|(
name|rlimit
argument_list|,
operator|&
name|old_limits
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"getrlimit(%s): %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|user_id
operator|!=
literal|0
operator|&&
name|limits
operator|.
name|rlim_max
operator|==
name|RLIM_INFINITY
condition|)
name|limits
operator|.
name|rlim_cur
operator|=
name|limits
operator|.
name|rlim_max
operator|=
name|old_limits
operator|.
name|rlim_max
expr_stmt|;
if|if
condition|(
name|setrlimit
argument_list|(
name|rlimit
argument_list|,
operator|&
name|limits
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"setrlimit(%s): %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"%s is default"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|value
operator|==
name|RLIM_INFINITY
condition|)
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"%s is unlimited"
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
ifdef|#
directive|ifdef
name|RLIMIT_LONGLONG
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"%s is %llu"
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|value
argument_list|)
expr_stmt|;
else|#
directive|else
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"%s is %lu"
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* HAVE_GETRUSAGE */
end_comment

begin_function
name|listen_info_list
name|new_listen_info_list
parameter_list|()
block|{
name|listen_info_list
name|ll
decl_stmt|;
name|ll
operator|=
operator|(
name|listen_info_list
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_info_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ll
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_listen_info_list()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ll
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|ll
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ll
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_listen_info_list
parameter_list|(
name|listen_info_list
name|ll
parameter_list|)
block|{
name|listen_info
name|li
decl_stmt|,
name|next_li
decl_stmt|;
name|INSIST
argument_list|(
name|ll
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|li
operator|=
name|ll
operator|->
name|first
init|;
name|li
operator|!=
name|NULL
condition|;
name|li
operator|=
name|next_li
control|)
block|{
name|next_li
operator|=
name|li
operator|->
name|next
expr_stmt|;
name|free_ip_match_list
argument_list|(
name|li
operator|->
name|list
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|li
argument_list|,
sizeof|sizeof
expr|*
name|li
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|ll
argument_list|,
sizeof|sizeof
expr|*
name|ll
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_listen_on
parameter_list|(
name|options
name|op
parameter_list|,
name|u_short
name|port
parameter_list|,
name|ip_match_list
name|iml
parameter_list|)
block|{
name|listen_info_list
name|ll
decl_stmt|;
name|listen_info
name|ni
decl_stmt|;
name|INSIST
argument_list|(
name|op
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|listen_list
operator|==
name|NULL
condition|)
name|op
operator|->
name|listen_list
operator|=
name|new_listen_info_list
argument_list|()
expr_stmt|;
name|ll
operator|=
name|op
operator|->
name|listen_list
expr_stmt|;
name|ni
operator|=
operator|(
name|listen_info
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|listen_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ni
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in add_listen_on"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ni
operator|->
name|port
operator|=
name|port
expr_stmt|;
name|ni
operator|->
name|list
operator|=
name|iml
expr_stmt|;
name|ni
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ll
operator|->
name|last
operator|!=
name|NULL
condition|)
name|ll
operator|->
name|last
operator|->
name|next
operator|=
name|ni
expr_stmt|;
name|ll
operator|->
name|last
operator|=
name|ni
expr_stmt|;
if|if
condition|(
name|ll
operator|->
name|first
operator|==
name|NULL
condition|)
name|ll
operator|->
name|first
operator|=
name|ni
expr_stmt|;
block|}
end_function

begin_function
name|FILE
modifier|*
name|write_open
parameter_list|(
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|int
name|regular
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"write_open: stat of %s failed: %s"
argument_list|,
name|filename
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|regular
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|regular
operator|=
operator|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IFREG
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|regular
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"write_open: %s isn't a regular file"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|fd
operator|=
name|open
argument_list|(
name|filename
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
name|S_IRUSR
operator||
name|S_IWUSR
operator||
name|S_IRGRP
operator||
name|S_IWGRP
operator||
name|S_IROTH
operator||
name|S_IWOTH
argument_list|)
expr_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
operator|(
name|void
operator|)
name|fchown
argument_list|(
name|fd
argument_list|,
name|user_id
argument_list|,
name|group_id
argument_list|)
expr_stmt|;
name|stream
operator|=
name|fdopen
argument_list|(
name|fd
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|stream
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|stream
operator|)
return|;
block|}
end_function

begin_function
name|void
name|update_pid_file
parameter_list|()
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|REQUIRE
argument_list|(
name|server_options
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|REQUIRE
argument_list|(
name|server_options
operator|->
name|pid_filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"update_pid_file()"
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_pid_filename
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|current_pid_filename
argument_list|)
expr_stmt|;
name|freestr
argument_list|(
name|current_pid_filename
argument_list|)
expr_stmt|;
name|current_pid_filename
operator|=
name|NULL
expr_stmt|;
block|}
name|current_pid_filename
operator|=
name|savestr
argument_list|(
name|server_options
operator|->
name|pid_filename
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|current_pid_filename
operator|==
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"savestr() failed in update_pid_file()"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fp
operator|=
name|write_open
argument_list|(
name|current_pid_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%ld\n"
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"couldn't create pid file '%s'"
argument_list|,
name|server_options
operator|->
name|pid_filename
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX This function will eventually be public and will be relocated to  *     the UNIX OS support library.  */
end_comment

begin_function
specifier|static
name|int
name|os_change_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|stat
name|sb
decl_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
operator|||
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|name
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|stat
argument_list|(
name|name
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_os
argument_list|,
literal|"stat(%s) failed: %s"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|sb
operator|.
name|st_mode
operator|&
name|S_IWOTH
condition|)
name|ns_warning
argument_list|(
name|ns_log_os
argument_list|,
literal|"directory %s is world-writable"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|periodic_getnetconf
parameter_list|(
name|evContext
name|ctx
parameter_list|,
name|void
modifier|*
name|uap
parameter_list|,
name|struct
name|timespec
name|due
parameter_list|,
name|struct
name|timespec
name|inter
parameter_list|)
block|{
name|getnetconf
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|clean_interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|interface_interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|stats_interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|heartbeat_interval
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|set_interval_timer
parameter_list|(
name|int
name|which_timer
parameter_list|,
name|int
name|interval
parameter_list|)
block|{
name|evTimerID
modifier|*
name|tid
init|=
name|NULL
decl_stmt|;
name|evTimerFunc
name|func
init|=
name|NULL
decl_stmt|;
name|int
name|changed
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|which_timer
condition|)
block|{
case|case
name|CLEAN_TIMER
case|:
if|if
condition|(
name|clean_interval
operator|!=
name|interval
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
name|clean_interval
operator|=
name|interval
expr_stmt|;
name|tid
operator|=
operator|&
name|clean_timer
expr_stmt|;
name|func
operator|=
name|ns_cleancache
expr_stmt|;
break|break;
case|case
name|INTERFACE_TIMER
case|:
if|if
condition|(
name|interface_interval
operator|!=
name|interval
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
name|interface_interval
operator|=
name|interval
expr_stmt|;
name|tid
operator|=
operator|&
name|interface_timer
expr_stmt|;
name|func
operator|=
name|periodic_getnetconf
expr_stmt|;
break|break;
case|case
name|STATS_TIMER
case|:
if|if
condition|(
name|stats_interval
operator|!=
name|interval
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
name|stats_interval
operator|=
name|interval
expr_stmt|;
name|tid
operator|=
operator|&
name|stats_timer
expr_stmt|;
name|func
operator|=
name|ns_logstats
expr_stmt|;
break|break;
case|case
name|HEARTBEAT_TIMER
case|:
if|if
condition|(
name|heartbeat_interval
operator|!=
name|interval
condition|)
name|changed
operator|=
literal|1
expr_stmt|;
name|heartbeat_interval
operator|=
name|interval
expr_stmt|;
name|tid
operator|=
operator|&
name|heartbeat_timer
expr_stmt|;
name|func
operator|=
name|ns_heartbeat
expr_stmt|;
break|break;
default|default:
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"set_interval_timer: unknown timer %d"
argument_list|,
name|which_timer
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|active_timers
operator|&
name|which_timer
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|interval
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|changed
operator|&&
name|evResetTimer
argument_list|(
name|ev
argument_list|,
operator|*
name|tid
argument_list|,
name|func
argument_list|,
name|NULL
argument_list|,
name|evAddTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
name|interval
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|evConsTime
argument_list|(
name|interval
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"evResetTimer %d interval %d failed: %s"
argument_list|,
name|which_timer
argument_list|,
name|interval
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|evClearTimer
argument_list|(
name|ev
argument_list|,
operator|*
name|tid
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"evClearTimer %d failed: %s"
argument_list|,
name|which_timer
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|active_timers
operator|&=
operator|~
name|which_timer
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|interval
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|evSetTimer
argument_list|(
name|ev
argument_list|,
name|func
argument_list|,
name|NULL
argument_list|,
name|evAddTime
argument_list|(
name|evNowTime
argument_list|()
argument_list|,
name|evConsTime
argument_list|(
name|interval
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|,
name|evConsTime
argument_list|(
name|interval
argument_list|,
literal|0
argument_list|)
argument_list|,
name|tid
argument_list|)
operator|<
literal|0
condition|)
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"evSetTimer %d interval %d failed: %s"
argument_list|,
name|which_timer
argument_list|,
name|interval
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|active_timers
operator||=
name|which_timer
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Set all named global options based on the global options structure  * generated by the parser.  */
end_comment

begin_function
name|void
name|set_options
parameter_list|(
name|options
name|op
parameter_list|,
name|int
name|is_default
parameter_list|)
block|{
name|INSIST
argument_list|(
name|op
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|listen_list
operator|==
name|NULL
condition|)
block|{
name|ip_match_list
name|iml
decl_stmt|;
name|ip_match_element
name|ime
decl_stmt|;
name|struct
name|in_addr
name|address
decl_stmt|;
name|op
operator|->
name|listen_list
operator|=
name|new_listen_info_list
argument_list|()
expr_stmt|;
name|address
operator|.
name|s_addr
operator|=
name|htonl
argument_list|(
name|INADDR_ANY
argument_list|)
expr_stmt|;
name|iml
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|address
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|iml
argument_list|,
name|ime
argument_list|)
expr_stmt|;
name|add_listen_on
argument_list|(
name|op
argument_list|,
name|htons
argument_list|(
name|NS_DEFAULTPORT
argument_list|)
argument_list|,
name|iml
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|op
operator|->
name|topology
operator|==
name|NULL
condition|)
block|{
name|ip_match_list
name|iml
decl_stmt|;
name|ip_match_element
name|ime
decl_stmt|;
comment|/* default topology is { localhost; localnets; } */
name|iml
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
name|ime
operator|=
name|new_ip_match_localhost
argument_list|()
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|iml
argument_list|,
name|ime
argument_list|)
expr_stmt|;
name|ime
operator|=
name|new_ip_match_localnets
argument_list|()
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|iml
argument_list|,
name|ime
argument_list|)
expr_stmt|;
name|op
operator|->
name|topology
operator|=
name|iml
expr_stmt|;
block|}
if|if
condition|(
name|server_options
operator|!=
name|NULL
condition|)
name|free_options
argument_list|(
name|server_options
argument_list|)
expr_stmt|;
name|server_options
operator|=
name|op
expr_stmt|;
comment|/* XXX should validate pid filename */
name|INSIST
argument_list|(
name|op
operator|->
name|pid_filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|directory
operator|&&
operator|!
name|os_change_directory
argument_list|(
name|op
operator|->
name|directory
argument_list|)
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"can't change directory to %s: %s"
argument_list|,
name|op
operator|->
name|directory
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/* XXX currently a value of 0 means "use default"; it would be 	   better if the options block had a "attributes updated" vector 	   (like the way X deals with GC updates) */
if|if
condition|(
operator|!
name|op
operator|->
name|transfers_in
condition|)
name|op
operator|->
name|transfers_in
operator|=
name|DEFAULT_XFERS_RUNNING
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|transfers_in
operator|>
name|MAX_XFERS_RUNNING
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"the maximum number of concurrent inbound transfers is %d"
argument_list|,
name|MAX_XFERS_RUNNING
argument_list|)
expr_stmt|;
name|op
operator|->
name|transfers_in
operator|=
name|MAX_XFERS_RUNNING
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|op
operator|->
name|transfers_per_ns
condition|)
name|op
operator|->
name|transfers_per_ns
operator|=
name|DEFAULT_XFERS_PER_NS
expr_stmt|;
if|if
condition|(
operator|!
name|op
operator|->
name|max_transfer_time_in
condition|)
name|op
operator|->
name|max_transfer_time_in
operator|=
name|MAX_XFER_TIME
expr_stmt|;
comment|/* XXX currently transfers_out is not used */
if|if
condition|(
operator|!
name|op
operator|->
name|max_ncache_ttl
condition|)
name|op
operator|->
name|max_ncache_ttl
operator|=
name|DEFAULT_MAX_NCACHE_TTL
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|max_ncache_ttl
operator|>
name|max_cache_ttl
condition|)
name|op
operator|->
name|max_ncache_ttl
operator|=
name|max_cache_ttl
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|lame_ttl
operator|>
operator|(
literal|3
operator|*
name|NTTL
operator|)
condition|)
name|op
operator|->
name|lame_ttl
operator|=
literal|3
operator|*
name|NTTL
expr_stmt|;
comment|/* 	 * Limits 	 */
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
name|ns_rlimit
argument_list|(
name|Datasize
argument_list|,
name|op
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|ns_rlimit
argument_list|(
name|Stacksize
argument_list|,
name|op
operator|->
name|stack_size
argument_list|)
expr_stmt|;
name|ns_rlimit
argument_list|(
name|Coresize
argument_list|,
name|op
operator|->
name|core_size
argument_list|)
expr_stmt|;
name|ns_rlimit
argument_list|(
name|Files
argument_list|,
name|op
operator|->
name|files
argument_list|)
expr_stmt|;
else|#
directive|else
name|ns_info
argument_list|(
name|ns_log_config
argument_list|,
literal|"cannot set resource limits on this system"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Timers 	 */
name|set_interval_timer
argument_list|(
name|CLEAN_TIMER
argument_list|,
name|server_options
operator|->
name|clean_interval
argument_list|)
expr_stmt|;
name|set_interval_timer
argument_list|(
name|INTERFACE_TIMER
argument_list|,
name|server_options
operator|->
name|interface_interval
argument_list|)
expr_stmt|;
name|set_interval_timer
argument_list|(
name|STATS_TIMER
argument_list|,
name|server_options
operator|->
name|stats_interval
argument_list|)
expr_stmt|;
name|set_interval_timer
argument_list|(
name|HEARTBEAT_TIMER
argument_list|,
name|server_options
operator|->
name|heartbeat_interval
argument_list|)
expr_stmt|;
name|options_installed
operator|=
literal|1
expr_stmt|;
name|default_options_installed
operator|=
name|is_default
expr_stmt|;
block|}
end_function

begin_function
name|void
name|use_default_options
parameter_list|()
block|{
name|set_options
argument_list|(
name|new_options
argument_list|()
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * rrset order types  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|res_sym
name|order_table
index|[]
init|=
block|{
block|{
name|unknown_order
block|,
literal|" unknown "
block|}
block|,
comment|/* can't match */
block|{
name|fixed_order
block|,
literal|"fixed"
block|}
block|,
block|{
name|cyclic_order
block|,
literal|"cyclic"
block|}
block|,
block|{
name|random_order
block|,
literal|"random"
block|}
block|,
block|{
name|unknown_order
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Return the print name of the ordering value.  */
end_comment

begin_function
specifier|const
name|char
modifier|*
name|p_order
parameter_list|(
name|int
name|order
parameter_list|)
block|{
return|return
operator|(
name|__sym_ntos
argument_list|(
name|order_table
argument_list|,
name|order
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the ordering by name and return the matching enum value.  */
end_comment

begin_function
name|enum
name|ordering
name|lookup_ordering
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|order_table
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcasecmp
argument_list|(
name|name
argument_list|,
name|order_table
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
operator|(
expr|enum
name|ordering
operator|)
name|order_table
index|[
name|i
index|]
operator|.
name|number
operator|)
return|;
return|return
operator|(
name|unknown_order
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * rrset-order Lists  */
end_comment

begin_function
name|rrset_order_list
name|new_rrset_order_list
parameter_list|()
block|{
name|rrset_order_list
name|rol
decl_stmt|;
name|rol
operator|=
operator|(
name|rrset_order_list
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_order_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rol
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_rrset_order_list"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rol
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|rol
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|rol
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_rrset_order_list
parameter_list|(
name|rrset_order_list
name|rol
parameter_list|)
block|{
name|rrset_order_element
name|roe
decl_stmt|,
name|next_element
decl_stmt|;
for|for
control|(
name|roe
operator|=
name|rol
operator|->
name|first
init|;
name|roe
operator|!=
name|NULL
condition|;
name|roe
operator|=
name|next_element
control|)
block|{
name|next_element
operator|=
name|roe
operator|->
name|next
expr_stmt|;
name|freestr
argument_list|(
name|roe
operator|->
name|name
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|roe
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|roe
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|rol
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rol
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_to_rrset_order_list
parameter_list|(
name|rrset_order_list
name|rol
parameter_list|,
name|rrset_order_element
name|roe
parameter_list|)
block|{
name|INSIST
argument_list|(
name|rol
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|roe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rol
operator|->
name|last
operator|!=
name|NULL
condition|)
name|rol
operator|->
name|last
operator|->
name|next
operator|=
name|roe
expr_stmt|;
name|roe
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|rol
operator|->
name|last
operator|=
name|roe
expr_stmt|;
if|if
condition|(
name|rol
operator|->
name|first
operator|==
name|NULL
condition|)
name|rol
operator|->
name|first
operator|=
name|roe
expr_stmt|;
block|}
end_function

begin_comment
comment|/* XXX this isn't being used yet, but it probably should be. Where? */
end_comment

begin_function
name|void
name|dprint_rrset_order_list
parameter_list|(
name|int
name|category
parameter_list|,
name|rrset_order_list
name|rol
parameter_list|,
name|int
name|indent
parameter_list|,
name|char
modifier|*
name|allow
parameter_list|,
name|char
modifier|*
name|deny
parameter_list|)
block|{
name|rrset_order_element
name|roe
decl_stmt|;
name|char
name|spaces
index|[
literal|40
operator|+
literal|1
index|]
decl_stmt|;
name|INSIST
argument_list|(
name|rol
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|>
literal|40
condition|)
name|indent
operator|=
literal|40
expr_stmt|;
if|if
condition|(
name|indent
condition|)
name|memset
argument_list|(
name|spaces
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|spaces
index|[
name|indent
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|roe
operator|=
name|rol
operator|->
name|first
init|;
name|roe
operator|!=
name|NULL
condition|;
name|roe
operator|=
name|roe
operator|->
name|next
control|)
block|{
name|ns_debug
argument_list|(
name|category
argument_list|,
literal|7
argument_list|,
literal|"%sclass %s type %s name %s order %s"
argument_list|,
name|spaces
argument_list|,
name|p_class
argument_list|(
name|roe
operator|->
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|roe
operator|->
name|type
argument_list|)
argument_list|,
name|roe
operator|->
name|name
argument_list|,
name|p_order
argument_list|(
name|roe
operator|->
name|order
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|rrset_order_element
name|new_rrset_order_element
parameter_list|(
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|enum
name|ordering
name|order
parameter_list|)
block|{
name|rrset_order_element
name|roe
decl_stmt|;
name|int
name|i
decl_stmt|;
name|roe
operator|=
operator|(
name|rrset_order_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|rrset_order_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|roe
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_rrset_order_element"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|roe
operator|->
name|class
operator|=
name|class
expr_stmt|;
name|roe
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|roe
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|roe
operator|->
name|order
operator|=
name|order
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|roe
operator|->
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
name|INSIST
argument_list|(
name|i
operator|>=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|roe
operator|->
name|name
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* We compare from right to left so we don't need a dot on 		   the end. */
name|roe
operator|->
name|name
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|roe
return|;
block|}
end_function

begin_comment
comment|/*  * IP Matching Lists  */
end_comment

begin_function
name|ip_match_list
name|new_ip_match_list
parameter_list|()
block|{
name|ip_match_list
name|iml
decl_stmt|;
name|iml
operator|=
operator|(
name|ip_match_list
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_match_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|iml
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_ip_match_list"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|iml
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|iml
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|iml
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_ip_match_list
parameter_list|(
name|ip_match_list
name|iml
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|,
name|next_element
decl_stmt|;
for|for
control|(
name|ime
operator|=
name|iml
operator|->
name|first
init|;
name|ime
operator|!=
name|NULL
condition|;
name|ime
operator|=
name|next_element
control|)
block|{
name|next_element
operator|=
name|ime
operator|->
name|next
expr_stmt|;
name|memput
argument_list|(
name|ime
argument_list|,
sizeof|sizeof
expr|*
name|ime
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|iml
argument_list|,
sizeof|sizeof
expr|*
name|iml
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|ip_match_element
name|new_ip_match_pattern
parameter_list|(
name|struct
name|in_addr
name|address
parameter_list|,
name|u_int
name|mask_bits
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|u_int32_t
name|mask
decl_stmt|;
name|ime
operator|=
operator|(
name|ip_match_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_match_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ime
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_ip_match_pattern"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ime
operator|->
name|type
operator|=
name|ip_match_pattern
expr_stmt|;
name|ime
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
operator|=
name|address
expr_stmt|;
if|if
condition|(
name|mask_bits
operator|==
literal|0
condition|)
comment|/* can't shift>= the size of a type in bits, so  		   we deal with an empty mask here */
name|mask
operator|=
literal|0
expr_stmt|;
else|else
block|{
comment|/* set the 'mask_bits' most significant bits */
name|mask
operator|=
literal|0xffffffffU
expr_stmt|;
name|mask
operator|>>=
operator|(
literal|32
operator|-
name|mask_bits
operator|)
expr_stmt|;
name|mask
operator|<<=
operator|(
literal|32
operator|-
name|mask_bits
operator|)
expr_stmt|;
block|}
name|mask
operator|=
name|ntohl
argument_list|(
name|mask
argument_list|)
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
operator|.
name|s_addr
operator|=
name|mask
expr_stmt|;
name|ime
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ina_onnet
argument_list|(
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
argument_list|)
condition|)
block|{
name|memput
argument_list|(
name|ime
argument_list|,
sizeof|sizeof
expr|*
name|ime
argument_list|)
expr_stmt|;
name|ime
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ime
operator|)
return|;
block|}
end_function

begin_function
name|ip_match_element
name|new_ip_match_mask
parameter_list|(
name|struct
name|in_addr
name|address
parameter_list|,
name|struct
name|in_addr
name|mask
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|ime
operator|=
operator|(
name|ip_match_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_match_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ime
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_ip_match_pattern"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ime
operator|->
name|type
operator|=
name|ip_match_pattern
expr_stmt|;
name|ime
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
operator|=
name|address
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
operator|=
name|mask
expr_stmt|;
name|ime
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ina_onnet
argument_list|(
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
argument_list|)
condition|)
block|{
name|memput
argument_list|(
name|ime
argument_list|,
sizeof|sizeof
expr|*
name|ime
argument_list|)
expr_stmt|;
name|ime
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|ime
operator|)
return|;
block|}
end_function

begin_function
name|ip_match_element
name|new_ip_match_indirect
parameter_list|(
name|ip_match_list
name|iml
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|INSIST
argument_list|(
name|iml
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ime
operator|=
operator|(
name|ip_match_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_match_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ime
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_ip_match_indirect"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ime
operator|->
name|type
operator|=
name|ip_match_indirect
expr_stmt|;
name|ime
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|iml
expr_stmt|;
name|ime
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ime
operator|)
return|;
block|}
end_function

begin_function
name|ip_match_element
name|new_ip_match_key
parameter_list|(
name|DST_KEY
modifier|*
name|dst_key
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|ime
operator|=
operator|(
name|ip_match_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_match_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ime
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_ip_match_key"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ime
operator|->
name|type
operator|=
name|ip_match_key
expr_stmt|;
name|ime
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|key
operator|.
name|key
operator|=
name|dst_key
expr_stmt|;
return|return
operator|(
name|ime
operator|)
return|;
block|}
end_function

begin_function
name|ip_match_element
name|new_ip_match_localhost
parameter_list|()
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|ime
operator|=
operator|(
name|ip_match_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_match_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ime
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_ip_match_localhost"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ime
operator|->
name|type
operator|=
name|ip_match_localhost
expr_stmt|;
name|ime
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|ime
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ime
operator|)
return|;
block|}
end_function

begin_function
name|ip_match_element
name|new_ip_match_localnets
parameter_list|()
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|ime
operator|=
operator|(
name|ip_match_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|ip_match_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ime
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_ip_match_localnets"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ime
operator|->
name|type
operator|=
name|ip_match_localnets
expr_stmt|;
name|ime
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|NULL
expr_stmt|;
name|ime
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|ime
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ip_match_negate
parameter_list|(
name|ip_match_element
name|ime
parameter_list|)
block|{
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
name|ime
operator|->
name|flags
operator|&=
operator|~
name|IP_MATCH_NEGATE
expr_stmt|;
else|else
name|ime
operator|->
name|flags
operator||=
name|IP_MATCH_NEGATE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_to_ip_match_list
parameter_list|(
name|ip_match_list
name|iml
parameter_list|,
name|ip_match_element
name|ime
parameter_list|)
block|{
name|INSIST
argument_list|(
name|iml
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ime
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|iml
operator|->
name|last
operator|!=
name|NULL
condition|)
name|iml
operator|->
name|last
operator|->
name|next
operator|=
name|ime
expr_stmt|;
name|ime
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|iml
operator|->
name|last
operator|=
name|ime
expr_stmt|;
if|if
condition|(
name|iml
operator|->
name|first
operator|==
name|NULL
condition|)
name|iml
operator|->
name|first
operator|=
name|ime
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dprint_ip_match_list
parameter_list|(
name|int
name|category
parameter_list|,
name|ip_match_list
name|iml
parameter_list|,
name|int
name|indent
parameter_list|,
name|char
modifier|*
name|allow
parameter_list|,
name|char
modifier|*
name|deny
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|char
name|spaces
index|[
literal|40
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|addr_text
index|[
sizeof|sizeof
expr|"255.255.255.255"]
expr_stmt|;
name|char
name|mask_text
index|[
sizeof|sizeof
expr|"255.255.255.255"]
expr_stmt|;
name|INSIST
argument_list|(
name|iml
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|>
literal|40
condition|)
name|indent
operator|=
literal|40
expr_stmt|;
if|if
condition|(
name|indent
condition|)
name|memset
argument_list|(
name|spaces
argument_list|,
literal|' '
argument_list|,
name|indent
argument_list|)
expr_stmt|;
name|spaces
index|[
name|indent
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|ime
operator|=
name|iml
operator|->
name|first
init|;
name|ime
operator|!=
name|NULL
condition|;
name|ime
operator|=
name|ime
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|ime
operator|->
name|type
condition|)
block|{
case|case
name|ip_match_pattern
case|:
name|memset
argument_list|(
name|addr_text
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|addr_text
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|addr_text
argument_list|,
name|inet_ntoa
argument_list|(
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
argument_list|)
argument_list|,
operator|(
operator|(
sizeof|sizeof
name|addr_text
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|mask_text
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|mask_text
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|mask_text
argument_list|,
name|inet_ntoa
argument_list|(
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
argument_list|)
argument_list|,
operator|(
operator|(
sizeof|sizeof
name|mask_text
operator|)
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|category
argument_list|,
literal|7
argument_list|,
literal|"%s%saddr: %s, mask: %s"
argument_list|,
name|spaces
argument_list|,
operator|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
operator|)
condition|?
name|deny
else|:
name|allow
argument_list|,
name|addr_text
argument_list|,
name|mask_text
argument_list|)
expr_stmt|;
break|break;
case|case
name|ip_match_localhost
case|:
name|ns_debug
argument_list|(
name|category
argument_list|,
literal|7
argument_list|,
literal|"%s%slocalhost"
argument_list|,
name|spaces
argument_list|,
operator|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
operator|)
condition|?
name|deny
else|:
name|allow
argument_list|)
expr_stmt|;
break|break;
case|case
name|ip_match_localnets
case|:
name|ns_debug
argument_list|(
name|category
argument_list|,
literal|7
argument_list|,
literal|"%s%slocalnets"
argument_list|,
name|spaces
argument_list|,
operator|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
operator|)
condition|?
name|deny
else|:
name|allow
argument_list|)
expr_stmt|;
break|break;
case|case
name|ip_match_indirect
case|:
name|ns_debug
argument_list|(
name|category
argument_list|,
literal|7
argument_list|,
literal|"%s%sindirect list %p"
argument_list|,
name|spaces
argument_list|,
operator|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
operator|)
condition|?
name|deny
else|:
name|allow
argument_list|,
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|!=
name|NULL
condition|)
name|dprint_ip_match_list
argument_list|(
name|category
argument_list|,
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
argument_list|,
name|indent
operator|+
literal|2
argument_list|,
name|allow
argument_list|,
name|deny
argument_list|)
expr_stmt|;
break|break;
case|case
name|ip_match_key
case|:
name|ns_debug
argument_list|(
name|category
argument_list|,
literal|7
argument_list|,
literal|"%s%skey %s"
argument_list|,
name|spaces
argument_list|,
operator|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
operator|)
condition|?
name|deny
else|:
name|allow
argument_list|,
name|ime
operator|->
name|u
operator|.
name|key
operator|.
name|key
operator|->
name|dk_key_name
argument_list|)
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unexpected ime type in dprint_ip_match_list()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|int
name|ip_match_addr_or_key
parameter_list|(
name|ip_match_list
name|iml
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|,
name|DST_KEY
modifier|*
name|key
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|indirect
decl_stmt|;
name|INSIST
argument_list|(
name|iml
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ime
operator|=
name|iml
operator|->
name|first
init|;
name|ime
operator|!=
name|NULL
condition|;
name|ime
operator|=
name|ime
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|ime
operator|->
name|type
condition|)
block|{
case|case
name|ip_match_pattern
case|:
name|indirect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ip_match_indirect
case|:
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_localhost
case|:
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|local_addresses
expr_stmt|;
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_localnets
case|:
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|local_networks
expr_stmt|;
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_key
case|:
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|indirect
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
if|if
condition|(
name|ns_samename
argument_list|(
name|ime
operator|->
name|u
operator|.
name|key
operator|.
name|key
operator|->
name|dk_key_name
argument_list|,
name|key
operator|->
name|dk_key_name
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
continue|continue;
block|}
default|default:
name|panic
argument_list|(
literal|"unexpected ime type in ip_match_addr_or_key()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirect
condition|)
block|{
name|ret
operator|=
name|ip_match_addr_or_key
argument_list|(
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
argument_list|,
name|address
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
name|ret
operator|=
operator|(
name|ret
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ina_onnet
argument_list|(
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
argument_list|)
condition|)
block|{
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ip_match_address
parameter_list|(
name|ip_match_list
name|iml
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
return|return
name|ip_match_addr_or_key
argument_list|(
name|iml
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|ip_addr_or_key_allowed
parameter_list|(
name|ip_match_list
name|iml
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|,
name|DST_KEY
modifier|*
name|key
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|iml
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ret
operator|=
name|ip_match_addr_or_key
argument_list|(
name|iml
argument_list|,
name|address
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
name|ret
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ip_address_allowed
parameter_list|(
name|ip_match_list
name|iml
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
return|return
operator|(
name|ip_addr_or_key_allowed
argument_list|(
name|iml
argument_list|,
name|address
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ip_match_network
parameter_list|(
name|ip_match_list
name|iml
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|,
name|struct
name|in_addr
name|mask
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|indirect
decl_stmt|;
name|INSIST
argument_list|(
name|iml
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|ime
operator|=
name|iml
operator|->
name|first
init|;
name|ime
operator|!=
name|NULL
condition|;
name|ime
operator|=
name|ime
operator|->
name|next
control|)
block|{
switch|switch
condition|(
name|ime
operator|->
name|type
condition|)
block|{
case|case
name|ip_match_pattern
case|:
name|indirect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ip_match_indirect
case|:
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_localhost
case|:
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|local_addresses
expr_stmt|;
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_localnets
case|:
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|local_networks
expr_stmt|;
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_key
case|:
name|indirect
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|indirect
operator|=
literal|0
expr_stmt|;
comment|/* Make gcc happy. */
name|panic
argument_list|(
literal|"unexpected ime type in ip_match_network()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirect
condition|)
block|{
name|ret
operator|=
name|ip_match_network
argument_list|(
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
argument_list|,
name|address
argument_list|,
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
name|ret
operator|=
operator|(
name|ret
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|address
operator|.
name|s_addr
operator|==
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
operator|.
name|s_addr
operator|&&
name|mask
operator|.
name|s_addr
operator|==
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
operator|.
name|s_addr
condition|)
block|{
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|distance_of_address
parameter_list|(
name|ip_match_list
name|iml
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|int
name|indirect
decl_stmt|;
name|int
name|distance
decl_stmt|;
name|INSIST
argument_list|(
name|iml
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|distance
operator|=
literal|1
operator|,
name|ime
operator|=
name|iml
operator|->
name|first
init|;
name|ime
operator|!=
name|NULL
condition|;
name|ime
operator|=
name|ime
operator|->
name|next
operator|,
name|distance
operator|++
control|)
block|{
switch|switch
condition|(
name|ime
operator|->
name|type
condition|)
block|{
case|case
name|ip_match_pattern
case|:
name|indirect
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ip_match_indirect
case|:
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_localhost
case|:
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|local_addresses
expr_stmt|;
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_localnets
case|:
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
operator|=
name|local_networks
expr_stmt|;
name|indirect
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ip_match_key
case|:
name|indirect
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
name|indirect
operator|=
literal|0
expr_stmt|;
comment|/* Make gcc happy. */
name|panic
argument_list|(
literal|"unexpected ime type in distance_of_address()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indirect
condition|)
block|{
name|ret
operator|=
name|ip_match_address
argument_list|(
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
argument_list|,
name|address
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
name|ret
operator|=
operator|(
name|ret
operator|)
condition|?
literal|0
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|distance
operator|>
name|MAX_TOPOLOGY_DISTANCE
condition|)
name|distance
operator|=
name|MAX_TOPOLOGY_DISTANCE
expr_stmt|;
if|if
condition|(
name|ret
condition|)
return|return
operator|(
name|distance
operator|)
return|;
else|else
return|return
operator|(
name|MAX_TOPOLOGY_DISTANCE
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ina_onnet
argument_list|(
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
argument_list|,
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
argument_list|)
condition|)
block|{
if|if
condition|(
name|distance
operator|>
name|MAX_TOPOLOGY_DISTANCE
condition|)
name|distance
operator|=
name|MAX_TOPOLOGY_DISTANCE
expr_stmt|;
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
return|return
operator|(
name|MAX_TOPOLOGY_DISTANCE
operator|)
return|;
else|else
return|return
operator|(
name|distance
operator|)
return|;
block|}
block|}
block|}
return|return
operator|(
name|UNKNOWN_TOPOLOGY_DISTANCE
operator|)
return|;
block|}
end_function

begin_function
name|int
name|ip_match_is_none
parameter_list|(
name|ip_match_list
name|iml
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
if|if
condition|(
operator|(
name|iml
operator|==
name|NULL
operator|)
operator|||
operator|(
name|iml
operator|->
name|first
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ime
operator|=
name|iml
operator|->
name|first
expr_stmt|;
if|if
condition|(
name|ime
operator|->
name|type
operator|==
name|ip_match_indirect
condition|)
block|{
if|if
condition|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|iml
operator|=
name|ime
operator|->
name|u
operator|.
name|indirect
operator|.
name|list
expr_stmt|;
if|if
condition|(
operator|(
name|iml
operator|==
name|NULL
operator|)
operator|||
operator|(
name|iml
operator|->
name|first
operator|==
name|NULL
operator|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ime
operator|=
name|iml
operator|->
name|first
expr_stmt|;
block|}
if|if
condition|(
name|ime
operator|->
name|type
operator|==
name|ip_match_pattern
condition|)
block|{
if|if
condition|(
operator|(
name|ime
operator|->
name|flags
operator|&
name|IP_MATCH_NEGATE
operator|)
operator|&&
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|address
operator|.
name|s_addr
operator|==
literal|0
operator|&&
name|ime
operator|->
name|u
operator|.
name|direct
operator|.
name|mask
operator|.
name|s_addr
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find_forwarder finds the fwddata structure for an address,  * allocating one if we can't find one already existing.  */
end_comment

begin_function
specifier|static
name|struct
name|fwddata
modifier|*
name|find_forwarder
parameter_list|(
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|struct
name|fwddata
modifier|*
name|fdp
decl_stmt|;
name|struct
name|fwddata
modifier|*
modifier|*
name|fdpp
init|=
name|NULL
decl_stmt|;
name|struct
name|databuf
modifier|*
name|ns
decl_stmt|,
modifier|*
name|nsdata
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fwddata_count
condition|;
name|i
operator|++
control|)
block|{
name|fdp
operator|=
name|fwddata
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|fdp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|fdpp
operator|==
name|NULL
condition|)
name|fdpp
operator|=
operator|&
name|fwddata
index|[
name|i
index|]
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|memcmp
argument_list|(
operator|&
name|fdp
operator|->
name|fwdaddr
operator|.
name|sin_addr
argument_list|,
operator|&
name|address
argument_list|,
sizeof|sizeof
argument_list|(
name|address
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fdp
operator|->
name|ref_count
operator|++
expr_stmt|;
return|return
operator|(
name|fdp
operator|)
return|;
block|}
block|}
name|fdp
operator|=
operator|(
expr|struct
name|fwddata
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fwddata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fdp
condition|)
name|panic
argument_list|(
literal|"memget failed in find_forwarder"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fdp
operator|->
name|fwdaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|fdp
operator|->
name|fwdaddr
operator|.
name|sin_addr
operator|=
name|address
expr_stmt|;
name|fdp
operator|->
name|fwdaddr
operator|.
name|sin_port
operator|=
name|ns_port
expr_stmt|;
name|ns
operator|=
name|fdp
operator|->
name|ns
operator|=
operator|(
expr|struct
name|databuf
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|ns
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns
condition|)
name|panic
argument_list|(
literal|"memget failed in find_forwarder"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|ns
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ns
argument_list|)
argument_list|)
expr_stmt|;
name|nsdata
operator|=
name|fdp
operator|->
name|nsdata
operator|=
operator|(
expr|struct
name|databuf
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|nsdata
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nsdata
condition|)
name|panic
argument_list|(
literal|"memget failed in find_forwarder"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|nsdata
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|nsdata
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|->
name|d_type
operator|=
name|T_NS
expr_stmt|;
name|ns
operator|->
name|d_class
operator|=
name|C_IN
expr_stmt|;
name|ns
operator|->
name|d_rcnt
operator|=
literal|1
expr_stmt|;
name|nsdata
operator|->
name|d_type
operator|=
name|T_A
expr_stmt|;
name|nsdata
operator|->
name|d_class
operator|=
name|C_IN
expr_stmt|;
name|nsdata
operator|->
name|d_nstime
operator|=
literal|1
operator|+
call|(
name|int
call|)
argument_list|(
literal|25.0
operator|*
name|rand
argument_list|()
operator|/
operator|(
name|RAND_MAX
operator|+
literal|1.0
operator|)
argument_list|)
expr_stmt|;
name|nsdata
operator|->
name|d_rcnt
operator|=
literal|1
expr_stmt|;
name|fdp
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fdpp
operator|!=
name|NULL
condition|)
block|{
operator|*
name|fdpp
operator|=
name|fdp
expr_stmt|;
return|return
operator|(
name|fdp
operator|)
return|;
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|fwddata
operator|==
name|NULL
condition|)
block|{
name|fwddata
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|fwddata
argument_list|)
expr_stmt|;
if|if
condition|(
name|fwddata
operator|==
name|NULL
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|struct
name|fwddata
modifier|*
modifier|*
name|an_tmp
decl_stmt|;
name|size
operator|=
name|fwddata_count
operator|*
sizeof|sizeof
expr|*
name|fwddata
expr_stmt|;
name|an_tmp
operator|=
name|memget
argument_list|(
name|size
operator|+
sizeof|sizeof
expr|*
name|fwddata
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_tmp
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|an_tmp
argument_list|,
name|fwddata
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|fwddata
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|fwddata
operator|=
name|an_tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fwddata
index|[
name|fwddata_count
index|]
operator|=
name|fdp
expr_stmt|;
name|fwddata_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"forwarder add failed (memget) [%s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fdp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Forwarder glue  *  * XXX  This will go away when the rest of bind understands   *      forward zones.  */
end_comment

begin_function
specifier|static
name|void
name|add_forwarder
parameter_list|(
name|struct
name|fwdinfo
modifier|*
modifier|*
name|fipp
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|struct
name|fwdinfo
modifier|*
name|fip
init|=
operator|*
name|fipp
decl_stmt|,
modifier|*
name|ftp
init|=
name|NULL
decl_stmt|;
name|struct
name|fwddata
modifier|*
name|fdp
decl_stmt|;
ifdef|#
directive|ifdef
name|FWD_LOOP
if|if
condition|(
name|aIsUs
argument_list|(
name|address
argument_list|)
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"forwarder '%s' ignored, my address"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* FWD_LOOP */
comment|/* On multiple forwarder lines, move to end of the list. */
while|while
condition|(
name|fip
operator|!=
name|NULL
operator|&&
name|fip
operator|->
name|next
operator|!=
name|NULL
condition|)
name|fip
operator|=
name|fip
operator|->
name|next
expr_stmt|;
name|fdp
operator|=
name|find_forwarder
argument_list|(
name|address
argument_list|)
expr_stmt|;
name|ftp
operator|=
operator|(
expr|struct
name|fwdinfo
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|fwdinfo
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ftp
condition|)
name|panic
argument_list|(
literal|"memget failed in add_forwarder"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ftp
operator|->
name|fwddata
operator|=
name|fdp
expr_stmt|;
name|ftp
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fip
operator|==
name|NULL
condition|)
operator|*
name|fipp
operator|=
name|ftp
expr_stmt|;
comment|/* First time only */
else|else
name|fip
operator|->
name|next
operator|=
name|ftp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_also_notify
parameter_list|(
name|options
name|op
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|memput
argument_list|(
name|op
operator|->
name|also_notify
argument_list|,
name|op
operator|->
name|notify_count
operator|*
sizeof|sizeof
expr|*
name|op
operator|->
name|also_notify
argument_list|)
expr_stmt|;
name|op
operator|->
name|also_notify
operator|=
name|NULL
expr_stmt|;
name|op
operator|->
name|notify_count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|int
name|add_global_also_notify
parameter_list|(
name|options
name|op
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|BIND_NOTIFY
name|int
name|i
decl_stmt|;
name|INSIST
argument_list|(
name|op
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|2
argument_list|,
literal|"adding global notify %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for duplicates. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|op
operator|->
name|notify_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|memcmp
argument_list|(
name|op
operator|->
name|also_notify
operator|+
name|i
argument_list|,
operator|&
name|address
argument_list|,
sizeof|sizeof
name|address
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"duplicate global also-notify address ignored [%s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|i
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|also_notify
operator|==
name|NULL
condition|)
block|{
name|op
operator|->
name|also_notify
operator|=
name|memget
argument_list|(
sizeof|sizeof
expr|*
name|op
operator|->
name|also_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|also_notify
operator|==
name|NULL
condition|)
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|size_t
name|size
decl_stmt|;
specifier|register
name|struct
name|in_addr
modifier|*
name|an_tmp
decl_stmt|;
name|size
operator|=
name|op
operator|->
name|notify_count
operator|*
sizeof|sizeof
expr|*
name|op
operator|->
name|also_notify
expr_stmt|;
name|an_tmp
operator|=
name|memget
argument_list|(
name|size
operator|+
sizeof|sizeof
expr|*
name|op
operator|->
name|also_notify
argument_list|)
expr_stmt|;
if|if
condition|(
name|an_tmp
operator|==
name|NULL
condition|)
block|{
name|i
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|an_tmp
argument_list|,
name|op
operator|->
name|also_notify
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|op
operator|->
name|also_notify
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|op
operator|->
name|also_notify
operator|=
name|an_tmp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|op
operator|->
name|also_notify
index|[
name|op
operator|->
name|notify_count
index|]
operator|=
name|address
expr_stmt|;
name|op
operator|->
name|notify_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"global also-notify add failed (memget) [%s]"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|add_global_forwarder
parameter_list|(
name|options
name|op
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|INSIST
argument_list|(
name|op
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|2
argument_list|,
literal|"adding default forwarder %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|)
expr_stmt|;
name|add_forwarder
argument_list|(
operator|&
name|op
operator|->
name|fwdtab
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_zone_forward
parameter_list|(
name|zone_config
name|zh
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_FORWARD_SET
expr_stmt|;
name|set_zone_boolean_option
argument_list|(
name|zh
argument_list|,
name|OPTION_FORWARD_ONLY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_zone_forwarder
parameter_list|(
name|zone_config
name|zh
parameter_list|,
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|char
modifier|*
name|zname
decl_stmt|;
name|zp
operator|=
name|zh
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|zp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zname
operator|=
operator|(
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|2
argument_list|,
literal|"adding forwarder %s for zone zone '%s'"
argument_list|,
name|inet_ntoa
argument_list|(
name|address
argument_list|)
argument_list|,
name|zname
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_flags
operator||=
name|Z_FORWARD_SET
expr_stmt|;
name|add_forwarder
argument_list|(
operator|&
name|zp
operator|->
name|z_fwdtab
argument_list|,
name|address
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|free_forwarders
parameter_list|(
name|struct
name|fwdinfo
modifier|*
name|fwdtab
parameter_list|)
block|{
name|struct
name|fwdinfo
modifier|*
name|ftp
decl_stmt|,
modifier|*
name|fnext
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|ftp
operator|=
name|fwdtab
init|;
name|ftp
operator|!=
name|NULL
condition|;
name|ftp
operator|=
name|fnext
control|)
block|{
name|fnext
operator|=
name|ftp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|--
name|ftp
operator|->
name|fwddata
operator|->
name|ref_count
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fwddata_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|fwddata
index|[
name|i
index|]
operator|==
name|ftp
operator|->
name|fwddata
condition|)
block|{
name|fwddata
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|memput
argument_list|(
name|ftp
operator|->
name|fwddata
operator|->
name|ns
argument_list|,
sizeof|sizeof
expr|*
name|ftp
operator|->
name|fwddata
operator|->
name|ns
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ftp
operator|->
name|fwddata
operator|->
name|nsdata
argument_list|,
sizeof|sizeof
expr|*
name|ftp
operator|->
name|fwddata
operator|->
name|nsdata
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|ftp
operator|->
name|fwddata
argument_list|,
sizeof|sizeof
expr|*
name|ftp
operator|->
name|fwddata
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|ftp
argument_list|,
sizeof|sizeof
expr|*
name|ftp
argument_list|)
expr_stmt|;
block|}
name|fwdtab
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Servers   */
end_comment

begin_function
specifier|static
name|server_info
name|new_server
parameter_list|(
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
name|si
operator|=
operator|(
name|server_info
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|server_info
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_server()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|si
operator|->
name|address
operator|=
name|address
expr_stmt|;
name|si
operator|->
name|flags
operator|=
literal|0U
expr_stmt|;
name|si
operator|->
name|transfers
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|transfer_format
operator|=
name|axfr_use_default
expr_stmt|;
name|si
operator|->
name|key_list
operator|=
name|NULL
expr_stmt|;
name|si
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|server_options
operator|->
name|flags
operator|&
name|OPTION_MAINTAIN_IXFR_BASE
condition|)
name|si
operator|->
name|flags
operator||=
name|SERVER_INFO_SUPPORT_IXFR
expr_stmt|;
else|else
name|si
operator|->
name|flags
operator|&=
operator|~
name|SERVER_INFO_SUPPORT_IXFR
expr_stmt|;
return|return
operator|(
name|si
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_server
parameter_list|(
name|server_info
name|si
parameter_list|)
block|{
comment|/* Don't free key; it'll be done when the auth table is freed. */
name|memput
argument_list|(
name|si
argument_list|,
sizeof|sizeof
expr|*
name|si
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|server_info
name|find_server
parameter_list|(
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
for|for
control|(
name|si
operator|=
name|nameserver_info
init|;
name|si
operator|!=
name|NULL
condition|;
name|si
operator|=
name|si
operator|->
name|next
control|)
if|if
condition|(
name|si
operator|->
name|address
operator|.
name|s_addr
operator|==
name|address
operator|.
name|s_addr
condition|)
break|break;
return|return
operator|(
name|si
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_server
parameter_list|(
name|server_info
name|si
parameter_list|)
block|{
name|ip_match_element
name|ime
decl_stmt|;
name|si
operator|->
name|next
operator|=
name|nameserver_info
expr_stmt|;
name|nameserver_info
operator|=
name|si
expr_stmt|;
comment|/* 	 * To ease transition, we'll add bogus nameservers to an 	 * ip matching list.  This will probably be redone when the 	 * merging of nameserver data structures occurs. 	 */
if|if
condition|(
name|si
operator|->
name|flags
operator|&
name|SERVER_INFO_BOGUS
condition|)
block|{
name|ime
operator|=
name|new_ip_match_pattern
argument_list|(
name|si
operator|->
name|address
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|ime
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|add_to_ip_match_list
argument_list|(
name|bogus_nameservers
argument_list|,
name|ime
argument_list|)
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"server %s: flags %08x transfers %d"
argument_list|,
name|inet_ntoa
argument_list|(
name|si
operator|->
name|address
argument_list|)
argument_list|,
name|si
operator|->
name|flags
argument_list|,
name|si
operator|->
name|transfers
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|key_list
operator|!=
name|NULL
condition|)
name|dprint_key_info_list
argument_list|(
name|si
operator|->
name|key_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_nameserver_info
parameter_list|()
block|{
name|server_info
name|si_next
decl_stmt|,
name|si
decl_stmt|;
for|for
control|(
name|si
operator|=
name|nameserver_info
init|;
name|si
operator|!=
name|NULL
condition|;
name|si
operator|=
name|si_next
control|)
block|{
name|si_next
operator|=
name|si
operator|->
name|next
expr_stmt|;
name|free_server
argument_list|(
name|si
argument_list|)
expr_stmt|;
block|}
name|nameserver_info
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bogus_nameservers
operator|!=
name|NULL
condition|)
block|{
name|free_ip_match_list
argument_list|(
name|bogus_nameservers
argument_list|)
expr_stmt|;
name|bogus_nameservers
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|free_secretkey_info
parameter_list|()
block|{
if|if
condition|(
name|secretkey_info
operator|!=
name|NULL
condition|)
block|{
name|free_key_info_list
argument_list|(
name|secretkey_info
argument_list|)
expr_stmt|;
name|secretkey_info
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_function
name|server_config
name|begin_server
parameter_list|(
name|struct
name|in_addr
name|address
parameter_list|)
block|{
name|server_config
name|sc
decl_stmt|;
name|sc
operator|.
name|opaque
operator|=
name|new_server
argument_list|(
name|address
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|end_server
parameter_list|(
name|server_config
name|sc
parameter_list|,
name|int
name|should_install
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
name|si
operator|=
name|sc
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|si
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|should_install
condition|)
name|add_server
argument_list|(
name|si
argument_list|)
expr_stmt|;
else|else
name|free_server
argument_list|(
name|si
argument_list|)
expr_stmt|;
name|sc
operator|.
name|opaque
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_server_option
parameter_list|(
name|server_config
name|sc
parameter_list|,
name|int
name|bool_opt
parameter_list|,
name|int
name|value
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
name|si
operator|=
name|sc
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|si
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|bool_opt
condition|)
block|{
case|case
name|SERVER_INFO_BOGUS
case|:
case|case
name|SERVER_INFO_SUPPORT_IXFR
case|:
if|if
condition|(
name|value
condition|)
name|si
operator|->
name|flags
operator||=
name|bool_opt
expr_stmt|;
else|else
name|si
operator|->
name|flags
operator|&=
operator|~
name|bool_opt
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unexpected option in set_server_option"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|set_server_transfers
parameter_list|(
name|server_config
name|sc
parameter_list|,
name|int
name|transfers
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
name|si
operator|=
name|sc
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|si
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|transfers
operator|<
literal|0
condition|)
name|transfers
operator|=
literal|0
expr_stmt|;
name|si
operator|->
name|transfers
operator|=
name|transfers
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_server_transfer_format
parameter_list|(
name|server_config
name|sc
parameter_list|,
name|enum
name|axfr_format
name|transfer_format
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
name|si
operator|=
name|sc
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|si
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|si
operator|->
name|transfer_format
operator|=
name|transfer_format
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_server_key_info
parameter_list|(
name|server_config
name|sc
parameter_list|,
name|DST_KEY
modifier|*
name|dst_key
parameter_list|)
block|{
name|server_info
name|si
decl_stmt|;
name|si
operator|=
name|sc
operator|.
name|opaque
expr_stmt|;
name|INSIST
argument_list|(
name|si
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|si
operator|->
name|key_list
operator|==
name|NULL
condition|)
name|si
operator|->
name|key_list
operator|=
name|new_key_info_list
argument_list|()
expr_stmt|;
name|add_to_key_info_list
argument_list|(
name|si
operator|->
name|key_list
argument_list|,
name|dst_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Keys  */
end_comment

begin_function
name|DST_KEY
modifier|*
name|new_key_info
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|algorithm
parameter_list|,
name|char
modifier|*
name|secret
parameter_list|)
block|{
name|DST_KEY
modifier|*
name|dst_key
decl_stmt|;
name|int
name|alg
decl_stmt|,
name|blen
decl_stmt|;
name|u_char
name|buffer
index|[
literal|1024
index|]
decl_stmt|;
name|INSIST
argument_list|(
name|name
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|algorithm
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|secret
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|alg
operator|=
name|tsig_alg_value
argument_list|(
name|algorithm
argument_list|)
expr_stmt|;
if|if
condition|(
name|alg
operator|==
operator|-
literal|1
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"Unsupported TSIG algorithm %s"
argument_list|,
name|algorithm
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|blen
operator|=
name|b64_pton
argument_list|(
name|secret
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|blen
operator|<
literal|0
condition|)
block|{
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"Invalid TSIG secret \"%s\""
argument_list|,
name|secret
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|dst_key
operator|=
name|dst_buffer_to_key
argument_list|(
name|name
argument_list|,
name|alg
argument_list|,
name|NS_KEY_TYPE_AUTH_ONLY
operator||
name|NS_KEY_NAME_ENTITY
argument_list|,
name|NS_KEY_PROT_ANY
argument_list|,
name|buffer
argument_list|,
name|blen
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_key
operator|==
name|NULL
condition|)
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"dst_buffer_to_key failed in new_key_info"
argument_list|)
expr_stmt|;
return|return
operator|(
name|dst_key
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_key_info
parameter_list|(
name|DST_KEY
modifier|*
name|dst_key
parameter_list|)
block|{
name|INSIST
argument_list|(
name|dst_key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dst_free_key
argument_list|(
name|dst_key
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|DST_KEY
modifier|*
name|find_key
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|algorithm
parameter_list|)
block|{
name|key_list_element
name|ke
decl_stmt|;
if|if
condition|(
name|secretkey_info
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|ke
operator|=
name|secretkey_info
operator|->
name|first
init|;
name|ke
operator|!=
name|NULL
condition|;
name|ke
operator|=
name|ke
operator|->
name|next
control|)
block|{
name|DST_KEY
modifier|*
name|dst_key
init|=
name|ke
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|ns_samename
argument_list|(
name|name
argument_list|,
name|dst_key
operator|->
name|dk_key_name
argument_list|)
operator|!=
literal|1
condition|)
continue|continue;
if|if
condition|(
name|algorithm
operator|==
name|NULL
operator|||
name|dst_key
operator|->
name|dk_alg
operator|==
name|tsig_alg_value
argument_list|(
name|algorithm
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|ke
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
return|return
operator|(
name|ke
operator|->
name|key
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dprint_key_info
parameter_list|(
name|DST_KEY
modifier|*
name|dst_key
parameter_list|)
block|{
name|INSIST
argument_list|(
name|dst_key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|7
argument_list|,
literal|"key %s"
argument_list|,
name|dst_key
operator|->
name|dk_key_name
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|7
argument_list|,
literal|"  algorithm %d"
argument_list|,
name|dst_key
operator|->
name|dk_alg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|key_info_list
name|new_key_info_list
parameter_list|()
block|{
name|key_info_list
name|kil
decl_stmt|;
name|kil
operator|=
operator|(
name|key_info_list
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|key_info_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kil
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in new_key_info_list()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kil
operator|->
name|first
operator|=
name|NULL
expr_stmt|;
name|kil
operator|->
name|last
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|kil
operator|)
return|;
block|}
end_function

begin_function
name|void
name|free_key_info_list
parameter_list|(
name|key_info_list
name|kil
parameter_list|)
block|{
name|key_list_element
name|kle
decl_stmt|,
name|kle_next
decl_stmt|;
name|INSIST
argument_list|(
name|kil
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|kle
operator|=
name|kil
operator|->
name|first
init|;
name|kle
operator|!=
name|NULL
condition|;
name|kle
operator|=
name|kle_next
control|)
block|{
name|kle_next
operator|=
name|kle
operator|->
name|next
expr_stmt|;
comment|/* note we do NOT free kle->info */
name|memput
argument_list|(
name|kle
argument_list|,
sizeof|sizeof
expr|*
name|kle
argument_list|)
expr_stmt|;
block|}
name|memput
argument_list|(
name|kil
argument_list|,
sizeof|sizeof
expr|*
name|kil
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_to_key_info_list
parameter_list|(
name|key_info_list
name|kil
parameter_list|,
name|DST_KEY
modifier|*
name|dst_key
parameter_list|)
block|{
name|key_list_element
name|kle
decl_stmt|;
name|INSIST
argument_list|(
name|kil
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|INSIST
argument_list|(
name|dst_key
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|kle
operator|=
operator|(
name|key_list_element
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|key_list_element
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kle
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"memget failed in add_to_key_info_list()"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kle
operator|->
name|key
operator|=
name|dst_key
expr_stmt|;
if|if
condition|(
name|kil
operator|->
name|last
operator|!=
name|NULL
condition|)
name|kil
operator|->
name|last
operator|->
name|next
operator|=
name|kle
expr_stmt|;
name|kle
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|kil
operator|->
name|last
operator|=
name|kle
expr_stmt|;
if|if
condition|(
name|kil
operator|->
name|first
operator|==
name|NULL
condition|)
name|kil
operator|->
name|first
operator|=
name|kle
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dprint_key_info_list
parameter_list|(
name|key_info_list
name|kil
parameter_list|)
block|{
name|key_list_element
name|kle
decl_stmt|;
name|INSIST
argument_list|(
name|kil
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|kle
operator|=
name|kil
operator|->
name|first
init|;
name|kle
operator|!=
name|NULL
condition|;
name|kle
operator|=
name|kle
operator|->
name|next
control|)
name|dprint_key_info
argument_list|(
name|kle
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Logging.  */
end_comment

begin_function
name|log_config
name|begin_logging
parameter_list|()
block|{
name|log_config
name|log_cfg
decl_stmt|;
name|log_context
name|lc
decl_stmt|;
name|log_cfg
operator|=
operator|(
name|log_config
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|log_config
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_cfg
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"memget failed creating log_config"
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_new_context
argument_list|(
name|ns_log_max_category
argument_list|,
name|logging_categories
argument_list|,
operator|&
name|lc
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"log_new_context() failed: %s"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|log_cfg
operator|->
name|log_ctx
operator|=
name|lc
expr_stmt|;
name|log_cfg
operator|->
name|eventlib_channel
operator|=
name|NULL
expr_stmt|;
name|log_cfg
operator|->
name|packet_channel
operator|=
name|NULL
expr_stmt|;
name|log_cfg
operator|->
name|default_debug_active
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|log_cfg
operator|)
return|;
block|}
end_function

begin_function
name|void
name|add_log_channel
parameter_list|(
name|log_config
name|log_cfg
parameter_list|,
name|int
name|category
parameter_list|,
name|log_channel
name|chan
parameter_list|)
block|{
name|log_channel_type
name|type
decl_stmt|;
name|INSIST
argument_list|(
name|log_cfg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|type
operator|=
name|log_get_channel_type
argument_list|(
name|chan
argument_list|)
expr_stmt|;
if|if
condition|(
name|category
operator|==
name|ns_log_eventlib
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|log_file
operator|&&
name|type
operator|!=
name|log_null
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"must specify a file or null channel for the eventlib category"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|log_cfg
operator|->
name|eventlib_channel
operator|!=
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"only one channel allowed for the eventlib category"
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_cfg
operator|->
name|eventlib_channel
operator|=
name|chan
expr_stmt|;
block|}
if|if
condition|(
name|category
operator|==
name|ns_log_packet
condition|)
block|{
if|if
condition|(
name|type
operator|!=
name|log_file
operator|&&
name|type
operator|!=
name|log_null
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"must specify a file or null channel for the packet category"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|log_cfg
operator|->
name|packet_channel
operator|!=
name|NULL
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"only one channel allowed for the packet category"
argument_list|)
expr_stmt|;
return|return;
block|}
name|log_cfg
operator|->
name|packet_channel
operator|=
name|chan
expr_stmt|;
block|}
if|if
condition|(
name|log_add_channel
argument_list|(
name|log_cfg
operator|->
name|log_ctx
argument_list|,
name|category
argument_list|,
name|chan
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ns_error
argument_list|(
name|ns_log_config
argument_list|,
literal|"log_add_channel() failed"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|chan
operator|==
name|debug_channel
condition|)
name|log_cfg
operator|->
name|default_debug_active
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|open_special_channels
parameter_list|()
block|{
name|int
name|using_null
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|log_open_stream
argument_list|(
name|eventlib_channel
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|eventlib_channel
operator|=
name|null_channel
expr_stmt|;
name|using_null
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|log_open_stream
argument_list|(
name|packet_channel
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|packet_channel
operator|=
name|null_channel
expr_stmt|;
name|using_null
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|using_null
operator|&&
name|log_open_stream
argument_list|(
name|null_channel
argument_list|)
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|1
argument_list|,
literal|"couldn't open null channel"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|set_logging
parameter_list|(
name|log_config
name|log_cfg
parameter_list|,
name|int
name|is_default
parameter_list|)
block|{
name|log_context
name|lc
decl_stmt|;
name|INSIST
argument_list|(
name|log_cfg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|lc
operator|=
name|log_cfg
operator|->
name|log_ctx
expr_stmt|;
comment|/* 	 * Add the default category if it's not in the context already. 	 */
if|if
condition|(
operator|!
name|log_category_is_active
argument_list|(
name|lc
argument_list|,
name|ns_log_default
argument_list|)
condition|)
block|{
name|add_log_channel
argument_list|(
name|log_cfg
argument_list|,
name|ns_log_default
argument_list|,
name|debug_channel
argument_list|)
expr_stmt|;
name|add_log_channel
argument_list|(
name|log_cfg
argument_list|,
name|ns_log_default
argument_list|,
name|syslog_channel
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add the panic category if it's not in the context already. 	 */
if|if
condition|(
operator|!
name|log_category_is_active
argument_list|(
name|lc
argument_list|,
name|ns_log_panic
argument_list|)
condition|)
block|{
name|add_log_channel
argument_list|(
name|log_cfg
argument_list|,
name|ns_log_panic
argument_list|,
name|stderr_channel
argument_list|)
expr_stmt|;
name|add_log_channel
argument_list|(
name|log_cfg
argument_list|,
name|ns_log_panic
argument_list|,
name|syslog_channel
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Add the eventlib category if it's not in the context already. 	 */
if|if
condition|(
operator|!
name|log_category_is_active
argument_list|(
name|lc
argument_list|,
name|ns_log_eventlib
argument_list|)
condition|)
name|add_log_channel
argument_list|(
name|log_cfg
argument_list|,
name|ns_log_eventlib
argument_list|,
name|debug_channel
argument_list|)
expr_stmt|;
comment|/* 	 * Add the packet category if it's not in the context already. 	 */
if|if
condition|(
operator|!
name|log_category_is_active
argument_list|(
name|lc
argument_list|,
name|ns_log_packet
argument_list|)
condition|)
name|add_log_channel
argument_list|(
name|log_cfg
argument_list|,
name|ns_log_packet
argument_list|,
name|debug_channel
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
comment|/* 	 * Preserve debugging state. 	 */
name|log_option
argument_list|(
name|lc
argument_list|,
name|LOG_OPTION_DEBUG
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|log_option
argument_list|(
name|lc
argument_list|,
name|LOG_OPTION_LEVEL
argument_list|,
name|debug
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Special case for query-log, so we can co-exist with the command 	 * line option and SIGWINCH. 	 */
if|if
condition|(
name|log_category_is_active
argument_list|(
name|lc
argument_list|,
name|ns_log_queries
argument_list|)
condition|)
name|qrylog
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Cleanup the old context. 	 */
if|if
condition|(
name|need_logging_free
condition|)
name|log_free_context
argument_list|(
name|log_ctx
argument_list|)
expr_stmt|;
comment|/* 	 * The default file channels will never have their reference counts 	 * drop to zero, and so they will not be closed by the logging system 	 * when log_free_context() is called.  We don't want to keep files 	 * open unnecessarily, and we want them to behave like user-created 	 * channels, so we close them here. 	 */
if|if
condition|(
name|log_get_stream
argument_list|(
name|debug_channel
argument_list|)
operator|!=
name|stderr
condition|)
operator|(
name|void
operator|)
name|log_close_stream
argument_list|(
name|debug_channel
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|log_close_stream
argument_list|(
name|null_channel
argument_list|)
expr_stmt|;
comment|/* 	 * Install the new context. 	 */
name|log_ctx
operator|=
name|lc
expr_stmt|;
name|eventlib_channel
operator|=
name|log_cfg
operator|->
name|eventlib_channel
expr_stmt|;
name|packet_channel
operator|=
name|log_cfg
operator|->
name|packet_channel
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
name|open_special_channels
argument_list|()
expr_stmt|;
name|evSetDebug
argument_list|(
name|ev
argument_list|,
name|debug
argument_list|,
name|log_get_stream
argument_list|(
name|eventlib_channel
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|log_ctx_valid
operator|=
literal|1
expr_stmt|;
name|need_logging_free
operator|=
literal|1
expr_stmt|;
name|logging_installed
operator|=
literal|1
expr_stmt|;
name|default_logging_installed
operator|=
name|is_default
expr_stmt|;
block|}
end_function

begin_function
name|void
name|end_logging
parameter_list|(
name|log_config
name|log_cfg
parameter_list|,
name|int
name|should_install
parameter_list|)
block|{
if|if
condition|(
name|should_install
condition|)
name|set_logging
argument_list|(
name|log_cfg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|log_free_context
argument_list|(
name|log_cfg
operator|->
name|log_ctx
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|log_cfg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_config
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|use_default_logging
parameter_list|()
block|{
name|log_config
name|log_cfg
decl_stmt|;
name|log_cfg
operator|=
name|begin_logging
argument_list|()
expr_stmt|;
name|set_logging
argument_list|(
name|log_cfg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|log_cfg
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|log_config
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|init_default_log_channels
parameter_list|()
block|{
name|u_int
name|flags
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|syslog_channel
operator|=
name|log_new_syslog_channel
argument_list|(
literal|0
argument_list|,
name|log_info
argument_list|,
name|ISC_FACILITY
argument_list|)
expr_stmt|;
if|if
condition|(
name|syslog_channel
operator|==
name|NULL
operator|||
name|log_inc_references
argument_list|(
name|syslog_channel
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"couldn't create syslog_channel"
argument_list|)
expr_stmt|;
name|flags
operator|=
name|LOG_USE_CONTEXT_LEVEL
operator||
name|LOG_REQUIRE_DEBUG
expr_stmt|;
if|if
condition|(
name|foreground
condition|)
block|{
name|name
operator|=
name|NULL
expr_stmt|;
name|stream
operator|=
name|stderr
expr_stmt|;
block|}
else|else
block|{
name|name
operator|=
name|_PATH_DEBUG
expr_stmt|;
name|stream
operator|=
name|NULL
expr_stmt|;
block|}
name|debug_channel
operator|=
name|log_new_file_channel
argument_list|(
name|flags
argument_list|,
name|log_info
argument_list|,
name|name
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|ULONG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug_channel
operator|==
name|NULL
operator|||
name|log_inc_references
argument_list|(
name|debug_channel
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"couldn't create debug_channel"
argument_list|)
expr_stmt|;
name|log_set_file_owner
argument_list|(
name|debug_channel
argument_list|,
name|user_id
argument_list|,
name|group_id
argument_list|)
expr_stmt|;
name|stderr_channel
operator|=
name|log_new_file_channel
argument_list|(
literal|0
argument_list|,
name|log_info
argument_list|,
name|NULL
argument_list|,
name|stderr
argument_list|,
literal|0
argument_list|,
name|ULONG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|stderr_channel
operator|==
name|NULL
operator|||
name|log_inc_references
argument_list|(
name|stderr_channel
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"couldn't create stderr_channel"
argument_list|)
expr_stmt|;
name|log_set_file_owner
argument_list|(
name|stderr_channel
argument_list|,
name|user_id
argument_list|,
name|group_id
argument_list|)
expr_stmt|;
name|null_channel
operator|=
name|log_new_file_channel
argument_list|(
name|LOG_CHANNEL_OFF
argument_list|,
name|log_info
argument_list|,
name|_PATH_DEVNULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ULONG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|null_channel
operator|==
name|NULL
operator|||
name|log_inc_references
argument_list|(
name|null_channel
argument_list|)
operator|<
literal|0
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"couldn't create null_channel"
argument_list|)
expr_stmt|;
name|log_set_file_owner
argument_list|(
name|null_channel
argument_list|,
name|user_id
argument_list|,
name|group_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|shutdown_default_log_channels
parameter_list|()
block|{
name|log_free_channel
argument_list|(
name|syslog_channel
argument_list|)
expr_stmt|;
name|log_free_channel
argument_list|(
name|debug_channel
argument_list|)
expr_stmt|;
name|log_free_channel
argument_list|(
name|stderr_channel
argument_list|)
expr_stmt|;
name|log_free_channel
argument_list|(
name|null_channel
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|init_logging
parameter_list|()
block|{
name|int
name|size
decl_stmt|;
specifier|const
name|struct
name|ns_sym
modifier|*
name|s
decl_stmt|;
name|char
name|category_name
index|[
literal|256
index|]
decl_stmt|;
name|size
operator|=
name|ns_log_max_category
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
name|logging_categories
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|memget
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|logging_categories
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_config
argument_list|,
literal|0
argument_list|,
literal|"memget failed in init_logging"
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|logging_categories
argument_list|,
literal|0
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|category_constants
init|;
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|name
operator|!=
name|NULL
condition|;
name|s
operator|++
control|)
block|{
name|sprintf
argument_list|(
name|category_name
argument_list|,
literal|"%s: "
argument_list|,
name|s
operator|->
name|name
argument_list|)
expr_stmt|;
name|logging_categories
index|[
name|s
operator|->
name|number
index|]
operator|=
name|savestr
argument_list|(
name|category_name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|init_default_log_channels
argument_list|()
expr_stmt|;
name|use_default_logging
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shutdown_logging
parameter_list|()
block|{
name|int
name|size
decl_stmt|;
specifier|const
name|struct
name|ns_sym
modifier|*
name|s
decl_stmt|;
name|evSetDebug
argument_list|(
name|ev
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|shutdown_default_log_channels
argument_list|()
expr_stmt|;
name|log_free_context
argument_list|(
name|log_ctx
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|category_constants
init|;
name|s
operator|!=
name|NULL
operator|&&
name|s
operator|->
name|name
operator|!=
name|NULL
condition|;
name|s
operator|++
control|)
name|freestr
argument_list|(
name|logging_categories
index|[
name|s
operator|->
name|number
index|]
argument_list|)
expr_stmt|;
name|size
operator|=
name|ns_log_max_category
operator|*
operator|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|)
expr_stmt|;
name|memput
argument_list|(
name|logging_categories
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|logging_categories
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Main Loader  */
end_comment

begin_function
name|void
name|init_configuration
parameter_list|()
block|{
comment|/* 	 * Remember initial limits for use if "default" is specified in 	 * a config file. 	 */
ifdef|#
directive|ifdef
name|HAVE_GETRUSAGE
name|get_initial_limits
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|zone_symbol_table
operator|=
name|new_symbol_table
argument_list|(
name|ZONE_SYM_TABLE_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|use_default_options
argument_list|()
expr_stmt|;
name|parser_initialize
argument_list|()
expr_stmt|;
name|ns_ctl_initialize
argument_list|()
expr_stmt|;
name|config_initialized
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|shutdown_configuration
parameter_list|()
block|{
name|REQUIRE
argument_list|(
name|config_initialized
argument_list|)
expr_stmt|;
name|ns_ctl_shutdown
argument_list|()
expr_stmt|;
if|if
condition|(
name|server_options
operator|!=
name|NULL
condition|)
block|{
name|free_options
argument_list|(
name|server_options
argument_list|)
expr_stmt|;
name|server_options
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|current_pid_filename
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|current_pid_filename
argument_list|)
expr_stmt|;
name|free_nameserver_info
argument_list|()
expr_stmt|;
name|free_secretkey_info
argument_list|()
expr_stmt|;
name|free_symbol_table
argument_list|(
name|zone_symbol_table
argument_list|)
expr_stmt|;
name|parser_shutdown
argument_list|()
expr_stmt|;
name|config_initialized
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|time_t
name|load_configuration
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|time_t
name|mtime
decl_stmt|;
name|REQUIRE
argument_list|(
name|config_initialized
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_config
argument_list|,
literal|3
argument_list|,
literal|"load configuration %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|loading
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Clean up any previous configuration and initialize 	 * global data structures we'll be updating. 	 */
name|free_nameserver_info
argument_list|()
expr_stmt|;
name|free_secretkey_info
argument_list|()
expr_stmt|;
name|bogus_nameservers
operator|=
name|new_ip_match_list
argument_list|()
expr_stmt|;
name|options_installed
operator|=
literal|0
expr_stmt|;
name|logging_installed
operator|=
literal|0
expr_stmt|;
name|mtime
operator|=
name|parse_configuration
argument_list|(
name|filename
argument_list|)
expr_stmt|;
comment|/* 	 * If the user didn't specify logging or options, but they previously 	 * had specified one or both of them, then we need to 	 * re-establish the default environment.  We have to be careful 	 * about when we install default options because the parser 	 * must respect limits (e.g. data-size, number of open files) 	 * specified in the options file.  In the ordinary case where the 	 * options section isn't changing on a zone reload, it would be bad 	 * to lower these limits temporarily, because we might not survive 	 * to the point where they get raised back again.  The logging case 	 * has similar motivation -- we don't want to override the existing 	 * logging scheme (perhaps causing log messages to go somewhere  	 * unexpected) when the user hasn't expressed a desire for a new 	 * scheme. 	 */
if|if
condition|(
operator|!
name|logging_installed
condition|)
name|use_default_logging
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|options_installed
operator|&&
operator|!
name|default_options_installed
condition|)
block|{
name|use_default_options
argument_list|()
expr_stmt|;
name|ns_warning
argument_list|(
name|ns_log_config
argument_list|,
literal|"re-establishing default options"
argument_list|)
expr_stmt|;
block|}
name|update_pid_file
argument_list|()
expr_stmt|;
comment|/* Init or reinit the interface/port list and associated sockets. */
name|getnetconf
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|opensocket_f
argument_list|()
expr_stmt|;
name|initial_configuration
operator|=
literal|0
expr_stmt|;
name|loading
operator|=
literal|0
expr_stmt|;
comment|/* release queued notifies */
name|notify_afterload
argument_list|()
expr_stmt|;
return|return
operator|(
name|mtime
operator|)
return|;
block|}
end_function

end_unit

