begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)ns_resp.c	4.65 (Berkeley) 3/3/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: ns_resp.c,v 8.136 1999/11/16 07:10:34 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986, 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-1999 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"named.h"
end_include

begin_decl_stmt
specifier|static
name|u_int8_t
name|norootlogged
index|[
name|MAXCLASS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX- should be a bitmap */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|skipnameFailedAnswer
index|[]
init|=
literal|"skipname failed in answer"
decl_stmt|,
name|skipnameFailedAuth
index|[]
init|=
literal|"skipname failed in authority"
decl_stmt|,
name|skipnameFailedQuery
index|[]
init|=
literal|"skipname failed in query"
decl_stmt|,
name|outofDataQuery
index|[]
init|=
literal|"ran out of data in query"
decl_stmt|,
name|outofDataAnswer
index|[]
init|=
literal|"ran out of data in answer"
decl_stmt|,
name|notSingleQuery
index|[]
init|=
literal|"not exactly one query"
decl_stmt|,
name|expandFailedQuery
index|[]
init|=
literal|"dn_expand failed in query"
decl_stmt|,
name|expandFailedAnswer
index|[]
init|=
literal|"dn_expand failed in answer"
decl_stmt|,
name|expandFailedAuth
index|[]
init|=
literal|"dn_expand failed in authority"
decl_stmt|,
name|outofDataAuth
index|[]
init|=
literal|"ran out of data in authority"
decl_stmt|,
name|dlenOverrunAnswer
index|[]
init|=
literal|"dlen overrun in answer"
decl_stmt|,
name|dlenOverrunAuth
index|[]
init|=
literal|"dlen overrun in authority"
decl_stmt|,
name|dlenUnderrunAnswer
index|[]
init|=
literal|"dlen underrun in answer"
decl_stmt|,
name|outofDataFinal
index|[]
init|=
literal|"out of data in final pass"
decl_stmt|,
name|outofDataAFinal
index|[]
init|=
literal|"out of data after final pass"
decl_stmt|,
name|badNameFound
index|[]
init|=
literal|"found an invalid domain name"
decl_stmt|,
name|wrongQuestion
index|[]
init|=
literal|"answer to wrong question"
decl_stmt|,
name|danglingCname
index|[]
init|=
literal|"dangling CNAME pointer"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|db_list
block|{
name|struct
name|db_list
modifier|*
name|db_next
decl_stmt|;
name|struct
name|databuf
modifier|*
name|db_dp
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|flush_set
block|{
name|char
modifier|*
name|fs_name
decl_stmt|;
name|int
name|fs_type
decl_stmt|;
name|int
name|fs_class
decl_stmt|;
name|u_int
name|fs_cred
decl_stmt|;
name|struct
name|db_list
modifier|*
name|fs_list
decl_stmt|;
name|struct
name|db_list
modifier|*
name|fs_last
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|void
name|rrsetadd
argument_list|(
expr|struct
name|flush_set
operator|*
argument_list|,
specifier|const
name|char
operator|*
argument_list|,
expr|struct
name|databuf
operator|*
argument_list|)
decl_stmt|,
name|rrsetupdate
argument_list|(
expr|struct
name|flush_set
operator|*
argument_list|,
name|int
name|flags
argument_list|,
expr|struct
name|sockaddr_in
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|flushrrset
argument_list|(
expr|struct
name|flush_set
operator|*
argument_list|,
expr|struct
name|sockaddr_in
argument_list|)
decl_stmt|,
name|free_flushset
argument_list|(
expr|struct
name|flush_set
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|check_hints
argument_list|(
expr|struct
name|flush_set
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|rrsetcmp
argument_list|(
name|char
operator|*
argument_list|,
expr|struct
name|db_list
operator|*
argument_list|,
expr|struct
name|hashbuf
operator|*
argument_list|)
decl_stmt|,
name|check_root
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|check_ns
argument_list|(
name|void
argument_list|)
decl_stmt|,
name|wanted
argument_list|(
specifier|const
expr|struct
name|databuf
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|wantedsig
argument_list|(
specifier|const
expr|struct
name|databuf
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|rrextract
argument_list|(
name|u_char
operator|*
argument_list|,
name|int
argument_list|,
name|u_char
operator|*
argument_list|,
expr|struct
name|databuf
operator|*
operator|*
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|,
expr|struct
name|sockaddr_in
argument_list|,
name|char
operator|*
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|mark_bad
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mark_lame
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fast_retry
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|add_related_additional
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|free_related_additional
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|related_additional
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|freestr_maybe
parameter_list|(
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|enum
name|ordering
name|match_order
parameter_list|(
specifier|const
name|struct
name|namebuf
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|match_name
parameter_list|(
specifier|const
name|struct
name|namebuf
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|MAX_RELATED
value|100
end_define

begin_decl_stmt
specifier|static
name|int
name|num_related
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|related
index|[
name|MAX_RELATED
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|learntFrom
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|server
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|ns
decl_stmt|,
modifier|*
name|na
decl_stmt|;
name|struct
name|databuf
modifier|*
name|db
decl_stmt|;
name|int
name|i
decl_stmt|;
name|a
operator|=
name|ns
operator|=
name|na
operator|=
literal|"<Not Available>"
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|i
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ina_equal
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|server
operator|->
name|sin_addr
argument_list|)
condition|)
block|{
name|db
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_HOSTSTATS
argument_list|)
condition|)
block|{
name|char
name|nsbuf
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
name|db
operator|->
name|d_ns
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|nsbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|db
operator|->
name|d_ns
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|ns
operator|=
name|nsbuf
expr_stmt|;
block|}
else|else
block|{
name|ns
operator|=
name|zones
index|[
name|db
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
block|}
if|if
condition|(
name|db
operator|->
name|d_rcode
operator|==
literal|0
condition|)
name|na
operator|=
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_data
expr_stmt|;
block|}
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_HOSTSTATS
argument_list|)
condition|)
block|{
name|char
name|abuf
index|[
literal|20
index|]
decl_stmt|;
name|db
operator|=
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nsdata
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|d_ns
operator|!=
name|NULL
condition|)
block|{
name|strcpy
argument_list|(
name|abuf
argument_list|,
name|inet_ntoa
argument_list|(
name|db
operator|->
name|d_ns
operator|->
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|a
operator|=
name|abuf
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|zones
index|[
name|db
operator|->
name|d_zone
index|]
operator|.
name|z_origin
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|a
operator|==
name|ns
operator|&&
name|ns
operator|==
name|na
condition|)
comment|/* all "UNKNOWN" */
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|*
name|a
operator|==
literal|'\0'
condition|)
name|a
operator|=
literal|"\".\""
expr_stmt|;
if|if
condition|(
operator|*
name|ns
operator|==
literal|'\0'
condition|)
name|ns
operator|=
literal|"\".\""
expr_stmt|;
if|if
condition|(
operator|*
name|na
operator|==
literal|'\0'
condition|)
name|na
operator|=
literal|"\".\""
expr_stmt|;
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_HOSTSTATS
argument_list|)
condition|)
block|{
specifier|static
specifier|const
name|char
name|fmt
index|[]
init|=
literal|" '%s': learnt (A=%s,NS=%s)"
decl_stmt|;
name|buf
operator|=
name|newstr
argument_list|(
sizeof|sizeof
name|fmt
operator|+
name|strlen
argument_list|(
name|na
argument_list|)
operator|+
name|strlen
argument_list|(
name|a
argument_list|)
operator|+
name|strlen
argument_list|(
name|ns
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|na
argument_list|,
name|a
argument_list|,
name|ns
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|static
specifier|const
name|char
name|fmt
index|[]
init|=
literal|" '%s'"
decl_stmt|;
name|buf
operator|=
name|newstr
argument_list|(
sizeof|sizeof
name|fmt
operator|+
name|strlen
argument_list|(
name|na
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|na
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|ns_resp
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|struct
name|qstream
modifier|*
name|qsp
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
init|=
name|NULL
decl_stmt|;
name|struct
name|databuf
modifier|*
name|ns
decl_stmt|,
modifier|*
name|ns2
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|answers
decl_stmt|,
modifier|*
name|eom
init|=
name|msg
operator|+
name|msglen
decl_stmt|;
name|struct
name|flush_set
modifier|*
name|flushset
init|=
name|NULL
decl_stmt|;
name|int
name|flushset_size
init|=
literal|0
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|,
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|aucount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|arfirst
decl_stmt|;
name|int
name|soacount
decl_stmt|;
name|u_int
name|qtype
decl_stmt|,
name|qclass
decl_stmt|;
name|int
name|restart
decl_stmt|;
comment|/* flag for processing cname response */
name|int
name|validanswer
decl_stmt|,
name|dbflags
decl_stmt|;
name|int
name|cname
decl_stmt|,
name|lastwascname
decl_stmt|,
name|externalcname
decl_stmt|;
name|int
name|count
decl_stmt|,
name|founddata
decl_stmt|,
name|foundname
decl_stmt|;
name|int
name|buflen
decl_stmt|;
name|int
name|newmsglen
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|qname
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|aname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|msgbuf
index|[
name|MAXDNAME
operator|+
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|,
name|tmpdomain
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|formerrmsg
init|=
literal|"brain damage"
decl_stmt|;
name|u_char
name|newmsg
index|[
name|PACKETSZ
index|]
decl_stmt|;
name|u_char
modifier|*
modifier|*
name|dpp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|time_t
name|rtrip
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|fwdinfo
modifier|*
name|fwd
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|forcecmsg
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|tname
init|=
name|NULL
decl_stmt|;
name|int
name|sendto_errno
init|=
literal|0
decl_stmt|;
name|int
name|has_tsig
decl_stmt|,
name|oldqlen
decl_stmt|;
name|u_char
modifier|*
name|oldqbuf
decl_stmt|;
name|u_char
modifier|*
name|smsg
decl_stmt|;
name|int
name|smsglen
decl_stmt|,
name|smsgsize
decl_stmt|,
name|siglen
decl_stmt|;
name|u_char
name|sig
index|[
name|TSIG_SIG_SIZE
index|]
decl_stmt|;
name|time_t
name|tsig_time
decl_stmt|;
name|DST_KEY
modifier|*
name|key
decl_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdR
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|=
name|qfindid
argument_list|(
name|hp
operator|->
name|id
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"DUP? dropped (id %d)"
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdDupR
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"Response (%s %s %s) nsid=%d id=%d"
argument_list|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
condition|?
literal|"SYSTEM"
else|:
literal|"USER"
argument_list|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
literal|"PRIMING"
else|:
literal|"NORMAL"
argument_list|,
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
condition|?
literal|"ZSERIAL"
else|:
literal|"-"
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_nstsig
operator|==
name|NULL
condition|)
name|has_tsig
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|ns_verify
argument_list|(
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|qp
operator|->
name|q_nstsig
operator|->
name|key
argument_list|,
name|qp
operator|->
name|q_nstsig
operator|->
name|sig
argument_list|,
name|qp
operator|->
name|q_nstsig
operator|->
name|siglen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tsig_time
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|has_tsig
operator|=
literal|1
expr_stmt|;
else|else
block|{
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NOTAUTH
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"resp: error bad tsig, record dropped"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Here we handle high level formatting problems by parsing the header. 	 */
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|free_addinfo
argument_list|()
expr_stmt|;
comment|/* sets addcount to zero */
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
name|dpp
operator|=
name|dnptrs
expr_stmt|;
operator|*
name|dpp
operator|++
operator|=
name|msg
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
name|INDIR_MASK
operator|)
operator|==
literal|0
condition|)
operator|*
name|dpp
operator|++
operator|=
name|cp
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|qdcount
operator|==
literal|1
condition|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|qname
argument_list|,
sizeof|sizeof
argument_list|(
name|qname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETSHORT
argument_list|(
name|qtype
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|qclass
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|qp
argument_list|,
name|qname
argument_list|,
name|qclass
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|qtype
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|qname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|formerrmsg
operator|=
name|badNameFound
expr_stmt|;
goto|goto
name|refused
goto|;
block|}
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|&&
name|qp
operator|->
name|q_msglen
operator|&&
operator|!
name|res_nameinquery
argument_list|(
name|qname
argument_list|,
name|qtype
argument_list|,
name|qclass
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
name|qp
operator|->
name|q_msglen
argument_list|)
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"query section mismatch (%s %s %s)"
argument_list|,
name|qname
argument_list|,
name|p_class
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
name|ns_samename
argument_list|(
name|qp
operator|->
name|q_name
argument_list|,
name|qname
argument_list|)
operator|!=
literal|1
operator|||
name|qp
operator|->
name|q_class
operator|!=
name|qclass
operator|||
name|qp
operator|->
name|q_type
operator|!=
name|qtype
condition|)
block|{
name|formerrmsg
operator|=
name|wrongQuestion
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
block|}
else|else
block|{
name|strcpy
argument_list|(
name|qname
argument_list|,
name|qp
operator|->
name|q_name
argument_list|)
expr_stmt|;
name|qclass
operator|=
name|qp
operator|->
name|q_class
expr_stmt|;
name|qtype
operator|=
name|qp
operator|->
name|q_type
expr_stmt|;
block|}
comment|/* cp now points after the query section. */
comment|/* 	 *  Here we handle bad responses from servers. 	 *  Several possibilities come to mind: 	 *	The server is sick and returns SERVFAIL 	 *	The server returns some garbage opcode (it's sick) 	 *	The server can't understand our query and return FORMERR 	 *  In all these cases, we drop the packet, disable retries on 	 *  this server and immediately force a retry. 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|&&
name|hp
operator|->
name|rcode
operator|!=
name|NXDOMAIN
operator|)
operator|||
operator|(
name|hp
operator|->
name|opcode
operator|!=
name|QUERY
ifdef|#
directive|ifdef
name|BIND_NOTIFY
operator|&&
name|hp
operator|->
name|opcode
operator|!=
name|NS_NOTIFY_OP
endif|#
directive|endif
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"resp: error (ret %d, op %d), dropped"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|hp
operator|->
name|opcode
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
case|case
name|SERVFAIL
case|:
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFail
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFErr
argument_list|)
expr_stmt|;
break|break;
default|default:
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdErr
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ns_samename
argument_list|(
name|qp
operator|->
name|q_name
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
operator|==
literal|1
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|SERVFAIL
operator|&&
name|hp
operator|->
name|opcode
operator|==
name|QUERY
condition|)
name|mark_lame
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|mark_bad
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|fast_retry
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|qdcount
operator|!=
literal|1
condition|)
block|{
comment|/* We don't generate or forward these (yet). */
name|formerrmsg
operator|=
name|notSingleQuery
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
comment|/* 	 * Determine if the response came from a forwarder.  Packets from 	 * anyplace not listed as a forwarder or as a server to whom we 	 * might have forwarded the query will be dropped. 	 * XXX - should put this in STATS somewhere. 	 */
for|for
control|(
name|fwd
operator|=
name|NS_ZFWDTAB
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|)
init|;
name|fwd
condition|;
name|fwd
operator|=
name|fwd
operator|->
name|next
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|fwd
operator|->
name|fwdaddr
operator|.
name|sin_addr
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
break|break;
comment|/* 	 * XXX:	note bad ambiguity here.  if one of our forwarders is also 	 *	a delegated server for some domain, then we will not update 	 *	the RTT information on any replies we get from those servers. 	 *	Workaround: disable recursion on authoritative servers so that 	 *	the ambiguity does not arise. 	 */
comment|/* 	 * If we weren't using a forwarder, find the qinfo pointer and update 	 * the rtt and fact that we have called on this server before. 	 */
if|if
condition|(
name|fwd
operator|==
name|NULL
condition|)
block|{
name|struct
name|timeval
modifier|*
name|stp
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|(
name|u_int
operator|)
name|n
operator|>=
name|qp
operator|->
name|q_naddr
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
literal|"unexpected source"
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"Response from unexpected source (%s)"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*  			 * We don't know who this response came from so it 			 * gets dropped on the floor. 			 */
return|return;
block|}
name|stp
operator|=
operator|&
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* Handle response from different (untried) interface. */
if|if
condition|(
name|qs
operator|->
name|ns
operator|!=
name|NULL
operator|&&
name|stp
operator|->
name|tv_sec
operator|==
literal|0
condition|)
block|{
name|ns
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
while|while
condition|(
name|qs
operator|>
name|qp
operator|->
name|q_addr
operator|&&
operator|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
operator|==
literal|0
operator|||
name|qs
operator|->
name|ns
operator|!=
name|ns
operator|)
condition|)
name|qs
operator|--
expr_stmt|;
operator|*
name|stp
operator|=
name|qs
operator|->
name|stime
expr_stmt|;
comment|/* XXX - sometimes stp still ends up pointing to 			 * a zero timeval, in spite of the above attempt. 			 * Why?  What should we do about it? 			 */
comment|/* XXX - catch aliases here */
block|}
comment|/* compute query round trip time */
comment|/* XXX - avoid integer overflow, which is quite likely if stp 		 * points to a zero timeval (see above). 		 * rtrip is of type time_t, which we assume is at least 		 * as big as an int. 		 */
if|if
condition|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|>
operator|(
name|INT_MAX
operator|-
literal|999
operator|)
operator|/
literal|1000
condition|)
block|{
name|rtrip
operator|=
name|INT_MAX
expr_stmt|;
block|}
else|else
block|{
name|rtrip
operator|=
operator|(
operator|(
name|tt
operator|.
name|tv_sec
operator|-
name|stp
operator|->
name|tv_sec
operator|)
operator|*
literal|1000
operator|+
operator|(
name|tt
operator|.
name|tv_usec
operator|-
name|stp
operator|->
name|tv_usec
operator|)
operator|/
literal|1000
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"stime %lu/%lu  now %lu/%lu rtt %ld"
argument_list|,
operator|(
name|u_long
operator|)
name|stp
operator|->
name|tv_sec
argument_list|,
operator|(
name|u_long
operator|)
name|stp
operator|->
name|tv_usec
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_usec
argument_list|,
operator|(
name|long
operator|)
name|rtrip
argument_list|)
expr_stmt|;
block|}
comment|/* prevent floating point overflow, limit to 1000 sec */
if|if
condition|(
name|rtrip
operator|>
literal|1000000
condition|)
block|{
name|rtrip
operator|=
literal|1000000
expr_stmt|;
block|}
name|ns
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
comment|/* 		 * Don't update nstime if this doesn't look 		 * like an address databuf now.			XXX 		 */
if|if
condition|(
name|ns
operator|&&
name|ns
operator|->
name|d_type
operator|==
name|T_A
operator|&&
name|ns
operator|->
name|d_class
operator|==
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
block|{
name|u_long
name|t
decl_stmt|;
if|if
condition|(
name|ns
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|t
operator|=
name|rtrip
expr_stmt|;
else|else
name|t
operator|=
name|ns
operator|->
name|d_nstime
operator|*
name|ALPHA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
name|rtrip
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|65535
condition|)
name|t
operator|=
literal|65535
expr_stmt|;
name|ns
operator|->
name|d_nstime
operator|=
operator|(
name|u_int16_t
operator|)
name|t
expr_stmt|;
block|}
comment|/* 		 * Record the source so that we do not use this NS again. 		 */
if|if
condition|(
name|ns
operator|&&
name|qs
operator|->
name|ns
operator|&&
operator|(
name|qp
operator|->
name|q_nusedns
operator|<
name|NSMAX
operator|)
condition|)
block|{
name|qp
operator|->
name|q_usedns
index|[
name|qp
operator|->
name|q_nusedns
operator|++
index|]
operator|=
name|qs
operator|->
name|ns
expr_stmt|;
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"NS #%d addr %s used, rtt %d"
argument_list|,
name|n
argument_list|,
name|sin_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
argument_list|)
argument_list|,
name|ns
operator|->
name|d_nstime
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * Penalize those who had earlier chances but failed 		 * by multiplying round-trip times by BETA (>1). 		 * Improve nstime for unused addresses by applying GAMMA. 		 * The GAMMA factor makes unused entries slowly 		 * improve, so they eventually get tried again. 		 * GAMMA should be slightly less than 1. 		 * Watch out for records that may have timed out 		 * and are no longer the correct type.			XXX 		 */
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|u_long
name|t
decl_stmt|;
name|ns2
operator|=
name|qs
operator|->
name|nsdata
expr_stmt|;
if|if
condition|(
operator|!
name|ns2
operator|||
name|ns2
operator|==
name|ns
condition|)
continue|continue;
if|if
condition|(
name|ns2
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|ns2
operator|->
name|d_class
operator|!=
name|qs
operator|->
name|ns
operator|->
name|d_class
condition|)
comment|/* XXX */
continue|continue;
if|if
condition|(
name|qs
operator|->
name|stime
operator|.
name|tv_sec
condition|)
block|{
if|if
condition|(
name|ns2
operator|->
name|d_nstime
operator|==
literal|0
condition|)
name|t
operator|=
operator|(
name|rtrip
operator|*
name|BETA
operator|)
expr_stmt|;
else|else
name|t
operator|=
name|ns2
operator|->
name|d_nstime
operator|*
name|BETA
operator|+
operator|(
literal|1
operator|-
name|ALPHA
operator|)
operator|*
name|rtrip
expr_stmt|;
block|}
else|else
name|t
operator|=
name|ns2
operator|->
name|d_nstime
operator|*
name|GAMMA
expr_stmt|;
if|if
condition|(
name|t
operator|>
literal|65535
condition|)
name|t
operator|=
literal|65535
expr_stmt|;
name|ns2
operator|->
name|d_nstime
operator|=
operator|(
name|u_int16_t
operator|)
name|t
expr_stmt|;
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"NS #%d %s rtt now %d"
argument_list|,
name|n
argument_list|,
name|sin_ntoa
argument_list|(
name|qs
operator|->
name|ns_addr
argument_list|)
argument_list|,
name|ns2
operator|->
name|d_nstime
argument_list|)
expr_stmt|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* 	 * For now, NOTIFY isn't defined for ANCOUNT!=0, AUCOUNT!=0, 	 * or ADCOUNT!=0.  Therefore the only real work to be done for 	 * a NOTIFY-QR is to remove it from the query queue. 	 */
if|if
condition|(
name|hp
operator|->
name|opcode
operator|==
name|NS_NOTIFY_OP
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_notify
argument_list|,
literal|"Received NOTIFY answer from %s for \"%s %s %s\""
argument_list|,
name|inet_ntoa
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|*
operator|(
name|qp
operator|->
name|q_name
operator|)
condition|?
name|qp
operator|->
name|q_name
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|qp
operator|->
name|q_class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qp
operator|->
name|q_type
argument_list|)
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_ZSERIAL
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|aa
operator|&&
name|ancount
operator|>
literal|0
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|qtype
operator|==
name|T_SOA
operator|&&
operator|(
name|qclass
operator|==
name|C_IN
operator|||
name|qclass
operator|==
name|C_HS
operator|)
condition|)
block|{
name|int
name|n
decl_stmt|;
name|u_int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|u_char
modifier|*
name|tp
init|=
name|cp
decl_stmt|;
name|u_char
modifier|*
name|rdatap
decl_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|tp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* name */
if|if
condition|(
name|tp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* type */
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* class */
name|tp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|tp
argument_list|)
expr_stmt|;
comment|/* dlen */
name|rdatap
operator|=
name|tp
expr_stmt|;
comment|/* start of rdata */
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|qp
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|name
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|formerrmsg
operator|=
name|badNameFound
expr_stmt|;
goto|goto
name|refused
goto|;
block|}
if|if
condition|(
name|ns_samename
argument_list|(
name|qname
argument_list|,
name|name
argument_list|)
operator|!=
literal|1
operator|||
name|qtype
operator|!=
name|type
operator|||
name|qclass
operator|!=
name|class
condition|)
block|{
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"qserial answer mismatch (%s %s %s)"
argument_list|,
name|name
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|msgbuf
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* mname */
if|if
condition|(
literal|0
operator|>=
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|)
operator|)
condition|)
block|{
name|formerrmsg
operator|=
name|skipnameFailedAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
comment|/* rname */
if|if
condition|(
name|tp
operator|+
literal|5
operator|*
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|dlenUnderrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETLONG
argument_list|(
name|serial
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|+=
literal|4
operator|*
name|INT32SZ
expr_stmt|;
comment|/* Skip rest of SOA. */
if|if
condition|(
call|(
name|u_int
call|)
argument_list|(
name|tp
operator|-
name|rdatap
argument_list|)
operator|!=
name|dlen
condition|)
block|{
name|formerrmsg
operator|=
name|dlenOverrunAnswer
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
operator|,
name|qs
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
break|break;
if|if
condition|(
name|n
operator|==
name|qp
operator|->
name|q_naddr
condition|)
block|{
name|qserial_answer
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
name|qs
operator|->
name|serial
operator|=
name|serial
expr_stmt|;
block|}
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 *  Non-authoritative, no answer, no error, with referral. 	 */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
operator|!
name|hp
operator|->
name|aa
operator|&&
name|ancount
operator|==
literal|0
operator|&&
name|aucount
operator|>
literal|0
ifdef|#
directive|ifdef
name|BIND_NOTIFY
operator|&&
name|hp
operator|->
name|opcode
operator|!=
name|NS_NOTIFY_OP
endif|#
directive|endif
condition|)
block|{
name|u_char
modifier|*
name|tp
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 		 * Since there is no answer section (ancount == 0), 		 * we must be pointing at the authority section (aucount> 0). 		 */
name|tp
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|tp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|formerrmsg
operator|=
name|expandFailedAuth
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|tp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|tp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAuth
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|qp
argument_list|,
name|name
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|name
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|formerrmsg
operator|=
name|badNameFound
expr_stmt|;
goto|goto
name|refused
goto|;
block|}
comment|/* 		 * If the answer delegates us either to the same level in 		 * the hierarchy or closer to the root, we consider this 		 * server lame.  Note that for now we only log the message 		 * if the T_NS was C_IN, which is technically wrong (NS is 		 * visible in all classes) but necessary anyway (non-IN 		 * classes tend to not have good strong delegation graphs). 		 */
if|if
condition|(
name|type
operator|==
name|T_NS
operator|&&
name|ns_samedomain
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdLDel
argument_list|)
expr_stmt|;
name|mark_lame
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|mark_bad
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_IN
operator|&&
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|nhash
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
argument_list|)
condition|)
block|{
name|char
modifier|*
name|learnt_from
init|=
name|learntFrom
argument_list|(
name|qp
argument_list|,
operator|&
name|from
argument_list|)
decl_stmt|;
name|ns_info
argument_list|(
name|ns_log_lame_servers
argument_list|,
literal|"Lame server on '%s' (in '%s'?): %s%s"
argument_list|,
name|qname
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
operator|(
name|learnt_from
operator|==
name|NULL
operator|)
condition|?
literal|""
else|:
name|learnt_from
argument_list|)
expr_stmt|;
if|if
condition|(
name|learnt_from
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|learnt_from
argument_list|)
expr_stmt|;
block|}
name|fast_retry
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * Add the info received in the response to the data base. 	 */
name|arfirst
operator|=
name|ancount
operator|+
name|aucount
expr_stmt|;
name|c
operator|=
name|arfirst
operator|+
name|arcount
expr_stmt|;
comment|/* Don't return if it's a TSIG signed truncated message */
if|if
condition|(
name|has_tsig
operator|>
literal|0
operator|&&
name|hp
operator|->
name|tc
condition|)
goto|goto
name|tcp_retry
goto|;
comment|/* -ve $ing non-existence of record, must handle non-authoritative 	 * NOERRORs with c == 0. 	 */
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
operator|&&
operator|!
name|hp
operator|->
name|tc
operator|&&
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|c
operator|==
literal|0
condition|)
goto|goto
name|return_msg
goto|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
expr_stmt|;
else|else
name|dbflags
operator|=
name|DB_NOTAUTH
operator||
name|DB_NODATA
operator||
name|DB_NOHINTS
expr_stmt|;
name|count
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
condition|)
name|dbflags
operator||=
name|DB_PRIMING
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
block|{
name|count
operator|-=
name|arcount
expr_stmt|;
comment|/* truncation had to affect this */
if|if
condition|(
operator|!
name|arcount
condition|)
block|{
name|count
operator|-=
name|aucount
expr_stmt|;
comment|/* guess it got this too */
block|}
if|if
condition|(
operator|!
operator|(
name|arcount
operator|||
name|aucount
operator|)
condition|)
block|{
name|count
operator|-=
name|ancount
expr_stmt|;
comment|/* things are pretty grim */
block|}
name|tcp_retry
label|:
comment|/* retry using tcp provided this was not a tcp query */
if|if
condition|(
operator|!
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_USEVC
operator|)
condition|)
block|{
name|qp
operator|->
name|q_flags
operator||=
name|Q_USEVC
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
literal|60
argument_list|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|key
operator|=
name|tsig_key_from_addr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|smsgsize
operator|=
name|qp
operator|->
name|q_msglen
operator|+
name|TSIG_BUF_SIZE
expr_stmt|;
name|smsg
operator|=
name|memget
argument_list|(
name|smsgsize
argument_list|)
expr_stmt|;
name|smsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|smsg
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_sign
argument_list|(
name|smsg
argument_list|,
operator|&
name|smsglen
argument_list|,
name|smsgsize
argument_list|,
name|NOERROR
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|oldqbuf
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|oldqlen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|smsglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|smsg
expr_stmt|;
name|has_tsig
operator|=
literal|1
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|new_tsig
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tcp_send
argument_list|(
name|qp
argument_list|)
operator|!=
name|NOERROR
condition|)
comment|/* 				 * We're probably in trouble if tcp_send 				 * failed, but we'll try to press on because 				 * there isn't anything else to do. 				 */
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_tsig
operator|==
literal|1
condition|)
block|{
name|memput
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|smsgsize
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|oldqbuf
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|oldqlen
expr_stmt|;
block|}
return|return;
block|}
elseif|else
if|if
condition|(
operator|!
name|qsp
condition|)
block|{
comment|/* outstanding udp response */
return|return;
block|}
comment|/* XXX truncated tcp response */
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_resp: TCP truncated: \"%s\" %s %s from %s"
argument_list|,
name|qname
argument_list|,
name|p_class
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark this server as bad */
name|mark_bad
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
comment|/* try another server, it may have a bigger write buffer */
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
name|tp
operator|=
name|cp
expr_stmt|;
name|restart
operator|=
literal|0
expr_stmt|;
name|validanswer
operator|=
literal|0
expr_stmt|;
name|nscount
operator|=
literal|0
expr_stmt|;
name|soacount
operator|=
literal|0
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
name|lastwascname
operator|=
literal|0
expr_stmt|;
name|externalcname
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|aname
argument_list|,
name|qname
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
block|{
comment|/* allocate 1 extra record for end of set detection */
name|flushset_size
operator|=
operator|(
name|count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|flushset
expr_stmt|;
name|flushset
operator|=
name|memget
argument_list|(
name|flushset_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushset
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"flushset: out of memory"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|flushset
argument_list|,
literal|0
argument_list|,
name|flushset_size
argument_list|)
expr_stmt|;
block|}
else|else
name|flushset
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|type
decl_stmt|;
name|freestr_maybe
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>=
name|eom
condition|)
block|{
name|free_related_additional
argument_list|()
expr_stmt|;
if|if
condition|(
name|flushset
operator|!=
name|NULL
condition|)
name|free_flushset
argument_list|(
name|flushset
argument_list|,
name|flushset_size
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
name|n
operator|=
name|rrextract
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|cp
argument_list|,
operator|&
name|dp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|,
name|from
argument_list|,
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|free_related_additional
argument_list|()
expr_stmt|;
name|freestr_maybe
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushset
operator|!=
name|NULL
condition|)
name|free_flushset
argument_list|(
name|flushset
argument_list|,
name|flushset_size
argument_list|)
expr_stmt|;
name|formerrmsg
operator|=
name|outofDataFinal
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|REFUSED
condition|)
goto|goto
name|refused
goto|;
else|else
goto|goto
name|formerr
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
continue|continue;
name|type
operator|=
name|dp
operator|->
name|d_type
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|ancount
condition|)
block|{
comment|/* Answer section. */
if|if
condition|(
name|externalcname
operator|||
name|ns_samename
argument_list|(
name|name
argument_list|,
name|aname
argument_list|)
operator|!=
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|externalcname
condition|)
name|ns_info
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|"wrong ans. name (%s != %s)"
argument_list|,
name|name
index|[
literal|0
index|]
condition|?
name|name
else|:
literal|"."
argument_list|,
name|aname
index|[
literal|0
index|]
condition|?
name|aname
else|:
literal|"."
argument_list|)
expr_stmt|;
else|else
name|ns_debug
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|3
argument_list|,
literal|"ignoring answer '%s' after external cname"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|qtype
operator|!=
name|T_CNAME
operator|&&
name|qtype
operator|!=
name|T_ANY
condition|)
block|{
name|strcpy
argument_list|(
name|aname
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ns_samedomain
argument_list|(
name|aname
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
condition|)
name|externalcname
operator|=
literal|1
expr_stmt|;
name|cname
operator|++
expr_stmt|;
name|lastwascname
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|validanswer
operator|=
literal|1
expr_stmt|;
name|lastwascname
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tname
operator|!=
name|NULL
condition|)
block|{
name|add_related_additional
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
name|dp
operator|->
name|d_cred
operator|=
operator|(
name|hp
operator|->
name|aa
operator|&&
name|ns_samename
argument_list|(
name|name
argument_list|,
name|qname
argument_list|)
operator|==
literal|1
operator|)
condition|?
name|DB_C_AUTH
else|:
name|DB_C_ANSWER
expr_stmt|;
block|}
else|else
block|{
comment|/* After answer section. */
if|if
condition|(
name|lastwascname
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|3
argument_list|,
literal|"last was cname, ignoring auth. and add."
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|arfirst
condition|)
block|{
comment|/* Authority section. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_NS
case|:
case|case
name|T_SOA
case|:
if|if
condition|(
operator|!
name|ns_samedomain
argument_list|(
name|aname
argument_list|,
name|name
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|"bad referral (%s !< %s)"
argument_list|,
name|aname
index|[
literal|0
index|]
condition|?
name|aname
else|:
literal|"."
argument_list|,
name|name
index|[
literal|0
index|]
condition|?
name|name
else|:
literal|"."
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
name|ns_samedomain
argument_list|(
name|name
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|externalcname
condition|)
name|ns_info
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|"bad referral (%s !< %s)"
argument_list|,
name|name
index|[
literal|0
index|]
condition|?
name|name
else|:
literal|"."
argument_list|,
name|qp
operator|->
name|q_domain
index|[
literal|0
index|]
condition|?
name|qp
operator|->
name|q_domain
else|:
literal|"."
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_NS
condition|)
block|{
name|nscount
operator|++
expr_stmt|;
name|add_related_additional
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|soacount
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|T_NXT
case|:
comment|/* XXX check */
break|break;
case|case
name|T_SIG
case|:
comment|/* XXX check that it relates to an 					   NS or SOA or NXT */
break|break;
default|default:
name|ns_info
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|"invalid RR type '%s' in authority section (name = '%s') from %s"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dp
operator|->
name|d_cred
operator|=
operator|(
name|hp
operator|->
name|aa
operator|&&
operator|(
name|cname
operator|==
literal|0
operator|)
operator|)
condition|?
name|DB_C_AUTH
else|:
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
name|DB_C_ANSWER
else|:
name|DB_C_ADDITIONAL
expr_stmt|;
block|}
else|else
block|{
comment|/* Additional section. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_AAAA
case|:
if|if
condition|(
name|externalcname
operator|||
operator|!
name|ns_samedomain
argument_list|(
name|name
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|3
argument_list|,
literal|"ignoring additional info '%s' type %s"
argument_list|,
name|name
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|related_additional
argument_list|(
name|name
argument_list|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|"unrelated additional info '%s' type %s from %s"
argument_list|,
name|name
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
name|T_KEY
case|:
comment|/* XXX  check? */
break|break;
case|case
name|T_SIG
case|:
comment|/* 					 * XXX  a SIG RR should relate 					 * to some other RR in this section, 					 * although if it's the last RR 					 * it might be a transaction signature. 					 */
break|break;
default|default:
name|ns_info
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|"invalid RR type '%s' in additional section (name = '%s') from %s"
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|name
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|)
expr_stmt|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|dp
operator|->
name|d_cred
operator|=
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|?
name|DB_C_ANSWER
else|:
name|DB_C_ADDITIONAL
expr_stmt|;
block|}
block|}
name|rrsetadd
argument_list|(
name|flushset
argument_list|,
name|name
argument_list|,
name|dp
argument_list|)
expr_stmt|;
block|}
name|free_related_additional
argument_list|()
expr_stmt|;
name|freestr_maybe
argument_list|(
operator|&
name|tname
argument_list|)
expr_stmt|;
if|if
condition|(
name|flushset
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
operator|&&
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
condition|)
block|{
name|check_hints
argument_list|(
name|flushset
argument_list|)
expr_stmt|;
comment|/* before rrsetupdate */
name|rrsetupdate
argument_list|(
name|flushset
argument_list|,
name|dbflags
argument_list|,
name|from
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
name|rrsetupdate
argument_list|(
name|flushset
argument_list|,
name|dbflags
argument_list|,
name|from
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free_flushset
argument_list|(
name|flushset
argument_list|,
name|flushset_size
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|lastwascname
operator|&&
operator|!
name|externalcname
condition|)
name|ns_debug
argument_list|(
name|ns_log_cname
argument_list|,
literal|3
argument_list|,
literal|"%s (%s) q(%s %s %s) %s qd(%s)"
argument_list|,
name|danglingCname
argument_list|,
name|aname
argument_list|,
operator|(
name|qname
operator|&&
operator|*
name|qname
operator|)
condition|?
name|qname
else|:
literal|"."
argument_list|,
name|p_class
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|qp
operator|->
name|q_domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|formerrmsg
operator|=
name|outofDataAFinal
expr_stmt|;
goto|goto
name|formerr
goto|;
block|}
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
operator|)
operator|&&
name|ancount
condition|)
block|{
if|if
condition|(
operator|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_PRIMING
operator|)
operator|&&
operator|!
name|check_root
argument_list|()
condition|)
block|{
comment|/* mark server as bad */
name|mark_bad
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|fast_retry
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
return|return;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: leaving, SYSQUERY ancount %d"
argument_list|,
name|ancount
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BIND_NOTIFY
if|if
condition|(
name|qp
operator|->
name|q_notifyzone
operator|!=
name|DB_Z_CACHE
condition|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
operator|&
name|zones
index|[
name|qp
operator|->
name|q_notifyzone
index|]
decl_stmt|;
name|qp
operator|->
name|q_notifyzone
operator|=
name|DB_Z_CACHE
expr_stmt|;
name|ns_notify
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_class
argument_list|,
name|ns_t_soa
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ancount
operator|&&
name|count
operator|&&
operator|!
name|validanswer
condition|)
block|{
comment|/* 		 * Everything passed validation but we didn't get the 		 * final answer.  The response must have contained 		 * a dangling CNAME.  Force a restart of the query. 		 * 		 * Don't set restart if count==0, since this means 		 * the response was truncated in the answer section, 	         * causing us to set count to 0 which will cause 		 * validanswer to be 0 as well even though the answer 		 * section probably contained valid RRs (just not 		 * a complete set). 		 * XXX - this works right if we can just forward this 		 * response to the client, but not if we found a CNAME 		 * in a prior response and restarted the query. 		 */
name|restart
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|restart
operator|&&
operator|!
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
operator|>
literal|1
operator|&&
name|qtype
operator|==
name|T_A
condition|)
name|sort_response
argument_list|(
name|tp
argument_list|,
name|eom
argument_list|,
name|ancount
argument_list|,
operator|&
name|qp
operator|->
name|q_from
argument_list|)
expr_stmt|;
comment|/* 	 * An answer to a T_ANY query or a successful answer to a 	 * regular query with no indirection, then just return answer. 	 */
if|if
condition|(
operator|!
name|restart
operator|&&
name|ancount
operator|&&
operator|(
name|qtype
operator|==
name|T_ANY
operator|||
operator|!
name|qp
operator|->
name|q_cmsglen
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: got as much answer as there is"
argument_list|)
expr_stmt|;
goto|goto
name|return_msg
goto|;
block|}
comment|/* 	 * We might want to cache this negative answer. 	 * 	 * if ancount != 0 and rcode == NOERROR we cannot determine if the 	 * CNAME chain has been processed to completion or not, so just 	 * restart the query. DNS needs a NODATA return code! 	 * 	 * As some servers incorrectly return a NODATA indication when 	 * there is a CNAME chain instead of NXDOMAIN, we requery to get 	 * a definitive answer. 	 */
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
operator|&&
name|cname
operator|==
name|ancount
operator|)
operator|||
operator|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR
operator|&&
name|ancount
operator|==
literal|0
operator|&&
operator|(
name|nscount
operator|==
literal|0
operator|||
name|soacount
operator|!=
literal|0
operator|)
operator|)
condition|)
block|{
name|cache_n_resp
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|from
argument_list|,
name|qp
operator|->
name|q_name
argument_list|,
name|qp
operator|->
name|q_class
argument_list|,
name|qp
operator|->
name|q_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_cmsglen
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: leaving NO: auth = %d"
argument_list|,
name|hp
operator|->
name|aa
argument_list|)
expr_stmt|;
goto|goto
name|return_msg
goto|;
block|}
name|forcecmsg
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 	 * All messages in here need further processing.  i.e. they 	 * are either CNAMEs or we got referred again. 	 */
name|count
operator|=
literal|0
expr_stmt|;
name|founddata
operator|=
literal|0
expr_stmt|;
name|dname
operator|=
name|name
expr_stmt|;
comment|/* 	 * If restart==0 and ancount> 0, we should 	 * have some valid data because because the data in the answer 	 * section is owned by the query name and that passes the 	 * validation test by definition 	 * 	 * XXX - the restart stuff doesn't work if any of the answer RRs 	 * is not cacheable (TTL==0 or unknown RR type), since all of the 	 * answer must pass through the cache and be re-assembled. 	 */
if|if
condition|(
operator|(
name|forcecmsg
operator|&&
name|qp
operator|->
name|q_cmsglen
operator|)
operator|||
operator|(
operator|(
operator|!
name|restart
operator|||
operator|!
name|cname
operator|)
operator|&&
name|qp
operator|->
name|q_cmsglen
operator|&&
name|ancount
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"Cname second pass"
argument_list|)
expr_stmt|;
name|newmsglen
operator|=
name|MIN
argument_list|(
name|PACKETSZ
argument_list|,
name|qp
operator|->
name|q_cmsglen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newmsg
argument_list|,
name|qp
operator|->
name|q_cmsg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|newmsglen
operator|=
name|MIN
argument_list|(
name|PACKETSZ
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|newmsg
argument_list|,
name|msg
argument_list|,
name|newmsglen
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
name|dnptrs
index|[
literal|0
index|]
operator|=
name|newmsg
expr_stmt|;
name|dnptrs
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|newmsg
operator|+
name|HFIXEDSZ
expr_stmt|;
comment|/* 	 * Keep in mind that none of this code works when QDCOUNT>1. 	 * cp ends up pointed just past the query section in both cases. 	 */
comment|/* 	 * Arrange for dname to contain the query name. The query 	 * name can be either the original query name if restart==0 	 * or the target of the last CNAME if we are following a 	 * CNAME chain and were referred. 	 */
name|n
operator|=
name|dn_expand
argument_list|(
name|newmsg
argument_list|,
name|newmsg
operator|+
name|newmsglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"dn_expand failed"
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
operator|!
name|res_dnok
argument_list|(
name|dname
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"bad name (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|newmsg
argument_list|)
operator|-
operator|(
name|cp
operator|-
name|newmsg
operator|)
expr_stmt|;
name|cname
operator|=
literal|0
expr_stmt|;
name|try_again
label|:
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"resp: nlookup(%s) qtype=%d"
argument_list|,
name|dname
argument_list|,
name|qtype
argument_list|)
expr_stmt|;
name|foundname
operator|=
literal|0
expr_stmt|;
name|fname
operator|=
literal|""
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
comment|/* lookup relative to root */
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"resp: %s '%s' as '%s' (cname=%d)"
argument_list|,
name|np
operator|==
name|NULL
condition|?
literal|"missed"
else|:
literal|"found"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
goto|goto
name|fetch_ns
goto|;
name|foundname
operator|++
expr_stmt|;
name|answers
operator|=
name|cp
expr_stmt|;
name|count
operator|=
name|cp
operator|-
name|newmsg
expr_stmt|;
comment|/* 	 * Look for NXDOMAIN record. 	 */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|stale
argument_list|(
name|dp
argument_list|)
operator|&&
operator|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_class
operator|==
operator|(
name|int
operator|)
name|qclass
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|RETURNSOA
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|qclass
argument_list|,
name|T_SOA
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|count
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|newmsglen
operator|+=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
goto|goto
name|return_newmsg
goto|;
block|}
block|}
else|#
directive|else
name|count
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
comment|/*  			 * XXX forcing AA all the time isn't right, but 			 * we have to work that way by default 			 * for compatibility with older servers. 			 */
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_NONAUTH_NXDOMAIN
argument_list|)
condition|)
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: NXDOMAIN aa = %d"
argument_list|,
name|hp
operator|->
name|aa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORFC2308_TYPE1
argument_list|)
condition|)
goto|goto
name|return_newmsg
goto|;
name|founddata
operator|=
literal|1
expr_stmt|;
goto|goto
name|fetch_ns
goto|;
block|}
block|}
name|n
operator|=
name|finddata
argument_list|(
name|np
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|hp
argument_list|,
operator|&
name|dname
argument_list|,
operator|&
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
goto|goto
name|fetch_ns
goto|;
comment|/* NO data available */
if|if
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NOERROR_NODATA
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NOERROR
expr_stmt|;
ifdef|#
directive|ifdef
name|RETURNSOA
if|if
condition|(
name|count
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|count
operator|==
literal|0
operator|)
operator|||
name|NS_OPTION_P
argument_list|(
name|OPTION_NORFC2308_TYPE1
argument_list|)
condition|)
goto|goto
name|return_newmsg
goto|;
name|founddata
operator|=
literal|1
expr_stmt|;
goto|goto
name|fetch_ns
goto|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|+
operator|(
name|u_int16_t
operator|)
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|fname
operator|!=
name|dname
operator|&&
name|qtype
operator|!=
name|T_CNAME
operator|&&
name|qtype
operator|!=
name|T_ANY
condition|)
block|{
name|cname
operator|++
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
name|founddata
operator|=
literal|1
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: foundname=%d, count=%d, founddata=%d, cname=%d"
argument_list|,
name|foundname
argument_list|,
name|count
argument_list|,
name|founddata
argument_list|,
name|cname
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
operator|&&
name|qtype
operator|==
name|T_A
condition|)
name|sort_response
argument_list|(
name|answers
argument_list|,
name|cp
argument_list|,
name|count
argument_list|,
operator|&
name|qp
operator|->
name|q_from
argument_list|)
expr_stmt|;
name|fetch_ns
label|:
if|if
condition|(
name|hp
operator|->
name|tc
condition|)
goto|goto
name|return_newmsg
goto|;
comment|/*  	 * Look for name servers to refer to and fill in the authority  	 * section or record the address for forwarding the query  	 * (recursion desired).  	 */
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|qclass
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* shouldn't happen */
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"req: leaving (%s, rcode %d)"
argument_list|,
name|dname
argument_list|,
name|hp
operator|->
name|rcode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|foundname
condition|)
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|qclass
operator|!=
name|C_ANY
condition|)
block|{
name|hp
operator|->
name|aa
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|&&
operator|(
operator|!
name|foundname
operator|||
operator|!
name|founddata
operator|)
condition|)
block|{
name|n
operator|=
name|doaddauth
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
name|np
argument_list|,
name|nsp
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
block|}
block|}
goto|goto
name|return_newmsg
goto|;
case|case
name|SERVFAIL
case|:
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
name|founddata
condition|)
block|{
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|newmsg
expr_stmt|;
name|n
operator|=
name|add_data
argument_list|(
name|np
argument_list|,
name|nsp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|n
operator|=
operator|(
operator|-
name|n
operator|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|count
operator|+
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|return_newmsg
goto|;
block|}
comment|/* 	 *  If we get here, we don't have the answer yet and are about 	 *  to iterate to try and get it.  First, infinite loop avoidance. 	 */
if|if
condition|(
name|qp
operator|->
name|q_nqueries
operator|++
operator|>
name|MAXQUERIES
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"resp: MAXQUERIES exceeded (%s %s %s)"
argument_list|,
name|dname
argument_list|,
name|p_class
argument_list|(
name|qclass
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|qtype
argument_list|)
argument_list|)
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"MAXQUERIES exceeded, possible data loop in resolving (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
comment|/* Reset the query control structure */
name|ns_freeqns
argument_list|(
name|qp
argument_list|,
literal|"ns_resp"
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_naddr
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_curaddr
operator|=
literal|0
expr_stmt|;
name|nsfwdadd
argument_list|(
name|qp
argument_list|,
name|NS_ZFWDTAB
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_domain
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|tmpdomain
argument_list|,
sizeof|sizeof
name|tmpdomain
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_domain
operator|=
name|savestr
argument_list|(
name|tmpdomain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|NS_ZOPTION_P
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|,
name|OPTION_FORWARD_ONLY
argument_list|)
condition|)
name|n
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|n
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"ns_resp"
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: nslookup reports danger"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
condition|)
comment|/* a remote CNAME that does not have data */
goto|goto
name|return_newmsg
goto|;
goto|goto
name|servfail
goto|;
block|}
else|else
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: no addrs found for NS's"
argument_list|)
expr_stmt|;
comment|/* 			 * Timeout while sysquery looks up the NS addresses. 			 * 			 * Hopefully we'll have them when the client asks 			 * again. 			 * 			 * too bad we can't just wait for the sysquery 			 * response to restart this query (it's too hard). 			 * 			 * We could try to crawl back up the tree looking 			 * for reachable servers, but we may have just 			 * gotten delegated down here by a response with 			 * no A RRs for the servers.  If we blindly tried 			 * this strategy, we bang on the same server forever. 			 */
goto|goto
name|timeout
goto|;
block|}
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
operator|(
name|u_int
operator|)
name|n
operator|<
name|qp
operator|->
name|q_naddr
condition|;
name|n
operator|++
control|)
name|qp
operator|->
name|q_addr
index|[
name|n
index|]
operator|.
name|stime
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
if|if
condition|(
name|cname
condition|)
block|{
if|if
condition|(
name|qp
operator|->
name|q_cname
operator|++
operator|==
name|MAXCNAMES
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: leaving, MAXCNAMES exceeded"
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"q_cname = %d"
argument_list|,
name|qp
operator|->
name|q_cname
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: building recursive query; nslookup"
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_cmsg
operator|==
name|NULL
condition|)
block|{
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|qp
operator|->
name|q_cmsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_cmsgsize
operator|=
name|qp
operator|->
name|q_msgsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msgsize
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_msg
operator|==
name|NULL
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"resp: memget error"
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
name|qp
operator|->
name|q_msgsize
operator|=
name|PACKETSZ
expr_stmt|;
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|dname
argument_list|,
name|qclass
argument_list|,
name|qtype
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"resp: res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|servfail
goto|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_name
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|qp
operator|->
name|q_name
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_name
operator|=
name|savestr
argument_list|(
name|dname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|forwarder
condition|)
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"resp: forw -> %s ds=%d nsid=%d id=%d %dms"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|nsa
argument_list|)
argument_list|,
name|ds
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|,
operator|(
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|!=
name|NULL
operator|)
condition|?
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|nsdata
operator|->
name|d_nstime
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|key
operator|=
name|tsig_key_from_addr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|smsgsize
operator|=
name|qp
operator|->
name|q_msglen
operator|+
name|TSIG_BUF_SIZE
expr_stmt|;
name|smsg
operator|=
name|memget
argument_list|(
name|smsgsize
argument_list|)
expr_stmt|;
name|smsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|smsg
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_sign
argument_list|(
name|smsg
argument_list|,
operator|&
name|smsglen
argument_list|,
name|smsgsize
argument_list|,
name|NOERROR
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|oldqbuf
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|oldqlen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|smsglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|smsg
expr_stmt|;
name|has_tsig
operator|=
literal|1
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|new_tsig
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_USEVC
condition|)
block|{
if|if
condition|(
name|tcp_send
argument_list|(
name|qp
argument_list|)
operator|!=
name|NOERROR
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|tcpsendStr
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_forw: tcp_send(%s) failed: %s"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sendto
argument_list|(
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sendto_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|sendtoStr
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"ns_resp: sendto(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_tsig
operator|==
literal|1
condition|)
block|{
name|memput
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|smsgsize
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|oldqbuf
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|oldqlen
expr_stmt|;
block|}
name|hp
operator|->
name|rd
operator|=
literal|0
expr_stmt|;
comment|/* leave set to 0 for dup detection */
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentFwdR
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFwdR
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"resp: Query sent."
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sendto_errno
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return;
name|formerr
label|:
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|formerrmsg
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_resp_checks
argument_list|,
literal|"Malformed response from %s (%s)"
argument_list|,
name|sin_ntoa
argument_list|(
name|from
argument_list|)
argument_list|,
name|formerrmsg
argument_list|)
expr_stmt|;
name|fast_retry
argument_list|(
name|qp
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|return_msg
label|:
name|nameserIncr
argument_list|(
name|from
operator|.
name|sin_addr
argument_list|,
name|nssRcvdFwdR
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFwdR
argument_list|)
expr_stmt|;
comment|/* The "standard" return code */
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|return_newmsg
label|:
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentAns
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentNaAns
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|NXDOMAIN
condition|)
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentNXD
argument_list|)
expr_stmt|;
name|n
operator|=
name|doaddinfo
argument_list|(
name|hp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
name|newmsg
argument_list|,
name|cp
operator|-
name|newmsg
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|refused
label|:
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_cmsglen
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|hp
argument_list|,
operator|(
name|qp
operator|->
name|q_cmsglen
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|servfail
label|:
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSentFail
argument_list|)
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|(
name|qp
operator|->
name|q_cmsglen
condition|?
name|qp
operator|->
name|q_cmsg
else|:
name|qp
operator|->
name|q_msg
operator|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|SERVFAIL
expr_stmt|;
name|hp
operator|->
name|qr
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_id
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|ra
operator|=
operator|(
name|NS_OPTION_P
argument_list|(
name|OPTION_NORECURSE
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|send_msg
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|hp
argument_list|,
operator|(
name|qp
operator|->
name|q_cmsglen
condition|?
name|qp
operator|->
name|q_cmsglen
else|:
name|qp
operator|->
name|q_msglen
operator|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
name|timeout
label|:
if|if
condition|(
name|qp
operator|->
name|q_stream
condition|)
name|sq_remove
argument_list|(
name|qp
operator|->
name|q_stream
argument_list|)
expr_stmt|;
name|qremove
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_define
define|#
directive|define
name|BOUNDS_CHECK
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
define|\
value|do { \ 		if ((ptr) + (count)> eom) { \ 			hp->rcode = FORMERR; \ 			return (-1); \ 		} \ 	} while (0)
end_define

begin_function
specifier|static
name|int
name|rrextract
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|u_char
modifier|*
name|rrp
parameter_list|,
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
parameter_list|,
name|char
modifier|*
name|dname
parameter_list|,
name|int
name|namelen
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|char
modifier|*
modifier|*
name|tnamep
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|eom
decl_stmt|,
modifier|*
name|rdatap
decl_stmt|;
name|u_int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
name|data
index|[
name|MAXDATA
operator|*
literal|2
index|]
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|enum
name|context
name|context
decl_stmt|;
if|if
condition|(
name|tnamep
operator|!=
name|NULL
condition|)
operator|*
name|tnamep
operator|=
name|NULL
expr_stmt|;
operator|*
name|dpp
operator|=
name|NULL
expr_stmt|;
name|cp
operator|=
name|rrp
expr_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
name|namelen
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|2
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|+
name|INT16SZ
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|>
name|CLASS_MAX
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"bad class in rrextract"
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttl
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"%s: converted TTL> %u to 0"
argument_list|,
name|dname
argument_list|,
name|MAXIMUM_TTL
argument_list|)
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|rdatap
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|ns_ownercontext
argument_list|(
name|type
argument_list|,
name|response_trans
argument_list|)
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|REFUSED
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"rrextract: dname %s type %d class %d ttl %d"
argument_list|,
name|dname
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the resource record data into the internal 	 * database format. 	 * 	 * On entry to the switch: 	 *   CP points to the RDATA section of the wire-format RR. 	 *   DLEN is its length. 	 *   The memory area at DATA is available for processing. 	 *  	 * On exit from the switch: 	 *   CP has been incremented past the RR. 	 *   CP1 points to the RDATA section of the database-format RR. 	 *   N contains the length of the RDATA section of the dbase-format RR. 	 * 	 * The new data at CP1 for length N will be copied into the database, 	 * so it need not be in any particular storage location. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
if|if
condition|(
name|dlen
operator|!=
name|INT32SZ
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/*FALLTHROUGH*/
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_NSAP
case|:
case|case
name|T_AAAA
case|:
case|case
name|T_LOC
case|:
case|case
name|T_KEY
case|:
case|case
name|ns_t_cert
case|:
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|type
operator|==
name|T_PTR
condition|?
name|ns_ptrcontext
argument_list|(
name|dname
argument_list|)
else|:
name|domain_ctx
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tnamep
operator|!=
name|NULL
operator|&&
operator|(
name|type
operator|==
name|T_NS
operator|||
name|type
operator|==
name|T_MB
operator|)
condition|)
operator|*
name|tnamep
operator|=
name|savestr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
name|context
operator|=
name|hostname_ctx
expr_stmt|;
goto|goto
name|soa_rp_minfo
goto|;
case|case
name|T_RP
case|:
case|case
name|T_MINFO
case|:
name|context
operator|=
name|mailname_ctx
expr_stmt|;
comment|/* FALLTHROUGH */
name|soa_rp_minfo
label|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|context
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* 		 * The next use of 'cp' is dn_expand(), so we don't have 		 * to BOUNDS_CHECK() here. 		 */
name|cp1
operator|=
name|data
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|T_RP
condition|)
name|context
operator|=
name|domain_ctx
expr_stmt|;
else|else
name|context
operator|=
name|mailname_ctx
expr_stmt|;
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|context
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|n
operator|=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_NAPTR
case|:
comment|/* Grab weight and port. */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
comment|/* Flags */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Service */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Regexp */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Replacement */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp1
operator|-
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|hostname_ctx
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
comment|/* grab preference */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SRV
condition|)
block|{
comment|/* Grab weight and port. */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
block|}
comment|/* get name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp1
operator|-
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|hostname_ctx
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|tnamep
operator|!=
name|NULL
condition|)
operator|*
name|tnamep
operator|=
name|savestr
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
comment|/* grab preference */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get MAP822 name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|domain_ctx
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* 		 * The next use of 'cp' is dn_expand(), so we don't have 		 * to BOUNDS_CHECK() here. 		 */
name|cp1
operator|+=
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|domain_ctx
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_SIG
case|:
block|{
name|u_long
name|origTTL
decl_stmt|,
name|exptime
decl_stmt|,
name|signtime
decl_stmt|,
name|timetilexp
decl_stmt|,
name|now
decl_stmt|;
name|u_int8_t
name|alg
decl_stmt|;
comment|/* Check signature time, expiration, and adjust TTL.  */
comment|/* This code is similar to that in db_load.c.  */
comment|/* Skip coveredType, save alg, skip labels */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|+
literal|1
operator|+
literal|1
operator|+
literal|3
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|cp
operator|+
name|INT16SZ
expr_stmt|;
name|alg
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|cp1
operator|++
expr_stmt|;
name|GETLONG
argument_list|(
name|origTTL
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|exptime
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|signtime
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|now
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get current time in GMT/UTC */
comment|/* Don't let bogus name servers increase the signed TTL */
if|if
condition|(
name|ttl
operator|>
name|origTTL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"shrinking SIG TTL from %d to origTTL %d"
argument_list|,
name|ttl
argument_list|,
name|origTTL
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|origTTL
expr_stmt|;
block|}
comment|/* Don't let bogus signers "sign" in the future.  */
if|if
condition|(
name|signtime
operator|>
name|now
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ignoring SIG: signature date %s is in the future"
argument_list|,
name|p_secstodate
argument_list|(
name|signtime
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
comment|/* Ignore received SIG RR's that are already expired.  */
if|if
condition|(
name|exptime
operator|<=
name|now
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"ignoring SIG: expiration %s is in the past"
argument_list|,
name|p_secstodate
argument_list|(
name|exptime
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
comment|/* Lop off the TTL at the expiration time.  */
name|timetilexp
operator|=
name|exptime
operator|-
name|now
expr_stmt|;
if|if
condition|(
name|timetilexp
operator|<
name|ttl
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"shrinking expiring %s SIG TTL from %d to %d"
argument_list|,
name|p_secstodate
argument_list|(
name|exptime
argument_list|)
argument_list|,
name|ttl
argument_list|,
name|timetilexp
argument_list|)
expr_stmt|;
name|ttl
operator|=
name|timetilexp
expr_stmt|;
block|}
comment|/* The following code is copied from named-xfer.c.  */
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* first just copy over the type_covered, algorithm, */
comment|/* labels, orig ttl, two timestamps, and the footprint */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|18
expr_stmt|;
name|cp1
operator|+=
literal|18
expr_stmt|;
comment|/* then the signer's name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
sizeof|sizeof
name|data
operator|)
operator|-
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|+
name|NS_SIG_SIGNER
operator|>
name|dlen
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* finally, we copy over the variable-length signature. 		   Its size is the total data length, minus what we copied. */
name|n
operator|=
name|dlen
operator|-
operator|(
name|NS_SIG_SIGNER
operator|+
name|n
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
sizeof|sizeof
name|data
operator|)
operator|-
operator|(
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* out of room! */
block|}
switch|switch
condition|(
name|alg
condition|)
block|{
case|case
name|NS_ALG_MD5RSA
case|:
if|if
condition|(
name|n
operator|<
name|NS_MD5RSA_MIN_SIZE
operator|||
name|n
operator|>
name|NS_MD5RSA_MAX_SIZE
condition|)
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
break|break;
case|case
name|NS_ALG_DSA
case|:
if|if
condition|(
name|n
operator|!=
name|NS_DSA_SIG_SIZE
condition|)
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|FORMERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
block|}
case|case
name|T_NXT
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
comment|/* 		 * By testing if n>= dlen, we are requiring that the type 		 * bitmap be at least one octet.  This is reasonable 		 * because we always have to look at the 0 bit to see if 		 * this is a "different format" NXT or not. 		 */
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|n
operator|>=
name|dlen
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|ns_nameok
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
name|class
argument_list|,
name|NULL
argument_list|,
name|response_trans
argument_list|,
name|domain_ctx
argument_list|,
name|dname
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n1
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
name|n1
expr_stmt|;
comment|/* 		 * We don't need to BOUNDS_CHECK() cp here because we've 		 * previously checked that 'dlen' bytes are in bounds, and 		 * we know that n< dlen. 		 */
name|n2
operator|=
name|dlen
operator|-
name|n
expr_stmt|;
comment|/* 		 * The first bit of the first octet determines the format 		 * of the NXT record.  A format for types>= 128 has not 		 * yet been defined, so if bit zero is set, we just copy 		 * what's there because we don't understand it. 		 */
if|if
condition|(
operator|(
operator|*
name|cp
operator|&
literal|0x80
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * Bit zero is not set; this is an ordinary NXT 			 * record.  The bitmap must be at least 4 octets 			 * because the NXT bit should be set.  It should be 			 * less than or equal to 16 octets because this NXT 			 * format is only defined for types< 128. 			 */
if|if
condition|(
name|n2
operator|<
literal|4
operator|||
name|n2
operator|>
literal|16
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
name|n2
operator|>
sizeof|sizeof
name|data
operator|-
name|n1
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n2
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n2
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
default|default:
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"unknown type %d"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
call|(
name|u_int
call|)
argument_list|(
name|cp
operator|-
name|rdatap
argument_list|)
operator|!=
name|dlen
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"encoded rdata length is %u, but actual length was %u"
argument_list|,
name|dlen
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|cp
operator|-
name|rdatap
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"update type %d: %d bytes is too much data"
argument_list|,
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ttl
operator|+=
name|tt
operator|.
name|tv_sec
expr_stmt|;
operator|*
name|dpp
operator|=
name|savedata
argument_list|(
name|class
argument_list|,
name|type
argument_list|,
name|ttl
argument_list|,
name|cp1
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|rrp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|send_msg
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_char
modifier|*
name|oldmsg
decl_stmt|;
name|int
name|oldlen
decl_stmt|;
name|int
name|msgsize
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_flags
operator|&
name|Q_SYSTEM
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
operator|!
name|qp
operator|->
name|q_stream
operator|&&
operator|(
name|msglen
operator|>
name|PACKETSZ
operator|)
condition|)
name|msglen
operator|=
name|trunc_adjust
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"send_msg -> %s (%s %d) id=%d"
argument_list|,
name|sin_ntoa
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|NULL
condition|?
literal|"UDP"
else|:
literal|"TCP"
argument_list|,
name|qp
operator|->
name|q_stream
operator|==
name|NULL
condition|?
name|qp
operator|->
name|q_dfd
else|:
name|qp
operator|->
name|q_stream
operator|->
name|s_rfd
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|ns_wouldlog
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|struct
name|qinfo
modifier|*
name|tqp
decl_stmt|;
for|for
control|(
name|tqp
operator|=
name|nsqhead
init|;
name|tqp
operator|!=
name|NULL
condition|;
name|tqp
operator|=
name|tqp
operator|->
name|q_link
control|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"qp %#lx q_id: %d  q_nsid: %d q_msglen: %d"
argument_list|,
operator|(
name|u_long
operator|)
name|tqp
argument_list|,
name|tqp
operator|->
name|q_id
argument_list|,
name|tqp
operator|->
name|q_nsid
argument_list|,
name|tqp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"\tq_naddr: %d q_curaddr: %d"
argument_list|,
name|tqp
operator|->
name|q_naddr
argument_list|,
name|tqp
operator|->
name|q_curaddr
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|4
argument_list|,
literal|"\tq_next: %#lx q_link: %#lx"
argument_list|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_next
argument_list|,
operator|(
name|u_long
operator|)
name|qp
operator|->
name|q_link
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debug
operator|>=
literal|6
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|msg
argument_list|,
name|msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DEBUG */
if|if
condition|(
name|qp
operator|->
name|q_tsig
operator|!=
name|NULL
condition|)
block|{
name|u_char
name|sig
index|[
name|TSIG_SIG_SIZE
index|]
decl_stmt|;
name|int
name|siglen
init|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
decl_stmt|;
name|oldmsg
operator|=
name|msg
expr_stmt|;
name|oldlen
operator|=
name|msglen
expr_stmt|;
name|msgsize
operator|=
name|msglen
operator|+
name|TSIG_BUF_SIZE
expr_stmt|;
name|msg
operator|=
name|memget
argument_list|(
name|msgsize
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|msg
argument_list|,
name|oldmsg
argument_list|,
name|oldlen
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ns_sign
argument_list|(
name|msg
argument_list|,
operator|&
name|msglen
argument_list|,
name|msgsize
argument_list|,
name|NOERROR
argument_list|,
name|qp
operator|->
name|q_tsig
operator|->
name|key
argument_list|,
name|qp
operator|->
name|q_tsig
operator|->
name|sig
argument_list|,
name|qp
operator|->
name|q_tsig
operator|->
name|siglen
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|qp
operator|->
name|q_stream
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * Don't send FORMERR to these well known ports 		 * (loop avoidance). 		 */
switch|switch
condition|(
name|ntohs
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_port
argument_list|)
condition|)
block|{
case|case
literal|7
case|:
comment|/* echo */
case|case
literal|13
case|:
comment|/* daytime */
case|case
literal|19
case|:
comment|/* chargen */
case|case
literal|37
case|:
comment|/* time */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|==
name|FORMERR
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
default|default:
break|break;
block|}
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|qp
operator|->
name|q_from
argument_list|,
sizeof|sizeof
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|sendtoStr
argument_list|)
condition|)
if|#
directive|if
name|defined
argument_list|(
name|SPURIOUS_ECONNREFUSED
argument_list|)
if|if
condition|(
name|errno
operator|!=
name|ECONNREFUSED
condition|)
endif|#
directive|endif
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"send_msg: sendto(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
name|qp
operator|->
name|q_from
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|qp
operator|->
name|q_from
operator|.
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|writestream
argument_list|(
name|qp
operator|->
name|q_stream
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_tsig
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|msg
argument_list|,
name|oldlen
operator|+
name|TSIG_BUF_SIZE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|root_server_p
parameter_list|(
name|ns_class
name|class
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
init|=
name|find_zone
argument_list|(
literal|""
argument_list|,
name|class
argument_list|)
decl_stmt|;
return|return
operator|(
name|zp
operator|!=
name|NULL
operator|&&
operator|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_slave
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|prime_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|root
init|=
name|root_server_p
argument_list|(
name|ns_c_in
argument_list|)
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"prime_cache: priming = %d, root = %d"
argument_list|,
name|priming
argument_list|,
name|root
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priming
operator|&&
operator|!
name|root
condition|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
init|=
name|sysquery
argument_list|(
literal|""
argument_list|,
name|ns_c_in
argument_list|,
name|ns_t_ns
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ns_port
argument_list|,
name|ns_o_query
argument_list|)
decl_stmt|;
if|if
condition|(
name|qp
operator|!=
name|NULL
condition|)
block|{
name|qp
operator|->
name|q_flags
operator||=
operator|(
name|Q_SYSTEM
operator||
name|Q_PRIMING
operator|)
expr_stmt|;
name|priming
operator|++
expr_stmt|;
block|}
block|}
name|needs_prime_cache
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|struct
name|qinfo
modifier|*
name|sysquery
parameter_list|(
specifier|const
name|char
modifier|*
name|dname
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|,
name|struct
name|in_addr
modifier|*
name|nss
parameter_list|,
name|int
name|nsc
parameter_list|,
name|u_int16_t
name|port
parameter_list|,
name|int
name|opcode
parameter_list|)
block|{
name|struct
name|qinfo
modifier|*
name|qp
decl_stmt|,
modifier|*
name|oqp
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|char
name|tmpdomain
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
init|=
name|NULL
decl_stmt|;
name|struct
name|databuf
modifier|*
name|nsp
index|[
name|NSMAX
index|]
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp1
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp2
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp3
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|nsa
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|n
decl_stmt|,
name|count
decl_stmt|;
name|int
name|sendto_errno
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|oldqbuf
decl_stmt|;
name|int
name|oldqlen
decl_stmt|,
name|has_tsig
decl_stmt|;
name|u_char
modifier|*
name|smsg
decl_stmt|;
name|int
name|smsglen
decl_stmt|,
name|smsgsize
decl_stmt|,
name|siglen
decl_stmt|;
name|u_char
name|sig
index|[
name|TSIG_SIG_SIZE
index|]
decl_stmt|;
name|DST_KEY
modifier|*
name|key
decl_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"sysquery(%s, %d, %d, %#x, %d, %d)"
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|nss
argument_list|,
name|nsc
argument_list|,
name|ntohs
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|qnew
argument_list|(
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
operator|(
name|nss
operator|!=
name|NULL
operator|&&
name|nsc
operator|!=
literal|0
operator|)
condition|?
literal|0
else|:
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|nss
operator|!=
name|NULL
operator|&&
name|nsc
operator|!=
literal|0
condition|)
name|np
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|NS_ZOPTION_P
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|,
name|OPTION_FORWARD_ONLY
argument_list|)
condition|)
block|{
name|htp1
operator|=
name|hashtab
expr_stmt|;
name|htp2
operator|=
name|hashtab
expr_stmt|;
name|htp3
operator|=
name|fcachetab
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
name|dname
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|np
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp1
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
literal|""
argument_list|,
operator|&
name|htp2
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|np
operator|=
name|nlookup
argument_list|(
literal|""
argument_list|,
operator|&
name|htp3
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|NULL
operator|)
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: nlookup error on %s?"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|err1
label|:
name|ns_freeqry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|n
operator|=
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|NXDOMAIN
case|:
case|case
name|SERVFAIL
case|:
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: findns error (%s) on %s?"
argument_list|,
name|n
operator|==
name|NXDOMAIN
condition|?
literal|"NXDOMAIN"
else|:
literal|"SERVFAIL"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|err2
label|:
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
goto|goto
name|err1
goto|;
block|}
block|}
comment|/* Build new qinfo struct. */
name|qp
operator|->
name|q_cmsg
operator|=
name|qp
operator|->
name|q_msg
operator|=
name|NULL
expr_stmt|;
name|qp
operator|->
name|q_dfd
operator|=
name|ds
expr_stmt|;
if|if
condition|(
name|nss
operator|==
name|NULL
operator|||
name|nsc
operator|==
literal|0
condition|)
name|nsfwdadd
argument_list|(
name|qp
argument_list|,
name|NS_ZFWDTAB
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_expire
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|RETRY_TIMEOUT
operator|*
literal|2
expr_stmt|;
name|qp
operator|->
name|q_flags
operator||=
name|Q_SYSTEM
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|tmpdomain
argument_list|,
sizeof|sizeof
name|tmpdomain
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_domain
operator|=
name|savestr
argument_list|(
name|tmpdomain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|qp
operator|->
name|q_msg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|memget
argument_list|(
name|PACKETSZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: memget failed"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|qp
operator|->
name|q_msgsize
operator|=
name|PACKETSZ
expr_stmt|;
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|opcode
argument_list|,
name|dname
argument_list|,
name|class
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: res_mkquery(%s) failed"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|qp
operator|->
name|q_msglen
operator|=
name|n
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|qp
operator|->
name|q_msg
expr_stmt|;
name|hp
operator|->
name|id
operator|=
name|qp
operator|->
name|q_nsid
operator|=
name|htons
argument_list|(
name|nsid_next
argument_list|()
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rd
operator|=
operator|(
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
operator|.
name|forwarder
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
comment|/* First check for an already pending query for this data. */
for|for
control|(
name|oqp
operator|=
name|nsqhead
init|;
name|oqp
operator|!=
name|NULL
condition|;
name|oqp
operator|=
name|oqp
operator|->
name|q_link
control|)
block|{
if|if
condition|(
operator|(
name|oqp
operator|!=
name|qp
operator|)
operator|&&
operator|(
name|oqp
operator|->
name|q_msglen
operator|==
name|qp
operator|->
name|q_msglen
operator|)
operator|&&
name|memcmp
argument_list|(
name|oqp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msg
operator|+
literal|2
argument_list|,
name|qp
operator|->
name|q_msglen
operator|-
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BIND_NOTIFY
comment|/* XXX - need fancier test to suppress duplicate 			 *       NOTIFYs to the same server (compare nss?) 			 */
if|if
condition|(
name|opcode
operator|!=
name|NS_NOTIFY_OP
condition|)
endif|#
directive|endif
comment|/*BIND_NOTIFY*/
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"sysquery: duplicate"
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
block|}
block|}
if|if
condition|(
name|nss
operator|!=
name|NULL
operator|&&
name|nsc
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|qserv
modifier|*
name|qs
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|qs
operator|=
name|qp
operator|->
name|q_addr
init|;
name|i
operator|<
name|nsc
condition|;
name|i
operator|++
operator|,
name|qs
operator|++
control|)
block|{
name|qs
operator|->
name|ns_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_addr
operator|=
name|nss
index|[
name|i
index|]
expr_stmt|;
name|qs
operator|->
name|ns_addr
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|qs
operator|->
name|ns
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|nsdata
operator|=
name|NULL
expr_stmt|;
name|qs
operator|->
name|stime
operator|=
name|tt
expr_stmt|;
name|qs
operator|->
name|forwarder
operator|=
literal|0
expr_stmt|;
name|qs
operator|->
name|nretry
operator|=
literal|0
expr_stmt|;
block|}
name|qp
operator|->
name|q_naddr
operator|=
name|nsc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|NS_ZOPTION_P
argument_list|(
name|qp
operator|->
name|q_fzone
argument_list|,
name|OPTION_FORWARD_ONLY
argument_list|)
condition|)
block|{
name|fetch_a
label|:
name|count
operator|=
name|nslookup
argument_list|(
name|nsp
argument_list|,
name|qp
argument_list|,
name|dname
argument_list|,
literal|"sysquery"
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|count
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|n
operator|==
operator|-
literal|1
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: nslookup reports danger (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
elseif|else
if|if
condition|(
name|np
operator|&&
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* 				 * It's not too serious if we don't have 				 * the root server addresses if we have to 				 * go through a forwarder anyway.  Don't 				 * bother to log it, since prime_cache() 				 * won't do anything about it as currently 				 * implemented. 				 * 				 * XXX - should we skip setting 				 *       needs_prime_cache as well? 				 * 				 * XXX - what happens when we implement 				 *       selective forwarding? 				 */
if|if
condition|(
operator|!
name|NS_OPTION_P
argument_list|(
name|OPTION_FORWARD_ONLY
argument_list|)
condition|)
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: no addrs found for root NS (%s)"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|C_IN
operator|&&
operator|!
name|priming
condition|)
name|needs_prime_cache
operator|=
literal|1
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
if|if
condition|(
name|np
condition|)
block|{
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
name|np
operator|=
name|np_parent
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|n
operator|=
name|findns
argument_list|(
operator|&
name|np
argument_list|,
name|class
argument_list|,
name|nsp
argument_list|,
operator|&
name|count
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/*FALLTHROUGH*/
case|case
name|SERVFAIL
case|:
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: findns error (%d) on %s?"
argument_list|,
name|n
argument_list|,
name|dname
argument_list|)
expr_stmt|;
goto|goto
name|err2
goto|;
block|}
name|getname
argument_list|(
name|np
argument_list|,
name|tmpdomain
argument_list|,
sizeof|sizeof
name|tmpdomain
argument_list|)
expr_stmt|;
if|if
condition|(
name|qp
operator|->
name|q_domain
operator|!=
name|NULL
condition|)
name|freestr
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_domain
operator|=
name|savestr
argument_list|(
name|tmpdomain
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|fetch_a
goto|;
block|}
goto|goto
name|err2
goto|;
block|}
block|}
name|schedretry
argument_list|(
name|qp
argument_list|,
name|retrytime
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_addr
index|[
literal|0
index|]
operator|.
name|stime
operator|=
name|tt
expr_stmt|;
comment|/* XXX - why not every? */
name|nsa
operator|=
name|Q_NEXTADDR
argument_list|(
name|qp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"sysquery: send -> %s dfd=%d nsid=%d id=%d retry=%ld"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|nsa
argument_list|)
argument_list|,
name|qp
operator|->
name|q_dfd
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_nsid
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|qp
operator|->
name|q_id
argument_list|)
argument_list|,
operator|(
name|long
operator|)
name|qp
operator|->
name|q_time
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|10
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
name|log_get_stream
argument_list|(
name|packet_channel
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|key
operator|=
name|tsig_key_from_addr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|!=
name|NULL
condition|)
block|{
name|smsgsize
operator|=
name|qp
operator|->
name|q_msglen
operator|+
name|TSIG_BUF_SIZE
expr_stmt|;
name|smsg
operator|=
name|memget
argument_list|(
name|smsgsize
argument_list|)
expr_stmt|;
name|smsglen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|smsg
argument_list|,
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_sign
argument_list|(
name|smsg
argument_list|,
operator|&
name|smsglen
argument_list|,
name|smsgsize
argument_list|,
name|NOERROR
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|oldqbuf
operator|=
name|qp
operator|->
name|q_msg
expr_stmt|;
name|oldqlen
operator|=
name|qp
operator|->
name|q_msglen
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|smsglen
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|smsg
expr_stmt|;
name|has_tsig
operator|=
literal|1
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|new_tsig
argument_list|(
name|key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|)
expr_stmt|;
comment|/* BEW? */
block|}
else|else
block|{
name|INSIST
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|has_tsig
operator|=
literal|0
expr_stmt|;
name|free_tsig
argument_list|(
name|qp
operator|->
name|q_nstsig
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_nstsig
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|sendto
argument_list|(
name|qp
operator|->
name|q_dfd
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_msg
argument_list|,
name|qp
operator|->
name|q_msglen
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|nsa
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sendto_errno
operator|=
name|errno
expr_stmt|;
if|if
condition|(
operator|!
name|haveComplained
argument_list|(
name|ina_ulong
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|u_long
operator|)
name|sendtoStr
argument_list|)
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"sysquery: sendto(%s): %s"
argument_list|,
name|sin_ntoa
argument_list|(
operator|*
name|nsa
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSendtoErr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_tsig
operator|==
literal|1
condition|)
block|{
name|memput
argument_list|(
name|qp
operator|->
name|q_msg
argument_list|,
name|smsgsize
argument_list|)
expr_stmt|;
name|qp
operator|->
name|q_msg
operator|=
name|oldqbuf
expr_stmt|;
name|qp
operator|->
name|q_msglen
operator|=
name|oldqlen
expr_stmt|;
block|}
name|nameserIncr
argument_list|(
name|nsa
operator|->
name|sin_addr
argument_list|,
name|nssSentSysQ
argument_list|)
expr_stmt|;
name|free_nsp
argument_list|(
name|nsp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|sendto_errno
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|EHOSTDOWN
case|:
case|case
name|EHOSTUNREACH
case|:
name|unsched
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|schedretry
argument_list|(
name|qp
argument_list|,
operator|(
name|time_t
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|qp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check the list of root servers after receiving a response  * to a query for the root servers.  */
end_comment

begin_function
specifier|static
name|int
name|check_root
parameter_list|()
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|priming
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_root: Can't find root!"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
condition|)
name|count
operator|++
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"%d root servers"
argument_list|,
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|server_options
operator|->
name|minroots
condition|)
block|{
name|ns_notice
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_root: %d root servers after query to root server< min"
argument_list|,
name|count
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_NS
operator|&&
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|&&
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"deleting old root server '%s'"
argument_list|,
name|dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* SHOULD DELETE FROM HINTS ALSO */
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
if|if
condition|(
name|check_ns
argument_list|()
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
block|{
name|priming
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*   * Check the root to make sure that for each NS record we have a A RR  */
end_comment

begin_function
specifier|static
name|int
name|check_ns
parameter_list|()
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|,
modifier|*
name|tnp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|;
name|int
name|found_arr
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|time_t
name|curtime
decl_stmt|;
name|int
name|servers
init|=
literal|0
decl_stmt|,
name|rrsets
init|=
literal|0
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"check_ns()"
argument_list|)
expr_stmt|;
name|curtime
operator|=
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
expr_stmt|;
for|for
control|(
name|np
operator|=
name|hashtab
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
block|{
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
continue|continue;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
name|int
name|cnames
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NS
condition|)
continue|continue;
name|servers
operator|++
expr_stmt|;
comment|/* look for A records */
name|dname
operator|=
operator|(
name|caddr_t
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
name|htp
operator|=
name|hashtab
expr_stmt|;
name|tnp
operator|=
name|nlookup
argument_list|(
name|dname
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tnp
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|dname
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"check_ns: %s: not found %s %#lx"
argument_list|,
name|dname
argument_list|,
name|fname
argument_list|,
operator|(
name|u_long
operator|)
name|tnp
argument_list|)
expr_stmt|;
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ns_port
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* look for name server addresses */
name|found_arr
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|delete_stale
argument_list|(
name|tnp
argument_list|)
expr_stmt|;
for|for
control|(
name|tdp
operator|=
name|tnp
operator|->
name|n_data
init|;
name|tdp
operator|!=
name|NULL
condition|;
name|tdp
operator|=
name|tdp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|tdp
operator|->
name|d_rcode
condition|)
continue|continue;
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
name|cnames
operator|++
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|d_type
operator|!=
name|T_A
operator|||
name|tdp
operator|->
name|d_class
operator|!=
name|dp
operator|->
name|d_class
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tdp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|)
operator|&&
operator|(
name|tdp
operator|->
name|d_ttl
operator|<
operator|(
name|u_int32_t
operator|)
name|curtime
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"check_ns: stale entry '%s'"
argument_list|,
name|NAME
argument_list|(
operator|*
name|tnp
argument_list|)
argument_list|)
expr_stmt|;
name|found_arr
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|found_arr
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|found_arr
condition|)
name|rrsets
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|cnames
operator|>
literal|0
condition|)
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"Root NS %s -> CNAME %s"
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
name|NAME
argument_list|(
operator|*
name|tnp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sysquery
argument_list|(
name|dname
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|T_A
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|ns_port
argument_list|,
name|QUERY
argument_list|)
expr_stmt|;
block|}
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"check_ns: %d %d"
argument_list|,
name|servers
argument_list|,
name|rrsets
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|servers
operator|<=
literal|2
operator|)
condition|?
operator|(
name|rrsets
operator|==
name|servers
operator|)
else|:
operator|(
operator|(
name|rrsets
operator|*
literal|2
operator|)
operator|>=
name|servers
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* int findns(npp, class, nsp, countp, flag)  *	Find NS's or an SOA  * npp, class:  *	dname whose most enclosing NS is wanted  * nsp, countp:  *	result array and count; array will also be NULL terminated  * flag:  *	boolean: we're being called from ADDAUTH, bypass authority checks  * return value:  *	NXDOMAIN: we are authoritative for this {dname,class}  *		  *countp is bogus, but nsp[] has a single SOA returned in it.  *	SERVFAIL: we are auth but zone isn't loaded; or, no root servers found  *		  *countp and nsp[] are bogus.  *	OK: we are not authoritative, and here are the NS records we found.  *		  *countp and nsp[] return NS records of interest.  */
end_comment

begin_function
name|int
name|findns
parameter_list|(
name|struct
name|namebuf
modifier|*
modifier|*
name|npp
parameter_list|,
name|int
name|class
parameter_list|,
name|struct
name|databuf
modifier|*
modifier|*
name|nsp
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|struct
name|namebuf
modifier|*
name|np
init|=
operator|*
name|npp
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|nspp
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
decl_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|priming
operator|&&
operator|(
name|np
operator|==
name|NULL
operator|||
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
name|htp
operator|=
name|fcachetab
expr_stmt|;
else|else
name|htp
operator|=
name|hashtab
expr_stmt|;
name|try_again
label|:
if|if
condition|(
name|htp
operator|==
name|fcachetab
operator|&&
name|class
operator|==
name|C_IN
operator|&&
operator|!
name|priming
condition|)
comment|/* 		 * XXX - do we want to set needs_prime_cache if 		 *       OPTION_FORWARD_ONLY? 		 */
name|needs_prime_cache
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
condition|)
block|{
comment|/* find the root */
for|for
control|(
name|np
operator|=
name|htp
operator|->
name|h_tab
index|[
literal|0
index|]
init|;
name|np
operator|!=
name|NULL
condition|;
name|np
operator|=
name|np
operator|->
name|n_next
control|)
if|if
condition|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
block|}
while|while
condition|(
name|np
operator|!=
name|NULL
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|5
argument_list|,
literal|"findns: np %#x '%s'"
argument_list|,
name|np
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look first for SOA records. */
ifdef|#
directive|ifdef
name|ADDAUTH
if|if
condition|(
operator|!
name|flag
condition|)
endif|#
directive|endif
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
name|DB_Z_CACHE
operator|&&
operator|(
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_PRIMARY
operator|)
operator|||
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_type
operator|==
name|Z_SECONDARY
operator|)
operator|)
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_SOA
argument_list|)
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_SOA
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"findns: SOA found"
argument_list|)
expr_stmt|;
if|if
condition|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
condition|)
block|{
operator|*
name|npp
operator|=
name|np
expr_stmt|;
name|nsp
index|[
literal|0
index|]
operator|=
name|dp
expr_stmt|;
name|nsp
index|[
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|DRCNTINC
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return
operator|(
name|NXDOMAIN
operator|)
return|;
block|}
else|else
block|{
comment|/* XXX:	zone isn't loaded but we're 					 *	primary or secondary for it. 					 *	should we fwd this? 					 */
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
block|}
block|}
comment|/* If no SOA records, look for NS records. */
name|nspp
operator|=
operator|&
name|nsp
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|delete_stale
argument_list|(
name|np
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|T_NS
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
comment|/* 			 * Don't use records that may become invalid to 			 * reference later when we do the rtt computation. 			 * Never delete our safety-belt information! 			 * 			 * XXX:	this is horribly bogus. 			 */
if|if
condition|(
operator|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|)
operator|&&
operator|(
name|dp
operator|->
name|d_ttl
operator|<
operator|(
name|u_int32_t
operator|)
name|tt
operator|.
name|tv_sec
operator|)
operator|&&
operator|!
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"findns: stale entry '%s'"
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 				 * We may have already added NS databufs 				 * and are going to throw them away. Fix 				 * reference counts. We don't need to free 				 * them here as we just got them from the 				 * cache. 				 */
while|while
condition|(
name|nspp
operator|>
operator|&
name|nsp
index|[
literal|0
index|]
condition|)
block|{
name|nspp
operator|--
expr_stmt|;
name|DRCNTDEC
argument_list|(
operator|*
name|nspp
argument_list|)
expr_stmt|;
block|}
name|nsp
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
goto|goto
name|try_parent
goto|;
block|}
if|if
condition|(
name|nspp
operator|<
operator|&
name|nsp
index|[
name|NSMAX
operator|-
literal|1
index|]
condition|)
block|{
operator|*
name|nspp
operator|++
operator|=
name|dp
expr_stmt|;
name|DRCNTINC
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|countp
operator|=
name|nspp
operator|-
name|nsp
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|>
literal|0
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"findns: %d NS's added for '%s'"
argument_list|,
operator|*
name|countp
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nspp
operator|=
name|NULL
expr_stmt|;
operator|*
name|npp
operator|=
name|np
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
comment|/* Success, got some NS's */
block|}
name|try_parent
label|:
name|np
operator|=
name|np_parent
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|htp
operator|==
name|hashtab
condition|)
block|{
name|htp
operator|=
name|fcachetab
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"findns: No root nameservers for class %s?"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|unsigned
operator|)
name|class
operator|<
name|MAXCLASS
operator|&&
name|norootlogged
index|[
name|class
index|]
operator|==
literal|0
condition|)
block|{
name|norootlogged
index|[
name|class
index|]
operator|=
literal|1
expr_stmt|;
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"No root nameservers for class %s"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SERVFAIL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Extract RR's from the given node that match class and type.  * Return number of bytes added to response.  * If no matching data is found, then 0 is returned.  */
end_comment

begin_function
name|int
name|finddata
parameter_list|(
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|,
name|HEADER
modifier|*
name|hp
parameter_list|,
name|char
modifier|*
modifier|*
name|dnamep
parameter_list|,
name|int
modifier|*
name|lenp
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|buflen
decl_stmt|,
name|n
decl_stmt|,
name|count
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|new_dnamep
init|=
name|NULL
decl_stmt|;
name|int
name|defer
init|=
literal|0
decl_stmt|,
name|found_count
init|=
literal|0
decl_stmt|,
name|choice
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|found
init|=
name|NULL
decl_stmt|;
name|struct
name|databuf
modifier|*
modifier|*
name|tmpfound
init|=
name|NULL
decl_stmt|;
name|int
name|foundcname
decl_stmt|;
name|int
name|stalecount
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|stalecount
operator|=
name|delete_stale
argument_list|(
name|np
argument_list|)
expr_stmt|;
comment|/* We don't want to return cached SIG records when asked for SIGs, 	 * since we may have an incomplete set. 	 */
if|if
condition|(
name|type
operator|==
name|T_SIG
operator|&&
name|findMyZone
argument_list|(
name|np
argument_list|,
name|class
argument_list|)
operator|==
name|DB_Z_CACHE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|T_ANY
operator|&&
name|type
operator|!=
name|T_PTR
operator|&&
name|type
operator|!=
name|T_NXT
condition|)
block|{
name|found
operator|=
name|memget
argument_list|(
operator|(
name|stalecount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|found
argument_list|)
expr_stmt|;
name|tmpfound
operator|=
name|memget
argument_list|(
operator|(
name|stalecount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|tmpfound
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|==
name|NULL
operator|||
name|tmpfound
operator|==
name|NULL
condition|)
name|ns_panic
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"finddata: out of memory"
argument_list|)
expr_stmt|;
name|defer
operator|=
literal|1
expr_stmt|;
block|}
name|buflen
operator|=
operator|*
name|lenp
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|buflen
operator|>
name|PACKETSZ
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"finddata(): buflen=%d"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cp
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
operator|*
name|countp
expr_stmt|;
name|foundcname
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|wanted
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|T_CNAME
operator|&&
name|class
operator|==
name|dp
operator|->
name|d_class
condition|)
block|{
comment|/* any data means no CNAME exists */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_NXT
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_KEY
operator|&&
name|dp
operator|->
name|d_type
operator|!=
name|T_SIG
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
continue|continue;
block|}
if|if
condition|(
name|dp
operator|->
name|d_cred
operator|==
name|DB_C_ADDITIONAL
condition|)
block|{
ifdef|#
directive|ifdef
name|NOADDITIONAL
continue|continue;
else|#
directive|else
comment|/* we want to expire additional data very 			 * quickly.  current strategy is to cut 5% 			 * off each time it is accessed.  this makes 			 * stale(dp) true earlier when this datum is 			 * used often. 			 */
name|dp
operator|->
name|d_ttl
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|0.95
operator|*
call|(
name|int
call|)
argument_list|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* -ve $ing stuff, anant@isi.edu 		 * if we have a -ve $ed record, change the rcode on the 		 * header to reflect that 		 */
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it does... 				 */
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"NODATA& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|type
operator|==
name|T_ANY
condition|)
continue|continue;
name|hp
operator|->
name|rcode
operator|=
name|NOERROR_NODATA
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|==
literal|0
condition|)
block|{
comment|/* !RETURNSOA */
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|==
name|NXDOMAIN
condition|)
block|{
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
block|{
comment|/* 				 * This should not happen, yet it might... 				 */
name|ns_info
argument_list|(
name|ns_log_default
argument_list|,
literal|"NXDOMAIN& data for \"%s\" type %d class %d"
argument_list|,
operator|*
name|dnamep
argument_list|,
name|type
argument_list|,
name|class
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|hp
operator|->
name|rcode
operator|=
name|NXDOMAIN
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_size
operator|==
literal|0
condition|)
block|{
comment|/* !RETURNSOA */
name|ret
operator|=
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
comment|/* Don't put anything but key or sig RR's in response to 			     requests for key or sig */
if|if
condition|(
operator|(
operator|(
name|type
operator|==
name|T_SIG
operator|)
operator|||
operator|(
name|type
operator|==
name|T_KEY
operator|)
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_SIG
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_type
operator|==
name|T_KEY
operator|)
operator|)
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|!
name|defer
condition|)
block|{
if|if
condition|(
name|foundcname
operator|!=
literal|0
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
continue|continue;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
name|foundcname
operator|=
literal|1
expr_stmt|;
define|#
directive|define
name|FOLLOWCNAME
parameter_list|(
name|type
parameter_list|)
define|\
value|(type != T_KEY)&& (type != T_SIG)&& (type != T_NXT)&& (type != T_ANY)
comment|/* don't alias if querying for key, sig, nxt, or any */
if|if
condition|(
name|FOLLOWCNAME
argument_list|(
name|type
argument_list|)
condition|)
name|new_dnamep
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
name|foundcname
operator|=
literal|1
expr_stmt|;
name|found
index|[
name|found_count
operator|++
index|]
operator|=
name|dp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|found_count
operator|==
literal|0
operator|&&
name|count
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
literal|0
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 	 * If the query type was SIG or ANY we will have returned the SIG 	 * records already. 	 */
if|if
condition|(
name|type
operator|!=
name|T_SIG
operator|&&
name|type
operator|!=
name|T_ANY
condition|)
block|{
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|wantedsig
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_cred
operator|==
name|DB_C_ADDITIONAL
condition|)
block|{
ifdef|#
directive|ifdef
name|NOADDITIONAL
continue|continue;
else|#
directive|else
comment|/* we want to expire additional data very 				 * quickly.  current strategy is to cut 5% 				 * off each time it is accessed.  this makes 				 * stale(dp) true earlier when this datum is 				 * used often. 				 */
name|dp
operator|->
name|d_ttl
operator|=
name|tt
operator|.
name|tv_sec
operator|+
literal|0.95
operator|*
call|(
name|int
call|)
argument_list|(
name|dp
operator|->
name|d_ttl
operator|-
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
operator|!
name|defer
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
else|else
name|found
index|[
name|found_count
operator|++
index|]
operator|=
name|dp
expr_stmt|;
block|}
block|}
if|if
condition|(
name|defer
operator|&&
name|found_count
operator|>
literal|0
condition|)
block|{
name|int
name|first_sig
decl_stmt|;
name|int
name|non_sig_count
decl_stmt|;
name|int
name|sig_count
decl_stmt|;
comment|/* number of SIG records in found */
name|int
name|idx
decl_stmt|,
name|jdx
decl_stmt|;
name|enum
name|ordering
name|order
decl_stmt|;
name|order
operator|=
name|match_order
argument_list|(
name|np
argument_list|,
name|class
argument_list|,
name|foundcname
condition|?
name|T_CNAME
else|:
name|type
argument_list|)
expr_stmt|;
comment|/* shuffle the SIG records down to the bottom of the array 		 * as we need to make sure they get packed last, no matter 		 * what the ordering is. We're sure to maintain the 		 * original ordering within the two sets of records (so 		 * that fixed_order can work). 		 * First we pack the non-SIG records into the temp array. 		 */
for|for
control|(
name|idx
operator|=
name|jdx
operator|=
literal|0
init|;
name|idx
operator|<
name|found_count
condition|;
name|idx
operator|++
control|)
block|{
if|if
condition|(
name|found
index|[
name|idx
index|]
operator|->
name|d_type
operator|!=
name|T_SIG
condition|)
block|{
name|tmpfound
index|[
name|jdx
operator|++
index|]
operator|=
name|found
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
name|non_sig_count
operator|=
name|jdx
expr_stmt|;
name|sig_count
operator|=
name|found_count
operator|-
name|jdx
expr_stmt|;
name|first_sig
operator|=
name|jdx
expr_stmt|;
comment|/* now shift the SIG records down to the end of the array 		 *  and copy in the non-SIG records 		 */
for|for
control|(
name|i
operator|=
name|idx
operator|=
name|found_count
operator|-
literal|1
init|;
name|idx
operator|>=
literal|0
condition|;
name|idx
operator|--
control|)
block|{
if|if
condition|(
name|i
operator|<
name|non_sig_count
condition|)
block|{
name|found
index|[
name|i
index|]
operator|=
name|tmpfound
index|[
name|i
index|]
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|found
index|[
name|idx
index|]
operator|->
name|d_type
operator|==
name|T_SIG
condition|)
block|{
name|found
index|[
name|i
operator|--
index|]
operator|=
name|found
index|[
name|idx
index|]
expr_stmt|;
block|}
block|}
name|foundcname
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|order
condition|)
block|{
case|case
name|fixed_order
case|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|found_count
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|found
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|foundcname
operator|!=
literal|0
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
name|foundcname
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FOLLOWCNAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|new_dnamep
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|random_order
case|:
block|{
comment|/* first we shuffle the non-SIG records */
name|int
name|iters
init|=
name|non_sig_count
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iters
condition|;
name|i
operator|++
control|)
block|{
name|choice
operator|=
operator|(
operator|(
name|u_int
operator|)
name|rand
argument_list|()
operator|>>
literal|3
operator|)
operator|%
name|non_sig_count
expr_stmt|;
name|non_sig_count
operator|--
expr_stmt|;
name|dp
operator|=
name|found
index|[
name|choice
index|]
expr_stmt|;
name|found
index|[
name|choice
index|]
operator|=
name|found
index|[
name|non_sig_count
index|]
expr_stmt|;
if|if
condition|(
name|foundcname
operator|!=
literal|0
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
name|foundcname
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FOLLOWCNAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|new_dnamep
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* now shuffle the SIG records */
name|iters
operator|=
name|sig_count
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iters
condition|;
name|i
operator|++
control|)
block|{
name|choice
operator|=
operator|(
operator|(
name|u_int
operator|)
name|rand
argument_list|()
operator|>>
literal|3
operator|)
operator|%
name|sig_count
expr_stmt|;
name|choice
operator|+=
name|first_sig
expr_stmt|;
name|sig_count
operator|--
expr_stmt|;
name|dp
operator|=
name|found
index|[
name|choice
index|]
expr_stmt|;
name|found
index|[
name|choice
index|]
operator|=
name|found
index|[
name|sig_count
operator|+
name|first_sig
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
break|break;
block|}
case|case
name|cyclic_order
case|:
comment|/* first we do the non-SIG records */
if|if
condition|(
name|non_sig_count
operator|>
literal|0
condition|)
name|choice
operator|=
operator|(
operator|(
name|u_int
operator|)
name|rand
argument_list|()
operator|>>
literal|3
operator|)
operator|%
name|non_sig_count
expr_stmt|;
else|else
name|choice
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|non_sig_count
condition|;
name|i
operator|++
control|)
block|{
name|dp
operator|=
name|found
index|[
operator|(
name|i
operator|+
name|choice
operator|)
operator|%
name|non_sig_count
index|]
expr_stmt|;
if|if
condition|(
name|foundcname
operator|!=
literal|0
operator|&&
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|T_CNAME
condition|)
block|{
name|foundcname
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|FOLLOWCNAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|new_dnamep
operator|=
operator|(
name|char
operator|*
operator|)
name|dp
operator|->
name|d_data
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* now do the SIG record rotation. */
if|if
condition|(
name|sig_count
operator|>
literal|0
condition|)
block|{
name|choice
operator|=
operator|(
operator|(
name|u_int
operator|)
name|rand
argument_list|()
operator|>>
literal|3
operator|)
operator|%
name|sig_count
expr_stmt|;
name|choice
operator|+=
name|first_sig
expr_stmt|;
name|i
operator|=
name|choice
expr_stmt|;
do|do
block|{
name|dp
operator|=
name|found
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
operator|*
name|dnamep
argument_list|,
name|dp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
name|dp
operator|->
name|d_secure
operator|!=
name|DB_S_SECURE
condition|)
name|hp
operator|->
name|ad
operator|=
literal|0
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|count
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|found_count
condition|)
name|i
operator|=
name|first_sig
expr_stmt|;
block|}
do|while
condition|(
name|i
operator|!=
name|choice
condition|)
do|;
block|}
break|break;
default|default:
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"finddata: unknown ordering: %d"
argument_list|,
name|order
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_dnamep
operator|!=
name|NULL
condition|)
operator|*
name|dnamep
operator|=
name|new_dnamep
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"finddata: added %d class %d type %d RRs"
argument_list|,
name|count
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|*
name|lenp
operator|-
name|buflen
expr_stmt|;
name|done
label|:
if|if
condition|(
name|found
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|found
argument_list|,
operator|(
name|stalecount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|found
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfound
operator|!=
name|NULL
condition|)
name|memput
argument_list|(
name|tmpfound
argument_list|,
operator|(
name|stalecount
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
expr|*
name|tmpfound
argument_list|)
expr_stmt|;
operator|*
name|countp
operator|=
name|count
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Do we want this data record based on the class and type?  */
end_comment

begin_function
specifier|static
name|int
name|wanted
parameter_list|(
specifier|const
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|coveredType
decl_stmt|;
name|time_t
name|expiration
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
name|pclass
index|[
literal|15
index|]
decl_stmt|,
name|ptype
index|[
literal|15
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|strcpy
argument_list|(
name|pclass
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptype
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"wanted(%#x, %s %s) [%s %s]"
argument_list|,
name|dp
argument_list|,
name|pclass
argument_list|,
name|ptype
argument_list|,
name|p_class
argument_list|(
name|dp
operator|->
name|d_class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Must check SIG for expiration below, other matches 	 * return OK here. 	 */
if|if
condition|(
name|type
operator|==
name|dp
operator|->
name|d_type
operator|&&
operator|(
name|type
operator|!=
name|T_SIG
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* For a T_ANY query, we do not want to return -ve $ed RRs. */
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|&&
name|dp
operator|->
name|d_rcode
operator|==
name|NOERROR_NODATA
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* First, look at the type of RR.  */
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
comment|/* Cases to deal with: 			T_ANY search, return all unexpired SIGs. 			T_SIG search, return all unexpired SIGs. 			T_<foo> search, return all unexp SIG<FOO>s. 		 */
case|case
name|T_SIG
case|:
name|cp
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|GETSHORT
argument_list|(
name|coveredType
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/* skip alg, labels,& orig TTL */
name|GETLONG
argument_list|(
name|expiration
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|||
name|type
operator|==
name|T_SIG
condition|)
block|{
if|if
condition|(
name|expiration
operator|>
name|time
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* Unexpired matching SIG */
block|}
return|return
operator|(
literal|0
operator|)
return|;
comment|/* We don't return this SIG. */
case|case
name|T_ANY
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|T_CNAME
case|:
if|if
condition|(
name|dp
operator|->
name|d_rcode
operator|!=
name|NOERROR_NODATA
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
break|break;
block|}
comment|/* OK, now look at the type of query.  */
if|if
condition|(
name|type
operator|==
name|ns_t_any
condition|)
return|return
operator|(
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|type
operator|==
name|ns_t_mailb
condition|)
switch|switch
condition|(
name|dp
operator|->
name|d_type
condition|)
block|{
case|case
name|T_MR
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ns_t_xfr_p
argument_list|(
name|type
argument_list|)
condition|)
block|{
comment|/* 		 * This is used to validate transfer requests, not 		 * generate transfer responses.  Is there an SOA? 		 */
if|if
condition|(
name|dp
operator|->
name|d_type
operator|==
name|ns_t_soa
operator|&&
name|dp
operator|->
name|d_zone
operator|!=
name|DB_Z_CACHE
operator|&&
operator|(
name|zones
index|[
name|dp
operator|->
name|d_zone
index|]
operator|.
name|z_flags
operator|&
name|Z_AUTH
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|wantedsig
parameter_list|(
specifier|const
name|struct
name|databuf
modifier|*
name|dp
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|)
block|{
specifier|const
name|u_char
modifier|*
name|cp
decl_stmt|;
name|int
name|coveredType
decl_stmt|;
name|time_t
name|expiration
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|char
name|pclass
index|[
literal|15
index|]
decl_stmt|,
name|ptype
index|[
literal|15
index|]
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|strcpy
argument_list|(
name|pclass
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ptype
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"wantedtsig(%#x, %s %s) [%s %s]"
argument_list|,
name|dp
argument_list|,
name|pclass
argument_list|,
name|ptype
argument_list|,
name|p_class
argument_list|(
name|dp
operator|->
name|d_class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|dp
operator|->
name|d_type
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|dp
operator|->
name|d_class
operator|!=
name|class
operator|&&
name|class
operator|!=
name|C_ANY
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|dp
operator|->
name|d_type
operator|!=
name|T_SIG
operator|||
name|dp
operator|->
name|d_rcode
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|cp
operator|=
name|dp
operator|->
name|d_data
expr_stmt|;
name|GETSHORT
argument_list|(
name|coveredType
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
comment|/* skip alg, labels,& orig TTL */
name|GETLONG
argument_list|(
name|expiration
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|expiration
operator|<
name|time
argument_list|(
literal|0
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|T_ANY
operator|||
name|type
operator|==
name|T_SIG
operator|||
name|type
operator|==
name|coveredType
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|type
operator|==
name|ns_t_mailb
condition|)
block|{
switch|switch
condition|(
name|coveredType
condition|)
block|{
case|case
name|T_MR
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MINFO
case|:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  Add RR entries from dpp array to a query/response.  *  Return the number of bytes added or negative the amount  *  added if truncation occured.  Typically you are  *  adding NS records to a response.  */
end_comment

begin_function
name|int
name|add_data
parameter_list|(
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|struct
name|databuf
modifier|*
modifier|*
name|dpp
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|int
name|buflen
parameter_list|,
name|int
modifier|*
name|countp
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|char
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|bytes
decl_stmt|;
name|bytes
operator|=
operator|*
name|countp
operator|=
literal|0
expr_stmt|;
name|getname
argument_list|(
name|np
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
operator|*
name|dpp
operator|++
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
operator|*
name|dpp
operator|++
control|)
block|{
if|if
condition|(
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
continue|continue;
comment|/* ignore old cache entry */
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
continue|continue;
if|if
condition|(
operator|(
name|n
operator|=
name|make_rr
argument_list|(
name|dname
argument_list|,
name|dp
argument_list|,
name|cp
argument_list|,
name|buflen
argument_list|,
literal|1
argument_list|,
name|dnptrs
argument_list|,
name|dnptrs_end
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
name|bytes
operator|)
return|;
comment|/* Truncation */
name|cp
operator|+=
name|n
expr_stmt|;
name|buflen
operator|-=
name|n
expr_stmt|;
name|bytes
operator|+=
name|n
expr_stmt|;
operator|(
operator|*
name|countp
operator|)
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|bytes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|rrsetadd
parameter_list|(
name|struct
name|flush_set
modifier|*
name|flushset
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|databuf
modifier|*
name|dp
parameter_list|)
block|{
name|struct
name|flush_set
modifier|*
name|fs
init|=
name|flushset
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbl
decl_stmt|;
while|while
condition|(
name|fs
operator|->
name|fs_name
operator|&&
operator|(
name|ns_samename
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|name
argument_list|)
operator|!=
literal|1
operator|||
operator|(
name|fs
operator|->
name|fs_class
operator|!=
name|dp
operator|->
name|d_class
operator|)
operator|||
operator|(
name|fs
operator|->
name|fs_type
operator|!=
name|dp
operator|->
name|d_type
operator|)
operator|||
operator|(
name|fs
operator|->
name|fs_cred
operator|!=
name|dp
operator|->
name|d_cred
operator|)
operator|)
condition|)
block|{
name|fs
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|fs
operator|->
name|fs_name
condition|)
block|{
name|fs
operator|->
name|fs_name
operator|=
name|savestr
argument_list|(
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fs
operator|->
name|fs_class
operator|=
name|dp
operator|->
name|d_class
expr_stmt|;
name|fs
operator|->
name|fs_type
operator|=
name|dp
operator|->
name|d_type
expr_stmt|;
name|fs
operator|->
name|fs_cred
operator|=
name|dp
operator|->
name|d_cred
expr_stmt|;
name|fs
operator|->
name|fs_list
operator|=
name|NULL
expr_stmt|;
name|fs
operator|->
name|fs_last
operator|=
name|NULL
expr_stmt|;
block|}
name|dbl
operator|=
operator|(
expr|struct
name|db_list
operator|*
operator|)
name|memget
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|db_list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbl
condition|)
name|panic
argument_list|(
literal|"rrsetadd: out of memory"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dbl
operator|->
name|db_next
operator|=
name|NULL
expr_stmt|;
name|dbl
operator|->
name|db_dp
operator|=
name|dp
expr_stmt|;
if|if
condition|(
name|fs
operator|->
name|fs_last
operator|==
name|NULL
condition|)
name|fs
operator|->
name|fs_list
operator|=
name|dbl
expr_stmt|;
else|else
name|fs
operator|->
name|fs_last
operator|->
name|db_next
operator|=
name|dbl
expr_stmt|;
name|fs
operator|->
name|fs_last
operator|=
name|dbl
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|ttlcheck
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|db_list
modifier|*
name|dbl
parameter_list|,
name|int
name|update
parameter_list|)
block|{
name|int
name|type
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_type
decl_stmt|;
name|int
name|class
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_class
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|hashtab
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbp
init|=
name|dbl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|u_int32_t
name|ttl
init|=
literal|0
decl_stmt|;
comment|/* Make gcc happy. */
name|int
name|first
decl_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|name
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|name
operator|||
name|ns_wildcard
argument_list|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* check that all the ttl's we have are the same, if not return 1 */
name|first
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|first
condition|)
block|{
comment|/* we can't update zone data so return early */
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|!=
name|DB_Z_CACHE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ttl
operator|=
name|dp
operator|->
name|d_ttl
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ttl
operator|!=
name|dp
operator|->
name|d_ttl
condition|)
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* there are no records of this type in the cache */
if|if
condition|(
name|first
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * the ttls of all records we have in the cache are the same 	 * if the ttls differ in the new set we don't want it. 	 */
comment|/* check that all the ttl's we have are the same, if not return 0 */
name|first
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
if|if
condition|(
name|first
condition|)
block|{
name|ttl
operator|=
name|dbp
operator|->
name|db_dp
operator|->
name|d_ttl
expr_stmt|;
name|first
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ttl
operator|!=
name|dbp
operator|->
name|db_dp
operator|->
name|d_ttl
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
block|}
comment|/* update ttl if required */
if|if
condition|(
name|update
condition|)
block|{
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|dp
operator|->
name|d_ttl
operator|>
name|ttl
condition|)
break|break;
name|dp
operator|->
name|d_ttl
operator|=
name|ttl
expr_stmt|;
name|fixttl
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * lookup rrset in table and compare to dbl  * tri state result  * -1: lookup failed  * 0: rrsets same  * 1: rrsets differ  */
end_comment

begin_function
specifier|static
name|int
name|rrsetcmp
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|struct
name|db_list
modifier|*
name|dbl
parameter_list|,
name|struct
name|hashbuf
modifier|*
name|table
parameter_list|)
block|{
name|int
name|type
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_type
decl_stmt|;
name|int
name|class
init|=
name|dbl
operator|->
name|db_dp
operator|->
name|d_class
decl_stmt|;
name|struct
name|hashbuf
modifier|*
name|htp
init|=
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbp
init|=
name|dbl
decl_stmt|;
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|exists
init|=
literal|0
decl_stmt|;
name|np
operator|=
name|nlookup
argument_list|(
name|name
argument_list|,
operator|&
name|htp
argument_list|,
operator|&
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|==
name|NULL
operator|||
name|fname
operator|!=
name|name
operator|||
name|ns_wildcard
argument_list|(
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|)
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"rrsetcmp: name not in database"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* check that all entries in dbl are in the cache */
while|while
condition|(
name|dbp
condition|)
block|{
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
name|exists
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|dbp
operator|->
name|db_dp
argument_list|)
ifdef|#
directive|ifdef
name|NOADDITIONAL
operator|&&
operator|(
operator|(
name|dp
operator|->
name|d_cred
operator|==
name|dbp
operator|->
name|db_dp
operator|->
name|d_cred
operator|)
operator|||
operator|(
name|dp
operator|->
name|d_cred
operator|!=
name|DB_C_ADDITIONAL
operator|)
operator|)
endif|#
directive|endif
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"rrsetcmp: %srecord%s in database"
argument_list|,
name|exists
condition|?
literal|""
else|:
literal|"no "
argument_list|,
name|exists
condition|?
literal|" not"
else|:
literal|"s"
argument_list|)
expr_stmt|;
return|return
operator|(
name|exists
condition|?
literal|1
else|:
operator|-
literal|1
operator|)
return|;
block|}
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
block|}
comment|/* Check that all cache entries are in the list. */
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
operator|!
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
continue|continue;
ifdef|#
directive|ifdef
name|NCACHE
if|if
condition|(
name|dp
operator|->
name|d_rcode
condition|)
return|return
operator|(
literal|1
operator|)
return|;
endif|#
directive|endif
name|dbp
operator|=
name|dbl
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
if|if
condition|(
operator|!
name|db_cmp
argument_list|(
name|dp
argument_list|,
name|dbp
operator|->
name|db_dp
argument_list|)
condition|)
break|break;
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dbp
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"rrsetcmp: record not in rrset"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"rrsetcmp: rrsets matched"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * verify incoming answer against what we already have in the hints  * issue warnings / errors if differences detected.  */
end_comment

begin_function
specifier|static
name|void
name|check_hints
parameter_list|(
name|struct
name|flush_set
modifier|*
name|flushset
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|flush_set
modifier|*
name|fs
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbp
decl_stmt|;
comment|/* We don't use hints when in forward only mode */
if|if
condition|(
name|NS_OPTION_P
argument_list|(
name|OPTION_FORWARD_ONLY
argument_list|)
condition|)
return|return;
comment|/* find "." NS rrset and hence class */
for|for
control|(
name|fs
operator|=
name|flushset
init|;
name|fs
operator|->
name|fs_name
operator|!=
name|NULL
condition|;
name|fs
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|||
operator|(
name|fs
operator|->
name|fs_type
operator|!=
name|ns_t_ns
operator|)
condition|)
continue|continue;
comment|/* see if we are a root server */
name|zp
operator|=
name|find_zone
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|!=
name|NULL
operator|&&
operator|(
name|zp
operator|->
name|z_type
operator|==
name|z_master
operator|||
name|zp
operator|->
name|z_type
operator|==
name|z_slave
operator|)
condition|)
return|return;
switch|switch
condition|(
name|rrsetcmp
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|,
name|fcachetab
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_hints: no NS records for class %d in hints"
argument_list|,
name|fs
operator|->
name|fs_class
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_hints: root NS list in hints for class %d does not match root NS list"
argument_list|,
name|fs
operator|->
name|fs_class
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_hints: unexpected response from rrsetcmp"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_name
operator|==
name|NULL
condition|)
comment|/* no root NS records */
return|return;
name|dbp
operator|=
name|fs
operator|->
name|fs_list
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
comment|/* for each NS find A rrset in answer and check */
for|for
control|(
name|fs
operator|=
name|flushset
init|;
name|fs
operator|->
name|fs_name
operator|!=
name|NULL
condition|;
name|fs
operator|++
control|)
block|{
if|if
condition|(
name|ns_samename
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|dbp
operator|->
name|db_dp
operator|->
name|d_data
argument_list|)
operator|!=
literal|1
operator|||
name|fs
operator|->
name|fs_type
operator|!=
name|ns_t_a
condition|)
continue|continue;
switch|switch
condition|(
name|rrsetcmp
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|,
name|fcachetab
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_hints: no A records for %s class %d in hints"
argument_list|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
argument_list|,
name|fs
operator|->
name|fs_class
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|ns_warning
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_hints: A records for %s class %d do not match hint records"
argument_list|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
argument_list|,
name|fs
operator|->
name|fs_class
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
break|break;
default|default:
name|ns_error
argument_list|(
name|ns_log_default
argument_list|,
literal|"check_hints: unexpected response from rrsetcmp"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
if|if
condition|(
name|fs
operator|->
name|fs_name
operator|==
name|NULL
condition|)
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"check_hints: no A records for %s"
argument_list|,
name|dbp
operator|->
name|db_dp
operator|->
name|d_data
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|rrsetupdate
parameter_list|(
name|struct
name|flush_set
modifier|*
name|flushset
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|,
name|int
name|updatettl
parameter_list|)
block|{
name|struct
name|flush_set
modifier|*
name|fs
init|=
name|flushset
decl_stmt|;
name|struct
name|db_list
modifier|*
name|dbp
decl_stmt|,
modifier|*
name|odbp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|void
modifier|*
name|state
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|fs
operator|->
name|fs_name
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"rrsetupdate: %s"
argument_list|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|rrsetcmp
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|,
name|hashtab
argument_list|)
operator|)
operator|&&
name|ttlcheck
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|,
literal|0
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|flushrrset
argument_list|(
name|fs
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|fs
operator|->
name|fs_list
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
name|n
operator|=
name|db_set_update
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|dbp
operator|->
name|db_dp
argument_list|,
operator|&
name|state
argument_list|,
name|flags
argument_list|,
operator|&
name|hashtab
argument_list|,
name|from
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"rrsetupdate: %s %d"
argument_list|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|odbp
operator|=
name|dbp
expr_stmt|;
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
name|memput
argument_list|(
name|odbp
argument_list|,
sizeof|sizeof
expr|*
name|odbp
argument_list|)
expr_stmt|;
block|}
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"rrsetupdate: %s %d"
argument_list|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|n
operator|==
literal|0
operator|)
operator|&&
name|updatettl
condition|)
operator|(
name|void
operator|)
name|ttlcheck
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|fs
operator|->
name|fs_list
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dbp
operator|=
name|fs
operator|->
name|fs_list
expr_stmt|;
while|while
condition|(
name|dbp
condition|)
block|{
name|db_freedata
argument_list|(
name|dbp
operator|->
name|db_dp
argument_list|)
expr_stmt|;
name|odbp
operator|=
name|dbp
expr_stmt|;
name|dbp
operator|=
name|dbp
operator|->
name|db_next
expr_stmt|;
name|memput
argument_list|(
name|odbp
argument_list|,
sizeof|sizeof
expr|*
name|odbp
argument_list|)
expr_stmt|;
block|}
block|}
name|fs
operator|->
name|fs_list
operator|=
name|NULL
expr_stmt|;
name|fs
operator|++
expr_stmt|;
block|}
name|n
operator|=
name|db_set_update
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|state
argument_list|,
name|flags
argument_list|,
operator|&
name|hashtab
argument_list|,
name|from
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|flushrrset
parameter_list|(
name|struct
name|flush_set
modifier|*
name|fs
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|n
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|2
argument_list|,
literal|"flushrrset(%s, %s, %s, %d)"
argument_list|,
name|fs
operator|->
name|fs_name
index|[
literal|0
index|]
condition|?
name|fs
operator|->
name|fs_name
else|:
literal|"."
argument_list|,
name|p_type
argument_list|(
name|fs
operator|->
name|fs_type
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|fs
operator|->
name|fs_class
argument_list|)
argument_list|,
name|fs
operator|->
name|fs_cred
argument_list|)
expr_stmt|;
name|dp
operator|=
name|savedata
argument_list|(
name|fs
operator|->
name|fs_class
argument_list|,
name|fs
operator|->
name|fs_type
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|->
name|d_zone
operator|=
name|DB_Z_CACHE
expr_stmt|;
name|dp
operator|->
name|d_cred
operator|=
name|fs
operator|->
name|fs_cred
expr_stmt|;
name|dp
operator|->
name|d_clev
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|n
operator|=
name|db_update
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|,
name|dp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|DB_DELETE
argument_list|,
name|hashtab
argument_list|,
name|from
argument_list|)
expr_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"flushrrset: %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
operator|==
name|OK
condition|)
do|;
name|db_freedata
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_flushset
parameter_list|(
name|struct
name|flush_set
modifier|*
name|flushset
parameter_list|,
name|int
name|flushset_size
parameter_list|)
block|{
name|struct
name|flush_set
modifier|*
name|fs
decl_stmt|;
for|for
control|(
name|fs
operator|=
name|flushset
init|;
name|fs
operator|->
name|fs_name
operator|!=
name|NULL
condition|;
name|fs
operator|++
control|)
name|freestr
argument_list|(
name|fs
operator|->
name|fs_name
argument_list|)
expr_stmt|;
name|memput
argument_list|(
name|flushset
argument_list|,
name|flushset_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  *  This is best thought of as a "cache invalidate" function.  *  It is called whenever a piece of data is determined to have  *  become invalid either through a timeout or a validation  *  failure.  It is better to have no information, than to  *  have partial information you pass off as complete.  */
end_comment

begin_function
name|void
name|delete_all
parameter_list|(
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|,
modifier|*
name|pdp
decl_stmt|;
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|3
argument_list|,
literal|"delete_all(%#x:\"%s\" %s %s)"
argument_list|,
name|np
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|pdp
operator|=
name|NULL
expr_stmt|;
name|dp
operator|=
name|np
operator|->
name|n_data
expr_stmt|;
while|while
condition|(
name|dp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|&&
operator|(
name|dp
operator|->
name|d_flags
operator|&
name|DB_F_HINT
operator|)
operator|==
literal|0
operator|&&
name|match
argument_list|(
name|dp
argument_list|,
name|class
argument_list|,
name|type
argument_list|)
condition|)
block|{
name|dp
operator|=
name|rm_datum
argument_list|(
name|dp
argument_list|,
name|np
argument_list|,
name|pdp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|pdp
operator|=
name|dp
expr_stmt|;
name|dp
operator|=
name|dp
operator|->
name|d_next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* delete_stale(np)  *	for all RRs associated with this name, check for staleness (& delete)  * arguments:  *	np = pointer to namebuf to be cleaned.  * returns:  *	number of RRs associated with this name.  * side effects:  *	delete_all() can be called, freeing memory and relinking chains.  */
end_comment

begin_function
name|int
name|delete_stale
parameter_list|(
name|np
parameter_list|)
name|struct
name|namebuf
modifier|*
name|np
decl_stmt|;
block|{
name|struct
name|databuf
modifier|*
name|dp
decl_stmt|;
name|int
name|count
decl_stmt|;
name|again
label|:
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|np
operator|->
name|n_data
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|dp
operator|->
name|d_next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|d_zone
operator|==
name|DB_Z_CACHE
operator|&&
name|stale
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|delete_all
argument_list|(
name|np
argument_list|,
name|dp
operator|->
name|d_class
argument_list|,
name|dp
operator|->
name|d_type
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|count
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Adjust answer message so that it fits in outlen. Set tc if required.  *  * If outlen = msglen, can be used to verify qdcount, ancount, nscount  * and arcount.  *  * return new length  */
end_comment

begin_function
name|int
name|trunc_adjust
parameter_list|(
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|int
name|outlen
parameter_list|)
block|{
specifier|register
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|dlen
decl_stmt|;
name|u_char
modifier|*
name|cp
init|=
name|msg
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|eom_in
decl_stmt|,
modifier|*
name|eom_out
decl_stmt|;
name|int
name|n
decl_stmt|;
name|eom_in
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
name|eom_out
operator|=
name|msg
operator|+
name|outlen
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|HFIXEDSZ
expr_stmt|;
while|while
condition|(
operator|(
name|qdcount
operator|||
name|ancount
operator|||
name|nscount
operator|||
name|arcount
operator|)
operator|&&
name|cp
operator|<
name|eom_in
operator|&&
name|cp
operator|<
name|eom_out
condition|)
block|{
name|cp1
operator|=
name|cp
expr_stmt|;
comment|/* use temporary in case we break */
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp1
argument_list|,
name|eom_in
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|cp1
operator|+=
name|n
operator|+
literal|2
operator|*
name|INT16SZ
expr_stmt|;
comment|/* type, class */
if|if
condition|(
operator|!
name|qdcount
condition|)
block|{
name|cp1
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
if|if
condition|(
name|cp1
operator|+
name|INT16SZ
operator|>
name|eom_in
condition|)
break|break;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
name|cp1
operator|+=
name|dlen
expr_stmt|;
block|}
if|if
condition|(
name|cp1
operator|>
name|eom_in
operator|||
name|cp1
operator|>
name|eom_out
condition|)
break|break;
name|cp
operator|=
name|cp1
expr_stmt|;
if|if
condition|(
name|qdcount
condition|)
name|qdcount
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|ancount
condition|)
name|ancount
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|nscount
condition|)
name|nscount
operator|--
expr_stmt|;
else|else
name|arcount
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|qdcount
operator|||
name|ancount
operator|||
name|nscount
operator|||
name|arcount
condition|)
block|{
name|ns_debug
argument_list|(
name|ns_log_default
argument_list|,
literal|1
argument_list|,
literal|"trunc_adjust:%s %d %d %d %d %d, %d %d %d %d %d"
argument_list|,
name|hp
operator|->
name|tc
condition|?
literal|" tc"
else|:
literal|""
argument_list|,
name|msglen
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
argument_list|,
name|cp
operator|-
name|msg
argument_list|,
name|qdcount
argument_list|,
name|ancount
argument_list|,
name|nscount
argument_list|,
name|arcount
argument_list|)
expr_stmt|;
name|hp
operator|->
name|tc
operator|=
literal|1
expr_stmt|;
name|hp
operator|->
name|qdcount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|-
name|qdcount
argument_list|)
expr_stmt|;
name|hp
operator|->
name|ancount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
operator|-
name|ancount
argument_list|)
expr_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
operator|-
name|nscount
argument_list|)
expr_stmt|;
name|hp
operator|->
name|arcount
operator|=
name|htons
argument_list|(
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
operator|-
name|arcount
argument_list|)
expr_stmt|;
block|}
name|ENSURE
argument_list|(
name|cp
operator|<=
name|eom_out
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|-
name|msg
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mark the server "from" bad in the qp structure so it won't be retried.  */
end_comment

begin_function
specifier|static
name|void
name|mark_bad
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|nretry
operator|=
name|MAXRETRY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|mark_lame
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
name|qp
operator|->
name|q_naddr
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ina_equal
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
operator|&&
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|!=
name|NULL
condition|)
block|{
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_flags
operator||=
name|DB_F_LAME
expr_stmt|;
name|db_lame_add
argument_list|(
name|qp
operator|->
name|q_domain
argument_list|,
operator|(
name|char
operator|*
operator|)
name|qp
operator|->
name|q_addr
index|[
name|i
index|]
operator|.
name|ns
operator|->
name|d_data
argument_list|,
name|tt
operator|.
name|tv_sec
operator|+
name|server_options
operator|->
name|lame_ttl
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Retry the message if and only if from matches where the query was  * last sent to.  The code does not handle responses sent from the  * wrong interface an a multihomed server.  */
end_comment

begin_function
specifier|static
name|void
name|fast_retry
parameter_list|(
name|struct
name|qinfo
modifier|*
name|qp
parameter_list|,
name|struct
name|sockaddr_in
name|from
parameter_list|)
block|{
if|if
condition|(
name|ina_equal
argument_list|(
name|qp
operator|->
name|q_addr
index|[
name|qp
operator|->
name|q_curaddr
index|]
operator|.
name|ns_addr
operator|.
name|sin_addr
argument_list|,
name|from
operator|.
name|sin_addr
argument_list|)
condition|)
name|retry
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|add_related_additional
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|num_related
operator|>=
name|MAX_RELATED
operator|-
literal|1
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_related
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ns_samename
argument_list|(
name|name
argument_list|,
name|related
index|[
name|i
index|]
argument_list|)
operator|==
literal|1
condition|)
block|{
name|freestr
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
name|related
index|[
name|num_related
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|free_related_additional
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_related
condition|;
name|i
operator|++
control|)
name|freestr
argument_list|(
name|related
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|num_related
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|related_additional
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_related
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ns_samename
argument_list|(
name|name
argument_list|,
name|related
index|[
name|i
index|]
argument_list|)
operator|==
literal|1
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freestr_maybe
parameter_list|(
name|char
modifier|*
modifier|*
name|tname
parameter_list|)
block|{
if|if
condition|(
name|tname
operator|==
name|NULL
operator|||
operator|*
name|tname
operator|==
name|NULL
condition|)
return|return;
name|freestr
argument_list|(
operator|*
name|tname
argument_list|)
expr_stmt|;
operator|*
name|tname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Match a request namebuf against the configured rrset-order info.  First  * match wins.  There is an implicit '*.' at the front to the ordering names.  */
end_comment

begin_function
specifier|static
name|enum
name|ordering
name|match_order
parameter_list|(
specifier|const
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
name|int
name|class
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|rrset_order_list
name|orders
init|=
name|server_options
operator|->
name|ordering
decl_stmt|;
name|rrset_order_element
name|roe
decl_stmt|;
if|if
condition|(
name|orders
operator|==
name|NULL
condition|)
return|return
operator|(
name|DEFAULT_ORDERING
operator|)
return|;
for|for
control|(
name|roe
operator|=
name|orders
operator|->
name|first
init|;
name|roe
operator|!=
name|NULL
condition|;
name|roe
operator|=
name|roe
operator|->
name|next
control|)
block|{
if|if
condition|(
name|roe
operator|->
name|class
operator|!=
name|C_ANY
operator|&&
name|roe
operator|->
name|class
operator|!=
name|class
condition|)
continue|continue;
if|if
condition|(
name|roe
operator|->
name|type
operator|!=
name|T_ANY
operator|&&
name|roe
operator|->
name|type
operator|!=
name|type
condition|)
continue|continue;
if|if
condition|(
name|match_name
argument_list|(
name|np
argument_list|,
name|roe
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|roe
operator|->
name|name
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|roe
operator|->
name|order
operator|)
return|;
block|}
block|}
comment|/* none matched so use default */
return|return
operator|(
name|DEFAULT_ORDERING
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Do a simple compare of the NP data against the given NAME, recursively  * looking at the NP parent if necessary. NAMELEN is the length of the NAME  * that needs to be matched. Matching happen from right to left. Returns -1  * on failure, on success the index of the first character of the matched  * portion of the string is returned. In the first level call a return  * value of 0 is of interest.  */
end_comment

begin_function
specifier|static
name|int
name|match_name
parameter_list|(
specifier|const
name|struct
name|namebuf
modifier|*
name|np
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|size_t
name|namelen
parameter_list|)
block|{
name|int
name|matched
decl_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|np
operator|->
name|n_parent
operator|!=
name|NULL
condition|)
block|{
comment|/* recurse to end of np list */
name|matched
operator|=
name|match_name
argument_list|(
name|np
operator|->
name|n_parent
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|matched
operator|=
name|namelen
expr_stmt|;
block|}
if|if
condition|(
name|matched
operator|>
literal|0
condition|)
block|{
name|int
name|labellen
init|=
name|NAMELEN
argument_list|(
operator|*
name|np
argument_list|)
decl_stmt|;
name|char
name|pch
decl_stmt|;
specifier|const
name|char
modifier|*
name|start
decl_stmt|;
if|if
condition|(
name|labellen
operator|>
name|matched
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|labellen
operator|<
name|matched
condition|)
block|{
comment|/* string is longer than this namebuf's data, so 			   make sure there's a period before the end of the  			   match so we don't just match a suffix. */
name|start
operator|=
name|name
operator|+
operator|(
name|matched
operator|-
name|labellen
operator|)
expr_stmt|;
name|pch
operator|=
name|start
index|[
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|pch
operator|!=
literal|'.'
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
block|}
else|else
block|{
name|start
operator|=
name|name
expr_stmt|;
block|}
if|if
condition|(
name|strncasecmp
argument_list|(
name|start
argument_list|,
name|NAME
argument_list|(
operator|*
name|np
argument_list|)
argument_list|,
name|labellen
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* looking good. tell our caller what portion of 			   the tail of string has been matched */
if|if
condition|(
name|start
operator|==
name|name
condition|)
return|return
operator|(
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|start
operator|-
name|name
operator|-
literal|1
operator|)
return|;
comment|/* matched '.' too */
block|}
else|else
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
name|matched
operator|)
return|;
block|}
end_function

end_unit

