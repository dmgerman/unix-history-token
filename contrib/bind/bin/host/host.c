begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: host.c,v 8.37 2000/07/11 07:06:14 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Copyright (c) 1986  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-1999 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1986 Regents of the University of California.\n\  Portions Copyright (c) 1993 Digital Equipment Corporation.\n\  Portions Copyright (c) 1996-1999 Internet Software Consortium.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  * Actually, this program is from Rutgers University, however it is   * based on nslookup and other pieces of named tools, so it needs  * the above copyright notices.  */
end_comment

begin_comment
comment|/* Import. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<memory.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_comment
comment|/* Global. */
end_comment

begin_define
define|#
directive|define
name|SIG_RDATA_BY_NAME
value|18
end_define

begin_define
define|#
directive|define
name|NS_HEADERDATA_SIZE
value|10
end_define

begin_define
define|#
directive|define
name|NUMNS
value|8
end_define

begin_define
define|#
directive|define
name|NUMNSADDR
value|16
end_define

begin_define
define|#
directive|define
name|NUMMX
value|50
end_define

begin_define
define|#
directive|define
name|NUMRR
value|127
end_define

begin_comment
comment|/* max rr's per node to verify signatures for */
end_comment

begin_define
define|#
directive|define
name|SUCCESS
value|0
end_define

begin_define
define|#
directive|define
name|TIME_OUT
value|-1
end_define

begin_define
define|#
directive|define
name|NO_INFO
value|-2
end_define

begin_define
define|#
directive|define
name|ERROR
value|-3
end_define

begin_define
define|#
directive|define
name|NONAUTH
value|-4
end_define

begin_define
define|#
directive|define
name|MY_PACKETSZ
value|64*1024
end_define

begin_comment
comment|/* need this to hold tcp answers */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|qb1
decl_stmt|;
name|u_char
name|qb2
index|[
name|MY_PACKETSZ
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_define
define|#
directive|define
name|SD_RR
value|1
end_define

begin_define
define|#
directive|define
name|SD_SIG
value|2
end_define

begin_define
define|#
directive|define
name|SD_BADSIG
value|4
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|u_char
name|data
index|[
name|MY_PACKETSZ
index|]
decl_stmt|;
name|size_t
name|len
decl_stmt|;
block|}
name|rrstruct
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|chase_domain
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chase_class
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chase_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|chase_sigorigttl
index|[
name|NS_INT32SZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|rrstruct
name|chase_rr
index|[
name|NUMRR
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chase_rr_num
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|chase_lastgoodkey
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|chase_signer
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|chase_sigrdata
index|[
name|MY_PACKETSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|chase_sigrdata_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|chase_signature
index|[
name|MY_PACKETSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|chase_signature_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|chase_step
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sigchase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|cnamebuf
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_char
name|hostbuf
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|sockFD
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|filePtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|__res_state
name|res
decl_stmt|,
name|orig
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|cname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|progname
init|=
literal|"amnesia"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getclass
init|=
name|ns_c_in
decl_stmt|,
name|verbose
init|=
literal|0
decl_stmt|,
name|list
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|server_specified
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|gettype
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|getdomain
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|int
name|parsetype
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parseclass
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|printanswer
parameter_list|(
specifier|const
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hperror
parameter_list|(
name|int
name|errnum
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|addrinfo
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|gethostinfo
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getdomaininfo
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|getinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|printinfo
parameter_list|(
specifier|const
name|querybuf
modifier|*
name|answer
parameter_list|,
specifier|const
name|u_char
modifier|*
name|eom
parameter_list|,
name|int
name|filter
parameter_list|,
name|int
name|isls
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|u_char
modifier|*
name|pr_rr
parameter_list|(
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|filter
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|pr_type
parameter_list|(
name|int
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|pr_class
parameter_list|(
name|int
name|class
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|u_char
modifier|*
name|pr_cdname
parameter_list|(
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|ListHosts
parameter_list|(
name|char
modifier|*
name|namePtr
parameter_list|,
name|int
name|queryType
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|DecodeError
parameter_list|(
name|int
name|result
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: usage error (%s)\n"
argument_list|,
name|progname
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-adlrwv] [-t querytype] [-c class] host [server]\n\ \t-a is equivalent to '-v -t *'\n\ \t-c class to look for non-Internet data\n\ \t-d to turn on debugging output\n\ \t-l to turn on 'list mode'\n\ \t-r to disable recursive processing\n\ \t-s recursively chase signature found in answers\n\ \t-t querytype to look for a specific type of information\n\ \t-v for verbose output\n\ \t-w to wait forever until reply\n\ "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Public. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|inverse
init|=
literal|0
decl_stmt|,
name|waitmode
init|=
literal|0
decl_stmt|;
name|int
name|ncnames
decl_stmt|,
name|ch
decl_stmt|;
name|int
name|nkeychains
decl_stmt|,
name|i
decl_stmt|;
name|dst_init
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|progname
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
else|else
name|progname
operator|++
expr_stmt|;
name|res_ninit
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|res
operator|.
name|retrans
operator|=
literal|5
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"ac:dlrst:vw"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
name|gettype
operator|=
name|ns_t_any
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|getclass
operator|=
name|parseclass
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|list
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sigchase
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|gettype
operator|=
name|parsetype
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|verbose
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|res
operator|.
name|retry
operator|=
literal|1
expr_stmt|;
name|res
operator|.
name|retrans
operator|=
literal|15
expr_stmt|;
name|waitmode
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|(
literal|"unrecogized switch"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
block|}
if|if
condition|(
operator|(
name|gettype
operator|==
literal|0
operator|)
operator|&&
operator|(
name|sigchase
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Forcing `-t a' for signature trace.\n"
argument_list|)
expr_stmt|;
name|gettype
operator|=
name|ns_t_a
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|1
condition|)
name|usage
argument_list|(
literal|"missing host argument"
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|getdomain
argument_list|,
operator|*
name|argv
operator|++
argument_list|,
name|NS_MAXDNAME
argument_list|)
expr_stmt|;
name|getdomain
index|[
name|NS_MAXDNAME
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|argc
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|usage
argument_list|(
literal|"extra undefined arguments"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|s
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
expr_stmt|;
name|server_specified
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|s
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error in looking up server name:\n"
argument_list|)
expr_stmt|;
name|hperror
argument_list|(
name|res
operator|.
name|res_h_errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
operator|&
name|res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|NS_INADDRSZ
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Using domain server:\n"
argument_list|)
expr_stmt|;
name|printanswer
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res
operator|.
name|nsaddr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|=
name|addr
expr_stmt|;
name|res
operator|.
name|nsaddr
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Using domain server %s:\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
name|res
operator|.
name|retry
operator|=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|getdomain
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
operator|!
name|inet_aton
argument_list|(
name|getdomain
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
name|addr
operator|.
name|s_addr
operator|=
name|INADDR_NONE
expr_stmt|;
name|hp
operator|=
name|NULL
expr_stmt|;
name|res
operator|.
name|res_h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
comment|/*  * We handle default domains ourselves, thank you.  */
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_DEFNAMES
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|exit
argument_list|(
name|ListHosts
argument_list|(
name|getdomain
argument_list|,
name|gettype
condition|?
name|gettype
else|:
name|ns_t_a
argument_list|)
argument_list|)
expr_stmt|;
name|ncnames
operator|=
literal|5
expr_stmt|;
name|nkeychains
operator|=
literal|18
expr_stmt|;
while|while
condition|(
name|hp
operator|==
name|NULL
operator|&&
name|res
operator|.
name|res_h_errno
operator|==
name|TRY_AGAIN
condition|)
block|{
if|if
condition|(
name|addr
operator|.
name|s_addr
operator|==
name|INADDR_NONE
condition|)
block|{
name|cname
operator|=
name|NULL
expr_stmt|;
name|hp
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
name|gethostinfo
argument_list|(
name|getdomain
argument_list|)
expr_stmt|;
name|getdomain
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* clear this query */
if|if
condition|(
name|sigchase
operator|&&
operator|(
name|chase_step
operator|&
name|SD_RR
operator|)
condition|)
block|{
if|if
condition|(
name|nkeychains
operator|--
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Too many sig/key chains. Loop?\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chase_step
operator|&
name|SD_SIG
condition|)
block|{
comment|/* start new query, for KEY */
name|strcpy
argument_list|(
name|getdomain
argument_list|,
name|chase_signer
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|getdomain
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|gettype
operator|=
name|ns_t_key
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|chase_step
operator|&
name|SD_BADSIG
operator|)
condition|)
block|{
comment|/* start new query, for SIG */
name|strcpy
argument_list|(
name|getdomain
argument_list|,
name|chase_domain
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|getdomain
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|gettype
operator|=
name|ns_t_sig
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hp
operator|&&
operator|!
operator|(
name|chase_step
operator|&
name|SD_SIG
operator|)
operator|&&
operator|(
name|chase_step
operator|&
name|SD_BADSIG
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s for %s not found, last verified key %s\n"
argument_list|,
name|chase_step
operator|&
name|SD_SIG
condition|?
literal|"Key"
else|:
literal|"Signature"
argument_list|,
name|chase_step
operator|&
name|SD_SIG
condition|?
name|chase_signer
else|:
name|chase_domain
argument_list|,
name|chase_domain
argument_list|,
name|chase_lastgoodkey
condition|?
name|chase_lastgoodkey
else|:
literal|"None"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|getdomain
index|[
literal|0
index|]
operator|&&
name|cname
condition|)
block|{
if|if
condition|(
name|ncnames
operator|--
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Too many cnames.  Loop?\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|getdomain
argument_list|,
name|cname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|getdomain
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|getdomain
index|[
literal|0
index|]
condition|)
block|{
if|if
condition|(
name|chase_step
operator|&
name|SD_SIG
condition|)
block|{
name|printf
argument_list|(
literal|"Locating key for %s\n"
argument_list|,
name|getdomain
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|chase_step
operator|&
name|SD_SIG
condition|)
block|{
name|printf
argument_list|(
literal|"Locating signature for %s record(s) on %s\n"
argument_list|,
name|sym_ntos
argument_list|(
name|__p_type_syms
argument_list|,
name|chase_type
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|getdomain
argument_list|)
expr_stmt|;
block|}
name|hp
operator|=
name|NULL
expr_stmt|;
name|res
operator|.
name|res_h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
if|if
condition|(
name|addrinfo
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
condition|)
name|hp
operator|=
name|NULL
expr_stmt|;
else|else
name|hp
operator|=
operator|(
expr|struct
name|hostent
operator|*
operator|)
literal|1
expr_stmt|;
comment|/* XXX */
block|}
if|if
condition|(
operator|!
name|waitmode
condition|)
break|break;
block|}
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|hperror
argument_list|(
name|res
operator|.
name|res_h_errno
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Private. */
end_comment

begin_function
specifier|static
name|int
name|parsetype
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|success
decl_stmt|;
name|type
operator|=
name|sym_ston
argument_list|(
name|__p_type_syms
argument_list|,
name|s
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
return|return
operator|(
name|type
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|s
argument_list|,
literal|"*"
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ns_t_any
operator|)
return|;
if|if
condition|(
name|atoi
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid query type: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|int
name|parseclass
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|class
decl_stmt|,
name|success
decl_stmt|;
name|class
operator|=
name|sym_ston
argument_list|(
name|__p_class_syms
argument_list|,
name|s
argument_list|,
operator|&
name|success
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
condition|)
return|return
operator|(
name|class
operator|)
return|;
if|if
condition|(
name|atoi
argument_list|(
name|s
argument_list|)
condition|)
return|return
operator|(
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid query class: %s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
specifier|static
name|void
name|printanswer
parameter_list|(
specifier|const
name|struct
name|hostent
modifier|*
name|hp
parameter_list|)
block|{
name|struct
name|in_addr
modifier|*
modifier|*
name|hptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|cp
decl_stmt|;
name|printf
argument_list|(
literal|"Name: %s\n"
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Address:"
argument_list|)
expr_stmt|;
for|for
control|(
name|hptr
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|hptr
condition|;
name|hptr
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|*
name|hptr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nAliases:"
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|hp
operator|->
name|h_aliases
init|;
name|cp
operator|&&
operator|*
name|cp
operator|&&
operator|*
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hperror
parameter_list|(
name|int
name|errnum
parameter_list|)
block|{
switch|switch
condition|(
name|errnum
condition|)
block|{
case|case
name|HOST_NOT_FOUND
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Host not found.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TRY_AGAIN
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Host not found, try again.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_RECOVERY
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No recovery, Host not found.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NO_ADDRESS
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"There is an entry for this host, but it doesn't have "
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gettype
condition|)
block|{
case|case
name|ns_t_a
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"an Internet address.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_ns
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Name Server.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_md
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Destination.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_mf
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Forwarder.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_cname
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Canonical Name.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_soa
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Start of Authority record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_mb
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mailbox Domain Name.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_mg
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Group Member.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_mr
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Rename Name.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_null
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Null Resource record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_wks
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any Well Known Service information.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_ptr
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Pointer record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_hinfo
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any Host Information.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_minfo
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"any Mailbox Information.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_mx
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Mail Exchanger record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_txt
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Text record.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_rp
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Responsible Person.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_srv
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a Server Selector.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_naptr
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"a URN Naming Authority.\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"the information you requested.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|addrinfo
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
name|u_int32_t
name|ha
init|=
name|ntohl
argument_list|(
name|addr
operator|.
name|s_addr
argument_list|)
decl_stmt|;
name|char
name|name
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%u.%u.%u.%u.IN-ADDR.ARPA."
argument_list|,
operator|(
name|ha
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|ha
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|ha
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|ha
operator|>>
literal|24
operator|)
operator|&
literal|0xff
argument_list|)
expr_stmt|;
return|return
operator|(
name|getinfo
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|ns_t_ptr
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|gethostinfo
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|domain
decl_stmt|;
name|char
name|tmp
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|tp
decl_stmt|;
name|int
name|hp
decl_stmt|,
name|nDomain
decl_stmt|;
name|int
name|asis
init|=
literal|0
decl_stmt|;
name|u_int
name|n
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|getdomaininfo
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
for|for
control|(
name|cp
operator|=
name|name
operator|,
name|n
operator|=
literal|0
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'.'
condition|)
name|n
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|&&
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|'.'
expr_stmt|;
return|return
operator|(
name|hp
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
operator|(
name|tp
operator|=
name|res_hostalias
argument_list|(
operator|&
name|res
argument_list|,
name|name
argument_list|,
name|tmp
argument_list|,
sizeof|sizeof
name|tmp
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Aliased to \"%s\"\n"
argument_list|,
name|tp
argument_list|)
expr_stmt|;
name|res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
return|return
operator|(
name|getdomaininfo
argument_list|(
name|tp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>=
name|res
operator|.
name|ndots
condition|)
block|{
name|asis
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying null domain\n"
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|)
return|;
block|}
for|for
control|(
name|domain
operator|=
name|res
operator|.
name|dnsrch
init|;
operator|*
name|domain
condition|;
name|domain
operator|++
control|)
block|{
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying domain \"%s\"\n"
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
name|hp
operator|=
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|*
name|domain
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
return|return
operator|(
name|hp
operator|)
return|;
block|}
if|if
condition|(
name|res
operator|.
name|res_h_errno
operator|!=
name|HOST_NOT_FOUND
operator|||
operator|(
name|res
operator|.
name|options
operator|&
name|RES_DNSRCH
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|asis
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying null domain\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|getdomaininfo
argument_list|(
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|getdomaininfo
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|)
block|{
name|int
name|val1
decl_stmt|,
name|val2
decl_stmt|;
if|if
condition|(
name|gettype
condition|)
return|return
operator|(
name|getinfo
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|gettype
argument_list|)
operator|)
return|;
else|else
block|{
name|val1
operator|=
name|getinfo
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|gettype
operator|=
name|ns_t_a
argument_list|)
expr_stmt|;
if|if
condition|(
name|cname
operator|||
name|verbose
condition|)
return|return
operator|(
name|val1
operator|)
return|;
name|val2
operator|=
name|getinfo
argument_list|(
name|name
argument_list|,
name|domain
argument_list|,
name|gettype
operator|=
name|ns_t_mx
argument_list|)
expr_stmt|;
return|return
operator|(
name|val1
operator|||
name|val2
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|getinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|int
name|type
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_char
modifier|*
name|eom
decl_stmt|,
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|querybuf
name|buf
decl_stmt|,
name|answer
decl_stmt|;
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nmx
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|qdcount
decl_stmt|,
name|buflen
decl_stmt|;
name|u_short
name|pref
decl_stmt|,
name|class
decl_stmt|;
name|char
name|host
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
if|if
condition|(
name|domain
operator|==
name|NULL
condition|)
name|sprintf
argument_list|(
name|host
argument_list|,
literal|"%.*s"
argument_list|,
name|NS_MAXDNAME
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|host
argument_list|,
literal|"%.*s.%.*s"
argument_list|,
name|NS_MAXDNAME
argument_list|,
name|name
argument_list|,
name|NS_MAXDNAME
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|host
argument_list|,
name|getclass
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|"res_nmkquery failed\n"
argument_list|)
expr_stmt|;
name|res
operator|.
name|res_h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|n
operator|=
name|res_nsend
argument_list|(
operator|&
name|res
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
name|n
argument_list|,
name|answer
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|printf
argument_list|(
literal|"res_nsend failed\n"
argument_list|)
expr_stmt|;
name|res
operator|.
name|res_h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|eom
operator|=
name|answer
operator|.
name|qb2
operator|+
name|n
expr_stmt|;
return|return
operator|(
name|printinfo
argument_list|(
operator|&
name|answer
argument_list|,
name|eom
argument_list|,
name|ns_t_any
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|printinfo
parameter_list|(
specifier|const
name|querybuf
modifier|*
name|answer
parameter_list|,
specifier|const
name|u_char
modifier|*
name|eom
parameter_list|,
name|int
name|filter
parameter_list|,
name|int
name|isls
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|n1
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nmx
decl_stmt|,
name|ancount
decl_stmt|,
name|nscount
decl_stmt|,
name|arcount
decl_stmt|,
name|qdcount
decl_stmt|,
name|buflen
decl_stmt|,
name|savesigchase
decl_stmt|;
name|u_short
name|pref
decl_stmt|,
name|class
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|const
name|HEADER
modifier|*
name|hp
decl_stmt|;
comment|/* 	 * Find first satisfactory answer. 	 */
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|answer
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|nscount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
operator|(
name|verbose
operator|&&
name|isls
operator|==
literal|0
operator|)
condition|)
name|printf
argument_list|(
literal|"rcode = %d (%s), ancount=%d\n"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|DecodeError
argument_list|(
name|hp
operator|->
name|rcode
argument_list|)
argument_list|,
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
operator|(
name|ancount
operator|+
name|nscount
operator|+
name|arcount
operator|)
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|hp
operator|->
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
name|res
operator|.
name|res_h_errno
operator|=
name|HOST_NOT_FOUND
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|SERVFAIL
case|:
name|res
operator|.
name|res_h_errno
operator|=
name|TRY_AGAIN
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|NOERROR
case|:
name|res
operator|.
name|res_h_errno
operator|=
name|NO_DATA
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
name|res
operator|.
name|res_h_errno
operator|=
name|NO_RECOVERY
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|bp
operator|=
name|hostbuf
expr_stmt|;
name|nmx
operator|=
literal|0
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|hostbuf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|answer
operator|->
name|qb2
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|qdcount
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|qdcount
operator|--
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Form error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|printf
argument_list|(
literal|"Form error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|ancount
condition|)
block|{
if|if
condition|(
operator|!
name|hp
operator|->
name|aa
condition|)
if|if
condition|(
name|verbose
operator|&&
name|isls
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"The following answer is not authoritative:\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hp
operator|->
name|ad
condition|)
if|if
condition|(
name|verbose
operator|&&
name|isls
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"The following answer is not verified as authentic by the server:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|ancount
operator|>=
literal|0
operator|&&
name|cp
operator|&&
name|cp
operator|<
name|eom
condition|)
name|cp
operator|=
name|pr_rr
argument_list|(
name|cp
argument_list|,
name|answer
operator|->
name|qb2
argument_list|,
name|stdout
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|verbose
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* don't chase signatures for non-answer stuff */
name|savesigchase
operator|=
name|sigchase
expr_stmt|;
name|sigchase
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nscount
condition|)
block|{
name|printf
argument_list|(
literal|"For authoritative answers, see:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|nscount
operator|>=
literal|0
operator|&&
name|cp
operator|&&
name|cp
operator|<
name|eom
condition|)
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_rr
argument_list|(
name|cp
argument_list|,
name|answer
operator|->
name|qb2
argument_list|,
name|stdout
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arcount
condition|)
block|{
name|printf
argument_list|(
literal|"Additional information:\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|arcount
operator|>=
literal|0
operator|&&
name|cp
operator|&&
name|cp
operator|<
name|eom
condition|)
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_rr
argument_list|(
name|cp
argument_list|,
name|answer
operator|->
name|qb2
argument_list|,
name|stdout
argument_list|,
name|filter
argument_list|)
expr_stmt|;
block|}
comment|/* restore sigchase value */
name|sigchase
operator|=
name|savesigchase
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|print_hex_field
parameter_list|(
name|u_int8_t
name|field
index|[]
parameter_list|,
name|int
name|length
parameter_list|,
name|int
name|width
parameter_list|,
name|char
modifier|*
name|pref
parameter_list|)
block|{
comment|/* Prints an arbitrary bit field, from one address for some number of 		bytes.  Output is formatted via the width, and includes the raw 		hex value and (if printable) the printed value underneath.  "pref" 		is a string used to start each line, e.g., "   " to indent.  		This is very useful in gdb to see what's in a memory field. 	*/
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|stop
operator|=
operator|(
name|start
operator|+
name|width
operator|)
operator|<
name|length
condition|?
operator|(
name|start
operator|+
name|width
operator|)
else|:
name|length
expr_stmt|;
name|printf
argument_list|(
name|pref
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|stop
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
name|u_char
operator|)
name|field
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|pref
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|stop
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|isprint
argument_list|(
name|field
index|[
name|i
index|]
argument_list|)
condition|)
name|printf
argument_list|(
literal|" %c "
argument_list|,
operator|(
name|u_char
operator|)
name|field
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|start
operator|=
name|stop
expr_stmt|;
block|}
do|while
condition|(
name|start
operator|<
name|length
condition|)
do|;
block|}
end_function

begin_function
name|void
name|memswap
parameter_list|(
name|void
modifier|*
name|s1
parameter_list|,
name|void
modifier|*
name|s2
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
name|void
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmp
condition|)
block|{
name|printf
argument_list|(
literal|"Out of memory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|memcpy
argument_list|(
name|tmp
argument_list|,
name|s1
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|s2
argument_list|,
name|tmp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_hex
parameter_list|(
name|u_int8_t
name|field
index|[]
parameter_list|,
name|int
name|length
parameter_list|)
block|{
comment|/* Prints the hex values of a field...not as pretty as the print_hex_field. 	*/
name|int
name|i
decl_stmt|,
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|stop
operator|=
name|length
expr_stmt|;
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|stop
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%02x "
argument_list|,
operator|(
name|u_char
operator|)
name|field
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|start
operator|=
name|stop
expr_stmt|;
if|if
condition|(
name|start
operator|<
name|length
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|start
operator|<
name|length
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Print resource record fields in human readable form.  */
end_comment

begin_function
specifier|static
specifier|const
name|u_char
modifier|*
name|pr_rr
parameter_list|(
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
name|filter
parameter_list|)
block|{
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|,
name|n
decl_stmt|,
name|c
decl_stmt|,
name|proto
decl_stmt|,
name|ttl
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|u_char
name|in6addr
index|[
name|NS_IN6ADDRSZ
index|]
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|savecp
init|=
name|cp
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|cp1
decl_stmt|;
name|struct
name|protoent
modifier|*
name|protop
decl_stmt|;
name|struct
name|servent
modifier|*
name|servp
decl_stmt|;
name|char
name|punc
init|=
literal|' '
decl_stmt|;
name|int
name|doprint
decl_stmt|;
name|char
name|name
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
name|char
name|thisdomain
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
name|char
name|tmpbuf
index|[
sizeof|sizeof
expr|"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"]
expr_stmt|;
name|u_char
name|canonrr
index|[
name|MY_PACKETSZ
index|]
decl_stmt|;
name|size_t
name|canonrr_len
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* compression error */
name|strcpy
argument_list|(
name|thisdomain
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|type
operator|=
name|ns_get16
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|class
operator|=
name|ns_get16
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|ttl
operator|=
name|ns_get32
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|filter
operator|==
name|type
operator|||
name|filter
operator|==
name|ns_t_any
operator|||
operator|(
name|filter
operator|==
name|ns_t_a
operator|&&
operator|(
name|type
operator|==
name|ns_t_ptr
operator|||
name|type
operator|==
name|ns_t_ns
operator|)
operator|)
condition|)
name|doprint
operator|=
literal|1
expr_stmt|;
else|else
name|doprint
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s\t%d%s\t%s"
argument_list|,
name|name
argument_list|,
name|ttl
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s%s %s"
argument_list|,
name|name
argument_list|,
name|pr_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|pr_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
name|punc
operator|=
literal|'\t'
expr_stmt|;
else|else
name|punc
operator|=
literal|' '
expr_stmt|;
block|}
name|dlen
operator|=
name|ns_get16
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
name|cp1
operator|=
name|cp
expr_stmt|;
comment|/* 	 * Print type specific data, if appropriate. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_a
case|:
name|memcpy
argument_list|(
operator|&
name|inaddr
argument_list|,
name|cp
argument_list|,
name|NS_INADDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
case|case
name|ns_t_aaaa
case|:
name|memcpy
argument_list|(
name|in6addr
argument_list|,
name|cp
argument_list|,
name|NS_IN6ADDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|in6addr
argument_list|,
name|tmpbuf
argument_list|,
sizeof|sizeof
name|tmpbuf
argument_list|)
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|tmpbuf
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c???"
argument_list|,
name|punc
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
case|case
name|ns_t_cname
case|:
if|if
condition|(
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
literal|512
argument_list|,
name|cp
argument_list|,
name|cnamebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|cnamebuf
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
name|cname
operator|=
name|cnamebuf
expr_stmt|;
case|case
name|ns_t_mb
case|:
case|case
name|ns_t_mg
case|:
case|case
name|ns_t_mr
case|:
case|case
name|ns_t_ns
case|:
case|case
name|ns_t_ptr
case|:
block|{
specifier|const
name|u_char
modifier|*
name|startrdata
init|=
name|cp
decl_stmt|;
name|u_char
name|cdname
index|[
name|NS_MAXCDNAME
index|]
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* Extract DNSSEC canonical RR. */
name|n
operator|=
name|ns_name_unpack
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|MY_PACKETSZ
argument_list|,
name|startrdata
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|n
operator|=
name|ns_name_ntol
argument_list|(
name|cdname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* Copy header. */
name|memcpy
argument_list|(
name|canonrr
argument_list|,
name|cp1
operator|-
name|NS_HEADERDATA_SIZE
argument_list|,
name|NS_HEADERDATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Overwrite length field. */
name|ns_put16
argument_list|(
name|n
argument_list|,
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
operator|-
name|NS_INT16SZ
argument_list|)
expr_stmt|;
comment|/* Copy unpacked name. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
argument_list|,
name|cdname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|canonrr_len
operator|=
name|NS_HEADERDATA_SIZE
operator|+
name|n
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ns_t_hinfo
case|:
case|case
name|ns_t_isdn
case|:
block|{
specifier|const
name|u_char
modifier|*
name|cp2
init|=
name|cp
operator|+
name|dlen
decl_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|cp
operator|<
name|cp2
operator|)
operator|&&
operator|(
name|n
operator|=
operator|*
name|cp
operator|++
operator|)
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|ns_t_hinfo
condition|)
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n; *** Warning *** OS-type missing"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ns_t_soa
case|:
block|{
specifier|const
name|u_char
modifier|*
name|startname
init|=
name|cp
decl_stmt|;
name|u_char
name|cdname
index|[
name|NS_MAXCDNAME
index|]
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_name_unpack
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
literal|512
argument_list|,
name|startname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|n
operator|=
name|ns_name_ntol
argument_list|(
name|cdname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* Copy header. */
name|memcpy
argument_list|(
name|canonrr
argument_list|,
name|cp1
operator|-
name|NS_HEADERDATA_SIZE
argument_list|,
name|NS_HEADERDATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Copy expanded name. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
argument_list|,
name|cdname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|canonrr_len
operator|=
name|NS_HEADERDATA_SIZE
operator|+
name|n
expr_stmt|;
block|}
name|startname
operator|=
name|cp
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_name_unpack
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
literal|512
argument_list|,
name|startname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|n
operator|=
name|ns_name_ntol
argument_list|(
name|cdname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* Copy expanded name. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|canonrr_len
argument_list|,
name|cdname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|canonrr_len
operator|+=
name|n
expr_stmt|;
comment|/* Copy rest of SOA. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|canonrr_len
argument_list|,
name|cp
argument_list|,
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|canonrr_len
operator|+=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
comment|/* Overwrite length field. */
name|ns_put16
argument_list|(
name|canonrr_len
operator|-
name|NS_HEADERDATA_SIZE
argument_list|,
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
operator|-
name|NS_INT16SZ
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"(\n\t\t\t%ld\t;serial (version)"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;refresh period"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;retry refresh this often"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;expiration period"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n\t\t\t%ld\t;minimum TTL\n\t\t\t)"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
break|break;
block|}
case|case
name|ns_t_mx
case|:
case|case
name|ns_t_afsdb
case|:
case|case
name|ns_t_rt
case|:
block|{
specifier|const
name|u_char
modifier|*
name|startrdata
init|=
name|cp
decl_stmt|;
name|u_char
name|cdname
index|[
name|NS_MAXCDNAME
index|]
decl_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ns_t_mx
operator|&&
operator|!
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (pri=%d) by "
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\t%d "
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_name_unpack
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
literal|512
argument_list|,
name|startrdata
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|n
operator|=
name|ns_name_ntol
argument_list|(
name|cdname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* Copy header. */
name|memcpy
argument_list|(
name|canonrr
argument_list|,
name|cp1
operator|-
name|NS_HEADERDATA_SIZE
argument_list|,
name|NS_HEADERDATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Overwrite length field. */
name|ns_put16
argument_list|(
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
name|n
argument_list|,
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
operator|-
name|NS_INT16SZ
argument_list|)
expr_stmt|;
comment|/* Copy u_short. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
argument_list|,
name|startrdata
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy expanded name. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|,
name|cdname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|canonrr_len
operator|=
name|NS_HEADERDATA_SIZE
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
name|n
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ns_t_srv
case|:
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_naptr
case|:
comment|/* order */
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* preference */
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|NS_INT16SZ
expr_stmt|;
comment|/* Flags */
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|n
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c\"\""
argument_list|,
name|punc
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Service */
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|n
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c\"\""
argument_list|,
name|punc
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Regexp  */
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|n
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c\"\""
argument_list|,
name|punc
argument_list|)
expr_stmt|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* replacement  */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_minfo
case|:
case|case
name|ns_t_rp
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|type
operator|==
name|ns_t_rp
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
operator|*
name|p
operator|=
literal|'@'
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_x25
case|:
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%.*s"
argument_list|,
name|punc
argument_list|,
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
break|break;
case|case
name|ns_t_txt
case|:
block|{
name|int
name|n
decl_stmt|,
name|j
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|end
init|=
name|cp
operator|+
name|dlen
decl_stmt|;
while|while
condition|(
name|cp
operator|<
name|end
condition|)
block|{
if|if
condition|(
name|doprint
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|" \""
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|n
operator|!=
literal|0
condition|)
for|for
control|(
name|j
operator|=
name|n
init|;
name|j
operator|>
literal|0
operator|&&
name|cp
operator|<
name|end
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
operator|||
operator|*
name|cp
operator|==
literal|'"'
operator|||
operator|*
name|cp
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|doprint
condition|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
name|ns_t_wks
case|:
if|if
condition|(
name|dlen
operator|<
name|INT32SZ
operator|+
literal|1
condition|)
break|break;
name|memcpy
argument_list|(
operator|&
name|inaddr
argument_list|,
name|cp
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
name|proto
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|protop
operator|=
name|getprotobynumber
argument_list|(
name|proto
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|protop
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s %s"
argument_list|,
name|punc
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|,
name|protop
operator|->
name|p_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s %d"
argument_list|,
name|punc
argument_list|,
name|inet_ntoa
argument_list|(
name|inaddr
argument_list|)
argument_list|,
name|proto
argument_list|)
expr_stmt|;
block|}
name|n
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
operator|+
name|dlen
condition|)
block|{
name|c
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
name|servp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|protop
condition|)
name|servp
operator|=
name|getservbyport
argument_list|(
name|htons
argument_list|(
name|n
argument_list|)
argument_list|,
name|protop
operator|->
name|p_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
block|{
if|if
condition|(
name|servp
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|servp
operator|->
name|s_name
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|n
operator|&
literal|07
condition|)
do|;
block|}
break|break;
case|case
name|ns_t_nxt
case|:
block|{
specifier|const
name|u_char
modifier|*
name|startrdata
init|=
name|cp
decl_stmt|;
name|u_char
name|cdname
index|[
name|NS_MAXCDNAME
index|]
decl_stmt|;
name|size_t
name|bitmaplen
decl_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|bitmaplen
operator|=
name|dlen
operator|-
operator|(
name|cp
operator|-
name|startrdata
operator|)
expr_stmt|;
comment|/* extract dnssec canonical rr */
name|n
operator|=
name|ns_name_unpack
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|MY_PACKETSZ
argument_list|,
name|startrdata
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|n
operator|=
name|ns_name_ntol
argument_list|(
name|cdname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
comment|/* Copy header. */
name|memcpy
argument_list|(
name|canonrr
argument_list|,
name|cp1
operator|-
name|NS_HEADERDATA_SIZE
argument_list|,
name|NS_HEADERDATA_SIZE
argument_list|)
expr_stmt|;
comment|/* Overwrite length field. */
name|ns_put16
argument_list|(
name|n
operator|+
name|bitmaplen
argument_list|,
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
operator|-
name|NS_INT16SZ
argument_list|)
expr_stmt|;
comment|/* Copy expanded name. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
argument_list|,
name|cdname
argument_list|,
name|n
argument_list|)
expr_stmt|;
comment|/* Copy type bit map. */
name|memcpy
argument_list|(
name|canonrr
operator|+
name|NS_HEADERDATA_SIZE
operator|+
name|n
argument_list|,
name|cp
argument_list|,
name|bitmaplen
argument_list|)
expr_stmt|;
name|canonrr_len
operator|=
name|NS_HEADERDATA_SIZE
operator|+
name|n
operator|+
name|bitmaplen
expr_stmt|;
block|}
name|cp
operator|+=
name|bitmaplen
expr_stmt|;
break|break;
block|}
case|case
name|ns_t_sig
case|:
block|{
name|int
name|tc
decl_stmt|;
specifier|const
name|u_char
modifier|*
name|origttl
decl_stmt|;
comment|/* type covered */
name|tc
operator|=
name|ns_get16
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%s"
argument_list|,
name|punc
argument_list|,
name|sym_ntos
argument_list|(
name|__p_type_syms
argument_list|,
name|tc
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* algorithm */
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
comment|/* labels */
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
comment|/* original ttl */
name|origttl
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* signature expiration */
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* time signed */
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get32
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* key footprint */
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* signer's name */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|pr_cdname
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|doprint
operator|&&
operator|!
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s for type %s"
argument_list|,
name|name
argument_list|,
name|sym_ntos
argument_list|(
name|__p_type_syms
argument_list|,
name|tc
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* signature */
block|{
name|char
name|str
index|[
name|MY_PACKETSZ
index|]
decl_stmt|;
name|size_t
name|len
init|=
name|cp1
operator|-
name|cp
operator|+
name|dlen
decl_stmt|;
name|b64_ntop
argument_list|(
name|cp
argument_list|,
name|len
argument_list|,
name|str
argument_list|,
name|MY_PACKETSZ
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigchase
operator|&&
operator|!
operator|(
name|chase_step
operator|&
name|SD_SIG
operator|)
operator|&&
name|strcmp
argument_list|(
name|chase_domain
argument_list|,
name|thisdomain
argument_list|)
operator|==
literal|0
operator|&&
name|chase_class
operator|==
name|class
operator|&
name|chase_type
operator|==
name|tc
condition|)
block|{
name|u_char
name|cdname
index|[
name|NS_MAXCDNAME
index|]
decl_stmt|;
if|if
condition|(
name|doprint
operator|&&
operator|!
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (chasing key)"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|chase_signer
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|chase_sigorigttl
index|[
literal|0
index|]
argument_list|,
name|origttl
argument_list|,
name|NS_INT32SZ
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_name_ntol
argument_list|(
name|cp1
operator|+
name|SIG_RDATA_BY_NAME
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|chase_sigrdata
argument_list|,
name|cp1
argument_list|,
name|SIG_RDATA_BY_NAME
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|chase_sigrdata
operator|+
name|SIG_RDATA_BY_NAME
argument_list|,
name|cdname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|chase_sigrdata_len
operator|+=
name|SIG_RDATA_BY_NAME
operator|+
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|chase_signature
argument_list|,
name|cp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|chase_signature_len
operator|=
name|len
expr_stmt|;
name|chase_step
operator||=
name|SD_SIG
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sigchase
condition|)
block|{
name|chase_step
operator||=
name|SD_BADSIG
expr_stmt|;
block|}
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
case|case
name|ns_t_key
case|:
comment|/* flags */
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c%d"
argument_list|,
name|punc
argument_list|,
name|ns_get16
argument_list|(
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* protocol */
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
comment|/* algorithm */
name|n
operator|=
operator|*
name|cp
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
switch|switch
condition|(
name|n
condition|)
block|{
case|case
literal|1
case|:
comment|/* MD5/RSA */
block|{
name|char
name|str
index|[
name|MY_PACKETSZ
index|]
decl_stmt|;
name|size_t
name|len
init|=
name|cp1
operator|-
name|cp
operator|+
name|dlen
decl_stmt|;
name|b64_ntop
argument_list|(
name|cp
argument_list|,
name|len
argument_list|,
name|str
argument_list|,
name|MY_PACKETSZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|len
expr_stmt|;
if|if
condition|(
name|doprint
operator|&&
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Unknown algorithm %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|=
name|cp1
operator|+
name|dlen
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|sigchase
operator|&&
operator|(
name|chase_step
operator|&
operator|(
name|SD_SIG
operator||
name|SD_RR
operator|)
operator|)
operator|&&
name|strcmp
argument_list|(
name|getdomain
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
name|getclass
operator|==
name|class
operator|&
name|gettype
operator|==
name|type
condition|)
block|{
name|DST_KEY
modifier|*
name|dstkey
decl_stmt|;
name|int
name|rc
decl_stmt|,
name|len
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
comment|/* convert dnskey to dstkey */
name|dstkey
operator|=
name|dst_dnskey_to_key
argument_list|(
name|name
argument_list|,
name|cp1
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
comment|/* fix ttl in rr */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMRR
operator|&&
name|chase_rr
index|[
name|i
index|]
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|dn_skipname
argument_list|(
name|chase_rr
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|chase_rr
index|[
name|i
index|]
operator|.
name|data
operator|+
name|chase_rr
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>=
literal|0
condition|)
name|memcpy
argument_list|(
name|chase_rr
index|[
name|i
index|]
operator|.
name|data
operator|+
name|len
operator|+
name|NS_INT16SZ
operator|+
name|NS_INT16SZ
argument_list|,
operator|&
name|chase_sigorigttl
argument_list|,
name|INT32SZ
argument_list|)
expr_stmt|;
block|}
comment|/* sort rr's (qsort() is too slow) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMRR
operator|&&
name|chase_rr
index|[
name|i
index|]
operator|.
name|len
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|i
operator|<
name|NUMRR
operator|&&
name|chase_rr
index|[
name|j
index|]
operator|.
name|len
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|memcmp
argument_list|(
name|chase_rr
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|chase_rr
index|[
name|j
index|]
operator|.
name|data
argument_list|,
name|MY_PACKETSZ
argument_list|)
operator|>
literal|0
condition|)
name|memswap
argument_list|(
operator|&
name|chase_rr
index|[
name|i
index|]
argument_list|,
operator|&
name|chase_rr
index|[
name|j
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|rrstruct
argument_list|)
argument_list|)
expr_stmt|;
comment|/* append rr's to sigrdata */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NUMRR
operator|&&
name|chase_rr
index|[
name|i
index|]
operator|.
name|len
condition|;
name|i
operator|++
control|)
block|{
name|memcpy
argument_list|(
name|chase_sigrdata
operator|+
name|chase_sigrdata_len
argument_list|,
name|chase_rr
index|[
name|i
index|]
operator|.
name|data
argument_list|,
name|chase_rr
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|chase_sigrdata_len
operator|+=
name|chase_rr
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
block|}
comment|/* print rr-data and signature */
if|if
condition|(
name|verbose
condition|)
block|{
name|print_hex_field
argument_list|(
name|chase_sigrdata
argument_list|,
name|chase_sigrdata_len
argument_list|,
literal|21
argument_list|,
literal|"DATA: "
argument_list|)
expr_stmt|;
name|print_hex_field
argument_list|(
name|chase_signature
argument_list|,
name|chase_signature_len
argument_list|,
literal|21
argument_list|,
literal|"SIG: "
argument_list|)
expr_stmt|;
block|}
comment|/* do the works */
if|if
condition|(
name|dstkey
condition|)
name|rc
operator|=
name|dst_verify_data
argument_list|(
name|SIG_MODE_ALL
argument_list|,
name|dstkey
argument_list|,
name|NULL
argument_list|,
name|chase_sigrdata
argument_list|,
name|chase_sigrdata_len
argument_list|,
name|chase_signature
argument_list|,
name|chase_signature_len
argument_list|)
expr_stmt|;
else|else
name|rc
operator|=
literal|1
expr_stmt|;
name|dst_free_key
argument_list|(
name|dstkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\nVerification %s"
argument_list|,
name|rc
operator|==
literal|0
condition|?
literal|"was SUCCESSFULL"
else|:
literal|"FAILED"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" that %s verify our %s "
literal|"record(s) on %s"
argument_list|,
name|rc
operator|==
literal|0
condition|?
literal|"successfully"
else|:
literal|"DOES NOT"
argument_list|,
name|sym_ntos
argument_list|(
name|__p_type_syms
argument_list|,
name|chase_type
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|chase_domain
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rc
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|chase_lastgoodkey
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* don't trace further after a failure */
name|sigchase
operator|=
literal|0
expr_stmt|;
block|}
name|chase_step
operator|=
literal|0
expr_stmt|;
name|chase_signature_len
operator|=
literal|0
expr_stmt|;
name|chase_sigrdata_len
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|chase_sigorigttl
argument_list|,
literal|0
argument_list|,
name|NS_INT32SZ
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|chase_rr
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|chase_rr
argument_list|)
argument_list|)
expr_stmt|;
name|chase_rr_num
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%c???"
argument_list|,
name|punc
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|dlen
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|!=
name|cp1
operator|+
name|dlen
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"packet size error (%p != %p)\n"
argument_list|,
name|cp
argument_list|,
name|cp1
operator|+
name|dlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|sigchase
operator|&&
operator|!
operator|(
name|chase_step
operator|&
name|SD_SIG
operator|)
operator|&&
name|strcmp
argument_list|(
name|getdomain
argument_list|,
name|thisdomain
argument_list|)
operator|==
literal|0
operator|&&
name|getclass
operator|==
name|class
operator|&&
name|gettype
operator|==
name|type
operator|&&
name|type
operator|!=
name|ns_t_sig
condition|)
block|{
name|u_char
name|cdname
index|[
name|NS_MAXCDNAME
index|]
decl_stmt|;
if|if
condition|(
name|doprint
operator|&&
operator|!
name|verbose
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|" (chasing signature)"
argument_list|,
name|sigchase
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* unpack rr */
name|n
operator|=
name|ns_name_unpack
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|MY_PACKETSZ
argument_list|,
name|savecp
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
name|n
operator|=
name|ns_name_ntol
argument_list|(
name|cdname
argument_list|,
name|cdname
argument_list|,
sizeof|sizeof
name|cdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>=
literal|0
condition|)
block|{
name|memcpy
argument_list|(
name|chase_rr
index|[
name|chase_rr_num
index|]
operator|.
name|data
argument_list|,
name|cdname
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|chase_rr
index|[
name|chase_rr_num
index|]
operator|.
name|data
operator|+
name|n
argument_list|,
name|canonrr_len
condition|?
name|canonrr
else|:
name|cp1
operator|-
name|NS_HEADERDATA_SIZE
argument_list|,
name|canonrr_len
condition|?
name|canonrr_len
else|:
name|dlen
operator|+
name|NS_HEADERDATA_SIZE
argument_list|)
expr_stmt|;
name|chase_rr
index|[
name|chase_rr_num
index|]
operator|.
name|len
operator|=
name|n
operator|+
operator|(
name|canonrr_len
operator|!=
literal|0
condition|?
name|canonrr_len
else|:
name|dlen
operator|+
name|NS_HEADERDATA_SIZE
operator|)
expr_stmt|;
name|strcpy
argument_list|(
name|chase_domain
argument_list|,
name|getdomain
argument_list|)
expr_stmt|;
name|chase_class
operator|=
name|class
expr_stmt|;
name|chase_type
operator|=
name|type
expr_stmt|;
name|chase_step
operator||=
name|SD_RR
expr_stmt|;
name|chase_rr_num
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|doprint
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a string for the type.  A few get special treatment when  * not in verbose mode, to make the program more chatty and easier to  * understand.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pr_type
parameter_list|(
name|int
name|type
parameter_list|)
block|{
if|if
condition|(
operator|!
name|verbose
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ns_t_a
case|:
return|return
operator|(
literal|"has address"
operator|)
return|;
case|case
name|ns_t_cname
case|:
return|return
operator|(
literal|"is a nickname for"
operator|)
return|;
case|case
name|ns_t_mx
case|:
return|return
operator|(
literal|"mail is handled"
operator|)
return|;
case|case
name|ns_t_txt
case|:
return|return
operator|(
literal|"descriptive text"
operator|)
return|;
case|case
name|ns_t_sig
case|:
return|return
operator|(
literal|"has a signature signed by"
operator|)
return|;
case|case
name|ns_t_key
case|:
return|return
operator|(
literal|"has a key"
operator|)
return|;
case|case
name|ns_t_nxt
case|:
return|return
operator|(
literal|"next valid name"
operator|)
return|;
case|case
name|ns_t_afsdb
case|:
return|return
operator|(
literal|"DCE or AFS service from"
operator|)
return|;
block|}
if|if
condition|(
name|verbose
condition|)
return|return
operator|(
name|sym_ntos
argument_list|(
name|__p_type_syms
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|sym_ntop
argument_list|(
name|__p_type_syms
argument_list|,
name|type
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return a mnemonic for class  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|pr_class
parameter_list|(
name|int
name|class
parameter_list|)
block|{
specifier|static
name|char
name|spacestr
index|[
literal|20
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|ns_c_in
case|:
comment|/* internet class */
return|return
operator|(
literal|""
operator|)
return|;
case|case
name|ns_c_hs
case|:
comment|/* hesiod class */
return|return
operator|(
literal|""
operator|)
return|;
block|}
name|spacestr
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|spacestr
index|[
literal|1
index|]
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|spacestr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|u_char
modifier|*
name|pr_cdname
parameter_list|(
specifier|const
name|u_char
modifier|*
name|cp
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|int
name|namelen
parameter_list|)
block|{
name|int
name|n
init|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|MY_PACKETSZ
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
name|namelen
operator|-
literal|2
argument_list|)
decl_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|name
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
operator|(
name|cp
operator|+
name|n
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ListHosts
parameter_list|(
name|char
modifier|*
name|namePtr
parameter_list|,
name|int
name|queryType
parameter_list|)
block|{
name|querybuf
name|buf
decl_stmt|,
name|answer
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
specifier|const
name|HEADER
modifier|*
name|headerPtr
decl_stmt|;
specifier|const
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
enum|enum
block|{
name|NO_ERRORS
block|,
name|ERR_READING_LEN
block|,
name|ERR_READING_MSG
block|,
name|ERR_PRINTING
block|}
name|error
init|=
name|NO_ERRORS
enum|;
name|int
name|msglen
decl_stmt|,
name|amtToRead
decl_stmt|,
name|numRead
decl_stmt|,
name|i
decl_stmt|,
name|len
decl_stmt|,
name|dlen
decl_stmt|,
name|type
decl_stmt|,
name|nscount
decl_stmt|,
name|n
decl_stmt|;
name|int
name|numAnswers
init|=
literal|0
decl_stmt|,
name|soacnt
init|=
literal|0
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|u_char
name|tmp
index|[
name|NS_INT16SZ
index|]
decl_stmt|;
name|char
name|name
index|[
name|NS_MAXDNAME
index|]
decl_stmt|,
name|dname
index|[
literal|2
index|]
index|[
name|NS_MAXDNAME
index|]
decl_stmt|,
name|domain
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|nmp
decl_stmt|,
modifier|*
name|eom
decl_stmt|;
comment|/* Names and addresses of name servers to try. */
name|char
name|nsname
index|[
name|NUMNS
index|]
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
name|int
name|nshaveaddr
index|[
name|NUMNS
index|]
decl_stmt|;
name|struct
name|in_addr
name|nsipaddr
index|[
name|NUMNSADDR
index|]
decl_stmt|;
name|int
name|numns
decl_stmt|,
name|numnsaddr
decl_stmt|,
name|thisns
decl_stmt|;
comment|/* 	 * Normalize to not have trailing dot.  We do string compares below 	 * of info from name server, and it won't have trailing dots. 	 */
name|i
operator|=
name|strlen
argument_list|(
name|namePtr
argument_list|)
expr_stmt|;
if|if
condition|(
name|namePtr
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|namePtr
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|server_specified
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|nsipaddr
index|[
literal|0
index|]
argument_list|,
operator|&
name|res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|,
name|NS_INADDRSZ
argument_list|)
expr_stmt|;
name|numnsaddr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * First we have to find out where to look.  This needs a NS 		 * query, possibly followed by looking up addresses for some 		 * of the names. 		 */
name|msglen
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|ns_o_query
argument_list|,
name|namePtr
argument_list|,
name|ns_c_in
argument_list|,
name|ns_t_ns
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"res_nmkquery failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|msglen
operator|=
name|res_nsend
argument_list|(
operator|&
name|res
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
name|msglen
argument_list|,
name|answer
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot find nameserver -- try again later\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"rcode = %d (%s), ancount=%d\n"
argument_list|,
name|answer
operator|.
name|qb1
operator|.
name|rcode
argument_list|,
name|DecodeError
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|rcode
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|ancount
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Analyze response to our NS lookup. 		 */
name|nscount
operator|=
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|ancount
argument_list|)
operator|+
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|nscount
argument_list|)
operator|+
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|arcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|answer
operator|.
name|qb1
operator|.
name|rcode
operator|!=
name|NOERROR
operator|||
name|nscount
operator|==
literal|0
condition|)
block|{
switch|switch
condition|(
name|answer
operator|.
name|qb1
operator|.
name|rcode
condition|)
block|{
case|case
name|NXDOMAIN
case|:
comment|/* Check if it's an authoritive answer */
if|if
condition|(
name|answer
operator|.
name|qb1
operator|.
name|aa
condition|)
name|printf
argument_list|(
literal|"No such domain\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"Unable to get information about domain -- try again later.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SERVFAIL
case|:
name|printf
argument_list|(
literal|"Unable to get information about that domain -- try again later.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOERROR
case|:
name|printf
argument_list|(
literal|"That domain exists, but seems to be a leaf node.\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|FORMERR
case|:
case|case
name|NOTIMP
case|:
case|case
name|REFUSED
case|:
name|printf
argument_list|(
literal|"Unrecoverable error looking up domain name.\n"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cp
operator|=
name|answer
operator|.
name|qb2
operator|+
name|HFIXEDSZ
expr_stmt|;
name|eom
operator|=
name|answer
operator|.
name|qb2
operator|+
name|msglen
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|answer
operator|.
name|qb1
operator|.
name|qdcount
argument_list|)
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Form error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|eom
condition|)
block|{
name|printf
argument_list|(
literal|"Form error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
name|numns
operator|=
literal|0
expr_stmt|;
name|numnsaddr
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Look at response from NS lookup for NS and A records. 		 */
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|nscount
condition|;
name|nscount
operator|--
control|)
block|{
name|cp
operator|+=
name|dn_expand
argument_list|(
name|answer
operator|.
name|qb2
argument_list|,
name|answer
operator|.
name|qb2
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|eom
condition|)
block|{
name|printf
argument_list|(
literal|"Form error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|type
operator|=
name|ns_get16
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|+
name|INT16SZ
operator|+
name|INT32SZ
expr_stmt|;
name|dlen
operator|=
name|ns_get16
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|dlen
operator|>
name|eom
condition|)
block|{
name|printf
argument_list|(
literal|"Form error.\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
if|if
condition|(
name|type
operator|==
name|ns_t_ns
condition|)
block|{
if|if
condition|(
name|dn_expand
argument_list|(
name|answer
operator|.
name|qb2
argument_list|,
name|eom
argument_list|,
name|cp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|numns
operator|<
name|NUMNS
operator|&&
name|ns_samename
argument_list|(
operator|(
name|char
operator|*
operator|)
name|domain
argument_list|,
name|namePtr
argument_list|)
operator|==
literal|1
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|ns_samename
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
operator|==
literal|1
condition|)
comment|/* duplicate */
break|break;
if|if
condition|(
name|i
operator|>=
name|numns
condition|)
block|{
name|strncpy
argument_list|(
name|nsname
index|[
name|numns
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|nshaveaddr
index|[
name|numns
index|]
operator|=
literal|0
expr_stmt|;
name|numns
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|type
operator|==
name|ns_t_a
condition|)
block|{
if|if
condition|(
name|numnsaddr
operator|<
name|NUMNSADDR
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|ns_samename
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|domain
argument_list|)
operator|==
literal|1
condition|)
block|{
name|nshaveaddr
index|[
name|i
index|]
operator|++
expr_stmt|;
name|memcpy
argument_list|(
operator|&
name|nsipaddr
index|[
name|numnsaddr
index|]
argument_list|,
name|cp
argument_list|,
name|NS_INADDRSZ
argument_list|)
expr_stmt|;
name|numnsaddr
operator|++
expr_stmt|;
break|break;
block|}
block|}
block|}
name|cp
operator|+=
name|dlen
expr_stmt|;
block|}
comment|/* 		 * Usually we'll get addresses for all the servers in the 		 * additional info section.  But in case we don't, look up 		 * their addresses. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|numns
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nshaveaddr
index|[
name|i
index|]
operator|==
literal|0
condition|)
block|{
name|struct
name|in_addr
modifier|*
modifier|*
name|hptr
decl_stmt|;
name|int
name|numaddrs
init|=
literal|0
decl_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|nsname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
condition|)
block|{
for|for
control|(
name|hptr
operator|=
operator|(
expr|struct
name|in_addr
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|hptr
operator|!=
name|NULL
condition|;
name|hptr
operator|++
control|)
if|if
condition|(
name|numnsaddr
operator|<
name|NUMNSADDR
condition|)
block|{
name|memcpy
argument_list|(
operator|&
name|nsipaddr
index|[
name|numnsaddr
index|]
argument_list|,
operator|*
name|hptr
argument_list|,
name|NS_INADDRSZ
argument_list|)
expr_stmt|;
name|numnsaddr
operator|++
expr_stmt|;
name|numaddrs
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d addresses for %s by extra query\n"
argument_list|,
name|numaddrs
argument_list|,
name|nsname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Found %d addresses for %s\n"
argument_list|,
name|nshaveaddr
index|[
name|i
index|]
argument_list|,
name|nsname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Now nsipaddr has numnsaddr addresses for name servers that 	 * serve the requested domain.  Now try to find one that will 	 * accept a zone transfer. 	 */
name|thisns
operator|=
literal|0
expr_stmt|;
name|again
label|:
name|numAnswers
operator|=
literal|0
expr_stmt|;
name|soacnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Create a query packet for the requested domain name. 	 */
name|msglen
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|namePtr
argument_list|,
name|getclass
argument_list|,
name|ns_t_axfr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ListHosts: Res_mkquery failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
expr_stmt|;
comment|/* 	 * Set up a virtual circuit to the server. 	 */
for|for
control|(
operator|(
name|void
operator|)
name|NULL
init|;
name|thisns
operator|<
name|numnsaddr
condition|;
name|thisns
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|sockFD
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"ListHosts"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|memcpy
argument_list|(
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
operator|&
name|nsipaddr
index|[
name|thisns
index|]
argument_list|,
name|NS_INADDRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Trying %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|sockFD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|>=
literal|0
condition|)
break|break;
if|if
condition|(
name|verbose
condition|)
name|perror
argument_list|(
literal|"Connection failed, trying next server"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|thisns
operator|>=
name|numnsaddr
condition|)
block|{
name|printf
argument_list|(
literal|"No server for that domain responded\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|verbose
condition|)
name|perror
argument_list|(
literal|"Error from the last server was"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
comment|/* 	 * Send length& message for zone transfer  	 */
name|ns_put16
argument_list|(
name|msglen
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
name|INT16SZ
argument_list|)
operator|!=
name|INT16SZ
operator|||
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
operator|.
name|qb2
argument_list|,
name|msglen
argument_list|)
operator|!=
name|msglen
condition|)
block|{
name|perror
argument_list|(
literal|"ListHosts"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|filePtr
operator|=
name|stdout
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * Read the length of the response. 		 */
name|cp
operator|=
name|buf
operator|.
name|qb2
expr_stmt|;
name|amtToRead
operator|=
name|INT16SZ
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_LEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ns_get16
argument_list|(
name|buf
operator|.
name|qb2
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
comment|/* Protocol violation. */
comment|/* 		 * Read the response. 		 */
name|amtToRead
operator|=
name|len
expr_stmt|;
name|cp
operator|=
name|buf
operator|.
name|qb2
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_MSG
expr_stmt|;
break|break;
block|}
name|i
operator|=
name|buf
operator|.
name|qb1
operator|.
name|rcode
expr_stmt|;
if|if
condition|(
name|i
operator|!=
name|NOERROR
operator|||
name|ntohs
argument_list|(
name|buf
operator|.
name|qb1
operator|.
name|ancount
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|thisns
operator|+
literal|1
operator|<
name|numnsaddr
operator|&&
operator|(
name|i
operator|==
name|SERVFAIL
operator|||
name|i
operator|==
name|NOTIMP
operator|||
name|i
operator|==
name|REFUSED
operator|)
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
operator|||
name|verbose
condition|)
name|printf
argument_list|(
literal|"Server failed, trying next server: %s\n"
argument_list|,
name|i
operator|!=
name|NOERROR
condition|?
name|DecodeError
argument_list|(
name|i
argument_list|)
else|:
literal|"Premature end of data"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
name|thisns
operator|++
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|printf
argument_list|(
literal|"Server failed: %s\n"
argument_list|,
name|i
operator|!=
name|NOERROR
condition|?
name|DecodeError
argument_list|(
name|i
argument_list|)
else|:
literal|"Premature end of data"
argument_list|)
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|printinfo
argument_list|(
operator|&
name|buf
argument_list|,
name|cp
argument_list|,
name|queryType
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
break|break;
block|}
name|numAnswers
operator|++
expr_stmt|;
name|cp
operator|=
name|buf
operator|.
name|qb2
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|buf
operator|.
name|qb1
operator|.
name|qdcount
argument_list|)
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|buf
operator|.
name|qb2
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
block|}
name|nmp
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|buf
operator|.
name|qb2
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|INT16SZ
operator|>
name|buf
operator|.
name|qb2
operator|+
name|len
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|ns_get16
argument_list|(
name|cp
argument_list|)
operator|==
name|ns_t_soa
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|dn_expand
argument_list|(
name|buf
operator|.
name|qb2
argument_list|,
name|buf
operator|.
name|qb2
operator|+
name|len
argument_list|,
name|nmp
argument_list|,
name|dname
index|[
name|soacnt
index|]
argument_list|,
sizeof|sizeof
name|dname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|soacnt
condition|)
block|{
if|if
condition|(
name|ns_samename
argument_list|(
name|dname
index|[
literal|0
index|]
argument_list|,
name|dname
index|[
literal|1
index|]
argument_list|)
operator|==
literal|1
condition|)
break|break;
block|}
else|else
name|soacnt
operator|++
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NO_ERRORS
case|:
return|return
operator|(
name|SUCCESS
operator|)
return|;
case|case
name|ERR_READING_LEN
case|:
return|return
operator|(
name|ERROR
operator|)
return|;
case|case
name|ERR_PRINTING
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Error during listing of %s: %s\n"
argument_list|,
name|namePtr
argument_list|,
name|DecodeError
argument_list|(
name|result
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
case|case
name|ERR_READING_MSG
case|:
name|headerPtr
operator|=
operator|(
name|HEADER
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ListHosts: error receiving zone transfer:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  result: %s, answers = %d, authority = %d, additional = %d\n"
argument_list|,
name|p_rcode
argument_list|(
name|headerPtr
operator|->
name|rcode
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|ancount
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|nscount
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|arcount
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
default|default:
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|DecodeError
parameter_list|(
name|int
name|result
parameter_list|)
block|{
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|NOERROR
case|:
return|return
operator|(
literal|"Success"
operator|)
return|;
case|case
name|FORMERR
case|:
return|return
operator|(
literal|"Format error"
operator|)
return|;
case|case
name|SERVFAIL
case|:
return|return
operator|(
literal|"Server failed"
operator|)
return|;
case|case
name|NXDOMAIN
case|:
return|return
operator|(
literal|"Non-existent domain"
operator|)
return|;
case|case
name|NOTIMP
case|:
return|return
operator|(
literal|"Not implemented"
operator|)
return|;
case|case
name|REFUSED
case|:
return|return
operator|(
literal|"Query refused"
operator|)
return|;
case|case
name|NO_INFO
case|:
return|return
operator|(
literal|"No information"
operator|)
return|;
case|case
name|ERROR
case|:
return|return
operator|(
literal|"Unspecified error"
operator|)
return|;
case|case
name|TIME_OUT
case|:
return|return
operator|(
literal|"Timed out"
operator|)
return|;
case|case
name|NONAUTH
case|:
return|return
operator|(
literal|"Non-authoritative answer"
operator|)
return|;
default|default:
return|return
operator|(
literal|"BAD ERROR VALUE"
operator|)
return|;
block|}
comment|/* NOTREACHED */
block|}
end_function

end_unit

