begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: dig.c,v 8.46 2001/04/01 17:35:01 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Copyright (c) 1989  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-1999 by Internet Software Consortium  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*********************** Notes for the BIND 4.9 release (Paul Vixie, DEC)  *	dig 2.0 was written by copying sections of libresolv.a and nslookup  *	and modifying them to be more useful for a general lookup utility.  *	as of BIND 4.9, the changes needed to support dig have mostly been  *	incorporated into libresolv.a and nslookup; dig now links against  *	some of nslookup's .o files rather than #including them or maintaining  *	local copies of them.  *  *	while merging dig back into the BIND release, i made a number of  *	structural changes.  for one thing, i put all of dig's private  *	library routines into this file rather than maintaining them in  *	separate, #included, files.  i don't like to #include ".c" files.  *	i removed all calls to "bcopy", replacing them with structure  *	assignments.  i removed all "extern"'s of standard functions,  *	replacing them with #include's of standard header files.  this  *	version of dig is probably as portable as the rest of BIND.  *  *	i had to remove the query-time and packet-count statistics since  *	the current libresolv.a is a lot harder to modify to maintain these  *	than the 4.8 one (used in the original dig) was.  for consolation,  *	i added a "usage" message with extensive help text.  *  *	to save my (limited, albeit) sanity, i ran "indent" over the source.  *	i also added the standard berkeley/DEC copyrights, since this file now  *	contains a fair amount of non-USC code.  note that the berkeley and  *	DEC copyrights do not prohibit redistribution, with or without fee;  *	we add them only to protect ourselves (you have to claim copyright  *	in order to disclaim liability and warranty).  *  *	Paul Vixie, Palo Alto, CA, April 1993  ****************************************************************************   ******************************************************************  *      DiG -- Domain Information Groper                          *  *                                                                *  *        dig.c - Version 2.1 (7/12/94) ("BIND takeover")         *  *                                                                *  *        Developed by: Steve Hotz& Paul Mockapetris             *  *        USC Information Sciences Institute (USC-ISI)            *  *        Marina del Rey, California                              *  *        1989                                                    *  *                                                                *  *        dig.c -                                                 *  *           Version 2.0 (9/1/90)                                 *  *               o renamed difftime() difftv() to avoid           *  *                 clash with ANSI C                              *  *               o fixed incorrect # args to strcmp,gettimeofday  *  *               o incorrect length specified to strncmp          *  *               o fixed broken -sticky -envsa -envset functions  *  *               o print options/flags redefined& modified       *  *                                                                *  *           Version 2.0.beta (5/9/90)                            *  *               o output format - helpful to `doc`               *  *               o minor cleanup                                  *  *               o release to beta testers                        *  *                                                                *  *           Version 1.1.beta (10/26/89)                          *  *               o hanging zone transer (when REFUSED) fixed      *  *               o trailing dot added to domain names in RDATA    *  *               o ISI internal                                   *  *                                                                *  *           Version 1.0.tmp  (8/27/89)                           *  *               o Error in prnttime() fixed                      *  *               o no longer dumps core on large pkts             *  *               o zone transfer (axfr) added                     *  *               o -x added for inverse queries                   *  *                               (i.e. "dig -x 128.9.0.32")       *  *               o give address of default server                 *  *               o accept broadcast to server @255.255.255.255    *  *                                                                *  *           Version 1.0  (3/27/89)                               *  *               o original release                               *  *                                                                *  *     DiG is Public Domain, and may be used for any purpose as   *  *     long as this notice is not removed.                        *  ******************************************************************/
end_comment

begin_comment
comment|/* Import. */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_include
include|#
directive|include
file|"../nslookup/res.h"
end_include

begin_comment
comment|/* Global. */
end_comment

begin_define
define|#
directive|define
name|VERSION
value|83
end_define

begin_define
define|#
directive|define
name|VSTRING
value|"8.3"
end_define

begin_define
define|#
directive|define
name|PRF_DEF
value|0x2ff9
end_define

begin_define
define|#
directive|define
name|PRF_MIN
value|0xA930
end_define

begin_define
define|#
directive|define
name|PRF_ZONE
value|0x24f9
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|SAVEENV
value|"DiG.env"
end_define

begin_define
define|#
directive|define
name|DIG_MAXARGS
value|30
end_define

begin_decl_stmt
specifier|static
name|int
name|eecode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|qfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|defsrv
decl_stmt|,
modifier|*
name|srvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|defbuf
index|[
literal|40
index|]
init|=
literal|"default -- "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|srvbuf
index|[
literal|60
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|myhostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|sockaddr_in
name|myaddress
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|u_int32_t
name|ixfr_serial
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* stuff for nslookup modules */
end_comment

begin_decl_stmt
name|struct
name|__res_state
name|res
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|filePtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HostInfo
modifier|*
name|defaultPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HostInfo
name|curHostInfo
decl_stmt|,
name|defaultRec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curHostValid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|queryType
decl_stmt|,
name|queryClass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|StringToClass
argument_list|()
decl_stmt|,
name|StringToType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subr.c */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
name|BSD
operator|>=
literal|199006
operator|&&
operator|!
name|defined
argument_list|(
name|RISCOS_BSD
argument_list|)
end_if

begin_decl_stmt
name|FILE
modifier|*
name|yyin
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|yyrestart
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|pager
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of nslookup stuff */
end_comment

begin_comment
comment|/* Forward. */
end_comment

begin_function_decl
specifier|static
name|void
name|Usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|setopt
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|res_re_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|xstrtonum
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|printZone
parameter_list|(
name|ns_type
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
parameter_list|,
name|ns_tsig_key
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|print_axfr
parameter_list|(
name|FILE
modifier|*
name|output
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|struct
name|timeval
name|difftv
parameter_list|(
name|struct
name|timeval
parameter_list|,
name|struct
name|timeval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prnttime
parameter_list|(
name|struct
name|timeval
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stackarg
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Public. */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|short
name|port
init|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
decl_stmt|;
comment|/* Wierd stuff for SPARC alignment, hurts nothing else. */
union|union
block|{
name|HEADER
name|header_
decl_stmt|;
name|u_char
name|packet_
index|[
name|PACKETSZ
index|]
decl_stmt|;
block|}
name|packet_
union|;
define|#
directive|define
name|header
value|(packet_.header_)
define|#
directive|define
name|packet
value|(packet_.packet_)
name|u_char
name|answer
index|[
literal|64
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|doping
index|[
literal|90
index|]
decl_stmt|;
name|char
name|pingstr
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|afile
decl_stmt|;
name|char
modifier|*
name|addrc
decl_stmt|,
modifier|*
name|addrend
decl_stmt|,
modifier|*
name|addrbegin
decl_stmt|;
name|time_t
name|exectime
decl_stmt|;
name|struct
name|timeval
name|tv1
decl_stmt|,
name|tv2
decl_stmt|,
name|start_time
decl_stmt|,
name|end_time
decl_stmt|,
name|query_time
decl_stmt|;
name|char
modifier|*
name|srv
decl_stmt|;
name|int
name|anyflag
init|=
literal|0
decl_stmt|;
name|int
name|sticky
init|=
literal|0
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|qtypeSet
decl_stmt|;
name|int
name|addrflag
init|=
literal|0
decl_stmt|;
name|ns_type
name|xfr
init|=
name|ns_t_invalid
decl_stmt|;
name|int
name|bytes_out
decl_stmt|,
name|bytes_in
decl_stmt|;
name|char
name|cmd
index|[
literal|512
index|]
decl_stmt|;
name|char
name|domain
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|msg
index|[
literal|120
index|]
decl_stmt|,
modifier|*
modifier|*
name|vtmp
decl_stmt|;
name|char
modifier|*
name|args
index|[
name|DIG_MAXARGS
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|ax
decl_stmt|;
name|int
name|once
init|=
literal|1
decl_stmt|,
name|dofile
init|=
literal|0
decl_stmt|;
comment|/* batch -vs- interactive control */
name|char
name|fileq
index|[
literal|384
index|]
decl_stmt|;
name|int
name|fp
decl_stmt|;
name|int
name|wait
init|=
literal|0
decl_stmt|,
name|delay
decl_stmt|;
name|int
name|envset
init|=
literal|0
decl_stmt|,
name|envsave
init|=
literal|0
decl_stmt|;
name|struct
name|__res_state
name|res_x
decl_stmt|,
name|res_t
decl_stmt|;
name|ns_tsig_key
name|key
decl_stmt|;
name|char
modifier|*
name|keyfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|keyname
init|=
name|NULL
decl_stmt|;
name|res_ninit
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|res
operator|.
name|pfcode
operator|=
name|PRF_DEF
expr_stmt|;
name|qtypeSet
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|domain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|domain
argument_list|)
expr_stmt|;
name|gethostname
argument_list|(
name|myhostname
argument_list|,
operator|(
sizeof|sizeof
name|myhostname
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|HAVE_SA_LEN
name|myaddress
operator|.
name|sin_len
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr_in
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|myaddress
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|myaddress
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|myaddress
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/*INPORT_ANY*/
empty_stmt|;
name|defsrv
operator|=
name|strcat
argument_list|(
name|defbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|res_x
operator|=
name|res
expr_stmt|;
comment|/*  * If LOCALDEF in environment, should point to file  * containing local favourite defaults.  Also look for file  * DiG.env (i.e. SAVEENV) in local directory.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|afile
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"LOCALDEF"
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|afile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|SAVEENV
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|read
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|res_x
argument_list|,
operator|(
sizeof|sizeof
name|res_x
operator|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|res
operator|=
name|res_x
expr_stmt|;
block|}
comment|/*  * Check for batch-mode DiG; also pre-scan for 'help'.  */
name|vtmp
operator|=
name|argv
expr_stmt|;
name|ax
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|vtmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-usage"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dofile
operator|++
expr_stmt|;
name|once
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|qfp
operator|=
name|fopen
argument_list|(
operator|*
operator|++
name|vtmp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"file open"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ax
operator|-
name|args
operator|==
name|DIG_MAXARGS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dig: too many arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
operator|*
name|ax
operator|++
operator|=
operator|*
name|vtmp
expr_stmt|;
block|}
name|vtmp
operator|++
expr_stmt|;
block|}
name|res
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  * Main section: once if cmd-line query  *               while !EOF if batch mode  */
operator|*
name|fileq
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|dofile
operator|&&
name|fgets
argument_list|(
name|fileq
argument_list|,
sizeof|sizeof
name|fileq
argument_list|,
name|qfp
argument_list|)
operator|!=
name|NULL
operator|)
operator|||
operator|(
operator|!
name|dofile
operator|&&
name|once
operator|--
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|fileq
operator|==
literal|'\n'
operator|||
operator|*
name|fileq
operator|==
literal|'#'
operator|||
operator|*
name|fileq
operator|==
literal|';'
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|fileq
argument_list|)
expr_stmt|;
comment|/* echo but otherwise ignore */
continue|continue;
comment|/* blank lines and comments  */
block|}
comment|/*  * "Sticky" requests that before current parsing args  * return to current "working" environment (X******).  */
if|if
condition|(
name|sticky
condition|)
block|{
name|printf
argument_list|(
literal|";; (using sticky settings)\n"
argument_list|)
expr_stmt|;
name|res
operator|=
name|res_x
expr_stmt|;
block|}
comment|/*  * Concat cmd-line and file args.  */
name|stackarg
argument_list|(
name|fileq
argument_list|,
name|ax
argument_list|)
expr_stmt|;
comment|/* defaults */
name|queryType
operator|=
name|ns_t_ns
expr_stmt|;
name|queryClass
operator|=
name|ns_c_in
expr_stmt|;
name|xfr
operator|=
name|ns_t_invalid
expr_stmt|;
operator|*
name|pingstr
operator|=
literal|0
expr_stmt|;
name|srv
operator|=
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"\n;<<>> DiG %s<<>> "
argument_list|,
name|VSTRING
argument_list|)
expr_stmt|;
name|argv
operator|=
name|args
expr_stmt|;
name|argc
operator|=
name|ax
operator|-
name|args
expr_stmt|;
comment|/*  * More cmd-line options than anyone should ever have to  * deal with ....  */
while|while
condition|(
operator|*
operator|(
operator|++
name|argv
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|argv
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|cmd
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'@'
condition|)
block|{
name|srv
operator|=
operator|(
operator|*
name|argv
operator|+
literal|1
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'%'
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'+'
condition|)
block|{
name|setopt
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'='
condition|)
block|{
name|ixfr_serial
operator|=
name|strtoul
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-nost"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sticky
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-st"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sticky
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-envsa"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|envsave
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-envse"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|envset
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'T'
case|:
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"; no arg for -T?\n"
argument_list|)
expr_stmt|;
else|else
name|wait
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"; no arg for -c?\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
name|queryClass
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|StringToClass
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|queryClass
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"; invalid class specified\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"; no arg for -t?\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
operator|)
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
name|queryType
operator|=
name|tmp
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|StringToType
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|queryType
operator|=
name|tmp
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"; invalid type specified\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|qtypeSet
condition|)
block|{
name|queryType
operator|=
name|T_ANY
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|addrc
operator|=
operator|*
operator|++
name|argv
operator|)
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"; no arg for -x?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|addrend
operator|=
name|addrc
operator|+
name|strlen
argument_list|(
name|addrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|addrend
operator|==
literal|'.'
condition|)
operator|*
name|addrend
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|domain
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|addrbegin
operator|=
name|strrchr
argument_list|(
name|addrc
argument_list|,
literal|'.'
argument_list|)
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|domain
argument_list|,
name|addrbegin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|*
name|addrbegin
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcat
argument_list|(
name|domain
argument_list|,
name|addrc
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|domain
argument_list|,
literal|".in-addr.arpa."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|port
operator|=
name|ntohs
argument_list|(
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"; no arg for -p?\n"
argument_list|)
expr_stmt|;
else|else
name|port
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|pingstr
argument_list|,
name|argv
index|[
literal|0
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|pingstr
argument_list|,
literal|"ping -s"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|res
operator|.
name|ndots
operator|=
name|atoi
argument_list|(
name|argv
index|[
literal|0
index|]
operator|+
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
name|printf
argument_list|(
literal|"; no arg for -n?\n"
argument_list|)
expr_stmt|;
else|else
name|res
operator|.
name|ndots
operator|=
name|atoi
argument_list|(
operator|*
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
block|{
name|char
modifier|*
name|a
decl_stmt|,
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|a
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"; no arg for -b?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|a
operator|=
operator|*
name|argv
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|strchr
argument_list|(
name|a
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|myaddress
operator|.
name|sin_port
operator|=
name|ntohs
argument_list|(
name|atoi
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|a
argument_list|,
operator|&
name|myaddress
operator|.
name|sin_addr
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; bad -b addr\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'k'
case|:
comment|/* -k keydir:keyname */
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|keyfile
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
operator|++
name|argv
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"; no arg for -k?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|keyfile
operator|=
operator|*
name|argv
expr_stmt|;
name|keyname
operator|=
name|strchr
argument_list|(
name|keyfile
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyname
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"key option argument should be keydir:keyname\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|*
name|keyname
operator|++
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
comment|/* switch - */
continue|continue;
block|}
comment|/* if '-'   */
if|if
condition|(
operator|(
name|tmp
operator|=
name|StringToType
argument_list|(
operator|*
name|argv
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|T_ANY
operator|==
name|tmp
operator|)
operator|&&
name|anyflag
operator|++
condition|)
block|{
name|queryClass
operator|=
name|C_ANY
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ns_t_xfr_p
argument_list|(
name|tmp
argument_list|)
operator|&&
operator|(
name|tmp
operator|==
name|ns_t_axfr
operator|||
operator|(
name|res
operator|.
name|options
operator|&
name|RES_USEVC
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|res
operator|.
name|pfcode
operator|=
name|PRF_ZONE
expr_stmt|;
name|xfr
operator|=
operator|(
name|ns_type
operator|)
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|queryType
operator|=
name|tmp
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|StringToClass
argument_list|(
operator|*
name|argv
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|queryClass
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|memset
argument_list|(
name|domain
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|domain
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|domain
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while argv remains */
comment|/* process key options */
if|if
condition|(
name|keyfile
condition|)
block|{
ifdef|#
directive|ifdef
name|PARSE_KEYFILE
name|int
name|i
decl_stmt|,
name|n1
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|;
name|int
name|file_major
decl_stmt|,
name|file_minor
decl_stmt|,
name|alg
decl_stmt|;
name|fp
operator|=
name|fopen
argument_list|(
name|keyfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|keyfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now read the header info from the file. */
name|i
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|BUFSIZ
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|5
condition|)
block|{
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* get length of strings */
name|n1
operator|=
name|strlen
argument_list|(
literal|"Private-key-format: v"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|>
name|n
operator|||
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"Private-key-format: v"
argument_list|,
name|n1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key file format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* not a match */
block|}
name|p
operator|+=
name|n1
expr_stmt|;
comment|/* advance pointer */
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"%d.%d"
argument_list|,
operator|&
name|file_major
argument_list|,
operator|&
name|file_minor
argument_list|)
expr_stmt|;
comment|/* should do some error checking with these someday */
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip to end of line */
name|n
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* get length of strings */
name|n1
operator|=
name|strlen
argument_list|(
literal|"Algorithm: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|>
name|n
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Algorithm: "
argument_list|,
name|n1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key file format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* not a match */
block|}
name|p
operator|+=
name|n1
expr_stmt|;
comment|/* advance pointer */
if|if
condition|(
name|sscanf
argument_list|(
operator|(
name|char
operator|*
operator|)
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|alg
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key file format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip to end of line */
name|n
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* get length of strings */
name|n1
operator|=
name|strlen
argument_list|(
literal|"Key: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|n1
operator|>
name|n
operator|||
name|strncmp
argument_list|(
name|p
argument_list|,
literal|"Key: "
argument_list|,
name|n1
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Invalid key file format\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* not a match */
block|}
name|p
operator|+=
name|n1
expr_stmt|;
comment|/* advance pointer */
name|pp
operator|=
name|p
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
comment|/* skip to end of line, 						 * terminate it */
operator|*
operator|--
name|pp
operator|=
literal|'\0'
expr_stmt|;
name|key
operator|.
name|data
operator|=
name|malloc
argument_list|(
literal|1024
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|len
operator|=
name|b64_pton
argument_list|(
name|p
argument_list|,
name|key
operator|.
name|data
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|key
operator|.
name|name
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|key
operator|.
name|alg
argument_list|,
literal|"HMAC-MD5.SIG-ALG.REG.INT"
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* use the dst* routines to parse the key files 			 *  			 * This requires that both the .key and the .private 			 * files exist in your cwd, so the keyfile parmeter 			 * here is assumed to be a path in which the 			 * K*.{key,private} files exist. 			 */
name|DST_KEY
modifier|*
name|dst_key
decl_stmt|;
name|char
name|cwd
index|[
name|PATH_MAX
operator|+
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|getcwd
argument_list|(
name|cwd
argument_list|,
name|PATH_MAX
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"unable to get current directory"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir
argument_list|(
name|keyfile
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to chdir to %s: %s\n"
argument_list|,
name|keyfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|dst_init
argument_list|()
expr_stmt|;
name|dst_key
operator|=
name|dst_read_key
argument_list|(
name|keyname
argument_list|,
literal|0
comment|/* not used for priv keys */
argument_list|,
name|KEY_HMAC_MD5
argument_list|,
name|DST_PRIVATE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dst_key
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dst_read_key: error reading key\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|key
operator|.
name|data
operator|=
name|malloc
argument_list|(
literal|1024
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|dst_key_to_buffer
argument_list|(
name|dst_key
argument_list|,
name|key
operator|.
name|data
argument_list|,
literal|1024
argument_list|)
expr_stmt|;
name|key
operator|.
name|len
operator|=
name|dst_key
operator|->
name|dk_key_size
expr_stmt|;
name|strcpy
argument_list|(
name|key
operator|.
name|name
argument_list|,
name|keyname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|key
operator|.
name|alg
argument_list|,
literal|"HMAC-MD5.SIG-ALG.REG.INT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|cwd
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"unable to chdir to %s: %s\n"
argument_list|,
name|cwd
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|res
operator|.
name|pfcode
operator|&
literal|0x80000
condition|)
name|printf
argument_list|(
literal|"; pfcode: %08lx, options: %08lx\n"
argument_list|,
name|res
operator|.
name|pfcode
argument_list|,
name|res
operator|.
name|options
argument_list|)
expr_stmt|;
comment|/*  * Current env. (after this parse) is to become the  * new "working" environmnet. Used in conj. with sticky.  */
if|if
condition|(
name|envset
condition|)
block|{
name|res_x
operator|=
name|res
expr_stmt|;
name|envset
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Current env. (after this parse) is to become the  * new default saved environmnet. Save in user specified  * file if exists else is SAVEENV (== "DiG.env").  */
if|if
condition|(
name|envsave
condition|)
block|{
name|afile
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"LOCALDEF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|afile
operator|&&
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|afile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|S_IREAD
operator||
name|S_IWRITE
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|SAVEENV
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|S_IREAD
operator||
name|S_IWRITE
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|write
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|res
argument_list|,
operator|(
sizeof|sizeof
name|res
operator|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|envsave
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|res
operator|.
name|pfcode
operator|&
name|RES_PRF_CMD
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|addrflag
operator|=
name|anyflag
operator|=
literal|0
expr_stmt|;
comment|/*  * Find address of server to query. If not dot-notation, then  * try to resolve domain-name (if so, save and turn off print   * options, this domain-query is not the one we want. Restore  * user options when done.  * Things get a bit wierd since we need to use resolver to be  * able to "put the resolver to work".  */
name|srvbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|srvmsg
operator|=
name|defsrv
expr_stmt|;
if|if
condition|(
name|srv
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|srv
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
name|res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|=
name|addr
expr_stmt|;
name|srvmsg
operator|=
name|strcat
argument_list|(
name|srvbuf
argument_list|,
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res_t
operator|=
name|res
expr_stmt|;
name|res_ninit
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|res
operator|.
name|pfcode
operator|=
literal|0
expr_stmt|;
name|res
operator|.
name|options
operator|=
name|RES_DEFAULT
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|srv
argument_list|)
expr_stmt|;
name|res
operator|=
name|res_t
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
operator|||
name|hp
operator|->
name|h_addr_list
operator|==
name|NULL
operator|||
operator|*
name|hp
operator|->
name|h_addr_list
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; Bad server: %s -- using default server and timer opts\n"
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|srvmsg
operator|=
name|defsrv
expr_stmt|;
name|srv
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
modifier|*
modifier|*
name|addr
decl_stmt|;
name|res
operator|.
name|nscount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr
operator|=
operator|(
name|u_int32_t
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|addr
operator|&&
operator|(
name|res
operator|.
name|nscount
operator|<
name|MAXNS
operator|)
condition|;
name|addr
operator|++
control|)
block|{
name|res
operator|.
name|nsaddr_list
index|[
name|res
operator|.
name|nscount
operator|++
index|]
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|*
name|addr
expr_stmt|;
block|}
name|srvmsg
operator|=
name|strcat
argument_list|(
name|srvbuf
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|srvbuf
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|srvmsg
argument_list|,
name|inet_ntoa
argument_list|(
name|res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"; (%d server%s found)\n"
argument_list|,
name|res
operator|.
name|nscount
argument_list|,
operator|(
name|res
operator|.
name|nscount
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|res
operator|.
name|id
operator|+=
name|res
operator|.
name|retry
expr_stmt|;
block|}
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
block|{
name|res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
name|res
operator|.
name|id
operator|+=
name|res
operator|.
name|retry
expr_stmt|;
block|}
if|if
condition|(
name|ns_t_xfr_p
argument_list|(
name|xfr
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
decl_stmt|;
if|if
condition|(
name|keyfile
condition|)
name|x
operator|=
name|printZone
argument_list|(
name|xfr
argument_list|,
name|domain
argument_list|,
operator|&
name|res
operator|.
name|nsaddr_list
index|[
name|i
index|]
argument_list|,
operator|&
name|key
argument_list|)
expr_stmt|;
else|else
name|x
operator|=
name|printZone
argument_list|(
name|xfr
argument_list|,
name|domain
argument_list|,
operator|&
name|res
operator|.
name|nsaddr_list
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pfcode
operator|&
name|RES_PRF_STATS
condition|)
block|{
name|exectime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; FROM: %s to SERVER: %s\n"
argument_list|,
name|myhostname
argument_list|,
name|inet_ntoa
argument_list|(
name|res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; WHEN: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|exectime
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|x
condition|)
break|break;
comment|/* success */
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|domain
operator|&&
operator|!
name|qtypeSet
condition|)
block|{
name|queryType
operator|=
name|T_A
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
name|bytes_out
operator|=
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|domain
argument_list|,
name|queryClass
argument_list|,
name|queryType
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|packet
argument_list|,
sizeof|sizeof
name|packet
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; res_nmkquery: buffer too small\n\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|queryType
operator|==
name|T_IXFR
condition|)
block|{
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|packet
decl_stmt|;
name|u_char
modifier|*
name|cpp
init|=
name|packet
operator|+
name|bytes_out
decl_stmt|;
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|1
operator|+
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
name|domain
argument_list|,
name|cpp
argument_list|,
operator|(
sizeof|sizeof
name|packet
operator|)
operator|-
operator|(
name|cpp
operator|-
name|packet
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cpp
operator|+=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
name|T_SOA
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* type */
name|PUTSHORT
argument_list|(
name|C_IN
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* class */
name|PUTLONG
argument_list|(
literal|0
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* ttl */
name|PUTSHORT
argument_list|(
literal|22
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* dlen */
operator|*
name|cpp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* mname */
operator|*
name|cpp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* rname */
name|PUTLONG
argument_list|(
name|ixfr_serial
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
literal|0xDEAD
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Refresh */
name|PUTLONG
argument_list|(
literal|0xBEEF
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Retry */
name|PUTLONG
argument_list|(
literal|0xABCD
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Expire */
name|PUTLONG
argument_list|(
literal|0x1776
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Min TTL */
name|bytes_out
operator|=
name|n
operator|=
name|cpp
operator|-
name|packet
expr_stmt|;
block|}
empty_stmt|;
name|eecode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pfcode
operator|&
name|RES_PRF_HEAD1
condition|)
name|fp_resstat
argument_list|(
operator|&
name|res
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|keyfile
condition|)
name|n
operator|=
name|res_nsendsigned
argument_list|(
operator|&
name|res
argument_list|,
name|packet
argument_list|,
name|n
argument_list|,
operator|&
name|key
argument_list|,
name|answer
argument_list|,
sizeof|sizeof
name|answer
argument_list|)
expr_stmt|;
else|else
name|n
operator|=
name|res_nsend
argument_list|(
operator|&
name|res
argument_list|,
name|packet
argument_list|,
name|n
argument_list|,
name|answer
argument_list|,
sizeof|sizeof
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bytes_in
operator|=
name|n
operator|)
operator|<
literal|0
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
operator|-
name|n
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|keyfile
condition|)
name|strcat
argument_list|(
name|msg
argument_list|,
literal|";; res_nsendsigned to server "
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|msg
argument_list|,
literal|";; res_nsend to server "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|srvmsg
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dofile
condition|)
block|{
if|if
condition|(
name|eecode
condition|)
name|exit
argument_list|(
name|eecode
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|end_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|.
name|pfcode
operator|&
name|RES_PRF_STATS
condition|)
block|{
name|query_time
operator|=
name|difftv
argument_list|(
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; Total query time: "
argument_list|)
expr_stmt|;
name|prnttime
argument_list|(
name|query_time
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exectime
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; FROM: %s to SERVER: %s\n"
argument_list|,
name|myhostname
argument_list|,
name|srvmsg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; WHEN: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
name|exectime
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; MSG SIZE  sent: %d  rcvd: %d\n"
argument_list|,
name|bytes_out
argument_list|,
name|bytes_in
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/*  *   Argh ... not particularly elegant. Should put in *real* ping code.  *   Would necessitate root priviledges for icmp port though!  */
if|if
condition|(
operator|*
name|pingstr
condition|)
block|{
name|sprintf
argument_list|(
name|doping
argument_list|,
literal|"%s %s 56 3 | tail -3"
argument_list|,
name|pingstr
argument_list|,
operator|(
name|srv
operator|==
name|NULL
operator|)
condition|?
operator|(
name|defsrv
operator|+
literal|10
operator|)
else|:
name|srv
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|doping
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/*  * Fairly crude method and low overhead method of keeping two  * batches started at different sites somewhat synchronized.  */
name|gettimeofday
argument_list|(
operator|&
name|tv2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delay
operator|=
call|(
name|int
call|)
argument_list|(
name|tv2
operator|.
name|tv_sec
operator|-
name|tv1
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
name|wait
condition|)
block|{
name|sleep
argument_list|(
name|wait
operator|-
name|delay
argument_list|)
expr_stmt|;
block|}
name|tv1
operator|=
name|tv2
expr_stmt|;
block|}
return|return
operator|(
name|eecode
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Private. */
end_comment

begin_function
specifier|static
name|void
name|Usage
parameter_list|()
block|{
name|fputs
argument_list|(
literal|"\ usage:  dig [@server] [domain] [q-type] [q-class] {q-opt} {d-opt} [%comment]\n\ where:	server,\n\ 	domain	are names in the Domain Name System\n\ 	q-class	is one of (in,any,...) [default: in]\n\ 	q-type	is one of (a,any,mx,ns,soa,hinfo,axfr,txt,...) [default: a]\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ 	q-opt	is one of:\n\ 		-x dot-notation-address	(shortcut to in-addr.arpa lookups)\n\ 		-f file			(batch mode input file name)\n\ 		-T time			(batch mode time delay, per query)\n\ 		-p port			(nameserver is on this port) [53]\n\ 		-b addr[:port]		(bind to this tcp address) [*]\n\ 		-P[ping-string]		(see man page)\n\ 		-t query-type		(synonym for q-type)\n\ 		-c query-class		(synonym for q-class)\n\ 		-k keydir:keyname	(sign the query with this TSIG key)\n\ 		-envsav,-envset		(see man page)\n\ 		-[no]stick		(see man page)\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ 	d-opt	is of the form ``+keyword=value'' where keyword is one of:\n\ 		[no]debug [no]d2 [no]recurse retry=# time=# [no]ko [no]vc\n\ 		[no]defname [no]search domain=NAME [no]ignore [no]primary\n\ 		[no]aaonly [no]cmd [no]stats [no]Header [no]header\n\ 		[no]ttlid [no]cl [no]qr [no]reply [no]ques [no]answer\n\ 		[no]author [no]addit pfdef pfmin pfset=# pfand=# pfor=#\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ notes:	defname and search don't work; use fully-qualified names.\n\ 	this is DiG version "
name|VSTRING
literal|"\n\ 	$Id: dig.c,v 8.46 2001/04/01 17:35:01 vixie Exp $\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|setopt
parameter_list|(
specifier|const
name|char
modifier|*
name|string
parameter_list|)
block|{
name|char
name|option
index|[
name|NAME_LEN
index|]
decl_stmt|,
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|pickString
argument_list|(
name|string
argument_list|,
name|option
argument_list|,
sizeof|sizeof
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";*** Invalid option: %s\n"
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* this is ugly, but fixing the caller to behave 		   properly with an error return value would require a major 		   cleanup. */
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"aa"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* aaonly */
name|res
operator|.
name|options
operator||=
name|RES_AAONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noaa"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_AAONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"deb"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* debug */
name|res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodeb"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ko"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* keepopen */
name|res
operator|.
name|options
operator||=
operator|(
name|RES_STAYOPEN
operator||
name|RES_USEVC
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noko"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_STAYOPEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"d2"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* d2 (more debug) */
name|res
operator|.
name|options
operator||=
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nod2"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"def"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* defname */
name|res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"sea"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* search list */
name|res
operator|.
name|options
operator||=
name|RES_DNSRCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nosea"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_DNSRCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"do"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* domain */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|i
operator|=
name|pickString
argument_list|(
operator|++
name|ptr
argument_list|,
name|res
operator|.
name|defdname
argument_list|,
sizeof|sizeof
name|res
operator|.
name|defdname
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* value's too long or non-existant. This actually 					 shouldn't happen due to pickString() 					 above */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"*** Invalid domain: %s\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
comment|/* see comment at previous call to exit()*/
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ti"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* timeout */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|res
operator|.
name|retrans
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ret"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* retry */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|res
operator|.
name|retry
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"i"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ignore */
name|res
operator|.
name|options
operator||=
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noi"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* primary */
name|res
operator|.
name|options
operator||=
name|RES_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nop"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"rec"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* recurse */
name|res
operator|.
name|options
operator||=
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"norec"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"v"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* vc */
name|res
operator|.
name|options
operator||=
name|RES_USEVC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nov"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|options
operator|&=
operator|~
name|RES_USEVC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfset"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|res
operator|.
name|pfcode
operator|=
name|xstrtonum
argument_list|(
operator|++
name|ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfand"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|res
operator|.
name|pfcode
operator|=
name|res
operator|.
name|pfcode
operator|&
name|xstrtonum
argument_list|(
operator|++
name|ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfor"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|res
operator|.
name|pfcode
operator||=
name|xstrtonum
argument_list|(
operator|++
name|ptr
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfmin"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|=
name|PRF_MIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfdef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|=
name|PRF_DEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"an"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* answer section */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_ANS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noan"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_ANS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"qu"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* question section */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_QUES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noqu"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_QUES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"au"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* authority section */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_AUTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noau"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_AUTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ad"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* addition section */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noad"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"tt"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* TTL& ID */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_TTLID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nott"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_TTLID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"he"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* head flags stats */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_HEAD2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nohe"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_HEAD2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"H"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* header all */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_HEADX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noH"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
operator|(
name|RES_PRF_HEADX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"qr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* query */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_QUERY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noqr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_QUERY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"rep"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* reply */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_REPLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"norep"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_REPLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"cm"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* command line */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_CMD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nocm"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_CMD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"cl"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* class mnemonic */
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_CLASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nocl"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_CLASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"st"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* stats*/
name|res
operator|.
name|pfcode
operator||=
name|RES_PRF_STATS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nost"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_STATS
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; *** Invalid option: %s\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|res_re_init
argument_list|()
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Force a reinitialization when the domain is changed.  */
end_comment

begin_function
specifier|static
name|void
name|res_re_init
parameter_list|()
block|{
specifier|static
name|char
name|localdomain
index|[]
init|=
literal|"LOCALDOMAIN"
decl_stmt|;
name|u_long
name|pfcode
init|=
name|res
operator|.
name|pfcode
decl_stmt|,
name|options
init|=
name|res
operator|.
name|options
decl_stmt|;
name|unsigned
name|ndots
init|=
name|res
operator|.
name|ndots
decl_stmt|;
name|int
name|retrans
init|=
name|res
operator|.
name|retrans
decl_stmt|,
name|retry
init|=
name|res
operator|.
name|retry
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* 	 * This is ugly but putenv() is more portable than setenv(). 	 */
name|buf
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
name|localdomain
operator|)
operator|+
name|strlen
argument_list|(
name|res
operator|.
name|defdname
argument_list|)
operator|+
literal|10
comment|/*fuzz*/
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|localdomain
argument_list|,
name|res
operator|.
name|defdname
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* keeps the argument, so we won't free it */
name|res_ninit
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|res
operator|.
name|pfcode
operator|=
name|pfcode
expr_stmt|;
name|res
operator|.
name|options
operator|=
name|options
expr_stmt|;
name|res
operator|.
name|ndots
operator|=
name|ndots
expr_stmt|;
name|res
operator|.
name|retrans
operator|=
name|retrans
expr_stmt|;
name|res
operator|.
name|retry
operator|=
name|retry
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * convert char string (decimal, octal, or hex) to integer  */
end_comment

begin_function
specifier|static
name|int
name|xstrtonum
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|v
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|b
init|=
literal|10
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|flag
operator|++
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
name|b
operator|=
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
condition|)
block|{
name|b
operator|=
literal|16
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|i
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|i
operator|=
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; *** Bad char in numeric string..ignored\n"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|b
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; *** Bad char in numeric string..ignored\n"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|v
operator|=
name|v
operator|*
name|b
operator|+
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|qb1
decl_stmt|;
name|u_char
name|qb2
index|[
name|PACKETSZ
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|printZone
parameter_list|(
name|ns_type
name|xfr
parameter_list|,
specifier|const
name|char
modifier|*
name|zone
parameter_list|,
specifier|const
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|,
name|ns_tsig_key
modifier|*
name|key
parameter_list|)
block|{
specifier|static
name|u_char
modifier|*
name|answer
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|answerLen
init|=
literal|0
decl_stmt|;
name|querybuf
name|buf
decl_stmt|;
name|int
name|msglen
decl_stmt|,
name|amtToRead
decl_stmt|,
name|numRead
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|,
name|sockFD
decl_stmt|,
name|len
decl_stmt|;
name|int
name|count
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|,
name|rlen
decl_stmt|,
name|done
decl_stmt|,
name|n
decl_stmt|;
name|int
name|numAnswers
init|=
literal|0
decl_stmt|,
name|numRecords
init|=
literal|0
decl_stmt|,
name|soacnt
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
name|tmp
index|[
name|NS_INT16SZ
index|]
decl_stmt|;
name|char
name|dname
index|[
literal|2
index|]
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
enum|enum
block|{
name|NO_ERRORS
block|,
name|ERR_READING_LEN
block|,
name|ERR_READING_MSG
block|,
name|ERR_PRINTING
block|}
name|error
init|=
name|NO_ERRORS
enum|;
name|pid_t
name|zpid
decl_stmt|;
name|u_char
modifier|*
name|newmsg
decl_stmt|;
name|int
name|newmsglen
decl_stmt|;
name|ns_tcp_tsig_state
name|tsig_state
decl_stmt|;
name|int
name|tsig_ret
decl_stmt|,
name|tsig_required
decl_stmt|,
name|tsig_present
decl_stmt|;
switch|switch
condition|(
name|xfr
condition|)
block|{
case|case
name|ns_t_axfr
case|:
case|case
name|ns_t_zxfr
case|:
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; %s - transfer type not supported\n"
argument_list|,
name|p_type
argument_list|(
name|xfr
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
comment|/* 	 *  Create a query packet for the requested zone name. 	 */
name|msglen
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|ns_o_query
argument_list|,
name|zone
argument_list|,
name|queryClass
argument_list|,
name|ns_t_axfr
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; res_nmkquery failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
comment|/* 	 * Sign the message if a key was sent 	 */
if|if
condition|(
name|key
operator|==
name|NULL
condition|)
block|{
name|newmsg
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
expr_stmt|;
name|newmsglen
operator|=
name|msglen
expr_stmt|;
block|}
else|else
block|{
name|DST_KEY
modifier|*
name|dstkey
decl_stmt|;
name|int
name|bufsize
decl_stmt|,
name|siglen
decl_stmt|;
name|u_char
name|sig
index|[
literal|64
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
comment|/* ns_sign() also calls dst_init(), but there is no harm 		 * doing it twice 		 */
name|dst_init
argument_list|()
expr_stmt|;
name|bufsize
operator|=
name|msglen
operator|+
literal|1024
expr_stmt|;
name|newmsg
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|newmsg
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|ENOMEM
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|memcpy
argument_list|(
name|newmsg
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|newmsglen
operator|=
name|msglen
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|key
operator|->
name|alg
argument_list|,
name|NS_TSIG_ALG_HMAC_MD5
argument_list|)
operator|!=
literal|0
condition|)
name|dstkey
operator|=
name|NULL
expr_stmt|;
else|else
name|dstkey
operator|=
name|dst_buffer_to_key
argument_list|(
name|key
operator|->
name|name
argument_list|,
name|KEY_HMAC_MD5
argument_list|,
name|NS_KEY_TYPE_AUTH_ONLY
argument_list|,
name|NS_KEY_PROT_ANY
argument_list|,
name|key
operator|->
name|data
argument_list|,
name|key
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstkey
operator|==
name|NULL
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
if|if
condition|(
name|key
condition|)
name|free
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
comment|/* newmsglen++; */
name|ret
operator|=
name|ns_sign
argument_list|(
name|newmsg
argument_list|,
operator|&
name|newmsglen
argument_list|,
name|bufsize
argument_list|,
name|NOERROR
argument_list|,
name|dstkey
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|key
condition|)
name|free
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|NS_TSIG_ERROR_NO_SPACE
condition|)
name|errno
operator|=
name|EMSGSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|ret
operator|==
operator|-
literal|1
condition|)
name|errno
operator|=
name|EINVAL
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|ns_verify_tcp_init
argument_list|(
name|dstkey
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
operator|&
name|tsig_state
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *  Set up a virtual circuit to the server. 	 */
if|if
condition|(
operator|(
name|sockFD
operator|=
name|socket
argument_list|(
name|sin
operator|->
name|sin_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|";; socket"
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
if|if
condition|(
name|bind
argument_list|(
name|sockFD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|myaddress
argument_list|,
sizeof|sizeof
name|myaddress
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; bind(%s:%u): %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|myaddress
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|myaddress
operator|.
name|sin_port
argument_list|)
argument_list|,
name|strerror
argument_list|(
name|e
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sockFD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
sizeof|sizeof
expr|*
name|sin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|";; connect"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
comment|/* 	 * Send length& message for zone transfer 	 */
name|ns_put16
argument_list|(
name|newmsglen
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tmp
argument_list|,
name|NS_INT16SZ
argument_list|)
operator|!=
name|NS_INT16SZ
operator|||
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
name|newmsg
argument_list|,
name|newmsglen
argument_list|)
operator|!=
name|newmsglen
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|key
condition|)
name|free
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|";; write"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
comment|/* 	 * If we're compressing, push a gzip into the pipeline. 	 */
if|if
condition|(
name|xfr
operator|==
name|ns_t_zxfr
condition|)
block|{
enum|enum
block|{
name|rd
init|=
literal|0
block|,
name|wr
init|=
literal|1
block|}
enum|;
name|int
name|z
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|z
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|key
condition|)
name|free
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|";; pipe"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
name|zpid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|zpid
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
if|if
condition|(
name|key
condition|)
name|free
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|";; fork"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zpid
operator|==
literal|0
condition|)
block|{
comment|/* Child. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|z
index|[
name|rd
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|sockFD
argument_list|,
name|STDIN_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|z
index|[
name|wr
index|]
argument_list|,
name|STDOUT_FILENO
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|z
index|[
name|wr
index|]
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"gzip"
argument_list|,
literal|"gzip"
argument_list|,
literal|"-d"
argument_list|,
literal|"-v"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|";; child: execlp(gunzip)"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Parent. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|z
index|[
name|wr
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|z
index|[
name|rd
index|]
argument_list|,
name|sockFD
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|z
index|[
name|rd
index|]
argument_list|)
expr_stmt|;
block|}
name|dname
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|done
operator|=
literal|0
init|;
operator|!
name|done
condition|;
operator|(
name|void
operator|)
name|NULL
control|)
block|{
comment|/* 		 * Read the length of the response. 		 */
name|cp
operator|=
name|tmp
expr_stmt|;
name|amtToRead
operator|=
name|INT16SZ
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_LEN
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|ns_get16
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
break|break;
comment|/* nothing left to read */
comment|/* 		 * The server sent too much data to fit the existing buffer -- 		 * allocate a new one. 		 */
if|if
condition|(
name|len
operator|>
name|answerLen
condition|)
block|{
if|if
condition|(
name|answerLen
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|answer
argument_list|)
expr_stmt|;
name|answerLen
operator|=
name|len
expr_stmt|;
name|answer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Malloc
argument_list|(
name|answerLen
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Read the response. 		 */
name|amtToRead
operator|=
name|len
expr_stmt|;
name|cp
operator|=
name|answer
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_MSG
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|print_axfr
argument_list|(
name|stdout
argument_list|,
name|answer
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
break|break;
block|}
name|numRecords
operator|+=
name|htons
argument_list|(
operator|(
operator|(
name|HEADER
operator|*
operator|)
name|answer
operator|)
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|numAnswers
operator|++
expr_stmt|;
comment|/* Header. */
name|cp
operator|=
name|answer
operator|+
name|HFIXEDSZ
expr_stmt|;
comment|/* Question. */
for|for
control|(
name|count
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
name|HEADER
operator|*
operator|)
name|answer
operator|)
operator|->
name|qdcount
argument_list|)
init|;
name|count
operator|>
literal|0
condition|;
name|count
operator|--
control|)
block|{
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|answer
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
name|done
operator|++
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|answer
operator|+
name|len
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
name|done
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* Answer. */
for|for
control|(
name|count
operator|=
name|ntohs
argument_list|(
operator|(
operator|(
name|HEADER
operator|*
operator|)
name|answer
operator|)
operator|->
name|ancount
argument_list|)
init|;
name|count
operator|>
literal|0
operator|&&
operator|!
name|done
condition|;
name|count
operator|--
control|)
block|{
name|n
operator|=
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|answer
operator|+
name|len
argument_list|,
name|cp
argument_list|,
name|dname
index|[
name|soacnt
index|]
argument_list|,
sizeof|sizeof
name|dname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
name|done
operator|++
expr_stmt|;
break|break;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|cp
operator|+
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
operator|>
name|answer
operator|+
name|len
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
name|done
operator|++
expr_stmt|;
break|break;
block|}
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* ttl */
name|GETSHORT
argument_list|(
name|rlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|rlen
expr_stmt|;
if|if
condition|(
name|cp
operator|>
name|answer
operator|+
name|len
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
name|done
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|type
operator|==
name|T_SOA
operator|&&
name|soacnt
operator|++
operator|&&
name|ns_samename
argument_list|(
name|dname
index|[
literal|0
index|]
argument_list|,
name|dname
index|[
literal|1
index|]
argument_list|)
operator|==
literal|1
condition|)
block|{
name|done
operator|++
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * Verify the TSIG 		 */
if|if
condition|(
name|key
condition|)
block|{
if|if
condition|(
name|ns_find_tsig
argument_list|(
name|answer
argument_list|,
name|answer
operator|+
name|len
argument_list|)
operator|!=
name|NULL
condition|)
name|tsig_present
operator|=
literal|1
expr_stmt|;
else|else
name|tsig_present
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|numAnswers
operator|==
literal|1
operator|||
name|soacnt
operator|>
literal|1
condition|)
name|tsig_required
operator|=
literal|1
expr_stmt|;
else|else
name|tsig_required
operator|=
literal|0
expr_stmt|;
name|tsig_ret
operator|=
name|ns_verify_tcp
argument_list|(
name|answer
argument_list|,
operator|&
name|len
argument_list|,
operator|&
name|tsig_state
argument_list|,
name|tsig_required
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsig_ret
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tsig_present
condition|)
name|printf
argument_list|(
literal|"; TSIG ok\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"; TSIG invalid\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|";; Received %d answer%s (%d record%s).\n"
argument_list|,
name|numAnswers
argument_list|,
operator|(
name|numAnswers
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|,
name|numRecords
argument_list|,
operator|(
name|numRecords
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If we were uncompressing, reap the uncompressor. 	 */
if|if
condition|(
name|xfr
operator|==
name|ns_t_zxfr
condition|)
block|{
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|pid
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|";; wait"
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
if|if
condition|(
name|pid
operator|!=
name|zpid
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; wrong pid (%lu != %lu)\n"
argument_list|,
operator|(
name|u_long
operator|)
name|pid
argument_list|,
operator|(
name|u_long
operator|)
name|zpid
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|printf
argument_list|(
literal|";; pid %lu: exit %d, signal %d, core %c\n"
argument_list|,
operator|(
name|u_long
operator|)
name|pid
argument_list|,
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
argument_list|,
name|WIFSIGNALED
argument_list|(
name|status
argument_list|)
condition|?
name|WTERMSIG
argument_list|(
name|status
argument_list|)
else|:
literal|0
argument_list|,
name|WCOREDUMP
argument_list|(
name|status
argument_list|)
condition|?
literal|'t'
else|:
literal|'f'
argument_list|)
expr_stmt|;
block|}
comment|/* XXX This should probably happen sooner than here */
if|if
condition|(
name|key
condition|)
name|free
argument_list|(
name|newmsg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NO_ERRORS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ERR_READING_LEN
case|:
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
case|case
name|ERR_PRINTING
case|:
return|return
operator|(
name|result
operator|)
return|;
case|case
name|ERR_READING_MSG
case|:
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
default|default:
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|print_axfr
parameter_list|(
name|FILE
modifier|*
name|file
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|size_t
name|msglen
parameter_list|)
block|{
name|ns_msg
name|handle
decl_stmt|;
if|if
condition|(
name|ns_initparse
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|,
operator|&
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ns_initparse: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ns_r_formerr
operator|)
return|;
block|}
if|if
condition|(
name|ns_msg_getflag
argument_list|(
name|handle
argument_list|,
name|ns_f_rcode
argument_list|)
operator|!=
name|ns_r_noerror
condition|)
return|return
operator|(
name|ns_msg_getflag
argument_list|(
name|handle
argument_list|,
name|ns_f_rcode
argument_list|)
operator|)
return|;
comment|/* 	 * We are looking for info from answer resource records. 	 * If there aren't any, return with an error. We assume 	 * there aren't any question records. 	 */
if|if
condition|(
name|ns_msg_count
argument_list|(
name|handle
argument_list|,
name|ns_s_an
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NO_INFO
operator|)
return|;
ifdef|#
directive|ifdef
name|PROTOCOLDEBUG
name|printf
argument_list|(
literal|";;; (message of %d octets has %d answers)\n"
argument_list|,
name|msglen
argument_list|,
name|ns_msg_count
argument_list|(
name|handle
argument_list|,
name|ns_s_an
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|static
name|char
name|origin
index|[
name|NS_MAXDNAME
index|]
decl_stmt|,
name|name_ctx
index|[
name|NS_MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
comment|/* XXX need to malloc/realloc. */
name|ns_rr
name|rr
decl_stmt|;
if|if
condition|(
name|ns_parserr
argument_list|(
operator|&
name|handle
argument_list|,
name|ns_s_an
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|rr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENODEV
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ns_parserr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
break|break;
block|}
name|name
operator|=
name|ns_rr_name
argument_list|(
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|!=
literal|0
condition|)
name|strcpy
argument_list|(
name|origin
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"$ORIGIN %s.\n"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
name|strcpy
argument_list|(
name|origin
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|name_ctx
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ns_sprintrr
argument_list|(
operator|&
name|handle
argument_list|,
operator|&
name|rr
argument_list|,
name|name_ctx
argument_list|,
name|origin
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ns_sprintrr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|FORMERR
operator|)
return|;
block|}
name|strcpy
argument_list|(
name|name_ctx
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|struct
name|timeval
name|difftv
parameter_list|(
name|struct
name|timeval
name|a
parameter_list|,
name|struct
name|timeval
name|b
parameter_list|)
block|{
specifier|static
name|struct
name|timeval
name|diff
decl_stmt|;
name|diff
operator|.
name|tv_sec
operator|=
name|b
operator|.
name|tv_sec
operator|-
name|a
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|diff
operator|.
name|tv_usec
operator|=
name|b
operator|.
name|tv_usec
operator|-
name|a
operator|.
name|tv_usec
operator|)
operator|<
literal|0
condition|)
block|{
name|diff
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|diff
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prnttime
parameter_list|(
name|struct
name|timeval
name|t
parameter_list|)
block|{
name|printf
argument_list|(
literal|"%lu msec"
argument_list|,
call|(
name|u_long
call|)
argument_list|(
name|t
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
operator|(
name|t
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Take arguments appearing in simple string (from file or command line)  * place in char**.  */
end_comment

begin_function
specifier|static
name|void
name|stackarg
parameter_list|(
name|char
modifier|*
name|l
parameter_list|,
name|char
modifier|*
modifier|*
name|y
parameter_list|)
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
name|l
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
name|l
operator|++
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
case|case
literal|'\n'
case|:
name|done
operator|++
expr_stmt|;
operator|*
name|y
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
operator|*
name|y
operator|++
operator|=
name|l
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|'\n'
condition|)
name|done
operator|++
expr_stmt|;
operator|*
name|l
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|y
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

