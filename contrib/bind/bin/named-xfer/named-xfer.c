begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*  * The original version of named-xfer by Kevin Dunlap.  * Completed and integrated with named by David Waitzman  *	(dwaitzman@bbn.com) 3/14/88.  * Modified by M. Karels and O. Kure 10-88.  * Modified extensively since then by just about everybody.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 1990  *    The Regents of the University of California.  All rights reserved.  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *   * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1995 by International Business Machines, Inc.  *  * International Business Machines, Inc. (hereinafter called IBM) grants  * permission under its copyrights to use, copy, modify, and distribute this  * Software with or without fee, provided that the above copyright notice and  * all paragraphs of this notice appear in all copies, and that the name of IBM  * not be used in connection with the marketing of any product incorporating  * the Software or modifications thereof, without specific, written prior  * permission.  *  * To the extent it has a right to do so, IBM grants an immunity from suit  * under its patents, if any, for the use, sale or manufacture of products to  * the extent that such products are used for performing Domain Name System  * dynamic updates in TCP/IP networks by means of the Software.  No immunity is  * granted for any product per se or for any other function of any product.  *  * THE SOFTWARE IS PROVIDED "AS IS", AND IBM DISCLAIMS ALL WARRANTIES,  * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A  * PARTICULAR PURPOSE.  IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL,  * DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER ARISING  * OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE, EVEN  * IF IBM IS APPRISED OF THE POSSIBILITY OF SUCH DAMAGES.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1996-1999 by Internet Software Consortium.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND INTERNET SOFTWARE CONSORTIUM DISCLAIMS  * ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL INTERNET SOFTWARE  * CONSORTIUM BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  */
end_comment

begin_comment
comment|/*  * Portions Copyright (c) 1998 by MetaInfo, Incorporated.  *   * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of MetaInfo Incorporated not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *   * THE SOFTWARE IS PROVIDED "AS IS" AND METAINFO INCORPORATED DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL METAINFO INCORPRATED  * BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR   * ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER  * IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT   * OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1990 The Regents of the University of California.\n\  portions Copyright (c) 1993 Digital Equipment Corporation\n\  portions Copyright (c) 1998 MetaInfo, Inc.\n\  portions Copyright (c) 1995, 1996 Internet Software Consorium\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|lint
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|SABER
argument_list|)
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
name|sccsid
index|[]
init|=
literal|"@(#)named-xfer.c	4.18 (Berkeley) 3/7/91"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$Id: named-xfer.c,v 8.94 2000/07/11 05:38:27 vixie Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|"port_before.h"
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<isc/eventlib.h>
end_include

begin_include
include|#
directive|include
file|<isc/list.h>
end_include

begin_include
include|#
directive|include
file|<isc/logging.h>
end_include

begin_comment
comment|/* This still uses malloc/free, but the tsig routines allocate memory with  * memget, and we free it with memput.  */
end_comment

begin_include
include|#
directive|include
file|<isc/memcluster.h>
end_include

begin_include
include|#
directive|include
file|<isc/dst.h>
end_include

begin_include
include|#
directive|include
file|"port_after.h"
end_include

begin_define
define|#
directive|define
name|MAIN_PROGRAM
end_define

begin_include
include|#
directive|include
file|"../named/named.h"
end_include

begin_undef
undef|#
directive|undef
name|MAIN_PROGRAM
end_undef

begin_define
define|#
directive|define
name|MAX_XFER_RESTARTS
value|2
end_define

begin_define
define|#
directive|define
name|ENABLE_IXFR
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_FNAMES
end_ifdef

begin_decl_stmt
specifier|extern
name|long
name|pathconf
name|__P
argument_list|(
operator|(
specifier|const
name|char
operator|*
name|path
operator|,
name|int
name|name
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|struct
name|zoneinfo
name|zone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zone information */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ddtfilename
init|=
name|NULL
decl_stmt|,
modifier|*
name|ddtfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmpname
init|=
name|NULL
decl_stmt|,
modifier|*
name|tmpiname
init|=
name|NULL
decl_stmt|,
comment|/* temporary file name for ixfr transaction file */
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain being xfered */
end_comment

begin_decl_stmt
specifier|static
name|int
name|quiet
init|=
literal|0
decl_stmt|,
name|read_interrupted
init|=
literal|0
decl_stmt|,
name|curclass
decl_stmt|,
name|domain_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* strlen(domain) */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|fp
init|=
name|NULL
decl_stmt|,
modifier|*
name|dbfp
init|=
name|NULL
decl_stmt|,
modifier|*
name|ixfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ProgName
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|usage
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|,
name|tsig_init
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getzone
argument_list|(
expr|struct
name|zoneinfo
operator|*
argument_list|,
name|u_int32_t
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|print_output
argument_list|(
expr|struct
name|zoneinfo
operator|*
argument_list|,
name|u_int32_t
argument_list|,
name|u_char
operator|*
argument_list|,
name|int
argument_list|,
name|u_char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|netread
argument_list|(
name|int
argument_list|,
name|char
operator|*
argument_list|,
name|int
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|writemsg
argument_list|(
name|int
argument_list|,
specifier|const
name|u_char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|ixfr_log
parameter_list|(
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|delete
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|u_int32_t
modifier|*
name|serial_no
parameter_list|,
name|int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|SIG_FN
name|read_alarm
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|SIG_FN
name|term_handler
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|soa_zinfo
argument_list|(
expr|struct
name|zoneinfo
operator|*
argument_list|,
name|u_char
operator|*
argument_list|,
name|u_char
operator|*
argument_list|)
decl_stmt|,
modifier|*
name|tsig_rcode
argument_list|(
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|zoneinfo
name|zp_start
decl_stmt|,
name|zp_finish
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|restarts
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|check_serial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xfr_qtype
init|=
name|T_AXFR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|ddt
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|servermethode
index|[
name|NSMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|soa_buf
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|_tsig_node
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
name|DST_KEY
modifier|*
name|dst_key
decl_stmt|;
name|LINK
argument_list|(
argument|struct _tsig_node
argument_list|)
name|link
expr_stmt|;
block|}
name|tsig_node
typedef|;
end_typedef

begin_macro
name|LIST
argument_list|(
argument|tsig_node
argument_list|)
end_macro

begin_expr_stmt
name|tsig_list
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Debugging printf.  */
end_comment

begin_function
name|void
name|dprintf
parameter_list|(
name|int
name|level
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddt
operator|!=
name|NULL
operator|&&
name|debug
operator|>=
name|level
condition|)
operator|(
name|void
operator|)
name|vfprintf
argument_list|(
name|ddt
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|init_xfer_logging
parameter_list|()
block|{
name|log_channel
name|chan
decl_stmt|;
if|if
condition|(
name|log_new_context
argument_list|(
name|ns_log_max_category
argument_list|,
name|NULL
argument_list|,
operator|&
name|log_ctx
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"log_new_context"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|log_option
argument_list|(
name|log_ctx
argument_list|,
name|LOG_OPTION_DEBUG
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|log_option
argument_list|(
name|log_ctx
argument_list|,
name|LOG_OPTION_LEVEL
argument_list|,
name|debug
argument_list|)
expr_stmt|;
name|log_ctx_valid
operator|=
literal|1
expr_stmt|;
name|chan
operator|=
name|log_new_syslog_channel
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|log_add_channel
argument_list|(
name|log_ctx
argument_list|,
name|ns_log_default
argument_list|,
name|chan
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"log_add_channel syslog"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
block|{
name|unsigned
name|int
name|flags
init|=
name|LOG_USE_CONTEXT_LEVEL
operator||
name|LOG_REQUIRE_DEBUG
decl_stmt|;
name|chan
operator|=
name|log_new_file_channel
argument_list|(
name|flags
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ddt
argument_list|,
literal|0
argument_list|,
name|ULONG_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|chan
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|log_add_channel
argument_list|(
name|log_ctx
argument_list|,
name|ns_log_default
argument_list|,
name|chan
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"log_add_channel debug"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|cleanup_for_exit
parameter_list|(
name|void
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|debug
condition|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpiname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tmpiname
condition|)
name|free
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
name|tmpiname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ddtfilename
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|ddtfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddtfilename
operator|==
name|ddtfile
condition|)
name|ddtfile
operator|=
name|NULL
expr_stmt|;
name|ddtfilename
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|tmpname
condition|)
name|free
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|tmpname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ddtfile
condition|)
name|free
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|ddtfile
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|struct
name|in_addr
name|axfr_src
decl_stmt|;
name|char
modifier|*
name|dbfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|tracefile
init|=
name|NULL
decl_stmt|,
modifier|*
name|tm
init|=
name|NULL
decl_stmt|,
modifier|*
name|tsigfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ixfrfile
init|=
name|NULL
decl_stmt|;
name|u_int32_t
name|new_serial_no
init|=
literal|0
decl_stmt|;
name|int
name|dbfd
decl_stmt|,
name|ddtd
decl_stmt|,
name|result
decl_stmt|,
name|c
decl_stmt|,
name|fd
decl_stmt|,
name|ixfd
decl_stmt|;
name|u_int32_t
name|serial_no
init|=
literal|0
decl_stmt|;
name|u_int
name|port
init|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
name|int
name|stub_only
init|=
literal|0
decl_stmt|;
name|int
name|class
init|=
name|C_IN
decl_stmt|;
name|int
name|n
decl_stmt|;
name|long
name|num_files
decl_stmt|;
ifdef|#
directive|ifdef
name|_AUX_SOURCE
name|set42sig
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|axfr_src
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|axfr_src
argument_list|)
expr_stmt|;
name|ProgName
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ProgName
operator|!=
name|NULL
condition|)
name|ProgName
operator|++
expr_stmt|;
else|else
name|ProgName
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
name|ddtfilename
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|_PATH_TMPXFER
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ddtfilename
argument_list|,
name|_PATH_TMPXFER
argument_list|)
expr_stmt|;
name|ddtfile
operator|=
name|ddtfilename
expr_stmt|;
ifdef|#
directive|ifdef
name|RENICE
name|nice
argument_list|(
operator|-
literal|40
argument_list|)
expr_stmt|;
comment|/* this is the recommended procedure to        */
name|nice
argument_list|(
literal|20
argument_list|)
expr_stmt|;
comment|/*   reset the priority of the current process */
name|nice
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*   to "normal" (== 0) - see nice(3)          */
endif|#
directive|endif
name|n
operator|=
name|LOG_PID
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_PERROR
name|n
operator||=
name|LOG_PERROR
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|LOG_CONS
argument_list|)
operator|&&
name|defined
argument_list|(
name|USE_LOG_CONS
argument_list|)
name|n
operator||=
name|LOG_CONS
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSLOG_42BSD
name|openlog
argument_list|(
name|ProgName
argument_list|,
name|n
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
name|ProgName
argument_list|,
name|n
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"C:d:l:s:t:z:f:i:p:P:qx:ST:Z"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'C'
case|:
name|class
operator|=
name|get_class
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
ifdef|#
directive|ifdef
name|DEBUG
name|debug
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'l'
case|:
name|ddtfile
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ddtfile
condition|)
name|panic
argument_list|(
literal|"malloc(ddtfile)"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHORT_FNAMES
name|filenamecpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHORT_FNAMES */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ddtfile
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|serial_no
operator|=
name|strtoul
argument_list|(
name|optarg
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|check_serial
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tracefile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* zone == domain */
name|domain
operator|=
name|optarg
expr_stmt|;
name|domain_len
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|domain_len
operator|>
literal|0
operator|)
operator|&&
operator|(
name|domain
index|[
name|domain_len
operator|-
literal|1
index|]
operator|==
literal|'.'
operator|)
condition|)
name|domain
index|[
operator|--
name|domain_len
index|]
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|dbfile
operator|=
name|optarg
expr_stmt|;
name|tmpname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpname
condition|)
name|panic
argument_list|(
literal|"malloc(tmpname)"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHORT_FNAMES
name|filenamecpy
argument_list|(
name|tmpname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHORT_FNAMES */
break|break;
case|case
literal|'i'
case|:
if|#
directive|if
name|ENABLE_IXFR
name|ixfrfile
operator|=
name|optarg
expr_stmt|;
name|tmpiname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tmpiname
condition|)
name|panic
argument_list|(
literal|"malloc(tmpiname)"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SHORT_FNAMES
name|filenamecpy
argument_list|(
name|tmpiname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpiname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SHORT_FNAMES */
endif|#
directive|endif
comment|/* ENABLE_IXFR */
break|break;
case|case
literal|'p'
case|:
name|port
operator|=
name|htons
argument_list|(
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|port
operator|=
operator|(
name|u_int16_t
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|stub_only
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|optarg
argument_list|,
operator|&
name|axfr_src
argument_list|)
condition|)
name|panic
argument_list|(
literal|"bad -x addr: %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|tsigfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|xfr_qtype
operator|=
name|ns_t_zxfr
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|(
literal|"unrecognized argument"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|domain
operator|||
operator|(
operator|(
operator|!
name|dbfile
operator|)
operator|&&
operator|(
operator|!
name|ixfrfile
operator|)
operator|)
operator|||
name|optind
operator|>=
name|argc
condition|)
block|{
if|if
condition|(
operator|!
name|domain
condition|)
name|usage
argument_list|(
literal|"no domain"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dbfile
condition|)
name|usage
argument_list|(
literal|"no dbfile"
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|>=
name|argc
condition|)
name|usage
argument_list|(
literal|"not enough arguments"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|stat
argument_list|(
name|dbfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISFIFO
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|usage
argument_list|(
literal|"dbfile must be a regular file or FIFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfrfile
operator|&&
operator|(
name|stat
argument_list|(
name|ixfrfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISFIFO
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
name|usage
argument_list|(
literal|"ixfrfile must be a regular file or FIFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsigfile
operator|&&
name|stat
argument_list|(
name|tsigfile
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
operator|!
name|S_ISREG
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
operator|&&
operator|!
name|S_ISFIFO
argument_list|(
name|statbuf
operator|.
name|st_mode
argument_list|)
condition|)
name|usage
argument_list|(
literal|"tsigfile must be a regular file or FIFO"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tracefile
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|tracefile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|tracefile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmpname
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
comment|/* tmpname is now something like "/etc/named/named.bu.db.XXXXXX" */
if|if
condition|(
operator|(
name|dbfd
operator|=
name|mkstemp
argument_list|(
name|tmpname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't make tmpfile (%s): %s\n"
argument_list|,
name|tmpname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_FCHMOD
comment|/* XXX */
if|if
condition|(
name|fchmod
argument_list|(
name|dbfd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|chmod
argument_list|(
name|tmpname
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't [f]chmod tmpfile (%s): %s\n"
argument_list|,
name|tmpname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dbfp
operator|=
name|fdopen
argument_list|(
name|dbfd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't fdopen tmpfile (%s)"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ixfrfile
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmpiname
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ixfd
operator|=
name|mkstemp
argument_list|(
name|tmpiname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't make tmpifile (%s): %s\n"
argument_list|,
name|tmpiname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|dbfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_FCHMOD
comment|/* XXX */
if|if
condition|(
name|fchmod
argument_list|(
name|ixfd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|chmod
argument_list|(
name|tmpiname
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't [f]chmod tmpifile (%s): %s\n"
argument_list|,
name|tmpiname
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|dbfd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|ixfd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|ixfd
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
comment|/* ddtfile is now something like "/usr/tmp/xfer.ddt.XXXXXX" */
if|if
condition|(
operator|(
name|ddtd
operator|=
name|mkstemp
argument_list|(
name|ddtfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|HAVE_FCHMOD
elseif|else
if|if
condition|(
name|fchmod
argument_list|(
name|ddtd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
elseif|else
if|if
condition|(
name|chmod
argument_list|(
name|ddtfile
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ddt
operator|=
name|fdopen
argument_list|(
name|ddtd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|setvbuf
argument_list|(
name|ddt
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|init_xfer_logging
argument_list|()
condition|)
block|{
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|perror
argument_list|(
literal|"init_xfer_logging"
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Ignore many types of signals that named (assumed to be our parent) 	 * considers important- if not, the user controlling named with 	 * signals usually kills us. 	 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGSYS
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
endif|#
directive|endif
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SIGUSR1&&SIGUSR2 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SIGUSR1&&SIGUSR2 */
if|if
condition|(
name|dbfile
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"domain `%s'; file `%s'; serial %u\n"
argument_list|,
name|domain
argument_list|,
name|dbfile
argument_list|,
name|serial_no
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfrfile
condition|)
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"domain `%s'; ixfrfile `%s'; serial %u\n"
argument_list|,
name|domain
argument_list|,
name|ixfrfile
argument_list|,
name|serial_no
argument_list|)
expr_stmt|;
name|buildservicelist
argument_list|()
expr_stmt|;
name|buildprotolist
argument_list|()
expr_stmt|;
name|tsig_init
argument_list|(
name|tsigfile
argument_list|)
expr_stmt|;
comment|/* init zone data */
name|zp
operator|=
operator|&
name|zone
expr_stmt|;
if|if
condition|(
name|stub_only
condition|)
name|zp
operator|->
name|z_type
operator|=
name|Z_STUB
expr_stmt|;
else|else
name|zp
operator|->
name|z_type
operator|=
name|Z_SECONDARY
expr_stmt|;
name|zp
operator|->
name|z_class
operator|=
name|class
expr_stmt|;
name|zp
operator|->
name|z_origin
operator|=
name|domain
expr_stmt|;
name|zp
operator|->
name|z_source
operator|=
name|dbfile
expr_stmt|;
name|zp
operator|->
name|z_axfr_src
operator|=
name|axfr_src
expr_stmt|;
name|zp
operator|->
name|z_addrcnt
operator|=
literal|0
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"zone found (%d): \"%s\", source = %s\n"
argument_list|,
name|zp
operator|->
name|z_type
argument_list|,
operator|(
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|?
literal|"."
else|:
name|zp
operator|->
name|z_origin
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|optind
operator|!=
name|argc
condition|;
name|optind
operator|++
control|)
block|{
name|int
name|tmpsupportixfr
decl_stmt|;
name|tm
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|tmpsupportixfr
operator|=
name|ISNOTIXFR
expr_stmt|;
if|if
condition|(
operator|(
name|optind
operator|+
literal|1
operator|)
operator|!=
name|argc
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"ixfr"
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|ENABLE_IXFR
name|tmpsupportixfr
operator|=
name|ISIXFR
expr_stmt|;
name|servermethode
index|[
name|zp
operator|->
name|z_addrcnt
index|]
operator|=
name|tmpsupportixfr
expr_stmt|;
endif|#
directive|endif
name|optind
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"axfr"
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmpsupportixfr
operator|=
name|ISNOTIXFR
expr_stmt|;
name|optind
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|inet_aton
argument_list|(
name|tm
argument_list|,
operator|&
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
literal|"-ixfr"
argument_list|,
name|tm
argument_list|)
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|ENABLE_IXFR
name|tmpsupportixfr
operator|=
name|ISIXFR
expr_stmt|;
name|servermethode
index|[
name|zp
operator|->
name|z_addrcnt
operator|-
literal|1
index|]
operator|=
name|tmpsupportixfr
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
literal|"-axfr"
argument_list|,
name|tm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|tmpsupportixfr
operator|=
name|ISNOTIXFR
expr_stmt|;
continue|continue;
block|}
name|hp
operator|=
name|gethostbyname
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"uninterpretable server (%s) for %s\n"
argument_list|,
name|tm
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|memcpy
argument_list|(
operator|&
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
argument_list|,
name|hp
operator|->
name|h_addr
argument_list|,
name|INADDRSZ
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"Arg: \"%s\" %s\n"
argument_list|,
name|tm
argument_list|,
operator|(
operator|(
name|tmpsupportixfr
operator|)
condition|?
literal|"IXFR"
else|:
literal|"AXFR"
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|zp
operator|->
name|z_addrcnt
operator|>=
name|NSMAX
condition|)
block|{
name|zp
operator|->
name|z_addrcnt
operator|=
name|NSMAX
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"NSMAX reached\n"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"addrcnt = %d\n"
argument_list|,
name|zp
operator|->
name|z_addrcnt
argument_list|)
expr_stmt|;
name|res_ninit
argument_list|(
operator|&
name|res
argument_list|)
expr_stmt|;
name|res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator||
name|RES_RECURSE
operator|)
expr_stmt|;
name|result
operator|=
name|getzone
argument_list|(
name|zp
argument_list|,
name|serial_no
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|dbfd
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfp
condition|)
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|ixfp
argument_list|)
expr_stmt|;
else|else
name|close
argument_list|(
name|ixfd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|XFER_SUCCESSAXFR
case|:
comment|/* ok exit */
if|if
condition|(
name|tmpiname
operator|!=
name|NULL
condition|)
name|unlink
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfrfile
condition|)
block|{
comment|/* 			 * An IXFR was requested but we performed an 			 * AXFR.  Rename the temporary file to the IXFR 			 * name, named will rename it again to the dbname. 			 */
if|if
condition|(
name|movefile
argument_list|(
name|tmpname
argument_list|,
name|ixfrfile
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"movefile"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rename %s to %s: %s"
argument_list|,
name|tmpname
argument_list|,
name|ixfrfile
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|exit
argument_list|(
name|XFER_SUCCESSAXFRIXFRFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|movefile
argument_list|(
name|tmpname
argument_list|,
name|dbfile
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"movefile"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"movefile %s to %s: %m"
argument_list|,
name|tmpname
argument_list|,
name|dbfile
argument_list|)
expr_stmt|;
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|XFER_SUCCESSAXFR
argument_list|)
expr_stmt|;
case|case
name|XFER_SUCCESSIXFR
case|:
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|movefile
argument_list|(
name|tmpiname
argument_list|,
name|ixfrfile
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"movefile"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"movefile %s to %s: %m"
argument_list|,
name|tmpiname
argument_list|,
name|ixfrfile
argument_list|)
expr_stmt|;
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|XFER_SUCCESSIXFR
argument_list|)
expr_stmt|;
case|case
name|XFER_UPTODATE
case|:
comment|/* the zone was already uptodate */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpiname
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|XFER_UPTODATE
argument_list|)
expr_stmt|;
default|default:
name|result
operator|=
name|XFER_FAIL
expr_stmt|;
comment|/* fall through */
case|case
name|XFER_TIMEOUT
case|:
case|case
name|XFER_FAIL
case|:
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|result
argument_list|)
expr_stmt|;
comment|/* error or timeout */
block|}
comment|/*NOTREACHED*/
return|return
operator|(
literal|0
operator|)
return|;
comment|/* Make gcc happy. */
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|UsageText
index|[]
init|=
block|{
literal|"\t-z zone_to_transfer\n"
block|,
literal|"\t-f db_file\n"
block|,
literal|"\t[-i ixfr_file]\n"
block|,
literal|"\t[-s serial_no]\n"
block|,
literal|"\t[-d debug_level]\n"
block|,
literal|"\t[-l debug_log_file]\n"
block|,
literal|"\t[-t trace_file]\n"
block|,
literal|"\t[-p port]\n"
block|,
literal|"\t[-S] [-Z]\n"
block|,
literal|"\t[-C class]\n"
block|,
literal|"\t[-x axfr-src]\n"
block|,
literal|"\t[-T tsig_info_file]\n"
block|,
literal|"\tservers [-ixfr|-axfr]...\n"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|char
modifier|*
specifier|const
modifier|*
name|line
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage error: %s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s\n"
argument_list|,
name|ProgName
argument_list|)
expr_stmt|;
for|for
control|(
name|line
operator|=
name|UsageText
init|;
operator|*
name|line
condition|;
name|line
operator|++
control|)
name|fputs
argument_list|(
operator|*
name|line
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|tsig_init
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|)
block|{
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|file
operator|==
name|NULL
condition|)
return|return;
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
return|return;
name|dst_init
argument_list|()
expr_stmt|;
name|INIT_LIST
argument_list|(
name|tsig_list
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|tsig_node
modifier|*
name|n
init|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|tsig_node
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|alg
decl_stmt|,
name|secret_len
decl_stmt|;
name|char
modifier|*
name|address
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|u_char
name|secret
index|[
literal|128
index|]
decl_stmt|;
name|s
operator|=
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
break|break;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|inet_aton
argument_list|(
name|buf
argument_list|,
operator|&
name|n
operator|->
name|addr
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|name
operator|=
name|strdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|fscanf
argument_list|(
name|fp
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|alg
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|buf
index|[
name|strlen
argument_list|(
name|buf
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
name|secret_len
operator|=
name|b64_pton
argument_list|(
name|cp
argument_list|,
name|secret
argument_list|,
sizeof|sizeof
argument_list|(
name|secret
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|->
name|dst_key
operator|=
name|dst_buffer_to_key
argument_list|(
name|name
argument_list|,
name|alg
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|secret
argument_list|,
name|secret_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|APPEND
argument_list|(
name|tsig_list
argument_list|,
name|n
argument_list|,
name|link
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|DEF_DNAME
value|'\001'
end_define

begin_comment
comment|/* '\0' means the root domain */
end_comment

begin_comment
comment|/* XXX: The following variables should probably all be "static" */
end_comment

begin_decl_stmt
name|u_int32_t
name|minimum_ttl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|soa_cnt
init|=
literal|0
decl_stmt|,
name|scdsoa
init|=
literal|0
decl_stmt|,
name|methode
init|=
name|ISNOTIXFR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delete_soa
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_int32_t
name|final_serial
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ixfr_soa
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|ns_cnt
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|query_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prev_comment
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* was previous record a comment? */
end_comment

begin_decl_stmt
name|char
name|zone_top
index|[
name|MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the top of the zone */
end_comment

begin_decl_stmt
name|char
name|prev_origin
index|[
name|MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from most recent $ORIGIN line */
end_comment

begin_decl_stmt
name|char
name|prev_dname
index|[
name|MAXDNAME
index|]
init|=
block|{
name|DEF_DNAME
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from previous record */
end_comment

begin_decl_stmt
name|char
name|prev_ns_dname
index|[
name|MAXDNAME
index|]
init|=
block|{
name|DEF_DNAME
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from most recent NS record */
end_comment

begin_function
specifier|static
name|int
name|getzone
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|u_int32_t
name|serial_no
parameter_list|,
name|int
name|port
parameter_list|)
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_int
name|len
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|l
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|int
name|was_ixfr
init|=
literal|0
decl_stmt|;
name|u_int
name|cnt
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|nmp
decl_stmt|,
modifier|*
name|eom
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|,
modifier|*
name|cpp
init|=
name|NULL
decl_stmt|;
name|u_char
modifier|*
name|bp
decl_stmt|;
name|u_int
name|bufsize
init|=
literal|0
decl_stmt|;
name|char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|name2
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|sockaddr_in
name|local
decl_stmt|;
name|int
name|locallen
decl_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|struct
name|sigaction
name|sv
decl_stmt|,
name|osv
decl_stmt|;
else|#
directive|else
name|struct
name|sigvec
name|sv
decl_stmt|,
name|osv
decl_stmt|;
endif|#
directive|endif
name|int
name|qdcount
decl_stmt|,
name|ancount
decl_stmt|,
name|aucount
decl_stmt|,
name|arcount
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|;
name|int
name|first_serial
decl_stmt|;
specifier|const
name|char
modifier|*
name|badsoa_msg
init|=
literal|"Nil"
decl_stmt|;
name|struct
name|sockaddr_in
name|my_addr
decl_stmt|;
name|char
name|my_addr_text
index|[
literal|30
index|]
decl_stmt|;
name|int
name|alen
decl_stmt|,
name|ret
decl_stmt|,
name|tsig_req
decl_stmt|;
name|DST_KEY
modifier|*
name|tsig_key
decl_stmt|;
name|ns_tcp_tsig_state
name|tsig_state
decl_stmt|;
name|int
name|tsig_signed
init|=
literal|0
decl_stmt|;
name|u_char
name|sig
index|[
literal|64
index|]
decl_stmt|;
name|int
name|siglen
decl_stmt|;
name|int
name|ixfr_first
init|=
literal|1
decl_stmt|;
name|int
name|loop_cnt
init|=
literal|0
decl_stmt|;
name|time_t
name|timesigned
decl_stmt|;
name|u_int32_t
name|query_serial
init|=
name|serial_no
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"getzone() %s "
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|zp
operator|->
name|z_type
condition|)
block|{
case|case
name|Z_STUB
case|:
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"stub\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|Z_SECONDARY
case|:
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"secondary\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"unknown type\n"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|memset
argument_list|(
operator|&
name|sv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|.
name|sa_handler
operator|=
operator|(
name|SIG_FN
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|read_alarm
expr_stmt|;
comment|/* SA_ONSTACK isn't recommended for strict POSIX code */
comment|/* is it absolutely necessary? */
comment|/* sv.sa_flags = SA_ONSTACK; */
name|sigfillset
argument_list|(
operator|&
name|sv
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|.
name|sa_handler
operator|=
operator|(
name|SIG_FN
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
name|term_handler
expr_stmt|;
name|sigfillset
argument_list|(
operator|&
name|sv
operator|.
name|sa_mask
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
else|#
directive|else
name|memset
argument_list|(
operator|&
name|sv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|.
name|sv_handler
operator|=
name|read_alarm
expr_stmt|;
name|sv
operator|.
name|sv_mask
operator|=
operator|~
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|sv
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sv
argument_list|)
expr_stmt|;
name|sv
operator|.
name|sv_handler
operator|=
name|term_handler
expr_stmt|;
name|sv
operator|.
name|sv_mask
operator|=
operator|~
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGTERM
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|strcpy
argument_list|(
name|zone_top
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|=
name|strlen
argument_list|(
name|zone_top
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|zone_top
index|[
name|l
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|zone_top
index|[
name|l
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|zone_top
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|cnt
operator|++
control|)
block|{
name|methode
operator|=
name|servermethode
index|[
name|cnt
index|]
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|zp
operator|->
name|z_addr
index|[
name|cnt
index|]
expr_stmt|;
name|dprintf
argument_list|(
literal|3
argument_list|,
literal|"address [%s] %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|methode
operator|==
name|ISIXFR
operator|)
condition|?
literal|"IXFR"
else|:
literal|"AXFR"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|cnt
operator|++
control|)
block|{
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
name|curclass
operator|=
name|zp
operator|->
name|z_class
expr_stmt|;
comment|/* 		 * If we have been given a serial number and a ixfr log 		 * file name then set methode. 		 */
if|if
condition|(
name|check_serial
operator|&&
name|tmpiname
operator|!=
name|NULL
condition|)
name|methode
operator|=
name|servermethode
index|[
name|cnt
index|]
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|PACKETSZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malloc(%u) failed"
argument_list|,
literal|2
operator|*
name|PACKETSZ
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
name|bufsize
operator|=
literal|2
operator|*
name|PACKETSZ
expr_stmt|;
block|}
name|try_again
label|:
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
name|PF_UNSPEC
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|zp
operator|->
name|z_axfr_src
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* "ANY" */
name|sin
operator|.
name|sin_addr
operator|=
name|zp
operator|->
name|z_axfr_src
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
literal|"binding to address [%s]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"warning: bind(%s) failed"
argument_list|,
name|inet_ntoa
argument_list|(
name|zp
operator|->
name|z_axfr_src
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|sin
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|zp
operator|->
name|z_addr
index|[
name|cnt
index|]
expr_stmt|;
name|dprintf
argument_list|(
literal|2
argument_list|,
literal|"connecting to server #%d [%s].%d\n"
argument_list|,
name|cnt
operator|+
literal|1
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_axfr_src
operator|.
name|s_addr
operator|!=
literal|0
condition|)
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
literal|"connect failed, trying w/o -x"
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_axfr_src
operator|.
name|s_addr
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
goto|goto
name|try_again
goto|;
block|}
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"connect(%s) for zone %s failed: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|methode
operator|==
name|ISIXFR
operator|&&
name|was_ixfr
operator|==
literal|0
condition|)
block|{
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|cpp
operator|=
name|buf
expr_stmt|;
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|curclass
argument_list|,
name|T_IXFR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"len = %d\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"zone %s: dn_comp for ixfr failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
name|hp
operator|->
name|nscount
operator|=
name|htons
argument_list|(
literal|1
operator|+
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
argument_list|)
expr_stmt|;
name|cpp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|dn_comp
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|cpp
argument_list|,
name|bufsize
operator|-
operator|(
name|cpp
operator|-
name|buf
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
literal|0
condition|)
name|cpp
operator|+=
name|n
expr_stmt|;
name|PUTSHORT
argument_list|(
name|T_SOA
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* type */
name|PUTSHORT
argument_list|(
name|C_IN
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* class */
name|PUTLONG
argument_list|(
literal|0
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* ttl */
name|PUTSHORT
argument_list|(
literal|22
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* dlen */
operator|*
name|cpp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* mname */
operator|*
name|cpp
operator|++
operator|=
literal|0
expr_stmt|;
comment|/* rname */
name|PUTLONG
argument_list|(
name|serial_no
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
name|PUTLONG
argument_list|(
literal|0xDEAD
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Refresh */
name|PUTLONG
argument_list|(
literal|0xBEEF
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Retry */
name|PUTLONG
argument_list|(
literal|0xABCD
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Expire */
name|PUTLONG
argument_list|(
literal|0x1776
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
comment|/* Min TTL */
name|n
operator|=
name|cpp
operator|-
name|buf
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"len = %d\n"
argument_list|,
name|cpp
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|buf
argument_list|,
name|n
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|curclass
argument_list|,
name|T_SOA
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"zone %s: res_nmkquery T_SOA failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
block|}
comment|/* 		 * Append TSIG to SOA query if desired 		 */
name|tsig_key
operator|=
name|tsig_key_from_addr
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsig_key
operator|!=
name|NULL
condition|)
block|{
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ns_sign
argument_list|(
name|buf
argument_list|,
operator|&
name|n
argument_list|,
name|bufsize
argument_list|,
name|NOERROR
argument_list|,
name|tsig_key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
name|timesigned
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|tsig_signed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 		 * Send length& message for SOA query 		 */
if|if
condition|(
name|writemsg
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"writemsg: %m"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Get out your butterfly net and catch the SOA 		 */
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|INT16SZ
argument_list|,
operator|(
name|soa_cnt
operator|==
literal|0
operator|)
condition|?
literal|400
else|:
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ns_get16
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|>
name|bufsize
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malloc(%u) failed for SOA from server [%s], zone %s\n"
argument_list|,
name|len
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bufsize
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Verify the TSIG if expected 		 */
if|if
condition|(
name|tsig_signed
operator|!=
literal|0
condition|)
block|{
name|ret
operator|=
name|ns_verify
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|len
argument_list|,
name|tsig_key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|timesigned
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"SOA TSIG verification from server [%s], zone %s: %s (%d)\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|tsig_rcode
argument_list|(
name|ret
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"len = %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
operator|(
name|methode
operator|==
name|ISIXFR
operator|)
operator|&&
operator|(
name|ixfp
operator|==
name|NULL
operator|)
operator|)
operator|&&
name|was_ixfr
operator|==
literal|0
condition|)
block|{
name|delete_soa
operator|=
literal|1
expr_stmt|;
name|ixfr_soa
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|ixfp
operator|=
name|fopen
argument_list|(
name|tmpiname
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't fdopen ixfr log (%s)"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|qdcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
name|arcount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
comment|/* 		 * close socket if any of these apply: 		 *  1) rcode != NOERROR 		 *  2) not an authority response 		 *  3) not an answer to our question 		 *  4) both the number of answers and authority count< 1) 		 */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
operator|!
name|hp
operator|->
name|aa
operator|||
name|qdcount
operator|!=
literal|1
operator|||
operator|(
name|ancount
operator|<
literal|1
operator|&&
name|aucount
operator|<
literal|1
operator|)
condition|)
block|{
ifndef|#
directive|ifndef
name|SYSLOG_42BSD
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"[%s] %s for %s, SOA query got rcode %d, aa %d, ancount %d, aucount %d"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|hp
operator|->
name|aa
condition|?
operator|(
name|qdcount
operator|==
literal|1
condition|?
literal|"no SOA found"
else|:
literal|"bad response"
operator|)
else|:
literal|"not authoritative"
operator|)
argument_list|,
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|zp
operator|->
name|z_origin
else|:
literal|"."
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|hp
operator|->
name|aa
argument_list|,
name|ancount
argument_list|,
name|aucount
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|zp_start
operator|=
operator|*
name|zp
expr_stmt|;
if|if
condition|(
operator|(
name|int
operator|)
name|len
operator|<
name|HFIXEDSZ
operator|+
name|QFIXEDSZ
condition|)
block|{
name|badsoa_msg
operator|=
literal|"too short"
expr_stmt|;
name|badsoa
label|:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed SOA from [%s], zone %s: %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|badsoa_msg
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * Step through response. 		 */
name|tmp
operator|=
name|buf
operator|+
name|HFIXEDSZ
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
comment|/* Query Section. */
if|if
condition|(
name|qdcount
operator|>
literal|1
condition|)
block|{
name|badsoa_msg
operator|=
literal|"question error"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
if|if
condition|(
name|qdcount
operator|<
literal|1
condition|)
goto|goto
name|no_question
goto|;
name|n
operator|=
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|eom
argument_list|,
name|tmp
argument_list|,
name|name2
argument_list|,
sizeof|sizeof
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
literal|"qname error"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|tmp
operator|+
literal|2
operator|*
name|INT16SZ
operator|>
name|eom
condition|)
block|{
name|badsoa_msg
operator|=
literal|"query error"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|NS_GET16
argument_list|(
name|type
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|class
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|!=
name|curclass
operator|||
operator|(
operator|(
name|type
operator|!=
name|T_SOA
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_IXFR
operator|)
operator|&&
operator|(
name|type
operator|!=
name|T_AXFR
operator|)
operator|)
operator|||
name|ns_samename
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"wrong query in resp from [%s], zone %s: [%s %s %s]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|no_question
label|:
comment|/* ... Answer Section. 		 * We may have to loop a little, to bypass SIG SOA's in 		 * the response. 		 */
name|loop_cnt
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|NULL
expr_stmt|;
do|do
block|{
name|u_char
modifier|*
name|cp4
decl_stmt|;
name|u_short
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|eom
argument_list|,
name|tmp
argument_list|,
name|name2
argument_list|,
sizeof|sizeof
name|name2
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
literal|"aname error"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|loop_cnt
operator|==
literal|0
condition|)
name|bp
operator|=
name|tmp
expr_stmt|;
comment|/* Are type, class, and ttl OK? */
name|cp4
operator|=
name|tmp
expr_stmt|;
comment|/* Leave tmp pointing to type field */
if|if
condition|(
name|eom
operator|-
name|cp4
operator|<
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
condition|)
block|{
name|badsoa_msg
operator|=
literal|"zinfo too short"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
name|NS_GET16
argument_list|(
name|type
argument_list|,
name|cp4
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|class
argument_list|,
name|cp4
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|ttl
argument_list|,
name|cp4
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|dlen
argument_list|,
name|cp4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp4
operator|+
name|dlen
operator|>
name|eom
condition|)
block|{
name|badsoa_msg
operator|=
literal|"zinfo dlen too big"
expr_stmt|;
goto|goto
name|badsoa
goto|;
block|}
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
if|if
condition|(
name|was_ixfr
condition|)
block|{
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|methode
operator|==
name|ISIXFR
operator|)
operator|&&
operator|(
name|loop_cnt
operator|==
literal|0
operator|)
condition|)
block|{
name|soa_cnt
operator|++
expr_stmt|;
name|badsoa_msg
operator|=
name|soa_zinfo
argument_list|(
operator|&
name|zp_finish
argument_list|,
name|tmp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|badsoa_msg
condition|)
goto|goto
name|badsoa
goto|;
if|if
condition|(
name|ixfp
condition|)
if|if
condition|(
name|ixfr_log
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|delete_soa
argument_list|,
name|ixfp
argument_list|,
operator|&
name|sin
argument_list|,
name|domain
argument_list|,
operator|&
name|serial_no
argument_list|,
operator|&
name|ixfr_first
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
if|if
condition|(
name|methode
operator|==
name|ISIXFR
condition|)
block|{
name|check_serial
operator|=
literal|0
expr_stmt|;
name|soa_cnt
operator|++
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|loop_cnt
operator|>=
literal|1
operator|)
operator|&&
operator|(
name|soa_cnt
operator|<
literal|2
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"server %s %d rejected IXFR and responded with AXFR\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|soa_cnt
argument_list|)
expr_stmt|;
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
name|check_serial
operator|=
literal|0
expr_stmt|;
name|was_ixfr
operator|++
expr_stmt|;
name|tmp
operator|=
name|bp
expr_stmt|;
break|break;
block|}
comment|/* Skip to next record, if any.  */
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"skipping %s %s RR in response\n"
argument_list|,
name|name2
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|cp4
operator|+
name|dlen
expr_stmt|;
name|loop_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|loop_cnt
operator|>=
name|ancount
condition|)
block|{
name|tmp
operator|=
name|bp
expr_stmt|;
name|check_serial
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
do|while
condition|(
literal|1
condition|)
do|;
if|if
condition|(
name|ns_samename
argument_list|(
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"wrong answer in resp from [%s], zone %s: [%s %s %s]\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|name2
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|badsoa_msg
operator|=
name|soa_zinfo
argument_list|(
operator|&
name|zp_start
argument_list|,
name|tmp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|badsoa_msg
condition|)
goto|goto
name|badsoa
goto|;
if|if
condition|(
name|methode
operator|==
name|ISNOTIXFR
condition|)
block|{
if|if
condition|(
name|SEQ_GT
argument_list|(
name|zp_start
operator|.
name|z_serial
argument_list|,
name|serial_no
argument_list|)
operator|||
operator|!
name|check_serial
condition|)
block|{
specifier|const
name|char
modifier|*
name|l
decl_stmt|,
modifier|*
name|nl
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|soa_cnt
condition|)
block|{
goto|goto
name|axfr_response
goto|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"need update, serial %u\n"
argument_list|,
name|zp_start
operator|.
name|z_serial
argument_list|)
expr_stmt|;
name|soa_cnt
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|ns_cnt
operator|=
literal|0
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|locallen
operator|=
sizeof|sizeof
name|local
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|local
argument_list|,
operator|&
name|locallen
argument_list|)
operator|<
literal|0
condition|)
block|{
name|memset
argument_list|(
operator|&
name|local
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|local
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|l
operator|=
name|Version
init|;
name|l
condition|;
name|l
operator|=
name|nl
control|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
operator|(
name|nl
operator|=
name|strchr
argument_list|(
name|l
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|len
operator|=
name|nl
operator|-
name|l
expr_stmt|;
name|nl
operator|=
name|nl
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
name|strlen
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|nl
operator|=
name|NULL
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l
condition|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; BIND version %.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|len
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|dbfp
argument_list|,
name|check_serial
condition|?
literal|"; zone '%s'   last serial %u\n"
else|:
literal|"; zone '%s'   first transfer\n"
argument_list|,
name|domain
argument_list|,
name|serial_no
argument_list|)
expr_stmt|;
name|t
operator|=
name|strdup
argument_list|(
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; from %s:%d (local %s) using %s at %s"
argument_list|,
name|t
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|.
name|sin_port
argument_list|)
argument_list|,
name|inet_ntoa
argument_list|(
name|local
operator|.
name|sin_addr
argument_list|)
argument_list|,
operator|(
name|methode
operator|==
name|ISIXFR
operator|)
condition|?
literal|"IXFR"
else|:
literal|"AXFR"
argument_list|,
name|ctimel
argument_list|(
name|tt
operator|.
name|tv_sec
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|t
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|soa_cnt
operator|==
literal|0
operator|)
operator|||
operator|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
operator|)
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
block|{
if|if
condition|(
name|soa_cnt
operator|==
literal|1
operator|&&
name|ns_cnt
operator|==
literal|0
condition|)
name|query_type
operator|=
name|T_NS
expr_stmt|;
else|else
name|query_type
operator|=
name|T_SOA
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|methode
operator|==
name|ISIXFR
condition|)
name|query_type
operator|=
name|T_IXFR
expr_stmt|;
else|else
name|query_type
operator|=
name|xfr_qtype
expr_stmt|;
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|curclass
argument_list|,
name|query_type
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"send %s query %d to %s"
argument_list|,
operator|(
name|query_type
operator|==
name|T_IXFR
operator|)
condition|?
literal|"IXFR"
else|:
operator|(
name|query_type
operator|==
name|T_AXFR
operator|)
condition|?
literal|"AXFR"
else|:
operator|(
name|query_type
operator|==
name|ns_t_zxfr
operator|)
condition|?
literal|"ZXFR"
else|:
operator|(
name|query_type
operator|==
name|T_SOA
operator|)
condition|?
literal|"SOA"
else|:
literal|"NS"
argument_list|,
name|cnt
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"send %s query to %s\n"
argument_list|,
operator|(
name|query_type
operator|==
name|T_IXFR
operator|)
condition|?
literal|"IXFR"
else|:
operator|(
name|query_type
operator|==
name|T_AXFR
operator|)
condition|?
literal|"AXFR"
else|:
operator|(
name|query_type
operator|==
name|ns_t_zxfr
operator|)
condition|?
literal|"ZXFR"
else|:
operator|(
name|query_type
operator|==
name|T_SOA
operator|)
condition|?
literal|"SOA"
else|:
literal|"NS"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"bufsize = %d\n"
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
operator|(
name|query_type
operator|==
name|T_SOA
operator|)
condition|?
literal|"zone %s: res_nmkquery T_SOA failed"
else|:
literal|"zone %s: res_nmkquery T_NS failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
else|else
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"zone %s: res_nmkquery %s failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|p_type
argument_list|(
name|query_type
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
name|cpp
operator|=
name|buf
operator|+
name|n
expr_stmt|;
comment|/* 					 * Append TSIG to AXFR query if desired 					 */
if|if
condition|(
name|tsig_signed
operator|!=
literal|0
condition|)
block|{
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|ns_sign
argument_list|(
name|buf
argument_list|,
operator|&
name|n
argument_list|,
name|bufsize
argument_list|,
name|NOERROR
argument_list|,
name|tsig_key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
name|timesigned
argument_list|)
expr_stmt|;
name|cpp
operator|=
name|buf
operator|+
name|n
expr_stmt|;
name|ns_verify_tcp_init
argument_list|(
name|tsig_key
argument_list|,
name|sig
argument_list|,
name|siglen
argument_list|,
operator|&
name|tsig_state
argument_list|)
expr_stmt|;
block|}
comment|/* 					 * Send length& msg for zone transfer 					 */
if|if
condition|(
name|writemsg
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|cpp
operator|-
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"writemsg: %m"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/*XXX ZXFR*/
name|receive
label|:
comment|/* 				 * Receive length& response 				 */
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|INT16SZ
argument_list|,
operator|(
name|soa_cnt
operator|==
literal|0
operator|)
condition|?
literal|300
else|:
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ns_get16
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|>
name|bufsize
condition|)
block|{
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malloc(%u) failed for packet from server [%s], zone %s\n"
argument_list|,
name|len
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
name|bufsize
operator|=
name|len
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"len = %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Verify the TSIG if expected 				 */
if|if
condition|(
name|tsig_signed
operator|!=
literal|0
condition|)
block|{
name|tsig_req
operator|=
operator|(
name|soa_cnt
operator|==
literal|0
operator|)
expr_stmt|;
name|ret
operator|=
name|ns_verify_tcp
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|len
argument_list|,
operator|&
name|tsig_state
argument_list|,
name|tsig_req
argument_list|)
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"TSIG verification from server [%s], zone %s: %s (%d)\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|tsig_rcode
argument_list|(
name|ret
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|HFIXEDSZ
condition|)
block|{
name|badrec
label|:
name|error
operator|++
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
name|my_addr
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|my_addr
argument_list|,
operator|&
name|alen
argument_list|)
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|my_addr_text
argument_list|,
literal|"[errno %d]"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|my_addr_text
argument_list|,
literal|"[%s].%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|my_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|my_addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|REFUSED
operator|)
operator|&&
operator|(
name|len
operator|>=
name|HFIXEDSZ
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"[%s] transfer refused from [%s], zone %s\n"
argument_list|,
name|my_addr_text
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"[%s] record too short from [%s], zone %s\n"
argument_list|,
name|my_addr_text
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
name|axfr_response
label|:
if|if
condition|(
name|query_type
operator|==
name|T_IXFR
condition|)
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"server %s did not support IXFR\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
continue|continue;
block|}
empty_stmt|;
name|cp
operator|=
name|buf
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
name|hp
operator|->
name|qdcount
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|query_type
operator|==
name|T_IXFR
operator|)
operator|&&
operator|(
name|methode
operator|==
name|ISIXFR
operator|)
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"server %s rejected IXFR and responded with AXFR\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
block|}
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
operator|(
name|n
operator|+
name|QFIXEDSZ
operator|)
operator|>=
operator|(
name|eom
operator|-
name|cp
operator|)
operator|)
condition|)
goto|goto
name|badrec
goto|;
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
block|}
name|nmp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badrec
goto|;
name|tmp
operator|=
name|cp
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
block|{
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
operator|(
name|u_int
operator|)
name|ancount
condition|;
name|cnt
operator|++
control|)
block|{
name|n
operator|=
name|print_output
argument_list|(
name|zp
argument_list|,
name|serial_no
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|cp
argument_list|,
name|was_ixfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
comment|/* 					 * If we've processed the answer 					 * section and didn't get any useful 					 * answers, bail out. 					 */
if|if
condition|(
name|query_type
operator|==
name|T_SOA
operator|&&
name|soa_cnt
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stubs: no SOA in answer"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|query_type
operator|==
name|T_NS
operator|&&
name|ns_cnt
operator|==
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"stubs: no NS in answer"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|n
operator|>=
literal|0
operator|&&
name|hp
operator|->
name|nscount
condition|)
block|{
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
operator|(
name|u_int
operator|)
name|ancount
condition|;
name|cnt
operator|++
control|)
block|{
name|n
operator|=
name|print_output
argument_list|(
name|zp
argument_list|,
name|serial_no
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|cp
argument_list|,
name|was_ixfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
block|}
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|arcount
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|n
operator|>
literal|0
operator|&&
name|cnt
operator|<
operator|(
name|u_int
operator|)
name|ancount
condition|;
name|cnt
operator|++
control|)
block|{
name|n
operator|=
name|print_output
argument_list|(
name|zp
argument_list|,
name|serial_no
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|cp
argument_list|,
name|was_ixfr
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"print_output: unparseable answer (%d), zone %s"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|!=
name|eom
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"print_output: short answer (%d, %d), zone %s"
argument_list|,
name|cp
operator|-
name|buf
argument_list|,
name|eom
operator|-
name|buf
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
if|if
condition|(
name|query_type
operator|==
name|T_IXFR
operator|&&
name|methode
operator|==
name|ISIXFR
condition|)
block|{
if|if
condition|(
name|ixfr_log
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|delete_soa
argument_list|,
name|ixfp
argument_list|,
operator|&
name|sin
argument_list|,
name|domain
argument_list|,
operator|&
name|serial_no
argument_list|,
operator|&
name|ixfr_first
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|n
operator|=
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
operator|(
name|u_int
operator|)
name|ancount
condition|;
name|cnt
operator|++
control|)
block|{
name|n
operator|=
name|print_output
argument_list|(
name|zp
argument_list|,
name|serial_no
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|cp
argument_list|,
name|was_ixfr
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
break|break;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"print_output: unparseable answer (%d), zone %s"
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cp
operator|!=
name|eom
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"print_output: short answer (%d, %d), zone %s"
argument_list|,
name|cp
operator|-
name|buf
argument_list|,
name|eom
operator|-
name|buf
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|(
name|soa_cnt
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|methode
operator|==
name|ISNOTIXFR
operator|)
condition|)
break|break;
if|if
condition|(
operator|(
name|soa_cnt
operator|==
operator|-
literal|1
operator|)
operator|&&
operator|(
name|methode
operator|==
name|ISIXFR
operator|)
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ixfp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ixfp
argument_list|)
expr_stmt|;
name|ixfp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|XFER_SUCCESSAXFR
operator|)
return|;
block|}
if|if
condition|(
name|ixfp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ixfp
argument_list|)
expr_stmt|;
name|ixfp
operator|=
name|NULL
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|2
argument_list|,
literal|"error receiving zone transfer\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zp_start
operator|.
name|z_serial
operator|==
name|serial_no
condition|)
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"zone up-to-date, serial %u\n"
argument_list|,
name|zp_start
operator|.
name|z_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfp
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ixfp
argument_list|)
expr_stmt|;
name|ixfp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|XFER_UPTODATE
operator|)
return|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"serial from [%s], zone %s: %u lower than current: %u\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp_start
operator|.
name|z_serial
argument_list|,
name|serial_no
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zp_finish
operator|.
name|z_serial
operator|==
name|query_serial
condition|)
block|{
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"zone up-to-date, serial %u\n"
argument_list|,
name|zp_start
operator|.
name|z_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfp
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ixfp
argument_list|)
expr_stmt|;
name|ixfp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|XFER_UPTODATE
operator|)
return|;
block|}
if|if
condition|(
name|SEQ_GT
argument_list|(
name|query_serial
argument_list|,
name|zp_finish
operator|.
name|z_serial
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"serial from [%s], zone %s: %u lower than current: %u\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp_finish
operator|.
name|z_serial
argument_list|,
name|query_serial
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"serial from [%s], zone %s: %u lower than current: %u\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp_finish
operator|.
name|z_serial
argument_list|,
name|query_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|ixfp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ixfp
argument_list|)
expr_stmt|;
name|ixfp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|was_ixfr
operator|==
literal|0
condition|)
block|{
name|was_ixfr
operator|++
expr_stmt|;
name|n
operator|=
name|res_nmkquery
argument_list|(
operator|&
name|res
argument_list|,
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|curclass
argument_list|,
name|T_AXFR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"zone %s: res_nmkquery T_SOA failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
comment|/* 					 * Append TSIG to SOA query if desired 					 */
name|tsig_key
operator|=
name|tsig_key_from_addr
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|tsig_key
operator|!=
name|NULL
condition|)
block|{
name|siglen
operator|=
sizeof|sizeof
argument_list|(
name|sig
argument_list|)
expr_stmt|;
name|ret
operator|=
name|ns_sign
argument_list|(
name|buf
argument_list|,
operator|&
name|n
argument_list|,
name|bufsize
argument_list|,
name|NOERROR
argument_list|,
name|tsig_key
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|sig
argument_list|,
operator|&
name|siglen
argument_list|,
name|timesigned
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
condition|)
name|tsig_signed
operator|=
literal|1
expr_stmt|;
block|}
comment|/* 				 * Send length& message for AXFR query 				 */
if|if
condition|(
name|writemsg
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"writemsg: %m"
argument_list|)
expr_stmt|;
else|else
block|{
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
name|check_serial
operator|=
literal|0
expr_stmt|;
name|soa_cnt
operator|=
literal|0
expr_stmt|;
name|was_ixfr
operator|=
literal|0
expr_stmt|;
goto|goto
name|receive
goto|;
block|}
block|}
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
if|if
condition|(
name|ancount
operator|==
literal|1
condition|)
block|{
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
name|check_serial
operator|=
literal|0
expr_stmt|;
name|soa_cnt
operator|=
literal|0
expr_stmt|;
goto|goto
name|axfr_response
goto|;
block|}
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"We have an IXFR\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|SEQ_GT
argument_list|(
name|zp_finish
operator|.
name|z_serial
argument_list|,
name|serial_no
argument_list|)
condition|)
block|{
comment|/* 				 * Receive length& response 				 */
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|INT16SZ
argument_list|,
operator|(
name|soa_cnt
operator|==
literal|0
operator|)
condition|?
literal|300
else|:
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|ns_get16
argument_list|(
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|len
operator|>
name|bufsize
condition|)
block|{
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malloc(%u) failed for packet from server [%s], zone %s\n"
argument_list|,
name|len
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
name|bufsize
operator|=
name|len
expr_stmt|;
block|}
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|netread
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|len
argument_list|,
name|XFER_TIMER
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"len = %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
name|res_pquery
argument_list|(
operator|&
name|res
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 				 * Verify the TSIG if expected 				 */
if|if
condition|(
name|tsig_signed
operator|!=
literal|0
condition|)
block|{
name|tsig_req
operator|=
operator|(
name|soa_cnt
operator|==
literal|0
operator|)
expr_stmt|;
name|ret
operator|=
name|ns_verify_tcp
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|&
name|len
argument_list|,
operator|&
name|tsig_state
argument_list|,
name|tsig_req
argument_list|)
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_NOTICE
argument_list|,
literal|"TSIG verification from server [%s], zone %s: %s (%d)\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|tsig_rcode
argument_list|(
name|ret
argument_list|)
argument_list|,
name|ret
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|len
operator|<
name|HFIXEDSZ
condition|)
block|{
name|error
operator|++
expr_stmt|;
name|alen
operator|=
sizeof|sizeof
name|my_addr
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|my_addr
argument_list|,
operator|&
name|alen
argument_list|)
operator|<
literal|0
condition|)
name|sprintf
argument_list|(
name|my_addr_text
argument_list|,
literal|"[errno %d]"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|my_addr_text
argument_list|,
literal|"[%s].%u"
argument_list|,
name|inet_ntoa
argument_list|(
name|my_addr
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|my_addr
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|hp
operator|->
name|rcode
operator|==
name|REFUSED
operator|)
operator|&&
operator|(
name|len
operator|>=
name|HFIXEDSZ
operator|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"[%s] transfer refused from [%s], zone %s\n"
argument_list|,
name|my_addr_text
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"[%s] record too short from [%s], zone %s\n"
argument_list|,
name|my_addr_text
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|ixfp
condition|)
if|if
condition|(
name|ixfr_log
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|delete_soa
argument_list|,
name|ixfp
argument_list|,
operator|&
name|sin
argument_list|,
name|domain
argument_list|,
operator|&
name|serial_no
argument_list|,
operator|&
name|ixfr_first
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|my_close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|fprintf
argument_list|(
name|ixfp
argument_list|,
literal|"update:\t{add} "
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa_buf
condition|)
name|fputs
argument_list|(
name|soa_buf
argument_list|,
name|ixfp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|ixfp
argument_list|,
literal|"[END_DELTA]\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFER_SUCCESSIXFR
operator|)
return|;
block|}
block|}
block|}
ifdef|#
directive|ifdef
name|POSIX_SIGNALS
operator|(
name|void
operator|)
name|sigaction
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigaction
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|ixfp
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpiname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|my_fclose
argument_list|(
name|ixfp
argument_list|)
expr_stmt|;
name|ixfp
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|error
condition|)
return|return
operator|(
name|XFER_TIMEOUT
operator|)
return|;
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|SIG_FN
name|term_handler
parameter_list|()
block|{
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|_exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
comment|/* not safe to call exit() from a signal handler */
block|}
end_function

begin_comment
comment|/*  * Set flag saying to read was interrupted  * used for a read timer  */
end_comment

begin_function
specifier|static
name|SIG_FN
name|read_alarm
parameter_list|()
block|{
name|read_interrupted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|netread
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|len
parameter_list|,
name|int
name|timeout
parameter_list|)
block|{
specifier|static
specifier|const
name|char
name|setitimerStr
index|[]
init|=
literal|"setitimer: %m"
decl_stmt|;
name|struct
name|itimerval
name|ival
decl_stmt|,
name|zeroival
decl_stmt|;
name|struct
name|sockaddr_in
name|sa
decl_stmt|;
name|int
name|n
decl_stmt|,
name|salen
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|NETREAD_BROKEN
argument_list|)
name|int
name|retries
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|memset
argument_list|(
operator|&
name|zeroival
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|zeroival
argument_list|)
expr_stmt|;
name|ival
operator|=
name|zeroival
expr_stmt|;
name|ival
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
name|timeout
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
ifndef|#
directive|ifndef
name|WINNT
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|setitimerStr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
name|salen
operator|=
sizeof|sizeof
name|sa
expr_stmt|;
name|n
operator|=
name|recvfrom
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sa
argument_list|,
operator|&
name|salen
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
operator|&&
name|errno
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NETREAD_BROKEN
argument_list|)
if|if
condition|(
operator|++
name|retries
operator|<
literal|42
condition|)
comment|/* doug adams */
continue|continue;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"premature EOF, fetching \"%s\""
argument_list|,
name|domain
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|defined
argument_list|(
name|NETREAD_BROKEN
argument_list|)
if|if
condition|(
operator|++
name|retries
operator|<
literal|42
condition|)
comment|/* doug adams */
continue|continue;
endif|#
directive|endif
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"recv(len=%d): n=%d&& !errno"
argument_list|,
name|len
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
block|{
if|if
condition|(
operator|!
name|read_interrupted
condition|)
block|{
comment|/* It wasn't a timeout; ignore it. */
continue|continue;
block|}
name|errno
operator|=
name|ETIMEDOUT
expr_stmt|;
block|}
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"recv(len=%d): %m"
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|buf
operator|+=
name|n
expr_stmt|;
name|len
operator|-=
name|n
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|WINNT
if|if
condition|(
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|zeroival
argument_list|,
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
name|setitimerStr
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write a counted buffer to a file descriptor preceded by a length word.  */
end_comment

begin_function
specifier|static
name|int
name|writemsg
parameter_list|(
name|int
name|rfd
parameter_list|,
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|)
block|{
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|u_char
name|len
index|[
name|INT16SZ
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|__putshort
argument_list|(
name|msglen
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|len
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
name|INT16SZ
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
operator|(
name|char
operator|*
operator|)
name|msg
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|msglen
expr_stmt|;
name|ret
operator|=
name|writev
argument_list|(
name|rfd
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|!=
name|INT16SZ
operator|+
name|msglen
condition|)
block|{
name|syslog
argument_list|(
name|LOG_DEBUG
argument_list|,
literal|"writemsg(%d,%p,%d) failed: %s"
argument_list|,
name|rfd
argument_list|,
operator|(
name|void
operator|*
operator|)
name|msg
argument_list|,
name|msglen
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|soa_zinfo
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|u_char
modifier|*
name|cp
parameter_list|,
name|u_char
modifier|*
name|eom
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|class
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|u_int16_t
name|dlen
decl_stmt|;
name|u_char
modifier|*
name|rdatap
decl_stmt|;
comment|/* Are type, class, and ttl OK? */
if|if
condition|(
name|eom
operator|-
name|cp
operator|<
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
condition|)
return|return
operator|(
literal|"zinfo too short"
operator|)
return|;
name|NS_GET16
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|rdatap
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|T_SOA
operator|||
name|class
operator|!=
name|curclass
condition|)
return|return
operator|(
literal|"zinfo wrong typ/cla/ttl"
operator|)
return|;
comment|/* Skip master name and contact name, we can't validate them. */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|"zinfo mname"
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
literal|"zinfo hname"
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* Grab the data fields. */
if|if
condition|(
name|eom
operator|-
name|cp
operator|<
literal|5
operator|*
name|INT32SZ
condition|)
return|return
operator|(
literal|"zinfo dlen"
operator|)
return|;
name|NS_GET32
argument_list|(
name|zp
operator|->
name|z_serial
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|zp
operator|->
name|z_refresh
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|zp
operator|->
name|z_retry
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|zp
operator|->
name|z_expire
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|zp
operator|->
name|z_minimum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|rdatap
operator|+
name|dlen
condition|)
return|return
operator|(
literal|"bad soa dlen"
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_define
define|#
directive|define
name|BOUNDS_CHECK
parameter_list|(
name|ptr
parameter_list|,
name|count
parameter_list|)
define|\
value|do { \ 		if ((ptr) + (count)> eom) { \ 			hp->rcode = FORMERR; \ 			return (-1); \ 		} \ 	} while (0)
end_define

begin_comment
comment|/*  * Parse the message, determine if it should be printed, and if so, print it  * in .db file form.  Does minimal error checking on the message content.  *  * XXX why aren't we using ns_sprintrr() ?  */
end_comment

begin_function
specifier|static
name|int
name|print_output
parameter_list|(
name|struct
name|zoneinfo
modifier|*
name|zp
parameter_list|,
name|u_int32_t
name|serial_no
parameter_list|,
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|msglen
parameter_list|,
name|u_char
modifier|*
name|rrp
parameter_list|,
name|int
name|was_ixfr
parameter_list|)
block|{
name|u_char
modifier|*
name|cp
decl_stmt|;
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_int32_t
name|addr
decl_stmt|,
name|ttl
decl_stmt|,
name|tmpnum
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tab
decl_stmt|,
name|result
decl_stmt|,
name|n1
decl_stmt|,
name|n
decl_stmt|;
name|u_int
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|;
name|char
name|data
index|[
name|MAXDATA
index|]
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|,
modifier|*
name|temp_ptr
decl_stmt|,
modifier|*
name|eom
decl_stmt|,
modifier|*
name|rr_type_ptr
decl_stmt|;
name|u_char
modifier|*
name|cdata
decl_stmt|,
modifier|*
name|rdatap
decl_stmt|;
name|char
modifier|*
name|origin
decl_stmt|,
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto
decl_stmt|;
specifier|const
name|char
modifier|*
name|ignore
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|badsoa_msg
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|eom
operator|=
name|msg
operator|+
name|msglen
expr_stmt|;
name|cp
operator|=
name|rrp
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|dname
argument_list|,
sizeof|sizeof
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|3
operator|*
name|INT16SZ
operator|+
name|INT32SZ
argument_list|)
expr_stmt|;
name|rr_type_ptr
operator|=
name|cp
expr_stmt|;
name|NS_GET16
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* 	 * Following the Clarification draft's direction, we treat TTLs with 	 * the MSB set as if they were 0. 	 */
if|if
condition|(
name|ttl
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: TTL> %u, converted to 0"
argument_list|,
name|dname
argument_list|,
name|MAXIMUM_TTL
argument_list|)
expr_stmt|;
name|ttl
operator|=
literal|0
expr_stmt|;
block|}
name|NS_GET16
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|dlen
argument_list|)
expr_stmt|;
name|rdatap
operator|=
name|cp
expr_stmt|;
name|origin
operator|=
name|dname
expr_stmt|;
while|while
condition|(
operator|*
name|origin
condition|)
block|{
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|*
name|origin
operator|==
literal|'.'
condition|)
block|{
name|origin
operator|++
expr_stmt|;
comment|/* skip over '.' */
break|break;
block|}
name|escaped
operator|=
operator|(
operator|*
name|origin
operator|++
operator|==
literal|'\\'
operator|)
operator|&&
operator|!
name|escaped
expr_stmt|;
block|}
name|dprintf
argument_list|(
literal|3
argument_list|,
literal|"print_output: dname %s type %d class %d ttl %u\n"
argument_list|,
name|dname
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
comment|/* 	 * Convert the resource record data into the internal database format. 	 * CP points to the raw resource record. 	 * After this switch: 	 *	CP has been updated to point past the RR. 	 *	CP1 points to the internal database version.  	 *	N is the length of the internal database version. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
case|case
name|T_ISDN
case|:
case|case
name|T_LOC
case|:
case|case
name|T_NSAP
case|:
case|case
name|T_AAAA
case|:
case|case
name|T_KEY
case|:
case|case
name|ns_t_cert
case|:
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
case|case
name|T_RP
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|n
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
name|data
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|5
operator|*
name|INT32SZ
argument_list|)
expr_stmt|;
name|temp_ptr
operator|=
name|cp
operator|+
literal|4
operator|*
name|INT32SZ
expr_stmt|;
name|NS_GET32
argument_list|(
name|minimum_ttl
argument_list|,
name|temp_ptr
argument_list|)
expr_stmt|;
comment|/* 			 * Following the Clarification draft's direction, 			 * we treat TTLs with the MSB set as if they were 0. 			 */
if|if
condition|(
name|minimum_ttl
operator|>
name|MAXIMUM_TTL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s: SOA minimum TTL> %u, converted to 0"
argument_list|,
name|dname
argument_list|,
name|MAXIMUM_TTL
argument_list|)
expr_stmt|;
name|minimum_ttl
operator|=
literal|0
expr_stmt|;
block|}
name|n
operator|=
literal|5
operator|*
name|INT32SZ
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|T_NAPTR
case|:
comment|/* Grab weight and port. */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
comment|/* Flags */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Service */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Regexp */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
name|n
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* Replacement */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
operator|(
name|char
operator|*
operator|)
name|cp1
operator|-
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
case|case
name|T_SRV
case|:
comment|/* grab preference */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SRV
condition|)
block|{
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|INT16SZ
operator|*
literal|2
argument_list|)
expr_stmt|;
name|cp1
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
operator|*
literal|2
expr_stmt|;
block|}
comment|/* get name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
operator|(
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
comment|/* grab preference */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|data
argument_list|,
name|cp
argument_list|,
name|INT16SZ
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|INT16SZ
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* get MAP822 name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
sizeof|sizeof
name|data
operator|-
name|INT16SZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
operator|(
name|n
operator|=
operator|(
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
operator|)
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
name|data
operator|-
name|n
expr_stmt|;
comment|/* get MAPX400 name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n1
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|T_SIG
case|:
comment|/* CP is the raw resource record as it arrived. 	  * CP1, after this switch, points to the internal database version. */
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
comment|/* first just copy over the type_covered, algorithm, */
comment|/* labels, orig ttl, two timestamps, and the footprint */
name|BOUNDS_CHECK
argument_list|(
name|cp
argument_list|,
name|NS_SIG_SIGNER
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|NS_SIG_SIGNER
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|NS_SIG_SIGNER
expr_stmt|;
name|cp1
operator|+=
name|NS_SIG_SIGNER
expr_stmt|;
comment|/* then the signer's name */
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
operator|(
sizeof|sizeof
name|data
operator|)
operator|-
literal|18
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* finally, we copy over the variable-length signature. 		   Its size is the total data length, minus what we copied. */
name|n
operator|=
name|dlen
operator|-
operator|(
name|NS_SIG_SIGNER
operator|+
name|n
operator|)
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|data
argument_list|)
operator|-
call|(
name|int
call|)
argument_list|(
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* out of room! */
block|}
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
case|case
name|T_NXT
case|:
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
operator|+
name|strlen
argument_list|(
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
name|n
operator|=
name|dlen
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|n
operator|>
operator|(
call|(
name|int
call|)
argument_list|(
sizeof|sizeof
name|data
argument_list|)
operator|-
call|(
name|int
call|)
argument_list|(
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
argument_list|)
operator|)
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* out of room! */
block|}
if|if
condition|(
name|n
operator|>
literal|0
condition|)
block|{
comment|/* Actually, n should never be less than 4 */
name|memcpy
argument_list|(
name|cp1
argument_list|,
name|cp
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|+=
name|cp1
operator|-
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
name|cp1
operator|=
operator|(
name|u_char
operator|*
operator|)
name|data
expr_stmt|;
break|break;
default|default:
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"\"%s %s %s\" - unknown type (%d)"
argument_list|,
name|dname
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|NOTIMP
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"update type %d: %d bytes is too much data\n"
argument_list|,
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|!=
name|rdatap
operator|+
name|dlen
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"encoded rdata length is %u, but actual length was %u\n"
argument_list|,
name|dlen
argument_list|,
call|(
name|u_int
call|)
argument_list|(
name|cp
operator|-
name|rdatap
argument_list|)
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cdata
operator|=
name|cp1
expr_stmt|;
name|result
operator|=
name|cp
operator|-
name|rrp
expr_stmt|;
comment|/* 	 * Special handling for SOA records. 	 */
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
if|if
condition|(
name|ns_samename
argument_list|(
name|dname
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
operator|!=
literal|1
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"wrong zone name in XFR (wanted \"%s\", got \"%s\")"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|soa_cnt
operator|==
literal|0
condition|)
block|{
name|badsoa_msg
operator|=
name|soa_zinfo
argument_list|(
operator|&
name|zp_start
argument_list|,
name|rr_type_ptr
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|badsoa_msg
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed SOA for zone %s: %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|badsoa_msg
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|SEQ_GT
argument_list|(
name|zp_start
operator|.
name|z_serial
argument_list|,
name|serial_no
argument_list|)
operator|||
operator|!
name|check_serial
condition|)
block|{
name|soa_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"serial went backwards after transfer started"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|soa_cnt
operator|==
literal|1
condition|)
block|{
name|badsoa_msg
operator|=
name|soa_zinfo
argument_list|(
operator|&
name|zp_finish
argument_list|,
name|rr_type_ptr
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|badsoa_msg
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed SOA for zone %s: %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|badsoa_msg
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|zp_start
operator|.
name|z_serial
operator|==
name|zp_finish
operator|.
name|z_serial
condition|)
block|{
name|methode
operator|=
name|ISNOTIXFR
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zp_finish
operator|.
name|z_serial
operator|!=
name|serial_no
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"Unexpected serial number for zone %s: %u"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|zp_finish
operator|.
name|z_serial
argument_list|)
expr_stmt|;
block|}
name|soa_cnt
operator|++
expr_stmt|;
if|if
condition|(
name|methode
operator|==
name|ISIXFR
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
block|{
name|badsoa_msg
operator|=
name|soa_zinfo
argument_list|(
operator|&
name|zp_finish
argument_list|,
name|rr_type_ptr
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|badsoa_msg
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malformed SOA for zone %s: %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|badsoa_msg
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|methode
operator|==
name|ISIXFR
condition|)
block|{
if|if
condition|(
name|zp_start
operator|.
name|z_serial
operator|==
name|zp_finish
operator|.
name|z_serial
condition|)
block|{
if|if
condition|(
name|scdsoa
condition|)
block|{
name|soa_cnt
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
else|else
block|{
name|scdsoa
operator|=
literal|1
expr_stmt|;
name|soa_cnt
operator|++
expr_stmt|;
block|}
empty_stmt|;
block|}
else|else
name|soa_cnt
operator|++
expr_stmt|;
block|}
else|else
block|{
name|dprintf
argument_list|(
literal|2
argument_list|,
literal|"SOA, serial %u\n"
argument_list|,
name|zp_finish
operator|.
name|z_serial
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp_start
operator|.
name|z_serial
operator|!=
name|zp_finish
operator|.
name|z_serial
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"serial changed, restart\n"
argument_list|)
expr_stmt|;
name|restarts
operator|++
expr_stmt|;
if|if
condition|(
name|restarts
operator|>
name|MAX_XFER_RESTARTS
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"too many transfer restarts for zone %s"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|soa_cnt
operator|=
literal|0
expr_stmt|;
name|ns_cnt
operator|=
literal|0
expr_stmt|;
name|minimum_ttl
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|prev_dname
index|[
literal|0
index|]
operator|=
name|DEF_DNAME
expr_stmt|;
comment|/* 					 * Flush buffer, truncate file 					 * and seek to beginning to restart. 					 */
name|fflush
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|dbfp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"ftruncate %s: %m\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fseek
argument_list|(
name|dbfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
name|soa_cnt
operator|++
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|soa_cnt
operator|==
literal|2
operator|)
operator|&&
operator|(
name|was_ixfr
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_type
operator|==
name|Z_STUB
condition|)
block|{
if|if
condition|(
name|query_type
operator|==
name|T_NS
operator|&&
name|type
operator|==
name|T_NS
condition|)
name|ns_cnt
operator|++
expr_stmt|;
comment|/* 		 * If we're processing a response to an SOA query, we don't 		 * want to print anything from the response except for the SOA. 		 * We do want to check everything in the packet, which is 		 * why we do this check now instead of earlier. 		 */
if|if
condition|(
name|query_type
operator|==
name|T_SOA
operator|&&
name|type
operator|!=
name|T_SOA
condition|)
return|return
operator|(
name|result
operator|)
return|;
block|}
if|if
condition|(
operator|(
operator|!
name|soa_cnt
operator|||
name|soa_cnt
operator|>
literal|2
operator|)
operator|&&
name|methode
operator|==
name|ISNOTIXFR
condition|)
block|{
name|char
modifier|*
name|gripe
decl_stmt|;
if|if
condition|(
operator|!
name|soa_cnt
condition|)
name|gripe
operator|=
literal|"got RR before first SOA"
expr_stmt|;
else|else
name|gripe
operator|=
literal|"got RR after second SOA"
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s in zone %s"
argument_list|,
name|gripe
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* 	 * If they are trying to tell us info about something that is 	 * not in the zone that we are transfering, then ignore it! 	 * They don't have the authority to tell us this info. 	 * 	 * We have to do a bit of checking here - the name that we are 	 * checking is is fully qualified& may be in a subdomain of the 	 * zone in question.  We also need to ignore any final dots. 	 * 	 * If a domain has both NS records and non-NS records, (for 	 * example, NS and MX records), then we should ignore the non-NS 	 * records (except that we should not ignore glue A records). 	 * XXX: It is difficult to do this properly, so we just compare 	 * the current dname with that in the most recent NS record. 	 * This defends against the most common error case, 	 * where the remote server sends MX records soon after the 	 * NS records for a particular domain.  If sent earlier, we lose. XXX 	 */
if|if
condition|(
operator|!
name|ns_samedomain
argument_list|(
name|dname
argument_list|,
name|domain
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; Ignoring info about %s, not in zone %s.\n"
argument_list|,
name|dname
argument_list|,
name|domain
argument_list|)
expr_stmt|;
name|ignore
operator|=
literal|"; "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|type
operator|!=
name|T_NS
operator|&&
name|type
operator|!=
name|T_A
operator|&&
name|ns_samename
argument_list|(
name|zone_top
argument_list|,
name|dname
argument_list|)
operator|!=
literal|1
operator|&&
name|ns_samename
argument_list|(
name|prev_ns_dname
argument_list|,
name|dname
argument_list|)
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; Ignoring extra info about %s, invalid after NS delegation.\n"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|ignore
operator|=
literal|"; "
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|class
operator|!=
name|zp
operator|->
name|z_class
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; Ignoring info about %s, not class %s\n"
argument_list|,
name|dname
argument_list|,
name|p_class
argument_list|(
name|zp
operator|->
name|z_class
argument_list|)
argument_list|)
expr_stmt|;
name|ignore
operator|=
literal|"; "
expr_stmt|;
block|}
comment|/* 	 * If the current record is not being ignored, but the 	 * previous record was ignored, then we invalidate information 	 * that might have been altered by ignored records. 	 * (This means that we sometimes output unnecessary $ORIGIN 	 * lines, but that is harmless.) 	 *  	 * Also update prev_comment now. 	 */
if|if
condition|(
name|prev_comment
operator|&&
name|ignore
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|prev_dname
index|[
literal|0
index|]
operator|=
name|DEF_DNAME
expr_stmt|;
name|prev_origin
index|[
literal|0
index|]
operator|=
name|DEF_DNAME
expr_stmt|;
block|}
name|prev_comment
operator|=
operator|(
name|ignore
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
expr_stmt|;
comment|/* 	 * set prev_ns_dname if necessary 	 */
if|if
condition|(
name|type
operator|==
name|T_NS
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_ns_dname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the origin has changed, print the new origin 	 */
if|if
condition|(
name|ns_samename
argument_list|(
name|prev_origin
argument_list|,
name|origin
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s$ORIGIN %s.\n"
argument_list|,
name|ignore
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
name|tab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ns_samename
argument_list|(
name|prev_dname
argument_list|,
name|dname
argument_list|)
operator|!=
literal|1
condition|)
block|{
comment|/* 		 * set the prev_dname to be the current dname, then cut off all 		 * characters of dname after (and including) the first '.' 		 */
name|char
modifier|*
name|cutp
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_dname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|escaped
operator|=
literal|0
expr_stmt|;
name|cutp
operator|=
name|dname
expr_stmt|;
while|while
condition|(
operator|*
name|cutp
condition|)
block|{
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|*
name|cutp
operator|==
literal|'.'
condition|)
break|break;
name|escaped
operator|=
operator|(
operator|*
name|cutp
operator|++
operator|==
literal|'\\'
operator|)
operator|&&
operator|!
name|escaped
expr_stmt|;
block|}
operator|*
name|cutp
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|origin
index|[
literal|0
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s.\t"
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s.%s.\t"
argument_list|,
name|ignore
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* ??? */
block|}
else|else
block|{
name|char
modifier|*
name|backslash
decl_stmt|;
name|backslash
operator|=
operator|(
operator|*
name|dname
operator|==
literal|'@'
operator|||
operator|*
name|dname
operator|==
literal|'$'
operator|)
condition|?
literal|"\\"
else|:
literal|""
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s%s%s\t"
argument_list|,
name|ignore
argument_list|,
name|backslash
argument_list|,
name|dname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strlen
argument_list|(
name|dname
argument_list|)
operator|<
operator|(
name|size_t
operator|)
literal|8
condition|)
name|tab
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t"
argument_list|,
name|ignore
argument_list|)
expr_stmt|;
name|tab
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%d\t"
argument_list|,
operator|(
name|int
operator|)
name|ttl
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t%s\t"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
name|cdata
expr_stmt|;
comment|/* 	 * Print type specific data 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
case|case
name|C_HS
case|:
name|fputs
argument_list|(
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
name|cp
argument_list|)
argument_list|)
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
name|cp
operator|=
name|cdata
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
case|case
name|T_ISDN
case|:
name|cp2
operator|=
name|cp
operator|+
name|n
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|n
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
name|cp1
operator|=
name|cp
operator|+
name|n
expr_stmt|;
if|if
condition|(
name|cp1
operator|>
name|cp2
condition|)
name|cp1
operator|=
name|cp2
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|cp
operator|=
name|cp1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|strchr
argument_list|(
literal|"\n\"\\"
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
operator|(
name|type
operator|!=
name|T_ISDN
operator|||
name|i
operator|==
literal|0
operator|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'?'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s. (\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|NS_GET32
argument_list|(
name|tmpnum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t\t%u"
argument_list|,
name|ignore
argument_list|,
name|tmpnum
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|tmpnum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u"
argument_list|,
name|tmpnum
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|tmpnum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u"
argument_list|,
name|tmpnum
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|tmpnum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u"
argument_list|,
name|tmpnum
argument_list|)
expr_stmt|;
name|NS_GET32
argument_list|(
name|tmpnum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u )\n"
argument_list|,
name|tmpnum
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
case|case
name|T_AFSDB
case|:
case|case
name|T_RT
case|:
name|NS_GET16
argument_list|(
name|tmpnum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%u"
argument_list|,
name|tmpnum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_PX
case|:
name|NS_GET16
argument_list|(
name|tmpnum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%u"
argument_list|,
name|tmpnum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
case|case
name|T_X25
case|:
name|cp1
operator|=
name|cp
operator|+
name|n
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
operator|&&
name|cp
operator|<
name|cp1
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"\n\"\\"
argument_list|,
operator|*
name|cp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|<
name|cp1
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NSAP
case|:
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|inet_nsap_ntoa
argument_list|(
name|n
argument_list|,
name|cp
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_AAAA
case|:
block|{
name|char
name|t
index|[
sizeof|sizeof
expr|"ffff:ffff:ffff:ffff:ffff:ffff:255.255.255.255"]
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
name|cp
argument_list|,
name|t
argument_list|,
sizeof|sizeof
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_LOC
case|:
block|{
name|char
name|t
index|[
literal|255
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|loc_ntoa
argument_list|(
name|cp
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_NAPTR
case|:
block|{
name|u_int32_t
name|order
decl_stmt|,
name|preference
decl_stmt|;
comment|/* Order */
name|NS_GET16
argument_list|(
name|order
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%u"
argument_list|,
name|order
argument_list|)
expr_stmt|;
comment|/* Preference */
name|NS_GET16
argument_list|(
name|preference
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u"
argument_list|,
name|preference
argument_list|)
expr_stmt|;
comment|/* Flags */
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" \"%.*s\""
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
comment|/* Service */
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" \"%.*s\""
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
comment|/* Regexp */
if|if
condition|(
operator|(
name|n
operator|=
operator|*
name|cp
operator|++
operator|)
operator|!=
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" \"%.*s\""
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
comment|/* Replacement */
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_SRV
case|:
block|{
name|u_int
name|priority
decl_stmt|,
name|weight
decl_stmt|,
name|port
decl_stmt|;
name|NS_GET16
argument_list|(
name|priority
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|weight
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|NS_GET16
argument_list|(
name|port
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\t%u %u %u %s.\n"
argument_list|,
name|priority
argument_list|,
name|weight
argument_list|,
name|port
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_WKS
case|:
name|fputs
argument_list|(
name|inet_ntoa
argument_list|(
name|ina_get
argument_list|(
name|cp
argument_list|)
argument_list|)
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INADDRSZ
expr_stmt|;
name|fputc
argument_list|(
literal|' '
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|proto
operator|=
name|protocolname
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s "
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cdata
operator|+
name|n
condition|)
block|{
name|j
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|j
operator|&
literal|0200
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s"
argument_list|,
name|servicename
argument_list|(
name|i
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|&
literal|07
condition|)
do|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_RP
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_KEY
case|:
block|{
name|char
name|databuf
index|[
literal|16
operator|+
name|NS_MD5RSA_MAX_BASE64
index|]
decl_stmt|;
comment|/* 16 for slop */
name|u_int
name|keyflags
decl_stmt|;
comment|/* get& format key flags */
name|keyflags
operator|=
name|ns_get16
argument_list|(
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"0x%04x "
argument_list|,
name|keyflags
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* protocol id */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/* algorithm id */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u "
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/* key itself (which may have zero length) */
name|n
operator|=
name|b64_ntop
argument_list|(
name|cp
argument_list|,
operator|(
name|cp1
operator|+
name|n
operator|)
operator|-
name|cp
argument_list|,
name|databuf
argument_list|,
sizeof|sizeof
name|databuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; BAD BASE64\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_SIG
case|:
block|{
name|char
name|databuf
index|[
literal|16
operator|+
name|NS_MD5RSA_MAX_BASE64
index|]
decl_stmt|;
comment|/* 16 for slop */
comment|/* get& format rr type which signature covers */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s"
argument_list|,
name|p_type
argument_list|(
name|ns_get16
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* algorithm id */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/* labels (# of labels in name) */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %d"
argument_list|,
operator|*
name|cp
operator|++
argument_list|)
expr_stmt|;
comment|/* orig time to live (TTL)) */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %u"
argument_list|,
operator|(
name|u_int32_t
operator|)
name|ns_get32
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* expiration time */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s"
argument_list|,
name|p_secstodate
argument_list|(
name|ns_get32
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* time signed */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s"
argument_list|,
name|p_secstodate
argument_list|(
name|ns_get32
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT32SZ
expr_stmt|;
comment|/* Key footprint */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %d"
argument_list|,
name|ns_get16
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* signer's name */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s. "
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* signature itself */
name|n
operator|=
name|b64_ntop
argument_list|(
name|cp
argument_list|,
operator|(
name|cdata
operator|+
name|n
operator|)
operator|-
name|cp
argument_list|,
name|databuf
argument_list|,
sizeof|sizeof
name|databuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"; BAD BASE64\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|T_NXT
case|:
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|cp
operator|+=
name|i
expr_stmt|;
name|n
operator|-=
name|i
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|*
name|NS_NXT_BITS
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|NS_NXT_BIT_ISSET
argument_list|(
name|i
argument_list|,
name|cp
argument_list|)
condition|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s"
argument_list|,
name|p_type
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|ns_t_cert
case|:
block|{
name|int
name|databufsize
init|=
name|n
operator|*
literal|4
operator|/
literal|3
operator|+
literal|4
decl_stmt|;
name|char
modifier|*
name|databuf
init|=
name|malloc
argument_list|(
name|databufsize
argument_list|)
decl_stmt|;
if|if
condition|(
name|databuf
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"cert malloc failed"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Object id */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%d "
argument_list|,
name|ns_get16
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* Key tag */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%d "
argument_list|,
name|ns_get16
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|INT16SZ
expr_stmt|;
comment|/* Algorithm id */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%d "
argument_list|,
operator|(
name|u_char
operator|)
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
name|n
operator|=
name|b64_ntop
argument_list|(
name|cp
argument_list|,
name|n
operator|-
literal|2
operator|*
name|INT16SZ
operator|-
literal|1
argument_list|,
name|databuf
argument_list|,
name|databufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|panic
argument_list|(
literal|"cert b64_ntop failed"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\n"
argument_list|,
name|databuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|databuf
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|cp1
operator|=
name|cp
operator|+
name|n
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
condition|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"0x%02.2X "
argument_list|,
operator|*
name|cp
operator|++
operator|&
literal|0xFF
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"???\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|dbfp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|cleanup_for_exit
argument_list|()
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SHORT_FNAMES
end_ifdef

begin_comment
comment|/* ** This routine handles creating temporary files with mkstemp ** in the presence of a 14 char filename system.  Pathconf() ** does not work over NFS. */
end_comment

begin_macro
name|filenamecpy
argument_list|(
argument|char *ddtfile
argument_list|,
argument|char *optarg
argument_list|)
end_macro

begin_block
block|{
name|int
name|namelen
decl_stmt|,
name|extra
decl_stmt|,
name|len
decl_stmt|;
name|char
modifier|*
name|dirname
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
comment|/* determine the length of filename allowed */
if|if
condition|(
operator|(
name|dirname
operator|=
name|strrchr
argument_list|(
name|optarg
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|filename
operator|=
name|optarg
expr_stmt|;
block|}
else|else
block|{
operator|*
name|dirname
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|filename
operator|=
name|dirname
expr_stmt|;
block|}
name|namelen
operator|=
name|pathconf
argument_list|(
name|dirname
operator|==
name|NULL
condition|?
literal|"."
else|:
name|optarg
argument_list|,
name|_PC_NAME_MAX
argument_list|)
expr_stmt|;
if|if
condition|(
name|namelen
operator|<=
literal|0
condition|)
name|namelen
operator|=
literal|255
expr_stmt|;
comment|/* length could not be determined */
if|if
condition|(
name|dirname
operator|!=
name|NULL
condition|)
operator|*
operator|--
name|dirname
operator|=
literal|'/'
expr_stmt|;
comment|/* copy a shorter name if it will be longer than allowed */
name|extra
operator|=
operator|(
name|strlen
argument_list|(
name|filename
argument_list|)
operator|+
name|strlen
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|)
operator|-
name|namelen
expr_stmt|;
if|if
condition|(
name|extra
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|-
name|extra
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ddtfile
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SHORT_FNAMES */
end_comment

begin_function
name|DST_KEY
modifier|*
name|tsig_key_from_addr
parameter_list|(
name|struct
name|in_addr
name|addr
parameter_list|)
block|{
name|tsig_node
modifier|*
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
name|HEAD
argument_list|(
name|tsig_list
argument_list|)
init|;
name|n
operator|!=
name|NULL
condition|;
name|n
operator|=
name|NEXT
argument_list|(
name|n
argument_list|,
name|link
argument_list|)
control|)
if|if
condition|(
name|memcpy
argument_list|(
operator|&
name|addr
argument_list|,
operator|&
name|n
operator|->
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|in_addr
argument_list|)
argument_list|)
condition|)
return|return
name|n
operator|->
name|dst_key
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|u_int32_t
name|do_section
parameter_list|(
name|ns_msg
modifier|*
name|handle
parameter_list|,
name|ns_sect
name|section
parameter_list|,
name|int
name|pflag
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|int
modifier|*
name|delete
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|sflag
decl_stmt|,
name|rrnum
decl_stmt|;
name|char
name|buf
index|[
literal|2048
index|]
decl_stmt|;
comment|/* XXX need to malloc */
name|ns_opcode
name|opcode
decl_stmt|;
name|ns_rr
name|rr
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|cp
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|eom
decl_stmt|;
name|u_int32_t
name|serial
decl_stmt|;
name|time_t
name|now
decl_stmt|;
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
comment|/* 	 * Print answer records. 	 */
name|sflag
operator|=
operator|(
name|_res
operator|.
name|pfcode
operator|&
name|pflag
operator|)
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|pfcode
operator|&&
operator|!
name|sflag
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|opcode
operator|=
operator|(
name|ns_opcode
operator|)
name|ns_msg_getflag
argument_list|(
operator|*
name|handle
argument_list|,
name|ns_f_opcode
argument_list|)
expr_stmt|;
name|rrnum
operator|=
literal|0
expr_stmt|;
name|serial
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|ns_parserr
argument_list|(
name|handle
argument_list|,
name|section
argument_list|,
name|rrnum
argument_list|,
operator|&
name|rr
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENODEV
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ns_parserr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|rrnum
operator|>
literal|0
operator|&&
name|sflag
operator|!=
literal|0
operator|&&
operator|(
name|_res
operator|.
name|pfcode
operator|&
name|RES_PRF_HEAD1
operator|)
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
return|return
operator|(
name|serial
operator|)
return|;
block|}
if|if
condition|(
name|rrnum
operator|==
literal|0
operator|&&
name|sflag
operator|!=
literal|0
operator|&&
operator|(
name|_res
operator|.
name|pfcode
operator|&
name|RES_PRF_HEAD1
operator|)
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; %s SECTION:\n"
argument_list|,
name|p_section
argument_list|(
name|section
argument_list|,
name|opcode
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|section
operator|==
name|ns_s_qd
condition|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";;\t%s, type = %s, class = %s\n"
argument_list|,
name|ns_rr_name
argument_list|(
name|rr
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|ns_rr_type
argument_list|(
name|rr
argument_list|)
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|ns_rr_class
argument_list|(
name|rr
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|print_record
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|rr
operator|.
name|type
operator|==
name|ns_t_soa
condition|)
block|{
name|print_record
operator|=
literal|0
expr_stmt|;
operator|*
name|delete
operator|=
operator|!
operator|*
name|delete
expr_stmt|;
name|cp
operator|=
name|ns_rr_rdata
argument_list|(
name|rr
argument_list|)
expr_stmt|;
name|eom
operator|=
name|cp
operator|+
name|ns_rr_rdlen
argument_list|(
name|rr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|rrnum
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|rrnum
operator|++
expr_stmt|;
continue|continue;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|NS_GET32
argument_list|(
name|serial
argument_list|,
name|cp
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|++
name|ixfr_soa
condition|)
block|{
case|case
literal|1
case|:
name|final_serial
operator|=
name|serial
expr_stmt|;
if|if
condition|(
name|soa_buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|soa_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|PACKETSZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"malloc(%u) failed"
argument_list|,
literal|2
operator|*
name|PACKETSZ
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|n
operator|=
name|ns_sprintrr
argument_list|(
name|handle
argument_list|,
operator|&
name|rr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|soa_buf
argument_list|,
literal|2
operator|*
name|PACKETSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ns_sprintrr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
name|print_record
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"zone:\torigin %s class %s serial %u\n"
argument_list|,
name|ns_rr_name
argument_list|(
name|rr
argument_list|)
argument_list|,
name|p_class
argument_list|(
name|ns_rr_class
argument_list|(
name|rr
argument_list|)
argument_list|)
argument_list|,
name|serial
argument_list|)
expr_stmt|;
name|print_record
operator|=
literal|0
expr_stmt|;
break|break;
default|default:
name|print_record
operator|=
literal|0
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|print_record
condition|)
block|{
if|if
condition|(
name|rr
operator|.
name|type
operator|!=
name|ns_t_soa
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"update:\t{%s} "
argument_list|,
operator|*
name|delete
condition|?
literal|"delete"
else|:
literal|"add"
argument_list|)
expr_stmt|;
name|n
operator|=
name|ns_sprintrr
argument_list|(
name|handle
argument_list|,
operator|&
name|rr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ns_sprintrr: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|fputs
argument_list|(
name|buf
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|rrnum
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|serial
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|ixfr_log
parameter_list|(
specifier|const
name|u_char
modifier|*
name|msg
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|delete
parameter_list|,
name|FILE
modifier|*
name|file
parameter_list|,
name|struct
name|sockaddr_in
modifier|*
name|sin
parameter_list|,
name|char
modifier|*
name|domain
parameter_list|,
name|u_int32_t
modifier|*
name|serial_no
parameter_list|,
name|int
modifier|*
name|first_rr
parameter_list|)
block|{
name|ns_msg
name|handle
decl_stmt|;
name|ns_type
name|type
decl_stmt|;
name|ns_class
name|class
decl_stmt|;
name|ns_opcode
name|opcode
decl_stmt|;
name|ns_rcode
name|rcode
decl_stmt|;
name|u_int
name|id
decl_stmt|,
name|n
decl_stmt|;
name|char
name|time
index|[
literal|25
index|]
decl_stmt|;
name|ns_rr
name|rr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|HEADER
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|_res
operator|.
name|options
operator|&
name|RES_INIT
operator|)
operator|==
literal|0
operator|&&
name|res_init
argument_list|()
operator|==
operator|-
literal|1
condition|)
block|{
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"ixfr_log() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ns_initparse
argument_list|(
name|msg
argument_list|,
name|len
argument_list|,
operator|&
name|handle
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|file
argument_list|,
literal|";; ns_initparse: %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"ixfr_log() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|opcode
operator|=
operator|(
name|ns_opcode
operator|)
name|ns_msg_getflag
argument_list|(
name|handle
argument_list|,
name|ns_f_opcode
argument_list|)
expr_stmt|;
name|rcode
operator|=
operator|(
name|ns_rcode
operator|)
name|ns_msg_getflag
argument_list|(
name|handle
argument_list|,
name|ns_f_rcode
argument_list|)
expr_stmt|;
name|id
operator|=
name|ns_msg_id
argument_list|(
name|handle
argument_list|)
expr_stmt|;
if|if
condition|(
name|ns_parserr
argument_list|(
operator|&
name|handle
argument_list|,
name|ns_s_an
argument_list|,
literal|0
argument_list|,
operator|&
name|rr
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"ns_parserr() failed"
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|1
argument_list|,
literal|"ixfr_log() failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|type
operator|=
operator|(
name|ns_type
operator|)
name|rr
operator|.
name|type
expr_stmt|;
name|class
operator|=
operator|(
name|ns_class
operator|)
name|rr
operator|.
name|rr_class
expr_stmt|;
if|if
condition|(
operator|*
name|first_rr
operator|==
literal|1
condition|)
block|{
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"%s"
argument_list|,
name|LogSignature
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|time
argument_list|,
literal|"at %lu"
argument_list|,
operator|(
name|u_long
operator|)
name|tt
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|file
argument_list|,
literal|"[IXFR_UPDATE] id %u from [%s].%d %s (named-xfer pid %ld):\n"
argument_list|,
name|id
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
argument_list|,
name|time
argument_list|,
operator|(
name|long
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
operator|*
name|first_rr
operator|)
operator|++
expr_stmt|;
block|}
operator|*
name|serial_no
operator|=
name|do_section
argument_list|(
operator|&
name|handle
argument_list|,
name|ns_s_an
argument_list|,
name|RES_PRF_ANS
argument_list|,
name|file
argument_list|,
name|delete
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tsig_rcode
parameter_list|(
name|int
name|rcode
parameter_list|)
block|{
specifier|static
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|rcode
condition|)
block|{
case|case
name|ns_r_badkey
case|:
case|case
name|ns_r_badsig
case|:
case|case
name|ns_r_badtime
case|:
name|sprintf
argument_list|(
name|buffer
argument_list|,
literal|"message had %s set"
argument_list|,
name|p_rcode
argument_list|(
name|rcode
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|buffer
operator|)
return|;
case|case
operator|-
name|ns_r_badkey
case|:
case|case
operator|-
name|ns_r_badsig
case|:
case|case
operator|-
name|ns_r_badtime
case|:
return|return
operator|(
name|p_rcode
argument_list|(
operator|-
name|rcode
argument_list|)
operator|)
return|;
case|case
name|NS_TSIG_ERROR_NO_TSIG
case|:
return|return
operator|(
literal|"no TSIG present"
operator|)
return|;
default|default:
break|break;
block|}
return|return
operator|(
literal|"FORMERR"
operator|)
return|;
block|}
end_function

end_unit

