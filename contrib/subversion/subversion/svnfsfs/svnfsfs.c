begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnfsfs.c: FSFS repository manipulation tool main file.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_cache_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svnfsfs.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* A flag to see if we've been cancelled by the client or not. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|cancelled
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A signal handler to support cancellation. */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|signum
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cancelled
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A helper to set up the cancellation signal handlers. */
end_comment

begin_function
specifier|static
name|void
name|setup_cancellation_signals
parameter_list|(
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
name|signum
parameter_list|)
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBREAK
comment|/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */
name|apr_signal
argument_list|(
name|SIGBREAK
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|apr_signal
argument_list|(
name|SIGHUP
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|apr_signal
argument_list|(
name|SIGTERM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|check_cancel
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
if|if
condition|(
name|cancelled
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Caught signal"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Custom filesystem warning function. */
end_comment

begin_function
specifier|static
name|void
name|warning_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|err
condition|)
return|return;
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svnfsfs: "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_repos"
block|,
name|svn_repos_version
block|}
block|,
block|{
literal|"svn_fs"
block|,
name|svn_fs_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Subcommands. **/
end_comment

begin_enum
enum|enum
name|svnfsfs__cmdline_options_t
block|{
name|svnfsfs__version
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|}
enum|;
end_enum

begin_comment
comment|/* Option codes and descriptions.  *  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|options_table
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
literal|"version"
block|,
name|svnfsfs__version
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
block|,
block|{
literal|"quiet"
block|,
literal|'q'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"no progress (only errors to stderr)"
argument_list|)
block|}
block|,
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify revision number ARG (or X:Y range)"
argument_list|)
block|}
block|,
block|{
literal|"memory-cache-size"
block|,
literal|'M'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"size of the extra in-memory cache in MB used to\n"
literal|"                             minimize redundant operations. Default: 16."
argument_list|)
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of available subcommands.  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|cmd_table
index|[]
init|=
block|{
block|{
literal|"help"
block|,
name|subcommand__help
block|,
block|{
literal|"?"
block|,
literal|"h"
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnfsfs help [SUBCOMMAND...]\n\n"
literal|"Describe the usage of this program or its subcommands.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"dump-index"
block|,
name|subcommand__dump_index
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnfsfs dump-index REPOS_PATH -r REV\n\n"
literal|"Dump the index contents for the revision / pack file containing revision REV\n"
literal|"to console.  This is only available for FSFS format 7 (SVN 1.9+) repositories.\n"
literal|"The table produced contains a header in the first line followed by one line\n"
literal|"per index entry, ordered by location in the revision / pack file.  Columns:\n\n"
literal|"   * Byte offset (hex) at which the item starts\n"
literal|"   * Length (hex) of the item in bytes\n"
literal|"   * Item type (string) is one of the following:\n\n"
literal|"        none ... Unused section.  File contents shall be NULs.\n"
literal|"        frep ... File representation.\n"
literal|"        drep ... Directory representation.\n"
literal|"        fprop .. File property.\n"
literal|"        dprop .. Directory property.\n"
literal|"        node ... Node revision.\n"
literal|"        chgs ... Changed paths list.\n"
literal|"        rep .... Representation of unknown type.  Should not be used.\n"
literal|"        ??? .... Invalid.  Index data is corrupt.\n\n"
literal|"        The distinction between frep, drep, fprop and dprop is a mere internal\n"
literal|"        classification used for various optimizations and does not affect the\n"
literal|"        operational correctness.\n\n"
literal|"   * Revision that the item belongs to (decimal)\n"
literal|"   * Item number (decimal) within that revision\n"
literal|"   * Modified FNV1a checksum (8 hex digits)\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'M'
block|}
block|}
block|,
block|{
literal|"load-index"
block|,
name|subcommand__load_index
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnfsfs load-index REPOS_PATH\n\n"
literal|"Read index contents from console.  The format is the same as produced by the\n"
literal|"dump-index command, except that checksum as well as header are optional and will\n"
literal|"be ignored.  The data must cover the full revision / pack file;  the revision\n"
literal|"number is automatically extracted from input stream.  No ordering is required.\n"
argument_list|)
block|,
block|{
literal|'M'
block|}
block|}
block|,
block|{
literal|"stats"
block|,
name|subcommand__stats
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnfsfs stats REPOS_PATH\n\n"
literal|"Write object size statistics to console.\n"
argument_list|)
block|,
block|{
literal|'M'
block|}
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|open_fs
parameter_list|(
name|svn_fs_t
modifier|*
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fs_type
decl_stmt|;
comment|/* Verify that we can handle the repository type. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
literal|"db"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_type
argument_list|(
operator|&
name|fs_type
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fs_type
argument_list|,
name|SVN_FS_TYPE_FSFS
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_TYPE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s repositories are not supported"
argument_list|)
argument_list|,
name|fs_type
argument_list|)
return|;
comment|/* Now open it. */
name|SVN_ERR
argument_list|(
name|svn_fs_open2
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_set_warning_func
argument_list|(
operator|*
name|fs
argument_list|,
name|warning_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|subcommand__help
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svnfsfs__opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
init|=
name|_
argument_list|(
literal|"general usage: svnfsfs SUBCOMMAND REPOS_PATH  [ARGS& OPTIONS ...]\n"
literal|"Subversion FSFS repository manipulation tool.\n"
literal|"Type 'svnfsfs help<subcommand>' for help on a specific subcommand.\n"
literal|"Type 'svnfsfs --version' to see the program version.\n"
literal|"\n"
literal|"Available subcommands:\n"
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_print_help4
argument_list|(
name|os
argument_list|,
literal|"svnfsfs"
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|version
else|:
name|FALSE
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|quiet
else|:
name|FALSE
argument_list|,
comment|/*###opt_state ? opt_state->verbose :*/
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|header
argument_list|,
name|cmd_table
argument_list|,
name|options_table
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Main. **/
end_comment

begin_comment
comment|/*  * On success, leave *EXIT_CODE untouched and return SVN_NO_ERROR. On error,  * either return an error to be displayed, or set *EXIT_CODE to non-zero and  * return SVN_NO_ERROR.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sub_main
parameter_list|(
name|int
modifier|*
name|exit_code
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|subcommand
init|=
name|NULL
decl_stmt|;
name|svnfsfs__opt_state
name|opt_state
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|int
name|opt_id
decl_stmt|;
name|apr_array_header_t
modifier|*
name|received_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|received_opts
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|SVN_OPT_MAX_OPTIONS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check library versions */
name|SVN_ERR
argument_list|(
name|check_lib_versions
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Initialize the FS library. */
name|SVN_ERR
argument_list|(
name|svn_fs_initialize
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|subcommand__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Initialize opt_state. */
name|opt_state
operator|.
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_state
operator|.
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_state
operator|.
name|memory_cache_size
operator|=
name|svn_cache_config_get
argument_list|()
operator|->
name|cache_size
expr_stmt|;
comment|/* Parse options. */
name|SVN_ERR
argument_list|(
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8_opt_arg
decl_stmt|;
comment|/* Parse the next option. */
name|apr_err
operator|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|options_table
argument_list|,
operator|&
name|opt_id
argument_list|,
operator|&
name|opt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|apr_err
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|subcommand__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Stash the option code in an array before parsing it. */
name|APR_ARRAY_PUSH
argument_list|(
name|received_opts
argument_list|,
name|int
argument_list|)
operator|=
name|opt_id
expr_stmt|;
switch|switch
condition|(
name|opt_id
condition|)
block|{
case|case
literal|'r'
case|:
block|{
if|if
condition|(
name|opt_state
operator|.
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Multiple revision arguments encountered; "
literal|"try '-r N:M' instead of '-r N -r M'"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|svn_opt_parse_revision
argument_list|(
operator|&
operator|(
name|opt_state
operator|.
name|start_revision
operator|)
argument_list|,
operator|&
operator|(
name|opt_state
operator|.
name|end_revision
operator|)
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Syntax error in revision argument '%s'"
argument_list|)
argument_list|,
name|utf8_opt_arg
argument_list|)
return|;
block|}
block|}
break|break;
case|case
literal|'q'
case|:
name|opt_state
operator|.
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|opt_state
operator|.
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|opt_state
operator|.
name|memory_cache_size
operator|=
literal|0x100000
operator|*
name|apr_strtoi64
argument_list|(
name|opt_arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnfsfs__version
case|:
name|opt_state
operator|.
name|version
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
block|{
name|SVN_ERR
argument_list|(
name|subcommand__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* close `switch' */
block|}
comment|/* close `while' */
comment|/* If the user asked for help, then the rest of the arguments are      the names of subcommands to get help on (if any), or else they're      just typos/mistakes.  Whatever the case, the subcommand to      actually run is subcommand_help(). */
if|if
condition|(
name|opt_state
operator|.
name|help
condition|)
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
comment|/* If we're not running the `help' subcommand, then look for a      subcommand in the first argument. */
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|version
condition|)
block|{
comment|/* Use the "help" subcommand to handle the "--version" option. */
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|pseudo_cmd
init|=
block|{
literal|"--version"
block|,
name|subcommand__help
block|,
block|{
literal|0
block|}
block|,
literal|""
block|,
block|{
name|svnfsfs__version
block|,
comment|/* must accept its own option */
literal|'q'
block|,
comment|/* --quiet */
block|}
block|}
decl_stmt|;
name|subcommand
operator|=
operator|&
name|pseudo_cmd
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"subcommand argument required\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|subcommand__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|first_arg
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
decl_stmt|;
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|first_arg_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|first_arg_utf8
argument_list|,
name|first_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unknown subcommand: '%s'\n"
argument_list|)
argument_list|,
name|first_arg_utf8
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|subcommand__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
comment|/* Every subcommand except `help' requires a second argument -- the      repository path.  Parse it out here and store it in opt_state. */
if|if
condition|(
operator|!
operator|(
name|subcommand
operator|->
name|cmd_func
operator|==
name|subcommand__help
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_path
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Repository argument required"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|repos_path
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|repos_path
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is a URL when it should be a "
literal|"local path"
argument_list|)
argument_list|,
name|repos_path
argument_list|)
return|;
block|}
name|opt_state
operator|.
name|repository_path
operator|=
name|svn_dirent_internal_style
argument_list|(
name|repos_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Check that the subcommand wasn't passed any inappropriate options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|received_opts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|opt_id
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|received_opts
argument_list|,
name|i
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* All commands implicitly accept --help, so just skip over this          when we see it. Note that we don't want to include this option          in their "accepted options" list because it would be awfully          redundant to display it in every commands' help text. */
if|if
condition|(
name|opt_id
operator|==
literal|'h'
operator|||
name|opt_id
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|svn_opt_subcommand_takes_option3
argument_list|(
name|subcommand
argument_list|,
name|opt_id
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|badopt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|opt_id
argument_list|,
name|options_table
argument_list|,
name|subcommand
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|badopt
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|SVN_ERR
argument_list|(
name|subcommand__help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand '%s' doesn't accept option '%s'\n"
literal|"Type 'svnfsfs help %s' for usage.\n"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|,
name|optstr
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Set up our cancellation support. */
name|setup_cancellation_signals
argument_list|(
name|signal_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it, otherwise    * working with large files when compiled against an APR that doesn't have    * large file support will crash the program, which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Configure FSFS caches for maximum efficiency with svnfsfs.    * Also, apply the respective command line parameters, if given. */
block|{
name|svn_cache_config_t
name|settings
init|=
operator|*
name|svn_cache_config_get
argument_list|()
decl_stmt|;
name|settings
operator|.
name|cache_size
operator|=
name|opt_state
operator|.
name|memory_cache_size
expr_stmt|;
name|settings
operator|.
name|single_threaded
operator|=
name|TRUE
expr_stmt|;
name|svn_cache_config_set
argument_list|(
operator|&
name|settings
argument_list|)
expr_stmt|;
block|}
comment|/* Run the subcommand. */
name|err
operator|=
call|(
modifier|*
name|subcommand
operator|->
name|cmd_func
call|)
argument_list|(
name|os
argument_list|,
operator|&
name|opt_state
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* For argument-related problems, suggest using the 'help'          subcommand. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_INSUFFICIENT_ARGS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_ARG_PARSING_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Try 'svnfsfs help' for more info"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|int
name|exit_code
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnfsfs"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|sub_main
argument_list|(
operator|&
name|exit_code
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Flush stdout and report if it fails. It would be flushed on exit anyway      but this makes sure that output is not silently lost if it fails. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
literal|"svnfsfs: "
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

end_unit

