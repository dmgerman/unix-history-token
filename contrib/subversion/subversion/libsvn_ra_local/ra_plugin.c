begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ra_plugin.c : the main RA module for local repository access  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"ra_local.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_cache_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_repos_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Miscellaneous helper functions ***/
end_comment

begin_comment
comment|/* Pool cleanup handler: ensure that the access descriptor of the    filesystem (svn_fs_t *) DATA is set to NULL. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cleanup_access
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|serr
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|data
decl_stmt|;
name|serr
operator|=
name|svn_fs_set_access
argument_list|(
name|fs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|serr
condition|)
block|{
name|apr_status_t
name|apr_err
init|=
name|serr
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|serr
argument_list|)
expr_stmt|;
return|return
name|apr_err
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Fetch a username for use with SESSION, and store it in SESSION->username.  *  * Allocate the username in SESSION->pool.  Use SCRATCH_POOL for temporary  * allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_username
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
comment|/* If we've already found the username don't ask for it again. */
if|if
condition|(
operator|!
name|sess
operator|->
name|username
condition|)
block|{
comment|/* Get a username somehow, so we have some svn:author property to          attach to a commit. */
if|if
condition|(
name|sess
operator|->
name|callbacks
operator|->
name|auth_baton
condition|)
block|{
name|void
modifier|*
name|creds
decl_stmt|;
name|svn_auth_cred_username_t
modifier|*
name|username_creds
decl_stmt|;
name|svn_auth_iterstate_t
modifier|*
name|iterstate
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_auth_first_credentials
argument_list|(
operator|&
name|creds
argument_list|,
operator|&
name|iterstate
argument_list|,
name|SVN_AUTH_CRED_USERNAME
argument_list|,
name|sess
operator|->
name|uuid
argument_list|,
comment|/* realmstring */
name|sess
operator|->
name|callbacks
operator|->
name|auth_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No point in calling next_creds(), since that assumes that the              first_creds() somehow failed to authenticate.  But there's no              challenge going on, so we use whatever creds we get back on              the first try. */
name|username_creds
operator|=
name|creds
expr_stmt|;
if|if
condition|(
name|username_creds
operator|&&
name|username_creds
operator|->
name|username
condition|)
block|{
name|sess
operator|->
name|username
operator|=
name|apr_pstrdup
argument_list|(
name|session
operator|->
name|pool
argument_list|,
name|username_creds
operator|->
name|username
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_auth_save_credentials
argument_list|(
name|iterstate
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|sess
operator|->
name|username
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|sess
operator|->
name|username
operator|=
literal|""
expr_stmt|;
block|}
comment|/* If we have a real username, attach it to the filesystem so that it can      be used to validate locks.  Even if there already is a user context      associated, it may contain irrelevant lock tokens, so always create a new.   */
if|if
condition|(
operator|*
name|sess
operator|->
name|username
condition|)
block|{
name|svn_fs_access_t
modifier|*
name|access_ctx
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_create_access
argument_list|(
operator|&
name|access_ctx
argument_list|,
name|sess
operator|->
name|username
argument_list|,
name|session
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_set_access
argument_list|(
name|sess
operator|->
name|fs
argument_list|,
name|access_ctx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure this context is disassociated when the pool gets          destroyed. */
name|apr_pool_cleanup_register
argument_list|(
name|session
operator|->
name|pool
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|cleanup_access
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements an svn_atomic__init_once callback.  Sets the FSFS memory    cache size. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cache_init
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|config_hash
init|=
name|baton
decl_stmt|;
name|svn_config_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|memory_cache_size_str
decl_stmt|;
if|if
condition|(
name|config_hash
condition|)
name|config
operator|=
name|svn_hash_gets
argument_list|(
name|config_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|config
argument_list|,
operator|&
name|memory_cache_size_str
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_MEMORY_CACHE_SIZE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|memory_cache_size_str
condition|)
block|{
name|apr_uint64_t
name|memory_cache_size
decl_stmt|;
name|svn_cache_config_t
name|settings
init|=
operator|*
name|svn_cache_config_get
argument_list|()
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_quick_wrap
argument_list|(
name|svn_cstring_atoui64
argument_list|(
operator|&
name|memory_cache_size
argument_list|,
name|memory_cache_size_str
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"memory-cache-size invalid"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|settings
operator|.
name|cache_size
operator|=
literal|1024
operator|*
literal|1024
operator|*
name|memory_cache_size
expr_stmt|;
name|svn_cache_config_set
argument_list|(
operator|&
name|settings
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** The reporter vtable needed by do_update() and friends ***/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reporter_baton_t
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
decl_stmt|;
name|void
modifier|*
name|report_baton
decl_stmt|;
block|}
name|reporter_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
modifier|*
name|make_reporter_baton
parameter_list|(
name|svn_ra_local__session_baton_t
modifier|*
name|sess
parameter_list|,
name|void
modifier|*
name|report_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|reporter_baton_t
modifier|*
name|rbaton
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rbaton
argument_list|)
argument_list|)
decl_stmt|;
name|rbaton
operator|->
name|sess
operator|=
name|sess
expr_stmt|;
name|rbaton
operator|->
name|report_baton
operator|=
name|report_baton
expr_stmt|;
return|return
name|rbaton
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_set_path
parameter_list|(
name|void
modifier|*
name|reporter_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|reporter_baton_t
modifier|*
name|rbaton
init|=
name|reporter_baton
decl_stmt|;
return|return
name|svn_repos_set_path3
argument_list|(
name|rbaton
operator|->
name|report_baton
argument_list|,
name|path
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_delete_path
parameter_list|(
name|void
modifier|*
name|reporter_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|reporter_baton_t
modifier|*
name|rbaton
init|=
name|reporter_baton
decl_stmt|;
return|return
name|svn_repos_delete_path
argument_list|(
name|rbaton
operator|->
name|report_baton
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_link_path
parameter_list|(
name|void
modifier|*
name|reporter_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|reporter_baton_t
modifier|*
name|rbaton
init|=
name|reporter_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_url
init|=
name|rbaton
operator|->
name|sess
operator|->
name|repos_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
if|if
condition|(
operator|!
name|relpath
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s'\n"
literal|"is not the same repository as\n"
literal|"'%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|rbaton
operator|->
name|sess
operator|->
name|repos_url
argument_list|)
return|;
comment|/* Convert the relpath to an fspath */
if|if
condition|(
name|relpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|fs_path
operator|=
literal|"/"
expr_stmt|;
else|else
name|fs_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|relpath
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_repos_link_path3
argument_list|(
name|rbaton
operator|->
name|report_baton
argument_list|,
name|path
argument_list|,
name|fs_path
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_finish_report
parameter_list|(
name|void
modifier|*
name|reporter_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|reporter_baton_t
modifier|*
name|rbaton
init|=
name|reporter_baton
decl_stmt|;
return|return
name|svn_repos_finish_report
argument_list|(
name|rbaton
operator|->
name|report_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reporter_abort_report
parameter_list|(
name|void
modifier|*
name|reporter_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|reporter_baton_t
modifier|*
name|rbaton
init|=
name|reporter_baton
decl_stmt|;
return|return
name|svn_repos_abort_report
argument_list|(
name|rbaton
operator|->
name|report_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra_reporter3_t
name|ra_local_reporter
init|=
block|{
name|reporter_set_path
block|,
name|reporter_delete_path
block|,
name|reporter_link_path
block|,
name|reporter_finish_report
block|,
name|reporter_abort_report
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ...  *  * Wrap a cancellation editor using SESSION's cancellation function around  * the supplied EDITOR.  ### Some callers (via svn_ra_do_update2() etc.)  * don't appear to know that we do this, and are supplying an editor that  * they have already wrapped with the same cancellation editor, so it ends  * up double-wrapped.  *  * Allocate @a *reporter and @a *report_baton in @a result_pool.  Use  * @a scratch_pool for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_reporter
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|other_url
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|void
modifier|*
name|rbaton
decl_stmt|;
specifier|const
name|char
modifier|*
name|other_fs_path
init|=
name|NULL
decl_stmt|;
comment|/* Get the HEAD revision if one is not supplied. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|revision
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If OTHER_URL was provided, validate it and convert it into a      regular filesystem path. */
if|if
condition|(
name|other_url
condition|)
block|{
specifier|const
name|char
modifier|*
name|other_relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|sess
operator|->
name|repos_url
argument_list|,
name|other_url
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Sanity check:  the other_url better be in the same repository as          the original session url! */
if|if
condition|(
operator|!
name|other_relpath
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s'\n"
literal|"is not the same repository as\n"
literal|"'%s'"
argument_list|)
argument_list|,
name|other_url
argument_list|,
name|sess
operator|->
name|repos_url
argument_list|)
return|;
name|other_fs_path
operator|=
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
literal|"/"
argument_list|,
name|other_relpath
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Pass back our reporter */
operator|*
name|reporter
operator|=
operator|&
name|ra_local_reporter
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_username
argument_list|(
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sess
operator|->
name|callbacks
condition|)
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|sess
operator|->
name|callbacks
operator|->
name|cancel_func
argument_list|,
name|sess
operator|->
name|callback_baton
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build a reporter baton. */
name|SVN_ERR
argument_list|(
name|svn_repos_begin_report3
argument_list|(
operator|&
name|rbaton
argument_list|,
name|revision
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|target
argument_list|,
name|other_fs_path
argument_list|,
name|text_deltas
argument_list|,
name|depth
argument_list|,
name|ignore_ancestry
argument_list|,
name|send_copyfrom_args
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|1024
operator|*
literal|1024
argument_list|,
comment|/* process-local transfers                                                    should be fast */
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wrap the report baton given us by the repos layer with our own      reporter baton. */
operator|*
name|report_baton
operator|=
name|make_reporter_baton
argument_list|(
name|sess
argument_list|,
name|rbaton
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Deltification stuff for get_commit_editor() ***/
end_comment

begin_struct
struct|struct
name|deltify_etc_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* the fs to deltify in */
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
comment|/* repos for unlocking */
specifier|const
name|char
modifier|*
name|fspath_base
decl_stmt|;
comment|/* fs-path part of split session URL */
name|apr_hash_t
modifier|*
name|lock_tokens
decl_stmt|;
comment|/* tokens to unlock, if any */
name|svn_commit_callback2_t
name|commit_cb
decl_stmt|;
comment|/* the original callback */
name|void
modifier|*
name|commit_baton
decl_stmt|;
comment|/* the original callback's baton */
block|}
struct|;
end_struct

begin_comment
comment|/* This implements 'svn_commit_callback_t'.  Its invokes the original    (wrapped) callback, but also does deltification on the new revision and    possibly unlocks committed paths.    BATON is 'struct deltify_etc_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|deltify_etc
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|deltify_etc_baton
modifier|*
name|deb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err1
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
comment|/* Invoke the original callback first, in case someone's waiting to      know the revision number so they can go off and annotate an      issue or something. */
if|if
condition|(
name|deb
operator|->
name|commit_cb
condition|)
name|err1
operator|=
name|deb
operator|->
name|commit_cb
argument_list|(
name|commit_info
argument_list|,
name|deb
operator|->
name|commit_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Maybe unlock the paths. */
if|if
condition|(
name|deb
operator|->
name|lock_tokens
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|deb
operator|->
name|lock_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|relpath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|fspath
operator|=
name|svn_fspath__join
argument_list|(
name|deb
operator|->
name|fspath_base
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* We may get errors here if the lock was broken or stolen              after the commit succeeded.  This is fine and should be              ignored. */
name|svn_error_clear
argument_list|(
name|svn_repos_fs_unlock
argument_list|(
name|deb
operator|->
name|repos
argument_list|,
name|fspath
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* But, deltification shouldn't be stopped just because someone's      random callback failed, so proceed unconditionally on to      deltification. */
name|err2
operator|=
name|svn_fs_deltify_revision
argument_list|(
name|deb
operator|->
name|fs
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err1
argument_list|,
name|err2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If LOCK_TOKENS is not NULL, then copy all tokens into the access context    of FS. The tokens' paths will be prepended with FSPATH_BASE.     ACCESS_POOL must match (or exceed) the lifetime of the access context    that was associated with FS. Typically, this is the session pool.     Temporary allocations are made in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_lock_tokens
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath_base
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|apr_pool_t
modifier|*
name|access_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|lock_tokens
condition|)
block|{
name|svn_fs_access_t
modifier|*
name|access_ctx
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_access
argument_list|(
operator|&
name|access_ctx
argument_list|,
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is no access context, the filesystem will scream if a          lock is needed.  */
if|if
condition|(
name|access_ctx
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Note: we have no use for an iterpool here since the data              within the loop is copied into ACCESS_POOL.  */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|lock_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|relpath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
decl_stmt|;
comment|/* The path needs to live as long as ACCESS_CTX.  */
name|fspath
operator|=
name|svn_fspath__join
argument_list|(
name|fspath_base
argument_list|,
name|relpath
argument_list|,
name|access_pool
argument_list|)
expr_stmt|;
comment|/* The token must live as long as ACCESS_CTX.  */
name|token
operator|=
name|apr_pstrdup
argument_list|(
name|access_pool
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_access_add_lock_token2
argument_list|(
name|access_ctx
argument_list|,
name|fspath
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** The RA vtable routines ***/
end_comment

begin_define
define|#
directive|define
name|RA_LOCAL_DESCRIPTION
define|\
value|N_("Module for accessing a repository on local disk.")
end_define

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|svn_ra_local__get_description
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|_
argument_list|(
name|RA_LOCAL_DESCRIPTION
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|svn_ra_local__get_schemes
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|schemes
index|[]
init|=
block|{
literal|"file"
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|schemes
return|;
block|}
end_function

begin_comment
comment|/* Do nothing.  *  * Why is this acceptable?  FS warnings used to be used for only  * two things: failures to close BDB repositories and failures to  * interact with memcached in FSFS (new in 1.6).  In 1.5 and earlier,  * we did not call svn_fs_set_warning_func in ra_local, which means  * that any BDB-closing failure would have led to abort()s; the fact  * that this hasn't led to huge hues and cries makes it seem likely  * that this just doesn't happen that often, at least not through  * ra_local.  And as far as memcached goes, it seems unlikely that  * somebody is going to go through the trouble of setting up and  * running memcached servers but then use ra_local access.  So we  * ignore errors here, so that memcached can use the FS warnings API  * without crashing ra_local.  */
end_comment

begin_function
specifier|static
name|void
name|ignore_warnings
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_DEBUG
name|SVN_DBG
argument_list|(
operator|(
literal|"Ignoring FS warning %d\n"
operator|,
name|err
condition|?
name|err
operator|->
name|apr_err
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__open
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|corrected_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_URL
parameter_list|,
specifier|const
name|svn_ra_callbacks2_t
modifier|*
name|callbacks
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
specifier|static
specifier|volatile
name|svn_atomic_t
name|cache_init_state
init|=
literal|0
decl_stmt|;
comment|/* Initialise the FSFS memory cache size.  We can only do this once      so one CONFIG will win the race and all others will be ignored      silently.  */
name|SVN_ERR
argument_list|(
name|svn_atomic__init_once
argument_list|(
operator|&
name|cache_init_state
argument_list|,
name|cache_init
argument_list|,
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't support redirections in ra-local. */
if|if
condition|(
name|corrected_url
condition|)
operator|*
name|corrected_url
operator|=
name|NULL
expr_stmt|;
comment|/* Allocate and stash the session_sess args we have already. */
name|sess
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sess
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|callbacks
operator|=
name|callbacks
expr_stmt|;
name|sess
operator|->
name|callback_baton
operator|=
name|callback_baton
expr_stmt|;
comment|/* Look through the URL, figure out which part points to the      repository, and which part is the path *within* the      repository. */
name|SVN_ERR_W
argument_list|(
name|svn_ra_local__split_URL
argument_list|(
operator|&
operator|(
name|sess
operator|->
name|repos
operator|)
argument_list|,
operator|&
operator|(
name|sess
operator|->
name|repos_url
operator|)
argument_list|,
operator|&
name|fs_path
argument_list|,
name|repos_URL
argument_list|,
name|session
operator|->
name|pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Unable to open an ra_local session to URL"
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|fs_path
operator|=
name|svn_stringbuf_create
argument_list|(
name|fs_path
argument_list|,
name|session
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Cache the filesystem object from the repos here for      convenience. */
name|sess
operator|->
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|sess
operator|->
name|repos
argument_list|)
expr_stmt|;
comment|/* Ignore FS warnings. */
name|svn_fs_set_warning_func
argument_list|(
name|sess
operator|->
name|fs
argument_list|,
name|ignore_warnings
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Cache the repository UUID as well */
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|sess
operator|->
name|fs
argument_list|,
operator|&
name|sess
operator|->
name|uuid
argument_list|,
name|session
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Be sure username is NULL so we know to look it up / ask for it */
name|sess
operator|->
name|username
operator|=
name|NULL
expr_stmt|;
name|session
operator|->
name|priv
operator|=
name|sess
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__reparent
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|sess
operator|->
name|repos_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* If the new URL isn't the same as our repository root URL, then      let's ensure that it's some child of it. */
if|if
condition|(
operator|!
name|relpath
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' is not a child of the session's repository root "
literal|"URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|sess
operator|->
name|repos_url
argument_list|)
return|;
comment|/* Update our FS_PATH sess member to point to our new      relative-URL-turned-absolute-filesystem-path. */
name|svn_stringbuf_set
argument_list|(
name|sess
operator|->
name|fs_path
argument_list|,
name|svn_fspath__canonicalize
argument_list|(
name|relpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_session_url
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
operator|*
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|sess
operator|->
name|repos_url
argument_list|,
name|sess
operator|->
name|fs_path
operator|->
name|data
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_latest_revnum
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
modifier|*
name|latest_revnum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
return|return
name|svn_fs_youngest_rev
argument_list|(
name|latest_revnum
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_file_revs
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_repos_get_file_revs2
argument_list|(
name|sess
operator|->
name|repos
argument_list|,
name|abs_path
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|include_merged_revisions
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_dated_revision
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|apr_time_t
name|tm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
return|return
name|svn_repos_dated_revision
argument_list|(
name|revision
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|tm
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__change_rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_username
argument_list|(
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_repos_fs_change_rev_prop4
argument_list|(
name|sess
operator|->
name|repos
argument_list|,
name|rev
argument_list|,
name|sess
operator|->
name|username
argument_list|,
name|name
argument_list|,
name|old_value_p
argument_list|,
name|value
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_uuid
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|uuid
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
operator|*
name|uuid
operator|=
name|sess
operator|->
name|uuid
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_repos_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
operator|*
name|url
operator|=
name|sess
operator|->
name|repos_url
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__rev_proplist
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
return|return
name|svn_repos_fs_revision_proplist
argument_list|(
name|props
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
return|return
name|svn_repos_fs_revision_prop
argument_list|(
name|value
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_commit_editor
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|callback
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|struct
name|deltify_etc_baton
modifier|*
name|deb
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|deb
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Prepare the baton for deltify_etc()  */
name|deb
operator|->
name|fs
operator|=
name|sess
operator|->
name|fs
expr_stmt|;
name|deb
operator|->
name|repos
operator|=
name|sess
operator|->
name|repos
expr_stmt|;
name|deb
operator|->
name|fspath_base
operator|=
name|sess
operator|->
name|fs_path
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|keep_locks
condition|)
name|deb
operator|->
name|lock_tokens
operator|=
name|lock_tokens
expr_stmt|;
else|else
name|deb
operator|->
name|lock_tokens
operator|=
name|NULL
expr_stmt|;
name|deb
operator|->
name|commit_cb
operator|=
name|callback
expr_stmt|;
name|deb
operator|->
name|commit_baton
operator|=
name|callback_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_username
argument_list|(
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there are lock tokens to add, do so. */
name|SVN_ERR
argument_list|(
name|apply_lock_tokens
argument_list|(
name|sess
operator|->
name|fs
argument_list|,
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|lock_tokens
argument_list|,
name|session
operator|->
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the revprops table so we can add the username. */
name|revprop_table
operator|=
name|apr_hash_copy
argument_list|(
name|pool
argument_list|,
name|revprop_table
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|svn_string_create
argument_list|(
name|sess
operator|->
name|username
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_TXN_CLIENT_COMPAT_VERSION
argument_list|,
name|svn_string_create
argument_list|(
name|SVN_VER_NUMBER
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the repos commit-editor */
return|return
name|svn_repos_get_commit_editor5
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|NULL
argument_list|,
name|svn_path_uri_decode
argument_list|(
name|sess
operator|->
name|repos_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|revprop_table
argument_list|,
name|deltify_etc
argument_list|,
name|deb
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_mergeinfo
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|catalog
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|tmp_catalog
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|abs_paths
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|relative_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|abs_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|relative_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_repos_fs_get_mergeinfo
argument_list|(
operator|&
name|tmp_catalog
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|abs_paths
argument_list|,
name|revision
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|tmp_catalog
argument_list|)
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__remove_prefix_from_catalog
argument_list|(
name|catalog
argument_list|,
name|tmp_catalog
argument_list|,
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|catalog
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__do_update
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|update_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|make_reporter
argument_list|(
name|session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|update_revision
argument_list|,
name|update_target
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|depth
argument_list|,
name|send_copyfrom_args
argument_list|,
name|ignore_ancestry
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__do_switch
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|update_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|make_reporter
argument_list|(
name|session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|update_revision
argument_list|,
name|update_target
argument_list|,
name|switch_url
argument_list|,
name|TRUE
comment|/* text_deltas */
argument_list|,
name|depth
argument_list|,
name|send_copyfrom_args
argument_list|,
name|ignore_ancestry
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__do_status
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|status_target
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|status_editor
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|make_reporter
argument_list|(
name|session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|revision
argument_list|,
name|status_target
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|status_editor
argument_list|,
name|status_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__do_diff
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|update_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|update_target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|make_reporter
argument_list|(
name|session
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|update_revision
argument_list|,
name|update_target
argument_list|,
name|switch_url
argument_list|,
name|text_deltas
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|ignore_ancestry
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|log_baton
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
decl_stmt|;
name|svn_log_entry_receiver_t
name|real_cb
decl_stmt|;
name|void
modifier|*
name|real_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_receiver_wrapper
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|b
operator|->
name|sess
decl_stmt|;
if|if
condition|(
name|sess
operator|->
name|callbacks
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
name|sess
operator|->
name|callbacks
operator|->
name|cancel_func
call|)
argument_list|(
name|sess
operator|->
name|callback_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For consistency with the other RA layers, replace an empty      changed-paths hash with a NULL one.       ### Should this be done by svn_ra_get_log2() instead, then? */
if|if
condition|(
operator|(
name|log_entry
operator|->
name|changed_paths2
operator|)
operator|&&
operator|(
name|apr_hash_count
argument_list|(
name|log_entry
operator|->
name|changed_paths2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|log_entry
operator|->
name|changed_paths
operator|=
name|NULL
expr_stmt|;
name|log_entry
operator|->
name|changed_paths2
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|b
operator|->
name|real_cb
argument_list|(
name|b
operator|->
name|real_baton
argument_list|,
name|log_entry
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|struct
name|log_baton
name|lb
decl_stmt|;
name|apr_array_header_t
modifier|*
name|abs_paths
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|paths
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|relative_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|abs_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|relative_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
name|lb
operator|.
name|real_cb
operator|=
name|receiver
expr_stmt|;
name|lb
operator|.
name|real_baton
operator|=
name|receiver_baton
expr_stmt|;
name|lb
operator|.
name|sess
operator|=
name|sess
expr_stmt|;
name|receiver
operator|=
name|log_receiver_wrapper
expr_stmt|;
name|receiver_baton
operator|=
operator|&
name|lb
expr_stmt|;
return|return
name|svn_repos_get_logs4
argument_list|(
name|sess
operator|->
name|repos
argument_list|,
name|abs_paths
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|limit
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|include_merged_revisions
argument_list|,
name|revprops
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__do_check_path
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|revision
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_check_path
argument_list|(
name|kind
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__stat
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|revision
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_repos_stat
argument_list|(
name|dirent
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|inherited_props
parameter_list|,
name|svn_ra_local__session_baton_t
modifier|*
name|sess
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|cmt_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmt_date
decl_stmt|,
modifier|*
name|cmt_author
decl_stmt|;
comment|/* Create a hash with props attached to the fs node. */
if|if
condition|(
name|props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
name|props
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get inherited properties if requested. */
if|if
condition|(
name|inherited_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos_fs_get_inherited_props
argument_list|(
name|inherited_props
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now add some non-tweakable metadata to the hash as well... */
if|if
condition|(
name|props
condition|)
block|{
comment|/* The so-called 'entryprops' with info about CR& friends. */
name|SVN_ERR
argument_list|(
name|svn_repos_get_committed_info
argument_list|(
operator|&
name|cmt_rev
argument_list|,
operator|&
name|cmt_date
argument_list|,
operator|&
name|cmt_author
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|,
name|svn_string_createf
argument_list|(
name|result_pool
argument_list|,
literal|"%ld"
argument_list|,
name|cmt_rev
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|,
name|cmt_date
condition|?
name|svn_string_create
argument_list|(
name|cmt_date
argument_list|,
name|result_pool
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|,
name|cmt_author
condition|?
name|svn_string_create
argument_list|(
name|cmt_author
argument_list|,
name|result_pool
argument_list|)
else|:
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|props
argument_list|,
name|SVN_PROP_ENTRY_UUID
argument_list|,
name|svn_string_create
argument_list|(
name|sess
operator|->
name|uuid
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We have no 'wcprops' in ra_local, but might someday. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Getting just one file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_file
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
comment|/* Open the revision's root. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|youngest_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetched_rev
operator|!=
name|NULL
condition|)
operator|*
name|fetched_rev
operator|=
name|youngest_rev
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|node_kind
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' path not found"
argument_list|)
argument_list|,
name|abs_path
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|!=
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|abs_path
argument_list|)
return|;
block|}
if|if
condition|(
name|stream
condition|)
block|{
comment|/* Get a stream representing the file's contents. */
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now push data from the fs stream back at the caller's stream.          Note that this particular RA layer does not computing a          checksum as we go, and confirming it against the repository's          checksum when done.  That's because it calls          svn_fs_file_contents() directly, which already checks the          stored checksum, and all we're doing here is writing bytes in          a loop.  Truly, Nothing Can Go Wrong :-).  But RA layers that          go over a network should confirm the checksum.           Note: we are not supposed to close the passed-in stream, so          disown the thing.       */
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|svn_stream_disown
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|sess
operator|->
name|callbacks
condition|?
name|sess
operator|->
name|callbacks
operator|->
name|cancel_func
else|:
name|NULL
argument_list|,
name|sess
operator|->
name|callback_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle props if requested. */
if|if
condition|(
name|props
condition|)
name|SVN_ERR
argument_list|(
name|get_node_props
argument_list|(
name|props
argument_list|,
name|NULL
argument_list|,
name|sess
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Getting a directory's entries */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_dir
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint32_t
name|dirent_fields
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Open the revision's root. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|youngest_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetched_rev
operator|!=
name|NULL
condition|)
operator|*
name|fetched_rev
operator|=
name|youngest_rev
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirents
condition|)
block|{
comment|/* Get the dir's entries. */
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over the fs dirents, and build a hash of general          svn_dirent_t's. */
operator|*
name|dirents
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_hash_t
modifier|*
name|prophash
decl_stmt|;
specifier|const
name|char
modifier|*
name|datestring
decl_stmt|,
modifier|*
name|entryname
decl_stmt|,
modifier|*
name|fullpath
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|fs_entry
decl_stmt|;
name|svn_dirent_t
modifier|*
name|entry
init|=
name|svn_dirent_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|entryname
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|key
expr_stmt|;
name|fs_entry
operator|=
operator|(
name|svn_fs_dirent_t
operator|*
operator|)
name|val
expr_stmt|;
name|fullpath
operator|=
name|svn_dirent_join
argument_list|(
name|abs_path
argument_list|,
name|entryname
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_KIND
condition|)
block|{
comment|/* node kind */
name|entry
operator|->
name|kind
operator|=
name|fs_entry
operator|->
name|kind
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_SIZE
condition|)
block|{
comment|/* size  */
if|if
condition|(
name|entry
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|entry
operator|->
name|size
operator|=
literal|0
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_file_length
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|size
operator|)
argument_list|,
name|root
argument_list|,
name|fullpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
condition|)
block|{
comment|/* has_props? */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|prophash
argument_list|,
name|root
argument_list|,
name|fullpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|has_props
operator|=
operator|(
name|apr_hash_count
argument_list|(
name|prophash
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_TIME
operator|)
operator|||
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_LAST_AUTHOR
operator|)
operator|||
operator|(
name|dirent_fields
operator|&
name|SVN_DIRENT_CREATED_REV
operator|)
condition|)
block|{
comment|/* created_rev& friends */
name|SVN_ERR
argument_list|(
name|svn_repos_get_committed_info
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|created_rev
operator|)
argument_list|,
operator|&
name|datestring
argument_list|,
operator|&
operator|(
name|entry
operator|->
name|last_author
operator|)
argument_list|,
name|root
argument_list|,
name|fullpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|datestring
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
name|entry
operator|->
name|time
operator|)
argument_list|,
name|datestring
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|last_author
condition|)
name|entry
operator|->
name|last_author
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|entry
operator|->
name|last_author
argument_list|)
expr_stmt|;
block|}
comment|/* Store. */
name|svn_hash_sets
argument_list|(
operator|*
name|dirents
argument_list|,
name|entryname
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Handle props if requested. */
if|if
condition|(
name|props
condition|)
name|SVN_ERR
argument_list|(
name|get_node_props
argument_list|(
name|props
argument_list|,
name|NULL
argument_list|,
name|sess
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_locations
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locations
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|location_revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_repos_trace_node_locations
argument_list|(
name|sess
operator|->
name|fs
argument_list|,
name|locations
argument_list|,
name|abs_path
argument_list|,
name|peg_revision
argument_list|,
name|location_revisions
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_location_segments
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_repos_node_location_segments
argument_list|(
name|sess
operator|->
name|repos
argument_list|,
name|abs_path
argument_list|,
name|peg_revision
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_revs
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* A username is absolutely required to lock a path. */
name|SVN_ERR
argument_list|(
name|get_username
argument_list|(
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_revs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_revnum_t
modifier|*
name|revnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|callback_err
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
name|revnum
operator|=
name|val
expr_stmt|;
name|abs_path
operator|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* This wrapper will call pre- and post-lock hooks. */
name|err
operator|=
name|svn_repos_fs_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|abs_path
argument_list|,
name|NULL
argument_list|,
name|comment
argument_list|,
name|FALSE
comment|/* not DAV comment */
argument_list|,
literal|0
comment|/* no expiration */
argument_list|,
operator|*
name|revnum
argument_list|,
name|force
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SVN_ERR_IS_LOCK_ERROR
argument_list|(
name|err
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|lock_func
condition|)
name|callback_err
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|err
condition|?
name|NULL
else|:
name|lock
argument_list|,
name|err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_err
condition|)
return|return
name|callback_err
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__unlock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_tokens
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* A username is absolutely required to unlock a path. */
name|SVN_ERR
argument_list|(
name|get_username
argument_list|(
name|session
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|callback_err
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
comment|/* Since we can't store NULL values in a hash, we turn "" to          NULL here. */
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
name|token
operator|=
name|val
expr_stmt|;
else|else
name|token
operator|=
name|NULL
expr_stmt|;
name|abs_path
operator|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* This wrapper will call pre- and post-unlock hooks. */
name|err
operator|=
name|svn_repos_fs_unlock
argument_list|(
name|sess
operator|->
name|repos
argument_list|,
name|abs_path
argument_list|,
name|token
argument_list|,
name|force
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SVN_ERR_IS_UNLOCK_ERROR
argument_list|(
name|err
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|lock_func
condition|)
name|callback_err
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_err
condition|)
return|return
name|callback_err
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_fs_get_lock
argument_list|(
name|lock
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|abs_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_locks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locks
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Kinda silly to call the repos wrapper, since we have no authz      func to give it.  But heck, why not. */
return|return
name|svn_repos_fs_get_locks2
argument_list|(
name|locks
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|abs_path
argument_list|,
name|depth
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__replay
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|svn_repos_fs
argument_list|(
name|sess
operator|->
name|repos
argument_list|)
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_repos_replay2
argument_list|(
name|root
argument_list|,
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|low_water_mark
argument_list|,
name|send_deltas
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__replay_range
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
name|svn_ra_replay_revstart_callback_t
name|revstart_func
parameter_list|,
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_IMPLEMENTED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__has_capability
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_boolean_t
modifier|*
name|has
parameter_list|,
specifier|const
name|char
modifier|*
name|capability
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_DEPTH
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_LOG_REVPROPS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_PARTIAL_REPLAY
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_COMMIT_REVPROPS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_INHERITED_PROPS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_EPHEMERAL_TXNPROPS
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_GET_FILE_REVS_REVERSE
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|has
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|capability
argument_list|,
name|SVN_RA_CAPABILITY_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* With mergeinfo, the code's capabilities may not reflect the          repository's, so inquire further. */
name|SVN_ERR
argument_list|(
name|svn_repos_has_capability
argument_list|(
name|sess
operator|->
name|repos
argument_list|,
name|has
argument_list|,
name|SVN_REPOS_CAPABILITY_MERGEINFO
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Don't know any other capabilities, so error. */
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNKNOWN_CAPABILITY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Don't know anything about capability '%s'"
argument_list|)
argument_list|,
name|capability
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_deleted_rev
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision_deleted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_deleted_rev
argument_list|(
name|sess
operator|->
name|fs
argument_list|,
name|abs_path
argument_list|,
name|peg_revision
argument_list|,
name|end_revision
argument_list|,
name|revision_deleted
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_inherited_props
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|iprops
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|const
name|char
modifier|*
name|abs_path
init|=
name|svn_fspath__join
argument_list|(
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
comment|/* Open the revision's root. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|youngest_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|sess
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
operator|&
name|node_kind
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' path not found"
argument_list|)
argument_list|,
name|abs_path
argument_list|)
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|get_node_props
argument_list|(
name|NULL
argument_list|,
name|iprops
argument_list|,
name|sess
argument_list|,
name|root
argument_list|,
name|abs_path
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__register_editor_shim_callbacks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
parameter_list|)
block|{
comment|/* This is currenly a no-op, since we don't provide our own editor, just      use the one the libsvn_repos hands back to us. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_ra_local__get_commit_ev2
parameter_list|(
name|svn_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
name|svn_commit_callback2_t
name|commit_cb
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|svn_ra__provide_base_cb_t
name|provide_base_cb
parameter_list|,
name|svn_ra__provide_props_cb_t
name|provide_props_cb
parameter_list|,
name|svn_ra__get_copysrc_kind_cb_t
name|get_copysrc_kind_cb
parameter_list|,
name|void
modifier|*
name|cb_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_local__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|struct
name|deltify_etc_baton
modifier|*
name|deb
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|deb
argument_list|)
argument_list|)
decl_stmt|;
comment|/* NOTE: the RA callbacks are ignored. We pass everything directly to      the REPOS editor.  */
comment|/* Prepare the baton for deltify_etc()  */
name|deb
operator|->
name|fs
operator|=
name|sess
operator|->
name|fs
expr_stmt|;
name|deb
operator|->
name|repos
operator|=
name|sess
operator|->
name|repos
expr_stmt|;
name|deb
operator|->
name|fspath_base
operator|=
name|sess
operator|->
name|fs_path
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|!
name|keep_locks
condition|)
name|deb
operator|->
name|lock_tokens
operator|=
name|lock_tokens
expr_stmt|;
else|else
name|deb
operator|->
name|lock_tokens
operator|=
name|NULL
expr_stmt|;
name|deb
operator|->
name|commit_cb
operator|=
name|commit_cb
expr_stmt|;
name|deb
operator|->
name|commit_baton
operator|=
name|commit_baton
expr_stmt|;
comment|/* Ensure there is a username (and an FS access context) associated with      the session and its FS handle.  */
name|SVN_ERR
argument_list|(
name|get_username
argument_list|(
name|session
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there are lock tokens to add, do so.  */
name|SVN_ERR
argument_list|(
name|apply_lock_tokens
argument_list|(
name|sess
operator|->
name|fs
argument_list|,
name|sess
operator|->
name|fs_path
operator|->
name|data
argument_list|,
name|lock_tokens
argument_list|,
name|session
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the REVPROPS and insert the author/username.  */
name|revprops
operator|=
name|apr_hash_copy
argument_list|(
name|scratch_pool
argument_list|,
name|revprops
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|svn_string_create
argument_list|(
name|sess
operator|->
name|username
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_repos__get_commit_ev2
argument_list|(
name|editor
argument_list|,
name|sess
operator|->
name|repos
argument_list|,
name|NULL
comment|/* authz */
argument_list|,
name|NULL
comment|/* authz_repos_name */
argument_list|,
name|NULL
comment|/* authz_user */
argument_list|,
name|revprops
argument_list|,
name|deltify_etc
argument_list|,
name|deb
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_function
specifier|static
specifier|const
name|svn_version_t
modifier|*
name|ra_local_version
parameter_list|(
name|void
parameter_list|)
block|{
name|SVN_VERSION_BODY
expr_stmt|;
block|}
end_function

begin_comment
comment|/** The ra_vtable **/
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra__vtable_t
name|ra_local_vtable
init|=
block|{
name|ra_local_version
block|,
name|svn_ra_local__get_description
block|,
name|svn_ra_local__get_schemes
block|,
name|svn_ra_local__open
block|,
name|svn_ra_local__reparent
block|,
name|svn_ra_local__get_session_url
block|,
name|svn_ra_local__get_latest_revnum
block|,
name|svn_ra_local__get_dated_revision
block|,
name|svn_ra_local__change_rev_prop
block|,
name|svn_ra_local__rev_proplist
block|,
name|svn_ra_local__rev_prop
block|,
name|svn_ra_local__get_commit_editor
block|,
name|svn_ra_local__get_file
block|,
name|svn_ra_local__get_dir
block|,
name|svn_ra_local__get_mergeinfo
block|,
name|svn_ra_local__do_update
block|,
name|svn_ra_local__do_switch
block|,
name|svn_ra_local__do_status
block|,
name|svn_ra_local__do_diff
block|,
name|svn_ra_local__get_log
block|,
name|svn_ra_local__do_check_path
block|,
name|svn_ra_local__stat
block|,
name|svn_ra_local__get_uuid
block|,
name|svn_ra_local__get_repos_root
block|,
name|svn_ra_local__get_locations
block|,
name|svn_ra_local__get_location_segments
block|,
name|svn_ra_local__get_file_revs
block|,
name|svn_ra_local__lock
block|,
name|svn_ra_local__unlock
block|,
name|svn_ra_local__get_lock
block|,
name|svn_ra_local__get_locks
block|,
name|svn_ra_local__replay
block|,
name|svn_ra_local__has_capability
block|,
name|svn_ra_local__replay_range
block|,
name|svn_ra_local__get_deleted_rev
block|,
name|svn_ra_local__register_editor_shim_callbacks
block|,
name|svn_ra_local__get_inherited_props
block|,
name|svn_ra_local__get_commit_ev2
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*----------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/** The One Public Routine, called by libsvn_ra **/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_local__init
parameter_list|(
specifier|const
name|svn_version_t
modifier|*
name|loader_version
parameter_list|,
specifier|const
name|svn_ra__vtable_t
modifier|*
modifier|*
name|vtable
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
literal|"svn_repos"
block|,
name|svn_repos_version
block|}
block|,
block|{
literal|"svn_fs"
block|,
name|svn_fs_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
comment|/* Simplified version check to make sure we can safely use the      VTABLE parameter. The RA loader does a more exhaustive check. */
if|if
condition|(
name|loader_version
operator|->
name|major
operator|!=
name|SVN_VER_MAJOR
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported RA loader version (%d) for "
literal|"ra_local"
argument_list|)
argument_list|,
name|loader_version
operator|->
name|major
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ver_check_list2
argument_list|(
name|ra_local_version
argument_list|()
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|SVN_LIBSVN_CLIENT_LINKS_RA_LOCAL
comment|/* This assumes that POOL was the pool used to load the dso. */
name|SVN_ERR
argument_list|(
name|svn_fs_initialize
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|*
name|vtable
operator|=
operator|&
name|ra_local_vtable
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compatibility wrapper for the 1.1 and before API. */
end_comment

begin_define
define|#
directive|define
name|NAME
value|"ra_local"
end_define

begin_define
define|#
directive|define
name|DESCRIPTION
value|RA_LOCAL_DESCRIPTION
end_define

begin_define
define|#
directive|define
name|VTBL
value|ra_local_vtable
end_define

begin_define
define|#
directive|define
name|INITFUNC
value|svn_ra_local__init
end_define

begin_define
define|#
directive|define
name|COMPAT_INITFUNC
value|svn_ra_local_init
end_define

begin_include
include|#
directive|include
file|"../libsvn_ra/wrapper_template.h"
end_include

end_unit

