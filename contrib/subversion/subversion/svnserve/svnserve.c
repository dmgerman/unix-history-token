begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnserve.c :  Main control function for svnserve  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_getopt.h>
end_include

begin_include
include|#
directive|include
file|<apr_network_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|<apr_thread_proc.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra_svn.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_cache_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mutex.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_include
include|#
directive|include
file|<apr_thread_pool.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"winservice.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* For getpid() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_include
include|#
directive|include
file|"logger.h"
end_include

begin_comment
comment|/* The strategy for handling incoming connections.  Some of these may be    unavailable due to platform limitations. */
end_comment

begin_enum
enum|enum
name|connection_handling_mode
block|{
name|connection_mode_fork
block|,
comment|/* Create a process per connection */
name|connection_mode_thread
block|,
comment|/* Create a thread per connection */
name|connection_mode_single
comment|/* One connection at a time in this process */
block|}
enum|;
end_enum

begin_comment
comment|/* The mode in which to run svnserve */
end_comment

begin_enum
enum|enum
name|run_mode
block|{
name|run_mode_unspecified
block|,
name|run_mode_inetd
block|,
name|run_mode_daemon
block|,
name|run_mode_tunnel
block|,
name|run_mode_listen_once
block|,
name|run_mode_service
block|}
enum|;
end_enum

begin_if
if|#
directive|if
name|APR_HAS_FORK
end_if

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_fork
end_define

begin_define
define|#
directive|define
name|CONNECTION_HAVE_THREAD_OPTION
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! APR_HAS_THREADS */
end_comment

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! APR_HAS_THREADS */
end_comment

begin_elif
elif|#
directive|elif
name|APR_HAS_THREADS
end_elif

begin_comment
comment|/* and ! APR_HAS_FORK */
end_comment

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_thread
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! APR_HAS_THREADS and ! APR_HAS_FORK */
end_comment

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_single
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Parameters for the worker thread pool used in threaded mode. */
end_comment

begin_comment
comment|/* Have at least this many worker threads (even if there are no requests  * to handle).  *  * A 0 value is legal but increases the latency for the next incoming  * request.  Higher values may be useful for servers that experience short  * bursts of concurrent requests followed by longer idle periods.  */
end_comment

begin_define
define|#
directive|define
name|THREADPOOL_MIN_SIZE
value|1
end_define

begin_comment
comment|/* Maximum number of worker threads.  If there are more concurrent requests  * than worker threads, the extra requests get queued.  *  * Since very slow connections will hog a full thread for a potentially  * long time before timing out, be sure to not set this limit too low.  *  * On the other hand, keep in mind that every thread will allocate up to  * 4MB of unused RAM in the APR allocator of its root pool.  32 bit servers  * must hence do with fewer threads.  */
end_comment

begin_if
if|#
directive|if
operator|(
name|APR_SIZEOF_VOIDP
operator|<=
literal|4
operator|)
end_if

begin_define
define|#
directive|define
name|THREADPOOL_MAX_SIZE
value|64
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|THREADPOOL_MAX_SIZE
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Number of microseconds that an unused thread remains in the pool before  * being terminated.  *  * Higher values are useful if clients frequently send small requests and  * you want to minimize the latency for those.  */
end_comment

begin_define
define|#
directive|define
name|THREADPOOL_THREAD_IDLE_LIMIT
value|1000000
end_define

begin_comment
comment|/* Number of client to server connections that may concurrently in the  * TCP 3-way handshake state, i.e. are in the process of being created.  *  * Larger values improve scalability with lots of small requests coming  * on over long latency networks.  *  * The OS may actually use a lower limit than specified here.  */
end_comment

begin_define
define|#
directive|define
name|ACCEPT_BACKLOG
value|128
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_decl_stmt
specifier|static
name|apr_os_sock_t
name|winservice_svnserve_accept_socket
init|=
name|INVALID_SOCKET
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The SCM calls this function (on an arbitrary thread, not the main()    thread!) when it wants to stop the service.     For now, our strategy is to close the listener socket, in order to    unblock main() and cause it to exit its accept loop.  We cannot use    apr_socket_close, because that function deletes the apr_socket_t    structure, as well as closing the socket handle.  If we called    apr_socket_close here, then main() will also call apr_socket_close,    resulting in a double-free.  This way, we just close the kernel    socket handle, which causes the accept() function call to fail,    which causes main() to clean up the socket.  So, memory gets freed    only once.     This isn't pretty, but it's better than a lot of other options.    Currently, there is no "right" way to shut down svnserve.     We store the OS handle rather than a pointer to the apr_socket_t    structure in order to eliminate any possibility of illegal memory    access. */
end_comment

begin_function
name|void
name|winservice_notify_stop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|winservice_svnserve_accept_socket
operator|!=
name|INVALID_SOCKET
condition|)
name|closesocket
argument_list|(
name|winservice_svnserve_accept_socket
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_comment
comment|/* Option codes and descriptions for svnserve.  *  * The entire list must be terminated with an entry of nulls.  *  * APR requires that options without abbreviations  * have codes greater than 255.  */
end_comment

begin_define
define|#
directive|define
name|SVNSERVE_OPT_LISTEN_PORT
value|256
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_LISTEN_HOST
value|257
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_FOREGROUND
value|258
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_TUNNEL_USER
value|259
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_VERSION
value|260
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_PID_FILE
value|261
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_SERVICE
value|262
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CONFIG_FILE
value|263
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_LOG_FILE
value|264
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CACHE_TXDELTAS
value|265
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CACHE_FULLTEXTS
value|266
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CACHE_REVPROPS
value|267
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_SINGLE_CONN
value|268
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CLIENT_SPEED
value|269
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_VIRTUAL_HOST
value|270
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_MIN_THREADS
value|271
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_MAX_THREADS
value|272
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_BLOCK_READ
value|273
end_define

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|svnserve__options
index|[]
init|=
block|{
block|{
literal|"daemon"
block|,
literal|'d'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"daemon mode"
argument_list|)
block|}
block|,
block|{
literal|"inetd"
block|,
literal|'i'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"inetd mode"
argument_list|)
block|}
block|,
block|{
literal|"tunnel"
block|,
literal|'t'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"tunnel mode"
argument_list|)
block|}
block|,
block|{
literal|"listen-once"
block|,
literal|'X'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"listen-once mode (useful for debugging)"
argument_list|)
block|}
block|,
ifdef|#
directive|ifdef
name|WIN32
block|{
literal|"service"
block|,
name|SVNSERVE_OPT_SERVICE
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Windows service mode (Service Control Manager)"
argument_list|)
block|}
block|,
endif|#
directive|endif
block|{
literal|"root"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"root of directory to serve"
argument_list|)
block|}
block|,
block|{
literal|"read-only"
block|,
literal|'R'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"force read only, overriding repository config file"
argument_list|)
block|}
block|,
block|{
literal|"config-file"
block|,
name|SVNSERVE_OPT_CONFIG_FILE
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"read configuration from file ARG"
argument_list|)
block|}
block|,
block|{
literal|"listen-port"
block|,
name|SVNSERVE_OPT_LISTEN_PORT
block|,
literal|1
block|,
ifdef|#
directive|ifdef
name|WIN32
name|N_
argument_list|(
literal|"listen port. The default port is 3690.\n"
literal|"                             "
literal|"[mode: daemon, service, listen-once]"
argument_list|)
block|}
block|,
else|#
directive|else
name|N_
argument_list|(
literal|"listen port. The default port is 3690.\n"
literal|"                             "
literal|"[mode: daemon, listen-once]"
argument_list|)
block|}
decl_stmt|,
endif|#
directive|endif
block|{
literal|"listen-host"
operator|,
name|SVNSERVE_OPT_LISTEN_HOST
operator|,
literal|1
operator|,
ifdef|#
directive|ifdef
name|WIN32
name|N_
argument_list|(
literal|"listen hostname or IP address\n"
literal|"                             "
literal|"By default svnserve listens on all addresses.\n"
literal|"                             "
literal|"[mode: daemon, service, listen-once]"
argument_list|)
block|}
end_decl_stmt

begin_operator
operator|,
end_operator

begin_else
else|#
directive|else
end_else

begin_macro
name|N_
argument_list|(
literal|"listen hostname or IP address\n"
literal|"                             "
literal|"By default svnserve listens on all addresses.\n"
literal|"                             "
literal|"[mode: daemon, listen-once]"
argument_list|)
end_macro

begin_endif
unit|},
endif|#
directive|endif
end_endif

begin_block
block|{
literal|"prefer-ipv6"
operator|,
literal|'6'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"prefer IPv6 when resolving the listen hostname\n"
literal|"                             "
literal|"[IPv4 is preferred by default. Using IPv4 and IPv6\n"
literal|"                             "
literal|"at the same time is not supported in daemon mode.\n"
literal|"                             "
literal|"Use inetd mode or tunnel mode if you need this.]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"compression"
operator|,
literal|'c'
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"compression level to use for network transmissions\n"
literal|"                             "
literal|"[0 .. no compression, 5 .. default, \n"
literal|"                             "
literal|" 9 .. maximum compression]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"memory-cache-size"
operator|,
literal|'M'
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"size of the extra in-memory cache in MB used to\n"
literal|"                             "
literal|"minimize redundant operations.\n"
literal|"                             "
literal|"Default is 16.\n"
literal|"                             "
literal|"0 switches to dynamically sized caches.\n"
literal|"                             "
literal|"[used for FSFS and FSX repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"cache-txdeltas"
operator|,
name|SVNSERVE_OPT_CACHE_TXDELTAS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"enable or disable caching of deltas between older\n"
literal|"                             "
literal|"revisions.\n"
literal|"                             "
literal|"Default is yes.\n"
literal|"                             "
literal|"[used for FSFS and FSX repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"cache-fulltexts"
operator|,
name|SVNSERVE_OPT_CACHE_FULLTEXTS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"enable or disable caching of file contents\n"
literal|"                             "
literal|"Default is yes.\n"
literal|"                             "
literal|"[used for FSFS and FSX repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"cache-revprops"
operator|,
name|SVNSERVE_OPT_CACHE_REVPROPS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"enable or disable caching of revision properties.\n"
literal|"                             "
literal|"Consult the documentation before activating this.\n"
literal|"                             "
literal|"Default is no.\n"
literal|"                             "
literal|"[used for FSFS and FSX repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"client-speed"
operator|,
name|SVNSERVE_OPT_CLIENT_SPEED
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"Optimize network handling based on the assumption\n"
literal|"                             "
literal|"that most clients are connected with a bitrate of\n"
literal|"                             "
literal|"ARG Mbit/s.\n"
literal|"                             "
literal|"Default is 0 (optimizations disabled)."
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"block-read"
operator|,
name|SVNSERVE_OPT_BLOCK_READ
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"Parse and cache all data found in block instead\n"
literal|"                             "
literal|"of just the requested item.\n"
literal|"                             "
literal|"Default is no.\n"
literal|"                             "
literal|"[used for FSFS repositories in 1.9 format only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_ifdef
ifdef|#
directive|ifdef
name|CONNECTION_HAVE_THREAD_OPTION
end_ifdef

begin_comment
comment|/* ### Making the assumption here that WIN32 never has fork and so      * ### this option never exists when --service exists. */
end_comment

begin_block
block|{
literal|"threads"
operator|,
literal|'T'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"use threads instead of fork "
literal|"[mode: daemon]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"min-threads"
operator|,
name|SVNSERVE_OPT_MIN_THREADS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"Minimum number of server threads, even if idle.\n"
literal|"                             "
literal|"Capped to max-threads; minimum value is 0.\n"
literal|"                             "
literal|"Default is 1.\n"
literal|"                             "
literal|"[used only with --threads]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_if
if|#
directive|if
operator|(
name|APR_SIZEOF_VOIDP
operator|<=
literal|4
operator|)
end_if

begin_block
block|{
literal|"max-threads"
operator|,
name|SVNSERVE_OPT_MAX_THREADS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"Maximum number of server threads, even if there\n"
literal|"                             "
literal|"are more connections.  Minimum value is 1.\n"
literal|"                             "
literal|"Default is 64.\n"
literal|"                             "
literal|"[used only with --threads]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_else
else|#
directive|else
end_else

begin_block
block|{
literal|"max-threads"
operator|,
name|SVNSERVE_OPT_MAX_THREADS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"Maximum number of server threads, even if there\n"
literal|"                             "
literal|"are more connections.  Minimum value is 1.\n"
literal|"                             "
literal|"Default is 256.\n"
literal|"                             "
literal|"[used only with --threads]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
literal|"foreground"
operator|,
name|SVNSERVE_OPT_FOREGROUND
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"run in foreground (useful for debugging)\n"
literal|"                             "
literal|"[mode: daemon]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"single-thread"
operator|,
name|SVNSERVE_OPT_SINGLE_CONN
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"handle one connection at a time in the parent\n"
literal|"                             "
literal|"process (useful for debugging)"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"log-file"
operator|,
name|SVNSERVE_OPT_LOG_FILE
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"svnserve log file"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"pid-file"
operator|,
name|SVNSERVE_OPT_PID_FILE
operator|,
literal|1
operator|,
ifdef|#
directive|ifdef
name|WIN32
name|N_
argument_list|(
literal|"write server process ID to file ARG\n"
literal|"                             "
literal|"[mode: daemon, listen-once, service]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_else
else|#
directive|else
end_else

begin_macro
name|N_
argument_list|(
literal|"write server process ID to file ARG\n"
literal|"                             "
literal|"[mode: daemon, listen-once]"
argument_list|)
end_macro

begin_endif
unit|},
endif|#
directive|endif
end_endif

begin_block
block|{
literal|"tunnel-user"
operator|,
name|SVNSERVE_OPT_TUNNEL_USER
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"tunnel username (default is current uid's name)\n"
literal|"                             "
literal|"[mode: tunnel]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"help"
operator|,
literal|'h'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"display this help"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"virtual-host"
operator|,
name|SVNSERVE_OPT_VIRTUAL_HOST
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"virtual host mode (look for repo in directory\n"
literal|"                             "
literal|"of provided hostname)"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"version"
operator|,
name|SVNSERVE_OPT_VERSION
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"quiet"
operator|,
literal|'q'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"no progress (only errors) to stderr"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
block|}
end_block

begin_function
unit|};
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|progname
condition|)
name|progname
operator|=
literal|"svnserve"
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Type '%s --help' for usage.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"usage: svnserve [-d | -i | -t | -X "
literal|"| --service] [options]\n"
literal|"Subversion repository server.\n"
literal|"Type 'svnserve --version' to see the "
literal|"program version.\n"
literal|"\n"
literal|"Valid options:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"usage: svnserve [-d | -i | -t | -X] "
literal|"[options]\n"
literal|"Subversion repository server.\n"
literal|"Type 'svnserve --version' to see the "
literal|"program version.\n"
literal|"\n"
literal|"Valid options:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|svnserve__options
index|[
name|i
index|]
operator|.
name|name
operator|&&
name|svnserve__options
index|[
name|i
index|]
operator|.
name|optch
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|svnserve__options
operator|+
name|i
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|,
literal|"  %s\n"
argument_list|,
name|optstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|version
parameter_list|(
name|svn_boolean_t
name|quiet
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fs_desc_start
init|=
name|_
argument_list|(
literal|"The following repository back-end (FS) modules are available:\n\n"
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|version_footer
decl_stmt|;
name|version_footer
operator|=
name|svn_stringbuf_create
argument_list|(
name|fs_desc_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
name|svn_stringbuf_appendcstr
argument_list|(
name|version_footer
argument_list|,
name|_
argument_list|(
literal|"\nCyrus SASL authentication is available.\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|svn_opt_print_help4
argument_list|(
name|NULL
argument_list|,
literal|"svnserve"
argument_list|,
name|TRUE
argument_list|,
name|quiet
argument_list|,
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_FORK
end_if

begin_function
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* Nothing to do; we just need to interrupt the accept(). */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Redirect stdout to stderr.  ARG is the pool.  *  * In tunnel or inetd mode, we don't want hook scripts corrupting the  * data stream by sending data to stdout, so we need to redirect  * stdout somewhere else.  Sending it to stderr is acceptable; sending  * it to /dev/null is another option, but apr doesn't provide a way to  * do that without also detaching from the controlling terminal.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|redirect_stdout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|arg
decl_stmt|;
name|apr_file_t
modifier|*
name|out_file
decl_stmt|,
modifier|*
name|err_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
if|if
condition|(
operator|(
name|apr_err
operator|=
name|apr_file_open_stdout
argument_list|(
operator|&
name|out_file
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|apr_err
return|;
if|if
condition|(
operator|(
name|apr_err
operator|=
name|apr_file_open_stderr
argument_list|(
operator|&
name|err_file
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|apr_err
return|;
return|return
name|apr_file_dup2
argument_list|(
name|out_file
argument_list|,
name|err_file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wait for the next client connection to come in from SOCK.  Allocate  * the connection in a root pool from CONNECTION_POOLS and assign PARAMS.  * Return the connection object in *CONNECTION.  *  * Use HANDLING_MODE for proper internal cleanup.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|accept_connection
parameter_list|(
name|connection_t
modifier|*
modifier|*
name|connection
parameter_list|,
name|apr_socket_t
modifier|*
name|sock
parameter_list|,
name|serve_params_t
modifier|*
name|params
parameter_list|,
name|enum
name|connection_handling_mode
name|handling_mode
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
comment|/* Non-standard pool handling.  The main thread never blocks to join    *         the connection threads so it cannot clean up after each one.  So    *         separate pools that can be cleared at thread exit are used. */
name|apr_pool_t
modifier|*
name|connection_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
operator|*
name|connection
operator|=
name|apr_pcalloc
argument_list|(
name|connection_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|connection
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|connection
operator|)
operator|->
name|pool
operator|=
name|connection_pool
expr_stmt|;
operator|(
operator|*
name|connection
operator|)
operator|->
name|params
operator|=
name|params
expr_stmt|;
operator|(
operator|*
name|connection
operator|)
operator|->
name|ref_count
operator|=
literal|1
expr_stmt|;
do|do
block|{
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
name|winservice_is_stopping
argument_list|()
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|status
operator|=
name|apr_socket_accept
argument_list|(
operator|&
operator|(
operator|*
name|connection
operator|)
operator|->
name|usock
argument_list|,
name|sock
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|handling_mode
operator|==
name|connection_mode_fork
condition|)
block|{
name|apr_proc_t
name|proc
decl_stmt|;
comment|/* Collect any zombie child processes. */
while|while
condition|(
name|apr_proc_wait_all_procs
argument_list|(
operator|&
name|proc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|APR_NOWAIT
argument_list|,
name|connection_pool
argument_list|)
operator|==
name|APR_CHILD_DONE
condition|)
empty_stmt|;
block|}
block|}
do|while
condition|(
name|APR_STATUS_IS_EINTR
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNABORTED
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNRESET
argument_list|(
name|status
argument_list|)
condition|)
do|;
return|return
name|status
condition|?
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't accept client connection"
argument_list|)
argument_list|)
else|:
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add a reference to CONNECTION, i.e. keep it and it's pool valid unless  * that reference gets released using release_shared_pool().  */
end_comment

begin_function
specifier|static
name|void
name|attach_connection
parameter_list|(
name|connection_t
modifier|*
name|connection
parameter_list|)
block|{
name|svn_atomic_inc
argument_list|(
operator|&
name|connection
operator|->
name|ref_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Release a reference to CONNECTION.  If there are no more references,  * the connection will be  */
end_comment

begin_function
specifier|static
name|void
name|close_connection
parameter_list|(
name|connection_t
modifier|*
name|connection
parameter_list|)
block|{
comment|/* this will automatically close USOCK */
if|if
condition|(
name|svn_atomic_dec
argument_list|(
operator|&
name|connection
operator|->
name|ref_count
argument_list|)
operator|==
literal|0
condition|)
name|svn_pool_destroy
argument_list|(
name|connection
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Wrapper around serve() that takes a socket instead of a connection.  * This is to off-load work from the main thread in threaded and fork modes.  *  * If an error occurs, log it and also return it.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|serve_socket
parameter_list|(
name|connection_t
modifier|*
name|connection
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* process the actual request and log errors */
name|svn_error_t
modifier|*
name|err
init|=
name|serve_interruptable
argument_list|(
name|NULL
argument_list|,
name|connection
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
name|logger__log_error
argument_list|(
name|connection
operator|->
name|params
operator|->
name|logger
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|,
name|get_client_info
argument_list|(
name|connection
operator|->
name|conn
argument_list|,
name|connection
operator|->
name|params
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_comment
comment|/* allocate and recycle root pools for connection objects.    There should be at most THREADPOOL_MAX_SIZE such pools. */
end_comment

begin_decl_stmt
specifier|static
name|svn_root_pools__t
modifier|*
name|connection_pools
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The global thread pool serving all connections. */
end_comment

begin_decl_stmt
specifier|static
name|apr_thread_pool_t
modifier|*
name|threads
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Very simple load determination callback for serve_interruptable:    With less than half the threads in THREADS in use, we can afford to    wait in the socket read() function.  Otherwise, poll them round-robin. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_busy
parameter_list|(
name|connection_t
modifier|*
name|connection
parameter_list|)
block|{
return|return
name|apr_thread_pool_threads_count
argument_list|(
name|threads
argument_list|)
operator|*
literal|2
operator|>
name|apr_thread_pool_thread_max_get
argument_list|(
name|threads
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Serve the connection given by DATA.  Under high load, serve only    the current command (if any) and then put the connection back into    THREAD's task pool. */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|APR_THREAD_FUNC
name|serve_thread
parameter_list|(
name|apr_thread_t
modifier|*
name|tid
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_boolean_t
name|done
decl_stmt|;
name|connection_t
modifier|*
name|connection
init|=
name|data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|svn_root_pools__acquire_pool
argument_list|(
name|connection_pools
argument_list|)
decl_stmt|;
comment|/* process the actual request and log errors */
name|err
operator|=
name|serve_interruptable
argument_list|(
operator|&
name|done
argument_list|,
name|connection
argument_list|,
name|is_busy
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|logger__log_error
argument_list|(
name|connection
operator|->
name|params
operator|->
name|logger
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|,
name|get_client_info
argument_list|(
name|connection
operator|->
name|conn
argument_list|,
name|connection
operator|->
name|params
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
name|svn_root_pools__release_pool
argument_list|(
name|pool
argument_list|,
name|connection_pools
argument_list|)
expr_stmt|;
comment|/* Close or re-schedule connection. */
if|if
condition|(
name|done
condition|)
name|close_connection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
else|else
name|apr_thread_pool_push
argument_list|(
name|threads
argument_list|,
name|serve_thread
argument_list|,
name|connection
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Write the PID of the current process as a decimal number, followed by a    newline to the file FILENAME, using POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_pid_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|contents
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_PID_T_FMT
literal|"\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|filename
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_EXCL
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|contents
argument_list|,
name|strlen
argument_list|(
name|contents
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_repos"
block|,
name|svn_repos_version
block|}
block|,
block|{
literal|"svn_fs"
block|,
name|svn_fs_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
literal|"svn_ra_svn"
block|,
name|svn_ra_svn_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * On success, leave *EXIT_CODE untouched and return SVN_NO_ERROR. On error,  * either return an error to be displayed, or set *EXIT_CODE to non-zero and  * return SVN_NO_ERROR.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sub_main
parameter_list|(
name|int
modifier|*
name|exit_code
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|enum
name|run_mode
name|run_mode
init|=
name|run_mode_unspecified
decl_stmt|;
name|svn_boolean_t
name|foreground
init|=
name|FALSE
decl_stmt|;
name|apr_socket_t
modifier|*
name|sock
decl_stmt|;
name|apr_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|serve_params_t
name|params
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
ifndef|#
directive|ifndef
name|WIN32
name|apr_proc_t
name|proc
decl_stmt|;
endif|#
directive|endif
name|svn_boolean_t
name|is_multi_threaded
decl_stmt|;
name|enum
name|connection_handling_mode
name|handling_mode
init|=
name|CONNECTION_DEFAULT
decl_stmt|;
name|svn_boolean_t
name|cache_fulltexts
init|=
name|TRUE
decl_stmt|;
name|svn_boolean_t
name|cache_txdeltas
init|=
name|TRUE
decl_stmt|;
name|svn_boolean_t
name|cache_revprops
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|use_block_read
init|=
name|FALSE
decl_stmt|;
name|apr_uint16_t
name|port
init|=
name|SVN_RA_SVN_PORT
decl_stmt|;
specifier|const
name|char
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
name|int
name|family
init|=
name|APR_INET
decl_stmt|;
name|apr_int32_t
name|sockaddr_info_flags
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|APR_HAVE_IPV6
name|svn_boolean_t
name|prefer_v6
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|svn_boolean_t
name|quiet
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|is_version
init|=
name|FALSE
decl_stmt|;
name|int
name|mode_opt_count
init|=
literal|0
decl_stmt|;
name|int
name|handling_opt_count
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_filename
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|pid_filename
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_filename
init|=
name|NULL
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_size_t
name|min_thread_count
init|=
name|THREADPOOL_MIN_SIZE
decl_stmt|;
name|apr_size_t
name|max_thread_count
init|=
name|THREADPOOL_MAX_SIZE
decl_stmt|;
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
name|SVN_ERR
argument_list|(
name|cyrus_init
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check library versions */
name|SVN_ERR
argument_list|(
name|check_lib_versions
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Initialize the FS library. */
name|SVN_ERR
argument_list|(
name|svn_fs_initialize
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|params
operator|.
name|root
operator|=
literal|"/"
expr_stmt|;
name|params
operator|.
name|tunnel
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|tunnel_user
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|read_only
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|cfg
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|compression_level
operator|=
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
expr_stmt|;
name|params
operator|.
name|logger
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|config_pool
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|authz_pool
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|fs_config
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|vhost
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|username_case
operator|=
name|CASE_ASIS
expr_stmt|;
name|params
operator|.
name|memory_cache_size
operator|=
operator|(
name|apr_uint64_t
operator|)
operator|-
literal|1
expr_stmt|;
name|params
operator|.
name|zero_copy_limit
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|error_check_interval
operator|=
literal|4096
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|svnserve__options
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
break|break;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'6'
case|:
if|#
directive|if
name|APR_HAVE_IPV6
name|prefer_v6
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* ### Maybe error here if we don't have IPV6 support? */
break|break;
case|case
literal|'h'
case|:
name|help
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_VERSION
case|:
name|is_version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_daemon
condition|)
block|{
name|run_mode
operator|=
name|run_mode_daemon
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_FOREGROUND
case|:
name|foreground
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_SINGLE_CONN
case|:
name|handling_mode
operator|=
name|connection_mode_single
expr_stmt|;
name|handling_opt_count
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_inetd
condition|)
block|{
name|run_mode
operator|=
name|run_mode_inetd
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_LISTEN_PORT
case|:
block|{
name|apr_uint64_t
name|val
decl_stmt|;
name|err
operator|=
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|val
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
name|APR_UINT16_MAX
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Invalid port '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
return|;
name|port
operator|=
operator|(
name|apr_uint16_t
operator|)
name|val
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_LISTEN_HOST
case|:
name|host
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_tunnel
condition|)
block|{
name|run_mode
operator|=
name|run_mode_tunnel
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_TUNNEL_USER
case|:
name|params
operator|.
name|tunnel_user
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_listen_once
condition|)
block|{
name|run_mode
operator|=
name|run_mode_listen_once
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|params
operator|.
name|root
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_resolved_path
argument_list|(
name|params
operator|.
name|root
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Root path '%s' does not exist "
literal|"or is not a directory"
argument_list|)
argument_list|,
name|params
operator|.
name|root
argument_list|)
return|;
block|}
name|params
operator|.
name|root
operator|=
name|svn_dirent_internal_style
argument_list|(
name|params
operator|.
name|root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|params
operator|.
name|root
argument_list|,
name|params
operator|.
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|params
operator|.
name|read_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|handling_mode
operator|=
name|connection_mode_thread
expr_stmt|;
name|handling_opt_count
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|params
operator|.
name|compression_level
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|compression_level
operator|<
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
condition|)
name|params
operator|.
name|compression_level
operator|=
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|compression_level
operator|>
name|SVN_DELTA_COMPRESSION_LEVEL_MAX
condition|)
name|params
operator|.
name|compression_level
operator|=
name|SVN_DELTA_COMPRESSION_LEVEL_MAX
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|params
operator|.
name|memory_cache_size
operator|=
literal|0x100000
operator|*
name|apr_strtoi64
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CACHE_TXDELTAS
case|:
name|cache_txdeltas
operator|=
name|svn_tristate__from_word
argument_list|(
name|arg
argument_list|)
operator|==
name|svn_tristate_true
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CACHE_FULLTEXTS
case|:
name|cache_fulltexts
operator|=
name|svn_tristate__from_word
argument_list|(
name|arg
argument_list|)
operator|==
name|svn_tristate_true
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CACHE_REVPROPS
case|:
name|cache_revprops
operator|=
name|svn_tristate__from_word
argument_list|(
name|arg
argument_list|)
operator|==
name|svn_tristate_true
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_BLOCK_READ
case|:
name|use_block_read
operator|=
name|svn_tristate__from_word
argument_list|(
name|arg
argument_list|)
operator|==
name|svn_tristate_true
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CLIENT_SPEED
case|:
block|{
name|apr_size_t
name|bandwidth
init|=
operator|(
name|apr_size_t
operator|)
name|apr_strtoi64
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* for slower clients, don't try anything fancy */
if|if
condition|(
name|bandwidth
operator|>=
literal|1000
condition|)
block|{
comment|/* block other clients for at most 1 ms (at full bandwidth).                    Note that the send buffer is 16kB anyways. */
name|params
operator|.
name|zero_copy_limit
operator|=
name|bandwidth
operator|*
literal|120
expr_stmt|;
comment|/* check for aborted connections at the same rate */
name|params
operator|.
name|error_check_interval
operator|=
name|bandwidth
operator|*
literal|120
expr_stmt|;
block|}
block|}
break|break;
case|case
name|SVNSERVE_OPT_MIN_THREADS
case|:
name|min_thread_count
operator|=
operator|(
name|apr_size_t
operator|)
name|apr_strtoi64
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_MAX_THREADS
case|:
name|max_thread_count
operator|=
operator|(
name|apr_size_t
operator|)
name|apr_strtoi64
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|WIN32
case|case
name|SVNSERVE_OPT_SERVICE
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_service
condition|)
block|{
name|run_mode
operator|=
name|run_mode_service
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|SVNSERVE_OPT_CONFIG_FILE
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|config_filename
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|config_filename
operator|=
name|svn_dirent_internal_style
argument_list|(
name|config_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|config_filename
argument_list|,
name|config_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_PID_FILE
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|pid_filename
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pid_filename
operator|=
name|svn_dirent_internal_style
argument_list|(
name|pid_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|pid_filename
argument_list|,
name|pid_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_VIRTUAL_HOST
case|:
name|params
operator|.
name|vhost
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_LOG_FILE
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|log_filename
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|log_filename
operator|=
name|svn_dirent_internal_style
argument_list|(
name|log_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|log_filename
argument_list|,
name|log_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is_version
condition|)
block|{
name|SVN_ERR
argument_list|(
name|version
argument_list|(
name|quiet
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|os
operator|->
name|ind
operator|!=
name|argc
condition|)
block|{
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|mode_opt_count
operator|!=
literal|1
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
ifdef|#
directive|ifdef
name|WIN32
name|_
argument_list|(
literal|"You must specify exactly one of -d, -i, -t, "
literal|"--service or -X.\n"
argument_list|)
argument_list|,
else|#
directive|else
name|_
argument_list|(
literal|"You must specify exactly one of -d, -i, -t or -X.\n"
argument_list|)
argument_list|,
endif|#
directive|endif
name|stderr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|handling_opt_count
operator|>
literal|1
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"You may only specify one of -T or --single-thread\n"
argument_list|)
argument_list|,
name|stderr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* construct object pools */
name|is_multi_threaded
operator|=
name|handling_mode
operator|==
name|connection_mode_thread
expr_stmt|;
name|params
operator|.
name|fs_config
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|params
operator|.
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_DELTAS
argument_list|,
name|cache_txdeltas
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|params
operator|.
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS
argument_list|,
name|cache_fulltexts
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|params
operator|.
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_REVPROPS
argument_list|,
name|cache_revprops
condition|?
literal|"2"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|params
operator|.
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_BLOCK_READ
argument_list|,
name|use_block_read
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__config_pool_create
argument_list|(
operator|&
name|params
operator|.
name|config_pool
argument_list|,
name|is_multi_threaded
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__authz_pool_create
argument_list|(
operator|&
name|params
operator|.
name|authz_pool
argument_list|,
name|params
operator|.
name|config_pool
argument_list|,
name|is_multi_threaded
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a configuration file is specified, load it and any referenced    * password and authorization files. */
if|if
condition|(
name|config_filename
condition|)
block|{
name|params
operator|.
name|base
operator|=
name|svn_dirent_dirname
argument_list|(
name|config_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos__config_pool_get
argument_list|(
operator|&
name|params
operator|.
name|cfg
argument_list|,
name|NULL
argument_list|,
name|params
operator|.
name|config_pool
argument_list|,
name|config_filename
argument_list|,
name|TRUE
argument_list|,
comment|/* must_exist */
name|FALSE
argument_list|,
comment|/* names_case_sensitive */
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_filename
condition|)
name|SVN_ERR
argument_list|(
name|logger__create
argument_list|(
operator|&
name|params
operator|.
name|logger
argument_list|,
name|log_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|run_mode
operator|==
name|run_mode_listen_once
condition|)
name|SVN_ERR
argument_list|(
name|logger__create_for_stderr
argument_list|(
operator|&
name|params
operator|.
name|logger
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|tunnel_user
operator|&&
name|run_mode
operator|!=
name|run_mode_tunnel
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Option --tunnel-user is only valid in tunnel mode"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|run_mode
operator|==
name|run_mode_inetd
operator|||
name|run_mode
operator|==
name|run_mode_tunnel
condition|)
block|{
name|apr_pool_t
modifier|*
name|connection_pool
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdin_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdout_stream
decl_stmt|;
name|params
operator|.
name|tunnel
operator|=
operator|(
name|run_mode
operator|==
name|run_mode_tunnel
operator|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|pool
argument_list|,
name|apr_pool_cleanup_null
argument_list|,
name|redirect_stdout
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdin
argument_list|(
operator|&
name|stdin_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use a subpool for the connection to ensure that if SASL is used        * the pool cleanup handlers that call sasl_dispose() (connection_pool)        * and sasl_done() (pool) are run in the right order. See issue #3664. */
name|connection_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|conn
operator|=
name|svn_ra_svn_create_conn4
argument_list|(
name|NULL
argument_list|,
name|stdin_stream
argument_list|,
name|stdout_stream
argument_list|,
name|params
operator|.
name|compression_level
argument_list|,
name|params
operator|.
name|zero_copy_limit
argument_list|,
name|params
operator|.
name|error_check_interval
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|serve
argument_list|(
name|conn
argument_list|,
operator|&
name|params
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|connection_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
ifdef|#
directive|ifdef
name|WIN32
comment|/* If svnserve needs to run as a Win32 service, then we need to      coordinate with the Service Control Manager (SCM) before      continuing.  This function call registers the svnserve.exe      process with the SCM, waits for the "start" command from the SCM      (which will come very quickly), and confirms that those steps      succeeded.       After this call succeeds, the service is free to run.  At some      point in the future, the SCM will send a message to the service,      requesting that it stop.  This is translated into a call to      winservice_notify_stop().  The service is then responsible for      cleanly terminating.       We need to do this before actually starting the service logic      (opening files, sockets, etc.) because the SCM wants you to      connect *first*, then do your service-specific logic.  If the      service process takes too long to connect to the SCM, then the      SCM will decide that the service is busted, and will give up on      it.      */
if|if
condition|(
name|run_mode
operator|==
name|run_mode_service
condition|)
block|{
name|err
operator|=
name|winservice_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnserve: "
argument_list|)
expr_stmt|;
comment|/* This is the most common error.  It means the user started              svnserve from a shell, and specified the --service              argument.  svnserve cannot be started, as a service, in              this way.  The --service argument is valid only valid if              svnserve is started by the SCM. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|APR_FROM_OS_ERROR
argument_list|(
name|ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"svnserve: The --service flag is only valid if the"
literal|" process is started by the Service Control Manager.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The service is now in the "starting" state.  Before the SCM will          consider the service "started", this thread must call the          winservice_running() function. */
block|}
endif|#
directive|endif
comment|/* WIN32 */
comment|/* Make sure we have IPV6 support first before giving apr_sockaddr_info_get      APR_UNSPEC, because it may give us back an IPV6 address even if we can't      create IPV6 sockets. */
if|#
directive|if
name|APR_HAVE_IPV6
ifdef|#
directive|ifdef
name|MAX_SECS_TO_LINGER
comment|/* ### old APR interface */
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|APR_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|APR_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
name|APR_PROTO_TCP
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|apr_socket_close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|family
operator|=
name|APR_UNSPEC
expr_stmt|;
if|if
condition|(
name|prefer_v6
condition|)
block|{
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
name|host
operator|=
literal|"::"
expr_stmt|;
name|sockaddr_info_flags
operator|=
name|APR_IPV6_ADDR_OK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
name|host
operator|=
literal|"0.0.0.0"
expr_stmt|;
name|sockaddr_info_flags
operator|=
name|APR_IPV4_ADDR_OK
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|status
operator|=
name|apr_sockaddr_info_get
argument_list|(
operator|&
name|sa
argument_list|,
name|host
argument_list|,
name|family
argument_list|,
name|port
argument_list|,
name|sockaddr_info_flags
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't get address info"
argument_list|)
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|MAX_SECS_TO_LINGER
comment|/* ### old APR interface */
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|sa
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|sa
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|APR_PROTO_TCP
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create server socket"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Prevents "socket in use" errors when server is killed and quickly    * restarted. */
name|status
operator|=
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_SO_REUSEADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't set options on server socket"
argument_list|)
argument_list|)
return|;
block|}
name|status
operator|=
name|apr_socket_bind
argument_list|(
name|sock
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't bind server socket"
argument_list|)
argument_list|)
return|;
block|}
name|status
operator|=
name|apr_socket_listen
argument_list|(
name|sock
argument_list|,
name|ACCEPT_BACKLOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't listen on server socket"
argument_list|)
argument_list|)
return|;
block|}
if|#
directive|if
name|APR_HAS_FORK
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_listen_once
operator|&&
operator|!
name|foreground
condition|)
comment|/* ### ignoring errors... */
name|apr_proc_detach
argument_list|(
name|APR_PROC_DETACH_DAEMONIZE
argument_list|)
expr_stmt|;
name|apr_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it, otherwise    * working with large files when compiled against an APR that doesn't have    * large file support will crash the program, which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid_filename
condition|)
name|SVN_ERR
argument_list|(
name|write_pid_file
argument_list|(
name|pid_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|status
operator|=
name|apr_os_sock_get
argument_list|(
operator|&
name|winservice_svnserve_accept_socket
argument_list|,
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|winservice_svnserve_accept_socket
operator|=
name|INVALID_SOCKET
expr_stmt|;
comment|/* At this point, the service is "running".  Notify the SCM. */
if|if
condition|(
name|run_mode
operator|==
name|run_mode_service
condition|)
name|winservice_running
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Configure FS caches for maximum efficiency with svnserve.    * For pre-forked (i.e. multi-processed) mode of operation,    * keep the per-process caches smaller than the default.    * Also, apply the respective command line parameters, if given. */
block|{
name|svn_cache_config_t
name|settings
init|=
operator|*
name|svn_cache_config_get
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|memory_cache_size
operator|!=
operator|-
literal|1
condition|)
name|settings
operator|.
name|cache_size
operator|=
name|params
operator|.
name|memory_cache_size
expr_stmt|;
name|settings
operator|.
name|single_threaded
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|handling_mode
operator|==
name|connection_mode_thread
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|settings
operator|.
name|single_threaded
operator|=
name|FALSE
expr_stmt|;
else|#
directive|else
comment|/* No requests will be processed at all          * (see "switch (handling_mode)" code further down).          * But if they were, some other synchronization code          * would need to take care of securing integrity of          * APR-based structures. That would include our caches.          */
endif|#
directive|endif
block|}
name|svn_cache_config_set
argument_list|(
operator|&
name|settings
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
name|SVN_ERR
argument_list|(
name|svn_root_pools__create
argument_list|(
operator|&
name|connection_pools
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handling_mode
operator|==
name|connection_mode_thread
condition|)
block|{
comment|/* create the thread pool with a valid range of threads */
if|if
condition|(
name|max_thread_count
operator|<
literal|1
condition|)
name|max_thread_count
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|min_thread_count
operator|>
name|max_thread_count
condition|)
name|min_thread_count
operator|=
name|max_thread_count
expr_stmt|;
name|status
operator|=
name|apr_thread_pool_create
argument_list|(
operator|&
name|threads
argument_list|,
name|min_thread_count
argument_list|,
name|max_thread_count
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create thread pool"
argument_list|)
argument_list|)
return|;
block|}
comment|/* let idle threads linger for a while in case more requests are          coming in */
name|apr_thread_pool_idle_wait_set
argument_list|(
name|threads
argument_list|,
name|THREADPOOL_THREAD_IDLE_LIMIT
argument_list|)
expr_stmt|;
comment|/* don't queue requests unless we reached the worker thread limit */
name|apr_thread_pool_threshold_set
argument_list|(
name|threads
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|threads
operator|=
name|NULL
expr_stmt|;
block|}
endif|#
directive|endif
while|while
condition|(
literal|1
condition|)
block|{
name|connection_t
modifier|*
name|connection
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|accept_connection
argument_list|(
operator|&
name|connection
argument_list|,
name|sock
argument_list|,
operator|&
name|params
argument_list|,
name|handling_mode
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|run_mode_listen_once
condition|)
block|{
name|err
operator|=
name|serve_socket
argument_list|(
name|connection
argument_list|,
name|connection
operator|->
name|pool
argument_list|)
expr_stmt|;
name|close_connection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
switch|switch
condition|(
name|handling_mode
condition|)
block|{
case|case
name|connection_mode_fork
case|:
if|#
directive|if
name|APR_HAS_FORK
name|status
operator|=
name|apr_proc_fork
argument_list|(
operator|&
name|proc
argument_list|,
name|connection
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_INCHILD
condition|)
block|{
comment|/* the child would't listen to the main server's socket */
name|apr_socket_close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
comment|/* serve_socket() logs any error it returns, so ignore it. */
name|svn_error_clear
argument_list|(
name|serve_socket
argument_list|(
name|connection
argument_list|,
name|connection
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|close_connection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|!=
name|APR_INPARENT
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
literal|"apr_proc_fork"
argument_list|)
expr_stmt|;
name|logger__log_error
argument_list|(
name|params
operator|.
name|logger
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|connection_mode_thread
case|:
comment|/* Create a detached thread for each connection.  That's not a              particularly sophisticated strategy for a threaded server, it's              little different from forking one process per connection. */
if|#
directive|if
name|APR_HAS_THREADS
name|attach_connection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_thread_pool_push
argument_list|(
name|threads
argument_list|,
name|serve_thread
argument_list|,
name|connection
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't push task"
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
break|break;
case|case
name|connection_mode_single
case|:
comment|/* Serve one connection at a time. */
comment|/* serve_socket() logs any error it returns, so ignore it. */
name|svn_error_clear
argument_list|(
name|serve_socket
argument_list|(
name|connection
argument_list|,
name|connection
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|close_connection
argument_list|(
name|connection
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|int
name|exit_code
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnserve"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool. */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|sub_main
argument_list|(
operator|&
name|exit_code
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Flush stdout and report if it fails. It would be flushed on exit anyway      but this makes sure that output is not silently lost if it fails. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
literal|"svnserve: "
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|APR_HAS_THREADS
comment|/* Explicitly wait for all threads to exit.  As we found out with similar      code in our C test framework, the memory pool cleanup below cannot be      trusted to do the right thing. */
if|if
condition|(
name|threads
condition|)
name|apr_thread_pool_destroy
argument_list|(
name|threads
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* this will also close the server's socket */
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

end_unit

