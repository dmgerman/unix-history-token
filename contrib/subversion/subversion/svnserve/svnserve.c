begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnserve.c :  Main control function for svnserve  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_getopt.h>
end_include

begin_include
include|#
directive|include
file|<apr_network_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|<apr_thread_proc.h>
end_include

begin_include
include|#
directive|include
file|<apr_portable.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra_svn.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_cache_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"winservice.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAVE_UNISTD_H
end_ifdef

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* For getpid() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"server.h"
end_include

begin_comment
comment|/* The strategy for handling incoming connections.  Some of these may be    unavailable due to platform limitations. */
end_comment

begin_enum
enum|enum
name|connection_handling_mode
block|{
name|connection_mode_fork
block|,
comment|/* Create a process per connection */
name|connection_mode_thread
block|,
comment|/* Create a thread per connection */
name|connection_mode_single
comment|/* One connection at a time in this process */
block|}
enum|;
end_enum

begin_comment
comment|/* The mode in which to run svnserve */
end_comment

begin_enum
enum|enum
name|run_mode
block|{
name|run_mode_unspecified
block|,
name|run_mode_inetd
block|,
name|run_mode_daemon
block|,
name|run_mode_tunnel
block|,
name|run_mode_listen_once
block|,
name|run_mode_service
block|}
enum|;
end_enum

begin_if
if|#
directive|if
name|APR_HAS_FORK
end_if

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_fork
end_define

begin_define
define|#
directive|define
name|CONNECTION_HAVE_THREAD_OPTION
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! APR_HAS_THREADS */
end_comment

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_fork
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ! APR_HAS_THREADS */
end_comment

begin_elif
elif|#
directive|elif
name|APR_HAS_THREADS
end_elif

begin_comment
comment|/* and ! APR_HAS_FORK */
end_comment

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_thread
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* ! APR_HAS_THREADS and ! APR_HAS_FORK */
end_comment

begin_define
define|#
directive|define
name|CONNECTION_DEFAULT
value|connection_mode_single
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|WIN32
end_ifdef

begin_decl_stmt
specifier|static
name|apr_os_sock_t
name|winservice_svnserve_accept_socket
init|=
name|INVALID_SOCKET
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The SCM calls this function (on an arbitrary thread, not the main()    thread!) when it wants to stop the service.     For now, our strategy is to close the listener socket, in order to    unblock main() and cause it to exit its accept loop.  We cannot use    apr_socket_close, because that function deletes the apr_socket_t    structure, as well as closing the socket handle.  If we called    apr_socket_close here, then main() will also call apr_socket_close,    resulting in a double-free.  This way, we just close the kernel    socket handle, which causes the accept() function call to fail,    which causes main() to clean up the socket.  So, memory gets freed    only once.     This isn't pretty, but it's better than a lot of other options.    Currently, there is no "right" way to shut down svnserve.     We store the OS handle rather than a pointer to the apr_socket_t    structure in order to eliminate any possibility of illegal memory    access. */
end_comment

begin_function
name|void
name|winservice_notify_stop
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|winservice_svnserve_accept_socket
operator|!=
name|INVALID_SOCKET
condition|)
name|closesocket
argument_list|(
name|winservice_svnserve_accept_socket
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _WIN32 */
end_comment

begin_comment
comment|/* Option codes and descriptions for svnserve.  *  * The entire list must be terminated with an entry of nulls.  *  * APR requires that options without abbreviations  * have codes greater than 255.  */
end_comment

begin_define
define|#
directive|define
name|SVNSERVE_OPT_LISTEN_PORT
value|256
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_LISTEN_HOST
value|257
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_FOREGROUND
value|258
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_TUNNEL_USER
value|259
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_VERSION
value|260
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_PID_FILE
value|261
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_SERVICE
value|262
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CONFIG_FILE
value|263
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_LOG_FILE
value|264
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CACHE_TXDELTAS
value|265
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CACHE_FULLTEXTS
value|266
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CACHE_REVPROPS
value|267
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_SINGLE_CONN
value|268
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_CLIENT_SPEED
value|269
end_define

begin_define
define|#
directive|define
name|SVNSERVE_OPT_VIRTUAL_HOST
value|270
end_define

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|svnserve__options
index|[]
init|=
block|{
block|{
literal|"daemon"
block|,
literal|'d'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"daemon mode"
argument_list|)
block|}
block|,
block|{
literal|"inetd"
block|,
literal|'i'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"inetd mode"
argument_list|)
block|}
block|,
block|{
literal|"tunnel"
block|,
literal|'t'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"tunnel mode"
argument_list|)
block|}
block|,
block|{
literal|"listen-once"
block|,
literal|'X'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"listen-once mode (useful for debugging)"
argument_list|)
block|}
block|,
ifdef|#
directive|ifdef
name|WIN32
block|{
literal|"service"
block|,
name|SVNSERVE_OPT_SERVICE
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Windows service mode (Service Control Manager)"
argument_list|)
block|}
block|,
endif|#
directive|endif
block|{
literal|"root"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"root of directory to serve"
argument_list|)
block|}
block|,
block|{
literal|"read-only"
block|,
literal|'R'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"force read only, overriding repository config file"
argument_list|)
block|}
block|,
block|{
literal|"config-file"
block|,
name|SVNSERVE_OPT_CONFIG_FILE
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"read configuration from file ARG"
argument_list|)
block|}
block|,
block|{
literal|"listen-port"
block|,
name|SVNSERVE_OPT_LISTEN_PORT
block|,
literal|1
block|,
ifdef|#
directive|ifdef
name|WIN32
name|N_
argument_list|(
literal|"listen port. The default port is 3690.\n"
literal|"                             "
literal|"[mode: daemon, service, listen-once]"
argument_list|)
block|}
block|,
else|#
directive|else
name|N_
argument_list|(
literal|"listen port. The default port is 3690.\n"
literal|"                             "
literal|"[mode: daemon, listen-once]"
argument_list|)
block|}
decl_stmt|,
endif|#
directive|endif
block|{
literal|"listen-host"
operator|,
name|SVNSERVE_OPT_LISTEN_HOST
operator|,
literal|1
operator|,
ifdef|#
directive|ifdef
name|WIN32
name|N_
argument_list|(
literal|"listen hostname or IP address\n"
literal|"                             "
literal|"By default svnserve listens on all addresses.\n"
literal|"                             "
literal|"[mode: daemon, service, listen-once]"
argument_list|)
block|}
end_decl_stmt

begin_operator
operator|,
end_operator

begin_else
else|#
directive|else
end_else

begin_macro
name|N_
argument_list|(
literal|"listen hostname or IP address\n"
literal|"                             "
literal|"By default svnserve listens on all addresses.\n"
literal|"                             "
literal|"[mode: daemon, listen-once]"
argument_list|)
end_macro

begin_endif
unit|},
endif|#
directive|endif
end_endif

begin_block
block|{
literal|"prefer-ipv6"
operator|,
literal|'6'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"prefer IPv6 when resolving the listen hostname\n"
literal|"                             "
literal|"[IPv4 is preferred by default. Using IPv4 and IPv6\n"
literal|"                             "
literal|"at the same time is not supported in daemon mode.\n"
literal|"                             "
literal|"Use inetd mode or tunnel mode if you need this.]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"compression"
operator|,
literal|'c'
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"compression level to use for network transmissions\n"
literal|"                             "
literal|"[0 .. no compression, 5 .. default, \n"
literal|"                             "
literal|" 9 .. maximum compression]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"memory-cache-size"
operator|,
literal|'M'
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"size of the extra in-memory cache in MB used to\n"
literal|"                             "
literal|"minimize redundant operations.\n"
literal|"                             "
literal|"Default is 128 for threaded and 16 for non-\n"
literal|"                             "
literal|"threaded mode.\n"
literal|"                             "
literal|"[used for FSFS repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"cache-txdeltas"
operator|,
name|SVNSERVE_OPT_CACHE_TXDELTAS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"enable or disable caching of deltas between older\n"
literal|"                             "
literal|"revisions.\n"
literal|"                             "
literal|"Default is no.\n"
literal|"                             "
literal|"[used for FSFS repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"cache-fulltexts"
operator|,
name|SVNSERVE_OPT_CACHE_FULLTEXTS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"enable or disable caching of file contents\n"
literal|"                             "
literal|"Default is yes.\n"
literal|"                             "
literal|"[used for FSFS repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"cache-revprops"
operator|,
name|SVNSERVE_OPT_CACHE_REVPROPS
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"enable or disable caching of revision properties.\n"
literal|"                             "
literal|"Consult the documentation before activating this.\n"
literal|"                             "
literal|"Default is no.\n"
literal|"                             "
literal|"[used for FSFS repositories only]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"client-speed"
operator|,
name|SVNSERVE_OPT_CLIENT_SPEED
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"Optimize network handling based on the assumption\n"
literal|"                             "
literal|"that most clients are connected with a bitrate of\n"
literal|"                             "
literal|"ARG Mbit/s.\n"
literal|"                             "
literal|"Default is 0 (optimizations disabled)."
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_ifdef
ifdef|#
directive|ifdef
name|CONNECTION_HAVE_THREAD_OPTION
end_ifdef

begin_comment
comment|/* ### Making the assumption here that WIN32 never has fork and so      * ### this option never exists when --service exists. */
end_comment

begin_block
block|{
literal|"threads"
operator|,
literal|'T'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"use threads instead of fork "
literal|"[mode: daemon]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
literal|"foreground"
operator|,
name|SVNSERVE_OPT_FOREGROUND
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"run in foreground (useful for debugging)\n"
literal|"                             "
literal|"[mode: daemon]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"single-thread"
operator|,
name|SVNSERVE_OPT_SINGLE_CONN
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"handle one connection at a time in the parent process\n"
literal|"                             "
literal|"(useful for debugging)"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"log-file"
operator|,
name|SVNSERVE_OPT_LOG_FILE
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"svnserve log file"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"pid-file"
operator|,
name|SVNSERVE_OPT_PID_FILE
operator|,
literal|1
operator|,
ifdef|#
directive|ifdef
name|WIN32
name|N_
argument_list|(
literal|"write server process ID to file ARG\n"
literal|"                             "
literal|"[mode: daemon, listen-once, service]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_else
else|#
directive|else
end_else

begin_macro
name|N_
argument_list|(
literal|"write server process ID to file ARG\n"
literal|"                             "
literal|"[mode: daemon, listen-once]"
argument_list|)
end_macro

begin_endif
unit|},
endif|#
directive|endif
end_endif

begin_block
block|{
literal|"tunnel-user"
operator|,
name|SVNSERVE_OPT_TUNNEL_USER
operator|,
literal|1
operator|,
name|N_
argument_list|(
literal|"tunnel username (default is current uid's name)\n"
literal|"                             "
literal|"[mode: tunnel]"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"help"
operator|,
literal|'h'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"display this help"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"virtual-host"
operator|,
name|SVNSERVE_OPT_VIRTUAL_HOST
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"virtual host mode (look for repo in directory\n"
literal|"                             "
literal|"of provided hostname)"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"version"
operator|,
name|SVNSERVE_OPT_VERSION
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|"quiet"
operator|,
literal|'q'
operator|,
literal|0
operator|,
name|N_
argument_list|(
literal|"no progress (only errors) to stderr"
argument_list|)
block|}
end_block

begin_operator
operator|,
end_operator

begin_block
block|{
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
block|}
end_block

begin_function
unit|};
specifier|static
name|void
name|usage
parameter_list|(
specifier|const
name|char
modifier|*
name|progname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|progname
condition|)
name|progname
operator|=
literal|"svnserve"
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Type '%s --help' for usage.\n"
argument_list|)
argument_list|,
name|progname
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"usage: svnserve [-d | -i | -t | -X "
literal|"| --service] [options]\n"
literal|"\n"
literal|"Valid options:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"usage: svnserve [-d | -i | -t | -X] "
literal|"[options]\n"
literal|"\n"
literal|"Valid options:\n"
argument_list|)
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|svnserve__options
index|[
name|i
index|]
operator|.
name|name
operator|&&
name|svnserve__options
index|[
name|i
index|]
operator|.
name|optch
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|svnserve__options
operator|+
name|i
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|,
literal|"  %s\n"
argument_list|,
name|optstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|version
parameter_list|(
name|svn_boolean_t
name|quiet
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fs_desc_start
init|=
name|_
argument_list|(
literal|"The following repository back-end (FS) modules are available:\n\n"
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|version_footer
decl_stmt|;
name|version_footer
operator|=
name|svn_stringbuf_create
argument_list|(
name|fs_desc_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
name|svn_stringbuf_appendcstr
argument_list|(
name|version_footer
argument_list|,
name|_
argument_list|(
literal|"\nCyrus SASL authentication is available.\n"
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|svn_opt_print_help4
argument_list|(
name|NULL
argument_list|,
literal|"svnserve"
argument_list|,
name|TRUE
argument_list|,
name|quiet
argument_list|,
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_FORK
end_if

begin_function
specifier|static
name|void
name|sigchld_handler
parameter_list|(
name|int
name|signo
parameter_list|)
block|{
comment|/* Nothing to do; we just need to interrupt the accept(). */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Redirect stdout to stderr.  ARG is the pool.  *  * In tunnel or inetd mode, we don't want hook scripts corrupting the  * data stream by sending data to stdout, so we need to redirect  * stdout somewhere else.  Sending it to stderr is acceptable; sending  * it to /dev/null is another option, but apr doesn't provide a way to  * do that without also detaching from the controlling terminal.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|redirect_stdout
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|arg
decl_stmt|;
name|apr_file_t
modifier|*
name|out_file
decl_stmt|,
modifier|*
name|err_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
if|if
condition|(
operator|(
name|apr_err
operator|=
name|apr_file_open_stdout
argument_list|(
operator|&
name|out_file
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|apr_err
return|;
if|if
condition|(
operator|(
name|apr_err
operator|=
name|apr_file_open_stderr
argument_list|(
operator|&
name|err_file
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|apr_err
return|;
return|return
name|apr_file_dup2
argument_list|(
name|out_file
argument_list|,
name|err_file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_comment
comment|/* The pool passed to apr_thread_create can only be released when both        A: the call to apr_thread_create has returned to the calling thread       B: the new thread has started running and reached apr_thread_start_t     So we set the atomic counter to 2 then both the calling thread and    the new thread decrease it and when it reaches 0 the pool can be    released.  */
end_comment

begin_struct
struct|struct
name|shared_pool_t
block|{
name|svn_atomic_t
name|count
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|shared_pool_t
modifier|*
name|attach_shared_pool
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|shared_pool_t
modifier|*
name|shared
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|shared_pool_t
argument_list|)
argument_list|)
decl_stmt|;
name|shared
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|svn_atomic_set
argument_list|(
operator|&
name|shared
operator|->
name|count
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|shared
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|release_shared_pool
parameter_list|(
name|struct
name|shared_pool_t
modifier|*
name|shared
parameter_list|)
block|{
if|if
condition|(
name|svn_atomic_dec
argument_list|(
operator|&
name|shared
operator|->
name|count
argument_list|)
operator|==
literal|0
condition|)
name|svn_pool_destroy
argument_list|(
name|shared
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* "Arguments" passed from the main thread to the connection thread */
end_comment

begin_struct
struct|struct
name|serve_thread_t
block|{
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|serve_params_t
modifier|*
name|params
decl_stmt|;
name|struct
name|shared_pool_t
modifier|*
name|shared_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_function
specifier|static
name|void
modifier|*
name|APR_THREAD_FUNC
name|serve_thread
parameter_list|(
name|apr_thread_t
modifier|*
name|tid
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|serve_thread_t
modifier|*
name|d
init|=
name|data
decl_stmt|;
name|svn_error_clear
argument_list|(
name|serve
argument_list|(
name|d
operator|->
name|conn
argument_list|,
name|d
operator|->
name|params
argument_list|,
name|d
operator|->
name|shared_pool
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|release_shared_pool
argument_list|(
name|d
operator|->
name|shared_pool
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Write the PID of the current process as a decimal number, followed by a    newline to the file FILENAME, using POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_pid_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|contents
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_PID_T_FMT
literal|"\n"
argument_list|,
name|getpid
argument_list|()
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_TRUNCATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|contents
argument_list|,
name|strlen
argument_list|(
name|contents
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_repos"
block|,
name|svn_repos_version
block|}
block|,
block|{
literal|"svn_fs"
block|,
name|svn_fs_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
literal|"svn_ra_svn"
block|,
name|svn_ra_svn_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|enum
name|run_mode
name|run_mode
init|=
name|run_mode_unspecified
decl_stmt|;
name|svn_boolean_t
name|foreground
init|=
name|FALSE
decl_stmt|;
name|apr_socket_t
modifier|*
name|sock
decl_stmt|,
modifier|*
name|usock
decl_stmt|;
name|apr_file_t
modifier|*
name|in_file
decl_stmt|,
modifier|*
name|out_file
decl_stmt|;
name|apr_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_pool_t
modifier|*
name|connection_pool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|int
name|opt
decl_stmt|;
name|serve_params_t
name|params
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|apr_proc_t
name|proc
decl_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_threadattr_t
modifier|*
name|tattr
decl_stmt|;
name|apr_thread_t
modifier|*
name|tid
decl_stmt|;
name|struct
name|shared_pool_t
modifier|*
name|shared_pool
decl_stmt|;
name|struct
name|serve_thread_t
modifier|*
name|thread_data
decl_stmt|;
endif|#
directive|endif
name|enum
name|connection_handling_mode
name|handling_mode
init|=
name|CONNECTION_DEFAULT
decl_stmt|;
name|apr_uint16_t
name|port
init|=
name|SVN_RA_SVN_PORT
decl_stmt|;
specifier|const
name|char
modifier|*
name|host
init|=
name|NULL
decl_stmt|;
name|int
name|family
init|=
name|APR_INET
decl_stmt|;
name|apr_int32_t
name|sockaddr_info_flags
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|APR_HAVE_IPV6
name|svn_boolean_t
name|prefer_v6
init|=
name|FALSE
decl_stmt|;
endif|#
directive|endif
name|svn_boolean_t
name|quiet
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|is_version
init|=
name|FALSE
decl_stmt|;
name|int
name|mode_opt_count
init|=
literal|0
decl_stmt|;
name|int
name|handling_opt_count
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_filename
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|pid_filename
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_filename
init|=
name|NULL
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnserve"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool. */
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
name|SVN_INT_ERR
argument_list|(
name|cyrus_init
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check library versions */
name|err
operator|=
name|check_lib_versions
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
comment|/* Initialize the FS library. */
name|err
operator|=
name|svn_fs_initialize
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
name|err
operator|=
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
name|params
operator|.
name|root
operator|=
literal|"/"
expr_stmt|;
name|params
operator|.
name|tunnel
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|tunnel_user
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|read_only
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|base
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|cfg
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|compression_level
operator|=
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
expr_stmt|;
name|params
operator|.
name|log_file
operator|=
name|NULL
expr_stmt|;
name|params
operator|.
name|vhost
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|username_case
operator|=
name|CASE_ASIS
expr_stmt|;
name|params
operator|.
name|memory_cache_size
operator|=
operator|(
name|apr_uint64_t
operator|)
operator|-
literal|1
expr_stmt|;
name|params
operator|.
name|cache_fulltexts
operator|=
name|TRUE
expr_stmt|;
name|params
operator|.
name|cache_txdeltas
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|cache_revprops
operator|=
name|FALSE
expr_stmt|;
name|params
operator|.
name|zero_copy_limit
operator|=
literal|0
expr_stmt|;
name|params
operator|.
name|error_check_interval
operator|=
literal|4096
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|status
operator|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|svnserve__options
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
break|break;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'6'
case|:
if|#
directive|if
name|APR_HAVE_IPV6
name|prefer_v6
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* ### Maybe error here if we don't have IPV6 support? */
break|break;
case|case
literal|'h'
case|:
name|help
argument_list|(
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_VERSION
case|:
name|is_version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_daemon
condition|)
block|{
name|run_mode
operator|=
name|run_mode_daemon
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_FOREGROUND
case|:
name|foreground
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_SINGLE_CONN
case|:
name|handling_mode
operator|=
name|connection_mode_single
expr_stmt|;
name|handling_opt_count
operator|++
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_inetd
condition|)
block|{
name|run_mode
operator|=
name|run_mode_inetd
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_LISTEN_PORT
case|:
block|{
name|apr_uint64_t
name|val
decl_stmt|;
name|err
operator|=
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|val
argument_list|,
name|arg
argument_list|,
literal|0
argument_list|,
name|APR_UINT16_MAX
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Invalid port '%s'"
argument_list|)
argument_list|,
name|arg
argument_list|)
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
name|port
operator|=
operator|(
name|apr_uint16_t
operator|)
name|val
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_LISTEN_HOST
case|:
name|host
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_tunnel
condition|)
block|{
name|run_mode
operator|=
name|run_mode_tunnel
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|SVNSERVE_OPT_TUNNEL_USER
case|:
name|params
operator|.
name|tunnel_user
operator|=
name|arg
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_listen_once
condition|)
block|{
name|run_mode
operator|=
name|run_mode_listen_once
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'r'
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|params
operator|.
name|root
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_check_resolved_path
argument_list|(
name|params
operator|.
name|root
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"svnserve: Root path '%s' does not exist "
literal|"or is not a directory.\n"
argument_list|)
argument_list|,
name|params
operator|.
name|root
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
name|params
operator|.
name|root
operator|=
name|svn_dirent_internal_style
argument_list|(
name|params
operator|.
name|root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|params
operator|.
name|root
argument_list|,
name|params
operator|.
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|params
operator|.
name|read_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|handling_mode
operator|=
name|connection_mode_thread
expr_stmt|;
name|handling_opt_count
operator|++
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|params
operator|.
name|compression_level
operator|=
name|atoi
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|compression_level
operator|<
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
condition|)
name|params
operator|.
name|compression_level
operator|=
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|compression_level
operator|>
name|SVN_DELTA_COMPRESSION_LEVEL_MAX
condition|)
name|params
operator|.
name|compression_level
operator|=
name|SVN_DELTA_COMPRESSION_LEVEL_MAX
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|params
operator|.
name|memory_cache_size
operator|=
literal|0x100000
operator|*
name|apr_strtoi64
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CACHE_TXDELTAS
case|:
name|params
operator|.
name|cache_txdeltas
operator|=
name|svn_tristate__from_word
argument_list|(
name|arg
argument_list|)
operator|==
name|svn_tristate_true
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CACHE_FULLTEXTS
case|:
name|params
operator|.
name|cache_fulltexts
operator|=
name|svn_tristate__from_word
argument_list|(
name|arg
argument_list|)
operator|==
name|svn_tristate_true
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CACHE_REVPROPS
case|:
name|params
operator|.
name|cache_revprops
operator|=
name|svn_tristate__from_word
argument_list|(
name|arg
argument_list|)
operator|==
name|svn_tristate_true
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_CLIENT_SPEED
case|:
block|{
name|apr_size_t
name|bandwidth
init|=
operator|(
name|apr_size_t
operator|)
name|apr_strtoi64
argument_list|(
name|arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* for slower clients, don't try anything fancy */
if|if
condition|(
name|bandwidth
operator|>=
literal|1000
condition|)
block|{
comment|/* block other clients for at most 1 ms (at full bandwidth).                    Note that the send buffer is 16kB anyways. */
name|params
operator|.
name|zero_copy_limit
operator|=
name|bandwidth
operator|*
literal|120
expr_stmt|;
comment|/* check for aborted connections at the same rate */
name|params
operator|.
name|error_check_interval
operator|=
name|bandwidth
operator|*
literal|120
expr_stmt|;
block|}
block|}
break|break;
ifdef|#
directive|ifdef
name|WIN32
case|case
name|SVNSERVE_OPT_SERVICE
case|:
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_service
condition|)
block|{
name|run_mode
operator|=
name|run_mode_service
expr_stmt|;
name|mode_opt_count
operator|++
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
case|case
name|SVNSERVE_OPT_CONFIG_FILE
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|config_filename
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|config_filename
operator|=
name|svn_dirent_internal_style
argument_list|(
name|config_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|config_filename
argument_list|,
name|config_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_PID_FILE
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|pid_filename
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pid_filename
operator|=
name|svn_dirent_internal_style
argument_list|(
name|pid_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|pid_filename
argument_list|,
name|pid_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_VIRTUAL_HOST
case|:
name|params
operator|.
name|vhost
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SVNSERVE_OPT_LOG_FILE
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|log_filename
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|log_filename
operator|=
name|svn_dirent_internal_style
argument_list|(
name|log_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|log_filename
argument_list|,
name|log_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is_version
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|version
argument_list|(
name|quiet
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|os
operator|->
name|ind
operator|!=
name|argc
condition|)
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode_opt_count
operator|!=
literal|1
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
ifdef|#
directive|ifdef
name|WIN32
name|_
argument_list|(
literal|"You must specify exactly one of -d, -i, -t, "
literal|"--service or -X.\n"
argument_list|)
argument_list|,
else|#
directive|else
name|_
argument_list|(
literal|"You must specify exactly one of -d, -i, -t or -X.\n"
argument_list|)
argument_list|,
endif|#
directive|endif
name|stderr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|handling_opt_count
operator|>
literal|1
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"You may only specify one of -T or --single-thread\n"
argument_list|)
argument_list|,
name|stderr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|usage
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If a configuration file is specified, load it and any referenced    * password and authorization files. */
if|if
condition|(
name|config_filename
condition|)
block|{
name|params
operator|.
name|base
operator|=
name|svn_dirent_dirname
argument_list|(
name|config_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|params
operator|.
name|cfg
argument_list|,
name|config_filename
argument_list|,
name|TRUE
argument_list|,
comment|/* must_exist */
name|FALSE
argument_list|,
comment|/* section_names_case_sensitive */
name|FALSE
argument_list|,
comment|/* option_names_case_sensitive */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|log_filename
condition|)
name|SVN_INT_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|params
operator|.
name|log_file
argument_list|,
name|log_filename
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_APPEND
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|params
operator|.
name|tunnel_user
operator|&&
name|run_mode
operator|!=
name|run_mode_tunnel
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Option --tunnel-user is only valid in tunnel mode.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|run_mode
operator|==
name|run_mode_inetd
operator|||
name|run_mode
operator|==
name|run_mode_tunnel
condition|)
block|{
name|params
operator|.
name|tunnel
operator|=
operator|(
name|run_mode
operator|==
name|run_mode_tunnel
operator|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|pool
argument_list|,
name|apr_pool_cleanup_null
argument_list|,
name|redirect_stdout
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_file_open_stdin
argument_list|(
operator|&
name|in_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't open stdin"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
block|}
name|status
operator|=
name|apr_file_open_stdout
argument_list|(
operator|&
name|out_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't open stdout"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
block|}
comment|/* Use a subpool for the connection to ensure that if SASL is used        * the pool cleanup handlers that call sasl_dispose() (connection_pool)        * and sasl_done() (pool) are run in the right order. See issue #3664. */
name|connection_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|conn
operator|=
name|svn_ra_svn_create_conn3
argument_list|(
name|NULL
argument_list|,
name|in_file
argument_list|,
name|out_file
argument_list|,
name|params
operator|.
name|compression_level
argument_list|,
name|params
operator|.
name|zero_copy_limit
argument_list|,
name|params
operator|.
name|error_check_interval
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|serve
argument_list|(
name|conn
argument_list|,
operator|&
name|params
argument_list|,
name|connection_pool
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|WIN32
comment|/* If svnserve needs to run as a Win32 service, then we need to      coordinate with the Service Control Manager (SCM) before      continuing.  This function call registers the svnserve.exe      process with the SCM, waits for the "start" command from the SCM      (which will come very quickly), and confirms that those steps      succeeded.       After this call succeeds, the service is free to run.  At some      point in the future, the SCM will send a message to the service,      requesting that it stop.  This is translated into a call to      winservice_notify_stop().  The service is then responsible for      cleanly terminating.       We need to do this before actually starting the service logic      (opening files, sockets, etc.) because the SCM wants you to      connect *first*, then do your service-specific logic.  If the      service process takes too long to connect to the SCM, then the      SCM will decide that the service is busted, and will give up on      it.      */
if|if
condition|(
name|run_mode
operator|==
name|run_mode_service
condition|)
block|{
name|err
operator|=
name|winservice_start
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnserve: "
argument_list|)
expr_stmt|;
comment|/* This is the most common error.  It means the user started              svnserve from a shell, and specified the --service              argument.  svnserve cannot be started, as a service, in              this way.  The --service argument is valid only valid if              svnserve is started by the SCM. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|APR_FROM_OS_ERROR
argument_list|(
name|ERROR_FAILED_SERVICE_CONTROLLER_CONNECT
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"svnserve: The --service flag is only valid if the"
literal|" process is started by the Service Control Manager.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* The service is now in the "starting" state.  Before the SCM will          consider the service "started", this thread must call the          winservice_running() function. */
block|}
endif|#
directive|endif
comment|/* WIN32 */
comment|/* Make sure we have IPV6 support first before giving apr_sockaddr_info_get      APR_UNSPEC, because it may give us back an IPV6 address even if we can't      create IPV6 sockets. */
if|#
directive|if
name|APR_HAVE_IPV6
ifdef|#
directive|ifdef
name|MAX_SECS_TO_LINGER
comment|/* ### old APR interface */
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|APR_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|APR_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
name|APR_PROTO_TCP
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|apr_socket_close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|family
operator|=
name|APR_UNSPEC
expr_stmt|;
if|if
condition|(
name|prefer_v6
condition|)
block|{
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
name|host
operator|=
literal|"::"
expr_stmt|;
name|sockaddr_info_flags
operator|=
name|APR_IPV6_ADDR_OK
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
name|host
operator|=
literal|"0.0.0.0"
expr_stmt|;
name|sockaddr_info_flags
operator|=
name|APR_IPV4_ADDR_OK
expr_stmt|;
block|}
block|}
endif|#
directive|endif
name|status
operator|=
name|apr_sockaddr_info_get
argument_list|(
operator|&
name|sa
argument_list|,
name|host
argument_list|,
name|family
argument_list|,
name|port
argument_list|,
name|sockaddr_info_flags
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't get address info"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|MAX_SECS_TO_LINGER
comment|/* ### old APR interface */
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|sa
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|apr_socket_create
argument_list|(
operator|&
name|sock
argument_list|,
name|sa
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|APR_PROTO_TCP
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create server socket"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
block|}
comment|/* Prevents "socket in use" errors when server is killed and quickly    * restarted. */
name|apr_socket_opt_set
argument_list|(
name|sock
argument_list|,
name|APR_SO_REUSEADDR
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_socket_bind
argument_list|(
name|sock
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't bind server socket"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
block|}
name|apr_socket_listen
argument_list|(
name|sock
argument_list|,
literal|7
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_FORK
if|if
condition|(
name|run_mode
operator|!=
name|run_mode_listen_once
operator|&&
operator|!
name|foreground
condition|)
name|apr_proc_detach
argument_list|(
name|APR_PROC_DETACH_DAEMONIZE
argument_list|)
expr_stmt|;
name|apr_signal
argument_list|(
name|SIGCHLD
argument_list|,
name|sigchld_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it, otherwise    * working with large files when compiled against an APR that doesn't have    * large file support will crash the program, which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pid_filename
condition|)
name|SVN_INT_ERR
argument_list|(
name|write_pid_file
argument_list|(
name|pid_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|WIN32
name|status
operator|=
name|apr_os_sock_get
argument_list|(
operator|&
name|winservice_svnserve_accept_socket
argument_list|,
name|sock
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|winservice_svnserve_accept_socket
operator|=
name|INVALID_SOCKET
expr_stmt|;
comment|/* At this point, the service is "running".  Notify the SCM. */
if|if
condition|(
name|run_mode
operator|==
name|run_mode_service
condition|)
name|winservice_running
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Configure FS caches for maximum efficiency with svnserve.    * For pre-forked (i.e. multi-processed) mode of operation,    * keep the per-process caches smaller than the default.    * Also, apply the respective command line parameters, if given. */
block|{
name|svn_cache_config_t
name|settings
init|=
operator|*
name|svn_cache_config_get
argument_list|()
decl_stmt|;
if|if
condition|(
name|params
operator|.
name|memory_cache_size
operator|!=
operator|-
literal|1
condition|)
name|settings
operator|.
name|cache_size
operator|=
name|params
operator|.
name|memory_cache_size
expr_stmt|;
name|settings
operator|.
name|single_threaded
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|handling_mode
operator|==
name|connection_mode_thread
condition|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|settings
operator|.
name|single_threaded
operator|=
name|FALSE
expr_stmt|;
else|#
directive|else
comment|/* No requests will be processed at all          * (see "switch (handling_mode)" code further down).          * But if they were, some other synchronization code          * would need to take care of securing integrity of          * APR-based structures. That would include our caches.          */
endif|#
directive|endif
block|}
name|svn_cache_config_set
argument_list|(
operator|&
name|settings
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|WIN32
if|if
condition|(
name|winservice_is_stopping
argument_list|()
condition|)
return|return
name|ERROR_SUCCESS
return|;
endif|#
directive|endif
comment|/* Non-standard pool handling.  The main thread never blocks to join          the connection threads so it cannot clean up after each one.  So          separate pools that can be cleared at thread exit are used. */
name|connection_pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_socket_accept
argument_list|(
operator|&
name|usock
argument_list|,
name|sock
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|handling_mode
operator|==
name|connection_mode_fork
condition|)
block|{
comment|/* Collect any zombie child processes. */
while|while
condition|(
name|apr_proc_wait_all_procs
argument_list|(
operator|&
name|proc
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|APR_NOWAIT
argument_list|,
name|connection_pool
argument_list|)
operator|==
name|APR_CHILD_DONE
condition|)
empty_stmt|;
block|}
if|if
condition|(
name|APR_STATUS_IS_EINTR
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNABORTED
argument_list|(
name|status
argument_list|)
operator|||
name|APR_STATUS_IS_ECONNRESET
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|connection_pool
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't accept client connection"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnserve: "
argument_list|)
return|;
block|}
comment|/* Enable TCP keep-alives on the socket so we time out when        * the connection breaks due to network-layer problems.        * If the peer has dropped the connection due to a network partition        * or a crash, or if the peer no longer considers the connection        * valid because we are behind a NAT and our public IP has changed,        * it will respond to the keep-alive probe with a RST instead of an        * acknowledgment segment, which will cause svn to abort the session        * even while it is currently blocked waiting for data from the peer. */
name|status
operator|=
name|apr_socket_opt_set
argument_list|(
name|usock
argument_list|,
name|APR_SO_KEEPALIVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* It's not a fatal error if we cannot enable keep-alives. */
block|}
name|conn
operator|=
name|svn_ra_svn_create_conn3
argument_list|(
name|usock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|params
operator|.
name|compression_level
argument_list|,
name|params
operator|.
name|zero_copy_limit
argument_list|,
name|params
operator|.
name|error_check_interval
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|run_mode
operator|==
name|run_mode_listen_once
condition|)
block|{
name|err
operator|=
name|serve
argument_list|(
name|conn
argument_list|,
operator|&
name|params
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stdout
argument_list|,
name|FALSE
argument_list|,
literal|"svnserve: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|apr_socket_close
argument_list|(
name|usock
argument_list|)
expr_stmt|;
name|apr_socket_close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|handling_mode
condition|)
block|{
case|case
name|connection_mode_fork
case|:
if|#
directive|if
name|APR_HAS_FORK
name|status
operator|=
name|apr_proc_fork
argument_list|(
operator|&
name|proc
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_INCHILD
condition|)
block|{
name|apr_socket_close
argument_list|(
name|sock
argument_list|)
expr_stmt|;
name|err
operator|=
name|serve
argument_list|(
name|conn
argument_list|,
operator|&
name|params
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
name|err
argument_list|,
name|params
operator|.
name|log_file
argument_list|,
name|svn_ra_svn_conn_remote_host
argument_list|(
name|conn
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* user, repos */
name|connection_pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|apr_socket_close
argument_list|(
name|usock
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|APR_INPARENT
condition|)
block|{
name|apr_socket_close
argument_list|(
name|usock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
literal|"apr_proc_fork"
argument_list|)
expr_stmt|;
name|log_error
argument_list|(
name|err
argument_list|,
name|params
operator|.
name|log_file
argument_list|,
name|svn_ra_svn_conn_remote_host
argument_list|(
name|conn
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
comment|/* user, repos */
name|connection_pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|apr_socket_close
argument_list|(
name|usock
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|connection_pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|connection_mode_thread
case|:
comment|/* Create a detached thread for each connection.  That's not a              particularly sophisticated strategy for a threaded server, it's              little different from forking one process per connection. */
if|#
directive|if
name|APR_HAS_THREADS
name|shared_pool
operator|=
name|attach_shared_pool
argument_list|(
name|connection_pool
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_threadattr_create
argument_list|(
operator|&
name|tattr
argument_list|,
name|connection_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create threadattr"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnserve: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|apr_threadattr_detach_set
argument_list|(
name|tattr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't set detached state"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnserve: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|thread_data
operator|=
name|apr_palloc
argument_list|(
name|connection_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|thread_data
argument_list|)
argument_list|)
expr_stmt|;
name|thread_data
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|thread_data
operator|->
name|params
operator|=
operator|&
name|params
expr_stmt|;
name|thread_data
operator|->
name|shared_pool
operator|=
name|shared_pool
expr_stmt|;
name|status
operator|=
name|apr_thread_create
argument_list|(
operator|&
name|tid
argument_list|,
name|tattr
argument_list|,
name|serve_thread
argument_list|,
name|thread_data
argument_list|,
name|shared_pool
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create thread"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnserve: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|release_shared_pool
argument_list|(
name|shared_pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|connection_mode_single
case|:
comment|/* Serve one connection at a time. */
name|svn_error_clear
argument_list|(
name|serve
argument_list|(
name|conn
argument_list|,
operator|&
name|params
argument_list|,
name|connection_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|connection_pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

end_unit

