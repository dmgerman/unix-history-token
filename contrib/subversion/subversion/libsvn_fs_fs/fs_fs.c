begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs_fs.c --- filesystem operations specific to fs_fs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|<apr_sha1.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_thread_mutex.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"key-gen.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_delta_private.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_comment
comment|/* An arbitrary maximum path length, so clients can't run us out of memory  * by giving us arbitrarily large paths. */
end_comment

begin_define
define|#
directive|define
name|FSFS_MAX_PATH_LEN
value|4096
end_define

begin_comment
comment|/* The default maximum number of files per directory to store in the    rev and revprops directory.  The number below is somewhat arbitrary,    and can be overridden by defining the macro while compiling; the    figure of 1000 is reasonable for VFAT filesystems, which are by far    the worst performers in this area. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR
end_ifndef

begin_define
define|#
directive|define
name|SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR
value|1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Begin deltification after a node history exceeded this this limit.    Useful values are 4 to 64 with 16 being a good compromise between    computational overhead and repository size savings.    Should be a power of 2.    Values< 2 will result in standard skip-delta behavior. */
end_comment

begin_define
define|#
directive|define
name|SVN_FS_FS_MAX_LINEAR_DELTIFICATION
value|16
end_define

begin_comment
comment|/* Finding a deltification base takes operations proportional to the    number of changes being skipped. To prevent exploding runtime    during commits, limit the deltification range to this value.    Should be a power of 2 minus one.    Values< 1 disable deltification. */
end_comment

begin_define
define|#
directive|define
name|SVN_FS_FS_MAX_DELTIFICATION_WALK
value|1023
end_define

begin_comment
comment|/* Give writing processes 10 seconds to replace an existing revprop    file with a new one. After that time, we assume that the writing    process got aborted and that we have re-read revprops. */
end_comment

begin_define
define|#
directive|define
name|REVPROP_CHANGE_TIMEOUT
value|(10 * 1000000)
end_define

begin_comment
comment|/* The following are names of atomics that will be used to communicate  * revprop updates across all processes on this machine. */
end_comment

begin_define
define|#
directive|define
name|ATOMIC_REVPROP_GENERATION
value|"rev-prop-generation"
end_define

begin_define
define|#
directive|define
name|ATOMIC_REVPROP_TIMEOUT
value|"rev-prop-timeout"
end_define

begin_define
define|#
directive|define
name|ATOMIC_REVPROP_NAMESPACE
value|"rev-prop-atomics"
end_define

begin_comment
comment|/* Following are defines that specify the textual elements of the    native filesystem directories and revision files. */
end_comment

begin_comment
comment|/* Headers used to describe node-revision in the revision file. */
end_comment

begin_define
define|#
directive|define
name|HEADER_ID
value|"id"
end_define

begin_define
define|#
directive|define
name|HEADER_TYPE
value|"type"
end_define

begin_define
define|#
directive|define
name|HEADER_COUNT
value|"count"
end_define

begin_define
define|#
directive|define
name|HEADER_PROPS
value|"props"
end_define

begin_define
define|#
directive|define
name|HEADER_TEXT
value|"text"
end_define

begin_define
define|#
directive|define
name|HEADER_CPATH
value|"cpath"
end_define

begin_define
define|#
directive|define
name|HEADER_PRED
value|"pred"
end_define

begin_define
define|#
directive|define
name|HEADER_COPYFROM
value|"copyfrom"
end_define

begin_define
define|#
directive|define
name|HEADER_COPYROOT
value|"copyroot"
end_define

begin_define
define|#
directive|define
name|HEADER_FRESHTXNRT
value|"is-fresh-txn-root"
end_define

begin_define
define|#
directive|define
name|HEADER_MINFO_HERE
value|"minfo-here"
end_define

begin_define
define|#
directive|define
name|HEADER_MINFO_CNT
value|"minfo-cnt"
end_define

begin_comment
comment|/* Kinds that a change can be. */
end_comment

begin_define
define|#
directive|define
name|ACTION_MODIFY
value|"modify"
end_define

begin_define
define|#
directive|define
name|ACTION_ADD
value|"add"
end_define

begin_define
define|#
directive|define
name|ACTION_DELETE
value|"delete"
end_define

begin_define
define|#
directive|define
name|ACTION_REPLACE
value|"replace"
end_define

begin_define
define|#
directive|define
name|ACTION_RESET
value|"reset"
end_define

begin_comment
comment|/* True and False flags. */
end_comment

begin_define
define|#
directive|define
name|FLAG_TRUE
value|"true"
end_define

begin_define
define|#
directive|define
name|FLAG_FALSE
value|"false"
end_define

begin_comment
comment|/* Kinds that a node-rev can be. */
end_comment

begin_define
define|#
directive|define
name|KIND_FILE
value|"file"
end_define

begin_define
define|#
directive|define
name|KIND_DIR
value|"dir"
end_define

begin_comment
comment|/* Kinds of representation. */
end_comment

begin_define
define|#
directive|define
name|REP_PLAIN
value|"PLAIN"
end_define

begin_define
define|#
directive|define
name|REP_DELTA
value|"DELTA"
end_define

begin_comment
comment|/* Notes:  To avoid opening and closing the rev-files all the time, it would probably be advantageous to keep each rev-file open for the lifetime of the transaction object.  I'll leave that as a later optimization for now.  I didn't keep track of pool lifetimes at all in this code.  There are likely some errors because of that.  */
end_comment

begin_comment
comment|/* The vtable associated with an open transaction object. */
end_comment

begin_decl_stmt
specifier|static
name|txn_vtable_t
name|txn_vtable
init|=
block|{
name|svn_fs_fs__commit_txn
block|,
name|svn_fs_fs__abort_txn
block|,
name|svn_fs_fs__txn_prop
block|,
name|svn_fs_fs__txn_proplist
block|,
name|svn_fs_fs__change_txn_prop
block|,
name|svn_fs_fs__txn_root
block|,
name|svn_fs_fs__change_txn_props
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Declarations. */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|read_min_unpacked_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|min_unpacked_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|update_min_unpacked_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|get_youngest
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_p
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|verify_walker
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Pathname helper functions */
end_comment

begin_comment
comment|/* Return TRUE is REV is packed in FS, FALSE otherwise. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_packed_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
operator|(
name|rev
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE is REV is packed in FS, FALSE otherwise. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_packed_revprop
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* rev 0 will not be packed */
return|return
operator|(
name|rev
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|)
operator|&&
operator|(
name|rev
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_format
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_FORMAT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_UUID
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_fs__path_current
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CURRENT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_current
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXN_CURRENT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_current_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXN_CURRENT_LOCK
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_LOCK_FILE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_revprop_generation
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROP_GENERATION
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_rev_packed
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|assert
argument_list|(
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|is_packed_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
name|PATH_EXT_PACKED_SHARD
argument_list|,
name|rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
argument_list|,
name|kind
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_rev_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|assert
argument_list|(
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
expr_stmt|;
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|assert
argument_list|(
operator|!
name|is_packed_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
condition|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|path_rev_shard
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__path_rev_absolute
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_FORMAT
operator|||
operator|!
name|is_packed_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
operator|*
name|path
operator|=
name|path_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|path
operator|=
name|path_rev_packed
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|PATH_PACKED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_revprops_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|assert
argument_list|(
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
expr_stmt|;
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_revprops_pack_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|assert
argument_list|(
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
expr_stmt|;
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
name|PATH_EXT_PACKED_SHARD
argument_list|,
name|rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
condition|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|path_revprops_shard
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_dir
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|txn_id
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXNS_DIR
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|txn_id
argument_list|,
name|PATH_EXT_TXN
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the name of the sha1->rep mapping file in transaction TXN_ID  * within FS for the given SHA1 checksum.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_sha1
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_checksum_t
modifier|*
name|sha1
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|sha1
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_changes
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_CHANGES
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_props
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_TXN_PROPS
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_next_ids
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_NEXT_IDS
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_min_unpacked_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_MIN_UNPACKED_REV
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_proto_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXN_PROTOS_DIR
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|txn_id
argument_list|,
name|PATH_EXT_REV
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|svn_dirent_join
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_REV
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_proto_rev_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXN_PROTOS_DIR
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|txn_id
argument_list|,
name|PATH_EXT_REV_LOCK
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
else|else
return|return
name|svn_dirent_join
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_REV_LOCK
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|path_txn_node_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id
init|=
name|svn_fs_fs__id_node_id
argument_list|(
name|id
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_id
init|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|id
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|PATH_PREFIX_NODE
literal|"%s.%s"
argument_list|,
name|node_id
argument_list|,
name|copy_id
argument_list|)
decl_stmt|;
return|return
name|svn_dirent_join
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_node_props
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_EXT_PROPS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_node_children
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_EXT_CHILDREN
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_node_origin
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|node_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|node_id
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id_minus_last_char
init|=
operator|(
name|len
operator|==
literal|1
operator|)
condition|?
literal|"0"
else|:
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|node_id
argument_list|,
name|len
operator|-
literal|1
argument_list|)
decl_stmt|;
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_NODE_ORIGINS_DIR
argument_list|,
name|node_id_minus_last_char
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_and_offset_of
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|apr_file_name_get
argument_list|(
operator|&
name|path
argument_list|,
name|file
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
name|path
operator|=
literal|"(unknown)"
expr_stmt|;
if|if
condition|(
name|apr_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%"
name|APR_OFF_T_FMT
argument_list|,
name|path
argument_list|,
name|offset
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Functions for working with shared transaction data. */
end_comment

begin_comment
comment|/* Return the transaction object for transaction TXN_ID from the    transaction list of filesystem FS (which must already be locked via the    txn_list_lock mutex).  If the transaction does not exist in the list,    then create a new transaction object and return it (if CREATE_NEW is    true) or return NULL (otherwise). */
end_comment

begin_function
specifier|static
name|fs_fs_shared_txn_data_t
modifier|*
name|get_shared_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_boolean_t
name|create_new
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
decl_stmt|;
for|for
control|(
name|txn
operator|=
name|ffsd
operator|->
name|txns
init|;
name|txn
condition|;
name|txn
operator|=
name|txn
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|txn
operator|->
name|txn_id
argument_list|,
name|txn_id
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|txn
operator|||
operator|!
name|create_new
condition|)
return|return
name|txn
return|;
comment|/* Use the transaction object from the (single-object) freelist,      if one is available, or otherwise create a new object. */
if|if
condition|(
name|ffsd
operator|->
name|free_txn
condition|)
block|{
name|txn
operator|=
name|ffsd
operator|->
name|free_txn
expr_stmt|;
name|ffsd
operator|->
name|free_txn
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|ffsd
operator|->
name|common_pool
argument_list|)
decl_stmt|;
name|txn
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
block|}
name|assert
argument_list|(
name|strlen
argument_list|(
name|txn_id
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|txn
operator|->
name|txn_id
argument_list|)
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|txn
operator|->
name|txn_id
argument_list|,
name|txn_id
argument_list|,
sizeof|sizeof
argument_list|(
name|txn
operator|->
name|txn_id
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|being_written
operator|=
name|FALSE
expr_stmt|;
comment|/* Link this transaction into the head of the list.  We will typically      be dealing with only one active transaction at a time, so it makes      sense for searches through the transaction list to look at the      newest transactions first.  */
name|txn
operator|->
name|next
operator|=
name|ffsd
operator|->
name|txns
expr_stmt|;
name|ffsd
operator|->
name|txns
operator|=
name|txn
expr_stmt|;
return|return
name|txn
return|;
block|}
end_function

begin_comment
comment|/* Free the transaction object for transaction TXN_ID, and remove it    from the transaction list of filesystem FS (which must already be    locked via the txn_list_lock mutex).  Do nothing if the transaction    does not exist. */
end_comment

begin_function
specifier|static
name|void
name|free_shared_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|txn
operator|=
name|ffsd
operator|->
name|txns
init|;
name|txn
condition|;
name|prev
operator|=
name|txn
operator|,
name|txn
operator|=
name|txn
operator|->
name|next
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|txn
operator|->
name|txn_id
argument_list|,
name|txn_id
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|txn
condition|)
return|return;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|txn
operator|->
name|next
expr_stmt|;
else|else
name|ffsd
operator|->
name|txns
operator|=
name|txn
operator|->
name|next
expr_stmt|;
comment|/* As we typically will be dealing with one transaction after another,      we will maintain a single-object free list so that we can hopefully      keep reusing the same transaction object. */
if|if
condition|(
operator|!
name|ffsd
operator|->
name|free_txn
condition|)
name|ffsd
operator|->
name|free_txn
operator|=
name|txn
expr_stmt|;
else|else
name|svn_pool_destroy
argument_list|(
name|txn
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Obtain a lock on the transaction list of filesystem FS, call BODY    with FS, BATON, and POOL, and then unlock the transaction list.    Return what BODY returned. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|with_txnlist_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|ffsd
operator|->
name|txn_list_lock
argument_list|,
name|body
argument_list|(
name|fs
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get a lock on empty file LOCK_FILENAME, creating it in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock_on_filesystem
parameter_list|(
specifier|const
name|char
modifier|*
name|lock_filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_file_lock2
argument_list|(
name|lock_filename
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* No lock file?  No big deal; these are just empty files          anyway.  Create it and try again. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|lock_filename
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_lock2
argument_list|(
name|lock_filename
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reset the HAS_WRITE_LOCK member in the FFD given as BATON_VOID.    When registered with the pool holding the lock on the lock file,    this makes sure the flag gets reset just before we release the lock. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|reset_lock_flag
parameter_list|(
name|void
modifier|*
name|baton_void
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|baton_void
decl_stmt|;
name|ffd
operator|->
name|has_write_lock
operator|=
name|FALSE
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Obtain a write lock on the file LOCK_FILENAME (protecting with    LOCK_MUTEX if APR is threaded) in a subpool of POOL, call BODY with    BATON and that subpool, destroy the subpool (releasing the write    lock) and return what BODY returned.  If IS_GLOBAL_LOCK is set,    set the HAS_WRITE_LOCK flag while we keep the write lock. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|with_some_lock_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_filename
parameter_list|,
name|svn_boolean_t
name|is_global_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|get_lock_on_filesystem
argument_list|(
name|lock_filename
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|is_global_lock
condition|)
block|{
comment|/* set the "got the lock" flag and register reset function */
name|apr_pool_cleanup_register
argument_list|(
name|subpool
argument_list|,
name|ffd
argument_list|,
name|reset_lock_flag
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|has_write_lock
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* nobody else will modify the repo state          => read HEAD& pack info once */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
operator|&
name|ffd
operator|->
name|youngest_rev_cache
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|body
argument_list|(
name|baton
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__with_write_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|ffsd
operator|->
name|fs_write_lock
argument_list|,
name|with_some_lock_file
argument_list|(
name|fs
argument_list|,
name|body
argument_list|,
name|baton
argument_list|,
name|path_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Run BODY (with BATON and POOL) while the txn-current file    of FS is locked. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|with_txn_current_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|ffsd
operator|->
name|txn_current_lock
argument_list|,
name|with_some_lock_file
argument_list|(
name|fs
argument_list|,
name|body
argument_list|,
name|baton
argument_list|,
name|path_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A structure used by unlock_proto_rev() and unlock_proto_rev_body(),    which see. */
end_comment

begin_struct
struct|struct
name|unlock_proto_rev_baton
block|{
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
name|void
modifier|*
name|lockcookie
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback used in the implementation of unlock_proto_rev(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_proto_rev_body
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|struct
name|unlock_proto_rev_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|b
operator|->
name|txn_id
decl_stmt|;
name|apr_file_t
modifier|*
name|lockfile
init|=
name|b
operator|->
name|lockcookie
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
init|=
name|get_shared_txn
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
if|if
condition|(
operator|!
name|txn
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't unlock unknown transaction '%s'"
argument_list|)
argument_list|,
name|txn_id
argument_list|)
return|;
if|if
condition|(
operator|!
name|txn
operator|->
name|being_written
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't unlock nonlocked transaction '%s'"
argument_list|)
argument_list|,
name|txn_id
argument_list|)
return|;
name|apr_err
operator|=
name|apr_file_unlock
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't unlock prototype revision lockfile for transaction '%s'"
argument_list|)
argument_list|,
name|txn_id
argument_list|)
return|;
name|apr_err
operator|=
name|apr_file_close
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't close prototype revision lockfile for transaction '%s'"
argument_list|)
argument_list|,
name|txn_id
argument_list|)
return|;
name|txn
operator|->
name|being_written
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Unlock the prototype revision file for transaction TXN_ID in filesystem    FS using cookie LOCKCOOKIE.  The original prototype revision file must    have been closed _before_ calling this function.     Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_proto_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|void
modifier|*
name|lockcookie
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_proto_rev_baton
name|b
decl_stmt|;
name|b
operator|.
name|txn_id
operator|=
name|txn_id
expr_stmt|;
name|b
operator|.
name|lockcookie
operator|=
name|lockcookie
expr_stmt|;
return|return
name|with_txnlist_lock
argument_list|(
name|fs
argument_list|,
name|unlock_proto_rev_body
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Same as unlock_proto_rev(), but requires that the transaction list    lock is already held. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_proto_rev_list_locked
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|void
modifier|*
name|lockcookie
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_proto_rev_baton
name|b
decl_stmt|;
name|b
operator|.
name|txn_id
operator|=
name|txn_id
expr_stmt|;
name|b
operator|.
name|lockcookie
operator|=
name|lockcookie
expr_stmt|;
return|return
name|unlock_proto_rev_body
argument_list|(
name|fs
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A structure used by get_writable_proto_rev() and    get_writable_proto_rev_body(), which see. */
end_comment

begin_struct
struct|struct
name|get_writable_proto_rev_baton
block|{
name|apr_file_t
modifier|*
modifier|*
name|file
decl_stmt|;
name|void
modifier|*
modifier|*
name|lockcookie
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback used in the implementation of get_writable_proto_rev(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_writable_proto_rev_body
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|struct
name|get_writable_proto_rev_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_file_t
modifier|*
modifier|*
name|file
init|=
name|b
operator|->
name|file
decl_stmt|;
name|void
modifier|*
modifier|*
name|lockcookie
init|=
name|b
operator|->
name|lockcookie
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|b
operator|->
name|txn_id
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
init|=
name|get_shared_txn
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
comment|/* First, ensure that no thread in this process (including this one)      is currently writing to this transaction's proto-rev file. */
if|if
condition|(
name|txn
operator|->
name|being_written
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REP_BEING_WRITTEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot write to the prototype revision file "
literal|"of transaction '%s' because a previous "
literal|"representation is currently being written by "
literal|"this process"
argument_list|)
argument_list|,
name|txn_id
argument_list|)
return|;
comment|/* We know that no thread in this process is writing to the proto-rev      file, and by extension, that no thread in this process is holding a      lock on the prototype revision lock file.  It is therefore safe      for us to attempt to lock this file, to see if any other process      is holding a lock. */
block|{
name|apr_file_t
modifier|*
name|lockfile
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|lockfile_path
init|=
name|path_txn_proto_rev_lock
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Open the proto-rev lockfile, creating it if necessary, as it may        not exist if the transaction dates from before the lockfiles were        introduced.         ### We'd also like to use something like svn_io_file_lock2(), but            that forces us to create a subpool just to be able to unlock            the file, which seems a waste. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|lockfile
argument_list|,
name|lockfile_path
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_file_lock
argument_list|(
name|lockfile
argument_list|,
name|APR_FLOCK_EXCLUSIVE
operator||
name|APR_FLOCK_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_io_file_close
argument_list|(
name|lockfile
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REP_BEING_WRITTEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot write to the prototype revision "
literal|"file of transaction '%s' because a "
literal|"previous representation is currently "
literal|"being written by another process"
argument_list|)
argument_list|,
name|txn_id
argument_list|)
return|;
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get exclusive lock on file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|lockfile_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|lockcookie
operator|=
name|lockfile
expr_stmt|;
block|}
comment|/* We've successfully locked the transaction; mark it as such. */
name|txn
operator|->
name|being_written
operator|=
name|TRUE
expr_stmt|;
comment|/* Now open the prototype revision file and seek to the end. */
name|err
operator|=
name|svn_io_file_open
argument_list|(
name|file
argument_list|,
name|path_txn_proto_rev
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* You might expect that we could dispense with the following seek      and achieve the same thing by opening the file using APR_APPEND.      Unfortunately, APR's buffered file implementation unconditionally      places its initial file pointer at the start of the file (even for      files opened with APR_APPEND), so we need this seek to reconcile      the APR file pointer to the OS file pointer (since we need to be      able to read the current file position later). */
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|svn_io_file_seek
argument_list|(
operator|*
name|file
argument_list|,
name|APR_END
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|unlock_proto_rev_list_locked
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
operator|*
name|lockcookie
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lockcookie
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get a handle to the prototype revision file for transaction TXN_ID in    filesystem FS, and lock it for writing.  Return FILE, a file handle    positioned at the end of the file, and LOCKCOOKIE, a cookie that    should be passed to unlock_proto_rev() to unlock the file once FILE    has been closed.     If the prototype revision file is already locked, return error    SVN_ERR_FS_REP_BEING_WRITTEN.     Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_writable_proto_rev
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|void
modifier|*
modifier|*
name|lockcookie
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_writable_proto_rev_baton
name|b
decl_stmt|;
name|b
operator|.
name|file
operator|=
name|file
expr_stmt|;
name|b
operator|.
name|lockcookie
operator|=
name|lockcookie
expr_stmt|;
name|b
operator|.
name|txn_id
operator|=
name|txn_id
expr_stmt|;
return|return
name|with_txnlist_lock
argument_list|(
name|fs
argument_list|,
name|get_writable_proto_rev_body
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback used in the implementation of purge_shared_txn(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|purge_shared_txn_body
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|baton
decl_stmt|;
name|free_shared_txn
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__reset_txn_caches
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Purge the shared data for transaction TXN_ID in filesystem FS.    Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|purge_shared_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|with_txnlist_lock
argument_list|(
name|fs
argument_list|,
name|purge_shared_txn_body
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Fetch the current offset of FILE into *OFFSET_P. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_offset
parameter_list|(
name|apr_off_t
modifier|*
name|offset_p
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
comment|/* Note that, for buffered files, one (possibly surprising) side-effect      of this call is to flush any unwritten data to disk. */
name|offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|offset_p
operator|=
name|offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check that BUF, a nul-terminated buffer of text from file PATH,    contains only digits at OFFSET and beyond, raising an error if not.    TITLE contains a user-visible description of the file, usually the    short file name.     Uses POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_file_buffer_numeric
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|title
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|buf
operator|+
name|offset
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|!
name|svn_ctype_isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s file '%s' contains unexpected non-digit '%c' within '%s'"
argument_list|)
argument_list|,
name|title
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|*
name|p
argument_list|,
name|buf
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check that BUF, a nul-terminated buffer of text from format file PATH,    contains only digits at OFFSET and beyond, raising an error if not.     Uses POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_format_file_buffer_numeric
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|check_file_buffer_numeric
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|path
argument_list|,
literal|"Format"
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the error SVN_ERR_FS_UNSUPPORTED_FORMAT if FS's format    number is not the same as a format number supported by this    Subversion. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_format
parameter_list|(
name|int
name|format
parameter_list|)
block|{
comment|/* Blacklist.  These formats may be either younger or older than      SVN_FS_FS__FORMAT_NUMBER, but we don't support them. */
if|if
condition|(
name|format
operator|==
name|SVN_FS_FS__PACKED_REVPROP_SQLITE_DEV_FORMAT
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Found format '%d', only created by "
literal|"unreleased dev builds; see "
literal|"http://subversion.apache.org"
literal|"/docs/release-notes/1.7#revprop-packing"
argument_list|)
argument_list|,
name|format
argument_list|)
return|;
comment|/* We support all formats from 1-current simultaneously */
if|if
condition|(
literal|1
operator|<=
name|format
operator|&&
name|format
operator|<=
name|SVN_FS_FS__FORMAT_NUMBER
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected FS format between '1' and '%d'; found format '%d'"
argument_list|)
argument_list|,
name|SVN_FS_FS__FORMAT_NUMBER
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the format number and maximum number of files per directory    from PATH and return them in *PFORMAT and *MAX_FILES_PER_DIR    respectively.     *MAX_FILES_PER_DIR is obtained from the 'layout' format option, and    will be set to zero if a linear scheme should be used.     Use POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_format
parameter_list|(
name|int
modifier|*
name|pformat
parameter_list|,
name|int
modifier|*
name|max_files_per_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_boolean_t
name|eos
init|=
name|FALSE
decl_stmt|;
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|content
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* Treat an absent format file as format 1.  Do not try to          create the format file on the fly, because the repository          might be read-only for us, or this might be a read-only          operation, and the spirit of FSFS is to make no changes          whatseover in read-only operations.  See thread starting at          http://subversion.tigris.org/servlets/ReadMsg?list=dev&msgNo=97600          for more. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|pformat
operator|=
literal|1
expr_stmt|;
operator|*
name|max_files_per_dir
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|content
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|==
literal|0
operator|&&
name|eos
condition|)
block|{
comment|/* Return a more useful error message. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't read first line of format file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Check that the first line contains only digits. */
name|SVN_ERR
argument_list|(
name|check_format_file_buffer_numeric
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
name|pformat
argument_list|,
name|buf
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that we support this format at all */
name|SVN_ERR
argument_list|(
name|check_format
argument_list|(
operator|*
name|pformat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the default values for anything that can be set via an option. */
operator|*
name|max_files_per_dir
operator|=
literal|0
expr_stmt|;
comment|/* Read any options. */
while|while
condition|(
operator|!
name|eos
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|*
name|pformat
operator|>=
name|SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT
operator|&&
name|strncmp
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|"layout "
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|buf
operator|->
name|data
operator|+
literal|7
argument_list|,
literal|"linear"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|max_files_per_dir
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|buf
operator|->
name|data
operator|+
literal|7
argument_list|,
literal|"sharded "
argument_list|,
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Check that the argument is numeric. */
name|SVN_ERR
argument_list|(
name|check_format_file_buffer_numeric
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|15
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
name|max_files_per_dir
argument_list|,
name|buf
operator|->
name|data
operator|+
literal|15
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' contains invalid filesystem format option '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|buf
operator|->
name|data
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the format number and maximum number of files per directory    to a new format file in PATH, possibly expecting to overwrite a    previously existing file.     Use POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_format
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|svn_boolean_t
name|overwrite
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
literal|1
operator|<=
name|format
operator|&&
name|format
operator|<=
name|SVN_FS_FS__FORMAT_NUMBER
argument_list|)
expr_stmt|;
name|sb
operator|=
name|svn_stringbuf_createf
argument_list|(
name|pool
argument_list|,
literal|"%d\n"
argument_list|,
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT
condition|)
block|{
if|if
condition|(
name|max_files_per_dir
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"layout sharded %d\n"
argument_list|,
name|max_files_per_dir
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
literal|"layout linear\n"
argument_list|)
expr_stmt|;
block|}
comment|/* svn_io_write_version_file() does a load of magic to allow it to      replace version files that already exist.  We only need to do      that when we're allowed to overwrite an existing file. */
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
comment|/* Create the file */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|path_tmp
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|path_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|sb
operator|->
name|len
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rename the temp file as the real destination */
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|path_tmp
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* And set the perms to make it read only */
return|return
name|svn_io_set_file_read_only
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fs_fs__fs_supports_mergeinfo
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_MERGEINFO_FORMAT
return|;
block|}
end_function

begin_comment
comment|/* Read the configuration information of the file system at FS_PATH  * and set the respective values in FFD.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_config
parameter_list|(
name|fs_fs_data_t
modifier|*
name|ffd
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|ffd
operator|->
name|config
argument_list|,
name|svn_dirent_join
argument_list|(
name|fs_path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize ffd->rep_sharing_allowed. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|rep_sharing_allowed
argument_list|,
name|CONFIG_SECTION_REP_SHARING
argument_list|,
name|CONFIG_OPTION_ENABLE_REP_SHARING
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|ffd
operator|->
name|rep_sharing_allowed
operator|=
name|FALSE
expr_stmt|;
comment|/* Initialize deltification settings in ffd. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_DELTIFICATION_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|deltify_directories
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_ENABLE_DIR_DELTIFICATION
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|deltify_properties
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_ENABLE_PROPS_DELTIFICATION
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|max_deltification_walk
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_MAX_DELTIFICATION_WALK
argument_list|,
name|SVN_FS_FS_MAX_DELTIFICATION_WALK
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|max_linear_deltification
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_MAX_LINEAR_DELTIFICATION
argument_list|,
name|SVN_FS_FS_MAX_LINEAR_DELTIFICATION
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|deltify_directories
operator|=
name|FALSE
expr_stmt|;
name|ffd
operator|->
name|deltify_properties
operator|=
name|FALSE
expr_stmt|;
name|ffd
operator|->
name|max_deltification_walk
operator|=
name|SVN_FS_FS_MAX_DELTIFICATION_WALK
expr_stmt|;
name|ffd
operator|->
name|max_linear_deltification
operator|=
name|SVN_FS_FS_MAX_LINEAR_DELTIFICATION
expr_stmt|;
block|}
comment|/* Initialize revprop packing settings in ffd. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|compress_packed_revprops
argument_list|,
name|CONFIG_SECTION_PACKED_REVPROPS
argument_list|,
name|CONFIG_OPTION_COMPRESS_PACKED_REVPROPS
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|revprop_pack_size
argument_list|,
name|CONFIG_SECTION_PACKED_REVPROPS
argument_list|,
name|CONFIG_OPTION_REVPROP_PACK_SIZE
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
literal|0x100
else|:
literal|0x40
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|revprop_pack_size
operator|*=
literal|1024
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|revprop_pack_size
operator|=
literal|0x10000
expr_stmt|;
name|ffd
operator|->
name|compress_packed_revprops
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_config
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
define|#
directive|define
name|NL
value|APR_EOL_STR
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|fsfs_conf_contents
init|=
literal|"### This file controls the configuration of the FSFS filesystem."
name|NL
literal|""
name|NL
literal|"["
name|SVN_CACHE_CONFIG_CATEGORY_MEMCACHED_SERVERS
literal|"]"
name|NL
literal|"### These options name memcached servers used to cache internal FSFS"
name|NL
literal|"### data.  See http://www.danga.com/memcached/ for more information on"
name|NL
literal|"### memcached.  To use memcached with FSFS, run one or more memcached"
name|NL
literal|"### servers, and specify each of them as an option like so:"
name|NL
literal|"# first-server = 127.0.0.1:11211"
name|NL
literal|"# remote-memcached = mymemcached.corp.example.com:11212"
name|NL
literal|"### The option name is ignored; the value is of the form HOST:PORT."
name|NL
literal|"### memcached servers can be shared between multiple repositories;"
name|NL
literal|"### however, if you do this, you *must* ensure that repositories have"
name|NL
literal|"### distinct UUIDs and paths, or else cached data from one repository"
name|NL
literal|"### might be used by another accidentally.  Note also that memcached has"
name|NL
literal|"### no authentication for reads or writes, so you must ensure that your"
name|NL
literal|"### memcached servers are only accessible by trusted users."
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_CACHES
literal|"]"
name|NL
literal|"### When a cache-related error occurs, normally Subversion ignores it"
name|NL
literal|"### and continues, logging an error if the server is appropriately"
name|NL
literal|"### configured (and ignoring it with file:// access).  To make"
name|NL
literal|"### Subversion never ignore cache errors, uncomment this line."
name|NL
literal|"# "
name|CONFIG_OPTION_FAIL_STOP
literal|" = true"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_REP_SHARING
literal|"]"
name|NL
literal|"### To conserve space, the filesystem can optionally avoid storing"
name|NL
literal|"### duplicate representations.  This comes at a slight cost in"
name|NL
literal|"### performance, as maintaining a database of shared representations can"
name|NL
literal|"### increase commit times.  The space savings are dependent upon the size"
name|NL
literal|"### of the repository, the number of objects it contains and the amount of"
name|NL
literal|"### duplication between them, usually a function of the branching and"
name|NL
literal|"### merging process."
name|NL
literal|"###"
name|NL
literal|"### The following parameter enables rep-sharing in the repository.  It can"
name|NL
literal|"### be switched on and off at will, but for best space-saving results"
name|NL
literal|"### should be enabled consistently over the life of the repository."
name|NL
literal|"### 'svnadmin verify' will check the rep-cache regardless of this setting."
name|NL
literal|"### rep-sharing is enabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_ENABLE_REP_SHARING
literal|" = true"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_DELTIFICATION
literal|"]"
name|NL
literal|"### To conserve space, the filesystem stores data as differences against"
name|NL
literal|"### existing representations.  This comes at a slight cost in performance,"
name|NL
literal|"### as calculating differences can increase commit times.  Reading data"
name|NL
literal|"### will also create higher CPU load and the data will be fragmented."
name|NL
literal|"### Since deltification tends to save significant amounts of disk space,"
name|NL
literal|"### the overall I/O load can actually be lower."
name|NL
literal|"###"
name|NL
literal|"### The options in this section allow for tuning the deltification"
name|NL
literal|"### strategy.  Their effects on data size and server performance may vary"
name|NL
literal|"### from one repository to another.  Versions prior to 1.8 will ignore"
name|NL
literal|"### this section."
name|NL
literal|"###"
name|NL
literal|"### The following parameter enables deltification for directories. It can"
name|NL
literal|"### be switched on and off at will, but for best space-saving results"
name|NL
literal|"### should be enabled consistently over the life of the repository."
name|NL
literal|"### Repositories containing large directories will benefit greatly."
name|NL
literal|"### In rarely read repositories, the I/O overhead may be significant as"
name|NL
literal|"### cache hit rates will most likely be low"
name|NL
literal|"### directory deltification is disabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_ENABLE_DIR_DELTIFICATION
literal|" = false"
name|NL
literal|"###"
name|NL
literal|"### The following parameter enables deltification for properties on files"
name|NL
literal|"### and directories.  Overall, this is a minor tuning option but can save"
name|NL
literal|"### some disk space if you merge frequently or frequently change node"
name|NL
literal|"### properties.  You should not activate this if rep-sharing has been"
name|NL
literal|"### disabled because this may result in a net increase in repository size."
name|NL
literal|"### property deltification is disabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_ENABLE_PROPS_DELTIFICATION
literal|" = false"
name|NL
literal|"###"
name|NL
literal|"### During commit, the server may need to walk the whole change history of"
name|NL
literal|"### of a given node to find a suitable deltification base.  This linear"
name|NL
literal|"### process can impact commit times, svnadmin load and similar operations."
name|NL
literal|"### This setting limits the depth of the deltification history.  If the"
name|NL
literal|"### threshold has been reached, the node will be stored as fulltext and a"
name|NL
literal|"### new deltification history begins."
name|NL
literal|"### Note, this is unrelated to svn log."
name|NL
literal|"### Very large values rarely provide significant additional savings but"
name|NL
literal|"### can impact performance greatly - in particular if directory"
name|NL
literal|"### deltification has been activated.  Very small values may be useful in"
name|NL
literal|"### repositories that are dominated by large, changing binaries."
name|NL
literal|"### Should be a power of two minus 1.  A value of 0 will effectively"
name|NL
literal|"### disable deltification."
name|NL
literal|"### For 1.8, the default value is 1023; earlier versions have no limit."
name|NL
literal|"# "
name|CONFIG_OPTION_MAX_DELTIFICATION_WALK
literal|" = 1023"
name|NL
literal|"###"
name|NL
literal|"### The skip-delta scheme used by FSFS tends to repeatably store redundant"
name|NL
literal|"### delta information where a simple delta against the latest version is"
name|NL
literal|"### often smaller.  By default, 1.8+ will therefore use skip deltas only"
name|NL
literal|"### after the linear chain of deltas has grown beyond the threshold"
name|NL
literal|"### specified by this setting."
name|NL
literal|"### Values up to 64 can result in some reduction in repository size for"
name|NL
literal|"### the cost of quickly increasing I/O and CPU costs. Similarly, smaller"
name|NL
literal|"### numbers can reduce those costs at the cost of more disk space.  For"
name|NL
literal|"### rarely read repositories or those containing larger binaries, this may"
name|NL
literal|"### present a better trade-off."
name|NL
literal|"### Should be a power of two.  A value of 1 or smaller will cause the"
name|NL
literal|"### exclusive use of skip-deltas (as in pre-1.8)."
name|NL
literal|"### For 1.8, the default value is 16; earlier versions use 1."
name|NL
literal|"# "
name|CONFIG_OPTION_MAX_LINEAR_DELTIFICATION
literal|" = 16"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_PACKED_REVPROPS
literal|"]"
name|NL
literal|"### This parameter controls the size (in kBytes) of packed revprop files."
name|NL
literal|"### Revprops of consecutive revisions will be concatenated into a single"
name|NL
literal|"### file up to but not exceeding the threshold given here.  However, each"
name|NL
literal|"### pack file may be much smaller and revprops of a single revision may be"
name|NL
literal|"### much larger than the limit set here.  The threshold will be applied"
name|NL
literal|"### before optional compression takes place."
name|NL
literal|"### Large values will reduce disk space usage at the expense of increased"
name|NL
literal|"### latency and CPU usage reading and changing individual revprops.  They"
name|NL
literal|"### become an advantage when revprop caching has been enabled because a"
name|NL
literal|"### lot of data can be read in one go.  Values smaller than 4 kByte will"
name|NL
literal|"### not improve latency any further and quickly render revprop packing"
name|NL
literal|"### ineffective."
name|NL
literal|"### revprop-pack-size is 64 kBytes by default for non-compressed revprop"
name|NL
literal|"### pack files and 256 kBytes when compression has been enabled."
name|NL
literal|"# "
name|CONFIG_OPTION_REVPROP_PACK_SIZE
literal|" = 64"
name|NL
literal|"###"
name|NL
literal|"### To save disk space, packed revprop files may be compressed.  Standard"
name|NL
literal|"### revprops tend to allow for very effective compression.  Reading and"
name|NL
literal|"### even more so writing, become significantly more CPU intensive.  With"
name|NL
literal|"### revprop caching enabled, the overhead can be offset by reduced I/O"
name|NL
literal|"### unless you often modify revprops after packing."
name|NL
literal|"### Compressing packed revprops is disabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_COMPRESS_PACKED_REVPROPS
literal|" = false"
name|NL
decl_stmt|;
undef|#
directive|undef
name|NL
return|return
name|svn_io_file_create
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fsfs_conf_contents
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_min_unpacked_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|min_unpacked_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|min_unpacked_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_min_unpacked_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
argument_list|)
expr_stmt|;
return|return
name|read_min_unpacked_rev
argument_list|(
operator|&
name|ffd
operator|->
name|min_unpacked_rev
argument_list|,
name|path_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__open
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_file_t
modifier|*
name|uuid_file
decl_stmt|;
name|int
name|format
decl_stmt|,
name|max_files_per_dir
decl_stmt|;
name|char
name|buf
index|[
name|APR_UUID_FORMATTED_LENGTH
operator|+
literal|2
index|]
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Read the FS format number. */
name|SVN_ERR
argument_list|(
name|read_format
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|max_files_per_dir
argument_list|,
name|path_format
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now we've got a format number no matter what. */
name|ffd
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|ffd
operator|->
name|max_files_per_dir
operator|=
name|max_files_per_dir
expr_stmt|;
comment|/* Read in and cache the repository uuid. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|uuid_file
argument_list|,
name|path_uuid
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|uuid_file
argument_list|,
name|buf
argument_list|,
operator|&
name|limit
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|uuid_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the min unpacked revision. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the configuration file. */
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
name|ffd
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|get_youngest
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|youngest_rev_cache
operator|)
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around svn_io_file_create which ignores EEXIST. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_file_ignore_eexist
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|contents
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_file_create
argument_list|(
name|file
argument_list|,
name|contents
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* forward declarations */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|pack_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_off_t
name|max_pack_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|delete_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* In the filesystem FS, pack all revprop shards up to min_unpacked_rev.  *   * NOTE: Keep the old non-packed shards around until after the format bump.  * Otherwise, re-running upgrade will drop the packed revprop shard but  * have no unpacked data anymore.  Call upgrade_cleanup_pack_revprops after  * the bump.  *   * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_pack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_pack_file_dir
decl_stmt|;
name|apr_int64_t
name|shard
decl_stmt|;
name|apr_int64_t
name|first_unpacked_shard
init|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revsprops_dir
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|compression_level
init|=
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
else|:
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
decl_stmt|;
comment|/* first, pack all revprops shards to match the packed revision shards */
for|for
control|(
name|shard
operator|=
literal|0
init|;
name|shard
operator|<
name|first_unpacked_shard
condition|;
operator|++
name|shard
control|)
block|{
name|revprops_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|iterpool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|pack_revprops_shard
argument_list|(
name|revprops_pack_file_dir
argument_list|,
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|0.9
operator|*
name|ffd
operator|->
name|revprop_pack_size
argument_list|)
argument_list|,
name|compression_level
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In the filesystem FS, remove all non-packed revprop shards up to  * min_unpacked_rev.  Use SCRATCH_POOL for temporary allocations.  * See upgrade_pack_revprops for more info.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_cleanup_pack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|;
name|apr_int64_t
name|shard
decl_stmt|;
name|apr_int64_t
name|first_unpacked_shard
init|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revsprops_dir
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* delete the non-packed revprops shards afterwards */
for|for
control|(
name|shard
operator|=
literal|0
init|;
name|shard
operator|<
name|first_unpacked_shard
condition|;
operator|++
name|shard
control|)
block|{
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delete_revprops_shard
argument_list|(
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|baton
decl_stmt|;
name|int
name|format
decl_stmt|,
name|max_files_per_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_path
init|=
name|path_format
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|needs_revprop_shard_cleanup
init|=
name|FALSE
decl_stmt|;
comment|/* Read the FS format number and max-files-per-dir setting. */
name|SVN_ERR
argument_list|(
name|read_format
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|max_files_per_dir
argument_list|,
name|format_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the config file does not exist, create one. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_node_none
case|:
name|SVN_ERR
argument_list|(
name|write_config
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_file
case|:
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a regular file."
literal|" Please move it out of "
literal|"the way and try again"
argument_list|)
argument_list|,
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* If we're already up-to-date, there's nothing else to be done here. */
if|if
condition|(
name|format
operator|==
name|SVN_FS_FS__FORMAT_NUMBER
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If our filesystem predates the existance of the 'txn-current      file', make that file and its corresponding lock file. */
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_file_ignore_eexist
argument_list|(
name|path_txn_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_file_ignore_eexist
argument_list|(
name|path_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If our filesystem predates the existance of the 'txn-protorevs'      dir, make that directory.  */
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
block|{
comment|/* We don't use path_txn_proto_rev() here because it expects          we've already bumped our format. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXN_PROTOS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If our filesystem is new enough, write the min unpacked rev file. */
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the file system supports revision packing but not revprop packing      *and* the FS has been sharded, pack the revprops up to the point that      revision data has been packed.  However, keep the non-packed revprop      files around until after the format bump */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
operator|&&
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
operator|&&
name|max_files_per_dir
operator|>
literal|0
condition|)
block|{
name|needs_revprop_shard_cleanup
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|upgrade_pack_revprops
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Bump the format file. */
name|SVN_ERR
argument_list|(
name|write_format
argument_list|(
name|format_path
argument_list|,
name|SVN_FS_FS__FORMAT_NUMBER
argument_list|,
name|max_files_per_dir
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, it is safe to remove the redundant revprop files. */
if|if
condition|(
name|needs_revprop_shard_cleanup
condition|)
name|SVN_ERR
argument_list|(
name|upgrade_cleanup_pack_revprops
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__upgrade
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|upgrade_body
argument_list|,
operator|(
name|void
operator|*
operator|)
name|fs
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Functions for dealing with recoverable errors on mutable files  *  * Revprops, current, and txn-current files are mutable; that is, they  * change as part of normal fsfs operation, in constrat to revs files, or  * the format file, which are written once at create (or upgrade) time.  * When more than one host writes to the same repository, we will  * sometimes see these recoverable errors when accesssing these files.  *  * These errors all relate to NFS, and thus we only use this retry code if  * ESTALE is defined.  *  ** ESTALE  *  * In NFS v3 and under, the server doesn't track opened files.  If you  * unlink(2) or rename(2) a file held open by another process *on the  * same host*, that host's kernel typically renames the file to  * .nfsXXXX and automatically deletes that when it's no longer open,  * but this behavior is not required.  *  * For obvious reasons, this does not work *across hosts*.  No one  * knows about the opened file; not the server, and not the deleting  * client.  So the file vanishes, and the reader gets stale NFS file  * handle.  *  ** EIO, ENOENT  *  * Some client implementations (at least the 2.6.18.5 kernel that ships  * with Ubuntu Dapper) sometimes give spurious ENOENT (only on open) or  * even EIO errors when trying to read these files that have been renamed  * over on some other host.  *  ** Solution  *  * Try open and read of such files in try_stringbuf_from_file().  Call  * this function within a loop of RECOVERABLE_RETRY_COUNT iterations  * (though, realistically, the second try will succeed).  */
end_comment

begin_define
define|#
directive|define
name|RECOVERABLE_RETRY_COUNT
value|10
end_define

begin_comment
comment|/* Read the file at PATH and return its content in *CONTENT. *CONTENT will  * not be modified unless the whole file was read successfully.  *  * ESTALE, EIO and ENOENT will not cause this function to return an error  * unless LAST_ATTEMPT has been set.  If MISSING is not NULL, indicate  * missing files (ENOENT) there.  *  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|try_stringbuf_from_file
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|content
parameter_list|,
name|svn_boolean_t
modifier|*
name|missing
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|last_attempt
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_stringbuf_from_file2
argument_list|(
name|content
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|missing
condition|)
operator|*
name|missing
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
operator|*
name|content
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|last_attempt
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|missing
condition|)
operator|*
name|missing
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
ifdef|#
directive|ifdef
name|ESTALE
elseif|else
if|if
condition|(
name|APR_TO_OS_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|==
name|ESTALE
operator|||
name|APR_TO_OS_ERROR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|==
name|EIO
condition|)
block|{
if|if
condition|(
operator|!
name|last_attempt
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
endif|#
directive|endif
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the 'current' file FNAME and store the contents in *BUF.    Allocations are performed in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_content
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|content
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|content
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|!
operator|*
name|content
operator|&&
operator|(
name|i
operator|<
name|RECOVERABLE_RETRY_COUNT
operator|)
condition|;
operator|++
name|i
control|)
name|SVN_ERR
argument_list|(
name|try_stringbuf_from_file
argument_list|(
name|content
argument_list|,
name|NULL
argument_list|,
name|fname
argument_list|,
name|i
operator|+
literal|1
operator|<
name|RECOVERABLE_RETRY_COUNT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|content
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't read '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fname
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the youngest revision in a repository at path FS_PATH and    return it in *YOUNGEST_P.  Perform temporary allocations in    POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_youngest
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_p
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_content
argument_list|(
operator|&
name|buf
argument_list|,
name|svn_dirent_join
argument_list|(
name|fs_path
argument_list|,
name|PATH_CURRENT
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|youngest_p
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__youngest_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
name|youngest_p
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
operator|*
name|youngest_p
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a revision file FILE that has been pre-positioned at the    beginning of a Node-Rev header block, read in that header block and    store it in the apr_hash_t HEADERS.  All allocations will be from    POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_header_block
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|headers
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|headers
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|header_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|header_str
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
operator|||
name|header_str
operator|->
name|len
operator|==
literal|0
condition|)
break|break;
comment|/* end of header block */
while|while
condition|(
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Found malformed header '%s' in "
literal|"revision file"
argument_list|)
argument_list|,
name|header_str
operator|->
name|data
argument_list|)
return|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Create a 'name' string and point to it. */
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|header_str
operator|->
name|data
expr_stmt|;
comment|/* Skip over the NULL byte and the space following it. */
name|i
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|>
name|header_str
operator|->
name|len
condition|)
block|{
comment|/* Restore the original line for the error. */
name|i
operator|-=
literal|2
expr_stmt|;
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|=
literal|':'
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Found malformed header '%s' in "
literal|"revision file"
argument_list|)
argument_list|,
name|header_str
operator|->
name|data
argument_list|)
return|;
block|}
name|value
operator|=
name|header_str
operator|->
name|data
operator|+
name|i
expr_stmt|;
comment|/* header_str is safely in our pool, so we can use bits of it as          key and value. */
name|svn_hash_sets
argument_list|(
operator|*
name|headers
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return SVN_ERR_FS_NO_SUCH_REVISION if the given revision is newer    than the current youngest revision or is simply not a valid    revision number, else return success.     FSFS is based around the concept that commits only take effect when    the number in "current" is bumped.  Thus if there happens to be a rev    or revprops file installed for a revision higher than the one recorded    in "current" (because a commit failed between installing the rev file    and bumping "current", or because an administrator rolled back the    repository by resetting "current" without deleting rev files, etc), it    ought to be completely ignored.  This function provides the check    by which callers can make that decision. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_revision_exists
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number '%ld'"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* Did the revision exist the last time we checked the current      file? */
if|if
condition|(
name|rev
operator|<=
name|ffd
operator|->
name|youngest_rev_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|youngest_rev_cache
operator|)
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check again. */
if|if
condition|(
name|rev
operator|<=
name|ffd
operator|->
name|youngest_rev_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__revision_exists
parameter_list|(
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Different order of parameters. */
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the correct revision file for REV.  If the filesystem FS has    been packed, *FILE will be set to the packed file; otherwise, set *FILE    to the revision file for REV.  Return SVN_ERR_FS_NO_SUCH_REVISION if the    file doesn't exist.     TODO: Consider returning an indication of whether this is a packed rev          file, so the caller need not rely on is_packed_rev() which in turn          relies on the cached FFD->min_unpacked_rev value not having changed          since the rev file was opened.     Use POOL for allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_pack_or_rev_file
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_boolean_t
name|retry
init|=
name|FALSE
decl_stmt|;
do|do
block|{
name|err
operator|=
name|svn_fs_fs__path_rev_absolute
argument_list|(
operator|&
name|path
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* open the revision file in buffered r/o mode */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_io_file_open
argument_list|(
name|file
argument_list|,
name|path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
block|{
comment|/* Could not open the file. This may happen if the                * file once existed but got packed later. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* if that was our 2nd attempt, leave it at that. */
if|if
condition|(
name|retry
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* We failed for the first time. Refresh cache& retry. */
name|SVN_ERR
argument_list|(
name|update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|retry
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
do|while
condition|(
name|retry
condition|)
do|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Reads a line from STREAM and converts it to a 64 bit integer to be  * returned in *RESULT.  If we encounter eof, set *HIT_EOF and leave  * *RESULT unchanged.  If HIT_EOF is NULL, EOF causes an "corrupt FS"  * error return.  * SCRATCH_POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_number_from_stream
parameter_list|(
name|apr_int64_t
modifier|*
name|result
parameter_list|,
name|svn_boolean_t
modifier|*
name|hit_eof
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|sb
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hit_eof
condition|)
operator|*
name|hit_eof
operator|=
name|eof
expr_stmt|;
elseif|else
if|if
condition|(
name|eof
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected EOF"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|eof
condition|)
block|{
name|err
operator|=
name|svn_cstring_atoi64
argument_list|(
name|result
argument_list|,
name|sb
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Number '%s' invalid or too large"
argument_list|)
argument_list|,
name|sb
operator|->
name|data
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given REV in FS, set *REV_OFFSET to REV's offset in the packed file.    Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_packed_offset
parameter_list|(
name|apr_off_t
modifier|*
name|rev_offset
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|svn_revnum_t
name|shard
decl_stmt|;
name|apr_int64_t
name|shard_pos
decl_stmt|;
name|apr_array_header_t
modifier|*
name|manifest
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|shard
operator|=
name|rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* position of the shard within the manifest */
name|shard_pos
operator|=
name|rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* fetch exactly that element into *rev_offset, if the manifest is found      in the cache */
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|rev_offset
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|packed_offset_cache
argument_list|,
operator|&
name|shard
argument_list|,
name|svn_fs_fs__get_sharded_offset
argument_list|,
operator|&
name|shard_pos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Open the manifest file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|manifest_stream
argument_list|,
name|path_rev_packed
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* While we're here, let's just read the entire manifest file into an array,      so we can cache the entire thing. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|manifest
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_number_from_stream
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|eof
argument_list|,
name|manifest_stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
break|break;
name|APR_ARRAY_PUSH
argument_list|(
name|manifest
argument_list|,
name|apr_off_t
argument_list|)
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|rev_offset
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|manifest
argument_list|,
name|rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|apr_off_t
argument_list|)
expr_stmt|;
comment|/* Close up shop and cache the array. */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|packed_offset_cache
argument_list|,
operator|&
name|shard
argument_list|,
name|manifest
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open the revision file for revision REV in filesystem FS and store    the newly opened file in FILE.  Seek to location OFFSET before    returning.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_revision
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|rev_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_packed_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|apr_off_t
name|rev_offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_packed_offset
argument_list|(
operator|&
name|rev_offset
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|rev_offset
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|rev_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the representation for a node-revision in transaction TXN_ID    in filesystem FS and store the newly opened file in FILE.  Seek to    location OFFSET before returning.  Perform temporary allocations in    POOL.  Only appropriate for file contents, nor props or directory    contents. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_transaction
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|rev_file
argument_list|,
name|path_txn_proto_rev
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rep
operator|->
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|rev_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a node-id ID, and a representation REP in filesystem FS, open    the correct file and seek to the correction location.  Store this    file in *FILE_P.  Perform any allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_representation
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rep
operator|->
name|txn_id
condition|)
return|return
name|open_and_seek_revision
argument_list|(
name|file_p
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|offset
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|open_and_seek_transaction
argument_list|(
name|file_p
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|txn_id
argument_list|,
name|rep
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Parse the description of a representation from STRING and store it    into *REP_P.  If the representation is mutable (the revision is    given as -1), then use TXN_ID for the representation's txn_id    field.  If MUTABLE_REP_TRUNCATED is true, then this representation    is for property or directory contents, and no information will be    expected except the "-1" revision number for a mutable    representation.  Allocate *REP_P in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_rep_offsets_body
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|rep_p
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_boolean_t
name|mutable_rep_truncated
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|rep
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rep_p
operator|=
name|rep
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|rep
operator|->
name|revision
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
name|rep
operator|->
name|txn_id
operator|=
name|txn_id
expr_stmt|;
if|if
condition|(
name|mutable_rep_truncated
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|offset
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|size
operator|=
operator|(
name|svn_filesize_t
operator|)
name|val
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|expanded_size
operator|=
operator|(
name|svn_filesize_t
operator|)
name|val
expr_stmt|;
comment|/* Read in the MD5 hash. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|!=
operator|(
name|APR_MD5_DIGESTSIZE
operator|*
literal|2
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|rep
operator|->
name|md5_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The remaining fields are only used for formats>= 4, so check that. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Read the SHA1 hash. */
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|!=
operator|(
name|APR_SHA1_DIGESTSIZE
operator|*
literal|2
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|str
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the uniquifier. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|rep
operator|->
name|uniquifier
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrap read_rep_offsets_body(), extracting its TXN_ID from our NODEREV_ID,    and adding an error message. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_rep_offsets
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|rep_p
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|noderev_id
parameter_list|,
name|svn_boolean_t
name|mutable_rep_truncated
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
if|if
condition|(
name|noderev_id
condition|)
name|txn_id
operator|=
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev_id
argument_list|)
expr_stmt|;
else|else
name|txn_id
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|read_rep_offsets_body
argument_list|(
name|rep_p
argument_list|,
name|string
argument_list|,
name|txn_id
argument_list|,
name|mutable_rep_truncated
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|id_unparsed
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|where
decl_stmt|;
name|where
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"While reading representation offsets "
literal|"for node-revision '%s':"
argument_list|)
argument_list|,
name|noderev_id
condition|?
name|id_unparsed
operator|->
name|data
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|where
argument_list|)
return|;
block|}
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|err_dangling_id
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ID_NOT_FOUND
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Reference to non-existent node '%s' in filesystem '%s'"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Look up the NODEREV_P for ID in FS' node revsion cache. If noderev  * caching has been enabled and the data can be found, IS_CACHED will  * be set to TRUE. The noderev will be allocated from POOL.  *  * Non-permanent ids (e.g. ids within a TXN) will not be cached.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_node_revision_body
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|ffd
operator|->
name|node_revision_cache
operator|||
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
condition|)
block|{
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|svn_fs_fs__id_offset
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|noderev_p
argument_list|,
name|is_cached
argument_list|,
name|ffd
operator|->
name|node_revision_cache
argument_list|,
operator|&
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If noderev caching has been enabled, store the NODEREV_P for the given ID  * in FS' node revsion cache. SCRATCH_POOL is used for temporary allcations.  *  * Non-permanent ids (e.g. ids within a TXN) will not be cached.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_cached_node_revision_body
parameter_list|(
name|node_revision_t
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
operator|&&
operator|!
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|svn_fs_fs__id_offset
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|node_revision_cache
argument_list|,
operator|&
name|key
argument_list|,
name|noderev_p
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the node-revision for the node ID in FS.    Set *NODEREV_P to the new node-revision structure, allocated in POOL.    See svn_fs_fs__get_node_revision, which wraps this and adds another    error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_revision_body
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|revision_file
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
comment|/* First, try a cache lookup. If that succeeds, we are done here. */
name|SVN_ERR
argument_list|(
name|get_cached_node_revision_body
argument_list|(
name|noderev_p
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
operator|&
name|is_cached
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
condition|)
block|{
comment|/* This is a transaction node-rev. */
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|revision_file
argument_list|,
name|path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a revision node-rev. */
name|err
operator|=
name|open_and_seek_revision
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|svn_fs_fs__id_rev
argument_list|(
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_offset
argument_list|(
name|id
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err_dangling_id
argument_list|(
name|fs
argument_list|,
name|id
argument_list|)
argument_list|)
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
name|noderev_p
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|revision_file
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The noderev is not in cache, yet. Add it, if caching has been enabled. */
return|return
name|set_cached_node_revision_body
argument_list|(
operator|*
name|noderev_p
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__read_noderev
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|headers
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|noderev_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_header_block
argument_list|(
operator|&
name|headers
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the node-rev id. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
comment|/* ### More information: filename/offset coordinates */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing id field in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|id
operator|=
name|svn_fs_fs__id_parse
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev_id
operator|=
name|value
expr_stmt|;
comment|/* for error messages later */
comment|/* Read the type. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|KIND_FILE
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
name|KIND_DIR
argument_list|)
operator|)
condition|)
comment|/* ### s/kind/type/ */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing kind field in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|kind
operator|=
operator|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|KIND_FILE
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|svn_node_file
else|:
name|svn_node_dir
expr_stmt|;
comment|/* Read the 'count' field. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
operator|&
name|noderev
operator|->
name|predecessor_count
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|noderev
operator|->
name|predecessor_count
operator|=
literal|0
expr_stmt|;
comment|/* Get the properties location. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_PROPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_rep_offsets
argument_list|(
operator|&
name|noderev
operator|->
name|prop_rep
argument_list|,
name|value
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the data location. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_rep_offsets
argument_list|(
operator|&
name|noderev
operator|->
name|data_rep
argument_list|,
name|value
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
operator|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the created path. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_CPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing cpath field in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
block|}
else|else
block|{
name|noderev
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Get the predecessor ID. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_PRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|noderev
operator|->
name|predecessor_id
operator|=
name|svn_fs_fs__id_parse
argument_list|(
name|value
argument_list|,
name|strlen
argument_list|(
name|value
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Get the copyroot. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_COPYROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed copyroot line in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|copyroot_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed copyroot line in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Get the copyfrom. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_COPYFROM
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|str
init|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|value
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed copyfrom line in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed copyfrom line in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Get whether this is a fresh txn root. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_FRESHTXNRT
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|is_fresh_txn_root
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* Get the mergeinfo count. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_MINFO_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|noderev
operator|->
name|mergeinfo_count
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|noderev
operator|->
name|mergeinfo_count
operator|=
literal|0
expr_stmt|;
comment|/* Get whether *this* node has mergeinfo. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_MINFO_HERE
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|has_mergeinfo
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
expr_stmt|;
operator|*
name|noderev_p
operator|=
name|noderev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_node_revision
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|get_node_revision_body
argument_list|(
name|noderev_p
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
condition|)
block|{
name|svn_string_t
modifier|*
name|id_string
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
literal|"Corrupt node-revision '%s'"
argument_list|,
name|id_string
operator|->
name|data
argument_list|)
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a formatted string, compatible with filesystem format FORMAT,    that represents the location of representation REP.  If    MUTABLE_REP_TRUNCATED is given, the rep is for props or dir contents,    and only a "-1" revision number will be given for a mutable rep.    If MAY_BE_CORRUPT is true, guard for NULL when constructing the string.    Perform the allocation from POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|representation_string
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|int
name|format
parameter_list|,
name|svn_boolean_t
name|mutable_rep_truncated
parameter_list|,
name|svn_boolean_t
name|may_be_corrupt
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|rep
operator|->
name|txn_id
operator|&&
name|mutable_rep_truncated
condition|)
return|return
literal|"-1"
return|;
define|#
directive|define
name|DISPLAY_MAYBE_NULL_CHECKSUM
parameter_list|(
name|checksum
parameter_list|)
define|\
value|((!may_be_corrupt || (checksum) != NULL)     \    ? svn_checksum_to_cstring_display((checksum), pool) \    : "(null)")
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
operator|||
name|rep
operator|->
name|sha1_checksum
operator|==
name|NULL
condition|)
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld %"
name|APR_OFF_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %s"
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|offset
argument_list|,
name|rep
operator|->
name|size
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|,
name|DISPLAY_MAYBE_NULL_CHECKSUM
argument_list|(
name|rep
operator|->
name|md5_checksum
argument_list|)
argument_list|)
return|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld %"
name|APR_OFF_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %s %s %s"
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|offset
argument_list|,
name|rep
operator|->
name|size
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|,
name|DISPLAY_MAYBE_NULL_CHECKSUM
argument_list|(
name|rep
operator|->
name|md5_checksum
argument_list|)
argument_list|,
name|DISPLAY_MAYBE_NULL_CHECKSUM
argument_list|(
name|rep
operator|->
name|sha1_checksum
argument_list|)
argument_list|,
name|rep
operator|->
name|uniquifier
argument_list|)
return|;
undef|#
directive|undef
name|DISPLAY_MAYBE_NULL_CHECKSUM
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__write_noderev
parameter_list|(
name|svn_stream_t
modifier|*
name|outfile
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|int
name|format
parameter_list|,
name|svn_boolean_t
name|include_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_ID
literal|": %s\n"
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_TYPE
literal|": %s\n"
argument_list|,
operator|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
condition|?
name|KIND_FILE
else|:
name|KIND_DIR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_id
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_PRED
literal|": %s\n"
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_COUNT
literal|": %d\n"
argument_list|,
name|noderev
operator|->
name|predecessor_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_TEXT
literal|": %s\n"
argument_list|,
name|representation_string
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|format
argument_list|,
operator|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_PROPS
literal|": %s\n"
argument_list|,
name|representation_string
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|format
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_CPATH
literal|": %s\n"
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|copyfrom_path
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_COPYFROM
literal|": %ld"
literal|" %s\n"
argument_list|,
name|noderev
operator|->
name|copyfrom_rev
argument_list|,
name|noderev
operator|->
name|copyfrom_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|noderev
operator|->
name|copyroot_rev
operator|!=
name|svn_fs_fs__id_rev
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|noderev
operator|->
name|copyroot_path
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_COPYROOT
literal|": %ld"
literal|" %s\n"
argument_list|,
name|noderev
operator|->
name|copyroot_rev
argument_list|,
name|noderev
operator|->
name|copyroot_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|is_fresh_txn_root
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|outfile
argument_list|,
name|HEADER_FRESHTXNRT
literal|": y\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_mergeinfo
condition|)
block|{
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|,
name|HEADER_MINFO_CNT
literal|": %"
name|APR_INT64_T_FMT
literal|"\n"
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|has_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|outfile
argument_list|,
name|HEADER_MINFO_HERE
literal|": y\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_stream_puts
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__put_node_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_boolean_t
name|fresh_txn_root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_file_t
modifier|*
name|noderev_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|noderev
operator|->
name|is_fresh_txn_root
operator|=
name|fresh_txn_root
expr_stmt|;
if|if
condition|(
operator|!
name|txn_id
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to write to non-transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|noderev_file
argument_list|,
name|path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_TRUNCATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_noderev
argument_list|(
name|svn_stream_from_aprfile2
argument_list|(
name|noderev_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|noderev
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|fs
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|noderev_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For the in-transaction NODEREV within FS, write the sha1->rep mapping  * file in the respective transaction, if rep sharing has been enabled etc.  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_sha1_rep_mapping
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* if rep sharing has been enabled and the noderev has a data rep and    * its SHA-1 is known, store the rep struct under its SHA1. */
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
operator|&&
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|sha1_checksum
condition|)
block|{
name|apr_file_t
modifier|*
name|rep_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
init|=
name|path_txn_sha1
argument_list|(
name|fs
argument_list|,
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
argument_list|,
name|noderev
operator|->
name|data_rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rep_string
init|=
name|representation_string
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
operator|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|rep_file
argument_list|,
name|file_name
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_TRUNCATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|rep_file
argument_list|,
name|rep_string
argument_list|,
name|strlen
argument_list|(
name|rep_string
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|rep_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This structure is used to hold the information associated with a    REP line. */
end_comment

begin_struct
struct|struct
name|rep_args
block|{
name|svn_boolean_t
name|is_delta
decl_stmt|;
name|svn_boolean_t
name|is_delta_vs_empty
decl_stmt|;
name|svn_revnum_t
name|base_revision
decl_stmt|;
name|apr_off_t
name|base_offset
decl_stmt|;
name|svn_filesize_t
name|base_length
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Read the next line from file FILE and parse it as a text    representation entry.  Return the parsed entry in *REP_ARGS_P.    Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_rep_line
parameter_list|(
name|struct
name|rep_args
modifier|*
modifier|*
name|rep_args_p
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|160
index|]
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
name|struct
name|rep_args
modifier|*
name|rep_args
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|last_str
init|=
name|buffer
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
operator|&
name|limit
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep_args
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep_args
argument_list|)
argument_list|)
expr_stmt|;
name|rep_args
operator|->
name|is_delta
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|REP_PLAIN
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|rep_args_p
operator|=
name|rep_args
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
argument_list|,
name|REP_DELTA
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a delta against the empty stream. */
name|rep_args
operator|->
name|is_delta
operator|=
name|TRUE
expr_stmt|;
name|rep_args
operator|->
name|is_delta_vs_empty
operator|=
name|TRUE
expr_stmt|;
operator|*
name|rep_args_p
operator|=
name|rep_args
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|rep_args
operator|->
name|is_delta
operator|=
name|TRUE
expr_stmt|;
name|rep_args
operator|->
name|is_delta_vs_empty
operator|=
name|FALSE
expr_stmt|;
comment|/* We have hopefully a DELTA vs. a non-empty base revision. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|REP_DELTA
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|error
goto|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|error
goto|;
name|rep_args
operator|->
name|base_revision
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|error
goto|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep_args
operator|->
name|base_offset
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|error
goto|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep_args
operator|->
name|base_length
operator|=
operator|(
name|svn_filesize_t
operator|)
name|val
expr_stmt|;
operator|*
name|rep_args_p
operator|=
name|rep_args
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
name|error
label|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed representation header at %s"
argument_list|)
argument_list|,
name|path_and_offset_of
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a revision file REV_FILE, opened to REV in FS, find the Node-ID    of the header located at OFFSET and store it in *ID_P.  Allocate    temporary variables from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_fs_id_at_offset
parameter_list|(
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|apr_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|apr_hash_t
modifier|*
name|headers
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id_str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_header_block
argument_list|(
operator|&
name|headers
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|rev_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In error messages, the offset is relative to the pack file,      not to the rev file. */
name|node_id_str
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_id_str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing node-id in node-rev at r%ld "
literal|"(offset %s)"
argument_list|)
argument_list|,
name|rev
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
name|id
operator|=
name|svn_fs_fs__id_parse
argument_list|(
name|node_id_str
argument_list|,
name|strlen
argument_list|(
name|node_id_str
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|id
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Corrupt node-id '%s' in node-rev at r%ld "
literal|"(offset %s)"
argument_list|)
argument_list|,
name|node_id_str
argument_list|,
name|rev
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
argument_list|,
name|offset
argument_list|)
argument_list|)
return|;
operator|*
name|id_p
operator|=
name|id
expr_stmt|;
comment|/* ### assert that the txn_id is REV/OFFSET ? */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given an open revision file REV_FILE in FS for REV, locate the trailer that    specifies the offset to the root node-id and to the changed path    information.  Store the root node offset in *ROOT_OFFSET and the    changed path offset in *CHANGES_OFFSET.  If either of these    pointers is NULL, do nothing with it.     If PACKED is true, REV_FILE should be a packed shard file.    ### There is currently no such parameter.  This function assumes that        is_packed_rev(FS, REV) will indicate whether REV_FILE is a packed        file.  Therefore FS->fsap_data->min_unpacked_rev must not have been        refreshed since REV_FILE was opened if there is a possibility that        revision REV may have become packed since then.        TODO: Take an IS_PACKED parameter instead, in order to remove this        requirement.     Allocate temporary variables from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_root_changes_offset
parameter_list|(
name|apr_off_t
modifier|*
name|root_offset
parameter_list|,
name|apr_off_t
modifier|*
name|changes_offset
parameter_list|,
name|apr_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|apr_off_t
name|rev_offset
decl_stmt|;
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_bytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_seek_where_t
name|seek_relative
decl_stmt|;
comment|/* Determine where to seek to in the file.       If we've got a pack file, we want to seek to the end of the desired      revision.  But we don't track that, so we seek to the beginning of the      next revision.       Unless the next revision is in a different file, in which case, we can      just seek to the end of the pack file -- just like we do in the      non-packed case. */
if|if
condition|(
name|is_packed_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
operator|&&
operator|(
operator|(
name|rev
operator|+
literal|1
operator|)
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|!=
literal|0
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_packed_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|rev
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|seek_relative
operator|=
name|APR_SET
expr_stmt|;
block|}
else|else
block|{
name|seek_relative
operator|=
name|APR_END
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Offset of the revision from the start of the pack file, if applicable. */
if|if
condition|(
name|is_packed_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|get_packed_offset
argument_list|(
operator|&
name|rev_offset
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rev_offset
operator|=
literal|0
expr_stmt|;
comment|/* We will assume that the last line containing the two offsets      will never be longer than 64 characters. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|seek_relative
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|-=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in this last block, from which we will identify the last line. */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read
argument_list|(
name|rev_file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This cast should be safe since the maximum amount read, 64, will      never be bigger than the size of an int. */
name|num_bytes
operator|=
operator|(
name|int
operator|)
name|len
expr_stmt|;
comment|/* The last byte should be a newline. */
if|if
condition|(
name|buf
index|[
name|num_bytes
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision file (r%ld) lacks trailing newline"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
comment|/* Look for the next previous newline. */
for|for
control|(
name|i
operator|=
name|num_bytes
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Final line in revision file (r%ld) longer "
literal|"than 64 characters"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
name|i
operator|++
expr_stmt|;
name|str
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
comment|/* find the next space */
for|for
control|(
init|;
name|i
operator|<
operator|(
name|num_bytes
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|(
name|num_bytes
operator|-
literal|2
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Final line in revision file r%ld missing space"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
if|if
condition|(
name|root_offset
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_offset
operator|=
name|rev_offset
operator|+
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|str
operator|=
operator|&
name|buf
index|[
name|i
index|]
expr_stmt|;
comment|/* find the next newline */
for|for
control|(
init|;
name|i
operator|<
name|num_bytes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|buf
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|changes_offset
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|changes_offset
operator|=
name|rev_offset
operator|+
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Move a file into place from OLD_FILENAME in the transactions    directory to its final location NEW_FILENAME in the repository.  On    Unix, match the permissions of the new file to the permissions of    PERMS_REFERENCE.  Temporary allocations are from POOL.     This function almost duplicates svn_io_file_move(), but it tries to    guarantee a flush. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|move_into_place
parameter_list|(
specifier|const
name|char
modifier|*
name|old_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|new_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|perms_reference
argument_list|,
name|old_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the file into place. */
name|err
operator|=
name|svn_io_file_rename
argument_list|(
name|old_filename
argument_list|,
name|new_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EXDEV
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* Can't rename across devices; fall back to copying. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|old_filename
argument_list|,
name|new_filename
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Flush the target of the copy to disk. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|new_filename
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### BH: Does this really guarantee a flush of the data written          ### via a completely different handle on all operating systems?          ###          ### Maybe we should perform the copy ourselves instead of making          ### apr do that and flush the real handle? */
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
ifdef|#
directive|ifdef
name|__linux__
block|{
comment|/* Linux has the unusual feature that fsync() on a file is not        enough to ensure that a file's directory entries have been        flushed to disk; you have to fsync the directory as well.        On other operating systems, we'd only be asking for trouble        by trying to open and fsync a directory. */
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|dirname
operator|=
name|svn_dirent_dirname
argument_list|(
name|new_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|dirname
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__rev_get_root
parameter_list|(
name|svn_fs_id_t
modifier|*
modifier|*
name|root_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_file_t
modifier|*
name|revision_file
decl_stmt|;
name|apr_off_t
name|root_offset
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|root_id
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|root_id_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|rev_root_id_cache
argument_list|,
operator|&
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|open_pack_or_rev_file
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_root_changes_offset
argument_list|(
operator|&
name|root_offset
argument_list|,
name|NULL
argument_list|,
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_fs_id_at_offset
argument_list|(
operator|&
name|root_id
argument_list|,
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|root_offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|revision_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|rev_root_id_cache
argument_list|,
operator|&
name|rev
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_id_p
operator|=
name|root_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Revprop caching management.  *  * Mechanism:  * ----------  *  * Revprop caching needs to be activated and will be deactivated for the  * respective FS instance if the necessary infrastructure could not be  * initialized.  In deactivated mode, there is almost no runtime overhead  * associated with revprop caching.  As long as no revprops are being read  * or changed, revprop caching imposes no overhead.  *  * When activated, we cache revprops using (revision, generation) pairs  * as keys with the generation being incremented upon every revprop change.  * Since the cache is process-local, the generation needs to be tracked  * for at least as long as the process lives but may be reset afterwards.  *  * To track the revprop generation, we use two-layer approach. On the lower  * level, we use named atomics to have a system-wide consistent value for  * the current revprop generation.  However, those named atomics will only  * remain valid for as long as at least one process / thread in the system  * accesses revprops in the respective repository.  The underlying shared  * memory gets cleaned up afterwards.  *  * On the second level, we will use a persistent file to track the latest  * revprop generation.  It will be written upon each revprop change but  * only be read if we are the first process to initialize the named atomics  * with that value.  *  * The overhead for the second and following accesses to revprops is  * almost zero on most systems.  *  *  * Tech aspects:  * -------------  *  * A problem is that we need to provide a globally available file name to  * back the SHM implementation on OSes that need it.  We can only assume  * write access to some file within the respective repositories.  Because  * a given server process may access thousands of repositories during its  * lifetime, keeping the SHM data alive for all of them is also not an  * option.  *  * So, we store the new revprop generation on disk as part of each  * setrevprop call, i.e. this write will be serialized and the write order  * be guaranteed by the repository write lock.  *  * The only racy situation occurs when the data is being read again by two  * processes concurrently but in that situation, the first process to  * finish that procedure is guaranteed to be the only one that initializes  * the SHM data.  Since even writers will first go through that  * initialization phase, they will never operate on stale data.  */
end_comment

begin_comment
comment|/* Read revprop generation as stored on disk for repository FS. The result  * is returned in *CURRENT. Default to 2 if no such file is available.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_revprop_generation_file
parameter_list|(
name|apr_int64_t
modifier|*
name|current
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|path_revprop_generation
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|current
operator|=
literal|2
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that the first line contains only digits. */
name|SVN_ERR
argument_list|(
name|check_file_buffer_numeric
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
literal|"Revprop Generation"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
name|current
argument_list|,
name|buf
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write the CURRENT revprop generation to disk for repository FS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revprop_generation_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_int64_t
name|current
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
name|char
name|buf
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|len
init|=
name|svn__i64toa
argument_list|(
name|buf
argument_list|,
name|current
argument_list|)
decl_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|move_into_place
argument_list|(
name|tmp_path
argument_list|,
name|path_revprop_generation
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|tmp_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make sure the revprop_namespace member in FS is set. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_revprop_namespace
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|ffd
operator|->
name|revprop_namespace
operator|==
name|NULL
condition|?
name|svn_atomic_namespace__create
argument_list|(
operator|&
name|ffd
operator|->
name|revprop_namespace
argument_list|,
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|ATOMIC_REVPROP_NAMESPACE
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
else|:
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make sure the revprop_namespace member in FS is set. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cleanup_revprop_namespace
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|ATOMIC_REVPROP_NAMESPACE
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_atomic_namespace__cleanup
argument_list|(
name|name
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make sure the revprop_generation member in FS is set and, if necessary,  * initialized with the latest value stored on disk.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_revprop_generation
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_revprop_namespace
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|revprop_generation
operator|==
name|NULL
condition|)
block|{
name|apr_int64_t
name|current
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_named_atomic__get
argument_list|(
operator|&
name|ffd
operator|->
name|revprop_generation
argument_list|,
name|ffd
operator|->
name|revprop_namespace
argument_list|,
name|ATOMIC_REVPROP_GENERATION
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the generation is at 0, we just created a new namespace        * (it would be at least 2 otherwise). Read the latest generation        * from disk and if we are the first one to initialize the atomic        * (i.e. is still 0), set it to the value just gotten.        */
name|SVN_ERR
argument_list|(
name|svn_named_atomic__read
argument_list|(
operator|&
name|current
argument_list|,
name|ffd
operator|->
name|revprop_generation
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|current
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_revprop_generation_file
argument_list|(
operator|&
name|current
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_named_atomic__cmpxchg
argument_list|(
name|NULL
argument_list|,
name|current
argument_list|,
literal|0
argument_list|,
name|ffd
operator|->
name|revprop_generation
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make sure the revprop_timeout member in FS is set. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_revprop_timeout
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_revprop_namespace
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|ffd
operator|->
name|revprop_timeout
operator|==
name|NULL
condition|?
name|svn_named_atomic__get
argument_list|(
operator|&
name|ffd
operator|->
name|revprop_timeout
argument_list|,
name|ffd
operator|->
name|revprop_namespace
argument_list|,
name|ATOMIC_REVPROP_TIMEOUT
argument_list|,
name|TRUE
argument_list|)
else|:
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create an error object with the given MESSAGE and pass it to the    WARNING member of FS. */
end_comment

begin_function
specifier|static
name|void
name|log_revprop_cache_init_warning
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
name|underlying_err
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REVPROP_CACHE_INIT_FAILURE
argument_list|,
name|underlying_err
argument_list|,
name|message
argument_list|,
name|fs
operator|->
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|warning
condition|)
call|(
name|fs
operator|->
name|warning
call|)
argument_list|(
name|fs
operator|->
name|warning_baton
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test whether revprop cache and necessary infrastructure are    available in FS. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|has_revprop_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_error_t
modifier|*
name|error
decl_stmt|;
comment|/* is the cache (still) enabled? */
if|if
condition|(
name|ffd
operator|->
name|revprop_cache
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* is it efficient? */
if|if
condition|(
operator|!
name|svn_named_atomic__is_efficient
argument_list|()
condition|)
block|{
comment|/* access to it would be quite slow        * -> disable the revprop cache for good        */
name|ffd
operator|->
name|revprop_cache
operator|=
name|NULL
expr_stmt|;
name|log_revprop_cache_init_warning
argument_list|(
name|fs
argument_list|,
name|NULL
argument_list|,
literal|"Revprop caching for '%s' disabled"
literal|" because it would be inefficient."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* try to access our SHM-backed infrastructure */
name|error
operator|=
name|ensure_revprop_generation
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* failure -> disable revprop cache for good */
name|ffd
operator|->
name|revprop_cache
operator|=
name|NULL
expr_stmt|;
name|log_revprop_cache_init_warning
argument_list|(
name|fs
argument_list|,
name|error
argument_list|,
literal|"Revprop caching for '%s' disabled "
literal|"because SHM infrastructure for revprop "
literal|"caching failed to initialize."
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Baton structure for revprop_generation_fixup. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|revprop_generation_fixup_t
block|{
comment|/* revprop generation to read */
name|apr_int64_t
modifier|*
name|generation
decl_stmt|;
comment|/* containing the revprop_generation member to query */
name|fs_fs_data_t
modifier|*
name|ffd
decl_stmt|;
block|}
name|revprop_generation_upgrade_t
typedef|;
end_typedef

begin_comment
comment|/* If the revprop generation has an odd value, it means the original writer    of the revprop got killed. We don't know whether that process as able    to change the revprop data but we assume that it was. Therefore, we    increase the generation in that case to basically invalidate everyones    cache content.    Execute this onlx while holding the write lock to the repo in baton->FFD.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|revprop_generation_fixup
parameter_list|(
name|void
modifier|*
name|void_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|revprop_generation_upgrade_t
modifier|*
name|baton
init|=
name|void_baton
decl_stmt|;
name|assert
argument_list|(
name|baton
operator|->
name|ffd
operator|->
name|has_write_lock
argument_list|)
expr_stmt|;
comment|/* Maybe, either the original revprop writer or some other reader has      already corrected / bumped the revprop generation.  Thus, we need      to read it again. */
name|SVN_ERR
argument_list|(
name|svn_named_atomic__read
argument_list|(
name|baton
operator|->
name|generation
argument_list|,
name|baton
operator|->
name|ffd
operator|->
name|revprop_generation
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cause everyone to re-read revprops upon their next access, if the      last revprop write did not complete properly. */
while|while
condition|(
operator|*
name|baton
operator|->
name|generation
operator|%
literal|2
condition|)
name|SVN_ERR
argument_list|(
name|svn_named_atomic__add
argument_list|(
name|baton
operator|->
name|generation
argument_list|,
literal|1
argument_list|,
name|baton
operator|->
name|ffd
operator|->
name|revprop_generation
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the current revprop generation and return it in *GENERATION.    Also, detect aborted / crashed writers and recover from that.    Use the access object in FS to set the shared mem values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_revprop_generation
parameter_list|(
name|apr_int64_t
modifier|*
name|generation
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int64_t
name|current
init|=
literal|0
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* read the current revprop generation number */
name|SVN_ERR
argument_list|(
name|ensure_revprop_generation
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_named_atomic__read
argument_list|(
operator|&
name|current
argument_list|,
name|ffd
operator|->
name|revprop_generation
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is an unfinished revprop write under the way? */
if|if
condition|(
name|current
operator|%
literal|2
condition|)
block|{
name|apr_int64_t
name|timeout
init|=
literal|0
decl_stmt|;
comment|/* read timeout for the write operation */
name|SVN_ERR
argument_list|(
name|ensure_revprop_timeout
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_named_atomic__read
argument_list|(
operator|&
name|timeout
argument_list|,
name|ffd
operator|->
name|revprop_timeout
argument_list|)
argument_list|)
expr_stmt|;
comment|/* has the writer process been aborted,        * i.e. has the timeout been reached?        */
if|if
condition|(
name|apr_time_now
argument_list|()
operator|>
name|timeout
condition|)
block|{
name|revprop_generation_upgrade_t
name|baton
decl_stmt|;
name|baton
operator|.
name|generation
operator|=
operator|&
name|current
expr_stmt|;
name|baton
operator|.
name|ffd
operator|=
name|ffd
expr_stmt|;
comment|/* Ensure that the original writer process no longer exists by            * acquiring the write lock to this repository.  Then, fix up            * the revprop generation.            */
if|if
condition|(
name|ffd
operator|->
name|has_write_lock
condition|)
name|SVN_ERR
argument_list|(
name|revprop_generation_fixup
argument_list|(
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|revprop_generation_fixup
argument_list|,
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* return the value we just got */
operator|*
name|generation
operator|=
name|current
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the revprop generation to the next odd number to indicate that    there is a revprop write process under way. If that times out,    readers shall recover from that state& re-read revprops.    Use the access object in FS to set the shared mem value. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|begin_revprop_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int64_t
name|current
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* set the timeout for the write operation */
name|SVN_ERR
argument_list|(
name|ensure_revprop_timeout
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_named_atomic__write
argument_list|(
name|NULL
argument_list|,
name|apr_time_now
argument_list|()
operator|+
name|REVPROP_CHANGE_TIMEOUT
argument_list|,
name|ffd
operator|->
name|revprop_timeout
argument_list|)
argument_list|)
expr_stmt|;
comment|/* set the revprop generation to an odd value to indicate    * that a write is in progress    */
name|SVN_ERR
argument_list|(
name|ensure_revprop_generation
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|SVN_ERR
argument_list|(
name|svn_named_atomic__add
argument_list|(
operator|&
name|current
argument_list|,
literal|1
argument_list|,
name|ffd
operator|->
name|revprop_generation
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|%
literal|2
operator|==
literal|0
condition|)
do|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the revprop generation to the next even number to indicate that    a) readers shall re-read revprops, and    b) the write process has been completed (no recovery required)    Use the access object in FS to set the shared mem value. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|end_revprop_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int64_t
name|current
init|=
literal|1
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* set the revprop generation to an even value to indicate    * that a write has been completed    */
name|SVN_ERR
argument_list|(
name|ensure_revprop_generation
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|SVN_ERR
argument_list|(
name|svn_named_atomic__add
argument_list|(
operator|&
name|current
argument_list|,
literal|1
argument_list|,
name|ffd
operator|->
name|revprop_generation
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|%
literal|2
condition|)
do|;
comment|/* Save the latest generation to disk. FS is currently in a "locked"    * state such that we can be sure the be the only ones to write that    * file.    */
return|return
name|write_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|current
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Container for all data required to access the packed revprop file  * for a given REVISION.  This structure will be filled incrementally  * by read_pack_revprops() its sub-routines.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|packed_revprops_t
block|{
comment|/* revision number to read (not necessarily the first in the pack) */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* current revprop generation. Used when populating the revprop cache */
name|apr_int64_t
name|generation
decl_stmt|;
comment|/* the actual revision properties */
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
comment|/* their size when serialized to a single string    * (as found in PACKED_REVPROPS) */
name|apr_size_t
name|serialized_size
decl_stmt|;
comment|/* name of the pack file (without folder path) */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* packed shard folder path */
specifier|const
name|char
modifier|*
name|folder
decl_stmt|;
comment|/* sum of values in SIZES */
name|apr_size_t
name|total_size
decl_stmt|;
comment|/* first revision in the pack (>= MANIFEST_START) */
name|svn_revnum_t
name|start_revision
decl_stmt|;
comment|/* size of the revprops in PACKED_REVPROPS */
name|apr_array_header_t
modifier|*
name|sizes
decl_stmt|;
comment|/* offset of the revprops in PACKED_REVPROPS */
name|apr_array_header_t
modifier|*
name|offsets
decl_stmt|;
comment|/* concatenation of the serialized representation of all revprops    * in the pack, i.e. the pack content without header and compression */
name|svn_stringbuf_t
modifier|*
name|packed_revprops
decl_stmt|;
comment|/* First revision covered by MANIFEST.    * Will equal the shard start revision or 1, for the 1st shard. */
name|svn_revnum_t
name|manifest_start
decl_stmt|;
comment|/* content of the manifest.    * Maps long(rev - MANIFEST_START) to const char* pack file name */
name|apr_array_header_t
modifier|*
name|manifest
decl_stmt|;
block|}
name|packed_revprops_t
typedef|;
end_typedef

begin_comment
comment|/* Parse the serialized revprops in CONTENT and return them in *PROPERTIES.  * Also, put them into the revprop cache, if activated, for future use.  * Three more parameters are being used to update the revprop cache: FS is  * our file system, the revprops belong to REVISION and the global revprop  * GENERATION is used as well.  *  * The returned hash will be allocated in POOL, SCRATCH_POOL is being used  * for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_revprop
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|properties
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|svn_string_t
modifier|*
name|content
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
init|=
name|svn_stream_from_string
argument_list|(
name|content
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|properties
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
operator|*
name|properties
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|generation
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|revprop_cache
argument_list|,
operator|&
name|key
argument_list|,
operator|*
name|properties
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the non-packed revprops for revision REV in FS, put them into the  * revprop cache if activated and return them in *PROPERTIES.  GENERATION  * is the current revprop generation.  *  * If the data could not be read due to an otherwise recoverable error,  * leave *PROPERTIES unchanged. No error will be returned in that case.  *  * Allocations will be done in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_non_packed_revprop
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|properties
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|missing
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RECOVERABLE_RETRY_COUNT
operator|&&
operator|!
name|missing
operator|&&
operator|!
name|content
condition|;
operator|++
name|i
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|try_stringbuf_from_file
argument_list|(
operator|&
name|content
argument_list|,
operator|&
name|missing
argument_list|,
name|path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|i
operator|+
literal|1
operator|<
name|RECOVERABLE_RETRY_COUNT
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|content
condition|)
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
name|properties
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|svn_stringbuf__morph_into_string
argument_list|(
name|content
argument_list|)
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given FS and REVPROPS->REVISION, fill the FILENAME, FOLDER and MANIFEST  * members. Use POOL for allocating results and SCRATCH_POOL for temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_revprop_packname
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|manifest_file_path
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* read content of the manifest file */
name|revprops
operator|->
name|folder
operator|=
name|path_revprops_pack_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_content
argument_list|(
operator|&
name|content
argument_list|,
name|manifest_file_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* parse the manifest. Every line is a file name */
name|revprops
operator|->
name|manifest
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read all lines.  Since the last line ends with a newline, we will      end up with a valid but empty string after the last entry. */
while|while
condition|(
name|content
operator|->
name|data
operator|&&
operator|*
name|content
operator|->
name|data
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|content
operator|->
name|data
expr_stmt|;
name|content
operator|->
name|data
operator|=
name|strchr
argument_list|(
name|content
operator|->
name|data
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|data
condition|)
block|{
operator|*
name|content
operator|->
name|data
operator|=
literal|0
expr_stmt|;
name|content
operator|->
name|data
operator|++
expr_stmt|;
block|}
block|}
comment|/* Index for our revision. Rev 0 is excluded from the first shard. */
name|revprops
operator|->
name|manifest_start
operator|=
name|revprops
operator|->
name|revision
operator|-
operator|(
name|revprops
operator|->
name|revision
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|)
expr_stmt|;
if|if
condition|(
name|revprops
operator|->
name|manifest_start
operator|==
literal|0
condition|)
operator|++
name|revprops
operator|->
name|manifest_start
expr_stmt|;
name|idx
operator|=
call|(
name|int
call|)
argument_list|(
name|revprops
operator|->
name|revision
operator|-
name|revprops
operator|->
name|manifest_start
argument_list|)
expr_stmt|;
if|if
condition|(
name|revprops
operator|->
name|manifest
operator|->
name|nelts
operator|<=
name|idx
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop manifest for r%ld too "
literal|"small"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|)
return|;
comment|/* Now get the file name */
name|revprops
operator|->
name|filename
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|idx
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if revision R1 and R2 refer to the same shard in FS.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|same_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|r1
parameter_list|,
name|svn_revnum_t
name|r2
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
operator|(
name|r1
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|==
operator|(
name|r2
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given FS and the full packed file content in REVPROPS->PACKED_REVPROPS,  * fill the START_REVISION, SIZES, OFFSETS members. Also, make  * PACKED_REVPROPS point to the first serialized revprop.  *  * Parse the revprops for REVPROPS->REVISION and set the PROPERTIES as  * well as the SERIALIZED_SIZE member.  If revprop caching has been  * enabled, parse all revprops in the pack and cache them.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_packed_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_int64_t
name|first_rev
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|header_end
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* decompress (even if the data is only "stored", there is still a    * length header to remove) */
name|svn_string_t
modifier|*
name|compressed
init|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|revprops
operator|->
name|packed_revprops
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn__decompress
argument_list|(
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|APR_SIZE_MAX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read first revision number and number of revisions in the pack */
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_number_from_stream
argument_list|(
operator|&
name|first_rev
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_number_from_stream
argument_list|(
operator|&
name|count
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check revision range for validity. */
if|if
condition|(
operator|!
name|same_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|first_rev
argument_list|)
operator|||
operator|!
name|same_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|first_rev
operator|+
name|count
operator|-
literal|1
argument_list|)
operator|||
name|count
operator|<
literal|1
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revprop pack for revision r%ld"
literal|" contains revprops for r%ld .. r%ld"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|first_rev
argument_list|,
call|(
name|svn_revnum_t
call|)
argument_list|(
name|first_rev
operator|+
name|count
operator|-
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Since start& end are in the same shard, it is enough to just test    * the FIRST_REV for being actually packed.  That will also cover the    * special case of rev 0 never being packed. */
if|if
condition|(
operator|!
name|is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|first_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revprop pack for revision r%ld"
literal|" starts at non-packed revisions r%ld"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|first_rev
argument_list|)
return|;
comment|/* make PACKED_REVPROPS point to the first char after the header.    * This is where the serialized revprops are. */
name|header_end
operator|=
name|strstr
argument_list|(
name|uncompressed
operator|->
name|data
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_end
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Header end not found"
argument_list|)
argument_list|)
return|;
name|offset
operator|=
name|header_end
operator|-
name|uncompressed
operator|->
name|data
operator|+
literal|2
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|=
name|uncompressed
operator|->
name|data
operator|+
name|offset
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|len
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|uncompressed
operator|->
name|len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|blocksize
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|uncompressed
operator|->
name|blocksize
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|/* STREAM still points to the first entry in the sizes list.    * Init / construct REVPROPS members. */
name|revprops
operator|->
name|start_revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|first_rev
expr_stmt|;
name|revprops
operator|->
name|sizes
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|offsets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now parse, revision by revision, the size and content of each    * revisions' revprops. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
operator|,
name|revprops
operator|->
name|total_size
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|apr_int64_t
name|size
decl_stmt|;
name|svn_string_t
name|serialized
decl_stmt|;
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|first_rev
operator|+
name|i
argument_list|)
decl_stmt|;
comment|/* read& check the serialized size */
name|SVN_ERR
argument_list|(
name|read_number_from_stream
argument_list|(
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|+
name|offset
operator|>
operator|(
name|apr_int64_t
operator|)
name|revprops
operator|->
name|packed_revprops
operator|->
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop size exceeds pack file size"
argument_list|)
argument_list|)
return|;
comment|/* Parse this revprops list, if necessary */
name|serialized
operator|.
name|data
operator|=
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|+
name|offset
expr_stmt|;
name|serialized
operator|.
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|revision
operator|==
name|revprops
operator|->
name|revision
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
operator|&
name|revprops
operator|->
name|properties
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|revprops
operator|->
name|generation
argument_list|,
operator|&
name|serialized
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|serialized_size
operator|=
name|serialized
operator|.
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* If revprop caching is enabled, parse any revprops.            * They will get cached as a side-effect of this. */
if|if
condition|(
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
operator|&
name|properties
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|revprops
operator|->
name|generation
argument_list|,
operator|&
name|serialized
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* fill REVPROPS data structures */
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|serialized
operator|.
name|len
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
operator|->
name|offsets
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|offset
expr_stmt|;
name|revprops
operator|->
name|total_size
operator|+=
name|serialized
operator|.
name|len
expr_stmt|;
name|offset
operator|+=
name|serialized
operator|.
name|len
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In filesystem FS, read the packed revprops for revision REV into  * *REVPROPS.  Use GENERATION to populate the revprop cache, if enabled.  * Allocate data in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_pack_revprop
parameter_list|(
name|packed_revprops_t
modifier|*
modifier|*
name|revprops
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|missing
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|packed_revprops_t
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* someone insisted that REV is packed. Double-check if necessary */
if|if
condition|(
operator|!
name|is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such packed revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* initialize the result data structure */
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|result
operator|->
name|generation
operator|=
name|generation
expr_stmt|;
comment|/* try to read the packed revprops. This may require retries if we have    * concurrent writers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|RECOVERABLE_RETRY_COUNT
operator|&&
operator|!
name|result
operator|->
name|packed_revprops
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|file_path
decl_stmt|;
comment|/* there might have been concurrent writes.        * Re-read the manifest and the pack file.        */
name|SVN_ERR
argument_list|(
name|get_revprop_packname
argument_list|(
name|fs
argument_list|,
name|result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|file_path
operator|=
name|svn_dirent_join
argument_list|(
name|result
operator|->
name|folder
argument_list|,
name|result
operator|->
name|filename
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|try_stringbuf_from_file
argument_list|(
operator|&
name|result
operator|->
name|packed_revprops
argument_list|,
operator|&
name|missing
argument_list|,
name|file_path
argument_list|,
name|i
operator|+
literal|1
operator|<
name|RECOVERABLE_RETRY_COUNT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we could not find the file, there was a write.        * So, we should refresh our revprop generation info as well such        * that others may find data we will put into the cache.  They would        * consider it outdated, otherwise.        */
if|if
condition|(
name|missing
operator|&&
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|read_revprop_generation
argument_list|(
operator|&
name|result
operator|->
name|generation
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* the file content should be available now */
if|if
condition|(
operator|!
name|result
operator|->
name|packed_revprops
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PACKED_REVPROP_READ_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to read revprop pack file for r%ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* parse it. RESULT will be complete afterwards. */
name|err
operator|=
name|parse_packed_revprops
argument_list|(
name|fs
argument_list|,
name|result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Revprop pack file for r%ld is corrupt"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
operator|*
name|revprops
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the revprops for revision REV in FS and return them in *PROPERTIES_P.  *  * Allocations will be done in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_revision_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_int64_t
name|generation
init|=
literal|0
decl_stmt|;
comment|/* not found, yet */
operator|*
name|proplist_p
operator|=
name|NULL
expr_stmt|;
comment|/* should they be available at all? */
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try cache lookup first. */
if|if
condition|(
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_revprop_generation
argument_list|(
operator|&
name|generation
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|generation
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|proplist_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|revprop_cache
argument_list|,
operator|&
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* if REV had not been packed when we began, try reading it from the    * non-packed shard.  If that fails, we will fall through to packed    * shard reads. */
if|if
condition|(
operator|!
name|is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|read_non_packed_revprop
argument_list|(
name|proplist_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|NULL
expr_stmt|;
comment|/* in case read_non_packed_revprop changed it */
block|}
block|}
comment|/* if revprop packing is available and we have not read the revprops, yet,    * try reading them from a packed shard.  If that fails, REV is most    * likely invalid (or its revprops highly contested). */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
operator|&&
operator|!
operator|*
name|proplist_p
condition|)
block|{
name|packed_revprops_t
modifier|*
name|packed_revprops
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_pack_revprop
argument_list|(
operator|&
name|packed_revprops
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|packed_revprops
operator|->
name|properties
expr_stmt|;
block|}
comment|/* The revprops should have been there. Did we get them? */
if|if
condition|(
operator|!
operator|*
name|proplist_p
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not read revprops for revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serialize the revision property list PROPLIST of revision REV in  * filesystem FS to a non-packed file.  Return the name of that temporary  * file in *TMP_PATH and the file path that it must be moved to in  * *FINAL_PATH.  *  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_non_packed_revprop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
operator|*
name|final_path
operator|=
name|path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ### do we have a directory sitting around already? we really shouldn't      ### have to get the dirname here. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmp_path
argument_list|,
name|svn_dirent_dirname
argument_list|(
operator|*
name|final_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* After writing the new revprop file(s), call this function to move the  * file at TMP_PATH to FINAL_PATH and give it the permissions from  * PERMS_REFERENCE.  *  * If indicated in BUMP_GENERATION, increase FS' revprop generation.  * Finally, delete all the temporary files given in FILES_TO_DELETE.  * The latter may be NULL.  *  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|switch_to_new_revprop
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
name|tmp_path
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_array_header_t
modifier|*
name|files_to_delete
parameter_list|,
name|svn_boolean_t
name|bump_generation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Now, we may actually be replacing revprops. Make sure that all other      threads and processes will know about this. */
if|if
condition|(
name|bump_generation
condition|)
name|SVN_ERR
argument_list|(
name|begin_revprop_change
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|move_into_place
argument_list|(
name|tmp_path
argument_list|,
name|final_path
argument_list|,
name|perms_reference
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate that the update (if relevant) has been completed. */
if|if
condition|(
name|bump_generation
condition|)
name|SVN_ERR
argument_list|(
name|end_revprop_change
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up temporary files, if necessary. */
if|if
condition|(
name|files_to_delete
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files_to_delete
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|files_to_delete
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write a pack file header to STREAM that starts at revision START_REVISION  * and contains the indexes [START,END) of SIZES.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|serialize_revprops_header
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|apr_array_header_t
modifier|*
name|sizes
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|start
operator|<
name|end
argument_list|)
expr_stmt|;
comment|/* start revision and entry count */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"%ld\n"
argument_list|,
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"%d\n"
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the sizes array */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
name|apr_off_t
name|size
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sizes
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|iterpool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
literal|"\n"
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* the double newline char indicates the end of the header */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|iterpool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Writes the a pack file to FILE_STREAM.  It copies the serialized data  * from REVPROPS for the indexes [START,END) except for index CHANGED_INDEX.  *  * The data for the latter is taken from NEW_SERIALIZED.  Note, that  * CHANGED_INDEX may be outside the [START,END) range, i.e. no new data is  * taken in that case but only a subset of the old data will be copied.  *  * NEW_TOTAL_SIZE is a hint for pre-allocating buffers of appropriate size.  * POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|changed_index
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|new_serialized
parameter_list|,
name|apr_off_t
name|new_total_size
parameter_list|,
name|svn_stream_t
modifier|*
name|file_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* create data empty buffers and the stream object */
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
operator|(
name|apr_size_t
operator|)
name|new_total_size
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* write the header*/
name|SVN_ERR
argument_list|(
name|serialize_revprops_header
argument_list|(
name|stream
argument_list|,
name|revprops
operator|->
name|start_revision
operator|+
name|start
argument_list|,
name|revprops
operator|->
name|sizes
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* append the serialized revprops */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|==
name|changed_index
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|new_serialized
operator|->
name|data
argument_list|,
operator|&
name|new_serialized
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_size_t
name|size
init|=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|apr_size_t
name|offset
init|=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|offsets
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|+
name|offset
argument_list|,
operator|&
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush the stream buffer (if any) to our underlying data buffer */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compress / store the data */
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|svn_stringbuf__morph_into_string
argument_list|(
name|uncompressed
argument_list|)
argument_list|,
name|compressed
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
else|:
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finally, write the content to the target stream and close it */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|file_stream
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
operator|&
name|compressed
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|file_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new pack file name for revisions  *     [REVPROPS->START_REVISION + START, REVPROPS->START_REVISION + END - 1]  * of REVPROPS->MANIFEST.  Add the name of old file to FILES_TO_DELETE,  * auto-create that array if necessary.  Return an open file stream to  * the new file in *STREAM allocated in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repack_stream_open
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|files_to_delete
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int64_t
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag_string
decl_stmt|;
name|svn_string_t
modifier|*
name|new_filename
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|int
name|manifest_offset
init|=
call|(
name|int
call|)
argument_list|(
name|revprops
operator|->
name|start_revision
operator|-
name|revprops
operator|->
name|manifest_start
argument_list|)
decl_stmt|;
comment|/* get the old (= current) file name and enlist it for later deletion */
specifier|const
name|char
modifier|*
name|old_filename
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|start
operator|+
name|manifest_offset
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|files_to_delete
operator|==
name|NULL
condition|)
operator|*
name|files_to_delete
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|files_to_delete
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|old_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* increase the tag part, i.e. the counter after the dot */
name|tag_string
operator|=
name|strchr
argument_list|(
name|old_filename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_string
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed file '%s' misses a tag"
argument_list|)
argument_list|,
name|old_filename
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|tag
argument_list|,
name|tag_string
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new_filename
operator|=
name|svn_string_createf
argument_list|(
name|pool
argument_list|,
literal|"%ld.%"
name|APR_INT64_T_FMT
argument_list|,
name|revprops
operator|->
name|start_revision
operator|+
name|start
argument_list|,
operator|++
name|tag
argument_list|)
expr_stmt|;
comment|/* update the manifest to point to the new file */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|i
operator|+
name|manifest_offset
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|new_filename
operator|->
name|data
expr_stmt|;
comment|/* create a file stream for the new file */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|new_filename
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For revision REV in filesystem FS, set the revision properties to  * PROPLIST.  Return a new file in *TMP_PATH that the caller shall move  * to *FINAL_PATH to make the change visible.  Files to be deleted will  * be listed in *FILES_TO_DELETE which may remain unchanged / unallocated.  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_packed_revprop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_path
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|files_to_delete
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|packed_revprops_t
modifier|*
name|revprops
decl_stmt|;
name|apr_int64_t
name|generation
init|=
literal|0
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_off_t
name|new_total_size
decl_stmt|;
name|int
name|changed_index
decl_stmt|;
comment|/* read the current revprop generation. This value will not change    * while we hold the global write lock to this FS. */
if|if
condition|(
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|read_revprop_generation
argument_list|(
operator|&
name|generation
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read contents of the current pack file */
name|SVN_ERR
argument_list|(
name|read_pack_revprop
argument_list|(
operator|&
name|revprops
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize the new revprops */
name|serialized
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|serialized
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate the size of the new data */
name|changed_index
operator|=
call|(
name|int
call|)
argument_list|(
name|rev
operator|-
name|revprops
operator|->
name|start_revision
argument_list|)
expr_stmt|;
name|new_total_size
operator|=
name|revprops
operator|->
name|total_size
operator|-
name|revprops
operator|->
name|serialized_size
operator|+
name|serialized
operator|->
name|len
operator|+
operator|(
name|revprops
operator|->
name|offsets
operator|->
name|nelts
operator|+
literal|2
operator|)
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|changed_index
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
comment|/* can we put the new data into the same pack as the before? */
if|if
condition|(
name|new_total_size
operator|<
name|ffd
operator|->
name|revprop_pack_size
operator|||
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
comment|/* simply replace the old pack file with new content as we do it        * in the non-packed case */
operator|*
name|final_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|revprops
operator|->
name|filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmp_path
argument_list|,
name|revprops
operator|->
name|folder
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* split the pack file into two of roughly equal size */
name|int
name|right_count
decl_stmt|,
name|left_count
decl_stmt|,
name|i
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|;
name|int
name|right
init|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
literal|1
decl_stmt|;
name|apr_off_t
name|left_size
init|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
decl_stmt|;
name|apr_off_t
name|right_size
init|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
decl_stmt|;
comment|/* let left and right side grow such that their size difference        * is minimal after each step. */
while|while
condition|(
name|left
operator|<=
name|right
condition|)
if|if
condition|(
name|left_size
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|left
argument_list|,
name|apr_off_t
argument_list|)
operator|<
name|right_size
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|right
argument_list|,
name|apr_off_t
argument_list|)
condition|)
block|{
name|left_size
operator|+=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|left
argument_list|,
name|apr_off_t
argument_list|)
operator|+
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
operator|++
name|left
expr_stmt|;
block|}
else|else
block|{
name|right_size
operator|+=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|right
argument_list|,
name|apr_off_t
argument_list|)
operator|+
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
comment|/* since the items need much less than SVN_INT64_BUFFER_SIZE         * bytes to represent their length, the split may not be optimal */
name|left_count
operator|=
name|left
expr_stmt|;
name|right_count
operator|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|left
expr_stmt|;
comment|/* if new_size is large, one side may exceed the pack size limit.        * In that case, split before and after the modified revprop.*/
if|if
condition|(
name|left_size
operator|>
name|ffd
operator|->
name|revprop_pack_size
operator|||
name|right_size
operator|>
name|ffd
operator|->
name|revprop_pack_size
condition|)
block|{
name|left_count
operator|=
name|changed_index
expr_stmt|;
name|right_count
operator|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|left_count
operator|-
literal|1
expr_stmt|;
block|}
comment|/* write the new, split files */
if|if
condition|(
name|left_count
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_stream_open
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|left_count
argument_list|,
name|files_to_delete
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|left_count
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left_count
operator|+
name|right_count
operator|<
name|revprops
operator|->
name|sizes
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_stream_open
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
name|changed_index
argument_list|,
name|changed_index
operator|+
literal|1
argument_list|,
name|files_to_delete
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
name|changed_index
argument_list|,
name|changed_index
operator|+
literal|1
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right_count
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_stream_open
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|right_count
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|files_to_delete
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|right_count
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write the new manifest */
operator|*
name|final_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmp_path
argument_list|,
name|revprops
operator|->
name|folder
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|manifest
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the revision property list of revision REV in filesystem FS to    PROPLIST.  Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_revision_proplist
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_packed
decl_stmt|;
name|svn_boolean_t
name|bump_generation
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|perms_reference
decl_stmt|;
name|apr_array_header_t
modifier|*
name|files_to_delete
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this info will not change while we hold the global FS write lock */
name|is_packed
operator|=
name|is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|/* Test whether revprops already exist for this revision.    * Only then will we need to bump the revprop generation. */
if|if
condition|(
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_packed
condition|)
block|{
name|bump_generation
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|bump_generation
operator|=
name|kind
operator|!=
name|svn_node_none
expr_stmt|;
block|}
block|}
comment|/* Serialize the new revprop data */
if|if
condition|(
name|is_packed
condition|)
name|SVN_ERR
argument_list|(
name|write_packed_revprop
argument_list|(
operator|&
name|final_path
argument_list|,
operator|&
name|tmp_path
argument_list|,
operator|&
name|files_to_delete
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|write_non_packed_revprop
argument_list|(
operator|&
name|final_path
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use the rev file of this revision as the perms reference,    * because when setting revprops for the first time, the revprop    * file won't exist and therefore can't serve as its own reference.    * (Whereas the rev file should already exist at this point.)    */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__path_rev_absolute
argument_list|(
operator|&
name|perms_reference
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, switch to the new revprop data. */
name|SVN_ERR
argument_list|(
name|switch_to_new_revprop
argument_list|(
name|fs
argument_list|,
name|final_path
argument_list|,
name|tmp_path
argument_list|,
name|perms_reference
argument_list|,
name|files_to_delete
argument_list|,
name|bump_generation
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__revision_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|get_revision_proplist
argument_list|(
name|proplist_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Represents where in the current svndiff data block each    representation is. */
end_comment

begin_struct
struct|struct
name|rep_state
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* The txdelta window cache to use or NULL. */
name|svn_cache__t
modifier|*
name|window_cache
decl_stmt|;
comment|/* Caches un-deltified windows. May be NULL. */
name|svn_cache__t
modifier|*
name|combined_cache
decl_stmt|;
name|apr_off_t
name|start
decl_stmt|;
comment|/* The starting offset for the raw                        svndiff/plaintext data minus header. */
name|apr_off_t
name|off
decl_stmt|;
comment|/* The current offset into the file. */
name|apr_off_t
name|end
decl_stmt|;
comment|/* The end offset of the raw data. */
name|int
name|ver
decl_stmt|;
comment|/* If a delta, what svndiff version? */
name|int
name|chunk_index
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* See create_rep_state, which wraps this and adds another error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_rep_state_body
parameter_list|(
name|struct
name|rep_state
modifier|*
modifier|*
name|rep_state
parameter_list|,
name|struct
name|rep_args
modifier|*
modifier|*
name|rep_args
parameter_list|,
name|apr_file_t
modifier|*
modifier|*
name|file_hint
parameter_list|,
name|svn_revnum_t
modifier|*
name|rev_hint
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|struct
name|rep_state
modifier|*
name|rs
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|rep_args
modifier|*
name|ra
decl_stmt|;
name|unsigned
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
comment|/* If the hint is    * - given,    * - refers to a valid revision,    * - refers to a packed revision,    * - as does the rep we want to read, and    * - refers to the same pack file as the rep    * ...    */
if|if
condition|(
name|file_hint
operator|&&
name|rev_hint
operator|&&
operator|*
name|file_hint
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|rev_hint
argument_list|)
operator|&&
operator|*
name|rev_hint
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|&&
name|rep
operator|->
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|&&
operator|(
operator|(
operator|*
name|rev_hint
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|==
operator|(
name|rep
operator|->
name|revision
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|)
condition|)
block|{
comment|/* ... we can re-use the same, already open file object        */
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_packed_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|rep
operator|->
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
operator|*
name|file_hint
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|file
operator|=
operator|*
name|file_hint
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, create a new file object        */
name|SVN_ERR
argument_list|(
name|open_and_seek_representation
argument_list|(
operator|&
name|rs
operator|->
name|file
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* remember the current file, if suggested by the caller */
if|if
condition|(
name|file_hint
condition|)
operator|*
name|file_hint
operator|=
name|rs
operator|->
name|file
expr_stmt|;
if|if
condition|(
name|rev_hint
condition|)
operator|*
name|rev_hint
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
comment|/* continue constructing RS and RA */
name|rs
operator|->
name|window_cache
operator|=
name|ffd
operator|->
name|txdelta_window_cache
expr_stmt|;
name|rs
operator|->
name|combined_cache
operator|=
name|ffd
operator|->
name|combined_window_cache
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_rep_line
argument_list|(
operator|&
name|ra
argument_list|,
name|rs
operator|->
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rs
operator|->
name|start
argument_list|,
name|rs
operator|->
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|off
operator|=
name|rs
operator|->
name|start
expr_stmt|;
name|rs
operator|->
name|end
operator|=
name|rs
operator|->
name|start
operator|+
name|rep
operator|->
name|size
expr_stmt|;
operator|*
name|rep_state
operator|=
name|rs
expr_stmt|;
operator|*
name|rep_args
operator|=
name|ra
expr_stmt|;
if|if
condition|(
operator|!
name|ra
operator|->
name|is_delta
condition|)
comment|/* This is a plaintext, so just return the current rep_state. */
return|return
name|SVN_NO_ERROR
return|;
comment|/* We are dealing with a delta, find out what version. */
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Layering violation */
if|if
condition|(
operator|!
operator|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'V'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'N'
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed svndiff data in representation"
argument_list|)
argument_list|)
return|;
name|rs
operator|->
name|ver
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|off
operator|+=
literal|4
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the rep args for REP in filesystem FS and create a rep_state    for reading the representation.  Return the rep_state in *REP_STATE    and the rep args in *REP_ARGS, both allocated in POOL.     When reading multiple reps, i.e. a skip delta chain, you may provide    non-NULL FILE_HINT and REV_HINT.  (If FILE_HINT is not NULL, in the first    call it should be a pointer to NULL.)  The function will use these variables    to store the previous call results and tries to re-use them.  This may    result in significant savings in I/O for packed files.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_rep_state
parameter_list|(
name|struct
name|rep_state
modifier|*
modifier|*
name|rep_state
parameter_list|,
name|struct
name|rep_args
modifier|*
modifier|*
name|rep_args
parameter_list|,
name|apr_file_t
modifier|*
modifier|*
name|file_hint
parameter_list|,
name|svn_revnum_t
modifier|*
name|rev_hint
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|create_rep_state_body
argument_list|(
name|rep_state
argument_list|,
name|rep_args
argument_list|,
name|file_hint
argument_list|,
name|rev_hint
argument_list|,
name|rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* ### This always returns "-1" for transaction reps, because          ### this particular bit of code doesn't know if the rep is          ### stored in the protorev or in the mutable area (for props          ### or dir contents).  It is pretty rare for FSFS to *read*          ### from the protorev file, though, so this is probably OK.          ### And anyone going to debug corruption errors is probably          ### going to jump straight to this comment anyway! */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
literal|"Corrupt representation '%s'"
argument_list|,
name|rep
condition|?
name|representation_string
argument_list|(
name|rep
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
else|:
literal|"(null)"
argument_list|)
return|;
block|}
comment|/* ### Call representation_string() ? */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|rep_read_baton
block|{
comment|/* The FS from which we're reading. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* If not NULL, this is the base for the first delta window in rs_list */
name|svn_stringbuf_t
modifier|*
name|base_window
decl_stmt|;
comment|/* The state of all prior delta representations. */
name|apr_array_header_t
modifier|*
name|rs_list
decl_stmt|;
comment|/* The plaintext state, if there is a plaintext. */
name|struct
name|rep_state
modifier|*
name|src_state
decl_stmt|;
comment|/* The index of the current delta chunk, if we are reading a delta. */
name|int
name|chunk_index
decl_stmt|;
comment|/* The buffer where we store undeltified data. */
name|char
modifier|*
name|buf
decl_stmt|;
name|apr_size_t
name|buf_pos
decl_stmt|;
name|apr_size_t
name|buf_len
decl_stmt|;
comment|/* A checksum context for summing the data read in order to verify it.      Note: we don't need to use the sha1 checksum because we're only doing      data verification, for which md5 is perfectly safe.  */
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
name|svn_boolean_t
name|checksum_finalized
decl_stmt|;
comment|/* The stored checksum of the representation we are reading, its      length, and the amount we've read so far.  Some of this      information is redundant with rs_list and src_state, but it's      convenient for the checksumming code to have it here. */
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|svn_filesize_t
name|len
decl_stmt|;
name|svn_filesize_t
name|off
decl_stmt|;
comment|/* The key for the fulltext cache for this rep, if there is a      fulltext cache. */
name|pair_cache_key_t
name|fulltext_cache_key
decl_stmt|;
comment|/* The text we've been reading, if we're going to cache it. */
name|svn_stringbuf_t
modifier|*
name|current_fulltext
decl_stmt|;
comment|/* Used for temporary allocations during the read. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Pool used to store file handles and other data that is persistant      for the entire stream read. */
name|apr_pool_t
modifier|*
name|filehandle_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Combine the name of the rev file in RS with the given OFFSET to form  * a cache lookup key.  Allocations will be made from POOL.  May return  * NULL if the key cannot be constructed. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|get_window_key
parameter_list|(
name|struct
name|rep_state
modifier|*
name|rs
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_part
decl_stmt|;
specifier|const
name|char
modifier|*
name|name_last
decl_stmt|;
comment|/* the rev file name containing the txdelta window.    * If this fails we are in serious trouble anyways.    * And if nobody else detects the problems, the file content checksum    * comparison _will_ find them.    */
if|if
condition|(
name|apr_file_name_get
argument_list|(
operator|&
name|name
argument_list|,
name|rs
operator|->
name|file
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* Handle packed files as well by scanning backwards until we find the    * revision or pack number. */
name|name_last
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|svn_ctype_isdigit
argument_list|(
operator|*
name|name_last
argument_list|)
condition|)
operator|--
name|name_last
expr_stmt|;
name|last_part
operator|=
name|name_last
expr_stmt|;
while|while
condition|(
name|svn_ctype_isdigit
argument_list|(
operator|*
name|last_part
argument_list|)
condition|)
operator|--
name|last_part
expr_stmt|;
comment|/* We must differentiate between packed files (as of today, the number    * is being followed by a dot) and non-packed files (followed by \0).    * Otherwise, there might be overlaps in the numbering range if the    * repo gets packed after caching the txdeltas of non-packed revs.    * => add the first non-digit char to the packed number. */
if|if
condition|(
name|name_last
index|[
literal|1
index|]
operator|!=
literal|'\0'
condition|)
operator|++
name|name_last
expr_stmt|;
comment|/* copy one char MORE than the actual number to mark packed files,    * i.e. packed revision file content uses different key space then    * non-packed ones: keys for packed rev file content ends with a dot    * for non-packed rev files they end with a digit. */
name|name
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|last_part
operator|+
literal|1
argument_list|,
name|name_last
operator|-
name|last_part
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__combine_number_and_string
argument_list|(
name|offset
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the WINDOW_P for the rep state RS from the current FSFS session's  * cache. This will be a no-op and IS_CACHED will be set to FALSE if no  * cache has been given. If a cache is available IS_CACHED will inform  * the caller about the success of the lookup. Allocations (of the window  * in particualar) will be made from POOL.  *  * If the information could be found, put RS and the position within the  * rev file into the same state as if the data had just been read from it.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|struct
name|rep_state
modifier|*
name|rs
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|->
name|window_cache
condition|)
block|{
comment|/* txdelta window has not been enabled */
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* ask the cache for the desired txdelta window */
name|svn_fs_fs__txdelta_cached_window_t
modifier|*
name|cached_window
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cached_window
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|window_cache
argument_list|,
name|get_window_key
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|off
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|is_cached
condition|)
block|{
comment|/* found it. Pass it back to the caller. */
operator|*
name|window_p
operator|=
name|cached_window
operator|->
name|window
expr_stmt|;
comment|/* manipulate the RS as if we just read the data */
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|rs
operator|->
name|off
operator|=
name|cached_window
operator|->
name|end_offset
expr_stmt|;
comment|/* manipulate the rev file as if we just read from it */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|rs
operator|->
name|off
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store the WINDOW read at OFFSET for the rep state RS in the current  * FSFS session's cache. This will be a no-op if no cache has been given.  * Temporary allocations will be made from SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_cached_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|struct
name|rep_state
modifier|*
name|rs
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|window_cache
condition|)
block|{
comment|/* store the window and the first offset _past_ it */
name|svn_fs_fs__txdelta_cached_window_t
name|cached_window
decl_stmt|;
name|cached_window
operator|.
name|window
operator|=
name|window
expr_stmt|;
name|cached_window
operator|.
name|end_offset
operator|=
name|rs
operator|->
name|off
expr_stmt|;
comment|/* but key it with the start offset because that is the known state        * when we will look it up */
return|return
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|window_cache
argument_list|,
name|get_window_key
argument_list|(
name|rs
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|&
name|cached_window
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the WINDOW_P for the rep state RS from the current FSFS session's  * cache. This will be a no-op and IS_CACHED will be set to FALSE if no  * cache has been given. If a cache is available IS_CACHED will inform  * the caller about the success of the lookup. Allocations (of the window  * in particualar) will be made from POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|struct
name|rep_state
modifier|*
name|rs
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|->
name|combined_cache
condition|)
block|{
comment|/* txdelta window has not been enabled */
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* ask the cache for the desired txdelta window */
return|return
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|window_p
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|combined_cache
argument_list|,
name|get_window_key
argument_list|(
name|rs
argument_list|,
name|rs
operator|->
name|start
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store the WINDOW read at OFFSET for the rep state RS in the current  * FSFS session's cache. This will be a no-op if no cache has been given.  * Temporary allocations will be made from SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_cached_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|window
parameter_list|,
name|struct
name|rep_state
modifier|*
name|rs
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|combined_cache
condition|)
block|{
comment|/* but key it with the start offset because that is the known state        * when we will look it up */
return|return
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|combined_cache
argument_list|,
name|get_window_key
argument_list|(
name|rs
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|window
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Build an array of rep_state structures in *LIST giving the delta    reps from first_rep to a plain-text or self-compressed rep.  Set    *SRC_STATE to the plain-text rep we find at the end of the chain,    or to NULL if the final delta representation is self-compressed.    The representation to start from is designated by filesystem FS, id    ID, and representation REP.    Also, set *WINDOW_P to the base window content for *LIST, if it    could be found in cache. Otherwise, *LIST will contain the base    representation for the whole delta chain.    Finally, return the expanded size of the representation in    *EXPANDED_SIZE. It will take care of cases where only the on-disk    size is known.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_rep_list
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|list
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|struct
name|rep_state
modifier|*
modifier|*
name|src_state
parameter_list|,
name|svn_filesize_t
modifier|*
name|expanded_size
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|first_rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
name|rep
decl_stmt|;
name|struct
name|rep_state
modifier|*
name|rs
init|=
name|NULL
decl_stmt|;
name|struct
name|rep_args
modifier|*
name|rep_args
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|apr_file_t
modifier|*
name|last_file
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|last_revision
decl_stmt|;
operator|*
name|list
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rep_state
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
operator|*
name|first_rep
expr_stmt|;
comment|/* The value as stored in the data struct.      0 is either for unknown length or actually zero length. */
operator|*
name|expanded_size
operator|=
name|first_rep
operator|->
name|expanded_size
expr_stmt|;
comment|/* for the top-level rep, we need the rep_args */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_args
argument_list|,
operator|&
name|last_file
argument_list|,
operator|&
name|last_revision
argument_list|,
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unknown size or empty representation?      That implies the this being the first iteration.      Usually size equals on-disk size, except for empty,      compressed representations (delta, size = 4).      Please note that for all non-empty deltas have      a 4-byte header _plus_ some data. */
if|if
condition|(
operator|*
name|expanded_size
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|rep_args
operator|->
name|is_delta
operator|||
name|first_rep
operator|->
name|size
operator|!=
literal|4
condition|)
operator|*
name|expanded_size
operator|=
name|first_rep
operator|->
name|size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* fetch state, if that has not been done already */
if|if
condition|(
operator|!
name|rs
condition|)
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_args
argument_list|,
operator|&
name|last_file
argument_list|,
operator|&
name|last_revision
argument_list|,
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_cached_combined_window
argument_list|(
name|window_p
argument_list|,
name|rs
argument_list|,
operator|&
name|is_cached
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
comment|/* We already have a reconstructed window in our cache.              Write a pseudo rep_state with the full length. */
name|rs
operator|->
name|off
operator|=
name|rs
operator|->
name|start
expr_stmt|;
name|rs
operator|->
name|end
operator|=
name|rs
operator|->
name|start
operator|+
operator|(
operator|*
name|window_p
operator|)
operator|->
name|len
expr_stmt|;
operator|*
name|src_state
operator|=
name|rs
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|rep_args
operator|->
name|is_delta
condition|)
block|{
comment|/* This is a plaintext, so just return the current rep_state. */
operator|*
name|src_state
operator|=
name|rs
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Push this rep onto the list.  If it's self-compressed, we're done. */
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|list
argument_list|,
expr|struct
name|rep_state
operator|*
argument_list|)
operator|=
name|rs
expr_stmt|;
if|if
condition|(
name|rep_args
operator|->
name|is_delta_vs_empty
condition|)
block|{
operator|*
name|src_state
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|rep
operator|.
name|revision
operator|=
name|rep_args
operator|->
name|base_revision
expr_stmt|;
name|rep
operator|.
name|offset
operator|=
name|rep_args
operator|->
name|base_offset
expr_stmt|;
name|rep
operator|.
name|size
operator|=
name|rep_args
operator|->
name|base_length
expr_stmt|;
name|rep
operator|.
name|txn_id
operator|=
name|NULL
expr_stmt|;
name|rs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Create a rep_read_baton structure for node revision NODEREV in    filesystem FS and store it in *RB_P.  If FULLTEXT_CACHE_KEY is not    NULL, it is the rep's key in the fulltext cache, and a stringbuf    must be allocated to store the text.  Perform all allocations in    POOL.  If rep is mutable, it must be for file contents. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_get_baton
parameter_list|(
name|struct
name|rep_read_baton
modifier|*
modifier|*
name|rb_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|pair_cache_key_t
name|fulltext_cache_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|->
name|base_window
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|checksum_finalized
operator|=
name|FALSE
expr_stmt|;
name|b
operator|->
name|md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|rep
operator|->
name|md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|len
operator|=
name|rep
operator|->
name|expanded_size
expr_stmt|;
name|b
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|fulltext_cache_key
operator|=
name|fulltext_cache_key
expr_stmt|;
name|b
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|filehandle_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build_rep_list
argument_list|(
operator|&
name|b
operator|->
name|rs_list
argument_list|,
operator|&
name|b
operator|->
name|base_window
argument_list|,
operator|&
name|b
operator|->
name|src_state
argument_list|,
operator|&
name|b
operator|->
name|len
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|b
operator|->
name|filehandle_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|fulltext_cache_key
operator|.
name|revision
argument_list|)
condition|)
name|b
operator|->
name|current_fulltext
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
operator|(
name|apr_size_t
operator|)
name|b
operator|->
name|len
argument_list|,
name|b
operator|->
name|filehandle_pool
argument_list|)
expr_stmt|;
else|else
name|b
operator|->
name|current_fulltext
operator|=
name|NULL
expr_stmt|;
comment|/* Save our output baton. */
operator|*
name|rb_p
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Skip forwards to THIS_CHUNK in REP_STATE and then read the next delta    window into *NWIN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_delta_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|nwin
parameter_list|,
name|int
name|this_chunk
parameter_list|,
name|struct
name|rep_state
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|apr_off_t
name|old_offset
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rs
operator|->
name|chunk_index
operator|<=
name|this_chunk
argument_list|)
expr_stmt|;
comment|/* RS->FILE may be shared between RS instances -> make sure we point    * to the right data. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|rs
operator|->
name|off
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip windows to reach the current chunk if we aren't there yet. */
while|while
condition|(
name|rs
operator|->
name|chunk_index
operator|<
name|this_chunk
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_txdelta_skip_svndiff_window
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|rs
operator|->
name|ver
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rs
operator|->
name|off
argument_list|,
name|rs
operator|->
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|off
operator|>=
name|rs
operator|->
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read "
literal|"beyond the end of the "
literal|"representation"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Read the next window. But first, try to find it in the cache. */
name|SVN_ERR
argument_list|(
name|get_cached_window
argument_list|(
name|nwin
argument_list|,
name|rs
argument_list|,
operator|&
name|is_cached
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Actually read the next window. */
name|old_offset
operator|=
name|rs
operator|->
name|off
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_read_svndiff_window
argument_list|(
name|nwin
argument_list|,
name|stream
argument_list|,
name|rs
operator|->
name|ver
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rs
operator|->
name|off
argument_list|,
name|rs
operator|->
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|off
operator|>
name|rs
operator|->
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read beyond "
literal|"the end of the representation"
argument_list|)
argument_list|)
return|;
comment|/* the window has not been cached before, thus cache it now    * (if caching is used for them at all) */
return|return
name|set_cached_window
argument_list|(
operator|*
name|nwin
argument_list|,
name|rs
argument_list|,
name|old_offset
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read SIZE bytes from the representation RS and return it in *NWIN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_plain_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|nwin
parameter_list|,
name|struct
name|rep_state
modifier|*
name|rs
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* RS->FILE may be shared between RS instances -> make sure we point    * to the right data. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|rs
operator|->
name|off
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the plain data. */
operator|*
name|nwin
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|size
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|file
argument_list|,
operator|(
operator|*
name|nwin
operator|)
operator|->
name|data
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nwin
operator|)
operator|->
name|data
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Update RS. */
name|rs
operator|->
name|off
operator|+=
operator|(
name|apr_off_t
operator|)
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the undeltified window that is a result of combining all deltas    from the current desired representation identified in *RB with its    base representation.  Store the window in *RESULT. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|result
parameter_list|,
name|struct
name|rep_read_baton
modifier|*
name|rb
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|,
modifier|*
name|new_pool
decl_stmt|,
modifier|*
name|window_pool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|apr_array_header_t
modifier|*
name|windows
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|source
decl_stmt|,
modifier|*
name|buf
init|=
name|rb
operator|->
name|base_window
decl_stmt|;
name|struct
name|rep_state
modifier|*
name|rs
decl_stmt|;
comment|/* Read all windows that we need to combine. This is fine because      the size of each window is relatively small (100kB) and skip-      delta limits the number of deltas in a chain to well under 100.      Stop early if one of them does not depend on its predecessors. */
name|window_pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|windows
operator|=
name|apr_array_make
argument_list|(
name|window_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_txdelta_window_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rb
operator|->
name|rs_list
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
name|i
argument_list|,
expr|struct
name|rep_state
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_delta_window
argument_list|(
operator|&
name|window
argument_list|,
name|rb
operator|->
name|chunk_index
argument_list|,
name|rs
argument_list|,
name|window_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|windows
argument_list|,
name|svn_txdelta_window_t
operator|*
argument_list|)
operator|=
name|window
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|src_ops
operator|==
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Combine in the windows from the other delta reps. */
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
name|i
argument_list|,
expr|struct
name|rep_state
operator|*
argument_list|)
expr_stmt|;
name|window
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|windows
argument_list|,
name|i
argument_list|,
name|svn_txdelta_window_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Maybe, we've got a PLAIN start representation.  If we do, read          as much data from it as the needed for the txdelta window's source          view.          Note that BUF / SOURCE may only be NULL in the first iteration. */
name|source
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
operator|&&
name|rb
operator|->
name|src_state
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|read_plain_window
argument_list|(
operator|&
name|source
argument_list|,
name|rb
operator|->
name|src_state
argument_list|,
name|window
operator|->
name|sview_len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Combine this window with the current one. */
name|new_pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|buf
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|window
operator|->
name|tview_len
argument_list|,
name|new_pool
argument_list|)
expr_stmt|;
name|buf
operator|->
name|len
operator|=
name|window
operator|->
name|tview_len
expr_stmt|;
name|svn_txdelta_apply_instructions
argument_list|(
name|window
argument_list|,
name|source
condition|?
name|source
operator|->
name|data
else|:
name|NULL
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|!=
name|window
operator|->
name|tview_len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"svndiff window length is "
literal|"corrupt"
argument_list|)
argument_list|)
return|;
comment|/* Cache windows only if the whole rep content could be read as a          single chunk.  Only then will no other chunk need a deeper RS          list than the cached chunk. */
if|if
condition|(
operator|(
name|rb
operator|->
name|chunk_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rs
operator|->
name|off
operator|==
name|rs
operator|->
name|end
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|set_cached_combined_window
argument_list|(
name|buf
argument_list|,
name|rs
argument_list|,
name|rs
operator|->
name|start
argument_list|,
name|new_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cycle pools so that we only need to hold three windows at a time. */
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|=
name|new_pool
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|window_pool
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Returns whether or not the expanded fulltext of the file is cachable  * based on its size SIZE.  The decision depends on the cache used by RB.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|fulltext_size_is_cachable
parameter_list|(
name|fs_fs_data_t
modifier|*
name|ffd
parameter_list|,
name|svn_filesize_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|<
name|APR_SIZE_MAX
operator|)
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|(
name|apr_size_t
operator|)
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close method used on streams returned by read_representation().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_contents_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|filehandle_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the next *LEN bytes of the rep and store them in *BUF. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_contents
parameter_list|(
name|struct
name|rep_read_baton
modifier|*
name|rb
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_size_t
name|copy_len
decl_stmt|,
name|remaining
init|=
operator|*
name|len
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
name|struct
name|rep_state
modifier|*
name|rs
decl_stmt|;
comment|/* Special case for when there are no delta reps, only a plain      text. */
if|if
condition|(
name|rb
operator|->
name|rs_list
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
name|copy_len
operator|=
name|remaining
expr_stmt|;
name|rs
operator|=
name|rb
operator|->
name|src_state
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|base_window
operator|!=
name|NULL
condition|)
block|{
comment|/* We got the desired rep directly from the cache.              This is where we need the pseudo rep_state created              by build_rep_list(). */
name|apr_size_t
name|offset
init|=
call|(
name|apr_size_t
call|)
argument_list|(
name|rs
operator|->
name|off
operator|-
name|rs
operator|->
name|start
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy_len
operator|+
name|offset
operator|>
name|rb
operator|->
name|base_window
operator|->
name|len
condition|)
name|copy_len
operator|=
name|offset
operator|<
name|rb
operator|->
name|base_window
operator|->
name|len
condition|?
name|rb
operator|->
name|base_window
operator|->
name|len
operator|-
name|offset
else|:
literal|0ul
expr_stmt|;
name|memcpy
argument_list|(
name|cur
argument_list|,
name|rb
operator|->
name|base_window
operator|->
name|data
operator|+
name|offset
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
operator|(
name|apr_off_t
operator|)
name|copy_len
operator|)
operator|>
name|rs
operator|->
name|end
operator|-
name|rs
operator|->
name|off
condition|)
name|copy_len
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|rs
operator|->
name|end
operator|-
name|rs
operator|->
name|off
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|file
argument_list|,
name|cur
argument_list|,
name|copy_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|->
name|off
operator|+=
name|copy_len
expr_stmt|;
operator|*
name|len
operator|=
name|copy_len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
comment|/* If we have buffered data from a previous chunk, use that. */
if|if
condition|(
name|rb
operator|->
name|buf
condition|)
block|{
comment|/* Determine how much to copy from the buffer. */
name|copy_len
operator|=
name|rb
operator|->
name|buf_len
operator|-
name|rb
operator|->
name|buf_pos
expr_stmt|;
if|if
condition|(
name|copy_len
operator|>
name|remaining
condition|)
name|copy_len
operator|=
name|remaining
expr_stmt|;
comment|/* Actually copy the data. */
name|memcpy
argument_list|(
name|cur
argument_list|,
name|rb
operator|->
name|buf
operator|+
name|rb
operator|->
name|buf_pos
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|rb
operator|->
name|buf_pos
operator|+=
name|copy_len
expr_stmt|;
name|cur
operator|+=
name|copy_len
expr_stmt|;
name|remaining
operator|-=
name|copy_len
expr_stmt|;
comment|/* If the buffer is all used up, clear it and empty the              local pool. */
if|if
condition|(
name|rb
operator|->
name|buf_pos
operator|==
name|rb
operator|->
name|buf_len
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|rb
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|svn_stringbuf_t
modifier|*
name|sbuf
init|=
name|NULL
decl_stmt|;
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
literal|0
argument_list|,
expr|struct
name|rep_state
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|off
operator|==
name|rs
operator|->
name|end
condition|)
break|break;
comment|/* Get more buffered data by evaluating a chunk. */
name|SVN_ERR
argument_list|(
name|get_combined_window
argument_list|(
operator|&
name|sbuf
argument_list|,
name|rb
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|rb
operator|->
name|buf_len
operator|=
name|sbuf
operator|->
name|len
expr_stmt|;
name|rb
operator|->
name|buf
operator|=
name|sbuf
operator|->
name|data
expr_stmt|;
name|rb
operator|->
name|buf_pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|len
operator|=
name|cur
operator|-
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* BATON is of type `rep_read_baton'; read the next *LEN bytes of the    representation and store them in *BUF.  Sum as we read and verify    the MD5 sum at the end. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
comment|/* Get the next block of data. */
name|SVN_ERR
argument_list|(
name|get_contents
argument_list|(
name|rb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|current_fulltext
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|rb
operator|->
name|current_fulltext
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
comment|/* Perform checksumming.  We want to check the checksum as soon as      the last byte of data is read, in case the caller never performs      a short read, but we don't want to finalize the MD5 context      twice. */
if|if
condition|(
operator|!
name|rb
operator|->
name|checksum_finalized
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|off
operator|+=
operator|*
name|len
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|off
operator|==
name|rb
operator|->
name|len
condition|)
block|{
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|rb
operator|->
name|checksum_finalized
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|md5_checksum
argument_list|,
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|md5_checksum
argument_list|,
name|rb
operator|->
name|md5_checksum
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|svn_checksum_mismatch_err
argument_list|(
name|rb
operator|->
name|md5_checksum
argument_list|,
name|md5_checksum
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch while reading representation"
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|rb
operator|->
name|off
operator|==
name|rb
operator|->
name|len
operator|&&
name|rb
operator|->
name|current_fulltext
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|rb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|rb
operator|->
name|fulltext_cache_key
argument_list|,
name|rb
operator|->
name|current_fulltext
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|current_fulltext
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a stream in *CONTENTS_P that will read the contents of a    representation stored at the location given by REP.  Appropriate    for any kind of immutable representation, but only for file    contents (not props or directory contents) in mutable    representations.     If REP is NULL, the representation is assumed to be empty, and the    empty stream is returned. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_representation
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rep
condition|)
block|{
operator|*
name|contents_p
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|pair_cache_key_t
name|fulltext_cache_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_filesize_t
name|len
init|=
name|rep
operator|->
name|expanded_size
condition|?
name|rep
operator|->
name|expanded_size
else|:
name|rep
operator|->
name|size
decl_stmt|;
name|struct
name|rep_read_baton
modifier|*
name|rb
decl_stmt|;
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|fulltext_cache_key
operator|.
name|second
operator|=
name|rep
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|fulltext_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
operator|&&
name|fulltext_size_is_cachable
argument_list|(
name|ffd
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|fulltext
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|fulltext
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|fulltext_cache_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
operator|*
name|contents_p
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|fulltext
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rep_read_get_baton
argument_list|(
operator|&
name|rb
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|fulltext_cache_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|svn_stream_create
argument_list|(
name|rb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_read_contents
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_read_contents_close
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|read_representation
argument_list|(
name|contents_p
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton used when reading delta windows. */
end_comment

begin_struct
struct|struct
name|delta_read_baton
block|{
name|struct
name|rep_state
modifier|*
name|rs
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements the svn_txdelta_next_window_fn_t interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_read_next_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|delta_read_baton
modifier|*
name|drb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|drb
operator|->
name|rs
operator|->
name|off
operator|==
name|drb
operator|->
name|rs
operator|->
name|end
condition|)
block|{
operator|*
name|window
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|read_delta_window
argument_list|(
name|window
argument_list|,
name|drb
operator|->
name|rs
operator|->
name|chunk_index
argument_list|,
name|drb
operator|->
name|rs
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the svn_txdelta_md5_digest_fn_t interface. */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|delta_read_md5_digest
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|delta_read_baton
modifier|*
name|drb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|drb
operator|->
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_md5
condition|)
return|return
name|drb
operator|->
name|checksum
operator|->
name|digest
return|;
else|else
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|source
parameter_list|,
name|node_revision_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|,
modifier|*
name|target_stream
decl_stmt|;
comment|/* Try a shortcut: if the target is stored as a delta against the source,      then just use that delta. */
if|if
condition|(
name|source
operator|&&
name|source
operator|->
name|data_rep
operator|&&
name|target
operator|->
name|data_rep
condition|)
block|{
name|struct
name|rep_state
modifier|*
name|rep_state
decl_stmt|;
name|struct
name|rep_args
modifier|*
name|rep_args
decl_stmt|;
comment|/* Read target's base rep if any. */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rep_state
argument_list|,
operator|&
name|rep_args
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|target
operator|->
name|data_rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If that matches source, then use this delta as is.          Note that we want an actual delta here.  E.g. a self-delta would          not be good enough. */
if|if
condition|(
name|rep_args
operator|->
name|is_delta
operator|&&
name|rep_args
operator|->
name|base_revision
operator|==
name|source
operator|->
name|data_rep
operator|->
name|revision
operator|&&
name|rep_args
operator|->
name|base_offset
operator|==
name|source
operator|->
name|data_rep
operator|->
name|offset
condition|)
block|{
comment|/* Create the delta read baton. */
name|struct
name|delta_read_baton
modifier|*
name|drb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drb
argument_list|)
argument_list|)
decl_stmt|;
name|drb
operator|->
name|rs
operator|=
name|rep_state
expr_stmt|;
name|drb
operator|->
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|target
operator|->
name|data_rep
operator|->
name|md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|stream_p
operator|=
name|svn_txdelta_stream_create
argument_list|(
name|drb
argument_list|,
name|delta_read_next_window
argument_list|,
name|delta_read_md5_digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|rep_state
operator|->
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Read both fulltexts and construct a delta. */
if|if
condition|(
name|source
condition|)
name|SVN_ERR
argument_list|(
name|read_representation
argument_list|(
operator|&
name|source_stream
argument_list|,
name|fs
argument_list|,
name|source
operator|->
name|data_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|source_stream
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_representation
argument_list|(
operator|&
name|target_stream
argument_list|,
name|fs
argument_list|,
name|target
operator|->
name|data_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because source and target stream will already verify their content,    * there is no need to do this once more.  In particular if the stream    * content is being fetched from cache. */
name|svn_txdelta2
argument_list|(
name|stream_p
argument_list|,
name|source_stream
argument_list|,
name|target_stream
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for cache_access_wrapper. Wraps the original parameters of  * svn_fs_fs__try_process_file_content().  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cache_access_wrapper_baton_t
block|{
name|svn_fs_process_contents_func_t
name|func
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
block|}
name|cache_access_wrapper_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Wrapper to translate between svn_fs_process_contents_func_t and  * svn_cache__partial_getter_func_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cache_access_wrapper
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|cache_access_wrapper_baton_t
modifier|*
name|wrapper_baton
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|wrapper_baton
operator|->
name|func
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
name|data_len
operator|-
literal|1
argument_list|,
comment|/* cache adds terminating 0 */
name|wrapper_baton
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* non-NULL value to signal the calling cache that all went well */
operator|*
name|out
operator|=
name|baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__try_process_file_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_fs_process_contents_func_t
name|processor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|noderev
operator|->
name|data_rep
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|pair_cache_key_t
name|fulltext_cache_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|fulltext_cache_key
operator|.
name|second
operator|=
name|rep
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|fulltext_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
operator|&&
name|fulltext_size_is_cachable
argument_list|(
name|ffd
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|)
condition|)
block|{
name|cache_access_wrapper_baton_t
name|wrapper_baton
decl_stmt|;
name|void
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|wrapper_baton
operator|.
name|func
operator|=
name|processor
expr_stmt|;
name|wrapper_baton
operator|.
name|baton
operator|=
name|baton
expr_stmt|;
return|return
name|svn_cache__get_partial
argument_list|(
operator|&
name|dummy
argument_list|,
name|success
argument_list|,
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|fulltext_cache_key
argument_list|,
name|cache_access_wrapper
argument_list|,
operator|&
name|wrapper_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
operator|*
name|success
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch the contents of a directory into ENTRIES.  Values are stored    as filename to string mappings; further conversion is necessary to    convert them into svn_fs_dirent_t values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir_contents
parameter_list|(
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|path_txn_node_children
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* The representation is mutable.  Read the old directory          contents from the mutable children file, followed by the          changes we've made in this transaction. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|contents
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|entries
argument_list|,
name|contents
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read_incremental
argument_list|(
name|entries
argument_list|,
name|contents
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
comment|/* use a temporary pool for temp objects.        * Also undeltify content before parsing it. Otherwise, we could only        * parse it byte-by-byte.        */
name|apr_pool_t
modifier|*
name|text_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_size_t
name|len
init|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
condition|?
operator|(
name|apr_size_t
operator|)
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
else|:
operator|(
name|apr_size_t
operator|)
name|noderev
operator|->
name|data_rep
operator|->
name|size
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|text
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|len
argument_list|,
name|text_pool
argument_list|)
decl_stmt|;
name|text
operator|->
name|len
operator|=
name|len
expr_stmt|;
comment|/* The representation is immutable.  Read it normally. */
name|SVN_ERR
argument_list|(
name|read_representation
argument_list|(
operator|&
name|contents
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|,
name|text_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|contents
argument_list|,
name|text
operator|->
name|data
argument_list|,
operator|&
name|text
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
comment|/* de-serialize hash */
name|contents
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|text
argument_list|,
name|text_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|entries
argument_list|,
name|contents
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|text_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|unparse_dir_entry
parameter_list|(
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s"
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
condition|?
name|KIND_FILE
else|:
name|KIND_DIR
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a hash ENTRIES of dirent structions, return a hash in    *STR_ENTRIES_P, that has svn_string_t as the values in the format    specified by the fs_fs directory contents file.  Perform    allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unparse_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|str_entries_p
parameter_list|,
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* For now, we use a our own hash function to ensure that we get a    * (largely) stable order when serializing the data.  It also gives    * us some performance improvement.    *    * ### TODO ###    * Use some sorted or other fixed order data container.    */
operator|*
name|str_entries_p
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new_val
operator|=
name|unparse_dir_entry
argument_list|(
name|dirent
operator|->
name|kind
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
operator|*
name|str_entries_p
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|svn_string_create
argument_list|(
name|new_val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a hash STR_ENTRIES with values as svn_string_t as specified    in an FSFS directory contents listing, return a hash of dirents in    *ENTRIES_P.  Perform allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries_p
parameter_list|,
name|apr_hash_t
modifier|*
name|str_entries
parameter_list|,
specifier|const
name|char
modifier|*
name|unparsed_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|entries_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Translate the string dir entries into real entries. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|str_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|str_val
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|last_str
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dirent
argument_list|)
argument_list|)
decl_stmt|;
name|last_str
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str_val
operator|->
name|data
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|unparsed_id
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|KIND_FILE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dirent
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|KIND_DIR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dirent
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|unparsed_id
argument_list|)
return|;
block|}
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|unparsed_id
argument_list|)
return|;
name|dirent
operator|->
name|id
operator|=
name|svn_fs_fs__id_parse
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|entries_p
argument_list|,
name|dirent
operator|->
name|name
argument_list|,
name|dirent
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the cache object in FS responsible to storing the directory  * the NODEREV. If none exists, return NULL. */
end_comment

begin_function
specifier|static
name|svn_cache__t
modifier|*
name|locate_dir_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
condition|?
name|ffd
operator|->
name|txn_dir_cache
else|:
name|ffd
operator|->
name|dir_cache
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__rep_contents_dir
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|unparsed_id
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|unparsed_entries
decl_stmt|,
modifier|*
name|parsed_entries
decl_stmt|;
comment|/* find the cache we may use */
name|svn_cache__t
modifier|*
name|cache
init|=
name|locate_dir_cache
argument_list|(
name|fs
argument_list|,
name|noderev
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|svn_boolean_t
name|found
decl_stmt|;
name|unparsed_id
operator|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|entries_p
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|unparsed_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Read in the directory hash. */
name|unparsed_entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dir_contents
argument_list|(
name|unparsed_entries
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_dir_entries
argument_list|(
operator|&
name|parsed_entries
argument_list|,
name|unparsed_entries
argument_list|,
name|unparsed_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the cache, if we are to use one. */
if|if
condition|(
name|cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|cache
argument_list|,
name|unparsed_id
argument_list|,
name|parsed_entries
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|entries_p
operator|=
name|parsed_entries
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__rep_contents_dir_entry
parameter_list|(
name|svn_fs_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
comment|/* find the cache we may use */
name|svn_cache__t
modifier|*
name|cache
init|=
name|locate_dir_cache
argument_list|(
name|fs
argument_list|,
name|noderev
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
specifier|const
name|char
modifier|*
name|unparsed_id
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
decl_stmt|;
comment|/* Cache lookup. */
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|dirent
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|unparsed_id
argument_list|,
name|svn_fs_fs__extract_dir_entry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* fetch data from disk if we did not find it in the cache */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|entry
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|entry_copy
init|=
name|NULL
decl_stmt|;
comment|/* read the dir from the file system. It will probably be put it          into the cache for faster lookup in future calls. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find desired entry and return a copy in POOL, if found */
name|entry
operator|=
name|svn_hash_gets
argument_list|(
name|entries
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|!=
name|NULL
condition|)
block|{
name|entry_copy
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry_copy
argument_list|)
argument_list|)
expr_stmt|;
name|entry_copy
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|entry_copy
operator|->
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|entry
operator|->
name|id
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|entry_copy
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
block|}
operator|*
name|dirent
operator|=
name|entry_copy
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|path_txn_node_props
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|representation_t
modifier|*
name|rep
init|=
name|noderev
operator|->
name|prop_rep
decl_stmt|;
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rep
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|properties_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|proplist_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|properties_cache
argument_list|,
operator|&
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_representation
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|prop_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|properties_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|properties_cache
argument_list|,
operator|&
name|key
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return an empty prop list if the node doesn't have any props */
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|proplist_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
operator|*
name|length
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
expr_stmt|;
else|else
operator|*
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fs_fs__noderev_same_rep_key
parameter_list|(
name|representation_t
modifier|*
name|a
parameter_list|,
name|representation_t
modifier|*
name|b
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
name|b
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|a
operator|==
name|NULL
operator|||
name|b
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|a
operator|->
name|offset
operator|!=
name|b
operator|->
name|offset
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|a
operator|->
name|revision
operator|!=
name|b
operator|->
name|revision
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|a
operator|->
name|uniquifier
operator|==
name|b
operator|->
name|uniquifier
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|a
operator|->
name|uniquifier
operator|==
name|NULL
operator|||
name|b
operator|->
name|uniquifier
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
return|return
name|strcmp
argument_list|(
name|a
operator|->
name|uniquifier
argument_list|,
name|b
operator|->
name|uniquifier
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_checksum_md5
case|:
operator|*
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|noderev
operator|->
name|data_rep
operator|->
name|md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_checksum_sha1
case|:
operator|*
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|noderev
operator|->
name|data_rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|checksum
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
operator|*
name|checksum
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|representation_t
modifier|*
name|svn_fs_fs__rep_copy
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep_new
decl_stmt|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
name|rep_new
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep_new
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rep_new
argument_list|,
name|rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep_new
argument_list|)
argument_list|)
expr_stmt|;
name|rep_new
operator|->
name|md5_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|rep
operator|->
name|md5_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rep_new
operator|->
name|sha1_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rep_new
operator|->
name|uniquifier
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|rep
operator|->
name|uniquifier
argument_list|)
expr_stmt|;
return|return
name|rep_new
return|;
block|}
end_function

begin_comment
comment|/* Merge the internal-use-only CHANGE into a hash of public-FS    svn_fs_path_change2_t CHANGES, collapsing multiple changes into a    single summarical (is that real word?) change per path.  Also keep    the COPYFROM_CACHE up to date with new adds and replaces.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fold_change
parameter_list|(
name|apr_hash_t
modifier|*
name|changes
parameter_list|,
specifier|const
name|change_t
modifier|*
name|change
parameter_list|,
name|apr_hash_t
modifier|*
name|copyfrom_cache
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|apr_hash_pool_get
argument_list|(
name|changes
argument_list|)
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|old_change
decl_stmt|,
modifier|*
name|new_change
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_size_t
name|path_len
init|=
name|strlen
argument_list|(
name|change
operator|->
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|old_change
operator|=
name|apr_hash_get
argument_list|(
name|changes
argument_list|,
name|change
operator|->
name|path
argument_list|,
name|path_len
argument_list|)
operator|)
condition|)
block|{
comment|/* This path already exists in the hash, so we have to merge          this change into the already existing one. */
comment|/* Sanity check:  only allow NULL node revision ID in the          `reset' case. */
if|if
condition|(
operator|(
operator|!
name|change
operator|->
name|noderev_id
operator|)
operator|&&
operator|(
name|change
operator|->
name|kind
operator|!=
name|svn_fs_path_change_reset
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing required node revision ID"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: we should be talking about the same node          revision ID as our last change except where the last change          was a deletion. */
if|if
condition|(
name|change
operator|->
name|noderev_id
operator|&&
operator|(
operator|!
name|svn_fs_fs__id_eq
argument_list|(
name|old_change
operator|->
name|node_rev_id
argument_list|,
name|change
operator|->
name|noderev_id
argument_list|)
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_delete
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: new node revision ID "
literal|"without delete"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: an add, replacement, or reset must be the first          thing to follow a deletion. */
if|if
condition|(
operator|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_delete
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_replace
operator|)
operator|||
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_reset
operator|)
operator|||
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_add
operator|)
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: non-add change on deleted path"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: an add can't follow anything except          a delete or reset.  */
if|if
condition|(
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_add
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_delete
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_reset
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: add change on preexisting path"
argument_list|)
argument_list|)
return|;
comment|/* Now, merge that change in. */
switch|switch
condition|(
name|change
operator|->
name|kind
condition|)
block|{
case|case
name|svn_fs_path_change_reset
case|:
comment|/* A reset here will simply remove the path change from the              hash. */
name|old_change
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
if|if
condition|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_add
condition|)
block|{
comment|/* If the path was introduced in this transaction via an                  add, and we are deleting it, just remove the path                  altogether. */
name|old_change
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* A deletion overrules all previous changes. */
name|old_change
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_delete
expr_stmt|;
name|old_change
operator|->
name|text_mod
operator|=
name|change
operator|->
name|text_mod
expr_stmt|;
name|old_change
operator|->
name|prop_mod
operator|=
name|change
operator|->
name|prop_mod
expr_stmt|;
name|old_change
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|old_change
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|svn_fs_path_change_add
case|:
case|case
name|svn_fs_path_change_replace
case|:
comment|/* An add at this point must be following a previous delete,              so treat it just like a replace. */
name|old_change
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
name|old_change
operator|->
name|node_rev_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|change
operator|->
name|noderev_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|old_change
operator|->
name|text_mod
operator|=
name|change
operator|->
name|text_mod
expr_stmt|;
name|old_change
operator|->
name|prop_mod
operator|=
name|change
operator|->
name|prop_mod
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|copyfrom_rev
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
name|old_change
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|old_change
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|old_change
operator|->
name|copyfrom_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
name|old_change
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|svn_fs_path_change_modify
case|:
default|default:
if|if
condition|(
name|change
operator|->
name|text_mod
condition|)
name|old_change
operator|->
name|text_mod
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|prop_mod
condition|)
name|old_change
operator|->
name|prop_mod
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
comment|/* Point our new_change to our (possibly modified) old_change. */
name|new_change
operator|=
name|old_change
expr_stmt|;
block|}
else|else
block|{
comment|/* This change is new to the hash, so make a new public change          structure from the internal one (in the hash's pool), and dup          the path into the hash's pool, too. */
name|new_change
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_change
argument_list|)
argument_list|)
expr_stmt|;
name|new_change
operator|->
name|node_rev_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|change
operator|->
name|noderev_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_change
operator|->
name|change_kind
operator|=
name|change
operator|->
name|kind
expr_stmt|;
name|new_change
operator|->
name|text_mod
operator|=
name|change
operator|->
name|text_mod
expr_stmt|;
name|new_change
operator|->
name|prop_mod
operator|=
name|change
operator|->
name|prop_mod
expr_stmt|;
comment|/* In FSFS, copyfrom_known is *always* true, since we've always        * stored copyfroms in changed paths lists. */
name|new_change
operator|->
name|copyfrom_known
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|copyfrom_rev
operator|!=
name|SVN_INVALID_REVNUM
condition|)
block|{
name|new_change
operator|->
name|copyfrom_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
name|new_change
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_change
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|new_change
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_change
condition|)
name|new_change
operator|->
name|node_kind
operator|=
name|change
operator|->
name|node_kind
expr_stmt|;
comment|/* Add (or update) this path.       Note: this key might already be present, and it would be nice to      re-use its value, but there is no way to fetch it. The API makes no      guarantees that this (new) key will not be retained. Thus, we (again)      copy the key into the target pool to ensure a proper lifetime.  */
name|path
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|change
operator|->
name|path
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changes
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|,
name|new_change
argument_list|)
expr_stmt|;
comment|/* Update the copyfrom cache, if any. */
if|if
condition|(
name|copyfrom_cache
condition|)
block|{
name|apr_pool_t
modifier|*
name|copyfrom_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|copyfrom_cache
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_string
init|=
name|NULL
decl_stmt|,
modifier|*
name|copyfrom_key
init|=
name|path
decl_stmt|;
if|if
condition|(
name|new_change
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|new_change
operator|->
name|copyfrom_rev
argument_list|)
condition|)
name|copyfrom_string
operator|=
name|apr_psprintf
argument_list|(
name|copyfrom_pool
argument_list|,
literal|"%ld %s"
argument_list|,
name|new_change
operator|->
name|copyfrom_rev
argument_list|,
name|new_change
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
else|else
name|copyfrom_string
operator|=
literal|""
expr_stmt|;
block|}
comment|/* We need to allocate a copy of the key in the copyfrom_pool if        * we're not doing a deletion and if it isn't already there. */
if|if
condition|(
name|copyfrom_string
operator|&&
operator|(
operator|!
name|apr_hash_count
argument_list|(
name|copyfrom_cache
argument_list|)
operator|||
operator|!
name|apr_hash_get
argument_list|(
name|copyfrom_cache
argument_list|,
name|copyfrom_key
argument_list|,
name|path_len
argument_list|)
operator|)
condition|)
name|copyfrom_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|copyfrom_pool
argument_list|,
name|copyfrom_key
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|copyfrom_cache
argument_list|,
name|copyfrom_key
argument_list|,
name|path_len
argument_list|,
name|copyfrom_string
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The 256 is an arbitrary size large enough to hold the node id and the  * various flags. */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANGE_LINE_LEN
value|FSFS_MAX_PATH_LEN + 256
end_define

begin_comment
comment|/* Read the next entry in the changes record from file FILE and store    the resulting change in *CHANGE_P.  If there is no next record,    store NULL there.  Perform all allocations from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_change
parameter_list|(
name|change_t
modifier|*
modifier|*
name|change_p
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|buf
index|[
name|MAX_CHANGE_LINE_LEN
index|]
decl_stmt|;
name|apr_size_t
name|len
init|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
decl_stmt|;
name|change_t
modifier|*
name|change
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|last_str
init|=
name|buf
decl_stmt|,
modifier|*
name|kind_str
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Default return value. */
operator|*
name|change_p
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|svn_io_read_length_line
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check for a blank line. */
if|if
condition|(
name|err
operator|||
operator|(
name|len
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EOF
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|!
name|err
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|change
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|change
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the node-id of the change. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
name|change
operator|->
name|noderev_id
operator|=
name|svn_fs_fs__id_parse
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|noderev_id
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
comment|/* Get the change type. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
comment|/* Don't bother to check the format number before looking for    * node-kinds: just read them if you find them. */
name|change
operator|->
name|node_kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|kind_str
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind_str
condition|)
block|{
comment|/* Cap off the end of "str" (the action). */
operator|*
name|kind_str
operator|=
literal|'\0'
expr_stmt|;
name|kind_str
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|kind_str
argument_list|,
name|KIND_FILE
argument_list|)
operator|==
literal|0
condition|)
name|change
operator|->
name|node_kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|kind_str
argument_list|,
name|KIND_DIR
argument_list|)
operator|==
literal|0
condition|)
name|change
operator|->
name|node_kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_MODIFY
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|kind
operator|=
name|svn_fs_path_change_modify
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_ADD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|kind
operator|=
name|svn_fs_path_change_add
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_DELETE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|kind
operator|=
name|svn_fs_path_change_delete
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_REPLACE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_RESET
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|kind
operator|=
name|svn_fs_path_change_reset
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change kind in rev file"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get the text-mod flag. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_TRUE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|text_mod
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|text_mod
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid text-mod flag in rev-file"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get the prop-mod flag. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_TRUE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|prop_mod
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|prop_mod
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid prop-mod flag in rev-file"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get the changed path. */
name|change
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
comment|/* Read the next line, the copyfrom line. */
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|change
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|change
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|last_str
operator|=
name|buf
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|last_str
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
name|change
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
block|}
operator|*
name|change_p
operator|=
name|change
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Examine all the changed path entries in CHANGES and store them in    *CHANGED_PATHS.  Folding is done to remove redundant or unnecessary    *data.  Store a hash of paths to copyfrom "REV PATH" strings in    COPYFROM_HASH if it is non-NULL.  If PREFOLDED is true, assume that    the changed-path entries have already been folded (by    write_final_changed_path_info) and may be out of order, so we shouldn't    remove children of replaced or deleted directories.  Do all    allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_changes
parameter_list|(
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_hash_t
modifier|*
name|copyfrom_cache
parameter_list|,
name|apr_array_header_t
modifier|*
name|changes
parameter_list|,
name|svn_boolean_t
name|prefolded
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Read in the changes one by one, folding them into our local hash      as necessary. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changes
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|change_t
modifier|*
name|change
init|=
name|APR_ARRAY_IDX
argument_list|(
name|changes
argument_list|,
name|i
argument_list|,
name|change_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|fold_change
argument_list|(
name|changed_paths
argument_list|,
name|change
argument_list|,
name|copyfrom_cache
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, if our change was a deletion or replacement, we have to          blow away any changes thus far on paths that are (or, were)          children of this path.          ### i won't bother with another iteration pool here -- at          most we talking about a few extra dups of paths into what          is already a temporary subpool.       */
if|if
condition|(
operator|(
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_delete
operator|)
operator|||
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_replace
operator|)
operator|)
operator|&&
operator|!
name|prefolded
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* a potential child path must contain at least 2 more chars              (the path separator plus at least one char for the name).              Also, we should not assume that all paths have been normalized              i.e. some might have trailing path separators.           */
name|apr_ssize_t
name|change_path_len
init|=
name|strlen
argument_list|(
name|change
operator|->
name|path
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|min_child_len
init|=
name|change_path_len
operator|==
literal|0
condition|?
literal|1
else|:
name|change
operator|->
name|path
index|[
name|change_path_len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|?
name|change_path_len
operator|+
literal|1
else|:
name|change_path_len
operator|+
literal|2
decl_stmt|;
comment|/* CAUTION: This is the inner loop of an O(n^2) algorithm.              The number of changes to process may be>> 1000.              Therefore, keep the inner loop as tight as possible.           */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|changed_paths
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
comment|/* KEY is the path. */
specifier|const
name|void
modifier|*
name|path
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we come across a child of our path, remove it.                  Call svn_dirent_is_child only if there is a chance that                  this is actually a sub-path.                */
if|if
condition|(
name|klen
operator|>=
name|min_child_len
operator|&&
name|svn_dirent_is_child
argument_list|(
name|change
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
condition|)
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Clear the per-iteration subpool. */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy the per-iteration subpool. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch all the changes from FILE and store them in *CHANGES.  Do all    allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_all_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|change_t
modifier|*
name|change
decl_stmt|;
comment|/* pre-allocate enough room for most change lists      (will be auto-expanded as necessary) */
operator|*
name|changes
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|30
argument_list|,
sizeof|sizeof
argument_list|(
name|change_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_change
argument_list|(
operator|&
name|change
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|change
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|changes
argument_list|,
name|change_t
operator|*
argument_list|)
operator|=
name|change
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_change
argument_list|(
operator|&
name|change
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_changes_fetch
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changed_paths_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_hash_t
modifier|*
name|changed_paths
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changes
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path_txn_changes
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_all_changes
argument_list|(
operator|&
name|changes
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|process_changes
argument_list|(
name|changed_paths
argument_list|,
name|NULL
argument_list|,
name|changes
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|changed_paths_p
operator|=
name|changed_paths
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch the list of change in revision REV in FS and return it in *CHANGES.  * Allocate the result in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|changes_offset
decl_stmt|;
name|apr_file_t
modifier|*
name|revision_file
decl_stmt|;
name|svn_boolean_t
name|found
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* try cache lookup first */
if|if
condition|(
name|ffd
operator|->
name|changes_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|changes
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* read changes from revision file */
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_pack_or_rev_file
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_root_changes_offset
argument_list|(
name|NULL
argument_list|,
operator|&
name|changes_offset
argument_list|,
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|revision_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|changes_offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_all_changes
argument_list|(
name|changes
argument_list|,
name|revision_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|revision_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cache for future reference */
if|if
condition|(
name|ffd
operator|->
name|changes_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|rev
argument_list|,
operator|*
name|changes
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__paths_changed
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changed_paths_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|copyfrom_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changes
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_changes
argument_list|(
operator|&
name|changes
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|changed_paths
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|process_changes
argument_list|(
name|changed_paths
argument_list|,
name|copyfrom_cache
argument_list|,
name|changes
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|changed_paths_p
operator|=
name|changed_paths
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy a revision node-rev SRC into the current transaction TXN_ID in    the filesystem FS.  This is only used to create the root of a transaction.    Allocations are from POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_new_txn_noderev_from_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_fs_id_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id
decl_stmt|,
modifier|*
name|copy_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copying from transactions not allowed"
argument_list|)
argument_list|)
return|;
name|noderev
operator|->
name|predecessor_id
operator|=
name|noderev
operator|->
name|id
expr_stmt|;
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* For the transaction root, the copyroot never changes. */
name|node_id
operator|=
name|svn_fs_fs__id_node_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
name|node_id
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A structure used by get_and_increment_txn_key_body(). */
end_comment

begin_struct
struct|struct
name|get_and_increment_txn_key_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|char
modifier|*
name|txn_id
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback used in the implementation of create_txn_dir().  This gets    the current base 36 value in PATH_TXN_CURRENT and increments it.    It returns the original value by the baton. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_and_increment_txn_key_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_and_increment_txn_key_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_current_filename
init|=
name|path_txn_current
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_filename
decl_stmt|;
name|char
name|next_txn_id
index|[
name|MAX_KEY_SIZE
operator|+
literal|3
index|]
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_content
argument_list|(
operator|&
name|buf
argument_list|,
name|txn_current_filename
argument_list|,
name|cb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove trailing newlines */
name|svn_stringbuf_strip_whitespace
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|cb
operator|->
name|txn_id
operator|=
name|buf
operator|->
name|data
expr_stmt|;
name|len
operator|=
name|buf
operator|->
name|len
expr_stmt|;
comment|/* Increment the key and add a trailing \n to the string so the      txn-current file has a newline in it. */
name|svn_fs_fs__next_key
argument_list|(
name|cb
operator|->
name|txn_id
argument_list|,
operator|&
name|len
argument_list|,
name|next_txn_id
argument_list|)
expr_stmt|;
name|next_txn_id
index|[
name|len
index|]
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|len
expr_stmt|;
name|next_txn_id
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|tmp_filename
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|txn_current_filename
argument_list|,
name|pool
argument_list|)
argument_list|,
name|next_txn_id
argument_list|,
name|len
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|move_into_place
argument_list|(
name|tmp_filename
argument_list|,
name|txn_current_filename
argument_list|,
name|txn_current_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a unique directory for a transaction in FS based on revision    REV.  Return the ID for this transaction in *ID_P.  Use a sequence    value in the transaction ID to prevent reuse of transaction IDs. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_txn_dir
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_and_increment_txn_key_baton
name|cb
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_dir
decl_stmt|;
comment|/* Get the current transaction sequence value, which is a base-36      number, from the txn-current file, and write an      incremented value back out to the file.  Place the revision      number the transaction is based off into the transaction id. */
name|cb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|cb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|SVN_ERR
argument_list|(
name|with_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|get_and_increment_txn_key_body
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld-%s"
argument_list|,
name|rev
argument_list|,
name|cb
operator|.
name|txn_id
argument_list|)
expr_stmt|;
name|txn_dir
operator|=
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXNS_DIR
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
operator|*
name|id_p
argument_list|,
name|PATH_EXT_TXN
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_io_dir_make
argument_list|(
name|txn_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a unique directory for a transaction in FS based on revision    REV.  Return the ID for this transaction in *ID_P.  This    implementation is used in svn 1.4 and earlier repositories and is    kept in 1.5 and greater to support the --pre-1.4-compatible and    --pre-1.5-compatible repository creation options.  Reused    transaction IDs are possible with this implementation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_txn_dir_pre_1_5
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_path
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
comment|/* Try to create directories named "<txndir>/<rev>-<uniqueifier>.txn". */
name|prefix
operator|=
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXNS_DIR
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|99999
condition|;
name|i
operator|++
control|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|unique_path
operator|=
name|apr_psprintf
argument_list|(
name|subpool
argument_list|,
literal|"%s-%u"
name|PATH_EXT_TXN
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_dir_make
argument_list|(
name|unique_path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
comment|/* We succeeded.  Return the basename minus the ".txn" extension. */
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_dirent_basename
argument_list|(
name|unique_path
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
operator|*
name|id_p
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|PATH_EXT_TXN
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to create transaction directory "
literal|"in '%s' for revision %ld"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|;
name|txn
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the txn_id. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|create_txn_dir
argument_list|(
operator|&
name|txn
operator|->
name|id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|create_txn_dir_pre_1_5
argument_list|(
operator|&
name|txn
operator|->
name|id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|txn
operator|->
name|base_rev
operator|=
name|rev
expr_stmt|;
name|txn
operator|->
name|vtable
operator|=
operator|&
name|txn_vtable
expr_stmt|;
operator|*
name|txn_p
operator|=
name|txn
expr_stmt|;
comment|/* Create a new root node for this transaction. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rev_get_root
argument_list|(
operator|&
name|root_id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_new_txn_noderev_from_rev
argument_list|(
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an empty rev file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_txn_proto_rev
argument_list|(
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an empty rev-lock file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_txn_proto_rev_lock
argument_list|(
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an empty changes file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_txn_changes
argument_list|(
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the next-ids file. */
return|return
name|svn_io_file_create
argument_list|(
name|path_txn_next_ids
argument_list|(
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0 0\n"
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Store the property list for transaction TXN_ID in PROPLIST.    Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_txn_proplist
parameter_list|(
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Check for issue #3696. (When we find and fix the cause, we can change    * this to an assertion.) */
if|if
condition|(
name|txn_id
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Internal error: a null transaction id was "
literal|"passed to get_txn_proplist()"
argument_list|)
argument_list|)
return|;
comment|/* Open the transaction properties file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|path_txn_props
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in the property list. */
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__change_txn_prop
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|props
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_prop_t
name|prop
decl_stmt|;
name|prop
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|prop
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
return|return
name|svn_fs_fs__change_txn_props
argument_list|(
name|txn
argument_list|,
name|props
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__change_txn_props
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|txn_prop_filename
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_hash_t
modifier|*
name|txn_prop
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|get_txn_proplist
argument_list|(
name|txn_prop
argument_list|,
name|txn
operator|->
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Here - and here only - we need to deal with the possibility that the      transaction property file doesn't yet exist.  The rest of the      implementation assumes that the file exists, but we're called to set the      initial transaction properties as the transaction is being created. */
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|props
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|txn_prop
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Create a new version of the file and write out the new props. */
comment|/* Open the transaction properties file. */
name|buf
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|1024
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|buf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|txn_prop
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|txn_prop_filename
argument_list|,
name|path_txn_dir
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_rename
argument_list|(
name|txn_prop_filename
argument_list|,
name|path_txn_props
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_txn
parameter_list|(
name|transaction_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|transaction_t
modifier|*
name|txn
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|;
name|txn
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_txn_proplist
argument_list|(
name|txn
operator|->
name|proplist
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|root_id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
literal|"0"
argument_list|,
literal|"0"
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|root_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|txn
operator|->
name|base_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|txn
operator|->
name|copies
operator|=
name|NULL
expr_stmt|;
operator|*
name|txn_p
operator|=
name|txn
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out the currently available next node_id NODE_ID and copy_id    COPY_ID for transaction TXN_ID in filesystem FS.  The next node-id is    used both for creating new unique nodes for the given transaction, as    well as uniquifying representations.  Perform temporary allocations in    POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_next_ids
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|char
modifier|*
name|node_id
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stream_t
modifier|*
name|out_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path_txn_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_TRUNCATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|out_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|out_stream
argument_list|,
name|pool
argument_list|,
literal|"%s %s\n"
argument_list|,
name|node_id
argument_list|,
name|copy_id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|out_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find out what the next unique node-id and copy-id are for    transaction TXN_ID in filesystem FS.  Store the results in *NODE_ID    and *COPY_ID.  The next node-id is used both for creating new unique    nodes for the given transaction, as well as uniquifying representations.    Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_next_ids
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|node_id
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|copy_id
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|char
name|buf
index|[
name|MAX_KEY_SIZE
operator|*
literal|2
operator|+
literal|3
index|]
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|last_str
init|=
name|buf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path_txn_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
operator|&
name|limit
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse this into two separate strings. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"next-id file corrupt"
argument_list|)
argument_list|)
return|;
operator|*
name|node_id
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"next-id file corrupt"
argument_list|)
argument_list|)
return|;
operator|*
name|copy_id
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get a new and unique to this transaction node-id for transaction    TXN_ID in filesystem FS.  Store the new node-id in *NODE_ID_P.    Node-ids are guaranteed to be unique to this transction, but may    not necessarily be sequential.  Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_new_txn_node_id
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|node_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cur_node_id
decl_stmt|,
modifier|*
name|cur_copy_id
decl_stmt|;
name|char
modifier|*
name|node_id
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* First read in the current next-ids file. */
name|SVN_ERR
argument_list|(
name|read_next_ids
argument_list|(
operator|&
name|cur_node_id
argument_list|,
operator|&
name|cur_copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|strlen
argument_list|(
name|cur_node_id
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cur_node_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__next_key
argument_list|(
name|cur_node_id
argument_list|,
operator|&
name|len
argument_list|,
name|node_id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|node_id
argument_list|,
name|cur_copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|node_id_p
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"_"
argument_list|,
name|cur_node_id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create_node
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|node_id
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
comment|/* Get a new node-id for this node. */
name|SVN_ERR
argument_list|(
name|get_new_txn_node_id
argument_list|(
operator|&
name|node_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
name|node_id
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__purge_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Remove the shared transaction object associated with this transaction. */
name|SVN_ERR
argument_list|(
name|purge_shared_txn
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the directory associated with this transaction. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
block|{
comment|/* Delete protorev and its lock, which aren't in the txn          directory.  It's OK if they don't exist (for example, if this          is post-commit and the proto-rev has been moved into          place). */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path_txn_proto_rev
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path_txn_proto_rev_lock
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__abort_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, purge the transaction. */
name|SVN_ERR_W
argument_list|(
name|svn_fs_fs__purge_txn
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Transaction '%s' cleanup failed"
argument_list|)
argument_list|,
name|txn
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_entry
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|node_revision_t
modifier|*
name|parent_noderev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|parent_noderev
operator|->
name|data_rep
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|path_txn_node_children
argument_list|(
name|fs
argument_list|,
name|parent_noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stream_t
modifier|*
name|out
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rep
operator|||
operator|!
name|rep
operator|->
name|txn_id
condition|)
block|{
specifier|const
name|char
modifier|*
name|unique_suffix
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
comment|/* Before we can modify the directory, we need to dump its old          contents into a mutable representation file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|parent_noderev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|unparse_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|entries
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|entries
argument_list|,
name|out
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Mark the node-rev's data rep as mutable. */
name|rep
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|rep
operator|->
name|txn_id
operator|=
name|txn_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_new_txn_node_id
argument_list|(
operator|&
name|unique_suffix
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|uniquifier
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s/%s"
argument_list|,
name|txn_id
argument_list|,
name|unique_suffix
argument_list|)
expr_stmt|;
name|parent_noderev
operator|->
name|data_rep
operator|=
name|rep
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|parent_noderev
operator|->
name|id
argument_list|,
name|parent_noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The directory rep is already mutable, so just open it for append. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_APPEND
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* if we have a directory cache for this transaction, update it */
if|if
condition|(
name|ffd
operator|->
name|txn_dir_cache
condition|)
block|{
comment|/* build parameters: (name, new entry) pair */
specifier|const
name|char
modifier|*
name|key
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|parent_noderev
operator|->
name|id
argument_list|,
name|subpool
argument_list|)
operator|->
name|data
decl_stmt|;
name|replace_baton_t
name|baton
decl_stmt|;
name|baton
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|baton
operator|.
name|new_entry
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
operator|.
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|->
name|id
operator|=
name|id
expr_stmt|;
block|}
comment|/* actually update the cached directory (if cached) */
name|SVN_ERR
argument_list|(
name|svn_cache__set_partial
argument_list|(
name|ffd
operator|->
name|txn_dir_cache
argument_list|,
name|key
argument_list|,
name|svn_fs_fs__replace_dir_entry
argument_list|,
operator|&
name|baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Append an incremental hash entry for the entry change. */
if|if
condition|(
name|id
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|unparse_dir_entry
argument_list|(
name|kind
argument_list|,
name|id
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|out
argument_list|,
name|subpool
argument_list|,
literal|"K %"
name|APR_SIZE_T_FMT
literal|"\n%s\n"
literal|"V %"
name|APR_SIZE_T_FMT
literal|"\n%s\n"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|out
argument_list|,
name|subpool
argument_list|,
literal|"D %"
name|APR_SIZE_T_FMT
literal|"\n%s\n"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write a single change entry, path PATH, change CHANGE, and copyfrom    string COPYFROM, into the file specified by FILE.  Only include the    node kind field if INCLUDE_NODE_KIND is true.  All temporary    allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_change_entry
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_path_change2_t
modifier|*
name|change
parameter_list|,
name|svn_boolean_t
name|include_node_kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|idstr
decl_stmt|,
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|change_string
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|kind_string
init|=
literal|""
decl_stmt|;
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_modify
case|:
name|change_string
operator|=
name|ACTION_MODIFY
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_add
case|:
name|change_string
operator|=
name|ACTION_ADD
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
name|change_string
operator|=
name|ACTION_DELETE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_replace
case|:
name|change_string
operator|=
name|ACTION_REPLACE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_reset
case|:
name|change_string
operator|=
name|ACTION_RESET
expr_stmt|;
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change type %d"
argument_list|)
argument_list|,
name|change
operator|->
name|change_kind
argument_list|)
return|;
block|}
if|if
condition|(
name|change
operator|->
name|node_rev_id
condition|)
name|idstr
operator|=
name|svn_fs_fs__id_unparse
argument_list|(
name|change
operator|->
name|node_rev_id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
expr_stmt|;
else|else
name|idstr
operator|=
name|ACTION_RESET
expr_stmt|;
if|if
condition|(
name|include_node_kind
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
operator|||
name|change
operator|->
name|node_kind
operator|==
name|svn_node_file
argument_list|)
expr_stmt|;
name|kind_string
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"-%s"
argument_list|,
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|?
name|KIND_DIR
else|:
name|KIND_FILE
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s%s %s %s %s\n"
argument_list|,
name|idstr
argument_list|,
name|change_string
argument_list|,
name|kind_string
argument_list|,
name|change
operator|->
name|text_mod
condition|?
name|FLAG_TRUE
else|:
name|FLAG_FALSE
argument_list|,
name|change
operator|->
name|prop_mod
condition|?
name|FLAG_TRUE
else|:
name|FLAG_FALSE
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|change
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|buf
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld %s"
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__add_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_fs_path_change_kind_t
name|change_kind
parameter_list|,
name|svn_boolean_t
name|text_mod
parameter_list|,
name|svn_boolean_t
name|prop_mod
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path_txn_changes
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_APPEND
operator||
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|=
name|svn_fs__path_change_create_internal
argument_list|(
name|id
argument_list|,
name|change_kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|change
operator|->
name|text_mod
operator|=
name|text_mod
expr_stmt|;
name|change
operator|->
name|prop_mod
operator|=
name|prop_mod
expr_stmt|;
name|change
operator|->
name|node_kind
operator|=
name|node_kind
expr_stmt|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|change
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|copyfrom_path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_change_entry
argument_list|(
name|file
argument_list|,
name|path
argument_list|,
name|change
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This baton is used by the representation writing streams.  It keeps    track of the checksum information as well as the total size of the    representation so far. */
end_comment

begin_struct
struct|struct
name|rep_write_baton
block|{
comment|/* The FS we are writing to. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* Actual file to which we are writing. */
name|svn_stream_t
modifier|*
name|rep_stream
decl_stmt|;
comment|/* A stream from the delta combiner.  Data written here gets      deltified, then eventually written to rep_stream. */
name|svn_stream_t
modifier|*
name|delta_stream
decl_stmt|;
comment|/* Where is this representation header stored. */
name|apr_off_t
name|rep_offset
decl_stmt|;
comment|/* Start of the actual data. */
name|apr_off_t
name|delta_start
decl_stmt|;
comment|/* How many bytes have been written to this rep already. */
name|svn_filesize_t
name|rep_size
decl_stmt|;
comment|/* The node revision for which we're writing out info. */
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Actual output file. */
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* Lock 'cookie' used to unlock the output file once we've finished      writing to it. */
name|void
modifier|*
name|lockcookie
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|sha1_checksum_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_pool_t
modifier|*
name|parent_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Handler for the write method of the representation writable stream.    BATON is a rep_write_baton, DATA is the data to write, and *LEN is    the length of this data. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|b
operator|->
name|md5_checksum_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|b
operator|->
name|sha1_checksum_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|rep_size
operator|+=
operator|*
name|len
expr_stmt|;
comment|/* If we are writing a delta, use that stream. */
if|if
condition|(
name|b
operator|->
name|delta_stream
condition|)
return|return
name|svn_stream_write
argument_list|(
name|b
operator|->
name|delta_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|svn_stream_write
argument_list|(
name|b
operator|->
name|rep_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a node-revision NODEREV in filesystem FS, return the    representation in *REP to use as the base for a text representation    delta if PROPS is FALSE.  If PROPS has been set, a suitable props    base representation will be returned.  Perform temporary allocations    in *POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|choose_delta_base
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_boolean_t
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|count
decl_stmt|;
name|int
name|walk
decl_stmt|;
name|node_revision_t
modifier|*
name|base
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|maybe_shared_rep
init|=
name|FALSE
decl_stmt|;
comment|/* If we have no predecessors, then use the empty stream as a      base. */
if|if
condition|(
operator|!
name|noderev
operator|->
name|predecessor_count
condition|)
block|{
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Flip the rightmost '1' bit of the predecessor count to determine      which file rev (counting from 0) we want to use.  (To see why      count& (count - 1) unsets the rightmost set bit, think about how      you decrement a binary number.) */
name|count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
name|count
operator|=
name|count
operator|&
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* We use skip delta for limiting the number of delta operations      along very long node histories.  Close to HEAD however, we create      a linear history to minimize delta size.  */
name|walk
operator|=
name|noderev
operator|->
name|predecessor_count
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|walk
operator|<
operator|(
name|int
operator|)
name|ffd
operator|->
name|max_linear_deltification
condition|)
name|count
operator|=
name|noderev
operator|->
name|predecessor_count
operator|-
literal|1
expr_stmt|;
comment|/* Finding the delta base over a very long distance can become extremely      expensive for very deep histories, possibly causing client timeouts etc.      OTOH, this is a rare operation and its gains are minimal. Lets simply      start deltification anew close every other 1000 changes or so.  */
if|if
condition|(
name|walk
operator|>
operator|(
name|int
operator|)
name|ffd
operator|->
name|max_deltification_walk
condition|)
block|{
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Walk back a number of predecessors equal to the difference      between count and the original predecessor count.  (For example,      if noderev has ten predecessors and we want the eighth file rev,      walk back two predecessors.) */
name|base
operator|=
name|noderev
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|++
operator|)
operator|<
name|noderev
operator|->
name|predecessor_count
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|base
argument_list|,
name|fs
argument_list|,
name|base
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is a shared rep along the way, we need to limit the        * length of the deltification chain.        *        * Please note that copied nodes - such as branch directories - will        * look the same (false positive) while reps shared within the same        * revision will not be caught (false negative).        */
if|if
condition|(
name|props
condition|)
block|{
if|if
condition|(
name|base
operator|->
name|prop_rep
operator|&&
name|svn_fs_fs__id_rev
argument_list|(
name|base
operator|->
name|id
argument_list|)
operator|>
name|base
operator|->
name|prop_rep
operator|->
name|revision
condition|)
name|maybe_shared_rep
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|base
operator|->
name|data_rep
operator|&&
name|svn_fs_fs__id_rev
argument_list|(
name|base
operator|->
name|id
argument_list|)
operator|>
name|base
operator|->
name|data_rep
operator|->
name|revision
condition|)
name|maybe_shared_rep
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* return a suitable base representation */
operator|*
name|rep
operator|=
name|props
condition|?
name|base
operator|->
name|prop_rep
else|:
name|base
operator|->
name|data_rep
expr_stmt|;
comment|/* if we encountered a shared rep, it's parent chain may be different    * from the node-rev parent chain. */
if|if
condition|(
operator|*
name|rep
operator|&&
name|maybe_shared_rep
condition|)
block|{
comment|/* Check whether the length of the deltification chain is acceptable.        * Otherwise, shared reps may form a non-skipping delta chain in        * extreme cases. */
name|apr_pool_t
modifier|*
name|sub_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|representation_t
name|base_rep
init|=
operator|*
operator|*
name|rep
decl_stmt|;
comment|/* Some reasonable limit, depending on how acceptable longer linear        * chains are in this repo.  Also, allow for some minimal chain. */
name|int
name|max_chain_length
init|=
literal|2
operator|*
operator|(
name|int
operator|)
name|ffd
operator|->
name|max_linear_deltification
operator|+
literal|2
decl_stmt|;
comment|/* re-use open files between iterations */
name|svn_revnum_t
name|rev_hint
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_file_t
modifier|*
name|file_hint
init|=
name|NULL
decl_stmt|;
comment|/* follow the delta chain towards the end but for at most        * MAX_CHAIN_LENGTH steps. */
for|for
control|(
init|;
name|max_chain_length
condition|;
operator|--
name|max_chain_length
control|)
block|{
name|struct
name|rep_state
modifier|*
name|rep_state
decl_stmt|;
name|struct
name|rep_args
modifier|*
name|rep_args
decl_stmt|;
name|SVN_ERR
argument_list|(
name|create_rep_state_body
argument_list|(
operator|&
name|rep_state
argument_list|,
operator|&
name|rep_args
argument_list|,
operator|&
name|file_hint
argument_list|,
operator|&
name|rev_hint
argument_list|,
operator|&
name|base_rep
argument_list|,
name|fs
argument_list|,
name|sub_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rep_args
operator|->
name|is_delta
operator|||
operator|!
name|rep_args
operator|->
name|base_revision
condition|)
break|break;
name|base_rep
operator|.
name|revision
operator|=
name|rep_args
operator|->
name|base_revision
expr_stmt|;
name|base_rep
operator|.
name|offset
operator|=
name|rep_args
operator|->
name|base_offset
expr_stmt|;
name|base_rep
operator|.
name|size
operator|=
name|rep_args
operator|->
name|base_length
expr_stmt|;
name|base_rep
operator|.
name|txn_id
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* start new delta chain if the current one has grown too long */
if|if
condition|(
name|max_chain_length
operator|==
literal|0
condition|)
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|sub_pool
argument_list|)
expr_stmt|;
block|}
comment|/* verify that the reps don't form a degenerated '*/
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Something went wrong and the pool for the rep write is being    cleared before we've finished writing the rep.  So we need    to remove the rep from the protorevfile and we need to unlock    the protorevfile. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|rep_write_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|svn_fs_fs__id_txn_id
argument_list|(
name|b
operator|->
name|noderev
operator|->
name|id
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Truncate and close the protorevfile. */
name|err
operator|=
name|svn_io_file_trunc
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|rep_offset
argument_list|,
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove our lock regardless of any preceeding errors so that the      being_written flag is always removed and stays consistent with the      file lock which will be removed no matter what since the pool is      going away. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|unlock_proto_rev
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|b
operator|->
name|lockcookie
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|rc
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Get a rep_write_baton and store it in *WB_P for the representation    indicated by NODEREV in filesystem FS.  Perform allocations in    POOL.  Only appropriate for file contents, not for props or    directory contents. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_get_baton
parameter_list|(
name|struct
name|rep_write_baton
modifier|*
modifier|*
name|wb_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|representation_t
modifier|*
name|base_rep
decl_stmt|;
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|svn_txdelta_window_handler_t
name|wh
decl_stmt|;
name|void
modifier|*
name|whb
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|diff_version
init|=
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_SVNDIFF1_FORMAT
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|b
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|sha1_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|->
name|parent_pool
operator|=
name|pool
expr_stmt|;
name|b
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|rep_size
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|noderev
operator|=
name|noderev
expr_stmt|;
comment|/* Open the prototype rev file and seek to its end. */
name|SVN_ERR
argument_list|(
name|get_writable_proto_rev
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|b
operator|->
name|lockcookie
argument_list|,
name|fs
argument_list|,
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|b
operator|->
name|rep_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|b
operator|->
name|rep_offset
argument_list|,
name|file
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the base for this delta. */
name|SVN_ERR
argument_list|(
name|choose_delta_base
argument_list|(
operator|&
name|base_rep
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_representation
argument_list|(
operator|&
name|source
argument_list|,
name|fs
argument_list|,
name|base_rep
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the rep header. */
if|if
condition|(
name|base_rep
condition|)
block|{
name|header
operator|=
name|apr_psprintf
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|REP_DELTA
literal|" %ld %"
name|APR_OFF_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|"\n"
argument_list|,
name|base_rep
operator|->
name|revision
argument_list|,
name|base_rep
operator|->
name|offset
argument_list|,
name|base_rep
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|=
name|REP_DELTA
literal|"\n"
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|header
argument_list|,
name|strlen
argument_list|(
name|header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now determine the offset of the actual svndiff data. */
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|b
operator|->
name|delta_start
argument_list|,
name|file
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup in case something goes wrong. */
name|apr_pool_cleanup_register
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|b
argument_list|,
name|rep_write_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Prepare to write the svndiff data. */
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|wh
argument_list|,
operator|&
name|whb
argument_list|,
name|b
operator|->
name|rep_stream
argument_list|,
name|diff_version
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|delta_stream
operator|=
name|svn_txdelta_target_push
argument_list|(
name|wh
argument_list|,
name|whb
argument_list|,
name|source
argument_list|,
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|wb_p
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For the hash REP->SHA1, try to find an already existing representation    in FS and return it in *OUT_REP.  If no such representation exists or    if rep sharing has been disabled for FS, NULL will be returned.  Since    there may be new duplicate representations within the same uncommitted    revision, those can be passed in REPS_HASH (maps a sha1 digest onto    representation_t*), otherwise pass in NULL for REPS_HASH.    POOL will be used for allocations. The lifetime of the returned rep is    limited by both, POOL and REP lifetime.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_shared_rep
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|old_rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Return NULL, if rep sharing has been disabled. */
operator|*
name|old_rep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out.  Start with the hash lookup      because it is cheepest. */
if|if
condition|(
name|reps_hash
condition|)
operator|*
name|old_rep
operator|=
name|apr_hash_get
argument_list|(
name|reps_hash
argument_list|,
name|rep
operator|->
name|sha1_checksum
operator|->
name|digest
argument_list|,
name|APR_SHA1_DIGESTSIZE
argument_list|)
expr_stmt|;
comment|/* If we haven't found anything yet, try harder and consult our DB. */
if|if
condition|(
operator|*
name|old_rep
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|svn_fs_fs__get_rep_reference
argument_list|(
name|old_rep
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ### Other error codes that we shouldn't mask out? */
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
block|{
if|if
condition|(
operator|*
name|old_rep
condition|)
name|SVN_ERR
argument_list|(
name|verify_walker
argument_list|(
operator|*
name|old_rep
argument_list|,
name|NULL
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
operator|||
name|SVN_ERROR_IN_CATEGORY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|SVN_ERR_MALFUNC_CATEGORY_START
argument_list|)
condition|)
block|{
comment|/* Fatal error; don't mask it.               In particular, this block is triggered when the rep-cache refers              to revisions in the future.  We signal that as a corruption situation              since, once those revisions are less than youngest (because of more              commits), the rep-cache would be invalid.            */
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Something's wrong with the rep-sharing index.  We can continue              without rep-sharing, but warn.            */
call|(
name|fs
operator|->
name|warning
call|)
argument_list|(
name|fs
operator|->
name|warning_baton
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|old_rep
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* look for intra-revision matches (usually data reps but not limited      to them in case props happen to look like some data rep)    */
if|if
condition|(
operator|*
name|old_rep
operator|==
name|NULL
operator|&&
name|rep
operator|->
name|txn_id
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
init|=
name|path_txn_sha1
argument_list|(
name|fs
argument_list|,
name|rep
operator|->
name|txn_id
argument_list|,
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* in our txn, is there a rep file named with the wanted SHA1?          If so, read it and use that rep.        */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|file_name
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|rep_string
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|rep_string
argument_list|,
name|file_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_rep_offsets_body
argument_list|(
name|old_rep
argument_list|,
name|rep_string
operator|->
name|data
argument_list|,
name|rep
operator|->
name|txn_id
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Add information that is missing in the cached data. */
if|if
condition|(
operator|*
name|old_rep
condition|)
block|{
comment|/* Use the old rep for this content. */
operator|(
operator|*
name|old_rep
operator|)
operator|->
name|md5_checksum
operator|=
name|rep
operator|->
name|md5_checksum
expr_stmt|;
operator|(
operator|*
name|old_rep
operator|)
operator|->
name|uniquifier
operator|=
name|rep
operator|->
name|uniquifier
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Close handler for the representation write stream.  BATON is a    rep_write_baton.  Writes out a new node-rev that correctly    references the representation we just finished writing. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_contents_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_suffix
decl_stmt|;
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|representation_t
modifier|*
name|old_rep
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|rep
operator|=
name|apr_pcalloc
argument_list|(
name|b
operator|->
name|parent_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|offset
operator|=
name|b
operator|->
name|rep_offset
expr_stmt|;
comment|/* Close our delta stream so the last bits of svndiff are written      out. */
if|if
condition|(
name|b
operator|->
name|delta_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|b
operator|->
name|delta_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the length of the svndiff data. */
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|size
operator|=
name|offset
operator|-
name|b
operator|->
name|delta_start
expr_stmt|;
comment|/* Fill in the rest of the representation field. */
name|rep
operator|->
name|expanded_size
operator|=
name|b
operator|->
name|rep_size
expr_stmt|;
name|rep
operator|->
name|txn_id
operator|=
name|svn_fs_fs__id_txn_id
argument_list|(
name|b
operator|->
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_new_txn_node_id
argument_list|(
operator|&
name|unique_suffix
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rep
operator|->
name|txn_id
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|uniquifier
operator|=
name|apr_psprintf
argument_list|(
name|b
operator|->
name|parent_pool
argument_list|,
literal|"%s/%s"
argument_list|,
name|rep
operator|->
name|txn_id
argument_list|,
name|unique_suffix
argument_list|)
expr_stmt|;
name|rep
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Finalize the checksum. */
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|rep
operator|->
name|md5_checksum
argument_list|,
name|b
operator|->
name|md5_checksum_ctx
argument_list|,
name|b
operator|->
name|parent_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|b
operator|->
name|sha1_checksum_ctx
argument_list|,
name|b
operator|->
name|parent_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out. */
name|SVN_ERR
argument_list|(
name|get_shared_rep
argument_list|(
operator|&
name|old_rep
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rep
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|parent_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rep
condition|)
block|{
comment|/* We need to erase from the protorev the data we just wrote. */
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|rep_offset
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the old rep for this content. */
name|b
operator|->
name|noderev
operator|->
name|data_rep
operator|=
name|old_rep
expr_stmt|;
block|}
else|else
block|{
comment|/* Write out our cosmetic end marker. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|b
operator|->
name|rep_stream
argument_list|,
literal|"ENDREP\n"
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|noderev
operator|->
name|data_rep
operator|=
name|rep
expr_stmt|;
block|}
comment|/* Remove cleanup callback. */
name|apr_pool_cleanup_kill
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|b
argument_list|,
name|rep_write_cleanup
argument_list|)
expr_stmt|;
comment|/* Write out the new node-rev information. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|b
operator|->
name|noderev
operator|->
name|id
argument_list|,
name|b
operator|->
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_rep
condition|)
name|SVN_ERR
argument_list|(
name|store_sha1_rep_mapping
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|b
operator|->
name|noderev
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|unlock_proto_rev
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|rep
operator|->
name|txn_id
argument_list|,
name|b
operator|->
name|lockcookie
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store a writable stream in *CONTENTS_P that will receive all data    written and store it as the file data representation referenced by    NODEREV in filesystem FS.  Perform temporary allocations in    POOL.  Only appropriate for file data, not props or directory    contents. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_representation
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|wb
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to write to non-transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|rep_write_get_baton
argument_list|(
operator|&
name|wb
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|svn_stream_create
argument_list|(
name|wb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_write_contents
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_write_contents_close
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't set text contents of a directory"
argument_list|)
argument_list|)
return|;
return|return
name|set_representation
argument_list|(
name|stream
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create_successor
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|new_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|old_idp
parameter_list|,
name|node_revision_t
modifier|*
name|new_noderev
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
operator|!
name|copy_id
condition|)
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|old_idp
argument_list|)
expr_stmt|;
name|id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|old_idp
argument_list|)
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_noderev
operator|->
name|id
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|new_noderev
operator|->
name|copyroot_path
condition|)
block|{
name|new_noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|new_noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
name|new_noderev
operator|->
name|copyroot_rev
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|new_noderev
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|new_noderev
operator|->
name|id
argument_list|,
name|new_noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_id_p
operator|=
name|id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_proplist
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|path_txn_node_props
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stream_t
modifier|*
name|out
decl_stmt|;
comment|/* Dump the property list to the mutable property file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_TRUNCATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|out
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the node-rev's prop rep as mutable, if not already done. */
if|if
condition|(
operator|!
name|noderev
operator|->
name|prop_rep
operator|||
operator|!
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
condition|)
block|{
name|noderev
operator|->
name|prop_rep
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
operator|->
name|prop_rep
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
operator|=
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the 'current' file for filesystem FS and store the next    available node id in *NODE_ID, and the next available copy id in    *COPY_ID.  Allocations are performed from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_next_revision_ids
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|node_id
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|copy_id
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_content
argument_list|(
operator|&
name|content
argument_list|,
name|svn_fs_fs__path_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|content
operator|->
name|data
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Corrupt 'current' file"
argument_list|)
argument_list|)
return|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Corrupt 'current' file"
argument_list|)
argument_list|)
return|;
operator|*
name|node_id
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" \n"
argument_list|,
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Corrupt 'current' file"
argument_list|)
argument_list|)
return|;
operator|*
name|copy_id
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This baton is used by the stream created for write_hash_rep. */
end_comment

begin_struct
struct|struct
name|write_hash_baton
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|md5_ctx
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|sha1_ctx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The handler for the write_hash_rep stream.  BATON is a    write_hash_baton, DATA has the data to write and *LEN is the number    of bytes to write. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_hash_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|write_hash_baton
modifier|*
name|whb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|whb
operator|->
name|md5_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|whb
operator|->
name|sha1_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|whb
operator|->
name|stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|->
name|size
operator|+=
operator|*
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out the hash HASH as a text representation to file FILE.  In    the process, record position, the total size of the dump and MD5 as    well as SHA1 in REP.   If rep sharing has been enabled and REPS_HASH    is not NULL, it will be used in addition to the on-disk cache to find    earlier reps with the same content.  When such existing reps can be    found, we will truncate the one just written from the file and return    the existing rep.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_hash_rep
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hash_t
modifier|*
name|hash
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|struct
name|write_hash_baton
modifier|*
name|whb
decl_stmt|;
name|representation_t
modifier|*
name|old_rep
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rep
operator|->
name|offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|whb
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|->
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|whb
operator|->
name|md5_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|sha1_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|whb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_hash_handler
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|whb
operator|->
name|stream
argument_list|,
literal|"PLAIN\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the results. */
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|rep
operator|->
name|md5_checksum
argument_list|,
name|whb
operator|->
name|md5_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|whb
operator|->
name|sha1_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out. */
name|SVN_ERR
argument_list|(
name|get_shared_rep
argument_list|(
operator|&
name|old_rep
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|reps_hash
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rep
condition|)
block|{
comment|/* We need to erase from the protorev the data we just wrote. */
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|file
argument_list|,
name|rep
operator|->
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the old rep for this content. */
name|memcpy
argument_list|(
name|rep
argument_list|,
name|old_rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Write out our cosmetic end marker. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|whb
operator|->
name|stream
argument_list|,
literal|"ENDREP\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update the representation */
name|rep
operator|->
name|size
operator|=
name|whb
operator|->
name|size
expr_stmt|;
name|rep
operator|->
name|expanded_size
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out the hash HASH pertaining to the NODEREV in FS as a deltified    text representation to file FILE.  In the process, record the total size    and the md5 digest in REP.  If rep sharing has been enabled and REPS_HASH    is not NULL, it will be used in addition to the on-disk cache to find    earlier reps with the same content.  When such existing reps can be found,    we will truncate the one just written from the file and return the existing    rep.  If PROPS is set, assume that we want to a props representation as    the base for our delta.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_hash_delta_rep
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_hash_t
modifier|*
name|hash
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|svn_boolean_t
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_window_handler_t
name|diff_wh
decl_stmt|;
name|void
modifier|*
name|diff_whb
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|representation_t
modifier|*
name|base_rep
decl_stmt|;
name|representation_t
modifier|*
name|old_rep
decl_stmt|;
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
name|apr_off_t
name|rep_end
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|delta_start
init|=
literal|0
decl_stmt|;
name|struct
name|write_hash_baton
modifier|*
name|whb
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|diff_version
init|=
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_SVNDIFF1_FORMAT
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* Get the base for this delta. */
name|SVN_ERR
argument_list|(
name|choose_delta_base
argument_list|(
operator|&
name|base_rep
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_representation
argument_list|(
operator|&
name|source
argument_list|,
name|fs
argument_list|,
name|base_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rep
operator|->
name|offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the rep header. */
if|if
condition|(
name|base_rep
condition|)
block|{
name|header
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|REP_DELTA
literal|" %ld %"
name|APR_OFF_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|"\n"
argument_list|,
name|base_rep
operator|->
name|revision
argument_list|,
name|base_rep
operator|->
name|offset
argument_list|,
name|base_rep
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|header
operator|=
name|REP_DELTA
literal|"\n"
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|header
argument_list|,
name|strlen
argument_list|(
name|header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|delta_start
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Prepare to write the svndiff data. */
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|diff_wh
argument_list|,
operator|&
name|diff_whb
argument_list|,
name|file_stream
argument_list|,
name|diff_version
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|whb
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|whb
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|->
name|stream
operator|=
name|svn_txdelta_target_push
argument_list|(
name|diff_wh
argument_list|,
name|diff_whb
argument_list|,
name|source
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|whb
operator|->
name|md5_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|sha1_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* serialize the hash */
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|whb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_hash_handler
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|whb
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the results. */
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|rep
operator|->
name|md5_checksum
argument_list|,
name|whb
operator|->
name|md5_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|whb
operator|->
name|sha1_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out. */
name|SVN_ERR
argument_list|(
name|get_shared_rep
argument_list|(
operator|&
name|old_rep
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|reps_hash
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rep
condition|)
block|{
comment|/* We need to erase from the protorev the data we just wrote. */
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|file
argument_list|,
name|rep
operator|->
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the old rep for this content. */
name|memcpy
argument_list|(
name|rep
argument_list|,
name|old_rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Write out our cosmetic end marker. */
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rep_end
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|file_stream
argument_list|,
literal|"ENDREP\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update the representation */
name|rep
operator|->
name|expanded_size
operator|=
name|whb
operator|->
name|size
expr_stmt|;
name|rep
operator|->
name|size
operator|=
name|rep_end
operator|-
name|delta_start
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Sanity check ROOT_NODEREV, a candidate for being the root node-revision    of (not yet committed) revision REV in FS.  Use POOL for temporary    allocations.     If you change this function, consider updating svn_fs_fs__verify() too.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validate_root_noderev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|root_noderev
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|head_revnum
init|=
name|rev
operator|-
literal|1
decl_stmt|;
name|int
name|head_predecessor_count
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rev
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute HEAD_PREDECESSOR_COUNT. */
block|{
name|svn_fs_root_t
modifier|*
name|head_revision
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|head_root_id
decl_stmt|;
name|node_revision_t
modifier|*
name|head_root_noderev
decl_stmt|;
comment|/* Get /@HEAD's noderev. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|head_revision
argument_list|,
name|fs
argument_list|,
name|head_revnum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|head_root_id
argument_list|,
name|head_revision
argument_list|,
literal|"/"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|head_root_noderev
argument_list|,
name|fs
argument_list|,
name|head_root_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|head_predecessor_count
operator|=
name|head_root_noderev
operator|->
name|predecessor_count
expr_stmt|;
block|}
comment|/* Check that the root noderev's predecessor count equals REV.       This kind of corruption was seen on svn.apache.org (both on      the root noderev and on other fspaths' noderevs); see      issue #4129.       Normally (rev == root_noderev->predecessor_count), but here we      use a more roundabout check that should only trigger on new instances      of the corruption, rather then trigger on each and every new commit      to a repository that has triggered the bug somewhere in its root      noderev's history.    */
if|if
condition|(
name|root_noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|root_noderev
operator|->
name|predecessor_count
operator|-
name|head_predecessor_count
operator|)
operator|!=
operator|(
name|rev
operator|-
name|head_revnum
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"predecessor count for "
literal|"the root node-revision is wrong: "
literal|"found (%d+%ld != %d), committing r%ld"
argument_list|)
argument_list|,
name|head_predecessor_count
argument_list|,
name|rev
operator|-
name|head_revnum
argument_list|,
comment|/* This is equal to 1. */
name|root_noderev
operator|->
name|predecessor_count
argument_list|,
name|rev
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy a node-revision specified by id ID in fileystem FS from a    transaction into the proto-rev-file FILE.  Set *NEW_ID_P to a    pointer to the new node-id which will be allocated in POOL.    If this is a directory, copy all children as well.     START_NODE_ID and START_COPY_ID are    the first available node and copy ids for this filesystem, for older    FS formats.     REV is the revision number that this proto-rev-file will represent.     INITIAL_OFFSET is the offset of the proto-rev-file on entry to    commit_body.     If REPS_TO_CACHE is not NULL, append to it a copy (allocated in    REPS_POOL) of each data rep that is new in this revision.     If REPS_HASH is not NULL, append copies (allocated in REPS_POOL)    of the representations of each property rep that is new in this    revision.     AT_ROOT is true if the node revision being written is the root    node-revision.  It is only controls additional sanity checking    logic.     Temporary allocations are also from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_final_rev
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|new_id_p
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|start_node_id
parameter_list|,
specifier|const
name|char
modifier|*
name|start_copy_id
parameter_list|,
name|apr_off_t
name|initial_offset
parameter_list|,
name|apr_array_header_t
modifier|*
name|reps_to_cache
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|reps_pool
parameter_list|,
name|svn_boolean_t
name|at_root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|apr_off_t
name|my_offset
decl_stmt|;
name|char
name|my_node_id_buf
index|[
name|MAX_KEY_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|my_copy_id_buf
index|[
name|MAX_KEY_SIZE
operator|+
literal|2
index|]
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|new_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id
decl_stmt|,
modifier|*
name|copy_id
decl_stmt|,
modifier|*
name|my_node_id
decl_stmt|,
modifier|*
name|my_copy_id
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|new_id_p
operator|=
name|NULL
expr_stmt|;
comment|/* Check to see if this is a transaction node. */
if|if
condition|(
operator|!
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|,
modifier|*
name|str_entries
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_entries
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* This is a directory.  Write out all the children first. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the sake of the repository administrator sort the entries          so that the final file is deterministic and repeatable,          however the rest of the FSFS code doesn't require any          particular order here. */
name|sorted_entries
operator|=
name|svn_sort__hash
argument_list|(
name|entries
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_entries
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|value
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_final_rev
argument_list|(
operator|&
name|new_id
argument_list|,
name|file
argument_list|,
name|rev
argument_list|,
name|fs
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|start_node_id
argument_list|,
name|start_copy_id
argument_list|,
name|initial_offset
argument_list|,
name|reps_to_cache
argument_list|,
name|reps_hash
argument_list|,
name|reps_pool
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_id
operator|&&
operator|(
name|svn_fs_fs__id_rev
argument_list|(
name|new_id
argument_list|)
operator|==
name|rev
operator|)
condition|)
name|dirent
operator|->
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|new_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
condition|)
block|{
comment|/* Write out the contents of this directory as a text rep. */
name|SVN_ERR
argument_list|(
name|unparse_dir_entries
argument_list|(
operator|&
name|str_entries
argument_list|,
name|entries
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|deltify_directories
condition|)
name|SVN_ERR
argument_list|(
name|write_hash_delta_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|file
argument_list|,
name|str_entries
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|write_hash_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|file
argument_list|,
name|str_entries
argument_list|,
name|fs
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a file.  We should make sure the data rep, if it          exists in a "this" state, gets rewritten to our new revision          num. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
condition|)
block|{
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
comment|/* See issue 3845.  Some unknown mechanism caused the              protorev file to get truncated, so check for that              here.  */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|->
name|offset
operator|+
name|noderev
operator|->
name|data_rep
operator|->
name|size
operator|>
name|initial_offset
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Truncated protorev file detected"
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Fix up the property reps. */
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
condition|)
block|{
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|prop_rep
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|deltify_properties
condition|)
name|SVN_ERR
argument_list|(
name|write_hash_delta_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|file
argument_list|,
name|proplist
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|reps_hash
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|write_hash_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|file
argument_list|,
name|proplist
argument_list|,
name|fs
argument_list|,
name|reps_hash
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert our temporary ID into a permanent revision one. */
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|my_offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id
operator|=
name|svn_fs_fs__id_node_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|node_id
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
name|my_node_id
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s-%ld"
argument_list|,
name|node_id
operator|+
literal|1
argument_list|,
name|rev
argument_list|)
expr_stmt|;
else|else
block|{
name|svn_fs_fs__add_keys
argument_list|(
name|start_node_id
argument_list|,
name|node_id
operator|+
literal|1
argument_list|,
name|my_node_id_buf
argument_list|)
expr_stmt|;
name|my_node_id
operator|=
name|my_node_id_buf
expr_stmt|;
block|}
block|}
else|else
name|my_node_id
operator|=
name|node_id
expr_stmt|;
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|copy_id
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
name|my_copy_id
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s-%ld"
argument_list|,
name|copy_id
operator|+
literal|1
argument_list|,
name|rev
argument_list|)
expr_stmt|;
else|else
block|{
name|svn_fs_fs__add_keys
argument_list|(
name|start_copy_id
argument_list|,
name|copy_id
operator|+
literal|1
argument_list|,
name|my_copy_id_buf
argument_list|)
expr_stmt|;
name|my_copy_id
operator|=
name|my_copy_id_buf
expr_stmt|;
block|}
block|}
else|else
name|my_copy_id
operator|=
name|copy_id
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|copyroot_rev
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|noderev
operator|->
name|copyroot_rev
operator|=
name|rev
expr_stmt|;
name|new_id
operator|=
name|svn_fs_fs__id_rev_create
argument_list|(
name|my_node_id
argument_list|,
name|my_copy_id
argument_list|,
name|rev
argument_list|,
name|my_offset
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|id
operator|=
name|new_id
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
comment|/* Save the data representation's hash in the rep cache. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|==
name|rev
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|reps_to_cache
operator|&&
name|reps_pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|reps_to_cache
argument_list|,
name|representation_t
operator|*
argument_list|)
operator|=
name|svn_fs_fs__rep_copy
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|reps_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|noderev
operator|->
name|prop_rep
operator|->
name|revision
operator|==
name|rev
condition|)
block|{
comment|/* Add new property reps to hash and on-disk cache. */
name|representation_t
modifier|*
name|copy
init|=
name|svn_fs_fs__rep_copy
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|reps_pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|reps_to_cache
operator|&&
name|reps_pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|reps_to_cache
argument_list|,
name|representation_t
operator|*
argument_list|)
operator|=
name|copy
expr_stmt|;
name|apr_hash_set
argument_list|(
name|reps_hash
argument_list|,
name|copy
operator|->
name|sha1_checksum
operator|->
name|digest
argument_list|,
name|APR_SHA1_DIGESTSIZE
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* don't serialize SHA1 for dirs to disk (waste of space) */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|noderev
operator|->
name|data_rep
operator|->
name|sha1_checksum
operator|=
name|NULL
expr_stmt|;
comment|/* don't serialize SHA1 for props to disk (waste of space) */
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
name|noderev
operator|->
name|prop_rep
operator|->
name|sha1_checksum
operator|=
name|NULL
expr_stmt|;
comment|/* Workaround issue #4031: is-fresh-txn-root in revision files. */
name|noderev
operator|->
name|is_fresh_txn_root
operator|=
name|FALSE
expr_stmt|;
comment|/* Write out our new node-revision. */
if|if
condition|(
name|at_root
condition|)
name|SVN_ERR
argument_list|(
name|validate_root_noderev
argument_list|(
name|fs
argument_list|,
name|noderev
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_noderev
argument_list|(
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|noderev
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|fs
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return our ID that references the revision file. */
operator|*
name|new_id_p
operator|=
name|noderev
operator|->
name|id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the changed path info from transaction TXN_ID in filesystem    FS to the permanent rev-file FILE.  *OFFSET_P is set the to offset    in the file of the beginning of this information.  Perform    temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_final_changed_path_info
parameter_list|(
name|apr_off_t
modifier|*
name|offset_p
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|include_node_kinds
init|=
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_KIND_IN_CHANGED_FORMAT
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_changed_paths
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_changes_fetch
argument_list|(
operator|&
name|changed_paths
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For the sake of the repository administrator sort the changes so      that the final file is deterministic and repeatable, however the      rest of the FSFS code doesn't require any particular order here. */
name|sorted_changed_paths
operator|=
name|svn_sort__hash
argument_list|(
name|changed_paths
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Iterate through the changed paths one at a time, and convert the      temporary node-id into a permanent one for each change entry. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_changed_paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|change
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_changed_paths
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|value
expr_stmt|;
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_changed_paths
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|key
expr_stmt|;
name|id
operator|=
name|change
operator|->
name|node_rev_id
expr_stmt|;
comment|/* If this was a delete of a mutable node, then it is OK to          leave the change entry pointing to the non-existent temporary          node, since it will never be used. */
if|if
condition|(
operator|(
name|change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_delete
operator|)
operator|&&
operator|(
operator|!
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* noderev has the permanent node-id at this point, so we just              substitute it for the temporary one. */
name|change
operator|->
name|node_rev_id
operator|=
name|noderev
operator|->
name|id
expr_stmt|;
block|}
comment|/* Write out the new entry into the final rev-file. */
name|SVN_ERR
argument_list|(
name|write_change_entry
argument_list|(
name|file
argument_list|,
name|path
argument_list|,
name|change
argument_list|,
name|include_node_kinds
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|offset_p
operator|=
name|offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Atomically update the 'current' file to hold the specifed REV,    NEXT_NODE_ID, and NEXT_COPY_ID.  (The two next-ID parameters are    ignored and may be NULL if the FS format does not use them.)    Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_current
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|next_node_id
parameter_list|,
specifier|const
name|char
modifier|*
name|next_copy_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_name
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Now we can just write out this line. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
name|buf
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld\n"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
else|else
name|buf
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld %s %s\n"
argument_list|,
name|rev
argument_list|,
name|next_node_id
argument_list|,
name|next_copy_id
argument_list|)
expr_stmt|;
name|name
operator|=
name|svn_fs_fs__path_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|tmp_name
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|name
argument_list|,
name|pool
argument_list|)
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|move_into_place
argument_list|(
name|tmp_name
argument_list|,
name|name
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open a new svn_fs_t handle to FS, set that handle's concept of "current    youngest revision" to NEW_REV, and call svn_fs_fs__verify_root() on    NEW_REV's revision root.     Intended to be called as the very last step in a commit before 'current'    is bumped.  This implies that we are holding the write lock. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_as_revision_before_current_plus_plus
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|new_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_DEBUG
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|ft
decl_stmt|;
comment|/* fs++ == ft */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ft_ffd
decl_stmt|;
name|apr_hash_t
modifier|*
name|fs_config
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ffd
operator|->
name|svn_fs_open_
argument_list|)
expr_stmt|;
comment|/* make sure FT does not simply return data cached by other instances    * but actually retrieves it from disk at least once.    */
name|fs_config
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_NS
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ffd
operator|->
name|svn_fs_open_
argument_list|(
operator|&
name|ft
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|fs_config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ft_ffd
operator|=
name|ft
operator|->
name|fsap_data
expr_stmt|;
comment|/* Don't let FT consult rep-cache.db, either. */
name|ft_ffd
operator|->
name|rep_sharing_allowed
operator|=
name|FALSE
expr_stmt|;
comment|/* Time travel! */
name|ft_ffd
operator|->
name|youngest_rev_cache
operator|=
name|new_rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|ft
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|root
operator|->
name|is_txn_root
operator|==
name|FALSE
operator|&&
name|root
operator|->
name|rev
operator|==
name|new_rev
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ft_ffd
operator|->
name|youngest_rev_cache
operator|==
name|new_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__verify_root
argument_list|(
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SVN_DEBUG */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Update the 'current' file to hold the correct next node and copy_ids    from transaction TXN_ID in filesystem FS.  The current revision is    set to REV.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_final_current
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|start_node_id
parameter_list|,
specifier|const
name|char
modifier|*
name|start_copy_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|txn_node_id
decl_stmt|,
modifier|*
name|txn_copy_id
decl_stmt|;
name|char
name|new_node_id
index|[
name|MAX_KEY_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|new_copy_id
index|[
name|MAX_KEY_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
return|return
name|write_current
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
comment|/* To find the next available ids, we add the id that used to be in      the 'current' file, to the next ids from the transaction file. */
name|SVN_ERR
argument_list|(
name|read_next_ids
argument_list|(
operator|&
name|txn_node_id
argument_list|,
operator|&
name|txn_copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_fs__add_keys
argument_list|(
name|start_node_id
argument_list|,
name|txn_node_id
argument_list|,
name|new_node_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__add_keys
argument_list|(
name|start_copy_id
argument_list|,
name|txn_copy_id
argument_list|,
name|new_copy_id
argument_list|)
expr_stmt|;
return|return
name|write_current
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|new_node_id
argument_list|,
name|new_copy_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the user registed with FS has all the locks necessary to    permit all the changes associate with TXN_NAME.    The FS write lock is assumed to be held by the caller. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|changes
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changed_paths
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|last_recursed
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Fetch the changes for this transaction. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_changes_fetch
argument_list|(
operator|&
name|changes
argument_list|,
name|fs
argument_list|,
name|txn_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make an array of the changed paths, and sort them depth-first-ily.  */
name|changed_paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|apr_hash_count
argument_list|(
name|changes
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|changed_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|changed_paths
operator|->
name|elts
argument_list|,
name|changed_paths
operator|->
name|nelts
argument_list|,
name|changed_paths
operator|->
name|elt_size
argument_list|,
name|svn_sort_compare_paths
argument_list|)
expr_stmt|;
comment|/* Now, traverse the array of changed paths, verify locks.  Note      that if we need to do a recursive verification a path, we'll skip      over children of that path when we get to them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changed_paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|recurse
init|=
name|TRUE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|changed_paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* If this path has already been verified as part of a recursive          check of one of its parents, no need to do it again.  */
if|if
condition|(
name|last_recursed
operator|&&
name|svn_dirent_is_child
argument_list|(
name|last_recursed
operator|->
name|data
argument_list|,
name|path
argument_list|,
name|subpool
argument_list|)
condition|)
continue|continue;
comment|/* Fetch the change associated with our path.  */
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|changes
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* What does it mean to succeed at lock verification for a given          path?  For an existing file or directory getting modified          (text, props), it means we hold the lock on the file or          directory.  For paths being added or removed, we need to hold          the locks for that path and any children of that path.           WHEW!  We have no reliable way to determine the node kind          of deleted items, but fortunately we are going to do a          recursive check on deleted paths regardless of their kind.  */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_modify
condition|)
name|recurse
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|fs
argument_list|,
name|recurse
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we just did a recursive check, remember the path we          checked (so children can be skipped).  */
if|if
condition|(
name|recurse
condition|)
block|{
if|if
condition|(
operator|!
name|last_recursed
condition|)
name|last_recursed
operator|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_set
argument_list|(
name|last_recursed
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for commit_body below. */
end_comment

begin_struct
struct|struct
name|commit_baton
block|{
name|svn_revnum_t
modifier|*
name|new_rev_p
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|reps_to_cache
decl_stmt|;
name|apr_hash_t
modifier|*
name|reps_hash
decl_stmt|;
name|apr_pool_t
modifier|*
name|reps_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The work-horse for svn_fs_fs__commit, called with the FS write lock.    This implements the svn_fs_fs__with_write_lock() 'body' callback    type.  BATON is a 'struct commit_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|commit_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|cb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_rev_filename
decl_stmt|,
modifier|*
name|rev_filename
decl_stmt|,
modifier|*
name|proto_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprop_filename
decl_stmt|,
modifier|*
name|final_revprop
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|,
modifier|*
name|new_root_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|start_node_id
init|=
name|NULL
decl_stmt|,
modifier|*
name|start_copy_id
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|old_rev
decl_stmt|,
name|new_rev
decl_stmt|;
name|apr_file_t
modifier|*
name|proto_file
decl_stmt|;
name|void
modifier|*
name|proto_file_lockcookie
decl_stmt|;
name|apr_off_t
name|initial_offset
decl_stmt|,
name|changed_path_offset
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|apr_hash_t
modifier|*
name|txnprops
decl_stmt|;
name|apr_array_header_t
modifier|*
name|txnprop_list
decl_stmt|;
name|svn_prop_t
name|prop
decl_stmt|;
name|svn_string_t
name|date
decl_stmt|;
comment|/* Get the current youngest revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|old_rev
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to make sure this transaction is based off the most recent      revision. */
if|if
condition|(
name|cb
operator|->
name|txn
operator|->
name|base_rev
operator|!=
name|old_rev
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_TXN_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Transaction out of date"
argument_list|)
argument_list|)
return|;
comment|/* Locks may have been added (or stolen) between the calling of      previous svn_fs.h functions and svn_fs_commit_txn(), so we need      to re-examine every changed-path in the txn and re-verify all      discovered locks. */
name|SVN_ERR
argument_list|(
name|verify_locks
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the next node_id and copy_id to use. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|get_next_revision_ids
argument_list|(
operator|&
name|start_node_id
argument_list|,
operator|&
name|start_copy_id
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are going to be one better than this puny old revision. */
name|new_rev
operator|=
name|old_rev
operator|+
literal|1
expr_stmt|;
comment|/* Get a write handle on the proto revision file. */
name|SVN_ERR
argument_list|(
name|get_writable_proto_rev
argument_list|(
operator|&
name|proto_file
argument_list|,
operator|&
name|proto_file_lockcookie
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|initial_offset
argument_list|,
name|proto_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out all the node-revisions and directory contents. */
name|root_id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
literal|"0"
argument_list|,
literal|"0"
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_final_rev
argument_list|(
operator|&
name|new_root_id
argument_list|,
name|proto_file
argument_list|,
name|new_rev
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|root_id
argument_list|,
name|start_node_id
argument_list|,
name|start_copy_id
argument_list|,
name|initial_offset
argument_list|,
name|cb
operator|->
name|reps_to_cache
argument_list|,
name|cb
operator|->
name|reps_hash
argument_list|,
name|cb
operator|->
name|reps_pool
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the changed-path information. */
name|SVN_ERR
argument_list|(
name|write_final_changed_path_info
argument_list|(
operator|&
name|changed_path_offset
argument_list|,
name|proto_file
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the final line. */
name|buf
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"\n%"
name|APR_OFF_T_FMT
literal|" %"
name|APR_OFF_T_FMT
literal|"\n"
argument_list|,
name|svn_fs_fs__id_offset
argument_list|(
name|new_root_id
argument_list|)
argument_list|,
name|changed_path_offset
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|proto_file
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|proto_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|proto_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't unlock the prototype revision file immediately to avoid a      race with another caller writing to the prototype revision file      before we commit it. */
comment|/* Remove any temporary txn props representing 'flags'. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_proplist
argument_list|(
operator|&
name|txnprops
argument_list|,
name|cb
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txnprop_list
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
name|prop
operator|.
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|)
condition|)
block|{
name|prop
operator|.
name|name
operator|=
name|SVN_FS__PROP_TXN_CHECK_OOD
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|txnprop_list
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
block|}
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|)
condition|)
block|{
name|prop
operator|.
name|name
operator|=
name|SVN_FS__PROP_TXN_CHECK_LOCKS
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|txnprop_list
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|apr_is_empty_array
argument_list|(
name|txnprop_list
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__change_txn_props
argument_list|(
name|cb
operator|->
name|txn
argument_list|,
name|txnprop_list
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the shard for the rev and revprop file, if we're sharding and      this is the first revision of a new shard.  We don't care if this      fails because the shard already existed for some reason. */
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
operator|&&
name|new_rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|==
literal|0
condition|)
block|{
comment|/* Create the revs shard. */
block|{
specifier|const
name|char
modifier|*
name|new_dir
init|=
name|path_rev_shard
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_dir_make
argument_list|(
name|new_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|svn_dirent_join
argument_list|(
name|cb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|new_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create the revprops shard. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|is_packed_revprop
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|new_dir
init|=
name|path_revprops_shard
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_dir_make
argument_list|(
name|new_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|svn_dirent_join
argument_list|(
name|cb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|new_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move the finished rev file into place. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__path_rev_absolute
argument_list|(
operator|&
name|old_rev_filename
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|old_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rev_filename
operator|=
name|path_rev
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|proto_filename
operator|=
name|path_txn_proto_rev
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|move_into_place
argument_list|(
name|proto_filename
argument_list|,
name|rev_filename
argument_list|,
name|old_rev_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that we've moved the prototype revision file out of the way,      we can unlock it (since further attempts to write to the file      will fail as it no longer exists).  We must do this so that we can      remove the transaction directory later. */
name|SVN_ERR
argument_list|(
name|unlock_proto_rev
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|proto_file_lockcookie
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update commit time to ensure that svn:date revprops remain ordered. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__change_txn_prop
argument_list|(
name|cb
operator|->
name|txn
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
operator|&
name|date
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the revprops file into place. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|is_packed_revprop
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|)
argument_list|)
expr_stmt|;
name|revprop_filename
operator|=
name|path_txn_props
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|final_revprop
operator|=
name|path_revprops
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|move_into_place
argument_list|(
name|revprop_filename
argument_list|,
name|final_revprop
argument_list|,
name|old_rev_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the 'current' file. */
name|SVN_ERR
argument_list|(
name|verify_as_revision_before_current_plus_plus
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_final_current
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|new_rev
argument_list|,
name|start_node_id
argument_list|,
name|start_copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At this point the new revision is committed and globally visible      so let the caller know it succeeded by giving it the new revision      number, which fulfills svn_fs_commit_txn() contract.  Any errors      after this point do not change the fact that a new revision was      created. */
operator|*
name|cb
operator|->
name|new_rev_p
operator|=
name|new_rev
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
name|new_rev
expr_stmt|;
comment|/* Remove this transaction directory. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__purge_txn
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add the representations in REPS_TO_CACHE (an array of representation_t *)  * to the rep-cache database of FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_reps_to_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|reps_to_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps_to_cache
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|APR_ARRAY_IDX
argument_list|(
name|reps_to_cache
argument_list|,
name|i
argument_list|,
name|representation_t
operator|*
argument_list|)
decl_stmt|;
comment|/* FALSE because we don't care if another parallel commit happened to        * collide with us.  (Non-parallel collisions will not be detected.) */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_rep_reference
argument_list|(
name|fs
argument_list|,
name|rep
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__commit
parameter_list|(
name|svn_revnum_t
modifier|*
name|new_rev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|commit_baton
name|cb
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|cb
operator|.
name|new_rev_p
operator|=
name|new_rev_p
expr_stmt|;
name|cb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|cb
operator|.
name|txn
operator|=
name|txn
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
name|cb
operator|.
name|reps_to_cache
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
name|representation_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|.
name|reps_hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|cb
operator|.
name|reps_pool
operator|=
name|pool
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|.
name|reps_to_cache
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|reps_hash
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|reps_pool
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|commit_body
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At this point, *NEW_REV_P has been set, so errors below won't affect      the success of the commit.  (See svn_fs_commit_txn().)  */
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_rep_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write new entries to the rep-sharing database.        *        * We use an sqlite transaction to speed things up;        * see<http://www.sqlite.org/faq.html#q19>.        */
name|SVN_SQLITE__WITH_TXN
argument_list|(
name|write_reps_to_cache
argument_list|(
name|fs
argument_list|,
name|cb
operator|.
name|reps_to_cache
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ffd
operator|->
name|rep_cache_db
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__reserve_copy_id
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|copy_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cur_node_id
decl_stmt|,
modifier|*
name|cur_copy_id
decl_stmt|;
name|char
modifier|*
name|copy_id
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* First read in the current next-ids file. */
name|SVN_ERR
argument_list|(
name|read_next_ids
argument_list|(
operator|&
name|cur_node_id
argument_list|,
operator|&
name|cur_copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copy_id
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|strlen
argument_list|(
name|cur_copy_id
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|cur_copy_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__next_key
argument_list|(
name|cur_copy_id
argument_list|,
operator|&
name|len
argument_list|,
name|copy_id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|cur_node_id
argument_list|,
name|copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|copy_id_p
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"_"
argument_list|,
name|cur_copy_id
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out the zeroth revision for filesystem FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revision_zero
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_revision_zero
init|=
name|path_rev
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_string_t
name|date
decl_stmt|;
comment|/* Write out a rev file for revision 0. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_revision_zero
argument_list|,
literal|"PLAIN\nEND\nENDREP\n"
literal|"id: 0.0.r0/17\n"
literal|"type: dir\n"
literal|"count: 0\n"
literal|"text: 0 0 4 4 "
literal|"2d2977d1c96f487abe4a1e202dd03b4e\n"
literal|"cpath: /\n"
literal|"\n\n17 107\n"
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|path_revision_zero
argument_list|,
name|FALSE
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a date on revision 0. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|fs
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
return|return
name|set_revision_proplist
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|proplist
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|format
init|=
name|SVN_FS_FS__FORMAT_NUMBER
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* See if compatibility with older versions was explicitly requested. */
if|if
condition|(
name|fs
operator|->
name|config
condition|)
block|{
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_4_COMPATIBLE
argument_list|)
condition|)
name|format
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_5_COMPATIBLE
argument_list|)
condition|)
name|format
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_6_COMPATIBLE
argument_list|)
condition|)
name|format
operator|=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_8_COMPATIBLE
argument_list|)
condition|)
name|format
operator|=
literal|4
expr_stmt|;
block|}
name|ffd
operator|->
name|format
operator|=
name|format
expr_stmt|;
comment|/* Override the default linear layout if this is a new-enough format. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT
condition|)
name|ffd
operator|->
name|max_files_per_dir
operator|=
name|SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR
expr_stmt|;
comment|/* Create the revision data directories. */
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|path_rev_shard
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the revprops directory. */
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|path_revprops_shard
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the transaction directory. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|PATH_TXNS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the protorevs directory. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|PATH_TXN_PROTOS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the 'current' file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_fs_fs__path_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|(
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|?
literal|"0\n"
else|:
literal|"0 1 1\n"
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_uuid
argument_list|(
name|fs
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_revision_zero
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the fsfs.conf file if supported.  Older server versions would      simply ignore the file but that might result in a different behavior      than with the later releases.  Also, hotcopy would ignore, i.e. not      copy, a fsfs.conf with old formats. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_CONFIG_FILE
condition|)
name|SVN_ERR
argument_list|(
name|write_config
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
name|ffd
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the min unpacked rev file. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the txn-current file if the repository supports      the transaction sequence file. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_txn_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* This filesystem is ready.  Stamp it with a format number. */
name|SVN_ERR
argument_list|(
name|write_format
argument_list|(
name|path_format
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Part of the recovery procedure.  Return the largest revision *REV in    filesystem FS.  Use POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_get_largest_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Discovering the largest revision in the filesystem would be an      expensive operation if we did a readdir() or searched linearly,      so we'll do a form of binary search.  left is a revision that we      know exists, right a revision that we know does not exist. */
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_revnum_t
name|left
decl_stmt|,
name|right
init|=
literal|1
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Keep doubling right, until we find a revision that doesn't exist. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|err
operator|=
name|open_pack_or_rev_file
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|right
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|right
operator|<<=
literal|1
expr_stmt|;
block|}
name|left
operator|=
name|right
operator|>>
literal|1
expr_stmt|;
comment|/* We know that left exists and right doesn't.  Do a normal bsearch to find      the last revision. */
while|while
condition|(
name|left
operator|+
literal|1
operator|<
name|right
condition|)
block|{
name|svn_revnum_t
name|probe
init|=
name|left
operator|+
operator|(
operator|(
name|right
operator|-
name|left
operator|)
operator|/
literal|2
operator|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|err
operator|=
name|open_pack_or_rev_file
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|probe
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|right
operator|=
name|probe
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|left
operator|=
name|probe
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* left is now the largest revision that exists. */
operator|*
name|rev
operator|=
name|left
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A baton for reading a fixed amount from an open file.  For    recover_find_max_ids() below. */
end_comment

begin_struct
struct|struct
name|recover_read_from_file_baton
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_off_t
name|remaining
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A stream read handler used by recover_find_max_ids() below.    Read and return at most BATON->REMAINING bytes from the stream,    returning nothing after that to indicate EOF. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_recover
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|recover_read_from_file_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_filesize_t
name|bytes_to_read
init|=
operator|*
name|len
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|remaining
operator|==
literal|0
condition|)
block|{
comment|/* Return a successful read of zero bytes to signal EOF. */
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|bytes_to_read
operator|>
name|b
operator|->
name|remaining
condition|)
name|bytes_to_read
operator|=
name|b
operator|->
name|remaining
expr_stmt|;
name|b
operator|->
name|remaining
operator|-=
name|bytes_to_read
expr_stmt|;
return|return
name|svn_io_file_read_full2
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|bytes_to_read
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Part of the recovery procedure.  Read the directory noderev at offset    OFFSET of file REV_FILE (the revision file of revision REV of    filesystem FS), and set MAX_NODE_ID and MAX_COPY_ID to be the node-id    and copy-id of that node, if greater than the current value stored    in either.  Recurse into any child directories that were modified in    this revision.     MAX_NODE_ID and MAX_COPY_ID must be arrays of at least MAX_KEY_SIZE.     Perform temporary allocation in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_find_max_ids
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_file_t
modifier|*
name|rev_file
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|char
modifier|*
name|max_node_id
parameter_list|,
name|char
modifier|*
name|max_copy_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|headers
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
name|representation_t
modifier|*
name|data_rep
decl_stmt|;
name|struct
name|rep_args
modifier|*
name|ra
decl_stmt|;
name|struct
name|recover_read_from_file_baton
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_header_block
argument_list|(
operator|&
name|headers
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|rev_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that this is a directory.  It should be. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|value
argument_list|,
name|KIND_DIR
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Recovery encountered a non-directory node"
argument_list|)
argument_list|)
return|;
comment|/* Get the data location.  No data location indicates an empty directory. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|read_rep_offsets
argument_list|(
operator|&
name|data_rep
argument_list|,
name|value
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the directory's data representation wasn't changed in this revision,      we've already scanned the directory's contents for noderevs, so we don't      need to again.  This will occur if a property is changed on a directory      without changing the directory's contents. */
if|if
condition|(
name|data_rep
operator|->
name|revision
operator|!=
name|rev
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We could use get_dir_contents(), but this is much cheaper.  It does      rely on directory entries being stored as PLAIN reps, though. */
name|offset
operator|=
name|data_rep
operator|->
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_rep_line
argument_list|(
operator|&
name|ra
argument_list|,
name|rev_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|->
name|is_delta
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Recovery encountered a deltified directory "
literal|"representation"
argument_list|)
argument_list|)
return|;
comment|/* Now create a stream that's allowed to read only as much data as is      stored in the representation. */
name|baton
operator|.
name|file
operator|=
name|rev_file
expr_stmt|;
name|baton
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|baton
operator|.
name|remaining
operator|=
name|data_rep
operator|->
name|expanded_size
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read
argument_list|(
name|stream
argument_list|,
name|read_handler_recover
argument_list|)
expr_stmt|;
comment|/* Now read the entries from that stream. */
name|entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|entries
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now check each of the entries in our directory to find new node and      copy ids, and recurse into new subdirectories. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|char
modifier|*
name|str_val
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id
decl_stmt|,
modifier|*
name|copy_id
decl_stmt|;
name|apr_off_t
name|child_dir_offset
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|path
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|str_val
operator|=
name|apr_pstrdup
argument_list|(
name|iterpool
argument_list|,
name|path
operator|->
name|data
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|str_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|KIND_FILE
argument_list|)
operator|==
literal|0
condition|)
name|kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|KIND_DIR
argument_list|)
operator|==
literal|0
condition|)
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt"
argument_list|)
argument_list|)
return|;
block|}
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|str_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt"
argument_list|)
argument_list|)
return|;
name|id
operator|=
name|svn_fs_fs__id_parse
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__id_rev
argument_list|(
name|id
argument_list|)
operator|!=
name|rev
condition|)
block|{
comment|/* If the node wasn't modified in this revision, we've already              checked the node and copy id. */
continue|continue;
block|}
name|node_id
operator|=
name|svn_fs_fs__id_node_id
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__key_compare
argument_list|(
name|node_id
argument_list|,
name|max_node_id
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|strlen
argument_list|(
name|node_id
argument_list|)
operator|<
name|MAX_KEY_SIZE
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|max_node_id
argument_list|,
name|node_id
argument_list|,
name|MAX_KEY_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|svn_fs_fs__key_compare
argument_list|(
name|copy_id
argument_list|,
name|max_copy_id
argument_list|)
operator|>
literal|0
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|strlen
argument_list|(
name|copy_id
argument_list|)
operator|<
name|MAX_KEY_SIZE
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|max_copy_id
argument_list|,
name|copy_id
argument_list|,
name|MAX_KEY_SIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
continue|continue;
name|child_dir_offset
operator|=
name|svn_fs_fs__id_offset
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|recover_find_max_ids
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|rev_file
argument_list|,
name|child_dir_offset
argument_list|,
name|max_node_id
argument_list|,
name|max_copy_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if for REVISION in FS, we can find the revprop pack file.  * Use POOL for temporary allocations.  * Set *MISSING, if the reason is a missing manifest or pack file.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|packed_revprop_available
parameter_list|(
name|svn_boolean_t
modifier|*
name|missing
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
comment|/* try to read the manifest file */
specifier|const
name|char
modifier|*
name|folder
init|=
name|path_revprops_pack_shard
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|manifest_path
init|=
name|svn_dirent_join
argument_list|(
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|try_stringbuf_from_file
argument_list|(
operator|&
name|content
argument_list|,
name|missing
argument_list|,
name|manifest_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* if the manifest cannot be read, consider the pack files inaccessible    * even if the file itself exists. */
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|missing
condition|)
return|return
name|FALSE
return|;
comment|/* parse manifest content until we find the entry for REVISION.    * Revision 0 is never packed. */
name|revision
operator|=
name|revision
operator|<
name|ffd
operator|->
name|max_files_per_dir
condition|?
name|revision
operator|-
literal|1
else|:
name|revision
operator|%
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
while|while
condition|(
name|content
operator|->
name|data
condition|)
block|{
name|char
modifier|*
name|next
init|=
name|strchr
argument_list|(
name|content
operator|->
name|data
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
condition|)
block|{
operator|*
name|next
operator|=
literal|0
expr_stmt|;
operator|++
name|next
expr_stmt|;
block|}
if|if
condition|(
name|revision
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* the respective pack file must exist (and be a file) */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|err
operator|=
name|svn_io_check_path
argument_list|(
name|svn_dirent_join
argument_list|(
name|folder
argument_list|,
name|content
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|missing
operator|=
name|kind
operator|==
name|svn_node_none
expr_stmt|;
return|return
name|kind
operator|==
name|svn_node_file
return|;
block|}
name|content
operator|->
name|data
operator|=
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Baton used for recover_body below. */
end_comment

begin_struct
struct|struct
name|recover_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The work-horse for svn_fs_fs__recover, called with the FS    write lock.  This implements the svn_fs_fs__with_write_lock()    'body' callback type.  BATON is a 'struct recover_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|recover_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|b
operator|->
name|fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|max_rev
decl_stmt|;
name|char
name|next_node_id_buf
index|[
name|MAX_KEY_SIZE
index|]
decl_stmt|,
name|next_copy_id_buf
index|[
name|MAX_KEY_SIZE
index|]
decl_stmt|;
name|char
modifier|*
name|next_node_id
init|=
name|NULL
decl_stmt|,
modifier|*
name|next_copy_id
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_node_kind_t
name|youngest_revprops_kind
decl_stmt|;
comment|/* Lose potentially corrupted data in temp files */
name|SVN_ERR
argument_list|(
name|cleanup_revprop_namespace
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to know the largest revision in the filesystem. */
name|SVN_ERR
argument_list|(
name|recover_get_largest_revision
argument_list|(
name|fs
argument_list|,
operator|&
name|max_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the expected youngest revision */
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Policy note:       Since the revprops file is written after the revs file, the true      maximum available revision is the youngest one for which both are      present.  That's probably the same as the max_rev we just found,      but if it's not, we could, in theory, repeatedly decrement      max_rev until we find a revision that has both a revs and      revprops file, then write db/current with that.       But we choose not to.  If a repository is so corrupt that it's      missing at least one revprops file, we shouldn't assume that the      youngest revision for which both the revs and revprops files are      present is healthy.  In other words, we're willing to recover      from a missing or out-of-date db/current file, because db/current      is truly redundant -- it's basically a cache so we don't have to      find max_rev each time, albeit a cache with unusual semantics,      since it also officially defines when a revision goes live.  But      if we're missing more than the cache, it's time to back out and      let the admin reconstruct things by hand: correctness at that      point may depend on external things like checking a commit email      list, looking in particular working copies, etc.       This policy matches well with a typical naive backup scenario.      Say you're rsyncing your FSFS repository nightly to the same      location.  Once revs and revprops are written, you've got the      maximum rev; if the backup should bomb before db/current is      written, then db/current could stay arbitrarily out-of-date, but      we can still recover.  It's a small window, but we might as well      do what we can. */
comment|/* Even if db/current were missing, it would be created with 0 by      get_youngest(), so this conditional remains valid. */
if|if
condition|(
name|youngest_rev
operator|>
name|max_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected current rev to be<= %ld "
literal|"but found %ld"
argument_list|)
argument_list|,
name|max_rev
argument_list|,
name|youngest_rev
argument_list|)
return|;
comment|/* We only need to search for maximum IDs for old FS formats which      se global ID counters. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
block|{
comment|/* Next we need to find the maximum node id and copy id in use across the          filesystem.  Unfortunately, the only way we can get this information          is to scan all the noderevs of all the revisions and keep track as          we go along. */
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|char
name|max_node_id
index|[
name|MAX_KEY_SIZE
index|]
init|=
literal|"0"
decl_stmt|,
name|max_copy_id
index|[
name|MAX_KEY_SIZE
index|]
init|=
literal|"0"
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
for|for
control|(
name|rev
operator|=
literal|0
init|;
name|rev
operator|<=
name|max_rev
condition|;
name|rev
operator|++
control|)
block|{
name|apr_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_off_t
name|root_offset
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|cancel_func
argument_list|(
name|b
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_root_changes_offset
argument_list|(
operator|&
name|root_offset
argument_list|,
name|NULL
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|recover_find_max_ids
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|rev_file
argument_list|,
name|root_offset
argument_list|,
name|max_node_id
argument_list|,
name|max_copy_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|rev_file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Now that we finally have the maximum revision, node-id and copy-id, we          can bump the two ids to get the next of each. */
name|len
operator|=
name|strlen
argument_list|(
name|max_node_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__next_key
argument_list|(
name|max_node_id
argument_list|,
operator|&
name|len
argument_list|,
name|next_node_id_buf
argument_list|)
expr_stmt|;
name|next_node_id
operator|=
name|next_node_id_buf
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|max_copy_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__next_key
argument_list|(
name|max_copy_id
argument_list|,
operator|&
name|len
argument_list|,
name|next_copy_id_buf
argument_list|)
expr_stmt|;
name|next_copy_id
operator|=
name|next_copy_id_buf
expr_stmt|;
block|}
comment|/* Before setting current, verify that there is a revprops file      for the youngest revision.  (Issue #2992) */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|path_revprops
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|youngest_revprops_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_revprops_kind
operator|==
name|svn_node_none
condition|)
block|{
name|svn_boolean_t
name|missing
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|packed_revprop_available
argument_list|(
operator|&
name|missing
argument_list|,
name|fs
argument_list|,
name|max_rev
argument_list|,
name|pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|missing
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a revs file but no "
literal|"revprops file"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a revs file but the "
literal|"revprops file is inaccessible"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|youngest_revprops_kind
operator|!=
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a non-file where its "
literal|"revprops file should be"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
comment|/* Prune younger-than-(newfound-youngest) revisions from the rep      cache if sharing is enabled taking care not to create the cache      if it does not exist. */
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
name|svn_boolean_t
name|rep_cache_exists
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__exists_rep_cache
argument_list|(
operator|&
name|rep_cache_exists
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_cache_exists
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__del_rep_reference
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now store the discovered youngest revision, and the next IDs if      relevant, in a new 'current' file. */
return|return
name|write_current
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|next_node_id
argument_list|,
name|next_copy_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the fs_library_vtable_t.recover() API. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__recover
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|recover_baton
name|b
decl_stmt|;
comment|/* We have no way to take out an exclusive lock in FSFS, so we're      restricted as to the types of recovery we can do.  Luckily,      we just want to recreate the 'current' file, and we can do that just      by blocking other writers. */
name|b
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|b
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|recover_body
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|my_uuid
decl_stmt|;
name|apr_size_t
name|my_uuid_len
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid_path
init|=
name|path_uuid
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uuid
condition|)
name|uuid
operator|=
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Make sure we have a copy in FS->POOL, and append a newline. */
name|my_uuid
operator|=
name|apr_pstrcat
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|uuid
argument_list|,
literal|"\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|my_uuid_len
operator|=
name|strlen
argument_list|(
name|my_uuid
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_unique
argument_list|(
operator|&
name|tmp_path
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|uuid_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|my_uuid
argument_list|,
name|my_uuid_len
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use the permissions of the 'current' file, because the 'uuid'      file does not exist during repository creation. */
name|SVN_ERR
argument_list|(
name|move_into_place
argument_list|(
name|tmp_path
argument_list|,
name|uuid_path
argument_list|,
name|svn_fs_fs__path_current
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the newline we added, and stash the UUID. */
name|my_uuid
index|[
name|my_uuid_len
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|fs
operator|->
name|uuid
operator|=
name|my_uuid
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Node origin lazy cache. */
end_comment

begin_comment
comment|/* If directory PATH does not exist, create it and give it the same    permissions as FS_path.*/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__ensure_dir_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_dir_make
argument_list|(
name|path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We successfully created a new directory.  Dup the permissions      from FS->path. */
return|return
name|svn_io_copy_perms
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *NODE_ORIGINS to a hash mapping 'const char *' node IDs to    'svn_string_t *' node revision IDs.  Use POOL for allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_origins_from_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|node_origins
parameter_list|,
specifier|const
name|char
modifier|*
name|node_origins_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|fd
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
operator|*
name|node_origins
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|fd
argument_list|,
name|node_origins_file
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|fd
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|node_origins
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
operator|*
name|node_origins
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_node_origin
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|origin_id
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|node_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|node_origins
decl_stmt|;
operator|*
name|origin_id
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_origins_from_file
argument_list|(
name|fs
argument_list|,
operator|&
name|node_origins
argument_list|,
name|path_node_origin
argument_list|(
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_origins
condition|)
block|{
name|svn_string_t
modifier|*
name|origin_id_str
init|=
name|svn_hash_gets
argument_list|(
name|node_origins
argument_list|,
name|node_id
argument_list|)
decl_stmt|;
if|if
condition|(
name|origin_id_str
condition|)
operator|*
name|origin_id
operator|=
name|svn_fs_fs__id_parse
argument_list|(
name|origin_id_str
operator|->
name|data
argument_list|,
name|origin_id_str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_fs_fs__set_node_origin.  Takes a NODE_ID/NODE_REV_ID    pair and adds it to the NODE_ORIGINS_PATH file.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_node_origins_for_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|node_origins_path
parameter_list|,
specifier|const
name|char
modifier|*
name|node_id
parameter_list|,
name|svn_string_t
modifier|*
name|node_rev_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_tmp
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_hash_t
modifier|*
name|origins_hash
decl_stmt|;
name|svn_string_t
modifier|*
name|old_node_rev_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_dir_exists
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_NODE_ORIGINS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the previously existing origins (if any), and merge our      update with it. */
name|SVN_ERR
argument_list|(
name|get_node_origins_from_file
argument_list|(
name|fs
argument_list|,
operator|&
name|origins_hash
argument_list|,
name|node_origins_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origins_hash
condition|)
name|origins_hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|old_node_rev_id
operator|=
name|svn_hash_gets
argument_list|(
name|origins_hash
argument_list|,
name|node_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_node_rev_id
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|node_rev_id
argument_list|,
name|old_node_rev_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node origin for '%s' exists with a different "
literal|"value (%s) than what we were about to store "
literal|"(%s)"
argument_list|)
argument_list|,
name|node_id
argument_list|,
name|old_node_rev_id
operator|->
name|data
argument_list|,
name|node_rev_id
operator|->
name|data
argument_list|)
return|;
name|svn_hash_sets
argument_list|(
name|origins_hash
argument_list|,
name|node_id
argument_list|,
name|node_rev_id
argument_list|)
expr_stmt|;
comment|/* Sure, there's a race condition here.  Two processes could be      trying to add different cache elements to the same file at the      same time, and the entries added by the first one to write will      be lost.  But this is just a cache of reconstructible data, so      we'll accept this problem in return for not having to deal with      locking overhead. */
comment|/* Create a temporary file, write out our hash, and close the file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|path_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|node_origins_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|origins_hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rename the temp file as the real destination */
return|return
name|svn_io_file_rename
argument_list|(
name|path_tmp
argument_list|,
name|node_origins_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_node_origin
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|node_id
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|node_rev_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|path_node_origin
argument_list|(
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|err
operator|=
name|set_node_origins_for_file
argument_list|(
name|fs
argument_list|,
name|filename
argument_list|,
name|node_id
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|node_rev_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* It's just a cache; stop trying if I can't write. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__list_transactions
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|names_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|txn_dir
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|names
decl_stmt|;
name|apr_size_t
name|ext_len
init|=
name|strlen
argument_list|(
name|PATH_EXT_TXN
argument_list|)
decl_stmt|;
name|names
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the transactions directory. */
name|txn_dir
operator|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_TXNS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Now find a listing of this directory. */
name|SVN_ERR
argument_list|(
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|txn_dir
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop through all the entries and return anything that ends with '.txn'. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|klen
init|=
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|id
decl_stmt|;
comment|/* The name must end with ".txn" to be considered a transaction. */
if|if
condition|(
operator|(
name|apr_size_t
operator|)
name|klen
operator|<=
name|ext_len
operator|||
operator|(
name|strcmp
argument_list|(
name|name
operator|+
name|klen
operator|-
name|ext_len
argument_list|,
name|PATH_EXT_TXN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Truncate the ".txn" extension and store the ID. */
name|id
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|ext_len
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|names
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|id
expr_stmt|;
block|}
operator|*
name|names_p
operator|=
name|names
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__open_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|transaction_t
modifier|*
name|local_txn
decl_stmt|;
comment|/* First check to see if the directory exists. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|path_txn_dir
argument_list|(
name|fs
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did we find it? */
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_TRANSACTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such transaction '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
name|txn
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in the root node of this transaction. */
name|txn
operator|->
name|id
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|txn
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_txn
argument_list|(
operator|&
name|local_txn
argument_list|,
name|fs
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|base_rev
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|local_txn
operator|->
name|base_id
argument_list|)
expr_stmt|;
name|txn
operator|->
name|vtable
operator|=
operator|&
name|txn_vtable
expr_stmt|;
operator|*
name|txn_p
operator|=
name|txn
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|proplist
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_txn_proplist
argument_list|(
name|proplist
argument_list|,
name|txn
operator|->
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|table_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__delete_node_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete any mutable property representation. */
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path_txn_node_props
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete any mutable data representation. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path_txn_node_children
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove the corresponding entry from the cache, if such exists */
if|if
condition|(
name|ffd
operator|->
name|txn_dir_cache
condition|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|txn_dir_cache
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_io_remove_file2
argument_list|(
name|path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Revisions ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__revision_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for change_rev_prop_body below. */
end_comment

begin_struct
struct|struct
name|change_rev_prop_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The work-horse for svn_fs_fs__change_rev_prop, called with the FS    write lock.  This implements the svn_fs_fs__with_write_lock()    'body' callback type.  BATON is a 'struct change_rev_prop_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_rev_prop_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|change_rev_prop_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|old_value_p
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|wanted_value
init|=
operator|*
name|cb
operator|->
name|old_value_p
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|present_value
init|=
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|cb
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|wanted_value
operator|!=
operator|!
name|present_value
operator|)
operator|||
operator|(
name|wanted_value
operator|&&
name|present_value
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|wanted_value
argument_list|,
name|present_value
argument_list|)
operator|)
condition|)
block|{
comment|/* What we expected isn't what we found. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PROP_BASEVALUE_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"revprop '%s' has unexpected value in "
literal|"filesystem"
argument_list|)
argument_list|,
name|cb
operator|->
name|name
argument_list|)
return|;
block|}
comment|/* Fall through. */
block|}
name|svn_hash_sets
argument_list|(
name|table
argument_list|,
name|cb
operator|->
name|name
argument_list|,
name|cb
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|set_revision_proplist
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|rev
argument_list|,
name|table
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__change_rev_prop
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|change_rev_prop_baton
name|cb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|cb
operator|.
name|rev
operator|=
name|rev
expr_stmt|;
name|cb
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|cb
operator|.
name|old_value_p
operator|=
name|old_value_p
expr_stmt|;
name|cb
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|change_rev_prop_body
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Transactions ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_txn_ids
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|root_id_p
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|base_root_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|transaction_t
modifier|*
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|txn_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_id_p
operator|=
name|txn
operator|->
name|root_id
expr_stmt|;
operator|*
name|base_root_id_p
operator|=
name|txn
operator|->
name|base_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic transaction operations.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__begin_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
name|date
decl_stmt|;
name|svn_prop_t
name|prop
decl_stmt|;
name|apr_array_header_t
modifier|*
name|props
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__create_txn
argument_list|(
name|txn_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put a datestamp on the newly created txn, so we always know      exactly how old it is.  (This will help sysadmins identify      long-abandoned txns that may need to be manually removed.)  When      a txn is promoted to a revision, this property will be      automatically overwritten with a revision datestamp. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
name|prop
operator|.
name|name
operator|=
name|SVN_PROP_REVISION_DATE
expr_stmt|;
name|prop
operator|.
name|value
operator|=
operator|&
name|date
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
comment|/* Set temporary txn props that represent the requested 'flags'      behaviors. */
if|if
condition|(
name|flags
operator|&
name|SVN_FS_TXN_CHECK_OOD
condition|)
block|{
name|prop
operator|.
name|name
operator|=
name|SVN_FS__PROP_TXN_CHECK_OOD
expr_stmt|;
name|prop
operator|.
name|value
operator|=
name|svn_string_create
argument_list|(
literal|"true"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
block|{
name|prop
operator|.
name|name
operator|=
name|SVN_FS__PROP_TXN_CHECK_LOCKS
expr_stmt|;
name|prop
operator|.
name|value
operator|=
name|svn_string_create
argument_list|(
literal|"true"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
block|}
return|return
name|svn_fs_fs__change_txn_props
argument_list|(
operator|*
name|txn_p
argument_list|,
name|props
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****** Packing FSFS shards *********/
end_comment

begin_comment
comment|/* Write a file FILENAME in directory FS_PATH, containing a single line  * with the number REVNUM in ASCII decimal.  Move the file into place  * atomically, overwriting any existing file.  *  * Similar to write_current(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revnum_file
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|svn_revnum_t
name|revnum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|final_path
decl_stmt|,
modifier|*
name|tmp_path
decl_stmt|;
name|svn_stream_t
modifier|*
name|tmp_stream
decl_stmt|;
name|final_path
operator|=
name|svn_dirent_join
argument_list|(
name|fs_path
argument_list|,
name|filename
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tmp_stream
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|fs_path
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|tmp_stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"%ld\n"
argument_list|,
name|revnum
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|tmp_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|move_into_place
argument_list|(
name|tmp_path
argument_list|,
name|final_path
argument_list|,
name|final_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Pack the revision SHARD containing exactly MAX_FILES_PER_DIR revisions  * from SHARD_PATH into the PACK_FILE_DIR, using POOL for allocations.  * CANCEL_FUNC and CANCEL_BATON are what you think they are.  *  * If for some reason we detect a partial packing already performed, we  * remove the pack file and start again.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_rev_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pack_file_path
decl_stmt|,
modifier|*
name|manifest_file_path
decl_stmt|;
name|svn_stream_t
modifier|*
name|pack_stream
decl_stmt|,
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|,
name|rev
decl_stmt|;
name|apr_off_t
name|next_offset
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Some useful paths. */
name|pack_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_PACKED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Remove any existing pack file for this shard, since it is incomplete. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|pack_file_dir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory and pack and manifest files. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|pack_file_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_writable
argument_list|(
operator|&
name|pack_stream
argument_list|,
name|pack_file_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_writable
argument_list|(
operator|&
name|manifest_stream
argument_list|,
name|manifest_file_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|start_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|shard
operator|*
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|end_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|shard
operator|+
literal|1
operator|)
operator|*
operator|(
name|max_files_per_dir
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|next_offset
operator|=
literal|0
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Iterate over the revisions in this shard, squashing them together. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|svn_stream_t
modifier|*
name|rev_stream
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the size of the file. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the manifest. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|manifest_stream
argument_list|,
name|iterpool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
literal|"\n"
argument_list|,
name|next_offset
argument_list|)
argument_list|)
expr_stmt|;
name|next_offset
operator|+=
name|finfo
operator|.
name|size
expr_stmt|;
comment|/* Copy all the bits from the rev file to the end of the pack file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|rev_stream
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|rev_stream
argument_list|,
name|svn_stream_disown
argument_list|(
name|pack_stream
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|pack_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|shard_path
argument_list|,
name|pack_file_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|pack_file_path
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|manifest_file_path
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy revprop files for revisions [START_REV, END_REV) from SHARD_PATH  * to the pack file at PACK_FILE_NAME in PACK_FILE_DIR.  *  * The file sizes have already been determined and written to SIZES.  * Please note that this function will be executed while the filesystem  * has been locked and that revprops files will therefore not be modified  * while the pack is in progress.  *  * COMPRESSION_LEVEL defines how well the resulting pack file shall be  * compressed or whether is shall be compressed at all.  TOTAL_SIZE is  * a hint on which initial buffer size we should use to hold the pack file  * content.  *  * CANCEL_FUNC and CANCEL_BATON are used as usual. Temporary allocations  * are done in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_revprops
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|apr_array_header_t
modifier|*
name|sizes
parameter_list|,
name|apr_size_t
name|total_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|pack_stream
decl_stmt|;
name|apr_file_t
modifier|*
name|pack_file
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* create empty data buffer and a write stream on top of it */
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|total_size
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|pack_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* write the pack file header */
name|SVN_ERR
argument_list|(
name|serialize_revprops_header
argument_list|(
name|pack_stream
argument_list|,
name|start_rev
argument_list|,
name|sizes
argument_list|,
literal|0
argument_list|,
name|sizes
operator|->
name|nelts
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some useful paths. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|pack_file
argument_list|,
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Iterate over the revisions in this shard, squashing them together. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Construct the file name. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Copy all the bits from the non-packed revprop file to the end of        * the pack file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|stream
argument_list|,
name|pack_stream
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush stream buffers to content buffer */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|pack_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compress the content (or just store it for COMPRESSION_LEVEL 0) */
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|svn_stringbuf__morph_into_string
argument_list|(
name|uncompressed
argument_list|)
argument_list|,
name|compressed
argument_list|,
name|compression_level
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the pack file content to disk */
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|pack_file
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
operator|&
name|compressed
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For the revprop SHARD at SHARD_PATH with exactly MAX_FILES_PER_DIR  * revprop files in it, create a packed shared at PACK_FILE_DIR.  *  * COMPRESSION_LEVEL defines how well the resulting pack file shall be  * compressed or whether is shall be compressed at all.  Individual pack  * file containing more than one revision will be limited to a size of  * MAX_PACK_SIZE bytes before compression.  *  * CANCEL_FUNC and CANCEL_BATON are used in the usual way.  Temporary  * allocations are done in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_off_t
name|max_pack_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|manifest_file_path
decl_stmt|,
modifier|*
name|pack_filename
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|,
name|rev
decl_stmt|;
name|apr_off_t
name|total_size
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sizes
decl_stmt|;
comment|/* Some useful paths. */
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Remove any existing pack file for this shard, since it is incomplete. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|pack_file_dir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory and manifest file stream. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|pack_file_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_writable
argument_list|(
operator|&
name|manifest_stream
argument_list|,
name|manifest_file_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* revisions to handle. Special case: revision 0 */
name|start_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|shard
operator|*
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|end_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|shard
operator|+
literal|1
operator|)
operator|*
operator|(
name|max_files_per_dir
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_rev
operator|==
literal|0
condition|)
operator|++
name|start_rev
expr_stmt|;
comment|/* initialize the revprop size info */
name|sizes
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|max_files_per_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|total_size
operator|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
comment|/* Iterate over the revisions in this shard, determine their size and    * squashing them together into pack files. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the size of the file. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if we already have started a pack file and this revprop cannot be        * appended to it, write the previous pack file. */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|!=
literal|0
operator|&&
name|total_size
operator|+
name|SVN_INT64_BUFFER_SIZE
operator|+
name|finfo
operator|.
name|size
operator|>
name|max_pack_size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|copy_revprops
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|shard_path
argument_list|,
name|start_rev
argument_list|,
name|rev
operator|-
literal|1
argument_list|,
name|sizes
argument_list|,
operator|(
name|apr_size_t
operator|)
name|total_size
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* next pack file starts empty again */
name|apr_array_clear
argument_list|(
name|sizes
argument_list|)
expr_stmt|;
name|total_size
operator|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
name|start_rev
operator|=
name|rev
expr_stmt|;
block|}
comment|/* Update the manifest. Allocate a file name for the current pack        * file if it is a new one */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|==
literal|0
condition|)
name|pack_filename
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld.0"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|manifest_stream
argument_list|,
name|iterpool
argument_list|,
literal|"%s\n"
argument_list|,
name|pack_filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add to list of files to put into the current pack file */
name|APR_ARRAY_PUSH
argument_list|(
name|sizes
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|finfo
operator|.
name|size
expr_stmt|;
name|total_size
operator|+=
name|SVN_INT64_BUFFER_SIZE
operator|+
name|finfo
operator|.
name|size
expr_stmt|;
block|}
comment|/* write the last pack file */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|!=
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|copy_revprops
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|shard_path
argument_list|,
name|start_rev
argument_list|,
name|rev
operator|-
literal|1
argument_list|,
name|sizes
argument_list|,
operator|(
name|apr_size_t
operator|)
name|total_size
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush the manifest file and update permissions */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|shard_path
argument_list|,
name|pack_file_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Delete the non-packed revprop SHARD at SHARD_PATH with exactly  * MAX_FILES_PER_DIR revprop files in it.  If this is shard 0, keep the  * revprop file for revision 0.  *  * CANCEL_FUNC and CANCEL_BATON are used in the usual way.  Temporary  * allocations are done in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|==
literal|0
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* delete all files except the one for revision 0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max_files_per_dir
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|cancel_func
call|)
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|shard_path
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In the file system at FS_PATH, pack the SHARD in REVS_DIR and  * REVPROPS_DIR containing exactly MAX_FILES_PER_DIR revisions, using POOL  * for allocations.  REVPROPS_DIR will be NULL if revprop packing is not  * supported.  COMPRESSION_LEVEL and MAX_PACK_SIZE will be ignored in that  * case.  *  * CANCEL_FUNC and CANCEL_BATON are what you think they are; similarly  * NOTIFY_FUNC and NOTIFY_BATON.  *  * If for some reason we detect a partial packing already performed, we  * remove the pack file and start again.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|revs_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|revsprops_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_off_t
name|max_pack_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_fs_pack_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|rev_shard_path
decl_stmt|,
modifier|*
name|rev_pack_file_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|,
modifier|*
name|revprops_pack_file_dir
decl_stmt|;
comment|/* Notify caller we're starting to pack this shard. */
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_pack_notify_start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some useful paths. */
name|rev_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|revs_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|pool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rev_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revs_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* pack the revision content */
name|SVN_ERR
argument_list|(
name|pack_rev_shard
argument_list|(
name|rev_pack_file_dir
argument_list|,
name|rev_shard_path
argument_list|,
name|shard
argument_list|,
name|max_files_per_dir
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if enabled, pack the revprops in an equivalent way */
if|if
condition|(
name|revsprops_dir
condition|)
block|{
name|revprops_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|pool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|pack_revprops_shard
argument_list|(
name|revprops_pack_file_dir
argument_list|,
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|max_files_per_dir
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|0.9
operator|*
name|max_pack_size
argument_list|)
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update the min-unpacked-rev file to reflect our newly packed shard.    * (This doesn't update ffd->min_unpacked_rev.  That will be updated by    * update_min_unpacked_rev() when necessary.) */
name|SVN_ERR
argument_list|(
name|write_revnum_file
argument_list|(
name|fs_path
argument_list|,
name|PATH_MIN_UNPACKED_REV
argument_list|,
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|shard
operator|+
literal|1
operator|)
operator|*
name|max_files_per_dir
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, remove the existing shard directories. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|rev_shard_path
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revsprops_dir
condition|)
name|SVN_ERR
argument_list|(
name|delete_revprops_shard
argument_list|(
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|max_files_per_dir
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notify caller we're starting to pack this shard. */
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_pack_notify_end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|pack_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_pack_notify_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The work-horse for svn_fs_fs__pack, called with the FS write lock.    This implements the svn_fs_fs__with_write_lock() 'body' callback    type.  BATON is a 'struct pack_baton *'.     WARNING: if you add a call to this function, please note:      The code currently assumes that any piece of code running with      the write-lock set can rely on the ffd->min_unpacked_rev and      ffd->min_unpacked_revprop caches to be up-to-date (and, by      extension, on not having to use a retry when calling      svn_fs_fs__path_rev_absolute() and friends).  If you add a call      to this function, consider whether you have to call      update_min_unpacked_rev().      See this thread: http://thread.gmane.org/1291206765.3782.3309.camel@edith  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pack_baton
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|fs_fs_data_t
name|ffd
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_int64_t
name|completed_shards
decl_stmt|;
name|apr_int64_t
name|i
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_data_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_data_path
init|=
name|NULL
decl_stmt|;
comment|/* read repository settings */
name|SVN_ERR
argument_list|(
name|read_format
argument_list|(
operator|&
name|ffd
operator|.
name|format
argument_list|,
operator|&
name|ffd
operator|.
name|max_files_per_dir
argument_list|,
name|path_format
argument_list|(
name|pb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_format
argument_list|(
name|ffd
operator|.
name|format
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
operator|&
name|ffd
argument_list|,
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the repository isn't a new enough format, we don't support packing.      Return a friendly error to that effect. */
if|if
condition|(
name|ffd
operator|.
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"FSFS format (%d) too old to pack; please upgrade the filesystem."
argument_list|)
argument_list|,
name|ffd
operator|.
name|format
argument_list|)
return|;
comment|/* If we aren't using sharding, we can't do any packing, so quit. */
if|if
condition|(
operator|!
name|ffd
operator|.
name|max_files_per_dir
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|read_min_unpacked_rev
argument_list|(
operator|&
name|ffd
operator|.
name|min_unpacked_rev
argument_list|,
name|path_min_unpacked_rev
argument_list|(
name|pb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
operator|&
name|youngest
argument_list|,
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|completed_shards
operator|=
operator|(
name|youngest
operator|+
literal|1
operator|)
operator|/
name|ffd
operator|.
name|max_files_per_dir
expr_stmt|;
comment|/* See if we've already completed all possible shards thus far. */
if|if
condition|(
name|ffd
operator|.
name|min_unpacked_rev
operator|==
operator|(
name|completed_shards
operator|*
name|ffd
operator|.
name|max_files_per_dir
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|rev_data_path
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|.
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
name|revprops_data_path
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ffd
operator|.
name|min_unpacked_rev
operator|/
name|ffd
operator|.
name|max_files_per_dir
init|;
name|i
operator|<
name|completed_shards
condition|;
name|i
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|pb
operator|->
name|cancel_func
argument_list|(
name|pb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|pack_shard
argument_list|(
name|rev_data_path
argument_list|,
name|revprops_data_path
argument_list|,
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|i
argument_list|,
name|ffd
operator|.
name|max_files_per_dir
argument_list|,
name|ffd
operator|.
name|revprop_pack_size
argument_list|,
name|ffd
operator|.
name|compress_packed_revprops
condition|?
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
else|:
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
argument_list|,
name|pb
operator|->
name|notify_func
argument_list|,
name|pb
operator|->
name|notify_baton
argument_list|,
name|pb
operator|->
name|cancel_func
argument_list|,
name|pb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__pack
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_pack_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pack_baton
name|pb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|pb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|pb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|pb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|pb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|pack_body
argument_list|,
operator|&
name|pb
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Verifying. **/
end_comment

begin_comment
comment|/* Baton type expected by verify_walker().  The purpose is to reuse open  * rev / pack file handles between calls.  Its contents need to be cleaned  * periodically to limit resource usage.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|verify_walker_baton_t
block|{
comment|/* number of calls to verify_walker() since the last clean */
name|int
name|iteration_count
decl_stmt|;
comment|/* number of files opened since the last clean */
name|int
name|file_count
decl_stmt|;
comment|/* progress notification callback to invoke periodically (may be NULL) */
name|svn_fs_progress_notify_func_t
name|notify_func
decl_stmt|;
comment|/* baton to use with NOTIFY_FUNC */
name|void
modifier|*
name|notify_baton
decl_stmt|;
comment|/* remember the last revision for which we called notify_func */
name|svn_revnum_t
name|last_notified_revision
decl_stmt|;
comment|/* current file handle (or NULL) */
name|apr_file_t
modifier|*
name|file_hint
decl_stmt|;
comment|/* corresponding revision (or SVN_INVALID_REVNUM) */
name|svn_revnum_t
name|rev_hint
decl_stmt|;
comment|/* pool to use for the file handles etc. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|verify_walker_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Used by svn_fs_fs__verify().    Implements svn_fs_fs__walk_rep_reference().walker.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_walker
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|rep_state
modifier|*
name|rs
decl_stmt|;
name|struct
name|rep_args
modifier|*
name|rep_args
decl_stmt|;
if|if
condition|(
name|baton
condition|)
block|{
name|verify_walker_baton_t
modifier|*
name|walker_baton
init|=
name|baton
decl_stmt|;
name|apr_file_t
modifier|*
name|previous_file
decl_stmt|;
comment|/* notify and free resources periodically */
if|if
condition|(
name|walker_baton
operator|->
name|iteration_count
operator|>
literal|1000
operator|||
name|walker_baton
operator|->
name|file_count
operator|>
literal|16
condition|)
block|{
if|if
condition|(
name|walker_baton
operator|->
name|notify_func
operator|&&
name|rep
operator|->
name|revision
operator|!=
name|walker_baton
operator|->
name|last_notified_revision
condition|)
block|{
name|walker_baton
operator|->
name|notify_func
argument_list|(
name|rep
operator|->
name|revision
argument_list|,
name|walker_baton
operator|->
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|walker_baton
operator|->
name|last_notified_revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
block|}
name|svn_pool_clear
argument_list|(
name|walker_baton
operator|->
name|pool
argument_list|)
expr_stmt|;
name|walker_baton
operator|->
name|iteration_count
operator|=
literal|0
expr_stmt|;
name|walker_baton
operator|->
name|file_count
operator|=
literal|0
expr_stmt|;
name|walker_baton
operator|->
name|file_hint
operator|=
name|NULL
expr_stmt|;
name|walker_baton
operator|->
name|rev_hint
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* access the repo data */
name|previous_file
operator|=
name|walker_baton
operator|->
name|file_hint
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_args
argument_list|,
operator|&
name|walker_baton
operator|->
name|file_hint
argument_list|,
operator|&
name|walker_baton
operator|->
name|rev_hint
argument_list|,
name|rep
argument_list|,
name|fs
argument_list|,
name|walker_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update resource usage counters */
name|walker_baton
operator|->
name|iteration_count
operator|++
expr_stmt|;
if|if
condition|(
name|previous_file
operator|!=
name|walker_baton
operator|->
name|file_hint
condition|)
name|walker_baton
operator|->
name|file_count
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* ### Should this be using read_rep_line() directly? */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_args
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rep
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__verify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_fs_progress_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|exists
decl_stmt|;
name|svn_revnum_t
name|youngest
init|=
name|ffd
operator|->
name|youngest_rev_cache
decl_stmt|;
comment|/* cache is current */
if|if
condition|(
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Input validation. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
condition|)
name|start
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
condition|)
name|end
operator|=
name|youngest
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_revision_exists
argument_list|(
name|fs
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* rep-cache verification. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__exists_rep_cache
argument_list|(
operator|&
name|exists
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
block|{
comment|/* provide a baton to allow the reuse of open file handles between          iterations (saves 2/3 of OS level file operations). */
name|verify_walker_baton_t
modifier|*
name|baton
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
name|baton
operator|->
name|rev_hint
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|last_notified_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|baton
operator|->
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|baton
operator|->
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
comment|/* tell the user that we are now ready to do *something* */
if|if
condition|(
name|notify_func
condition|)
name|notify_func
argument_list|(
name|SVN_INVALID_REVNUM
argument_list|,
name|notify_baton
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Do not attempt to walk the rep-cache database if its file does          not exist,  since doing so would create it --- which may confuse          the administrator.   Don't take any lock. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__walk_rep_reference
argument_list|(
name|fs
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|verify_walker
argument_list|,
name|baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* walker resource cleanup */
name|svn_pool_destroy
argument_list|(
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Hotcopy. **/
end_comment

begin_comment
comment|/* Like svn_io_dir_file_copy(), but doesn't copy files that exist at  * the destination and do not differ in terms of kind, size, and mtime. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_io_dir_file_copy
parameter_list|(
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_io_dirent2_t
modifier|*
name|src_dirent
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dst_dirent
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_target
decl_stmt|;
comment|/* Does the destination already exist? If not, we must copy it. */
name|dst_target
operator|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dst_dirent
argument_list|,
name|dst_target
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_dirent
operator|->
name|kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* If the destination's stat information indicates that the file        * is equal to the source, don't bother copying the file again. */
name|src_target
operator|=
name|svn_dirent_join
argument_list|(
name|src_path
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|src_dirent
argument_list|,
name|src_target
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_dirent
operator|->
name|kind
operator|==
name|dst_dirent
operator|->
name|kind
operator|&&
name|src_dirent
operator|->
name|special
operator|==
name|dst_dirent
operator|->
name|special
operator|&&
name|src_dirent
operator|->
name|filesize
operator|==
name|dst_dirent
operator|->
name|filesize
operator|&&
name|src_dirent
operator|->
name|mtime
operator|<=
name|dst_dirent
operator|->
name|mtime
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_io_dir_file_copy
argument_list|(
name|src_path
argument_list|,
name|dst_path
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *NAME_P to the UTF-8 representation of directory entry NAME.  * NAME is in the internal encoding used by APR; PARENT is in  * UTF-8 and in internal (not local) style.  *  * Use PARENT only for generating an error string if the conversion  * fails because NAME could not be represented in UTF-8.  In that  * case, return a two-level error in which the outer error's message  * mentions PARENT, but the inner error's message does not mention  * NAME (except possibly in hex) since NAME may not be printable.  * Such a compound error at least allows the user to go looking in the  * right directory for the problem.  *  * If there is any other error, just return that error directly.  *  * If there is any error, the effect on *NAME_P is undefined.  *  * *NAME_P and NAME may refer to the same storage.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|entry_name_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|name_p
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_path_cstring_to_utf8
argument_list|(
name|name_p
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|APR_EINVAL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Error converting entry "
literal|"in directory '%s' to UTF-8"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Like svn_io_copy_dir_recursively() but doesn't copy regular files that  * exist in the destination and do not differ from the source in terms of  * kind, size, and mtime. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_io_copy_dir_recursively
parameter_list|(
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_parent
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_basename
parameter_list|,
name|svn_boolean_t
name|copy_perms
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_path
decl_stmt|;
name|apr_dir_t
modifier|*
name|this_dir
decl_stmt|;
name|apr_finfo_t
name|this_entry
decl_stmt|;
name|apr_int32_t
name|flags
init|=
name|APR_FINFO_TYPE
operator||
name|APR_FINFO_NAME
decl_stmt|;
comment|/* Make a subpool for recursion */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* The 'dst_path' is simply dst_parent/dst_basename */
name|dst_path
operator|=
name|svn_dirent_join
argument_list|(
name|dst_parent
argument_list|,
name|dst_basename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Sanity checks:  SRC and DST_PARENT are directories, and      DST_BASENAME doesn't already exist in DST_PARENT. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Source '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_parent
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_parent
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_path
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory. */
comment|/* ### TODO: copy permissions (needs apr_file_attrs_get()) */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over the dirents in SRC.  ('.' and '..' are auto-excluded) */
name|SVN_ERR
argument_list|(
name|svn_io_dir_open
argument_list|(
operator|&
name|this_dir
argument_list|,
name|src
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
init|;
name|status
operator|==
name|APR_SUCCESS
condition|;
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|this_entry
operator|.
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|entryname_utf8
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|entry_name_to_utf8
argument_list|(
operator|&
name|entryname_utf8
argument_list|,
name|this_entry
operator|.
name|name
argument_list|,
name|src
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_REG
condition|)
comment|/* regular file */
block|{
name|SVN_ERR
argument_list|(
name|hotcopy_io_dir_file_copy
argument_list|(
name|src
argument_list|,
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_LNK
condition|)
comment|/* symlink */
block|{
specifier|const
name|char
modifier|*
name|src_target
init|=
name|svn_dirent_join
argument_list|(
name|src
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_target
init|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_link
argument_list|(
name|src_target
argument_list|,
name|dst_target
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_DIR
condition|)
comment|/* recurse */
block|{
specifier|const
name|char
modifier|*
name|src_target
decl_stmt|;
comment|/* Prevent infinite recursion by filtering off our                  newly created destination path. */
if|if
condition|(
name|strcmp
argument_list|(
name|src
argument_list|,
name|dst_parent
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|entryname_utf8
argument_list|,
name|dst_basename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|src_target
operator|=
name|svn_dirent_join
argument_list|(
name|src
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|src_target
argument_list|,
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|copy_perms
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### support other APR node types someday?? */
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
operator|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't read directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|status
operator|=
name|apr_dir_close
argument_list|(
name|this_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Error closing directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Free any memory used by recursion */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy an un-packed revision or revprop file for revision REV from SRC_SUBDIR  * to DST_SUBDIR. Assume a sharding layout based on MAX_FILES_PER_DIR.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_copy_shard_file
parameter_list|(
specifier|const
name|char
modifier|*
name|src_subdir
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_subdir
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src_subdir_shard
init|=
name|src_subdir
decl_stmt|,
modifier|*
name|dst_subdir_shard
init|=
name|dst_subdir
decl_stmt|;
if|if
condition|(
name|max_files_per_dir
condition|)
block|{
specifier|const
name|char
modifier|*
name|shard
init|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
decl_stmt|;
name|src_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|src_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|dst_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|dst_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|%
name|max_files_per_dir
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|dst_subdir_shard
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|dst_subdir
argument_list|,
name|dst_subdir_shard
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|hotcopy_io_dir_file_copy
argument_list|(
name|src_subdir_shard
argument_list|,
name|dst_subdir_shard
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy a packed shard containing revision REV, and which contains  * MAX_FILES_PER_DIR revisions, from SRC_FS to DST_FS.  * Update *DST_MIN_UNPACKED_REV in case the shard is new in DST_FS.  * Do not re-copy data which already exists in DST_FS.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_copy_packed_shard
parameter_list|(
name|svn_revnum_t
modifier|*
name|dst_min_unpacked_rev
parameter_list|,
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|packed_shard
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_subdir_packed_shard
decl_stmt|;
name|svn_revnum_t
name|revprop_rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Copy the packed shard. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|packed_shard
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
name|PATH_EXT_PACKED_SHARD
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|src_subdir_packed_shard
operator|=
name|svn_dirent_join
argument_list|(
name|src_subdir
argument_list|,
name|packed_shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|src_subdir_packed_shard
argument_list|,
name|dst_subdir
argument_list|,
name|packed_shard
argument_list|,
name|TRUE
comment|/* copy_perms */
argument_list|,
name|NULL
comment|/* cancel_func */
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy revprops belonging to revisions in this pack. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
operator|||
name|src_ffd
operator|->
name|min_unpacked_rev
operator|<
name|rev
operator|+
name|max_files_per_dir
condition|)
block|{
comment|/* copy unpacked revprops rev by rev */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|revprop_rev
operator|=
name|rev
init|;
name|revprop_rev
operator|<
name|rev
operator|+
name|max_files_per_dir
condition|;
name|revprop_rev
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_copy_shard_file
argument_list|(
name|src_subdir
argument_list|,
name|dst_subdir
argument_list|,
name|revprop_rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* revprop for revision 0 will never be packed */
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|hotcopy_copy_shard_file
argument_list|(
name|src_subdir
argument_list|,
name|dst_subdir
argument_list|,
literal|0
argument_list|,
name|max_files_per_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* packed revprops folder */
name|packed_shard
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
name|PATH_EXT_PACKED_SHARD
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|src_subdir_packed_shard
operator|=
name|svn_dirent_join
argument_list|(
name|src_subdir
argument_list|,
name|packed_shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|src_subdir_packed_shard
argument_list|,
name|dst_subdir
argument_list|,
name|packed_shard
argument_list|,
name|TRUE
comment|/* copy_perms */
argument_list|,
name|NULL
comment|/* cancel_func */
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If necessary, update the min-unpacked rev file in the hotcopy. */
if|if
condition|(
operator|*
name|dst_min_unpacked_rev
operator|<
name|rev
operator|+
name|max_files_per_dir
condition|)
block|{
operator|*
name|dst_min_unpacked_rev
operator|=
name|rev
operator|+
name|max_files_per_dir
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_revnum_file
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_MIN_UNPACKED_REV
argument_list|,
operator|*
name|dst_min_unpacked_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If NEW_YOUNGEST is younger than *DST_YOUNGEST, update the 'current'  * file in DST_FS and set *DST_YOUNGEST to NEW_YOUNGEST.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_update_current
parameter_list|(
name|svn_revnum_t
modifier|*
name|dst_youngest
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|new_youngest
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|char
name|next_node_id
index|[
name|MAX_KEY_SIZE
index|]
init|=
literal|"0"
decl_stmt|;
name|char
name|next_copy_id
index|[
name|MAX_KEY_SIZE
index|]
init|=
literal|"0"
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|*
name|dst_youngest
operator|>=
name|new_youngest
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If necessary, get new current next_node and next_copy IDs. */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
block|{
name|apr_off_t
name|root_offset
decl_stmt|;
name|apr_file_t
modifier|*
name|rev_file
decl_stmt|;
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|update_min_unpacked_rev
argument_list|(
name|dst_fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|dst_fs
argument_list|,
name|new_youngest
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_root_changes_offset
argument_list|(
operator|&
name|root_offset
argument_list|,
name|NULL
argument_list|,
name|rev_file
argument_list|,
name|dst_fs
argument_list|,
name|new_youngest
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|recover_find_max_ids
argument_list|(
name|dst_fs
argument_list|,
name|new_youngest
argument_list|,
name|rev_file
argument_list|,
name|root_offset
argument_list|,
name|next_node_id
argument_list|,
name|next_copy_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|rev_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update 'current'. */
name|SVN_ERR
argument_list|(
name|write_current
argument_list|(
name|dst_fs
argument_list|,
name|new_youngest
argument_list|,
name|next_node_id
argument_list|,
name|next_copy_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|dst_youngest
operator|=
name|new_youngest
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove revision or revprop files between START_REV (inclusive) and  * END_REV (non-inclusive) from folder DST_SUBDIR in DST_FS.  Assume  * sharding as per MAX_FILES_PER_DIR.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_remove_files
parameter_list|(
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_subdir
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|shard
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_subdir_shard
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Pre-compute paths for initial shard. */
name|shard
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|start_rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|dst_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|dst_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If necessary, update paths for shard. */
if|if
condition|(
name|rev
operator|!=
name|start_rev
operator|&&
name|rev
operator|%
name|max_files_per_dir
operator|==
literal|0
condition|)
block|{
name|shard
operator|=
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|dst_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|dst_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* remove files for REV */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|dst_subdir_shard
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Make the rev file writable and remove it. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove revisions between START_REV (inclusive) and END_REV (non-inclusive)  * from DST_FS. Assume sharding as per MAX_FILES_PER_DIR.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_remove_rev_files
parameter_list|(
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|start_rev
operator|<=
name|end_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_remove_files
argument_list|(
name|dst_fs
argument_list|,
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove revision properties between START_REV (inclusive) and END_REV  * (non-inclusive) from DST_FS. Assume sharding as per MAX_FILES_PER_DIR.  * Use SCRATCH_POOL for temporary allocations.  Revision 0 revprops will  * not be deleted. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_remove_revprop_files
parameter_list|(
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|start_rev
operator|<=
name|end_rev
argument_list|)
expr_stmt|;
comment|/* don't delete rev 0 props */
name|SVN_ERR
argument_list|(
name|hotcopy_remove_files
argument_list|(
name|dst_fs
argument_list|,
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|start_rev
condition|?
name|start_rev
else|:
literal|1
argument_list|,
name|end_rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that DST_FS is a suitable destination for an incremental  * hotcopy from SRC_FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_incremental_check_preconditions
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* We only support incremental hotcopy between the same format. */
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|!=
name|dst_ffd
operator|->
name|format
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The FSFS format (%d) of the hotcopy source does not match the "
literal|"FSFS format (%d) of the hotcopy destination; please upgrade "
literal|"both repositories to the same format"
argument_list|)
argument_list|,
name|src_ffd
operator|->
name|format
argument_list|,
name|dst_ffd
operator|->
name|format
argument_list|)
return|;
comment|/* Make sure the UUID of source and destination match up.    * We don't want to copy over a different repository. */
if|if
condition|(
name|strcmp
argument_list|(
name|src_fs
operator|->
name|uuid
argument_list|,
name|dst_fs
operator|->
name|uuid
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_UUID_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The UUID of the hotcopy source does "
literal|"not match the UUID of the hotcopy "
literal|"destination"
argument_list|)
argument_list|)
return|;
comment|/* Also require same shard size. */
if|if
condition|(
name|src_ffd
operator|->
name|max_files_per_dir
operator|!=
name|dst_ffd
operator|->
name|max_files_per_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The sharding layout configuration "
literal|"of the hotcopy source does not match "
literal|"the sharding layout configuration of "
literal|"the hotcopy destination"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove folder PATH.  Ignore errors due to the sub-tree not being empty.  * CANCEL_FUNC and CANCEL_BATON do the usual thing.  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_folder
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_remove_dir2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for hotcopy_body(). */
end_comment

begin_struct
struct|struct
name|hotcopy_body_baton
block|{
name|svn_fs_t
modifier|*
name|src_fs
decl_stmt|;
name|svn_fs_t
modifier|*
name|dst_fs
decl_stmt|;
name|svn_boolean_t
name|incremental
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
name|hotcopy_body_baton
struct|;
end_struct

begin_comment
comment|/* Perform a hotcopy, either normal or incremental.  *  * Normal hotcopy assumes that the destination exists as an empty  * directory. It behaves like an incremental hotcopy except that  * none of the copied files already exist in the destination.  *  * An incremental hotcopy copies only changed or new files to the destination,  * and removes files from the destination no longer present in the source.  * While the incremental hotcopy is running, readers should still be able  * to access the destintation repository without error and should not see  * revisions currently in progress of being copied. Readers are able to see  * new fully copied revisions even if the entire incremental hotcopy procedure  * has not yet completed.  *  * Writers are blocked out completely during the entire incremental hotcopy  * process to ensure consistency. This function assumes that the repository  * write-lock is held.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|hotcopy_body_baton
modifier|*
name|hbb
init|=
name|baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|src_fs
init|=
name|hbb
operator|->
name|src_fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|dst_fs
init|=
name|hbb
operator|->
name|dst_fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|max_files_per_dir
init|=
name|src_ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|svn_boolean_t
name|incremental
init|=
name|hbb
operator|->
name|incremental
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
init|=
name|hbb
operator|->
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
init|=
name|hbb
operator|->
name|cancel_baton
decl_stmt|;
name|svn_revnum_t
name|src_youngest
decl_stmt|;
name|svn_revnum_t
name|dst_youngest
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_revnum_t
name|src_min_unpacked_rev
decl_stmt|;
name|svn_revnum_t
name|dst_min_unpacked_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprop_src_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprop_dst_subdir
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* Try to copy the config.    *    * ### We try copying the config file before doing anything else,    * ### because higher layers will abort the hotcopy if we throw    * ### an error from this function, and that renders the hotcopy    * ### unusable anyway. */
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_CONFIG_FILE
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_io_dir_file_copy
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* 1.6.0 to 1.6.11 did not copy the configuration file during                * hotcopy. So if we're hotcopying a repository which has been                * created as a hotcopy itself, it's possible that fsfs.conf                * does not exist. Ask the user to re-create it.                *                * ### It would be nice to make this a non-fatal error,                * ### but this function does not get an svn_fs_t object                * ### so we have no way of just printing a warning via                * ### the fs->warning() callback. */
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_relpath
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|config_relpath
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err2
operator|=
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|src_abspath
argument_list|,
name|src_fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
name|err2
operator|=
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|dst_abspath
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
comment|/* ### hack: strip off the 'db/' directory from paths so                * ### they make sense to the user */
name|src_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|src_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|dst_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Failed to create hotcopy at '%s'. "
literal|"The file '%s' is missing from the source "
literal|"repository. Please create this file, for "
literal|"instance by running 'svnadmin upgrade %s'"
argument_list|)
argument_list|,
name|dst_abspath
argument_list|,
name|config_relpath
argument_list|,
name|src_abspath
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|msg
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the youngest revision in the source and destination.    * We only support hotcopies from sources with an equal or greater amount    * of revisions than the destination.    * This also catches the case where users accidentally swap the    * source and destination arguments. */
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
operator|&
name|src_youngest
argument_list|,
name|src_fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_youngest
argument_list|(
operator|&
name|dst_youngest
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_youngest
operator|<
name|dst_youngest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The hotcopy destination already contains more revisions "
literal|"(%lu) than the hotcopy source contains (%lu); are source "
literal|"and destination swapped?"
argument_list|)
argument_list|,
name|dst_youngest
argument_list|,
name|src_youngest
argument_list|)
return|;
block|}
else|else
name|dst_youngest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the min unpacked rev, and read its value. */
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
block|{
specifier|const
name|char
modifier|*
name|min_unpacked_rev_path
decl_stmt|;
name|min_unpacked_rev_path
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_MIN_UNPACKED_REV
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_min_unpacked_rev
argument_list|(
operator|&
name|src_min_unpacked_rev
argument_list|,
name|min_unpacked_rev_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|min_unpacked_rev_path
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_MIN_UNPACKED_REV
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_min_unpacked_rev
argument_list|(
operator|&
name|dst_min_unpacked_rev
argument_list|,
name|min_unpacked_rev_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only support packs coming from the hotcopy source.        * The destination should not be packed independently from        * the source. This also catches the case where users accidentally        * swap the source and destination arguments. */
if|if
condition|(
name|src_min_unpacked_rev
operator|<
name|dst_min_unpacked_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The hotcopy destination already contains "
literal|"more packed revisions (%lu) than the "
literal|"hotcopy source contains (%lu)"
argument_list|)
argument_list|,
name|dst_min_unpacked_rev
operator|-
literal|1
argument_list|,
name|src_min_unpacked_rev
operator|-
literal|1
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_dir_file_copy
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_MIN_UNPACKED_REV
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|src_min_unpacked_rev
operator|=
literal|0
expr_stmt|;
name|dst_min_unpacked_rev
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Copy the necessary rev files.    */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|dst_subdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* First, copy packed shards. */
for|for
control|(
name|rev
operator|=
literal|0
init|;
name|rev
operator|<
name|src_min_unpacked_rev
condition|;
name|rev
operator|+=
name|max_files_per_dir
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the packed shard. */
name|SVN_ERR
argument_list|(
name|hotcopy_copy_packed_shard
argument_list|(
operator|&
name|dst_min_unpacked_rev
argument_list|,
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If necessary, update 'current' to the most recent packed rev,        * so readers can see new revisions which arrived in this pack. */
name|SVN_ERR
argument_list|(
name|hotcopy_update_current
argument_list|(
operator|&
name|dst_youngest
argument_list|,
name|dst_fs
argument_list|,
name|rev
operator|+
name|max_files_per_dir
operator|-
literal|1
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove revision files which are now packed. */
if|if
condition|(
name|incremental
condition|)
block|{
name|SVN_ERR
argument_list|(
name|hotcopy_remove_rev_files
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|rev
operator|+
name|max_files_per_dir
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|hotcopy_remove_revprop_files
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|rev
operator|+
name|max_files_per_dir
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now that all revisions have moved into the pack, the original        * rev dir can be removed. */
name|SVN_ERR
argument_list|(
name|remove_folder
argument_list|(
name|path_rev_shard
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|>
literal|0
operator|&&
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|remove_folder
argument_list|(
name|path_revprops_shard
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, copy pairs of non-packed revisions and revprop files.    * If necessary, update 'current' after copying all files from a shard. */
name|SVN_ERR_ASSERT
argument_list|(
name|rev
operator|==
name|src_min_unpacked_rev
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|src_min_unpacked_rev
operator|==
name|dst_min_unpacked_rev
argument_list|)
expr_stmt|;
name|revprop_src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|revprop_dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|revprop_dst_subdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|rev
operator|<=
name|src_youngest
condition|;
name|rev
operator|++
control|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the rev file. */
name|err
operator|=
name|hotcopy_copy_shard_file
argument_list|(
name|src_subdir
argument_list|,
name|dst_subdir
argument_list|,
name|rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|&&
name|src_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* The source rev file does not exist. This can happen if the                * source repository is being packed concurrently with this                * hotcopy operation.                *                * If the new revision is now packed, and the youngest revision                * we're interested in is not inside this pack, try to copy the                * pack instead.                *                * If the youngest revision ended up being packed, don't try                * to be smart and work around this. Just abort the hotcopy. */
name|SVN_ERR
argument_list|(
name|update_min_unpacked_rev
argument_list|(
name|src_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_packed_rev
argument_list|(
name|src_fs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
if|if
condition|(
name|is_packed_rev
argument_list|(
name|src_fs
argument_list|,
name|src_youngest
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The assumed HEAD revision (%lu) of the "
literal|"hotcopy source has been packed while the "
literal|"hotcopy was in progress; please restart "
literal|"the hotcopy operation"
argument_list|)
argument_list|,
name|src_youngest
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|hotcopy_copy_packed_shard
argument_list|(
operator|&
name|dst_min_unpacked_rev
argument_list|,
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rev
operator|=
name|dst_min_unpacked_rev
expr_stmt|;
continue|continue;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %lu disappeared from the "
literal|"hotcopy source while hotcopy was "
literal|"in progress"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* Copy the revprop file. */
name|SVN_ERR
argument_list|(
name|hotcopy_copy_shard_file
argument_list|(
name|revprop_src_subdir
argument_list|,
name|revprop_dst_subdir
argument_list|,
name|rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* After completing a full shard, update 'current'. */
if|if
condition|(
name|max_files_per_dir
operator|&&
name|rev
operator|%
name|max_files_per_dir
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|hotcopy_update_current
argument_list|(
operator|&
name|dst_youngest
argument_list|,
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We assume that all revisions were copied now, i.e. we didn't exit the    * above loop early. 'rev' was last incremented during exit of the loop. */
name|SVN_ERR_ASSERT
argument_list|(
name|rev
operator|==
name|src_youngest
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* All revisions were copied. Update 'current'. */
name|SVN_ERR
argument_list|(
name|hotcopy_update_current
argument_list|(
operator|&
name|dst_youngest
argument_list|,
name|dst_fs
argument_list|,
name|src_youngest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the locks tree.    * This is racy in case readers are currently trying to list locks in    * the destination. However, we need to get rid of stale locks.    * This is the simplest way of doing this, so we accept this small race. */
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|dst_subdir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_subdir
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_copy_dir_recursively
argument_list|(
name|src_subdir
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy the node-origins cache tree. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_NODE_ORIGINS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_subdir
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|src_subdir
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_NODE_ORIGINS_DIR
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * NB: Data copied below is only read by writers, not readers.    *     Writers are still locked out at this point.    */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
condition|)
block|{
comment|/* Copy the rep cache and then remove entries for revisions        * younger than the destination's youngest revision. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|REP_CACHE_DB_NAME
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|REP_CACHE_DB_NAME
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_subdir
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__hotcopy
argument_list|(
name|src_subdir
argument_list|,
name|dst_subdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__del_rep_reference
argument_list|(
name|dst_fs
argument_list|,
name|dst_youngest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the txn-current file. */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_dir_file_copy
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_TXN_CURRENT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a revprop generation file exists in the source filesystem,    * reset it to zero (since this is on a different path, it will not    * overlap with data already in cache).  Also, clean up stale files    * used for the named atomics implementation. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|path_revprop_generation
argument_list|(
name|src_fs
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|write_revprop_generation_file
argument_list|(
name|dst_fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_revprop_namespace
argument_list|(
name|dst_fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Hotcopied FS is complete. Stamp it with a format file. */
name|SVN_ERR
argument_list|(
name|write_format
argument_list|(
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_FORMAT
argument_list|,
name|pool
argument_list|)
argument_list|,
name|dst_ffd
operator|->
name|format
argument_list|,
name|max_files_per_dir
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set up shared data between SRC_FS and DST_FS. */
end_comment

begin_function
specifier|static
name|void
name|hotcopy_setup_shared_fs_data
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* The common pool and mutexes are shared between src and dst filesystems.    * During hotcopy we only grab the mutexes for the destination, so there    * is no risk of dead-lock. We don't write to the src filesystem. Shared    * data for the src_fs has already been initialised in fs_hotcopy(). */
name|dst_ffd
operator|->
name|shared
operator|=
name|src_ffd
operator|->
name|shared
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Create an empty filesystem at DST_FS at DST_PATH with the same  * configuration as SRC_FS (uuid, format, and other parameters).  * After creation DST_FS has no revisions, not even revision zero. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_create_empty_dest
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
name|dst_fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|dst_path
argument_list|)
expr_stmt|;
name|dst_ffd
operator|->
name|max_files_per_dir
operator|=
name|src_ffd
operator|->
name|max_files_per_dir
expr_stmt|;
name|dst_ffd
operator|->
name|config
operator|=
name|src_ffd
operator|->
name|config
expr_stmt|;
name|dst_ffd
operator|->
name|format
operator|=
name|src_ffd
operator|->
name|format
expr_stmt|;
comment|/* Create the revision data directories. */
if|if
condition|(
name|dst_ffd
operator|->
name|max_files_per_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|path_rev_shard
argument_list|(
name|dst_fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the revprops directory. */
if|if
condition|(
name|src_ffd
operator|->
name|max_files_per_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|path_revprops_shard
argument_list|(
name|dst_fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the transaction directory. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|PATH_TXNS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the protorevs directory. */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|PATH_TXN_PROTOS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the 'current' file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_fs_fs__path_current
argument_list|(
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|?
literal|"0\n"
else|:
literal|"0 1 1\n"
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create lock file and UUID. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_lock
argument_list|(
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_uuid
argument_list|(
name|dst_fs
argument_list|,
name|src_fs
operator|->
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the min unpacked rev file. */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_min_unpacked_rev
argument_list|(
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the txn-current file if the repository supports      the transaction sequence file. */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_txn_current
argument_list|(
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_txn_current_lock
argument_list|(
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dst_ffd
operator|->
name|youngest_rev_cache
operator|=
literal|0
expr_stmt|;
name|hotcopy_setup_shared_fs_data
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__initialize_caches
argument_list|(
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__hotcopy
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|hotcopy_body_baton
name|hbb
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open
argument_list|(
name|src_fs
argument_list|,
name|src_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
block|{
specifier|const
name|char
modifier|*
name|dst_format_abspath
decl_stmt|;
name|svn_node_kind_t
name|dst_format_kind
decl_stmt|;
comment|/* Check destination format to be sure we know how to incrementally        * hotcopy to the destination FS. */
name|dst_format_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|PATH_FORMAT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_format_abspath
argument_list|,
operator|&
name|dst_format_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_format_kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Destination doesn't exist yet. Perform a normal hotcopy to a            * empty destination using the same configuration as the source. */
name|SVN_ERR
argument_list|(
name|hotcopy_create_empty_dest
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check the existing repository. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open
argument_list|(
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_incremental_check_preconditions
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hotcopy_setup_shared_fs_data
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__initialize_caches
argument_list|(
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Start out with an empty destination using the same configuration        * as the source. */
name|SVN_ERR
argument_list|(
name|hotcopy_create_empty_dest
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|hbb
operator|.
name|src_fs
operator|=
name|src_fs
expr_stmt|;
name|hbb
operator|.
name|dst_fs
operator|=
name|dst_fs
expr_stmt|;
name|hbb
operator|.
name|incremental
operator|=
name|incremental
expr_stmt|;
name|hbb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|hbb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__with_write_lock
argument_list|(
name|dst_fs
argument_list|,
name|hotcopy_body
argument_list|,
operator|&
name|hbb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

