begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* transaction.c --- transaction-related functions of FSFS  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_sha1.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Return the name of the sha1->rep mapping file in transaction TXN_ID  * within FS for the given SHA1 checksum.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_sha1
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|sha1
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_checksum_t
name|checksum
decl_stmt|;
name|checksum
operator|.
name|digest
operator|=
name|sha1
expr_stmt|;
name|checksum
operator|.
name|kind
operator|=
name|svn_checksum_sha1
expr_stmt|;
return|return
name|svn_dirent_join
argument_list|(
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
operator|&
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_changes
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_CHANGES
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_props
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_TXN_PROPS
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_props_final
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_TXN_PROPS_FINAL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|APR_INLINE
specifier|const
name|char
modifier|*
name|path_txn_next_ids
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join
argument_list|(
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|PATH_NEXT_IDS
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The vtable associated with an open transaction object. */
end_comment

begin_decl_stmt
specifier|static
name|txn_vtable_t
name|txn_vtable
init|=
block|{
name|svn_fs_fs__commit_txn
block|,
name|svn_fs_fs__abort_txn
block|,
name|svn_fs_fs__txn_prop
block|,
name|svn_fs_fs__txn_proplist
block|,
name|svn_fs_fs__change_txn_prop
block|,
name|svn_fs_fs__txn_root
block|,
name|svn_fs_fs__change_txn_props
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* FSFS-specific data being attached to svn_fs_txn_t.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fs_txn_data_t
block|{
comment|/* Strongly typed representation of the TXN's ID member. */
name|svn_fs_fs__id_part_t
name|txn_id
decl_stmt|;
block|}
name|fs_txn_data_t
typedef|;
end_typedef

begin_function
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|svn_fs_fs__txn_get_id
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|)
block|{
name|fs_txn_data_t
modifier|*
name|ftd
init|=
name|txn
operator|->
name|fsap_data
decl_stmt|;
return|return
operator|&
name|ftd
operator|->
name|txn_id
return|;
block|}
end_function

begin_comment
comment|/* Functions for working with shared transaction data. */
end_comment

begin_comment
comment|/* Return the transaction object for transaction TXN_ID from the    transaction list of filesystem FS (which must already be locked via the    txn_list_lock mutex).  If the transaction does not exist in the list,    then create a new transaction object and return it (if CREATE_NEW is    true) or return NULL (otherwise). */
end_comment

begin_function
specifier|static
name|fs_fs_shared_txn_data_t
modifier|*
name|get_shared_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|svn_boolean_t
name|create_new
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
decl_stmt|;
for|for
control|(
name|txn
operator|=
name|ffsd
operator|->
name|txns
init|;
name|txn
condition|;
name|txn
operator|=
name|txn
operator|->
name|next
control|)
if|if
condition|(
name|svn_fs_fs__id_part_eq
argument_list|(
operator|&
name|txn
operator|->
name|txn_id
argument_list|,
name|txn_id
argument_list|)
condition|)
break|break;
if|if
condition|(
name|txn
operator|||
operator|!
name|create_new
condition|)
return|return
name|txn
return|;
comment|/* Use the transaction object from the (single-object) freelist,      if one is available, or otherwise create a new object. */
if|if
condition|(
name|ffsd
operator|->
name|free_txn
condition|)
block|{
name|txn
operator|=
name|ffsd
operator|->
name|free_txn
expr_stmt|;
name|ffsd
operator|->
name|free_txn
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|ffsd
operator|->
name|common_pool
argument_list|)
decl_stmt|;
name|txn
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
block|}
name|txn
operator|->
name|txn_id
operator|=
operator|*
name|txn_id
expr_stmt|;
name|txn
operator|->
name|being_written
operator|=
name|FALSE
expr_stmt|;
comment|/* Link this transaction into the head of the list.  We will typically      be dealing with only one active transaction at a time, so it makes      sense for searches through the transaction list to look at the      newest transactions first.  */
name|txn
operator|->
name|next
operator|=
name|ffsd
operator|->
name|txns
expr_stmt|;
name|ffsd
operator|->
name|txns
operator|=
name|txn
expr_stmt|;
return|return
name|txn
return|;
block|}
end_function

begin_comment
comment|/* Free the transaction object for transaction TXN_ID, and remove it    from the transaction list of filesystem FS (which must already be    locked via the txn_list_lock mutex).  Do nothing if the transaction    does not exist. */
end_comment

begin_function
specifier|static
name|void
name|free_shared_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|txn
operator|=
name|ffsd
operator|->
name|txns
init|;
name|txn
condition|;
name|prev
operator|=
name|txn
operator|,
name|txn
operator|=
name|txn
operator|->
name|next
control|)
if|if
condition|(
name|svn_fs_fs__id_part_eq
argument_list|(
operator|&
name|txn
operator|->
name|txn_id
argument_list|,
name|txn_id
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
name|txn
condition|)
return|return;
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|txn
operator|->
name|next
expr_stmt|;
else|else
name|ffsd
operator|->
name|txns
operator|=
name|txn
operator|->
name|next
expr_stmt|;
comment|/* As we typically will be dealing with one transaction after another,      we will maintain a single-object free list so that we can hopefully      keep reusing the same transaction object. */
if|if
condition|(
operator|!
name|ffsd
operator|->
name|free_txn
condition|)
name|ffsd
operator|->
name|free_txn
operator|=
name|txn
expr_stmt|;
else|else
name|svn_pool_destroy
argument_list|(
name|txn
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Obtain a lock on the transaction list of filesystem FS, call BODY    with FS, BATON, and POOL, and then unlock the transaction list.    Return what BODY returned. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|with_txnlist_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|body
function_decl|)
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_shared_data_t
modifier|*
name|ffsd
init|=
name|ffd
operator|->
name|shared
decl_stmt|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|ffsd
operator|->
name|txn_list_lock
argument_list|,
name|body
argument_list|(
name|fs
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A structure used by unlock_proto_rev() and unlock_proto_rev_body(),    which see. */
end_comment

begin_struct
struct|struct
name|unlock_proto_rev_baton
block|{
name|svn_fs_fs__id_part_t
name|txn_id
decl_stmt|;
name|void
modifier|*
name|lockcookie
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback used in the implementation of unlock_proto_rev(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_proto_rev_body
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|struct
name|unlock_proto_rev_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_file_t
modifier|*
name|lockfile
init|=
name|b
operator|->
name|lockcookie
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
init|=
name|get_shared_txn
argument_list|(
name|fs
argument_list|,
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
if|if
condition|(
operator|!
name|txn
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't unlock unknown transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|txn
operator|->
name|being_written
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't unlock nonlocked transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_file_unlock
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't unlock prototype revision lockfile for transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|apr_err
operator|=
name|apr_file_close
argument_list|(
name|lockfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't close prototype revision lockfile for transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|txn
operator|->
name|being_written
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Unlock the prototype revision file for transaction TXN_ID in filesystem    FS using cookie LOCKCOOKIE.  The original prototype revision file must    have been closed _before_ calling this function.     Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_proto_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|void
modifier|*
name|lockcookie
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_proto_rev_baton
name|b
decl_stmt|;
name|b
operator|.
name|txn_id
operator|=
operator|*
name|txn_id
expr_stmt|;
name|b
operator|.
name|lockcookie
operator|=
name|lockcookie
expr_stmt|;
return|return
name|with_txnlist_lock
argument_list|(
name|fs
argument_list|,
name|unlock_proto_rev_body
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A structure used by get_writable_proto_rev() and    get_writable_proto_rev_body(), which see. */
end_comment

begin_struct
struct|struct
name|get_writable_proto_rev_baton
block|{
name|void
modifier|*
modifier|*
name|lockcookie
decl_stmt|;
name|svn_fs_fs__id_part_t
name|txn_id
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback used in the implementation of get_writable_proto_rev(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_writable_proto_rev_body
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|struct
name|get_writable_proto_rev_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|void
modifier|*
modifier|*
name|lockcookie
init|=
name|b
operator|->
name|lockcookie
decl_stmt|;
name|fs_fs_shared_txn_data_t
modifier|*
name|txn
init|=
name|get_shared_txn
argument_list|(
name|fs
argument_list|,
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|TRUE
argument_list|)
decl_stmt|;
comment|/* First, ensure that no thread in this process (including this one)      is currently writing to this transaction's proto-rev file. */
if|if
condition|(
name|txn
operator|->
name|being_written
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REP_BEING_WRITTEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot write to the prototype revision file "
literal|"of transaction '%s' because a previous "
literal|"representation is currently being written by "
literal|"this process"
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* We know that no thread in this process is writing to the proto-rev      file, and by extension, that no thread in this process is holding a      lock on the prototype revision lock file.  It is therefore safe      for us to attempt to lock this file, to see if any other process      is holding a lock. */
block|{
name|apr_file_t
modifier|*
name|lockfile
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|lockfile_path
init|=
name|svn_fs_fs__path_txn_proto_rev_lock
argument_list|(
name|fs
argument_list|,
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* Open the proto-rev lockfile, creating it if necessary, as it may        not exist if the transaction dates from before the lockfiles were        introduced.         ### We'd also like to use something like svn_io_file_lock2(), but            that forces us to create a subpool just to be able to unlock            the file, which seems a waste. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|lockfile
argument_list|,
name|lockfile_path
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_file_lock
argument_list|(
name|lockfile
argument_list|,
name|APR_FLOCK_EXCLUSIVE
operator||
name|APR_FLOCK_NONBLOCK
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_io_file_close
argument_list|(
name|lockfile
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REP_BEING_WRITTEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot write to the prototype revision "
literal|"file of transaction '%s' because a "
literal|"previous representation is currently "
literal|"being written by another process"
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
operator|&
name|b
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't get exclusive lock on file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|lockfile_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|lockcookie
operator|=
name|lockfile
expr_stmt|;
block|}
comment|/* We've successfully locked the transaction; mark it as such. */
name|txn
operator|->
name|being_written
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make sure the length ACTUAL_LENGTH of the proto-revision file PROTO_REV    of transaction TXN_ID in filesystem FS matches the proto-index file.    Trim any crash / failure related extra data from the proto-rev file.     If the prototype revision file is too short, we can't do much but bail out.     Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_truncate_proto_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_file_t
modifier|*
name|proto_rev
parameter_list|,
name|apr_off_t
name|actual_length
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Only relevant for newer FSFS formats. */
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* Determine file range covered by the proto-index so far.  Note that          we always append to both file, i.e. the last index entry also          corresponds to the last addition in the rev file. */
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_fs_fs__path_p2l_proto_index
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_off_t
name|indexed_length
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_next_offset
argument_list|(
operator|&
name|indexed_length
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle mismatches. */
if|if
condition|(
name|indexed_length
operator|<
name|actual_length
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|proto_rev
argument_list|,
name|indexed_length
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|indexed_length
operator|>
name|actual_length
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_INCONSISTENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"p2l proto index offset %s beyond proto"
literal|"rev file size %s for TXN %s"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|pool
argument_list|,
name|indexed_length
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|pool
argument_list|,
name|actual_length
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get a handle to the prototype revision file for transaction TXN_ID in    filesystem FS, and lock it for writing.  Return FILE, a file handle    positioned at the end of the file, and LOCKCOOKIE, a cookie that    should be passed to unlock_proto_rev() to unlock the file once FILE    has been closed.     If the prototype revision file is already locked, return error    SVN_ERR_FS_REP_BEING_WRITTEN.     Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_writable_proto_rev
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|void
modifier|*
modifier|*
name|lockcookie
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_writable_proto_rev_baton
name|b
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_off_t
name|end_offset
init|=
literal|0
decl_stmt|;
name|b
operator|.
name|lockcookie
operator|=
name|lockcookie
expr_stmt|;
name|b
operator|.
name|txn_id
operator|=
operator|*
name|txn_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|with_txnlist_lock
argument_list|(
name|fs
argument_list|,
name|get_writable_proto_rev_body
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now open the prototype revision file and seek to the end. */
name|err
operator|=
name|svn_io_file_open
argument_list|(
name|file
argument_list|,
name|svn_fs_fs__path_txn_proto_rev
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* You might expect that we could dispense with the following seek      and achieve the same thing by opening the file using APR_APPEND.      Unfortunately, APR's buffered file implementation unconditionally      places its initial file pointer at the start of the file (even for      files opened with APR_APPEND), so we need this seek to reconcile      the APR file pointer to the OS file pointer (since we need to be      able to read the current file position later). */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_io_file_seek
argument_list|(
operator|*
name|file
argument_list|,
name|APR_END
argument_list|,
operator|&
name|end_offset
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We don't want unused sections (such as leftovers from failed delta      stream) in our file.  If we use log addressing, we would need an      index entry for the unused section and that section would need to      be all NUL by convention.  So, detect and fix those cases by truncating      the protorev file. */
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|auto_truncate_proto_rev
argument_list|(
name|fs
argument_list|,
operator|*
name|file
argument_list|,
name|end_offset
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|unlock_proto_rev
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
operator|*
name|lockcookie
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lockcookie
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Callback used in the implementation of purge_shared_txn(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|purge_shared_txn_body
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|baton
decl_stmt|;
name|free_shared_txn
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|)
expr_stmt|;
name|svn_fs_fs__reset_txn_caches
argument_list|(
name|fs
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Purge the shared data for transaction TXN_ID in filesystem FS.    Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|purge_shared_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|with_txnlist_lock
argument_list|(
name|fs
argument_list|,
name|purge_shared_txn_body
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__put_node_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_boolean_t
name|fresh_txn_root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_file_t
modifier|*
name|noderev_file
decl_stmt|;
name|noderev
operator|->
name|is_fresh_txn_root
operator|=
name|fresh_txn_root
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__id_is_txn
argument_list|(
name|id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to write to non-transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|noderev_file
argument_list|,
name|svn_fs_fs__path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_TRUNCATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_noderev
argument_list|(
name|svn_stream_from_aprfile2
argument_list|(
name|noderev_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|noderev
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|fs
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|noderev_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For the in-transaction NODEREV within FS, write the sha1->rep mapping  * file in the respective transaction, if rep sharing has been enabled etc.  * Use SCATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_sha1_rep_mapping
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* if rep sharing has been enabled and the noderev has a data rep and    * its SHA-1 is known, store the rep struct under its SHA1. */
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
operator|&&
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|has_sha1
condition|)
block|{
name|apr_file_t
modifier|*
name|rep_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
init|=
name|path_txn_sha1
argument_list|(
name|fs
argument_list|,
operator|&
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
argument_list|,
name|noderev
operator|->
name|data_rep
operator|->
name|sha1_digest
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|rep_string
init|=
name|svn_fs_fs__unparse_representation
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
operator|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|rep_file
argument_list|,
name|file_name
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_TRUNCATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|rep_file
argument_list|,
name|rep_string
operator|->
name|data
argument_list|,
name|rep_string
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|rep_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unparse_dir_entry
parameter_list|(
name|svn_fs_dirent_t
modifier|*
name|dirent
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|val
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s %s"
argument_list|,
operator|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
condition|?
name|SVN_FS_FS__KIND_FILE
else|:
name|SVN_FS_FS__KIND_DIR
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|dirent
operator|->
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"K %"
name|APR_SIZE_T_FMT
literal|"\n%s\n"
literal|"V %"
name|APR_SIZE_T_FMT
literal|"\n%s\n"
argument_list|,
name|strlen
argument_list|(
name|dirent
operator|->
name|name
argument_list|)
argument_list|,
name|dirent
operator|->
name|name
argument_list|,
name|strlen
argument_list|(
name|val
argument_list|)
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the directory given as array of dirent structs in ENTRIES to STREAM.    Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unparse_dir_entries
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|dirent
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|unparse_dir_entry
argument_list|(
name|dirent
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a deep copy of SOURCE and allocate it in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_path_change2_t
modifier|*
name|path_change_dup
parameter_list|(
specifier|const
name|svn_fs_path_change2_t
modifier|*
name|source
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|result
init|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|source
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|node_rev_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|source
operator|->
name|node_rev_id
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|->
name|copyfrom_path
condition|)
name|result
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|source
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Merge the internal-use-only CHANGE into a hash of public-FS    svn_fs_path_change2_t CHANGED_PATHS, collapsing multiple changes into a    single summarical (is that real word?) change per path.  DELETIONS is    also a path->svn_fs_path_change2_t hash and contains all the deletions    that got turned into a replacement. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fold_change
parameter_list|(
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_hash_t
modifier|*
name|deletions
parameter_list|,
specifier|const
name|change_t
modifier|*
name|change
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|apr_hash_pool_get
argument_list|(
name|changed_paths
argument_list|)
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|old_change
decl_stmt|,
modifier|*
name|new_change
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|path
init|=
operator|&
name|change
operator|->
name|path
decl_stmt|;
specifier|const
name|svn_fs_path_change2_t
modifier|*
name|info
init|=
operator|&
name|change
operator|->
name|info
decl_stmt|;
if|if
condition|(
operator|(
name|old_change
operator|=
name|apr_hash_get
argument_list|(
name|changed_paths
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|)
operator|)
condition|)
block|{
comment|/* This path already exists in the hash, so we have to merge          this change into the already existing one. */
comment|/* Sanity check:  only allow NULL node revision ID in the          `reset' case. */
if|if
condition|(
operator|(
operator|!
name|info
operator|->
name|node_rev_id
operator|)
operator|&&
operator|(
name|info
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_reset
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing required node revision ID"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: we should be talking about the same node          revision ID as our last change except where the last change          was a deletion. */
if|if
condition|(
name|info
operator|->
name|node_rev_id
operator|&&
operator|(
operator|!
name|svn_fs_fs__id_eq
argument_list|(
name|old_change
operator|->
name|node_rev_id
argument_list|,
name|info
operator|->
name|node_rev_id
argument_list|)
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_delete
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: new node revision ID "
literal|"without delete"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: an add, replacement, or reset must be the first          thing to follow a deletion. */
if|if
condition|(
operator|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_delete
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|info
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_replace
operator|)
operator|||
operator|(
name|info
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_reset
operator|)
operator|||
operator|(
name|info
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_add
operator|)
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: non-add change on deleted path"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: an add can't follow anything except          a delete or reset.  */
if|if
condition|(
operator|(
name|info
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_add
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_delete
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_reset
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: add change on preexisting path"
argument_list|)
argument_list|)
return|;
comment|/* Now, merge that change in. */
switch|switch
condition|(
name|info
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_reset
case|:
comment|/* A reset here will simply remove the path change from the              hash. */
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
if|if
condition|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_add
condition|)
block|{
comment|/* If the path was introduced in this transaction via an                  add, and we are deleting it, just remove the path                  altogether.  (The caller will delete any child paths.) */
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_replace
condition|)
block|{
comment|/* A deleting a 'replace' restore the original deletion. */
name|new_change
operator|=
name|apr_hash_get
argument_list|(
name|deletions
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|new_change
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|new_change
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A deletion overrules a previous change (modify). */
name|new_change
operator|=
name|path_change_dup
argument_list|(
name|info
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|new_change
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|svn_fs_path_change_add
case|:
case|case
name|svn_fs_path_change_replace
case|:
comment|/* An add at this point must be following a previous delete,              so treat it just like a replace.  Remember the original              deletion such that we are able to delete this path again              (the replacement may have changed node kind and id). */
name|new_change
operator|=
name|path_change_dup
argument_list|(
name|info
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_change
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|new_change
argument_list|)
expr_stmt|;
comment|/* Remember the original change.            * Make sure to allocate the hash key in a durable pool. */
name|apr_hash_set
argument_list|(
name|deletions
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|deletions
argument_list|)
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|)
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|old_change
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_modify
case|:
default|default:
comment|/* If the new change modifies some attribute of the node, set              the corresponding flag, whether it already was set or not.              Note: We do not reset a flag to FALSE if a change is undone. */
if|if
condition|(
name|info
operator|->
name|text_mod
condition|)
name|old_change
operator|->
name|text_mod
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|prop_mod
condition|)
name|old_change
operator|->
name|prop_mod
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|mergeinfo_mod
operator|==
name|svn_tristate_true
condition|)
name|old_change
operator|->
name|mergeinfo_mod
operator|=
name|svn_tristate_true
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* Add this path.  The API makes no guarantees that this (new) key          will not be retained.  Thus, we copy the key into the target pool          to ensure a proper lifetime.  */
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|path
operator|->
name|data
argument_list|,
name|path
operator|->
name|len
argument_list|)
argument_list|,
name|path
operator|->
name|len
argument_list|,
name|path_change_dup
argument_list|(
name|info
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton type to be used with process_changes(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|process_changes_baton_t
block|{
comment|/* Folded list of path changes. */
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
comment|/* Path changes that are deletions and have been turned into      replacements.  If those replacements get deleted again, this      container contains the record that we have to revert to. */
name|apr_hash_t
modifier|*
name|deletions
decl_stmt|;
block|}
name|process_changes_baton_t
typedef|;
end_typedef

begin_comment
comment|/* An implementation of svn_fs_fs__change_receiver_t.    Examine all the changed path entries in CHANGES and store them in    *CHANGED_PATHS.  Folding is done to remove redundant or unnecessary    data. Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_changes
parameter_list|(
name|void
modifier|*
name|baton_p
parameter_list|,
name|change_t
modifier|*
name|change
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|process_changes_baton_t
modifier|*
name|baton
init|=
name|baton_p
decl_stmt|;
name|SVN_ERR
argument_list|(
name|fold_change
argument_list|(
name|baton
operator|->
name|changed_paths
argument_list|,
name|baton
operator|->
name|deletions
argument_list|,
name|change
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, if our change was a deletion or replacement, we have to      blow away any changes thus far on paths that are (or, were)      children of this path.      ### i won't bother with another iteration pool here -- at      most we talking about a few extra dups of paths into what      is already a temporary subpool.   */
if|if
condition|(
operator|(
name|change
operator|->
name|info
operator|.
name|change_kind
operator|==
name|svn_fs_path_change_delete
operator|)
operator|||
operator|(
name|change
operator|->
name|info
operator|.
name|change_kind
operator|==
name|svn_fs_path_change_replace
operator|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* a potential child path must contain at least 2 more chars          (the path separator plus at least one char for the name).          Also, we should not assume that all paths have been normalized          i.e. some might have trailing path separators.       */
name|apr_ssize_t
name|path_len
init|=
name|change
operator|->
name|path
operator|.
name|len
decl_stmt|;
name|apr_ssize_t
name|min_child_len
init|=
name|path_len
operator|==
literal|0
condition|?
literal|1
else|:
name|change
operator|->
name|path
operator|.
name|data
index|[
name|path_len
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|?
name|path_len
operator|+
literal|1
else|:
name|path_len
operator|+
literal|2
decl_stmt|;
comment|/* CAUTION: This is the inner loop of an O(n^2) algorithm.          The number of changes to process may be>> 1000.          Therefore, keep the inner loop as tight as possible.       */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|baton
operator|->
name|changed_paths
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
comment|/* KEY is the path. */
specifier|const
name|void
modifier|*
name|path
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|old_change
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|klen
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|old_change
argument_list|)
expr_stmt|;
comment|/* If we come across a child of our path, remove it.              Call svn_fspath__skip_ancestor only if there is a chance that              this is actually a sub-path.            */
if|if
condition|(
name|klen
operator|>=
name|min_child_len
condition|)
block|{
specifier|const
name|char
modifier|*
name|child
decl_stmt|;
name|child
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|change
operator|->
name|path
operator|.
name|data
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|&&
name|child
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|apr_hash_set
argument_list|(
name|baton
operator|->
name|changed_paths
argument_list|,
name|path
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_changes_fetch
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changed_paths_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|apr_hash_t
modifier|*
name|changed_paths
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|process_changes_baton_t
name|baton
decl_stmt|;
name|baton
operator|.
name|changed_paths
operator|=
name|changed_paths
expr_stmt|;
name|baton
operator|.
name|deletions
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path_txn_changes
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_changes_incrementally
argument_list|(
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|process_changes
argument_list|,
operator|&
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|changed_paths_p
operator|=
name|changed_paths
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__paths_changed
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changed_paths_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changes
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_changes
argument_list|(
operator|&
name|changes
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|changed_paths
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changes
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|change_t
modifier|*
name|change
init|=
name|APR_ARRAY_IDX
argument_list|(
name|changes
argument_list|,
name|i
argument_list|,
name|change_t
operator|*
argument_list|)
decl_stmt|;
name|apr_hash_set
argument_list|(
name|changed_paths
argument_list|,
name|change
operator|->
name|path
operator|.
name|data
argument_list|,
name|change
operator|->
name|path
operator|.
name|len
argument_list|,
operator|&
name|change
operator|->
name|info
argument_list|)
expr_stmt|;
block|}
operator|*
name|changed_paths_p
operator|=
name|changed_paths
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy a revision node-rev SRC into the current transaction TXN_ID in    the filesystem FS.  This is only used to create the root of a transaction.    Allocations are from POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_new_txn_noderev_from_rev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|svn_fs_id_t
modifier|*
name|src
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|node_id
decl_stmt|,
modifier|*
name|copy_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|src
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__id_is_txn
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copying from transactions not allowed"
argument_list|)
argument_list|)
return|;
name|noderev
operator|->
name|predecessor_id
operator|=
name|noderev
operator|->
name|id
expr_stmt|;
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* For the transaction root, the copyroot never changes. */
name|node_id
operator|=
name|svn_fs_fs__id_node_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
name|node_id
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A structure used by get_and_increment_txn_key_body(). */
end_comment

begin_struct
struct|struct
name|get_and_increment_txn_key_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|apr_uint64_t
name|txn_number
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Callback used in the implementation of create_txn_dir().  This gets    the current base 36 value in PATH_TXN_CURRENT and increments it.    It returns the original value by the baton. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_and_increment_txn_key_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_and_increment_txn_key_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_current_filename
init|=
name|svn_fs_fs__path_txn_current
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|char
name|new_id_str
index|[
name|SVN_INT64_BUFFER_SIZE
operator|+
literal|1
index|]
decl_stmt|;
comment|/* add space for a newline */
name|apr_size_t
name|line_length
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_content
argument_list|(
operator|&
name|buf
argument_list|,
name|txn_current_filename
argument_list|,
name|cb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* assign the current txn counter value to our result */
name|cb
operator|->
name|txn_number
operator|=
name|svn__base36toui64
argument_list|(
name|NULL
argument_list|,
name|buf
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* remove trailing newlines */
name|line_length
operator|=
name|svn__ui64tobase36
argument_list|(
name|new_id_str
argument_list|,
name|cb
operator|->
name|txn_number
operator|+
literal|1
argument_list|)
expr_stmt|;
name|new_id_str
index|[
name|line_length
index|]
operator|=
literal|'\n'
expr_stmt|;
comment|/* Increment the key and add a trailing \n to the string so the      txn-current file has a newline in it. */
name|SVN_ERR
argument_list|(
name|svn_io_write_atomic
argument_list|(
name|txn_current_filename
argument_list|,
name|new_id_str
argument_list|,
name|line_length
operator|+
literal|1
argument_list|,
name|txn_current_filename
comment|/* copy_perms path */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a unique directory for a transaction in FS based on revision REV.    Return the ID for this transaction in *ID_P and *TXN_ID.  Use a sequence    value in the transaction ID to prevent reuse of transaction IDs. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_txn_dir
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_and_increment_txn_key_baton
name|cb
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_dir
decl_stmt|;
comment|/* Get the current transaction sequence value, which is a base-36      number, from the txn-current file, and write an      incremented value back out to the file.  Place the revision      number the transaction is based off into the transaction id. */
name|cb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|cb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__with_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|get_and_increment_txn_key_body
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txn_id
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|txn_id
operator|->
name|number
operator|=
name|cb
operator|.
name|txn_number
expr_stmt|;
operator|*
name|id_p
operator|=
name|svn_fs_fs__id_txn_unparse
argument_list|(
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|txn_dir
operator|=
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_io_dir_make
argument_list|(
name|txn_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a unique directory for a transaction in FS based on revision    REV.  Return the ID for this transaction in *ID_P and *TXN_ID.  This    implementation is used in svn 1.4 and earlier repositories and is    kept in 1.5 and greater to support the --pre-1.4-compatible and    --pre-1.5-compatible repository creation options.  Reused    transaction IDs are possible with this implementation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_txn_dir_pre_1_5
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|unique_path
decl_stmt|,
modifier|*
name|prefix
decl_stmt|;
comment|/* Try to create directories named "<txndir>/<rev>-<uniqueifier>.txn". */
name|prefix
operator|=
name|svn_dirent_join
argument_list|(
name|svn_fs_fs__path_txns_dir
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
literal|99999
condition|;
name|i
operator|++
control|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|unique_path
operator|=
name|apr_psprintf
argument_list|(
name|subpool
argument_list|,
literal|"%s-%u"
name|PATH_EXT_TXN
argument_list|,
name|prefix
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_dir_make
argument_list|(
name|unique_path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
comment|/* We succeeded.  Return the basename minus the ".txn" extension. */
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_dirent_basename
argument_list|(
name|unique_path
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
operator|*
name|id_p
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|strlen
argument_list|(
name|PATH_EXT_TXN
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_txn_parse
argument_list|(
name|txn_id
argument_list|,
operator|*
name|id_p
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to create transaction directory "
literal|"in '%s' for revision %ld"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|fs_txn_data_t
modifier|*
name|ftd
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|;
name|txn
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
name|ftd
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ftd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the txn_id. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|create_txn_dir
argument_list|(
operator|&
name|txn
operator|->
name|id
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|create_txn_dir_pre_1_5
argument_list|(
operator|&
name|txn
operator|->
name|id
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|txn
operator|->
name|base_rev
operator|=
name|rev
expr_stmt|;
name|txn
operator|->
name|vtable
operator|=
operator|&
name|txn_vtable
expr_stmt|;
name|txn
operator|->
name|fsap_data
operator|=
name|ftd
expr_stmt|;
operator|*
name|txn_p
operator|=
name|txn
expr_stmt|;
comment|/* Create a new root node for this transaction. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rev_get_root
argument_list|(
operator|&
name|root_id
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_new_txn_noderev_from_rev
argument_list|(
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an empty rev file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_fs__path_txn_proto_rev
argument_list|(
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an empty rev-lock file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_fs__path_txn_proto_rev_lock
argument_list|(
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create an empty changes file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|path_txn_changes
argument_list|(
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the next-ids file. */
return|return
name|svn_io_file_create
argument_list|(
name|path_txn_next_ids
argument_list|(
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"0 0\n"
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Store the property list for transaction TXN_ID in PROPLIST.    Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_txn_proplist
parameter_list|(
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Check for issue #3696. (When we find and fix the cause, we can change    * this to an assertion.) */
if|if
condition|(
operator|!
name|txn_id
operator|||
operator|!
name|svn_fs_fs__id_txn_used
argument_list|(
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Internal error: a null transaction id was "
literal|"passed to get_txn_proplist()"
argument_list|)
argument_list|)
return|;
comment|/* Open the transaction properties file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|path_txn_props
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in the property list. */
name|err
operator|=
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrapf
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"malformed property list in transaction '%s'"
argument_list|)
argument_list|,
name|path_txn_props
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Save the property list PROPS as the revprops for transaction TXN_ID    in FS.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_txn_proplist
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_boolean_t
name|final
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Write out the new file contents to BUF. */
name|buf
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|1024
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|buf
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|props
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the transaction properties file and write new contents to it. */
name|SVN_ERR
argument_list|(
name|svn_io_write_atomic
argument_list|(
operator|(
name|final
condition|?
name|path_txn_props_final
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
else|:
name|path_txn_props
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
operator|)
argument_list|,
name|buf
operator|->
name|data
argument_list|,
name|buf
operator|->
name|len
argument_list|,
name|NULL
comment|/* copy_perms_path */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__change_txn_prop
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|props
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_prop_t
name|prop
decl_stmt|;
name|prop
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|prop
operator|.
name|value
operator|=
name|value
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
name|prop
expr_stmt|;
return|return
name|svn_fs_fs__change_txn_props
argument_list|(
name|txn
argument_list|,
name|props
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__change_txn_props
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_txn_data_t
modifier|*
name|ftd
init|=
name|txn
operator|->
name|fsap_data
decl_stmt|;
name|apr_hash_t
modifier|*
name|txn_prop
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|get_txn_proplist
argument_list|(
name|txn_prop
argument_list|,
name|txn
operator|->
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Here - and here only - we need to deal with the possibility that the      transaction property file doesn't yet exist.  The rest of the      implementation assumes that the file exists, but we're called to set the      initial transaction properties as the transaction is being created. */
if|if
condition|(
name|err
operator|&&
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|)
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|props
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txn_prop
argument_list|,
name|SVN_FS__PROP_TXN_CLIENT_DATE
argument_list|)
operator|&&
operator|!
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|txn_prop
argument_list|,
name|SVN_FS__PROP_TXN_CLIENT_DATE
argument_list|,
name|svn_string_create
argument_list|(
literal|"1"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|txn_prop
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Create a new version of the file and write out the new props. */
comment|/* Open the transaction properties file. */
name|SVN_ERR
argument_list|(
name|set_txn_proplist
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|txn_prop
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_txn
parameter_list|(
name|transaction_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|transaction_t
modifier|*
name|txn
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|;
name|txn
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
name|root_id
operator|=
name|svn_fs_fs__id_txn_create_root
argument_list|(
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|root_id
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|root_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|txn
operator|->
name|base_id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|txn
operator|->
name|copies
operator|=
name|NULL
expr_stmt|;
operator|*
name|txn_p
operator|=
name|txn
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out the currently available next node_id NODE_ID and copy_id    COPY_ID for transaction TXN_ID in filesystem FS.  The next node-id is    used both for creating new unique nodes for the given transaction, as    well as uniquifying representations.  Perform temporary allocations in    POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_next_ids
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_uint64_t
name|node_id
parameter_list|,
name|apr_uint64_t
name|copy_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|char
name|buffer
index|[
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
operator|+
literal|2
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buffer
decl_stmt|;
name|p
operator|+=
name|svn__ui64tobase36
argument_list|(
name|p
argument_list|,
name|node_id
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|' '
expr_stmt|;
name|p
operator|+=
name|svn__ui64tobase36
argument_list|(
name|p
argument_list|,
name|copy_id
argument_list|)
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'\n'
expr_stmt|;
operator|*
operator|(
name|p
operator|++
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path_txn_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_TRUNCATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|p
operator|-
name|buffer
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Find out what the next unique node-id and copy-id are for    transaction TXN_ID in filesystem FS.  Store the results in *NODE_ID    and *COPY_ID.  The next node-id is used both for creating new unique    nodes for the given transaction, as well as uniquifying representations.    Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_next_ids
parameter_list|(
name|apr_uint64_t
modifier|*
name|node_id
parameter_list|,
name|apr_uint64_t
modifier|*
name|copy_id
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_content
argument_list|(
operator|&
name|buf
argument_list|,
name|path_txn_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse this into two separate strings. */
name|str
operator|=
name|buf
operator|->
name|data
expr_stmt|;
operator|*
name|node_id
operator|=
name|svn__base36toui64
argument_list|(
operator|&
name|str
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|' '
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"next-id file corrupt"
argument_list|)
argument_list|)
return|;
operator|++
name|str
expr_stmt|;
operator|*
name|copy_id
operator|=
name|svn__base36toui64
argument_list|(
operator|&
name|str
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\n'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"next-id file corrupt"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get a new and unique to this transaction node-id for transaction    TXN_ID in filesystem FS.  Store the new node-id in *NODE_ID_P.    Node-ids are guaranteed to be unique to this transction, but may    not necessarily be sequential.  Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_new_txn_node_id
parameter_list|(
name|svn_fs_fs__id_part_t
modifier|*
name|node_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint64_t
name|node_id
decl_stmt|,
name|copy_id
decl_stmt|;
comment|/* First read in the current next-ids file. */
name|SVN_ERR
argument_list|(
name|read_next_ids
argument_list|(
operator|&
name|node_id
argument_list|,
operator|&
name|copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id_p
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|node_id_p
operator|->
name|number
operator|=
name|node_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
operator|++
name|node_id
argument_list|,
name|copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__reserve_copy_id
parameter_list|(
name|svn_fs_fs__id_part_t
modifier|*
name|copy_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint64_t
name|node_id
decl_stmt|,
name|copy_id
decl_stmt|;
comment|/* First read in the current next-ids file. */
name|SVN_ERR
argument_list|(
name|read_next_ids
argument_list|(
operator|&
name|node_id
argument_list|,
operator|&
name|copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this is an in-txn ID now */
name|copy_id_p
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|copy_id_p
operator|->
name|number
operator|=
name|copy_id
expr_stmt|;
comment|/* Update the ID counter file */
name|SVN_ERR
argument_list|(
name|write_next_ids
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|node_id
argument_list|,
operator|++
name|copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create_node
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|copy_id
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_fs__id_part_t
name|node_id
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
comment|/* Get a new node-id for this node. */
name|SVN_ERR
argument_list|(
name|get_new_txn_node_id
argument_list|(
operator|&
name|node_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
operator|&
name|node_id
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|id
operator|=
name|id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__purge_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id_str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_fs__id_part_t
name|txn_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_txn_parse
argument_list|(
operator|&
name|txn_id
argument_list|,
name|txn_id_str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the shared transaction object associated with this transaction. */
name|SVN_ERR
argument_list|(
name|purge_shared_txn
argument_list|(
name|fs
argument_list|,
operator|&
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the directory associated with this transaction. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
operator|&
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT
condition|)
block|{
comment|/* Delete protorev and its lock, which aren't in the txn          directory.  It's OK if they don't exist (for example, if this          is post-commit and the proto-rev has been moved into          place). */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_fs_fs__path_txn_proto_rev
argument_list|(
name|fs
argument_list|,
operator|&
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_fs_fs__path_txn_proto_rev_lock
argument_list|(
name|fs
argument_list|,
operator|&
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__abort_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, purge the transaction. */
name|SVN_ERR_W
argument_list|(
name|svn_fs_fs__purge_txn
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Transaction '%s' cleanup failed"
argument_list|)
argument_list|,
name|txn
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Assign the UNIQUIFIER member of REP based on the current state of TXN_ID  * in FS.  Allocate the uniquifier in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_uniquifier
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_fs__id_part_t
name|temp
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_new_txn_node_id
argument_list|(
operator|&
name|temp
argument_list|,
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|uniquifier
operator|.
name|noderev_txn_id
operator|=
name|rep
operator|->
name|txn_id
expr_stmt|;
name|rep
operator|->
name|uniquifier
operator|.
name|number
operator|=
name|temp
operator|.
name|number
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the TXN_ID member of REP is in use.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_txn_rep
parameter_list|(
specifier|const
name|representation_t
modifier|*
name|rep
parameter_list|)
block|{
return|return
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Mark the TXN_ID member of REP as "unused".  */
end_comment

begin_function
specifier|static
name|void
name|reset_txn_in_rep
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|)
block|{
name|svn_fs_fs__id_txn_reset
argument_list|(
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_entry
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|node_revision_t
modifier|*
name|parent_noderev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|parent_noderev
operator|->
name|data_rep
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|svn_fs_fs__path_txn_node_children
argument_list|(
name|fs
argument_list|,
name|parent_noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stream_t
modifier|*
name|out
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|rep
operator|||
operator|!
name|is_txn_rep
argument_list|(
name|rep
argument_list|)
condition|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
comment|/* Before we can modify the directory, we need to dump its old          contents into a mutable representation file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|parent_noderev
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|unparse_dir_entries
argument_list|(
name|entries
argument_list|,
name|out
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Mark the node-rev's data rep as mutable. */
name|rep
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|rep
operator|->
name|txn_id
operator|=
operator|*
name|txn_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|set_uniquifier
argument_list|(
name|fs
argument_list|,
name|rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|parent_noderev
operator|->
name|data_rep
operator|=
name|rep
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|parent_noderev
operator|->
name|id
argument_list|,
name|parent_noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The directory rep is already mutable, so just open it for append. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_APPEND
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* if we have a directory cache for this transaction, update it */
if|if
condition|(
name|ffd
operator|->
name|txn_dir_cache
condition|)
block|{
comment|/* build parameters: (name, new entry) pair */
specifier|const
name|char
modifier|*
name|key
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|parent_noderev
operator|->
name|id
argument_list|,
name|subpool
argument_list|)
operator|->
name|data
decl_stmt|;
name|replace_baton_t
name|baton
decl_stmt|;
name|baton
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|id
condition|)
block|{
name|baton
operator|.
name|new_entry
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
operator|.
name|new_entry
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|->
name|name
operator|=
name|name
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|baton
operator|.
name|new_entry
operator|->
name|id
operator|=
name|id
expr_stmt|;
block|}
comment|/* actually update the cached directory (if cached) */
name|SVN_ERR
argument_list|(
name|svn_cache__set_partial
argument_list|(
name|ffd
operator|->
name|txn_dir_cache
argument_list|,
name|key
argument_list|,
name|svn_fs_fs__replace_dir_entry
argument_list|,
operator|&
name|baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Append an incremental hash entry for the entry change. */
if|if
condition|(
name|id
condition|)
block|{
name|svn_fs_dirent_t
name|entry
decl_stmt|;
name|entry
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|entry
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|entry
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|SVN_ERR
argument_list|(
name|unparse_dir_entry
argument_list|(
operator|&
name|entry
argument_list|,
name|out
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|out
argument_list|,
name|subpool
argument_list|,
literal|"D %"
name|APR_SIZE_T_FMT
literal|"\n%s\n"
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__add_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_fs_path_change_kind_t
name|change_kind
parameter_list|,
name|svn_boolean_t
name|text_mod
parameter_list|,
name|svn_boolean_t
name|prop_mod
parameter_list|,
name|svn_boolean_t
name|mergeinfo_mod
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|apr_hash_t
modifier|*
name|changes
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Not using APR_BUFFERED to append change in one atomic write operation. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|path_txn_changes
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_APPEND
operator||
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|=
name|svn_fs__path_change_create_internal
argument_list|(
name|id
argument_list|,
name|change_kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|change
operator|->
name|text_mod
operator|=
name|text_mod
expr_stmt|;
name|change
operator|->
name|prop_mod
operator|=
name|prop_mod
expr_stmt|;
name|change
operator|->
name|mergeinfo_mod
operator|=
name|mergeinfo_mod
condition|?
name|svn_tristate_true
else|:
name|svn_tristate_false
expr_stmt|;
name|change
operator|->
name|node_kind
operator|=
name|node_kind
expr_stmt|;
name|change
operator|->
name|copyfrom_known
operator|=
name|TRUE
expr_stmt|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
if|if
condition|(
name|copyfrom_path
condition|)
name|change
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|copyfrom_path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|changes
argument_list|,
name|path
argument_list|,
name|change
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_changes
argument_list|(
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fs
argument_list|,
name|changes
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If the transaction TXN_ID in FS uses logical addressing, store the  * (ITEM_INDEX, OFFSET) pair in the txn's log-to-phys proto index file.  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_l2p_index_entry
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_fs_fs__path_l2p_proto_index
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_add_entry
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|item_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If the transaction TXN_ID in FS uses logical addressing, store ENTRY  * in the phys-to-log proto index file of transaction TXN_ID.  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_p2l_index_entry
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_fs_fs__path_p2l_proto_index
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_open
argument_list|(
operator|&
name|file
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_add_entry
argument_list|(
name|file
argument_list|,
name|entry
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate an item index for the given MY_OFFSET in the transaction TXN_ID  * of file system FS and return it in *ITEM_INDEX.  For old formats, it  * will simply return the offset as item index; in new formats, it will  * increment the txn's item index counter file and store the mapping in  * the proto index file.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|allocate_item_index
parameter_list|(
name|apr_uint64_t
modifier|*
name|item_index
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_off_t
name|my_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|char
name|buffer
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_boolean_t
name|eof
init|=
name|FALSE
decl_stmt|;
name|apr_size_t
name|to_write
decl_stmt|;
name|apr_size_t
name|read
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
comment|/* read number, increment it and write it back to disk */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|svn_fs_fs__path_txn_item_index
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
argument_list|,
operator|&
name|read
argument_list|,
operator|&
name|eof
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
condition|)
name|SVN_ERR
argument_list|(
name|svn_cstring_atoui64
argument_list|(
name|item_index
argument_list|,
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|item_index
operator|=
name|SVN_FS_FS__ITEM_INDEX_FIRST_USER
expr_stmt|;
name|to_write
operator|=
name|svn__ui64toa
argument_list|(
name|buffer
argument_list|,
operator|*
name|item_index
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|to_write
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write log-to-phys index */
name|SVN_ERR
argument_list|(
name|store_l2p_index_entry
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|my_offset
argument_list|,
operator|*
name|item_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|item_index
operator|=
operator|(
name|apr_uint64_t
operator|)
name|my_offset
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used by fnv1a_write_handler to calculate the FNV checksum  * before passing the data on to the INNER_STREAM.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fnv1a_stream_baton_t
block|{
name|svn_stream_t
modifier|*
name|inner_stream
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|context
decl_stmt|;
block|}
name|fnv1a_stream_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implement svn_write_fn_t.  * Update checksum and pass data on to inner stream.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fnv1a_write_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|fnv1a_stream_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|b
operator|->
name|context
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|b
operator|->
name|inner_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a stream that calculates a FNV checksum in *CONTEXT  * over all data written to the stream and passes that data on  * to INNER_STREAM.  Allocate objects in POOL.  */
end_comment

begin_function
specifier|static
name|svn_stream_t
modifier|*
name|fnv1a_wrap_stream
parameter_list|(
name|svn_checksum_ctx_t
modifier|*
modifier|*
name|context
parameter_list|,
name|svn_stream_t
modifier|*
name|inner_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|outer_stream
decl_stmt|;
name|fnv1a_stream_baton_t
modifier|*
name|baton
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
name|baton
operator|->
name|inner_stream
operator|=
name|inner_stream
expr_stmt|;
name|baton
operator|->
name|context
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_fnv1a_32x4
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|context
operator|=
name|baton
operator|->
name|context
expr_stmt|;
name|outer_stream
operator|=
name|svn_stream_create
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|outer_stream
argument_list|,
name|fnv1a_write_handler
argument_list|)
expr_stmt|;
return|return
name|outer_stream
return|;
block|}
end_function

begin_comment
comment|/* Set *DIGEST to the FNV checksum calculated in CONTEXT.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fnv1a_checksum_finalize
parameter_list|(
name|apr_uint32_t
modifier|*
name|digest
parameter_list|,
name|svn_checksum_ctx_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|checksum
argument_list|,
name|context
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_fnv1a_32x4
argument_list|)
expr_stmt|;
operator|*
name|digest
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
specifier|const
name|apr_uint32_t
operator|*
operator|)
operator|(
name|checksum
operator|->
name|digest
operator|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This baton is used by the representation writing streams.  It keeps    track of the checksum information as well as the total size of the    representation so far. */
end_comment

begin_struct
struct|struct
name|rep_write_baton
block|{
comment|/* The FS we are writing to. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* Actual file to which we are writing. */
name|svn_stream_t
modifier|*
name|rep_stream
decl_stmt|;
comment|/* A stream from the delta combiner.  Data written here gets      deltified, then eventually written to rep_stream. */
name|svn_stream_t
modifier|*
name|delta_stream
decl_stmt|;
comment|/* Where is this representation header stored. */
name|apr_off_t
name|rep_offset
decl_stmt|;
comment|/* Start of the actual data. */
name|apr_off_t
name|delta_start
decl_stmt|;
comment|/* How many bytes have been written to this rep already. */
name|svn_filesize_t
name|rep_size
decl_stmt|;
comment|/* The node revision for which we're writing out info. */
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Actual output file. */
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* Lock 'cookie' used to unlock the output file once we've finished      writing to it. */
name|void
modifier|*
name|lockcookie
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|sha1_checksum_ctx
decl_stmt|;
comment|/* calculate a modified FNV-1a checksum of the on-disk representation */
name|svn_checksum_ctx_t
modifier|*
name|fnv1a_checksum_ctx
decl_stmt|;
comment|/* Local / scratch pool, available for temporary allocations. */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
comment|/* Outer / result pool. */
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Handler for the write method of the representation writable stream.    BATON is a rep_write_baton, DATA is the data to write, and *LEN is    the length of this data. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|b
operator|->
name|md5_checksum_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|b
operator|->
name|sha1_checksum_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|rep_size
operator|+=
operator|*
name|len
expr_stmt|;
comment|/* If we are writing a delta, use that stream. */
if|if
condition|(
name|b
operator|->
name|delta_stream
condition|)
return|return
name|svn_stream_write
argument_list|(
name|b
operator|->
name|delta_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|svn_stream_write
argument_list|(
name|b
operator|->
name|rep_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *SPANNED to the number of shards touched when walking WALK steps on  * NODEREV's predecessor chain in FS.  Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|shards_spanned
parameter_list|(
name|int
modifier|*
name|spanned
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|int
name|walk
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|shard_size
init|=
name|ffd
operator|->
name|max_files_per_dir
condition|?
name|ffd
operator|->
name|max_files_per_dir
else|:
literal|1
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|count
init|=
name|walk
condition|?
literal|1
else|:
literal|0
decl_stmt|;
comment|/* The start of a walk already touches a shard. */
name|svn_revnum_t
name|shard
decl_stmt|,
name|last_shard
init|=
name|ffd
operator|->
name|youngest_rev_cache
operator|/
name|shard_size
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|walk
operator|--
operator|&&
name|noderev
operator|->
name|predecessor_count
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|shard
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
operator|/
name|shard_size
expr_stmt|;
if|if
condition|(
name|shard
operator|!=
name|last_shard
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|last_shard
operator|=
name|shard
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|spanned
operator|=
name|count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a node-revision NODEREV in filesystem FS, return the    representation in *REP to use as the base for a text representation    delta if PROPS is FALSE.  If PROPS has been set, a suitable props    base representation will be returned.  Perform temporary allocations    in *POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|choose_delta_base
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_boolean_t
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* The zero-based index (counting from the "oldest" end), along NODEREVs line    * predecessors, of the node-rev we will use as delta base. */
name|int
name|count
decl_stmt|;
comment|/* The length of the linear part of a delta chain.  (Delta chains use    * skip-delta bits for the high-order bits and are linear in the low-order    * bits.) */
name|int
name|walk
decl_stmt|;
name|node_revision_t
modifier|*
name|base
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* If we have no predecessors, or that one is empty, then use the empty    * stream as a base. */
if|if
condition|(
operator|!
name|noderev
operator|->
name|predecessor_count
condition|)
block|{
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Flip the rightmost '1' bit of the predecessor count to determine      which file rev (counting from 0) we want to use.  (To see why      count& (count - 1) unsets the rightmost set bit, think about how      you decrement a binary number.) */
name|count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
name|count
operator|=
name|count
operator|&
operator|(
name|count
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Finding the delta base over a very long distance can become extremely      expensive for very deep histories, possibly causing client timeouts etc.      OTOH, this is a rare operation and its gains are minimal. Lets simply      start deltification anew close every other 1000 changes or so.  */
name|walk
operator|=
name|noderev
operator|->
name|predecessor_count
operator|-
name|count
expr_stmt|;
if|if
condition|(
name|walk
operator|>
operator|(
name|int
operator|)
name|ffd
operator|->
name|max_deltification_walk
condition|)
block|{
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We use skip delta for limiting the number of delta operations      along very long node histories.  Close to HEAD however, we create      a linear history to minimize delta size.  */
if|if
condition|(
name|walk
operator|<
operator|(
name|int
operator|)
name|ffd
operator|->
name|max_linear_deltification
condition|)
block|{
name|int
name|shards
decl_stmt|;
name|SVN_ERR
argument_list|(
name|shards_spanned
argument_list|(
operator|&
name|shards
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|walk
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We also don't want the linear deltification to span more shards          than if deltas we used in a simple skip-delta scheme. */
if|if
condition|(
operator|(
literal|1
operator|<<
operator|(
operator|--
name|shards
operator|)
operator|)
operator|<=
name|walk
condition|)
name|count
operator|=
name|noderev
operator|->
name|predecessor_count
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Walk back a number of predecessors equal to the difference      between count and the original predecessor count.  (For example,      if noderev has ten predecessors and we want the eighth file rev,      walk back two predecessors.) */
name|base
operator|=
name|noderev
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|count
operator|++
operator|)
operator|<
name|noderev
operator|->
name|predecessor_count
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|base
argument_list|,
name|fs
argument_list|,
name|base
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* return a suitable base representation */
operator|*
name|rep
operator|=
name|props
condition|?
name|base
operator|->
name|prop_rep
else|:
name|base
operator|->
name|data_rep
expr_stmt|;
comment|/* if we encountered a shared rep, its parent chain may be different    * from the node-rev parent chain. */
if|if
condition|(
operator|*
name|rep
condition|)
block|{
name|int
name|chain_length
init|=
literal|0
decl_stmt|;
name|int
name|shard_count
init|=
literal|0
decl_stmt|;
comment|/* Very short rep bases are simply not worth it as we are unlikely        * to re-coup the deltification space overhead of 20+ bytes. */
name|svn_filesize_t
name|rep_size
init|=
operator|(
operator|*
name|rep
operator|)
operator|->
name|expanded_size
condition|?
operator|(
operator|*
name|rep
operator|)
operator|->
name|expanded_size
else|:
operator|(
operator|*
name|rep
operator|)
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|rep_size
operator|<
literal|64
condition|)
block|{
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Check whether the length of the deltification chain is acceptable.        * Otherwise, shared reps may form a non-skipping delta chain in        * extreme cases. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_chain_length
argument_list|(
operator|&
name|chain_length
argument_list|,
operator|&
name|shard_count
argument_list|,
operator|*
name|rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some reasonable limit, depending on how acceptable longer linear        * chains are in this repo.  Also, allow for some minimal chain. */
if|if
condition|(
name|chain_length
operator|>=
literal|2
operator|*
operator|(
name|int
operator|)
name|ffd
operator|->
name|max_linear_deltification
operator|+
literal|2
condition|)
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
elseif|else
comment|/* To make it worth opening additional shards / pack files, we          * require that the reps have a certain minimal size.  To deltify          * against a rep in different shard, the lower limit is 512 bytes          * and doubles with every extra shard to visit along the delta          * chain. */
if|if
condition|(
name|shard_count
operator|>
literal|1
operator|&&
operator|(
operator|(
name|svn_filesize_t
operator|)
literal|128
operator|<<
name|shard_count
operator|)
operator|>=
name|rep_size
condition|)
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Something went wrong and the pool for the rep write is being    cleared before we've finished writing the rep.  So we need    to remove the rep from the protorevfile and we need to unlock    the protorevfile. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|rep_write_cleanup
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
init|=
name|data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Truncate and close the protorevfile. */
name|err
operator|=
name|svn_io_file_trunc
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|rep_offset
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_file_close
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove our lock regardless of any preceding errors so that the      being_written flag is always removed and stays consistent with the      file lock which will be removed no matter what since the pool is      going away. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|unlock_proto_rev
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|svn_fs_fs__id_txn_id
argument_list|(
name|b
operator|->
name|noderev
operator|->
name|id
argument_list|)
argument_list|,
name|b
operator|->
name|lockcookie
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|rc
init|=
name|err
operator|->
name|apr_err
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|rc
return|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Get a rep_write_baton and store it in *WB_P for the representation    indicated by NODEREV in filesystem FS.  Perform allocations in    POOL.  Only appropriate for file contents, not for props or    directory contents. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_get_baton
parameter_list|(
name|struct
name|rep_write_baton
modifier|*
modifier|*
name|wb_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|representation_t
modifier|*
name|base_rep
decl_stmt|;
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|svn_txdelta_window_handler_t
name|wh
decl_stmt|;
name|void
modifier|*
name|whb
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|diff_version
init|=
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_SVNDIFF1_FORMAT
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|svn_fs_fs__rep_header_t
name|header
init|=
block|{
literal|0
block|}
decl_stmt|;
name|b
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|sha1_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|->
name|result_pool
operator|=
name|pool
expr_stmt|;
name|b
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|rep_size
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|noderev
operator|=
name|noderev
expr_stmt|;
comment|/* Open the prototype rev file and seek to its end. */
name|SVN_ERR
argument_list|(
name|get_writable_proto_rev
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|b
operator|->
name|lockcookie
argument_list|,
name|fs
argument_list|,
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|b
operator|->
name|rep_stream
operator|=
name|fnv1a_wrap_stream
argument_list|(
operator|&
name|b
operator|->
name|fnv1a_checksum_ctx
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|b
operator|->
name|rep_offset
argument_list|,
name|file
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the base for this delta. */
name|SVN_ERR
argument_list|(
name|choose_delta_base
argument_list|(
operator|&
name|base_rep
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|source
argument_list|,
name|fs
argument_list|,
name|base_rep
argument_list|,
name|TRUE
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the rep header. */
if|if
condition|(
name|base_rep
condition|)
block|{
name|header
operator|.
name|base_revision
operator|=
name|base_rep
operator|->
name|revision
expr_stmt|;
name|header
operator|.
name|base_item_index
operator|=
name|base_rep
operator|->
name|item_index
expr_stmt|;
name|header
operator|.
name|base_length
operator|=
name|base_rep
operator|->
name|size
expr_stmt|;
name|header
operator|.
name|type
operator|=
name|svn_fs_fs__rep_delta
expr_stmt|;
block|}
else|else
block|{
name|header
operator|.
name|type
operator|=
name|svn_fs_fs__rep_self_delta
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_rep_header
argument_list|(
operator|&
name|header
argument_list|,
name|b
operator|->
name|rep_stream
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now determine the offset of the actual svndiff data. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|b
operator|->
name|delta_start
argument_list|,
name|file
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cleanup in case something goes wrong. */
name|apr_pool_cleanup_register
argument_list|(
name|b
operator|->
name|scratch_pool
argument_list|,
name|b
argument_list|,
name|rep_write_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Prepare to write the svndiff data. */
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|wh
argument_list|,
operator|&
name|whb
argument_list|,
name|b
operator|->
name|rep_stream
argument_list|,
name|diff_version
argument_list|,
name|ffd
operator|->
name|delta_compression_level
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|delta_stream
operator|=
name|svn_txdelta_target_push
argument_list|(
name|wh
argument_list|,
name|whb
argument_list|,
name|source
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|wb_p
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For REP->SHA1_CHECKSUM, try to find an already existing representation    in FS and return it in *OUT_REP.  If no such representation exists or    if rep sharing has been disabled for FS, NULL will be returned.  Since    there may be new duplicate representations within the same uncommitted    revision, those can be passed in REPS_HASH (maps a sha1 digest onto    representation_t*), otherwise pass in NULL for REPS_HASH.    Use RESULT_POOL for *OLD_REP  allocations and SCRATCH_POOL for temporaries.    The lifetime of *OLD_REP is limited by both, RESULT_POOL and REP lifetime.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_shared_rep
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|old_rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Return NULL, if rep sharing has been disabled. */
operator|*
name|old_rep
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out.  Start with the hash lookup      because it is cheepest. */
if|if
condition|(
name|reps_hash
condition|)
operator|*
name|old_rep
operator|=
name|apr_hash_get
argument_list|(
name|reps_hash
argument_list|,
name|rep
operator|->
name|sha1_digest
argument_list|,
name|APR_SHA1_DIGESTSIZE
argument_list|)
expr_stmt|;
comment|/* If we haven't found anything yet, try harder and consult our DB. */
if|if
condition|(
operator|*
name|old_rep
operator|==
name|NULL
condition|)
block|{
name|svn_checksum_t
name|checksum
decl_stmt|;
name|checksum
operator|.
name|digest
operator|=
name|rep
operator|->
name|sha1_digest
expr_stmt|;
name|checksum
operator|.
name|kind
operator|=
name|svn_checksum_sha1
expr_stmt|;
name|err
operator|=
name|svn_fs_fs__get_rep_reference
argument_list|(
name|old_rep
argument_list|,
name|fs
argument_list|,
operator|&
name|checksum
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* ### Other error codes that we shouldn't mask out? */
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
condition|)
block|{
if|if
condition|(
operator|*
name|old_rep
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_rep
argument_list|(
operator|*
name|old_rep
argument_list|,
name|fs
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
operator|||
name|SVN_ERROR_IN_CATEGORY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|SVN_ERR_MALFUNC_CATEGORY_START
argument_list|)
condition|)
block|{
comment|/* Fatal error; don't mask it.               In particular, this block is triggered when the rep-cache refers              to revisions in the future.  We signal that as a corruption situation              since, once those revisions are less than youngest (because of more              commits), the rep-cache would be invalid.            */
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Something's wrong with the rep-sharing index.  We can continue              without rep-sharing, but warn.            */
call|(
name|fs
operator|->
name|warning
call|)
argument_list|(
name|fs
operator|->
name|warning_baton
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|old_rep
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* look for intra-revision matches (usually data reps but not limited      to them in case props happen to look like some data rep)    */
if|if
condition|(
operator|*
name|old_rep
operator|==
name|NULL
operator|&&
name|is_txn_rep
argument_list|(
name|rep
argument_list|)
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
init|=
name|path_txn_sha1
argument_list|(
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|rep
operator|->
name|sha1_digest
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* in our txn, is there a rep file named with the wanted SHA1?          If so, read it and use that rep.        */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|file_name
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|rep_string
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|rep_string
argument_list|,
name|file_name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__parse_representation
argument_list|(
name|old_rep
argument_list|,
name|rep_string
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|old_rep
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We don't want 0-length PLAIN representations to replace non-0-length      ones (see issue #4554).  Take into account that EXPANDED_SIZE may be      0 in which case we have to check the on-disk SIZE.  Also, this doubles      as a simple guard against general rep-cache induced corruption. */
if|if
condition|(
operator|(
operator|(
operator|*
name|old_rep
operator|)
operator|->
name|expanded_size
operator|!=
name|rep
operator|->
name|expanded_size
operator|)
operator|||
operator|(
operator|(
name|rep
operator|->
name|expanded_size
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|(
operator|*
name|old_rep
operator|)
operator|->
name|size
operator|!=
name|rep
operator|->
name|size
operator|)
operator|)
condition|)
block|{
operator|*
name|old_rep
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* Add information that is missing in the cached data.          Use the old rep for this content. */
name|memcpy
argument_list|(
operator|(
operator|*
name|old_rep
operator|)
operator|->
name|md5_digest
argument_list|,
name|rep
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|old_rep
operator|)
operator|->
name|uniquifier
operator|=
name|rep
operator|->
name|uniquifier
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the hash sum calculation results from MD5_CTX, SHA1_CTX into REP.  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|digests_final
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
specifier|const
name|svn_checksum_ctx_t
modifier|*
name|md5_ctx
parameter_list|,
specifier|const
name|svn_checksum_ctx_t
modifier|*
name|sha1_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|checksum
argument_list|,
name|md5_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
name|svn_checksum_size
argument_list|(
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|checksum
argument_list|,
name|sha1_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|has_sha1
operator|=
name|checksum
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|has_sha1
condition|)
name|memcpy
argument_list|(
name|rep
operator|->
name|sha1_digest
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
name|svn_checksum_size
argument_list|(
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Close handler for the representation write stream.  BATON is a    rep_write_baton.  Writes out a new node-rev that correctly    references the representation we just finished writing. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_write_contents_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|representation_t
modifier|*
name|old_rep
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|rep
operator|=
name|apr_pcalloc
argument_list|(
name|b
operator|->
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close our delta stream so the last bits of svndiff are written      out. */
if|if
condition|(
name|b
operator|->
name|delta_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|b
operator|->
name|delta_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the length of the svndiff data. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|size
operator|=
name|offset
operator|-
name|b
operator|->
name|delta_start
expr_stmt|;
comment|/* Fill in the rest of the representation field. */
name|rep
operator|->
name|expanded_size
operator|=
name|b
operator|->
name|rep_size
expr_stmt|;
name|rep
operator|->
name|txn_id
operator|=
operator|*
name|svn_fs_fs__id_txn_id
argument_list|(
name|b
operator|->
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|set_uniquifier
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|rep
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Finalize the checksum. */
name|SVN_ERR
argument_list|(
name|digests_final
argument_list|(
name|rep
argument_list|,
name|b
operator|->
name|md5_checksum_ctx
argument_list|,
name|b
operator|->
name|sha1_checksum_ctx
argument_list|,
name|b
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out. */
name|SVN_ERR
argument_list|(
name|get_shared_rep
argument_list|(
operator|&
name|old_rep
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|rep
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|result_pool
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rep
condition|)
block|{
comment|/* We need to erase from the protorev the data we just wrote. */
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|rep_offset
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the old rep for this content. */
name|b
operator|->
name|noderev
operator|->
name|data_rep
operator|=
name|old_rep
expr_stmt|;
block|}
else|else
block|{
comment|/* Write out our cosmetic end marker. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|b
operator|->
name|rep_stream
argument_list|,
literal|"ENDREP\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|allocate_item_index
argument_list|(
operator|&
name|rep
operator|->
name|item_index
argument_list|,
name|b
operator|->
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|b
operator|->
name|rep_offset
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|noderev
operator|->
name|data_rep
operator|=
name|rep
expr_stmt|;
block|}
comment|/* Remove cleanup callback. */
name|apr_pool_cleanup_kill
argument_list|(
name|b
operator|->
name|scratch_pool
argument_list|,
name|b
argument_list|,
name|rep_write_cleanup
argument_list|)
expr_stmt|;
comment|/* Write out the new node-rev information. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|b
operator|->
name|noderev
operator|->
name|id
argument_list|,
name|b
operator|->
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|old_rep
condition|)
block|{
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
name|entry
operator|.
name|offset
operator|=
name|b
operator|->
name|rep_offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|size
operator|=
name|offset
operator|-
name|b
operator|->
name|rep_offset
expr_stmt|;
name|entry
operator|.
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_FILE_REP
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|number
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fnv1a_checksum_finalize
argument_list|(
operator|&
name|entry
operator|.
name|fnv1_checksum
argument_list|,
name|b
operator|->
name|fnv1a_checksum_ctx
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_p2l_index_entry
argument_list|(
name|b
operator|->
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
operator|&
name|entry
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|b
operator|->
name|file
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the sha1->rep mapping *after* we successfully written node    * revision to disk. */
if|if
condition|(
operator|!
name|old_rep
condition|)
name|SVN_ERR
argument_list|(
name|store_sha1_rep_mapping
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|b
operator|->
name|noderev
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|unlock_proto_rev
argument_list|(
name|b
operator|->
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|b
operator|->
name|lockcookie
argument_list|,
name|b
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|b
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store a writable stream in *CONTENTS_P that will receive all data    written and store it as the file data representation referenced by    NODEREV in filesystem FS.  Perform temporary allocations in    POOL.  Only appropriate for file data, not props or directory    contents. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_representation
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_write_baton
modifier|*
name|wb
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__id_is_txn
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to write to non-transaction '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|rep_write_get_baton
argument_list|(
operator|&
name|wb
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|svn_stream_create
argument_list|(
name|wb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_write_contents
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_write_contents_close
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't set text contents of a directory"
argument_list|)
argument_list|)
return|;
return|return
name|set_representation
argument_list|(
name|stream
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__create_successor
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|new_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|old_idp
parameter_list|,
name|node_revision_t
modifier|*
name|new_noderev
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|copy_id
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
operator|!
name|copy_id
condition|)
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|old_idp
argument_list|)
expr_stmt|;
name|id
operator|=
name|svn_fs_fs__id_txn_create
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|old_idp
argument_list|)
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_noderev
operator|->
name|id
operator|=
name|id
expr_stmt|;
if|if
condition|(
operator|!
name|new_noderev
operator|->
name|copyroot_path
condition|)
block|{
name|new_noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|new_noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
name|new_noderev
operator|->
name|copyroot_rev
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|new_noderev
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|new_noderev
operator|->
name|id
argument_list|,
name|new_noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|new_id_p
operator|=
name|id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_proplist
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|svn_fs_fs__path_txn_node_props
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stream_t
modifier|*
name|out
decl_stmt|;
comment|/* Dump the property list to the mutable property file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|filename
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_TRUNCATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|out
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|out
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Mark the node-rev's prop rep as mutable, if not already done. */
if|if
condition|(
operator|!
name|noderev
operator|->
name|prop_rep
operator|||
operator|!
name|is_txn_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|)
condition|)
block|{
name|noderev
operator|->
name|prop_rep
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
operator|->
name|prop_rep
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
operator|=
operator|*
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__put_node_revision
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|noderev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This baton is used by the stream created for write_container_rep. */
end_comment

begin_struct
struct|struct
name|write_container_baton
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_size_t
name|size
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|md5_ctx
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|sha1_ctx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The handler for the write_container_rep stream.  BATON is a    write_container_baton, DATA has the data to write and *LEN is the number    of bytes to write. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_container_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|write_container_baton
modifier|*
name|whb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|whb
operator|->
name|md5_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|whb
operator|->
name|sha1_ctx
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|whb
operator|->
name|stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|->
name|size
operator|+=
operator|*
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback function type.  Write the data provided by BATON into STREAM. */
end_comment

begin_typedef
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|collection_writer_t
function_decl|)
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* Implement collection_writer_t writing the C string->svn_string_t hash    given as BATON. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_hash_to_stream
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|hash
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implement collection_writer_t writing the svn_fs_dirent_t* array given    as BATON. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_directory_to_stream
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|dir
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|unparse_dir_entries
argument_list|(
name|dir
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out the COLLECTION as a text representation to file FILE using    WRITER.  In the process, record position, the total size of the dump and    MD5 as well as SHA1 in REP.   Add the representation of type ITEM_TYPE to    the indexes if necessary.  If rep sharing has been enabled and REPS_HASH    is not NULL, it will be used in addition to the on-disk cache to find    earlier reps with the same content.  When such existing reps can be    found, we will truncate the one just written from the file and return    the existing rep.  Perform temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_container_rep
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|void
modifier|*
name|collection
parameter_list|,
name|collection_writer_t
name|writer
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|apr_uint32_t
name|item_type
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|struct
name|write_container_baton
modifier|*
name|whb
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|fnv1a_checksum_ctx
decl_stmt|;
name|representation_t
modifier|*
name|old_rep
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|whb
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|->
name|stream
operator|=
name|fnv1a_wrap_stream
argument_list|(
operator|&
name|fnv1a_checksum_ctx
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|whb
operator|->
name|md5_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|sha1_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|whb
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_container_handler
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|whb
operator|->
name|stream
argument_list|,
literal|"PLAIN\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|writer
argument_list|(
name|stream
argument_list|,
name|collection
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the results. */
name|SVN_ERR
argument_list|(
name|digests_final
argument_list|(
name|rep
argument_list|,
name|whb
operator|->
name|md5_ctx
argument_list|,
name|whb
operator|->
name|sha1_ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out. */
name|SVN_ERR
argument_list|(
name|get_shared_rep
argument_list|(
operator|&
name|old_rep
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|reps_hash
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rep
condition|)
block|{
comment|/* We need to erase from the protorev the data we just wrote. */
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the old rep for this content. */
name|memcpy
argument_list|(
name|rep
argument_list|,
name|old_rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
comment|/* Write out our cosmetic end marker. */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|whb
operator|->
name|stream
argument_list|,
literal|"ENDREP\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|allocate_item_index
argument_list|(
operator|&
name|rep
operator|->
name|item_index
argument_list|,
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|size
operator|=
name|offset
operator|-
name|entry
operator|.
name|offset
expr_stmt|;
name|entry
operator|.
name|type
operator|=
name|item_type
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|number
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fnv1a_checksum_finalize
argument_list|(
operator|&
name|entry
operator|.
name|fnv1_checksum
argument_list|,
name|fnv1a_checksum_ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_p2l_index_entry
argument_list|(
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
operator|&
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update the representation */
name|rep
operator|->
name|size
operator|=
name|whb
operator|->
name|size
expr_stmt|;
name|rep
operator|->
name|expanded_size
operator|=
name|whb
operator|->
name|size
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out the COLLECTION pertaining to the NODEREV in FS as a deltified    text representation to file FILE using WRITER.  In the process, record the    total size and the md5 digest in REP and add the representation of type    ITEM_TYPE to the indexes if necessary.  If rep sharing has been enabled and    REPS_HASH is not NULL, it will be used in addition to the on-disk cache to    find earlier reps with the same content.  When such existing reps can be    found, we will truncate the one just written from the file and return the    existing rep.     If ITEM_TYPE is IS_PROPS equals SVN_FS_FS__ITEM_TYPE_*_PROPS, assume    that we want to a props representation as the base for our delta.    Perform temporary allocations in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_container_delta_rep
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|void
modifier|*
name|collection
parameter_list|,
name|collection_writer_t
name|writer
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|apr_uint32_t
name|item_type
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_txdelta_window_handler_t
name|diff_wh
decl_stmt|;
name|void
modifier|*
name|diff_whb
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|representation_t
modifier|*
name|base_rep
decl_stmt|;
name|representation_t
modifier|*
name|old_rep
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|fnv1a_checksum_ctx
decl_stmt|;
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|svn_fs_fs__rep_header_t
name|header
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_off_t
name|rep_end
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|delta_start
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|struct
name|write_container_baton
modifier|*
name|whb
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|diff_version
init|=
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_SVNDIFF1_FORMAT
condition|?
literal|1
else|:
literal|0
decl_stmt|;
name|svn_boolean_t
name|is_props
init|=
operator|(
name|item_type
operator|==
name|SVN_FS_FS__ITEM_TYPE_FILE_PROPS
operator|)
operator|||
operator|(
name|item_type
operator|==
name|SVN_FS_FS__ITEM_TYPE_DIR_PROPS
operator|)
decl_stmt|;
comment|/* Get the base for this delta. */
name|SVN_ERR
argument_list|(
name|choose_delta_base
argument_list|(
operator|&
name|base_rep
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|is_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|source
argument_list|,
name|fs
argument_list|,
name|base_rep
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out the rep header. */
if|if
condition|(
name|base_rep
condition|)
block|{
name|header
operator|.
name|base_revision
operator|=
name|base_rep
operator|->
name|revision
expr_stmt|;
name|header
operator|.
name|base_item_index
operator|=
name|base_rep
operator|->
name|item_index
expr_stmt|;
name|header
operator|.
name|base_length
operator|=
name|base_rep
operator|->
name|size
expr_stmt|;
name|header
operator|.
name|type
operator|=
name|svn_fs_fs__rep_delta
expr_stmt|;
block|}
else|else
block|{
name|header
operator|.
name|type
operator|=
name|svn_fs_fs__rep_self_delta
expr_stmt|;
block|}
name|file_stream
operator|=
name|fnv1a_wrap_stream
argument_list|(
operator|&
name|fnv1a_checksum_ctx
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_rep_header
argument_list|(
operator|&
name|header
argument_list|,
name|file_stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|delta_start
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare to write the svndiff data. */
name|svn_txdelta_to_svndiff3
argument_list|(
operator|&
name|diff_wh
argument_list|,
operator|&
name|diff_whb
argument_list|,
name|file_stream
argument_list|,
name|diff_version
argument_list|,
name|ffd
operator|->
name|delta_compression_level
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|whb
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|whb
argument_list|)
argument_list|)
expr_stmt|;
name|whb
operator|->
name|stream
operator|=
name|svn_txdelta_target_push
argument_list|(
name|diff_wh
argument_list|,
name|diff_whb
argument_list|,
name|source
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|whb
operator|->
name|md5_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|whb
operator|->
name|sha1_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* serialize the hash */
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|whb
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_container_handler
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|writer
argument_list|(
name|stream
argument_list|,
name|collection
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|whb
operator|->
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store the results. */
name|SVN_ERR
argument_list|(
name|digests_final
argument_list|(
name|rep
argument_list|,
name|whb
operator|->
name|md5_ctx
argument_list|,
name|whb
operator|->
name|sha1_ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check and see if we already have a representation somewhere that's      identical to the one we just wrote out. */
name|SVN_ERR
argument_list|(
name|get_shared_rep
argument_list|(
operator|&
name|old_rep
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|reps_hash
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_rep
condition|)
block|{
comment|/* We need to erase from the protorev the data we just wrote. */
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|file
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the old rep for this content. */
name|memcpy
argument_list|(
name|rep
argument_list|,
name|old_rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
comment|/* Write out our cosmetic end marker. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|rep_end
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|file_stream
argument_list|,
literal|"ENDREP\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|allocate_item_index
argument_list|(
operator|&
name|rep
operator|->
name|item_index
argument_list|,
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|size
operator|=
name|offset
operator|-
name|entry
operator|.
name|offset
expr_stmt|;
name|entry
operator|.
name|type
operator|=
name|item_type
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|number
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fnv1a_checksum_finalize
argument_list|(
operator|&
name|entry
operator|.
name|fnv1_checksum
argument_list|,
name|fnv1a_checksum_ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_p2l_index_entry
argument_list|(
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
operator|&
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update the representation */
name|rep
operator|->
name|expanded_size
operator|=
name|whb
operator|->
name|size
expr_stmt|;
name|rep
operator|->
name|size
operator|=
name|rep_end
operator|-
name|delta_start
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Sanity check ROOT_NODEREV, a candidate for being the root node-revision    of (not yet committed) revision REV in FS.  Use POOL for temporary    allocations.     If you change this function, consider updating svn_fs_fs__verify() too.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|validate_root_noderev
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|root_noderev
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|head_revnum
init|=
name|rev
operator|-
literal|1
decl_stmt|;
name|int
name|head_predecessor_count
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rev
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Compute HEAD_PREDECESSOR_COUNT. */
block|{
name|svn_fs_root_t
modifier|*
name|head_revision
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|head_root_id
decl_stmt|;
name|node_revision_t
modifier|*
name|head_root_noderev
decl_stmt|;
comment|/* Get /@HEAD's noderev. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|head_revision
argument_list|,
name|fs
argument_list|,
name|head_revnum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|head_root_id
argument_list|,
name|head_revision
argument_list|,
literal|"/"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|head_root_noderev
argument_list|,
name|fs
argument_list|,
name|head_root_id
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|head_predecessor_count
operator|=
name|head_root_noderev
operator|->
name|predecessor_count
expr_stmt|;
block|}
comment|/* Check that the root noderev's predecessor count equals REV.       This kind of corruption was seen on svn.apache.org (both on      the root noderev and on other fspaths' noderevs); see      issue #4129.       Normally (rev == root_noderev->predecessor_count), but here we      use a more roundabout check that should only trigger on new instances      of the corruption, rather then trigger on each and every new commit      to a repository that has triggered the bug somewhere in its root      noderev's history.    */
if|if
condition|(
name|root_noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
operator|&&
operator|(
name|root_noderev
operator|->
name|predecessor_count
operator|-
name|head_predecessor_count
operator|)
operator|!=
operator|(
name|rev
operator|-
name|head_revnum
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"predecessor count for "
literal|"the root node-revision is wrong: "
literal|"found (%d+%ld != %d), committing r%ld"
argument_list|)
argument_list|,
name|head_predecessor_count
argument_list|,
name|rev
operator|-
name|head_revnum
argument_list|,
comment|/* This is equal to 1. */
name|root_noderev
operator|->
name|predecessor_count
argument_list|,
name|rev
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given the potentially txn-local id PART, update that to a permanent ID  * based on the REVISION currently being written and the START_ID for that  * revision.  Use the repo FORMAT to decide which implementation to use.  */
end_comment

begin_function
specifier|static
name|void
name|get_final_id
parameter_list|(
name|svn_fs_fs__id_part_t
modifier|*
name|part
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint64_t
name|start_id
parameter_list|,
name|int
name|format
parameter_list|)
block|{
if|if
condition|(
name|part
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
if|if
condition|(
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
block|{
name|part
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
block|}
else|else
block|{
name|part
operator|->
name|revision
operator|=
literal|0
expr_stmt|;
name|part
operator|->
name|number
operator|+=
name|start_id
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Copy a node-revision specified by id ID in fileystem FS from a    transaction into the proto-rev-file FILE.  Set *NEW_ID_P to a    pointer to the new node-id which will be allocated in POOL.    If this is a directory, copy all children as well.     START_NODE_ID and START_COPY_ID are    the first available node and copy ids for this filesystem, for older    FS formats.     REV is the revision number that this proto-rev-file will represent.     INITIAL_OFFSET is the offset of the proto-rev-file on entry to    commit_body.     If REPS_TO_CACHE is not NULL, append to it a copy (allocated in    REPS_POOL) of each data rep that is new in this revision.     If REPS_HASH is not NULL, append copies (allocated in REPS_POOL)    of the representations of each property rep that is new in this    revision.     AT_ROOT is true if the node revision being written is the root    node-revision.  It is only controls additional sanity checking    logic.     Temporary allocations are also from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_final_rev
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|new_id_p
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_uint64_t
name|start_node_id
parameter_list|,
name|apr_uint64_t
name|start_copy_id
parameter_list|,
name|apr_off_t
name|initial_offset
parameter_list|,
name|apr_array_header_t
modifier|*
name|reps_to_cache
parameter_list|,
name|apr_hash_t
modifier|*
name|reps_hash
parameter_list|,
name|apr_pool_t
modifier|*
name|reps_pool
parameter_list|,
name|svn_boolean_t
name|at_root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|apr_off_t
name|my_offset
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|new_id
decl_stmt|;
name|svn_fs_fs__id_part_t
name|node_id
decl_stmt|,
name|copy_id
decl_stmt|,
name|rev_item
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|svn_fs_fs__id_txn_id
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|fnv1a_checksum_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
operator|*
name|new_id_p
operator|=
name|NULL
expr_stmt|;
comment|/* Check to see if this is a transaction node. */
if|if
condition|(
operator|!
name|svn_fs_fs__id_is_txn
argument_list|(
name|id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* This is a directory.  Write out all the children first. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_final_rev
argument_list|(
operator|&
name|new_id
argument_list|,
name|file
argument_list|,
name|rev
argument_list|,
name|fs
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|start_node_id
argument_list|,
name|start_copy_id
argument_list|,
name|initial_offset
argument_list|,
name|reps_to_cache
argument_list|,
name|reps_hash
argument_list|,
name|reps_pool
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_id
operator|&&
operator|(
name|svn_fs_fs__id_rev
argument_list|(
name|new_id
argument_list|)
operator|==
name|rev
operator|)
condition|)
name|dirent
operator|->
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|new_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|is_txn_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|)
condition|)
block|{
comment|/* Write out the contents of this directory as a text rep. */
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|deltify_directories
condition|)
name|SVN_ERR
argument_list|(
name|write_container_delta_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|file
argument_list|,
name|entries
argument_list|,
name|write_directory_to_stream
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|NULL
argument_list|,
name|SVN_FS_FS__ITEM_TYPE_DIR_REP
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|write_container_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|file
argument_list|,
name|entries
argument_list|,
name|write_directory_to_stream
argument_list|,
name|fs
argument_list|,
name|NULL
argument_list|,
name|SVN_FS_FS__ITEM_TYPE_DIR_REP
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|reset_txn_in_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* This is a file.  We should make sure the data rep, if it          exists in a "this" state, gets rewritten to our new revision          num. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|is_txn_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|)
condition|)
block|{
name|reset_txn_in_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* See issue 3845.  Some unknown mechanism caused the                  protorev file to get truncated, so check for that                  here.  */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|->
name|item_index
operator|+
name|noderev
operator|->
name|data_rep
operator|->
name|size
operator|>
name|initial_offset
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Truncated protorev file detected"
argument_list|)
argument_list|)
return|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Fix up the property reps. */
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|is_txn_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|apr_uint32_t
name|item_type
init|=
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
name|SVN_FS_FS__ITEM_TYPE_DIR_PROPS
else|:
name|SVN_FS_FS__ITEM_TYPE_FILE_PROPS
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|prop_rep
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|deltify_properties
condition|)
name|SVN_ERR
argument_list|(
name|write_container_delta_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|file
argument_list|,
name|proplist
argument_list|,
name|write_hash_to_stream
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|reps_hash
argument_list|,
name|item_type
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|write_container_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|file
argument_list|,
name|proplist
argument_list|,
name|write_hash_to_stream
argument_list|,
name|fs
argument_list|,
name|reps_hash
argument_list|,
name|item_type
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|reset_txn_in_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|)
expr_stmt|;
block|}
comment|/* Convert our temporary ID into a permanent revision one. */
name|node_id
operator|=
operator|*
name|svn_fs_fs__id_node_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|get_final_id
argument_list|(
operator|&
name|node_id
argument_list|,
name|rev
argument_list|,
name|start_node_id
argument_list|,
name|ffd
operator|->
name|format
argument_list|)
expr_stmt|;
name|copy_id
operator|=
operator|*
name|svn_fs_fs__id_copy_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|get_final_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|rev
argument_list|,
name|start_copy_id
argument_list|,
name|ffd
operator|->
name|format
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|copyroot_rev
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|noderev
operator|->
name|copyroot_rev
operator|=
name|rev
expr_stmt|;
comment|/* root nodes have a fixed ID in log addressing mode */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|my_offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
operator|&&
name|at_root
condition|)
block|{
comment|/* reference the root noderev from the log-to-phys index */
name|rev_item
operator|.
name|number
operator|=
name|SVN_FS_FS__ITEM_INDEX_ROOT_NODE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_l2p_index_entry
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|my_offset
argument_list|,
name|rev_item
operator|.
name|number
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|allocate_item_index
argument_list|(
operator|&
name|rev_item
operator|.
name|number
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|my_offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rev_item
operator|.
name|revision
operator|=
name|rev
expr_stmt|;
name|new_id
operator|=
name|svn_fs_fs__id_rev_create
argument_list|(
operator|&
name|node_id
argument_list|,
operator|&
name|copy_id
argument_list|,
operator|&
name|rev_item
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|id
operator|=
name|new_id
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
comment|/* Save the data representation's hash in the rep cache. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|==
name|rev
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|reps_to_cache
operator|&&
name|reps_pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|reps_to_cache
argument_list|,
name|representation_t
operator|*
argument_list|)
operator|=
name|svn_fs_fs__rep_copy
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|reps_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|noderev
operator|->
name|prop_rep
operator|->
name|revision
operator|==
name|rev
condition|)
block|{
comment|/* Add new property reps to hash and on-disk cache. */
name|representation_t
modifier|*
name|copy
init|=
name|svn_fs_fs__rep_copy
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|reps_pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|reps_to_cache
operator|&&
name|reps_pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|reps_to_cache
argument_list|,
name|representation_t
operator|*
argument_list|)
operator|=
name|copy
expr_stmt|;
name|apr_hash_set
argument_list|(
name|reps_hash
argument_list|,
name|copy
operator|->
name|sha1_digest
argument_list|,
name|APR_SHA1_DIGESTSIZE
argument_list|,
name|copy
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* don't serialize SHA1 for dirs to disk (waste of space) */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|noderev
operator|->
name|data_rep
operator|->
name|has_sha1
operator|=
name|FALSE
expr_stmt|;
comment|/* don't serialize SHA1 for props to disk (waste of space) */
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
name|noderev
operator|->
name|prop_rep
operator|->
name|has_sha1
operator|=
name|FALSE
expr_stmt|;
comment|/* Workaround issue #4031: is-fresh-txn-root in revision files. */
name|noderev
operator|->
name|is_fresh_txn_root
operator|=
name|FALSE
expr_stmt|;
comment|/* Write out our new node-revision. */
if|if
condition|(
name|at_root
condition|)
name|SVN_ERR
argument_list|(
name|validate_root_noderev
argument_list|(
name|fs
argument_list|,
name|noderev
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|file_stream
operator|=
name|fnv1a_wrap_stream
argument_list|(
operator|&
name|fnv1a_checksum_ctx
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_noderev
argument_list|(
name|file_stream
argument_list|,
name|noderev
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|fs
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reference the root noderev from the log-to-phys index */
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
name|rev_item
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|.
name|offset
operator|=
name|my_offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|my_offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|size
operator|=
name|my_offset
operator|-
name|entry
operator|.
name|offset
expr_stmt|;
name|entry
operator|.
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_NODEREV
expr_stmt|;
name|entry
operator|.
name|item
operator|=
name|rev_item
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fnv1a_checksum_finalize
argument_list|(
operator|&
name|entry
operator|.
name|fnv1_checksum
argument_list|,
name|fnv1a_checksum_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_p2l_index_entry
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
operator|&
name|entry
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return our ID that references the revision file. */
operator|*
name|new_id_p
operator|=
name|noderev
operator|->
name|id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the changed path info CHANGED_PATHS from transaction TXN_ID to the    permanent rev-file FILE in filesystem FS.  *OFFSET_P is set the to offset    in the file of the beginning of this information.  Perform temporary    allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_final_changed_path_info
parameter_list|(
name|apr_off_t
modifier|*
name|offset_p
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|fnv1a_checksum_ctx
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write to target file& calculate checksum */
name|stream
operator|=
name|fnv1a_wrap_stream
argument_list|(
operator|&
name|fnv1a_checksum_ctx
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_changes
argument_list|(
name|stream
argument_list|,
name|fs
argument_list|,
name|changed_paths
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|offset_p
operator|=
name|offset
expr_stmt|;
comment|/* reference changes from the indexes */
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
name|entry
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|size
operator|=
name|offset
operator|-
name|entry
operator|.
name|offset
expr_stmt|;
name|entry
operator|.
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_CHANGES
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|number
operator|=
name|SVN_FS_FS__ITEM_INDEX_CHANGES
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fnv1a_checksum_finalize
argument_list|(
operator|&
name|entry
operator|.
name|fnv1_checksum
argument_list|,
name|fnv1a_checksum_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_p2l_index_entry
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
operator|&
name|entry
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_l2p_index_entry
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|entry
operator|.
name|offset
argument_list|,
name|SVN_FS_FS__ITEM_INDEX_CHANGES
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open a new svn_fs_t handle to FS, set that handle's concept of "current    youngest revision" to NEW_REV, and call svn_fs_fs__verify_root() on    NEW_REV's revision root.     Intended to be called as the very last step in a commit before 'current'    is bumped.  This implies that we are holding the write lock. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_as_revision_before_current_plus_plus
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|new_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SVN_DEBUG
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|ft
decl_stmt|;
comment|/* fs++ == ft */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ft_ffd
decl_stmt|;
name|apr_hash_t
modifier|*
name|fs_config
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ffd
operator|->
name|svn_fs_open_
argument_list|)
expr_stmt|;
comment|/* make sure FT does not simply return data cached by other instances    * but actually retrieves it from disk at least once.    */
name|fs_config
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_NS
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ffd
operator|->
name|svn_fs_open_
argument_list|(
operator|&
name|ft
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|fs_config
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ft_ffd
operator|=
name|ft
operator|->
name|fsap_data
expr_stmt|;
comment|/* Don't let FT consult rep-cache.db, either. */
name|ft_ffd
operator|->
name|rep_sharing_allowed
operator|=
name|FALSE
expr_stmt|;
comment|/* Time travel! */
name|ft_ffd
operator|->
name|youngest_rev_cache
operator|=
name|new_rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|ft
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|root
operator|->
name|is_txn_root
operator|==
name|FALSE
operator|&&
name|root
operator|->
name|rev
operator|==
name|new_rev
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ft_ffd
operator|->
name|youngest_rev_cache
operator|==
name|new_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__verify_root
argument_list|(
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* SVN_DEBUG */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Update the 'current' file to hold the correct next node and copy_ids    from transaction TXN_ID in filesystem FS.  The current revision is    set to REV.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_final_current
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_uint64_t
name|start_node_id
parameter_list|,
name|apr_uint64_t
name|start_copy_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint64_t
name|txn_node_id
decl_stmt|;
name|apr_uint64_t
name|txn_copy_id
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
return|return
name|svn_fs_fs__write_current
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
return|;
comment|/* To find the next available ids, we add the id that used to be in      the 'current' file, to the next ids from the transaction file. */
name|SVN_ERR
argument_list|(
name|read_next_ids
argument_list|(
operator|&
name|txn_node_id
argument_list|,
operator|&
name|txn_copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|start_node_id
operator|+=
name|txn_node_id
expr_stmt|;
name|start_copy_id
operator|+=
name|txn_copy_id
expr_stmt|;
return|return
name|svn_fs_fs__write_current
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|start_node_id
argument_list|,
name|start_copy_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Verify that the user registered with FS has all the locks necessary to    permit all the changes associated with TXN_NAME.    The FS write lock is assumed to be held by the caller. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_hash_t
modifier|*
name|changed_paths
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changed_paths_sorted
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|last_recursed
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Make an array of the changed paths, and sort them depth-first-ily.  */
name|changed_paths_sorted
operator|=
name|svn_sort__hash
argument_list|(
name|changed_paths
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Now, traverse the array of changed paths, verify locks.  Note      that if we need to do a recursive verification a path, we'll skip      over children of that path when we get to them. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changed_paths_sorted
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_sort__item_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|recurse
init|=
name|TRUE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|changed_paths_sorted
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
expr_stmt|;
comment|/* Fetch the change associated with our path.  */
name|path
operator|=
name|item
operator|->
name|key
expr_stmt|;
name|change
operator|=
name|item
operator|->
name|value
expr_stmt|;
comment|/* If this path has already been verified as part of a recursive          check of one of its parents, no need to do it again.  */
if|if
condition|(
name|last_recursed
operator|&&
name|svn_fspath__skip_ancestor
argument_list|(
name|last_recursed
operator|->
name|data
argument_list|,
name|path
argument_list|)
condition|)
continue|continue;
comment|/* What does it mean to succeed at lock verification for a given          path?  For an existing file or directory getting modified          (text, props), it means we hold the lock on the file or          directory.  For paths being added or removed, we need to hold          the locks for that path and any children of that path.           WHEW!  We have no reliable way to determine the node kind          of deleted items, but fortunately we are going to do a          recursive check on deleted paths regardless of their kind.  */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_modify
condition|)
name|recurse
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|fs
argument_list|,
name|recurse
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we just did a recursive check, remember the path we          checked (so children can be skipped).  */
if|if
condition|(
name|recurse
condition|)
block|{
if|if
condition|(
operator|!
name|last_recursed
condition|)
name|last_recursed
operator|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_set
argument_list|(
name|last_recursed
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return in *PATH the path to a file containing the properties that    make up the final revision properties file.  This involves setting    svn:date and removing any temporary properties associated with the    commit flags. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_final_revprop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|txnprops
decl_stmt|;
name|svn_boolean_t
name|final_mods
init|=
name|FALSE
decl_stmt|;
name|svn_string_t
name|date
decl_stmt|;
name|svn_string_t
modifier|*
name|client_date
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_proplist
argument_list|(
operator|&
name|txnprops
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove any temporary txn props representing 'flags'. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|final_mods
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|final_mods
operator|=
name|TRUE
expr_stmt|;
block|}
name|client_date
operator|=
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CLIENT_DATE
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_date
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CLIENT_DATE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|final_mods
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Update commit time to ensure that svn:date revprops remain ordered if      requested. */
if|if
condition|(
operator|!
name|client_date
operator|||
name|strcmp
argument_list|(
name|client_date
operator|->
name|data
argument_list|,
literal|"1"
argument_list|)
condition|)
block|{
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|txnprops
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
name|final_mods
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|final_mods
condition|)
block|{
name|SVN_ERR
argument_list|(
name|set_txn_proplist
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|txnprops
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|path
operator|=
name|path_txn_props_final
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|path
operator|=
name|path_txn_props
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__add_index_data
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|l2p_proto_index
parameter_list|,
specifier|const
name|char
modifier|*
name|p2l_proto_index
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|l2p_offset
decl_stmt|;
name|apr_off_t
name|p2l_offset
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|footer
decl_stmt|;
name|unsigned
name|char
name|footer_length
decl_stmt|;
name|svn_checksum_t
modifier|*
name|l2p_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|p2l_checksum
decl_stmt|;
comment|/* Append the actual index data to the pack file. */
name|l2p_offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_END
argument_list|,
operator|&
name|l2p_offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_index_append
argument_list|(
operator|&
name|l2p_checksum
argument_list|,
name|fs
argument_list|,
name|file
argument_list|,
name|l2p_proto_index
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|p2l_offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_END
argument_list|,
operator|&
name|p2l_offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_index_append
argument_list|(
operator|&
name|p2l_checksum
argument_list|,
name|fs
argument_list|,
name|file
argument_list|,
name|p2l_proto_index
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append footer. */
name|footer
operator|=
name|svn_fs_fs__unparse_footer
argument_list|(
name|l2p_offset
argument_list|,
name|l2p_checksum
argument_list|,
name|p2l_offset
argument_list|,
name|p2l_checksum
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|footer
operator|->
name|data
argument_list|,
name|footer
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|footer_length
operator|=
name|footer
operator|->
name|len
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|footer_length
operator|==
name|footer
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
operator|&
name|footer_length
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for commit_body below. */
end_comment

begin_struct
struct|struct
name|commit_baton
block|{
name|svn_revnum_t
modifier|*
name|new_rev_p
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|reps_to_cache
decl_stmt|;
name|apr_hash_t
modifier|*
name|reps_hash
decl_stmt|;
name|apr_pool_t
modifier|*
name|reps_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The work-horse for svn_fs_fs__commit, called with the FS write lock.    This implements the svn_fs_fs__with_write_lock() 'body' callback    type.  BATON is a 'struct commit_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|commit_baton
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|cb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_rev_filename
decl_stmt|,
modifier|*
name|rev_filename
decl_stmt|,
modifier|*
name|proto_filename
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprop_filename
decl_stmt|,
modifier|*
name|final_revprop
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|,
modifier|*
name|new_root_id
decl_stmt|;
name|apr_uint64_t
name|start_node_id
decl_stmt|;
name|apr_uint64_t
name|start_copy_id
decl_stmt|;
name|svn_revnum_t
name|old_rev
decl_stmt|,
name|new_rev
decl_stmt|;
name|apr_file_t
modifier|*
name|proto_file
decl_stmt|;
name|void
modifier|*
name|proto_file_lockcookie
decl_stmt|;
name|apr_off_t
name|initial_offset
decl_stmt|,
name|changed_path_offset
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|svn_fs_fs__txn_get_id
argument_list|(
name|cb
operator|->
name|txn
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|changed_paths
decl_stmt|;
comment|/* Re-Read the current repository format.  All our repo upgrade and      config evaluation strategies are such that existing information in      FS and FFD remains valid.       Although we don't recommend upgrading hot repositories, people may      still do it and we must make sure to either handle them gracefully      or to error out.       Committing pre-format 3 txns will fail after upgrade to format 3+      because the proto-rev cannot be found; no further action needed.      Upgrades from pre-f7 to f7+ means a potential change in addressing      mode for the final rev.  We must be sure to detect that cause because      the failure would only manifest once the new revision got committed.    */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_format_file
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the current youngest revision and, possibly, the next available      node id and copy id (for old format filesystems).  Update the cached      value for the youngest revision, because we have just checked it. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_current
argument_list|(
operator|&
name|old_rev
argument_list|,
operator|&
name|start_node_id
argument_list|,
operator|&
name|start_copy_id
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
name|old_rev
expr_stmt|;
comment|/* Check to make sure this transaction is based off the most recent      revision. */
if|if
condition|(
name|cb
operator|->
name|txn
operator|->
name|base_rev
operator|!=
name|old_rev
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_TXN_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Transaction out of date"
argument_list|)
argument_list|)
return|;
comment|/* We need the changes list for verification as well as for writing it      to the final rev file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_changes_fetch
argument_list|(
operator|&
name|changed_paths
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Locks may have been added (or stolen) between the calling of      previous svn_fs.h functions and svn_fs_commit_txn(), so we need      to re-examine every changed-path in the txn and re-verify all      discovered locks. */
name|SVN_ERR
argument_list|(
name|verify_locks
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|changed_paths
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We are going to be one better than this puny old revision. */
name|new_rev
operator|=
name|old_rev
operator|+
literal|1
expr_stmt|;
comment|/* Get a write handle on the proto revision file. */
name|SVN_ERR
argument_list|(
name|get_writable_proto_rev
argument_list|(
operator|&
name|proto_file
argument_list|,
operator|&
name|proto_file_lockcookie
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|initial_offset
argument_list|,
name|proto_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write out all the node-revisions and directory contents. */
name|root_id
operator|=
name|svn_fs_fs__id_txn_create_root
argument_list|(
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_final_rev
argument_list|(
operator|&
name|new_root_id
argument_list|,
name|proto_file
argument_list|,
name|new_rev
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|root_id
argument_list|,
name|start_node_id
argument_list|,
name|start_copy_id
argument_list|,
name|initial_offset
argument_list|,
name|cb
operator|->
name|reps_to_cache
argument_list|,
name|cb
operator|->
name|reps_hash
argument_list|,
name|cb
operator|->
name|reps_pool
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the changed-path information. */
name|SVN_ERR
argument_list|(
name|write_final_changed_path_info
argument_list|(
operator|&
name|changed_path_offset
argument_list|,
name|proto_file
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|changed_paths
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|cb
operator|->
name|fs
argument_list|)
condition|)
block|{
comment|/* Append the index data to the rev file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__add_index_data
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|proto_file
argument_list|,
name|svn_fs_fs__path_l2p_proto_index
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_fs_fs__path_p2l_proto_index
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Write the final line. */
name|svn_stringbuf_t
modifier|*
name|trailer
init|=
name|svn_fs_fs__unparse_revision_trailer
argument_list|(
operator|(
name|apr_off_t
operator|)
name|svn_fs_fs__id_item
argument_list|(
name|new_root_id
argument_list|)
argument_list|,
name|changed_path_offset
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|proto_file
argument_list|,
name|trailer
operator|->
name|data
argument_list|,
name|trailer
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|proto_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|proto_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We don't unlock the prototype revision file immediately to avoid a      race with another caller writing to the prototype revision file      before we commit it. */
comment|/* Create the shard for the rev and revprop file, if we're sharding and      this is the first revision of a new shard.  We don't care if this      fails because the shard already existed for some reason. */
if|if
condition|(
name|ffd
operator|->
name|max_files_per_dir
operator|&&
name|new_rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|==
literal|0
condition|)
block|{
comment|/* Create the revs shard. */
block|{
specifier|const
name|char
modifier|*
name|new_dir
init|=
name|svn_fs_fs__path_rev_shard
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_dir_make
argument_list|(
name|new_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|svn_dirent_join
argument_list|(
name|cb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|new_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create the revprops shard. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|svn_fs_fs__is_packed_revprop
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|)
argument_list|)
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|new_dir
init|=
name|svn_fs_fs__path_revprops_shard
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_dir_make
argument_list|(
name|new_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|svn_dirent_join
argument_list|(
name|cb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|new_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Move the finished rev file into place.       ### This "breaks" the transaction by removing the protorev file      ### but the revision is not yet complete.  If this commit does      ### not complete for any reason the transaction will be lost. */
name|old_rev_filename
operator|=
name|svn_fs_fs__path_rev_absolute
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|old_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rev_filename
operator|=
name|svn_fs_fs__path_rev
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|proto_filename
operator|=
name|svn_fs_fs__path_txn_proto_rev
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__move_into_place
argument_list|(
name|proto_filename
argument_list|,
name|rev_filename
argument_list|,
name|old_rev_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that we've moved the prototype revision file out of the way,      we can unlock it (since further attempts to write to the file      will fail as it no longer exists).  We must do this so that we can      remove the transaction directory later. */
name|SVN_ERR
argument_list|(
name|unlock_proto_rev
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|proto_file_lockcookie
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the revprops file into place. */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|svn_fs_fs__is_packed_revprop
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_final_revprop
argument_list|(
operator|&
name|revprop_filename
argument_list|,
name|cb
operator|->
name|txn
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|final_revprop
operator|=
name|svn_fs_fs__path_revprops
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__move_into_place
argument_list|(
name|revprop_filename
argument_list|,
name|final_revprop
argument_list|,
name|old_rev_filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the 'current' file. */
name|SVN_ERR
argument_list|(
name|verify_as_revision_before_current_plus_plus
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|new_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_final_current
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|new_rev
argument_list|,
name|start_node_id
argument_list|,
name|start_copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At this point the new revision is committed and globally visible      so let the caller know it succeeded by giving it the new revision      number, which fulfills svn_fs_commit_txn() contract.  Any errors      after this point do not change the fact that a new revision was      created. */
operator|*
name|cb
operator|->
name|new_rev_p
operator|=
name|new_rev
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
name|new_rev
expr_stmt|;
comment|/* Remove this transaction directory. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__purge_txn
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|txn
operator|->
name|id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add the representations in REPS_TO_CACHE (an array of representation_t *)  * to the rep-cache database of FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_reps_to_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|reps_to_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps_to_cache
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|APR_ARRAY_IDX
argument_list|(
name|reps_to_cache
argument_list|,
name|i
argument_list|,
name|representation_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_rep_reference
argument_list|(
name|fs
argument_list|,
name|rep
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__commit
parameter_list|(
name|svn_revnum_t
modifier|*
name|new_rev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|commit_baton
name|cb
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|cb
operator|.
name|new_rev_p
operator|=
name|new_rev_p
expr_stmt|;
name|cb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|cb
operator|.
name|txn
operator|=
name|txn
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
name|cb
operator|.
name|reps_to_cache
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|5
argument_list|,
sizeof|sizeof
argument_list|(
name|representation_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|.
name|reps_hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|cb
operator|.
name|reps_pool
operator|=
name|pool
expr_stmt|;
block|}
else|else
block|{
name|cb
operator|.
name|reps_to_cache
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|reps_hash
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|reps_pool
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|commit_body
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* At this point, *NEW_REV_P has been set, so errors below won't affect      the success of the commit.  (See svn_fs_commit_txn().)  */
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_rep_cache
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write new entries to the rep-sharing database.        *        * We use an sqlite transaction to speed things up;        * see<http://www.sqlite.org/faq.html#q19>.        */
comment|/* ### A commit that touches thousands of files will starve other              (reader/writer) commits for the duration of the below call.              Maybe write in batches? */
name|SVN_ERR
argument_list|(
name|svn_sqlite__begin_transaction
argument_list|(
name|ffd
operator|->
name|rep_cache_db
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|write_reps_to_cache
argument_list|(
name|fs
argument_list|,
name|cb
operator|.
name|reps_to_cache
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_sqlite__finish_transaction
argument_list|(
name|ffd
operator|->
name|rep_cache_db
argument_list|,
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_SQLITE__ERR_ROLLBACK_FAILED
argument_list|)
condition|)
block|{
comment|/* Failed rollback means that our db connection is unusable, and              the only thing we can do is close it.  The connection will be              reopened during the next operation with rep-cache.db. */
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_fs_fs__close_rep_cache
argument_list|(
name|fs
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__list_transactions
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|names_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|txn_dir
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|names
decl_stmt|;
name|apr_size_t
name|ext_len
init|=
name|strlen
argument_list|(
name|PATH_EXT_TXN
argument_list|)
decl_stmt|;
name|names
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the transactions directory. */
name|txn_dir
operator|=
name|svn_fs_fs__path_txns_dir
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Now find a listing of this directory. */
name|SVN_ERR
argument_list|(
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|txn_dir
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop through all the entries and return anything that ends with '.txn'. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|klen
init|=
name|apr_hash_this_key_len
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|id
decl_stmt|;
comment|/* The name must end with ".txn" to be considered a transaction. */
if|if
condition|(
operator|(
name|apr_size_t
operator|)
name|klen
operator|<=
name|ext_len
operator|||
operator|(
name|strcmp
argument_list|(
name|name
operator|+
name|klen
operator|-
name|ext_len
argument_list|,
name|PATH_EXT_TXN
argument_list|)
operator|)
operator|!=
literal|0
condition|)
continue|continue;
comment|/* Truncate the ".txn" extension and store the ID. */
name|id
operator|=
name|apr_pstrndup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|ext_len
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|names
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|id
expr_stmt|;
block|}
operator|*
name|names_p
operator|=
name|names
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__open_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|fs_txn_data_t
modifier|*
name|ftd
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|transaction_t
modifier|*
name|local_txn
decl_stmt|;
name|svn_fs_fs__id_part_t
name|txn_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_txn_parse
argument_list|(
operator|&
name|txn_id
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First check to see if the directory exists. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|svn_fs_fs__path_txn_dir
argument_list|(
name|fs
argument_list|,
operator|&
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did we find it? */
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_TRANSACTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such transaction '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
name|txn
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|txn
argument_list|)
argument_list|)
expr_stmt|;
name|ftd
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ftd
argument_list|)
argument_list|)
expr_stmt|;
name|ftd
operator|->
name|txn_id
operator|=
name|txn_id
expr_stmt|;
comment|/* Read in the root node of this transaction. */
name|txn
operator|->
name|id
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|txn
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_txn
argument_list|(
operator|&
name|local_txn
argument_list|,
name|fs
argument_list|,
operator|&
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|txn
operator|->
name|base_rev
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|local_txn
operator|->
name|base_id
argument_list|)
expr_stmt|;
name|txn
operator|->
name|vtable
operator|=
operator|&
name|txn_vtable
expr_stmt|;
name|txn
operator|->
name|fsap_data
operator|=
name|ftd
expr_stmt|;
operator|*
name|txn_p
operator|=
name|txn
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|proplist
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_txn_proplist
argument_list|(
name|proplist
argument_list|,
name|txn
operator|->
name|fs
argument_list|,
name|svn_fs_fs__txn_get_id
argument_list|(
name|txn
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|table_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__delete_node_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete any mutable property representation. */
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|is_txn_rep
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_fs_fs__path_txn_node_props
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete any mutable data representation. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|is_txn_rep
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|)
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|svn_fs_fs__path_txn_node_children
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove the corresponding entry from the cache, if such exists */
if|if
condition|(
name|ffd
operator|->
name|txn_dir_cache
condition|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|txn_dir_cache
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_io_remove_file2
argument_list|(
name|svn_fs_fs__path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Transactions ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_txn_ids
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|root_id_p
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|base_root_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|transaction_t
modifier|*
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_id_p
operator|=
name|txn
operator|->
name|root_id
expr_stmt|;
operator|*
name|base_root_id_p
operator|=
name|txn
operator|->
name|base_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Generic transaction operations.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__begin_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
name|date
decl_stmt|;
name|fs_txn_data_t
modifier|*
name|ftd
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__create_txn
argument_list|(
name|txn_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put a datestamp on the newly created txn, so we always know      exactly how old it is.  (This will help sysadmins identify      long-abandoned txns that may need to be manually removed.)  When      a txn is promoted to a revision, this property will be      automatically overwritten with a revision datestamp. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
comment|/* Set temporary txn props that represent the requested 'flags'      behaviors. */
if|if
condition|(
name|flags
operator|&
name|SVN_FS_TXN_CHECK_OOD
condition|)
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|,
name|svn_string_create
argument_list|(
literal|"true"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|,
name|svn_string_create
argument_list|(
literal|"true"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|SVN_FS_TXN_CLIENT_DATE
condition|)
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|SVN_FS__PROP_TXN_CLIENT_DATE
argument_list|,
name|svn_string_create
argument_list|(
literal|"0"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ftd
operator|=
operator|(
operator|*
name|txn_p
operator|)
operator|->
name|fsap_data
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|set_txn_proplist
argument_list|(
name|fs
argument_list|,
operator|&
name|ftd
operator|->
name|txn_id
argument_list|,
name|props
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

