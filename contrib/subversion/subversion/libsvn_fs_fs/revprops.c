begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* revprops.c --- everything needed to handle revprops in FSFS  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Give writing processes 10 seconds to replace an existing revprop    file with a new one. After that time, we assume that the writing    process got aborted and that we have re-read revprops. */
end_comment

begin_define
define|#
directive|define
name|REVPROP_CHANGE_TIMEOUT
value|(10 * 1000000)
end_define

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__upgrade_pack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_upgrade_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_pack_file_dir
decl_stmt|;
name|apr_int64_t
name|shard
decl_stmt|;
name|apr_int64_t
name|first_unpacked_shard
init|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revsprops_dir
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|compression_level
init|=
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
else|:
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
decl_stmt|;
comment|/* first, pack all revprops shards to match the packed revision shards */
for|for
control|(
name|shard
operator|=
literal|0
init|;
name|shard
operator|<
name|first_unpacked_shard
condition|;
operator|++
name|shard
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|revprops_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|iterpool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__pack_revprops_shard
argument_list|(
name|revprops_pack_file_dir
argument_list|,
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|0.9
operator|*
name|ffd
operator|->
name|revprop_pack_size
argument_list|)
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_upgrade_pack_revprops
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__upgrade_cleanup_pack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_upgrade_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|;
name|apr_int64_t
name|shard
decl_stmt|;
name|apr_int64_t
name|first_unpacked_shard
init|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revsprops_dir
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* delete the non-packed revprops shards afterwards */
for|for
control|(
name|shard
operator|=
literal|0
init|;
name|shard
operator|<
name|first_unpacked_shard
condition|;
operator|++
name|shard
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__delete_revprops_shard
argument_list|(
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_upgrade_cleanup_revprops
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Container for all data required to access the packed revprop file  * for a given REVISION.  This structure will be filled incrementally  * by read_pack_revprops() its sub-routines.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|packed_revprops_t
block|{
comment|/* revision number to read (not necessarily the first in the pack) */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* current revprop generation. Used when populating the revprop cache */
name|apr_int64_t
name|generation
decl_stmt|;
comment|/* the actual revision properties */
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
comment|/* their size when serialized to a single string    * (as found in PACKED_REVPROPS) */
name|apr_size_t
name|serialized_size
decl_stmt|;
comment|/* name of the pack file (without folder path) */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* packed shard folder path */
specifier|const
name|char
modifier|*
name|folder
decl_stmt|;
comment|/* sum of values in SIZES */
name|apr_size_t
name|total_size
decl_stmt|;
comment|/* first revision in the pack (>= MANIFEST_START) */
name|svn_revnum_t
name|start_revision
decl_stmt|;
comment|/* size of the revprops in PACKED_REVPROPS */
name|apr_array_header_t
modifier|*
name|sizes
decl_stmt|;
comment|/* offset of the revprops in PACKED_REVPROPS */
name|apr_array_header_t
modifier|*
name|offsets
decl_stmt|;
comment|/* concatenation of the serialized representation of all revprops    * in the pack, i.e. the pack content without header and compression */
name|svn_stringbuf_t
modifier|*
name|packed_revprops
decl_stmt|;
comment|/* First revision covered by MANIFEST.    * Will equal the shard start revision or 1, for the 1st shard. */
name|svn_revnum_t
name|manifest_start
decl_stmt|;
comment|/* content of the manifest.    * Maps long(rev - MANIFEST_START) to const char* pack file name */
name|apr_array_header_t
modifier|*
name|manifest
decl_stmt|;
block|}
name|packed_revprops_t
typedef|;
end_typedef

begin_comment
comment|/* Parse the serialized revprops in CONTENT and return them in *PROPERTIES.  * Also, put them into the revprop cache, if activated, for future use.  * Three more parameters are being used to update the revprop cache: FS is  * our file system, the revprops belong to REVISION and the global revprop  * GENERATION is used as well.  *  * The returned hash will be allocated in POOL, SCRATCH_POOL is being used  * for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_revprop
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|properties
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|svn_string_t
modifier|*
name|content
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
init|=
name|svn_stream_from_string
argument_list|(
name|content
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|properties
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR_W
argument_list|(
name|svn_hash_read2
argument_list|(
operator|*
name|properties
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"Failed to parse revprops for r%ld."
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the non-packed revprops for revision REV in FS, put them into the  * revprop cache if activated and return them in *PROPERTIES.  GENERATION  * is the current revprop generation.  *  * If the data could not be read due to an otherwise recoverable error,  * leave *PROPERTIES unchanged. No error will be returned in that case.  *  * Allocations will be done in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_non_packed_revprop
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|properties
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|missing
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_FS_FS__RECOVERABLE_RETRY_COUNT
operator|&&
operator|!
name|missing
operator|&&
operator|!
name|content
condition|;
operator|++
name|i
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__try_stringbuf_from_file
argument_list|(
operator|&
name|content
argument_list|,
operator|&
name|missing
argument_list|,
name|svn_fs_fs__path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|i
operator|+
literal|1
operator|<
name|SVN_FS_FS__RECOVERABLE_RETRY_COUNT
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|content
condition|)
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
name|properties
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|svn_stringbuf__morph_into_string
argument_list|(
name|content
argument_list|)
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the minimum length of any packed revprop file name in REVPROPS. */
end_comment

begin_function
specifier|static
name|apr_size_t
name|get_min_filename_len
parameter_list|(
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|)
block|{
name|char
name|number_buffer
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* The revprop filenames have the format<REV>.<COUNT> - with<REV> being    * at least the first rev in the shard and<COUNT> having at least one    * digit.  Thus, the minimum is 2 + #decimal places in the start rev.    */
return|return
name|svn__i64toa
argument_list|(
name|number_buffer
argument_list|,
name|revprops
operator|->
name|manifest_start
argument_list|)
operator|+
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Given FS and REVPROPS->REVISION, fill the FILENAME, FOLDER and MANIFEST  * members. Use POOL for allocating results and SCRATCH_POOL for temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_revprop_packname
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|manifest_file_path
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rev_count
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|buffer_end
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filenames
decl_stmt|,
modifier|*
modifier|*
name|filenames_end
decl_stmt|;
name|apr_size_t
name|min_filename_len
decl_stmt|;
comment|/* Determine the dimensions. Rev 0 is excluded from the first shard. */
name|rev_count
operator|=
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
name|revprops
operator|->
name|manifest_start
operator|=
name|revprops
operator|->
name|revision
operator|-
operator|(
name|revprops
operator|->
name|revision
operator|%
name|rev_count
operator|)
expr_stmt|;
if|if
condition|(
name|revprops
operator|->
name|manifest_start
operator|==
literal|0
condition|)
block|{
operator|++
name|revprops
operator|->
name|manifest_start
expr_stmt|;
operator|--
name|rev_count
expr_stmt|;
block|}
name|revprops
operator|->
name|manifest
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|rev_count
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No line in the file can be less than this number of chars long. */
name|min_filename_len
operator|=
name|get_min_filename_len
argument_list|(
name|revprops
argument_list|)
expr_stmt|;
comment|/* Read the content of the manifest file */
name|revprops
operator|->
name|folder
operator|=
name|svn_fs_fs__path_revprops_pack_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_content
argument_list|(
operator|&
name|content
argument_list|,
name|manifest_file_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There CONTENT must have a certain minimal size and there no    * unterminated lines at the end of the file.  Both guarantees also    * simplify the parser loop below.    */
if|if
condition|(
name|content
operator|->
name|len
operator|<
name|rev_count
operator|*
operator|(
name|min_filename_len
operator|+
literal|1
operator|)
operator|||
name|content
operator|->
name|data
index|[
name|content
operator|->
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop manifest for r%ld not "
literal|"properly terminated"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|)
return|;
comment|/* Chop (parse) the manifest CONTENT into filenames, one per line.    * We only have to replace all newlines with NUL and add all line    * starts to REVPROPS->MANIFEST.    *    * There must be exactly REV_COUNT lines and that is the number of    * lines we parse from BUFFER to FILENAMES.  Set the end pointer for    * the source BUFFER such that BUFFER+MIN_FILENAME_LEN is still valid    * BUFFER_END is always valid due to CONTENT->LEN> MIN_FILENAME_LEN.    *    * Please note that this loop is performance critical for e.g. 'svn log'.    * It is run 1000x per revprop access, i.e. per revision and about    * 50 million times per sec (and CPU core).    */
for|for
control|(
name|filenames
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|revprops
operator|->
name|manifest
operator|->
name|elts
operator|,
name|filenames_end
operator|=
name|filenames
operator|+
name|rev_count
operator|,
name|buffer
operator|=
name|content
operator|->
name|data
operator|,
name|buffer_end
operator|=
name|buffer
operator|+
name|content
operator|->
name|len
operator|-
name|min_filename_len
init|;
operator|(
name|filenames
operator|<
name|filenames_end
operator|)
operator|&&
operator|(
name|buffer
operator|<
name|buffer_end
operator|)
condition|;
operator|++
name|filenames
control|)
block|{
comment|/* BUFFER always points to the start of the next line / filename. */
operator|*
name|filenames
operator|=
name|buffer
expr_stmt|;
comment|/* Find the next EOL.  This is guaranteed to stay within the CONTENT        * buffer because we left enough room after BUFFER_END and we know        * we will always see a newline as the last non-NUL char. */
name|buffer
operator|+=
name|min_filename_len
expr_stmt|;
while|while
condition|(
operator|*
name|buffer
operator|!=
literal|'\n'
condition|)
operator|++
name|buffer
expr_stmt|;
comment|/* Found EOL.  Turn it into the filename terminator and move BUFFER        * to the start of the next line or CONTENT buffer end. */
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|buffer
expr_stmt|;
block|}
comment|/* We must have reached the end of both buffers. */
if|if
condition|(
name|buffer
operator|<
name|content
operator|->
name|data
operator|+
name|content
operator|->
name|len
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop manifest for r%ld "
literal|"has too many entries"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|)
return|;
if|if
condition|(
name|filenames
operator|<
name|filenames_end
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop manifest for r%ld "
literal|"has too few entries"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|)
return|;
comment|/* The target array has now exactly one entry per revision. */
name|revprops
operator|->
name|manifest
operator|->
name|nelts
operator|=
name|rev_count
expr_stmt|;
comment|/* Now get the file name */
name|idx
operator|=
call|(
name|int
call|)
argument_list|(
name|revprops
operator|->
name|revision
operator|-
name|revprops
operator|->
name|manifest_start
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|filename
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|idx
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if revision R1 and R2 refer to the same shard in FS.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|same_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|r1
parameter_list|,
name|svn_revnum_t
name|r2
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
operator|(
name|r1
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|==
operator|(
name|r2
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given FS and the full packed file content in REVPROPS->PACKED_REVPROPS,  * fill the START_REVISION member, and make PACKED_REVPROPS point to the  * first serialized revprop.  If READ_ALL is set, initialize the SIZES  * and OFFSETS members as well.  *  * Parse the revprops for REVPROPS->REVISION and set the PROPERTIES as  * well as the SERIALIZED_SIZE member.  If revprop caching has been  * enabled, parse all revprops in the pack and cache them.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_packed_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|svn_boolean_t
name|read_all
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_int64_t
name|first_rev
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|header_end
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* decompress (even if the data is only "stored", there is still a    * length header to remove) */
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|revprops
operator|->
name|packed_revprops
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn__decompress
argument_list|(
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|APR_SIZE_MAX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read first revision number and number of revisions in the pack */
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_number_from_stream
argument_list|(
operator|&
name|first_rev
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_number_from_stream
argument_list|(
operator|&
name|count
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check revision range for validity. */
if|if
condition|(
operator|!
name|same_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|first_rev
argument_list|)
operator|||
operator|!
name|same_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|first_rev
operator|+
name|count
operator|-
literal|1
argument_list|)
operator|||
name|count
operator|<
literal|1
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revprop pack for revision r%ld"
literal|" contains revprops for r%ld .. r%ld"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|first_rev
argument_list|,
call|(
name|svn_revnum_t
call|)
argument_list|(
name|first_rev
operator|+
name|count
operator|-
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Since start& end are in the same shard, it is enough to just test    * the FIRST_REV for being actually packed.  That will also cover the    * special case of rev 0 never being packed. */
if|if
condition|(
operator|!
name|svn_fs_fs__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|first_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revprop pack for revision r%ld"
literal|" starts at non-packed revisions r%ld"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|first_rev
argument_list|)
return|;
comment|/* make PACKED_REVPROPS point to the first char after the header.    * This is where the serialized revprops are. */
name|header_end
operator|=
name|strstr
argument_list|(
name|uncompressed
operator|->
name|data
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_end
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Header end not found"
argument_list|)
argument_list|)
return|;
name|offset
operator|=
name|header_end
operator|-
name|uncompressed
operator|->
name|data
operator|+
literal|2
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|=
name|uncompressed
operator|->
name|data
operator|+
name|offset
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|len
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|uncompressed
operator|->
name|len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|blocksize
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|uncompressed
operator|->
name|blocksize
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|/* STREAM still points to the first entry in the sizes list. */
name|revprops
operator|->
name|start_revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|first_rev
expr_stmt|;
if|if
condition|(
name|read_all
condition|)
block|{
comment|/* Init / construct REVPROPS members. */
name|revprops
operator|->
name|sizes
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|offsets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now parse, revision by revision, the size and content of each    * revisions' revprops. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
operator|,
name|revprops
operator|->
name|total_size
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|apr_int64_t
name|size
decl_stmt|;
name|svn_string_t
name|serialized
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|first_rev
operator|+
name|i
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* read& check the serialized size */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_number_from_stream
argument_list|(
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|+
name|offset
operator|>
operator|(
name|apr_int64_t
operator|)
name|revprops
operator|->
name|packed_revprops
operator|->
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop size exceeds pack file size"
argument_list|)
argument_list|)
return|;
comment|/* Parse this revprops list, if necessary */
name|serialized
operator|.
name|data
operator|=
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|+
name|offset
expr_stmt|;
name|serialized
operator|.
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|revision
operator|==
name|revprops
operator|->
name|revision
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
operator|&
name|revprops
operator|->
name|properties
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|revprops
operator|->
name|generation
argument_list|,
operator|&
name|serialized
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|serialized_size
operator|=
name|serialized
operator|.
name|len
expr_stmt|;
comment|/* If we only wanted the revprops for REVISION then we are done. */
if|if
condition|(
operator|!
name|read_all
condition|)
break|break;
block|}
if|if
condition|(
name|read_all
condition|)
block|{
comment|/* fill REVPROPS data structures */
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|serialized
operator|.
name|len
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
operator|->
name|offsets
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|offset
expr_stmt|;
block|}
name|revprops
operator|->
name|total_size
operator|+=
name|serialized
operator|.
name|len
expr_stmt|;
name|offset
operator|+=
name|serialized
operator|.
name|len
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In filesystem FS, read the packed revprops for revision REV into  * *REVPROPS.  Use GENERATION to populate the revprop cache, if enabled.  * If you want to modify revprop contents / update REVPROPS, READ_ALL  * must be set.  Otherwise, only the properties of REV are being provided.  * Allocate data in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_pack_revprop
parameter_list|(
name|packed_revprops_t
modifier|*
modifier|*
name|revprops
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|svn_boolean_t
name|read_all
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|missing
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|packed_revprops_t
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* someone insisted that REV is packed. Double-check if necessary */
if|if
condition|(
operator|!
name|svn_fs_fs__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such packed revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* initialize the result data structure */
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|result
operator|->
name|generation
operator|=
name|generation
expr_stmt|;
comment|/* try to read the packed revprops. This may require retries if we have    * concurrent writers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_FS_FS__RECOVERABLE_RETRY_COUNT
operator|&&
operator|!
name|result
operator|->
name|packed_revprops
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|file_path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* there might have been concurrent writes.        * Re-read the manifest and the pack file.        */
name|SVN_ERR
argument_list|(
name|get_revprop_packname
argument_list|(
name|fs
argument_list|,
name|result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|file_path
operator|=
name|svn_dirent_join
argument_list|(
name|result
operator|->
name|folder
argument_list|,
name|result
operator|->
name|filename
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__try_stringbuf_from_file
argument_list|(
operator|&
name|result
operator|->
name|packed_revprops
argument_list|,
operator|&
name|missing
argument_list|,
name|file_path
argument_list|,
name|i
operator|+
literal|1
operator|<
name|SVN_FS_FS__RECOVERABLE_RETRY_COUNT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* the file content should be available now */
if|if
condition|(
operator|!
name|result
operator|->
name|packed_revprops
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PACKED_REVPROP_READ_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to read revprop pack file for r%ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* parse it. RESULT will be complete afterwards. */
name|err
operator|=
name|parse_packed_revprops
argument_list|(
name|fs
argument_list|,
name|result
argument_list|,
name|read_all
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Revprop pack file for r%ld is corrupt"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
operator|*
name|revprops
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the revprops for revision REV in FS and return them in *PROPERTIES_P.  *  * Allocations will be done in POOL.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_revision_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_int64_t
name|generation
init|=
literal|0
decl_stmt|;
comment|/* not found, yet */
operator|*
name|proplist_p
operator|=
name|NULL
expr_stmt|;
comment|/* should they be available at all? */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if REV had not been packed when we began, try reading it from the    * non-packed shard.  If that fails, we will fall through to packed    * shard reads. */
if|if
condition|(
operator|!
name|svn_fs_fs__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|read_non_packed_revprop
argument_list|(
name|proplist_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|NULL
expr_stmt|;
comment|/* in case read_non_packed_revprop changed it */
block|}
block|}
comment|/* if revprop packing is available and we have not read the revprops, yet,    * try reading them from a packed shard.  If that fails, REV is most    * likely invalid (or its revprops highly contested). */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
operator|&&
operator|!
operator|*
name|proplist_p
condition|)
block|{
name|packed_revprops_t
modifier|*
name|revprops
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_pack_revprop
argument_list|(
operator|&
name|revprops
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|revprops
operator|->
name|properties
expr_stmt|;
block|}
comment|/* The revprops should have been there. Did we get them? */
if|if
condition|(
operator|!
operator|*
name|proplist_p
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not read revprops for revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serialize the revision property list PROPLIST of revision REV in  * filesystem FS to a non-packed file.  Return the name of that temporary  * file in *TMP_PATH and the file path that it must be moved to in  * *FINAL_PATH.  *  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_non_packed_revprop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
operator|*
name|final_path
operator|=
name|svn_fs_fs__path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ### do we have a directory sitting around already? we really shouldn't      ### have to get the dirname here. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
name|tmp_path
argument_list|,
name|svn_dirent_dirname
argument_list|(
operator|*
name|final_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Flush temporary file to disk and close it. */
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* After writing the new revprop file(s), call this function to move the  * file at TMP_PATH to FINAL_PATH and give it the permissions from  * PERMS_REFERENCE.  *  * Finally, delete all the temporary files given in FILES_TO_DELETE.  * The latter may be NULL.  *  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|switch_to_new_revprop
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
name|tmp_path
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_array_header_t
modifier|*
name|files_to_delete
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__move_into_place
argument_list|(
name|tmp_path
argument_list|,
name|final_path
argument_list|,
name|perms_reference
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up temporary files, if necessary. */
if|if
condition|(
name|files_to_delete
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files_to_delete
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|files_to_delete
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write a pack file header to STREAM that starts at revision START_REVISION  * and contains the indexes [START,END) of SIZES.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|serialize_revprops_header
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|apr_array_header_t
modifier|*
name|sizes
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|start
operator|<
name|end
argument_list|)
expr_stmt|;
comment|/* start revision and entry count */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"%ld\n"
argument_list|,
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|pool
argument_list|,
literal|"%d\n"
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the sizes array */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
comment|/* Non-standard pool usage.        *        * We only allocate a few bytes each iteration -- even with a        * million iterations we would still be in good shape memory-wise.        */
name|apr_off_t
name|size
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sizes
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|iterpool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
literal|"\n"
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* the double newline char indicates the end of the header */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|iterpool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Writes the a pack file to FILE.  It copies the serialized data  * from REVPROPS for the indexes [START,END) except for index CHANGED_INDEX.  *  * The data for the latter is taken from NEW_SERIALIZED.  Note, that  * CHANGED_INDEX may be outside the [START,END) range, i.e. no new data is  * taken in that case but only a subset of the old data will be copied.  *  * NEW_TOTAL_SIZE is a hint for pre-allocating buffers of appropriate size.  * POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|changed_index
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|new_serialized
parameter_list|,
name|apr_off_t
name|new_total_size
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* create data empty buffers and the stream object */
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
operator|(
name|apr_size_t
operator|)
name|new_total_size
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* write the header*/
name|SVN_ERR
argument_list|(
name|serialize_revprops_header
argument_list|(
name|stream
argument_list|,
name|revprops
operator|->
name|start_revision
operator|+
name|start
argument_list|,
name|revprops
operator|->
name|sizes
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* append the serialized revprops */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|==
name|changed_index
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|new_serialized
operator|->
name|data
argument_list|,
operator|&
name|new_serialized
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_size_t
name|size
init|=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|apr_size_t
name|offset
init|=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|offsets
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|+
name|offset
argument_list|,
operator|&
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush the stream buffer (if any) to our underlying data buffer */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compress / store the data */
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|uncompressed
argument_list|,
name|compressed
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
else|:
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finally, write the content to the target file, flush and close it */
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
name|compressed
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new pack file name for revisions  *     [REVPROPS->START_REVISION + START, REVPROPS->START_REVISION + END - 1]  * of REVPROPS->MANIFEST.  Add the name of old file to FILES_TO_DELETE,  * auto-create that array if necessary.  Return an open file *FILE that is  * allocated in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repack_file_open
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|files_to_delete
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int64_t
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag_string
decl_stmt|;
name|svn_string_t
modifier|*
name|new_filename
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|manifest_offset
init|=
call|(
name|int
call|)
argument_list|(
name|revprops
operator|->
name|start_revision
operator|-
name|revprops
operator|->
name|manifest_start
argument_list|)
decl_stmt|;
comment|/* get the old (= current) file name and enlist it for later deletion */
specifier|const
name|char
modifier|*
name|old_filename
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|start
operator|+
name|manifest_offset
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|files_to_delete
operator|==
name|NULL
condition|)
operator|*
name|files_to_delete
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|files_to_delete
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|old_filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* increase the tag part, i.e. the counter after the dot */
name|tag_string
operator|=
name|strchr
argument_list|(
name|old_filename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_string
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed file '%s' misses a tag"
argument_list|)
argument_list|,
name|old_filename
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|tag
argument_list|,
name|tag_string
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new_filename
operator|=
name|svn_string_createf
argument_list|(
name|pool
argument_list|,
literal|"%ld.%"
name|APR_INT64_T_FMT
argument_list|,
name|revprops
operator|->
name|start_revision
operator|+
name|start
argument_list|,
operator|++
name|tag
argument_list|)
expr_stmt|;
comment|/* update the manifest to point to the new file */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|i
operator|+
name|manifest_offset
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|new_filename
operator|->
name|data
expr_stmt|;
comment|/* open the file */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
name|file
argument_list|,
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|new_filename
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For revision REV in filesystem FS, set the revision properties to  * PROPLIST.  Return a new file in *TMP_PATH that the caller shall move  * to *FINAL_PATH to make the change visible.  Files to be deleted will  * be listed in *FILES_TO_DELETE which may remain unchanged / unallocated.  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_packed_revprop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_path
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|files_to_delete
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|packed_revprops_t
modifier|*
name|revprops
decl_stmt|;
name|apr_int64_t
name|generation
init|=
literal|0
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_off_t
name|new_total_size
decl_stmt|;
name|int
name|changed_index
decl_stmt|;
comment|/* read contents of the current pack file */
name|SVN_ERR
argument_list|(
name|read_pack_revprop
argument_list|(
operator|&
name|revprops
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize the new revprops */
name|serialized
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|serialized
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate the size of the new data */
name|changed_index
operator|=
call|(
name|int
call|)
argument_list|(
name|rev
operator|-
name|revprops
operator|->
name|start_revision
argument_list|)
expr_stmt|;
name|new_total_size
operator|=
name|revprops
operator|->
name|total_size
operator|-
name|revprops
operator|->
name|serialized_size
operator|+
name|serialized
operator|->
name|len
operator|+
operator|(
name|revprops
operator|->
name|offsets
operator|->
name|nelts
operator|+
literal|2
operator|)
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|changed_index
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
comment|/* can we put the new data into the same pack as the before? */
if|if
condition|(
name|new_total_size
operator|<
name|ffd
operator|->
name|revprop_pack_size
operator|||
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
comment|/* simply replace the old pack file with new content as we do it        * in the non-packed case */
operator|*
name|final_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|revprops
operator|->
name|filename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
name|tmp_path
argument_list|,
name|revprops
operator|->
name|folder
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* split the pack file into two of roughly equal size */
name|int
name|right_count
decl_stmt|,
name|left_count
decl_stmt|,
name|i
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|;
name|int
name|right
init|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
literal|1
decl_stmt|;
name|apr_off_t
name|left_size
init|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
decl_stmt|;
name|apr_off_t
name|right_size
init|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
decl_stmt|;
comment|/* let left and right side grow such that their size difference        * is minimal after each step. */
while|while
condition|(
name|left
operator|<=
name|right
condition|)
if|if
condition|(
name|left_size
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|left
argument_list|,
name|apr_off_t
argument_list|)
operator|<
name|right_size
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|right
argument_list|,
name|apr_off_t
argument_list|)
condition|)
block|{
name|left_size
operator|+=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|left
argument_list|,
name|apr_off_t
argument_list|)
operator|+
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
operator|++
name|left
expr_stmt|;
block|}
else|else
block|{
name|right_size
operator|+=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|right
argument_list|,
name|apr_off_t
argument_list|)
operator|+
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
comment|/* since the items need much less than SVN_INT64_BUFFER_SIZE         * bytes to represent their length, the split may not be optimal */
name|left_count
operator|=
name|left
expr_stmt|;
name|right_count
operator|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|left
expr_stmt|;
comment|/* if new_size is large, one side may exceed the pack size limit.        * In that case, split before and after the modified revprop.*/
if|if
condition|(
name|left_size
operator|>
name|ffd
operator|->
name|revprop_pack_size
operator|||
name|right_size
operator|>
name|ffd
operator|->
name|revprop_pack_size
condition|)
block|{
name|left_count
operator|=
name|changed_index
expr_stmt|;
name|right_count
operator|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|left_count
operator|-
literal|1
expr_stmt|;
block|}
comment|/* write the new, split files */
if|if
condition|(
name|left_count
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|left_count
argument_list|,
name|files_to_delete
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|left_count
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left_count
operator|+
name|right_count
operator|<
name|revprops
operator|->
name|sizes
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
name|changed_index
argument_list|,
name|changed_index
operator|+
literal|1
argument_list|,
name|files_to_delete
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
name|changed_index
argument_list|,
name|changed_index
operator|+
literal|1
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right_count
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|right_count
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|files_to_delete
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|right_count
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write the new manifest */
operator|*
name|final_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
name|tmp_path
argument_list|,
name|revprops
operator|->
name|folder
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|manifest
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|filename
argument_list|,
name|strlen
argument_list|(
name|filename
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_putc
argument_list|(
literal|'\n'
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the revision property list of revision REV in filesystem FS to    PROPLIST.  Use POOL for temporary allocations. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__set_revision_proplist
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_packed
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|perms_reference
decl_stmt|;
name|apr_array_header_t
modifier|*
name|files_to_delete
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this info will not change while we hold the global FS write lock */
name|is_packed
operator|=
name|svn_fs_fs__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|/* Serialize the new revprop data */
if|if
condition|(
name|is_packed
condition|)
name|SVN_ERR
argument_list|(
name|write_packed_revprop
argument_list|(
operator|&
name|final_path
argument_list|,
operator|&
name|tmp_path
argument_list|,
operator|&
name|files_to_delete
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|write_non_packed_revprop
argument_list|(
operator|&
name|final_path
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use the rev file of this revision as the perms reference,    * because when setting revprops for the first time, the revprop    * file won't exist and therefore can't serve as its own reference.    * (Whereas the rev file should already exist at this point.)    */
name|perms_reference
operator|=
name|svn_fs_fs__path_rev_absolute
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Now, switch to the new revprop data. */
name|SVN_ERR
argument_list|(
name|switch_to_new_revprop
argument_list|(
name|fs
argument_list|,
name|final_path
argument_list|,
name|tmp_path
argument_list|,
name|perms_reference
argument_list|,
name|files_to_delete
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if for REVISION in FS, we can find the revprop pack file.  * Use POOL for temporary allocations.  * Set *MISSING, if the reason is a missing manifest or pack file.  */
end_comment

begin_function
name|svn_boolean_t
name|svn_fs_fs__packed_revprop_available
parameter_list|(
name|svn_boolean_t
modifier|*
name|missing
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
comment|/* try to read the manifest file */
specifier|const
name|char
modifier|*
name|folder
init|=
name|svn_fs_fs__path_revprops_pack_shard
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|manifest_path
init|=
name|svn_dirent_join
argument_list|(
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_fs__try_stringbuf_from_file
argument_list|(
operator|&
name|content
argument_list|,
name|missing
argument_list|,
name|manifest_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* if the manifest cannot be read, consider the pack files inaccessible    * even if the file itself exists. */
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|missing
condition|)
return|return
name|FALSE
return|;
comment|/* parse manifest content until we find the entry for REVISION.    * Revision 0 is never packed. */
name|revision
operator|=
name|revision
operator|<
name|ffd
operator|->
name|max_files_per_dir
condition|?
name|revision
operator|-
literal|1
else|:
name|revision
operator|%
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
while|while
condition|(
name|content
operator|->
name|data
condition|)
block|{
name|char
modifier|*
name|next
init|=
name|strchr
argument_list|(
name|content
operator|->
name|data
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
condition|)
block|{
operator|*
name|next
operator|=
literal|0
expr_stmt|;
operator|++
name|next
expr_stmt|;
block|}
if|if
condition|(
name|revision
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* the respective pack file must exist (and be a file) */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|err
operator|=
name|svn_io_check_path
argument_list|(
name|svn_dirent_join
argument_list|(
name|folder
argument_list|,
name|content
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|missing
operator|=
name|kind
operator|==
name|svn_node_none
expr_stmt|;
return|return
name|kind
operator|==
name|svn_node_file
return|;
block|}
name|content
operator|->
name|data
operator|=
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****** Packing FSFS shards *********/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__copy_revprops
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|apr_array_header_t
modifier|*
name|sizes
parameter_list|,
name|apr_size_t
name|total_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|pack_stream
decl_stmt|;
name|apr_file_t
modifier|*
name|pack_file
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* create empty data buffer and a write stream on top of it */
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|total_size
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|pack_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* write the pack file header */
name|SVN_ERR
argument_list|(
name|serialize_revprops_header
argument_list|(
name|pack_stream
argument_list|,
name|start_rev
argument_list|,
name|sizes
argument_list|,
literal|0
argument_list|,
name|sizes
operator|->
name|nelts
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some useful paths. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|pack_file
argument_list|,
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Iterate over the revisions in this shard, squashing them together. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Construct the file name. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Copy all the bits from the non-packed revprop file to the end of        * the pack file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|stream
argument_list|,
name|pack_stream
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush stream buffers to content buffer */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|pack_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compress the content (or just store it for COMPRESSION_LEVEL 0) */
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|uncompressed
argument_list|,
name|compressed
argument_list|,
name|compression_level
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the pack file content to disk */
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|pack_file
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
name|compressed
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|pack_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|pack_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__pack_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_off_t
name|max_pack_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|manifest_file_path
decl_stmt|,
modifier|*
name|pack_filename
init|=
name|NULL
decl_stmt|;
name|apr_file_t
modifier|*
name|manifest_file
decl_stmt|;
name|svn_stream_t
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|,
name|rev
decl_stmt|;
name|apr_off_t
name|total_size
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sizes
decl_stmt|;
comment|/* Some useful paths. */
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Remove any existing pack file for this shard, since it is incomplete. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|pack_file_dir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory and manifest file stream. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|pack_file_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|manifest_file
argument_list|,
name|manifest_file_path
argument_list|,
name|APR_WRITE
operator||
name|APR_BUFFERED
operator||
name|APR_CREATE
operator||
name|APR_EXCL
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|manifest_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|manifest_file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* revisions to handle. Special case: revision 0 */
name|start_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|shard
operator|*
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|end_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|shard
operator|+
literal|1
operator|)
operator|*
operator|(
name|max_files_per_dir
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_rev
operator|==
literal|0
condition|)
operator|++
name|start_rev
expr_stmt|;
comment|/* Special special case: if max_files_per_dir is 1, then at this point        start_rev == 1 and end_rev == 0 (!).  Fortunately, everything just        works. */
comment|/* initialize the revprop size info */
name|sizes
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|max_files_per_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|total_size
operator|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
comment|/* Iterate over the revisions in this shard, determine their size and    * squashing them together into pack files. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the size of the file. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if we already have started a pack file and this revprop cannot be        * appended to it, write the previous pack file. */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|!=
literal|0
operator|&&
name|total_size
operator|+
name|SVN_INT64_BUFFER_SIZE
operator|+
name|finfo
operator|.
name|size
operator|>
name|max_pack_size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__copy_revprops
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|shard_path
argument_list|,
name|start_rev
argument_list|,
name|rev
operator|-
literal|1
argument_list|,
name|sizes
argument_list|,
operator|(
name|apr_size_t
operator|)
name|total_size
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* next pack file starts empty again */
name|apr_array_clear
argument_list|(
name|sizes
argument_list|)
expr_stmt|;
name|total_size
operator|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
name|start_rev
operator|=
name|rev
expr_stmt|;
block|}
comment|/* Update the manifest. Allocate a file name for the current pack        * file if it is a new one */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|==
literal|0
condition|)
name|pack_filename
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld.0"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|manifest_stream
argument_list|,
name|iterpool
argument_list|,
literal|"%s\n"
argument_list|,
name|pack_filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add to list of files to put into the current pack file */
name|APR_ARRAY_PUSH
argument_list|(
name|sizes
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|finfo
operator|.
name|size
expr_stmt|;
name|total_size
operator|+=
name|SVN_INT64_BUFFER_SIZE
operator|+
name|finfo
operator|.
name|size
expr_stmt|;
block|}
comment|/* write the last pack file */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|!=
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__copy_revprops
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|shard_path
argument_list|,
name|start_rev
argument_list|,
name|rev
operator|-
literal|1
argument_list|,
name|sizes
argument_list|,
operator|(
name|apr_size_t
operator|)
name|total_size
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush the manifest file to disk and update permissions */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|manifest_file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|manifest_file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|shard_path
argument_list|,
name|pack_file_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__delete_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|==
literal|0
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* delete all files except the one for revision 0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max_files_per_dir
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|cancel_func
call|)
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|shard_path
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

