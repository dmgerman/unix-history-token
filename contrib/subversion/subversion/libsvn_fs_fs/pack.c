begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pack.c --- FSFS shard packing functionality  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_comment
comment|/* Logical addressing packing logic:  *  * We pack files on a pack file basis (e.g. 1000 revs) without changing  * existing pack files nor the revision files outside the range to pack.  *  * First, we will scan the revision file indexes to determine the number  * of items to "place" (i.e. determine their optimal position within the  * future pack file).  For each item, we will need a constant amount of  * memory to track it.  A MAX_MEM parameter sets a limit to the number of  * items we may place in one go.  That means, we may not be able to add  * all revisions at once.  Instead, we will run the placement for a subset  * of revisions at a time.  The very unlikely worst case will simply append  * all revision data with just a little reshuffling inside each revision.  *  * In a second step, we read all revisions in the selected range, build  * the item tracking information and copy the items themselves from the  * revision files to temporary files.  The latter serve as buckets for a  * very coarse bucket presort:  Separate change lists, file properties,  * directory properties and noderevs + representations from one another.  *  * The third step will determine an optimized placement for the items in  * each of the 4 buckets separately.  The first three will simply order  * their items by revision, starting with the newest once.  Placing rep  * and noderev items is a more elaborate process documented in the code.  *  * In short, we store items in the following order:  * - changed paths lists  * - node property  * - directory properties  * - directory representations corresponding noderevs, lexical path order  *   with special treatment of "trunk" and "branches"  * - same for file representations  *  * Step 4 copies the items from the temporary buckets into the final  * pack file and writes the temporary index files.  *  * Finally, after the last range of revisions, create the final indexes.  */
end_comment

begin_comment
comment|/* Maximum amount of memory we allocate for placement information during  * the pack process.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MAX_MEM
value|(64 * 1024 * 1024)
end_define

begin_comment
comment|/* Data structure describing a node change at PATH, REVISION.  * We will sort these instances by PATH and NODE_ID such that we can combine  * similar nodes in the same reps container and store containers in path  * major order.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|path_order_t
block|{
comment|/* changed path */
name|svn_prefix_string__t
modifier|*
name|path
decl_stmt|;
comment|/* node ID for this PATH in REVISION */
name|svn_fs_fs__id_part_t
name|node_id
decl_stmt|;
comment|/* when this change happened */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* noderev predecessor count */
name|int
name|predecessor_count
decl_stmt|;
comment|/* this is a directory node */
name|svn_boolean_t
name|is_dir
decl_stmt|;
comment|/* length of the expanded representation content */
name|apr_int64_t
name|expanded_size
decl_stmt|;
comment|/* item ID of the noderev linked to the change. May be (0, 0). */
name|svn_fs_fs__id_part_t
name|noderev_id
decl_stmt|;
comment|/* item ID of the representation containing the new data. May be (0, 0). */
name|svn_fs_fs__id_part_t
name|rep_id
decl_stmt|;
block|}
name|path_order_t
typedef|;
end_typedef

begin_comment
comment|/* Represents a reference from item FROM to item TO.  FROM may be a noderev  * or rep_id while TO is (currently) always a representation.  We will sort  * them by TO which allows us to collect all dependent items.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reference_t
block|{
name|svn_fs_fs__id_part_t
name|to
decl_stmt|;
name|svn_fs_fs__id_part_t
name|from
decl_stmt|;
block|}
name|reference_t
typedef|;
end_typedef

begin_comment
comment|/* This structure keeps track of all the temporary data and status that  * needs to be kept around during the creation of one pack file.  After  * each revision range (in case we can't process all revs at once due to  * memory restrictions), parts of the data will get re-initialized.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pack_context_t
block|{
comment|/* file system that we operate on */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* cancel function to invoke at regular intervals. May be NULL */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
comment|/* baton to pass to CANCEL_FUNC */
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* first revision in the shard (and future pack file) */
name|svn_revnum_t
name|shard_rev
decl_stmt|;
comment|/* first revision in the range to process (>= SHARD_REV) */
name|svn_revnum_t
name|start_rev
decl_stmt|;
comment|/* first revision after the range to process (<= SHARD_END_REV) */
name|svn_revnum_t
name|end_rev
decl_stmt|;
comment|/* first revision after the current shard */
name|svn_revnum_t
name|shard_end_rev
decl_stmt|;
comment|/* log-to-phys proto index for the whole pack file */
name|apr_file_t
modifier|*
name|proto_l2p_index
decl_stmt|;
comment|/* phys-to-log proto index for the whole pack file */
name|apr_file_t
modifier|*
name|proto_p2l_index
decl_stmt|;
comment|/* full shard directory path (containing the unpacked revisions) */
specifier|const
name|char
modifier|*
name|shard_dir
decl_stmt|;
comment|/* full packed shard directory path (containing the pack file + indexes) */
specifier|const
name|char
modifier|*
name|pack_file_dir
decl_stmt|;
comment|/* full pack file path (including PACK_FILE_DIR) */
specifier|const
name|char
modifier|*
name|pack_file_path
decl_stmt|;
comment|/* current write position (i.e. file length) in the pack file */
name|apr_off_t
name|pack_offset
decl_stmt|;
comment|/* the pack file to ultimately write all data to */
name|apr_file_t
modifier|*
name|pack_file
decl_stmt|;
comment|/* array of svn_fs_fs__p2l_entry_t *, all referring to change lists.    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_array_header_t
modifier|*
name|changes
decl_stmt|;
comment|/* temp file receiving all change list items (referenced by CHANGES).    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_file_t
modifier|*
name|changes_file
decl_stmt|;
comment|/* array of svn_fs_fs__p2l_entry_t *, all referring to file properties.    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_array_header_t
modifier|*
name|file_props
decl_stmt|;
comment|/* temp file receiving all file prop items (referenced by FILE_PROPS).    * Will be filled in phase 2 and be cleared after each revision range.*/
name|apr_file_t
modifier|*
name|file_props_file
decl_stmt|;
comment|/* array of svn_fs_fs__p2l_entry_t *, all referring to directory properties.    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_array_header_t
modifier|*
name|dir_props
decl_stmt|;
comment|/* temp file receiving all directory prop items (referenced by DIR_PROPS).    * Will be filled in phase 2 and be cleared after each revision range.*/
name|apr_file_t
modifier|*
name|dir_props_file
decl_stmt|;
comment|/* container for all PATH members in PATH_ORDER. */
name|svn_prefix_tree__t
modifier|*
name|paths
decl_stmt|;
comment|/* array of path_order_t *.  Will be filled in phase 2 and be cleared    * after each revision range.  Sorted by PATH, NODE_ID. */
name|apr_array_header_t
modifier|*
name|path_order
decl_stmt|;
comment|/* array of reference_t* linking representations to their delta bases.    * Will be filled in phase 2 and be cleared after each revision range.    * It will be sorted by the FROM members (for rep->base rep lookup). */
name|apr_array_header_t
modifier|*
name|references
decl_stmt|;
comment|/* array of svn_fs_fs__p2l_entry_t*.  Will be filled in phase 2 and be    * cleared after each revision range.  During phase 3, we will set items    * to NULL that we already processed. */
name|apr_array_header_t
modifier|*
name|reps
decl_stmt|;
comment|/* array of int, marking for each revision, the which offset their items    * begin in REPS.  Will be filled in phase 2 and be cleared after    * each revision range. */
name|apr_array_header_t
modifier|*
name|rev_offsets
decl_stmt|;
comment|/* temp file receiving all items referenced by REPS.    * Will be filled in phase 2 and be cleared after each revision range.*/
name|apr_file_t
modifier|*
name|reps_file
decl_stmt|;
comment|/* pool used for temporary data structures that will be cleaned up when    * the next range of revisions is being processed */
name|apr_pool_t
modifier|*
name|info_pool
decl_stmt|;
block|}
name|pack_context_t
typedef|;
end_typedef

begin_comment
comment|/* Create and initialize a new pack context for packing shard SHARD_REV in  * SHARD_DIR into PACK_FILE_DIR within filesystem FS.  Allocate it in POOL  * and return the structure in *CONTEXT.  *  * Limit the number of items being copied per iteration to MAX_ITEMS.  * Set CANCEL_FUNC and CANCEL_BATON as well.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|initialize_pack_context
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_dir
parameter_list|,
name|svn_revnum_t
name|shard_rev
parameter_list|,
name|int
name|max_items
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_dir
decl_stmt|;
name|int
name|max_revs
init|=
name|MIN
argument_list|(
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|max_items
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_LOG_ADDRESSING_FORMAT
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|shard_rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* where we will place our various temp files */
name|SVN_ERR
argument_list|(
name|svn_io_temp_dir
argument_list|(
operator|&
name|temp_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store parameters */
name|context
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|context
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|context
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|context
operator|->
name|shard_rev
operator|=
name|shard_rev
expr_stmt|;
name|context
operator|->
name|start_rev
operator|=
name|shard_rev
expr_stmt|;
name|context
operator|->
name|end_rev
operator|=
name|shard_rev
expr_stmt|;
name|context
operator|->
name|shard_end_rev
operator|=
name|shard_rev
operator|+
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* Create the new directory and pack file. */
name|context
operator|->
name|shard_dir
operator|=
name|shard_dir
expr_stmt|;
name|context
operator|->
name|pack_file_dir
operator|=
name|pack_file_dir
expr_stmt|;
name|context
operator|->
name|pack_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_PACKED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|context
operator|->
name|pack_file
argument_list|,
name|context
operator|->
name|pack_file_path
argument_list|,
name|APR_WRITE
operator||
name|APR_BUFFERED
operator||
name|APR_BINARY
operator||
name|APR_EXCL
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Proto index files */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_open
argument_list|(
operator|&
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|svn_dirent_join
argument_list|(
argument|pack_file_dir
argument_list|,
argument|PATH_INDEX PATH_EXT_L2P_INDEX
argument_list|,
argument|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_open
argument_list|(
operator|&
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|svn_dirent_join
argument_list|(
argument|pack_file_dir
argument_list|,
argument|PATH_INDEX PATH_EXT_P2L_INDEX
argument_list|,
argument|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* item buckets: one item info array and one temp file per bucket */
name|context
operator|->
name|changes
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|changes_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|file_props
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|file_props_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|dir_props
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|dir_props_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* noderev and representation item bucket */
name|context
operator|->
name|rev_offsets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_revs
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|path_order
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|path_order_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|references
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|reference_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|reps
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|reps_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the pool used for temp structures */
name|context
operator|->
name|info_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|context
operator|->
name|paths
operator|=
name|svn_prefix_tree__create
argument_list|(
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Clean up / free all revision range specific data and files in CONTEXT.  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reset_pack_context
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_clear
argument_list|(
name|context
operator|->
name|changes
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|changes_file
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|file_props
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|file_props_file
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|dir_props
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|dir_props_file
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|rev_offsets
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|path_order
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|references
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|reps
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|reps_file
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Call this after the last revision range.  It will finalize all index files  * for CONTEXT and close any open files.  Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_pack_context
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|proto_l2p_index_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto_p2l_index_path
decl_stmt|;
comment|/* need the file names for the actual index creation call further down */
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|proto_l2p_index_path
argument_list|,
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|proto_p2l_index_path
argument_list|,
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finalize proto index files */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append the actual index data to the pack file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__add_index_data
argument_list|(
name|context
operator|->
name|fs
argument_list|,
name|context
operator|->
name|pack_file
argument_list|,
name|proto_l2p_index_path
argument_list|,
name|proto_p2l_index_path
argument_list|,
name|context
operator|->
name|shard_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove proto index files */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|proto_l2p_index_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|proto_p2l_index_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure that packed file is written to disk.*/
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Efficiently copy SIZE bytes from SOURCE to DEST.  Invoke the CANCEL_FUNC  * from CONTEXT at regular intervals.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_file_data
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|dest
parameter_list|,
name|apr_file_t
modifier|*
name|source
parameter_list|,
name|apr_off_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* most non-representation items will be small.  Minimize the buffer    * and infrastructure overhead in that case. */
enum|enum
block|{
name|STACK_BUFFER_SIZE
init|=
literal|1024
block|}
enum|;
if|if
condition|(
name|size
operator|<
name|STACK_BUFFER_SIZE
condition|)
block|{
comment|/* copy small data using a fixed-size buffer on stack */
name|char
name|buffer
index|[
name|STACK_BUFFER_SIZE
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|source
argument_list|,
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dest
argument_list|,
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|size
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use streaming copies for larger data blocks.  That may require        * the allocation of larger buffers and we should make sure that        * this extra memory is released asap. */
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|copypool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|apr_palloc
argument_list|(
name|copypool
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|apr_size_t
name|to_copy
init|=
call|(
name|apr_size_t
call|)
argument_list|(
name|MIN
argument_list|(
name|size
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|context
operator|->
name|cancel_func
argument_list|(
name|context
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|source
argument_list|,
name|buffer
argument_list|,
name|to_copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dest
argument_list|,
name|buffer
argument_list|,
name|to_copy
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|to_copy
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|copypool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Writes SIZE bytes, all 0, to DEST.  Uses POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_null_bytes
parameter_list|(
name|apr_file_t
modifier|*
name|dest
parameter_list|,
name|apr_off_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Have a collection of high-quality, easy to access NUL bytes handy. */
enum|enum
block|{
name|BUFFER_SIZE
init|=
literal|1024
block|}
enum|;
specifier|static
specifier|const
name|char
name|buffer
index|[
name|BUFFER_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* copy SIZE of them into the file's buffer */
while|while
condition|(
name|size
condition|)
block|{
name|apr_size_t
name|to_write
init|=
name|MIN
argument_list|(
name|size
argument_list|,
name|BUFFER_SIZE
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dest
argument_list|,
name|buffer
argument_list|,
name|to_write
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|to_write
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the "simple" item (changed paths list or property representation)  * from the current position in REV_FILE to TEMP_FILE using CONTEXT.  Add  * a copy of ENTRY to ENTRIES but with an updated offset value that points  * to the copy destination in TEMP_FILE.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_item_to_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|new_entry
init|=
name|apr_pmemdup
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|new_entry
operator|->
name|offset
argument_list|,
name|temp_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
operator|=
name|new_entry
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|rev_file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the offset within CONTEXT->REPS that corresponds to item  * ITEM_INDEX in  REVISION.  */
end_comment

begin_function
specifier|static
name|int
name|get_item_array_index
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_int64_t
name|item_index
parameter_list|)
block|{
name|assert
argument_list|(
name|revision
operator|>=
name|context
operator|->
name|start_rev
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|item_index
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|rev_offsets
argument_list|,
name|revision
operator|-
name|context
operator|->
name|start_rev
argument_list|,
name|int
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write INFO to the correct position in CONTEXT->REP_INFOS.  The latter  * may need auto-expanding.  Overwriting an array element is not allowed.  */
end_comment

begin_function
specifier|static
name|void
name|add_item_rep_mapping
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
comment|/* index of INFO */
name|idx
operator|=
name|get_item_array_index
argument_list|(
name|context
argument_list|,
name|entry
operator|->
name|item
operator|.
name|revision
argument_list|,
name|entry
operator|->
name|item
operator|.
name|number
argument_list|)
expr_stmt|;
comment|/* make sure the index exists in the array */
while|while
condition|(
name|context
operator|->
name|reps
operator|->
name|nelts
operator|<=
name|idx
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* set the element.  If there is already an entry, there are probably    * two items claiming to be the same -> bail out */
name|assert
argument_list|(
operator|!
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the P2L entry from CONTEXT->REPS for the given ID.  If there is  * none (or not anymore), return NULL.  If RESET has been specified, set  * the array entry to NULL after returning the entry.  */
end_comment

begin_function
specifier|static
name|svn_fs_fs__p2l_entry_t
modifier|*
name|get_item
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|id
parameter_list|,
name|svn_boolean_t
name|reset
parameter_list|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|number
operator|&&
name|id
operator|->
name|revision
operator|>=
name|context
operator|->
name|start_rev
condition|)
block|{
name|int
name|idx
init|=
name|get_item_array_index
argument_list|(
name|context
argument_list|,
name|id
operator|->
name|revision
argument_list|,
name|id
operator|->
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|reps
operator|->
name|nelts
operator|>
name|idx
condition|)
block|{
name|result
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|reset
condition|)
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Copy representation item identified by ENTRY from the current position  * in REV_FILE into CONTEXT->REPS_FILE.  Add all tracking into needed by  * our placement algorithm to CONTEXT.  Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_rep_to_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_fs__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_off_t
name|source_offset
init|=
name|entry
operator|->
name|offset
decl_stmt|;
comment|/* create a copy of ENTRY, make it point to the copy destination and    * store it in CONTEXT */
name|entry
operator|=
name|apr_pmemdup
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|add_item_rep_mapping
argument_list|(
name|context
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* read& parse the representation header */
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|rev_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_rep_header
argument_list|(
operator|&
name|rep_header
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* if the representation is a delta against some other rep, link the two */
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_delta
operator|&&
name|rep_header
operator|->
name|base_revision
operator|>=
name|context
operator|->
name|start_rev
condition|)
block|{
name|reference_t
modifier|*
name|reference
init|=
name|apr_pcalloc
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reference
argument_list|)
argument_list|)
decl_stmt|;
name|reference
operator|->
name|from
operator|=
name|entry
operator|->
name|item
expr_stmt|;
name|reference
operator|->
name|to
operator|.
name|revision
operator|=
name|rep_header
operator|->
name|base_revision
expr_stmt|;
name|reference
operator|->
name|to
operator|.
name|number
operator|=
name|rep_header
operator|->
name|base_item_index
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|references
argument_list|,
name|reference_t
operator|*
argument_list|)
operator|=
name|reference
expr_stmt|;
block|}
comment|/* copy the whole rep (including header!) to our temp file */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|source_offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|rev_file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Directories first, dirs / files sorted by name in reverse lexical order.  * This maximizes the chance of two items being located close to one another  * in *all* pack files independent of their change order.  It also groups  * multi-project repos nicely according to their sub-projects.  The reverse  * order aspect gives "trunk" preference over "tags" and "branches", so  * trunk-related items are more likely to be contiguous.  */
end_comment

begin_function
specifier|static
name|int
name|compare_dir_entries_format7
parameter_list|(
specifier|const
name|svn_sort__item_t
modifier|*
name|a
parameter_list|,
specifier|const
name|svn_sort__item_t
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|lhs
init|=
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
operator|)
name|a
operator|->
name|value
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
name|rhs
init|=
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
operator|)
name|b
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|lhs
operator|->
name|kind
operator|!=
name|rhs
operator|->
name|kind
condition|)
return|return
name|lhs
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
name|strcmp
argument_list|(
name|lhs
operator|->
name|name
argument_list|,
name|rhs
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Directories entries sorted by revision (decreasing - to max cache hits)  * and offset (increasing - to max benefit from APR file buffering).  */
end_comment

begin_function
specifier|static
name|int
name|compare_dir_entries_format6
parameter_list|(
specifier|const
name|svn_sort__item_t
modifier|*
name|a
parameter_list|,
specifier|const
name|svn_sort__item_t
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|lhs
init|=
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
operator|)
name|a
operator|->
name|value
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
name|rhs
init|=
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
operator|)
name|b
operator|->
name|value
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|lhs_rev_item
init|=
name|svn_fs_fs__id_rev_item
argument_list|(
name|lhs
operator|->
name|id
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|rhs_rev_item
init|=
name|svn_fs_fs__id_rev_item
argument_list|(
name|rhs
operator|->
name|id
argument_list|)
decl_stmt|;
comment|/* decreasing ("reverse") order on revs */
if|if
condition|(
name|lhs_rev_item
operator|->
name|revision
operator|!=
name|rhs_rev_item
operator|->
name|revision
condition|)
return|return
name|lhs_rev_item
operator|->
name|revision
operator|>
name|rhs_rev_item
operator|->
name|revision
condition|?
operator|-
literal|1
else|:
literal|1
return|;
comment|/* increasing order on offsets */
if|if
condition|(
name|lhs_rev_item
operator|->
name|number
operator|!=
name|rhs_rev_item
operator|->
name|number
condition|)
return|return
name|lhs_rev_item
operator|->
name|number
operator|>
name|rhs_rev_item
operator|->
name|number
condition|?
literal|1
else|:
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|apr_array_header_t
modifier|*
name|svn_fs_fs__order_dir_entries
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|directory
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|ordered
init|=
name|svn_sort__hash
argument_list|(
name|directory
argument_list|,
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|?
name|compare_dir_entries_format7
else|:
name|compare_dir_entries_format6
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|result
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|ordered
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_dirent_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ordered
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|result
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|ordered
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|value
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a duplicate of the the ORIGINAL path and with special sub-strins  * (e.g. "trunk") modified in such a way that have a lower lexicographic  * value than any other "normal" file name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tweak_path_for_ordering
parameter_list|(
specifier|const
name|char
modifier|*
name|original
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* We may add further special cases as needed. */
enum|enum
block|{
name|SPECIAL_COUNT
init|=
literal|2
block|}
enum|;
specifier|static
specifier|const
name|char
modifier|*
name|special
index|[
name|SPECIAL_COUNT
index|]
init|=
block|{
literal|"trunk"
block|,
literal|"branch"
block|}
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|original
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Replace the first char of any "special" sub-string we find by    * a control char, i.e. '\1' .. '\31'.  In the rare event that this    * would clash with existing paths, no data will be lost but merely    * the node ordering will be sub-optimal.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPECIAL_COUNT
condition|;
operator|++
name|i
control|)
for|for
control|(
name|pos
operator|=
name|strstr
argument_list|(
name|path
argument_list|,
name|special
index|[
name|i
index|]
argument_list|)
init|;
name|pos
condition|;
name|pos
operator|=
name|strstr
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|special
index|[
name|i
index|]
argument_list|)
control|)
block|{
operator|*
name|pos
operator|=
call|(
name|char
call|)
argument_list|(
name|i
operator|+
literal|'\1'
argument_list|)
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Copy node revision item identified by ENTRY from the current position  * in REV_FILE into CONTEXT->REPS_FILE.  Add all tracking into needed by  * our placement algorithm to CONTEXT.  Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_node_to_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|path_order_t
modifier|*
name|path_order
init|=
name|apr_pcalloc
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|path_order
argument_list|)
argument_list|)
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|sort_path
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_off_t
name|source_offset
init|=
name|entry
operator|->
name|offset
decl_stmt|;
comment|/* read& parse noderev */
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|rev_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
operator|&
name|noderev
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
expr_stmt|;
comment|/* create a copy of ENTRY, make it point to the copy destination and    * store it in CONTEXT */
name|entry
operator|=
name|apr_pmemdup
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|add_item_rep_mapping
argument_list|(
name|context
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* copy the noderev to our temp file */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|source_offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|rev_file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the node has a data representation, make that the node's "base".    * This will (often) cause the noderev to be placed right in front of    * its data representation. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|>=
name|context
operator|->
name|start_rev
condition|)
block|{
name|path_order
operator|->
name|rep_id
operator|.
name|revision
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|revision
expr_stmt|;
name|path_order
operator|->
name|rep_id
operator|.
name|number
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|item_index
expr_stmt|;
name|path_order
operator|->
name|expanded_size
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
condition|?
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
else|:
name|noderev
operator|->
name|data_rep
operator|->
name|size
expr_stmt|;
block|}
comment|/* Sort path is the key used for ordering noderevs and associated reps.    * It will not be stored in the final pack file. */
name|sort_path
operator|=
name|tweak_path_for_ordering
argument_list|(
name|noderev
operator|->
name|created_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|path_order
operator|->
name|path
operator|=
name|svn_prefix_string__create
argument_list|(
name|context
operator|->
name|paths
argument_list|,
name|sort_path
argument_list|)
expr_stmt|;
name|path_order
operator|->
name|node_id
operator|=
operator|*
name|svn_fs_fs__id_node_id
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|path_order
operator|->
name|revision
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|path_order
operator|->
name|predecessor_count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
name|path_order
operator|->
name|is_dir
operator|=
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
expr_stmt|;
name|path_order
operator|->
name|noderev_id
operator|=
operator|*
name|svn_fs_fs__id_rev_item
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|path_order
argument_list|,
name|path_order_t
operator|*
argument_list|)
operator|=
name|path_order
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t.  Bring all directories in front of the files    and sort descendingly by PATH, NODE_ID and REVISION.  */
end_comment

begin_function
specifier|static
name|int
name|compare_path_order
parameter_list|(
specifier|const
name|path_order_t
modifier|*
specifier|const
modifier|*
name|lhs_p
parameter_list|,
specifier|const
name|path_order_t
modifier|*
specifier|const
modifier|*
name|rhs_p
parameter_list|)
block|{
specifier|const
name|path_order_t
modifier|*
name|lhs
init|=
operator|*
name|lhs_p
decl_stmt|;
specifier|const
name|path_order_t
modifier|*
name|rhs
init|=
operator|*
name|rhs_p
decl_stmt|;
comment|/* cluster all directories */
name|int
name|diff
init|=
name|rhs
operator|->
name|is_dir
operator|-
name|lhs
operator|->
name|is_dir
decl_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
comment|/* lexicographic order on path and node (i.e. latest first) */
name|diff
operator|=
name|svn_prefix_string__compare
argument_list|(
name|lhs
operator|->
name|path
argument_list|,
name|rhs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
comment|/* reverse order on node (i.e. latest first) */
name|diff
operator|=
name|svn_fs_fs__id_part_compare
argument_list|(
operator|&
name|rhs
operator|->
name|node_id
argument_list|,
operator|&
name|lhs
operator|->
name|node_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
comment|/* reverse order on revision (i.e. latest first) */
if|if
condition|(
name|lhs
operator|->
name|revision
operator|!=
name|rhs
operator|->
name|revision
condition|)
return|return
name|lhs
operator|->
name|revision
operator|<
name|rhs
operator|->
name|revision
condition|?
literal|1
else|:
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t.  Sort ascendingly by FROM, TO.  */
end_comment

begin_function
specifier|static
name|int
name|compare_references
parameter_list|(
specifier|const
name|reference_t
modifier|*
specifier|const
modifier|*
name|lhs_p
parameter_list|,
specifier|const
name|reference_t
modifier|*
specifier|const
modifier|*
name|rhs_p
parameter_list|)
block|{
specifier|const
name|reference_t
modifier|*
name|lhs
init|=
operator|*
name|lhs_p
decl_stmt|;
specifier|const
name|reference_t
modifier|*
name|rhs
init|=
operator|*
name|rhs_p
decl_stmt|;
name|int
name|diff
init|=
name|svn_fs_fs__id_part_compare
argument_list|(
operator|&
name|lhs
operator|->
name|from
argument_list|,
operator|&
name|rhs
operator|->
name|from
argument_list|)
decl_stmt|;
return|return
name|diff
condition|?
name|diff
else|:
name|svn_fs_fs__id_part_compare
argument_list|(
operator|&
name|lhs
operator|->
name|to
argument_list|,
operator|&
name|rhs
operator|->
name|to
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t.  Assume ascending order by FROM.  */
end_comment

begin_function
specifier|static
name|int
name|compare_ref_to_item
parameter_list|(
specifier|const
name|reference_t
modifier|*
specifier|const
modifier|*
name|lhs_p
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|rhs_p
parameter_list|)
block|{
return|return
name|svn_fs_fs__id_part_compare
argument_list|(
operator|&
operator|(
operator|*
name|lhs_p
operator|)
operator|->
name|from
argument_list|,
name|rhs_p
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t.  Finds the DIR / FILE boundary.  */
end_comment

begin_function
specifier|static
name|int
name|compare_is_dir
parameter_list|(
specifier|const
name|path_order_t
modifier|*
specifier|const
modifier|*
name|lhs_p
parameter_list|,
specifier|const
name|void
modifier|*
name|unused
parameter_list|)
block|{
return|return
operator|(
operator|*
name|lhs_p
operator|)
operator|->
name|is_dir
condition|?
operator|-
literal|1
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Look for the least significant bit set in VALUE and return the smallest  * number with the same property, i.e. the largest power of 2 that is a  * factor in VALUE. */
end_comment

begin_function
specifier|static
name|int
name|roundness
parameter_list|(
name|int
name|value
parameter_list|)
block|{
return|return
name|value
condition|?
name|value
operator|-
operator|(
name|value
operator|&
operator|(
name|value
operator|-
literal|1
operator|)
operator|)
else|:
name|INT_MAX
return|;
block|}
end_function

begin_comment
comment|/* Order a range of data collected in CONTEXT such that we can place them  * in the desired order.  The input is taken from *PATH_ORDER, offsets FIRST  * to LAST and then written in the final order to the same range in *TEMP.  */
end_comment

begin_function
specifier|static
name|void
name|sort_reps_range
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|path_order_t
modifier|*
modifier|*
name|path_order
parameter_list|,
specifier|const
name|path_order_t
modifier|*
modifier|*
name|temp
parameter_list|,
name|int
name|first
parameter_list|,
name|int
name|last
parameter_list|)
block|{
specifier|const
name|svn_prefix_string__t
modifier|*
name|path
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dest
decl_stmt|,
name|best
decl_stmt|;
name|svn_fs_fs__id_part_t
name|rep_id
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* The logic below would fail for empty ranges. */
if|if
condition|(
name|first
operator|==
name|last
condition|)
return|return;
comment|/* Re-order noderevs like this:    *    * (1) Most likely to be referenced by future pack files, in path order.    * (2) highest revision rep per path + dependency chain    * (3) Remaining reps in path, rev order    *    * We simply pick& chose from the existing path, rev order.    */
name|dest
operator|=
name|first
expr_stmt|;
name|path
operator|=
name|path_order
index|[
name|first
index|]
operator|->
name|path
expr_stmt|;
name|best
operator|=
name|first
expr_stmt|;
comment|/* (1) For each path, pick the "roundest" representation and put it in    * front of all other nodes in the pack file.  The "roundest" rep is    * the one most likely to be referenced from future pack files, i.e. we    * concentrate those potential "foreign link targets" in one section of    * the pack file.    *    * And we only apply this to reps outside the linear deltification    * sections because references *into* linear deltification ranges are    * much less likely.    */
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
block|{
comment|/* Investigated all nodes for the current path? */
if|if
condition|(
name|svn_prefix_string__compare
argument_list|(
name|path
argument_list|,
name|path_order
index|[
name|i
index|]
operator|->
name|path
argument_list|)
condition|)
block|{
comment|/* next path */
name|path
operator|=
name|path_order
index|[
name|i
index|]
operator|->
name|path
expr_stmt|;
comment|/* Pick roundest non-linear deltified node. */
if|if
condition|(
name|roundness
argument_list|(
name|path_order
index|[
name|best
index|]
operator|->
name|predecessor_count
argument_list|)
operator|>=
name|ffd
operator|->
name|max_linear_deltification
condition|)
block|{
name|temp
index|[
name|dest
operator|++
index|]
operator|=
name|path_order
index|[
name|best
index|]
expr_stmt|;
name|path_order
index|[
name|best
index|]
operator|=
name|NULL
expr_stmt|;
name|best
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* next entry */
if|if
condition|(
name|roundness
argument_list|(
name|path_order
index|[
name|best
index|]
operator|->
name|predecessor_count
argument_list|)
operator|<
name|roundness
argument_list|(
name|path_order
index|[
name|i
index|]
operator|->
name|predecessor_count
argument_list|)
condition|)
name|best
operator|=
name|i
expr_stmt|;
block|}
comment|/* Treat the last path the same as all others. */
if|if
condition|(
name|roundness
argument_list|(
name|path_order
index|[
name|best
index|]
operator|->
name|predecessor_count
argument_list|)
operator|>=
name|ffd
operator|->
name|max_linear_deltification
condition|)
block|{
name|temp
index|[
name|dest
operator|++
index|]
operator|=
name|path_order
index|[
name|best
index|]
expr_stmt|;
name|path_order
index|[
name|best
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* (2) For each (remaining) path, pick the nodes along the delta chain    * for the highest revision.  Due to our ordering, this is the first    * node we encounter for any path.    *    * Most references that don't hit a delta base picked in (1), will    * access HEAD of the respective path.  Keeping all its dependency chain    * in one place turns reconstruction into a linear scan of minimal length.    */
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|path_order
index|[
name|i
index|]
condition|)
block|{
comment|/* This is the first path we still have to handle. */
name|path
operator|=
name|path_order
index|[
name|i
index|]
operator|->
name|path
expr_stmt|;
name|rep_id
operator|=
name|path_order
index|[
name|i
index|]
operator|->
name|rep_id
expr_stmt|;
break|break;
block|}
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|path_order
index|[
name|i
index|]
condition|)
block|{
comment|/* New path? */
if|if
condition|(
name|svn_prefix_string__compare
argument_list|(
name|path
argument_list|,
name|path_order
index|[
name|i
index|]
operator|->
name|path
argument_list|)
condition|)
block|{
name|path
operator|=
name|path_order
index|[
name|i
index|]
operator|->
name|path
expr_stmt|;
name|rep_id
operator|=
name|path_order
index|[
name|i
index|]
operator|->
name|rep_id
expr_stmt|;
block|}
comment|/* Pick nodes along the deltification chain.  Skip side-branches. */
if|if
condition|(
name|svn_fs_fs__id_part_eq
argument_list|(
operator|&
name|path_order
index|[
name|i
index|]
operator|->
name|rep_id
argument_list|,
operator|&
name|rep_id
argument_list|)
condition|)
block|{
name|reference_t
modifier|*
modifier|*
name|reference
decl_stmt|;
name|temp
index|[
name|dest
operator|++
index|]
operator|=
name|path_order
index|[
name|i
index|]
expr_stmt|;
name|path_order
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|reference
operator|=
name|svn_sort__array_lookup
argument_list|(
name|context
operator|->
name|references
argument_list|,
operator|&
name|rep_id
argument_list|,
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_ref_to_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|reference
condition|)
name|rep_id
operator|=
operator|(
operator|*
name|reference
operator|)
operator|->
name|to
expr_stmt|;
block|}
block|}
comment|/* (3) All remaining nodes in path, rev order.  Linear deltification    * makes HEAD delta chains from (2) cover all or most of their deltas    * in a given pack file.  So, this is just a few remnants that we put    * at the end of the pack file.    */
for|for
control|(
name|i
operator|=
name|first
init|;
name|i
operator|<
name|last
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|path_order
index|[
name|i
index|]
condition|)
name|temp
index|[
name|dest
operator|++
index|]
operator|=
name|path_order
index|[
name|i
index|]
expr_stmt|;
comment|/* We now know the final ordering. */
name|assert
argument_list|(
name|dest
operator|==
name|last
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Order the data collected in CONTEXT such that we can place them in the  * desired order.  */
end_comment

begin_function
specifier|static
name|void
name|sort_reps
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|temp_pool
decl_stmt|;
specifier|const
name|path_order_t
modifier|*
modifier|*
name|temp
decl_stmt|,
modifier|*
modifier|*
name|path_order
decl_stmt|;
name|int
name|i
decl_stmt|,
name|count
decl_stmt|,
name|dir_count
decl_stmt|;
comment|/* We will later assume that there is at least one node / path.    */
if|if
condition|(
name|context
operator|->
name|path_order
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
name|assert
argument_list|(
name|context
operator|->
name|references
operator|->
name|nelts
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Sort containers by path and IDs, respectively.    */
name|svn_sort__array
argument_list|(
name|context
operator|->
name|path_order
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_path_order
argument_list|)
expr_stmt|;
name|svn_sort__array
argument_list|(
name|context
operator|->
name|references
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_references
argument_list|)
expr_stmt|;
comment|/* Directories are already in front; sort directories section and files    * section separately but use the same heuristics (see sub-function).    */
name|temp_pool
operator|=
name|svn_pool_create
argument_list|(
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
name|count
operator|=
name|context
operator|->
name|path_order
operator|->
name|nelts
expr_stmt|;
name|temp
operator|=
name|apr_pcalloc
argument_list|(
name|temp_pool
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|temp
argument_list|)
argument_list|)
expr_stmt|;
name|path_order
operator|=
operator|(
name|void
operator|*
operator|)
name|context
operator|->
name|path_order
operator|->
name|elts
expr_stmt|;
comment|/* Find the boundary between DIR and FILE section. */
name|dir_count
operator|=
name|svn_sort__bsearch_lower_bound
argument_list|(
name|context
operator|->
name|path_order
argument_list|,
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_is_dir
argument_list|)
expr_stmt|;
comment|/* Sort those sub-sections separately. */
name|sort_reps_range
argument_list|(
name|context
argument_list|,
name|path_order
argument_list|,
name|temp
argument_list|,
literal|0
argument_list|,
name|dir_count
argument_list|)
expr_stmt|;
name|sort_reps_range
argument_list|(
name|context
argument_list|,
name|path_order
argument_list|,
name|temp
argument_list|,
name|dir_count
argument_list|,
name|count
argument_list|)
expr_stmt|;
comment|/* We now know the final ordering. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|path_order
index|[
name|i
index|]
operator|=
name|temp
index|[
name|i
index|]
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|temp_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t. Place LHS before RHS, if the latter is older.  */
end_comment

begin_function
specifier|static
name|int
name|compare_p2l_info
parameter_list|(
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
specifier|const
modifier|*
name|lhs
parameter_list|,
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
specifier|const
modifier|*
name|rhs
parameter_list|)
block|{
name|assert
argument_list|(
operator|*
name|lhs
operator|!=
operator|*
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lhs
operator|)
operator|->
name|item
operator|.
name|revision
operator|==
operator|(
operator|*
name|rhs
operator|)
operator|->
name|item
operator|.
name|revision
condition|)
return|return
operator|(
operator|*
name|lhs
operator|)
operator|->
name|item
operator|.
name|number
operator|>
operator|(
operator|*
name|rhs
operator|)
operator|->
name|item
operator|.
name|number
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
operator|(
operator|*
name|lhs
operator|)
operator|->
name|item
operator|.
name|revision
operator|>
operator|(
operator|*
name|rhs
operator|)
operator|->
name|item
operator|.
name|revision
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Sort svn_fs_fs__p2l_entry_t * array ENTRIES by age.  Place the latest  * items first.  */
end_comment

begin_function
specifier|static
name|void
name|sort_items
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|)
block|{
name|svn_sort__array
argument_list|(
name|entries
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_p2l_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the remaining unused bytes in the current block in CONTEXT's  * pack file.  */
end_comment

begin_function
specifier|static
name|apr_ssize_t
name|get_block_left
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|ffd
operator|->
name|block_size
operator|-
operator|(
name|context
operator|->
name|pack_offset
operator|%
name|ffd
operator|->
name|block_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* To prevent items from overlapping a block boundary, we will usually  * put them into the next block and top up the old one with NUL bytes.  * Pad CONTEXT's pack file to the end of the current block, if TO_ADD does  * not fit into the current block and the padding is short enough.  * Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_pad_block
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_off_t
name|to_add
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* This is the maximum number of bytes "wasted" that way per block.    * Larger items will cross the block boundaries. */
specifier|const
name|apr_off_t
name|max_padding
init|=
name|MAX
argument_list|(
name|ffd
operator|->
name|block_size
operator|/
literal|50
argument_list|,
literal|512
argument_list|)
decl_stmt|;
comment|/* Is wasted space small enough to align the current item to the next    * block? */
name|apr_off_t
name|padding
init|=
name|get_block_left
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|padding
operator|<
name|to_add
operator|&&
name|padding
operator|<
name|max_padding
condition|)
block|{
comment|/* Yes. To up with NUL bytes and don't forget to create        * an P2L index entry marking this section as unused. */
name|svn_fs_fs__p2l_entry_t
name|null_entry
decl_stmt|;
name|null_entry
operator|.
name|offset
operator|=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|null_entry
operator|.
name|size
operator|=
name|padding
expr_stmt|;
name|null_entry
operator|.
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_UNUSED
expr_stmt|;
name|null_entry
operator|.
name|item
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|null_entry
operator|.
name|item
operator|.
name|number
operator|=
name|SVN_FS_FS__ITEM_INDEX_UNUSED
expr_stmt|;
name|null_entry
operator|.
name|fnv1_checksum
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_null_bytes
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|padding
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
operator|&
name|null_entry
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|+=
name|padding
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of ITEM, if not empty, from TEMP_FILE and write it  * to CONTEXT->PACK_FILE.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_item
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|item
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|safety_margin
decl_stmt|;
comment|/* skip empty entries */
if|if
condition|(
name|item
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_UNUSED
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the next item does not fit into the current block, auto-pad it.       Take special care of textual noderevs since their parsers may       prefetch up to 80 bytes and we don't want them to cross block       boundaries. */
name|safety_margin
operator|=
name|item
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_NODEREV
condition|?
name|SVN__LINE_CHUNK_SIZE
else|:
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_pad_block
argument_list|(
name|context
argument_list|,
name|item
operator|->
name|size
operator|+
name|safety_margin
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* select the item in the source file and copy it into the target     * pack file */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|temp_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|item
operator|->
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|pack_file
argument_list|,
name|temp_file
argument_list|,
name|item
operator|->
name|size
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write index entry and update current position */
name|item
operator|->
name|offset
operator|=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|+=
name|item
operator|->
name|size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|item
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of the non-empty items in ITEMS from TEMP_FILE and  * write them to CONTEXT->PACK_FILE.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_items
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_array_header_t
modifier|*
name|items
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* copy all items in strict order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|items
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_item
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|items
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy (append) the items identified by svn_fs_fs__p2l_entry_t * elements  * in ENTRIES strictly in order from TEMP_FILE into CONTEXT->PACK_FILE.  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_reps_from_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|path_order
init|=
name|context
operator|->
name|path_order
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* copy items in path order. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_order
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|path_order_t
modifier|*
name|current_path
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
modifier|*
name|node_part
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
modifier|*
name|rep_part
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|current_path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|path_order
argument_list|,
name|i
argument_list|,
name|path_order_t
operator|*
argument_list|)
expr_stmt|;
name|node_part
operator|=
name|get_item
argument_list|(
name|context
argument_list|,
operator|&
name|current_path
operator|->
name|noderev_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rep_part
operator|=
name|get_item
argument_list|(
name|context
argument_list|,
operator|&
name|current_path
operator|->
name|rep_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_part
condition|)
name|SVN_ERR
argument_list|(
name|store_item
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|node_part
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_part
condition|)
name|SVN_ERR
argument_list|(
name|store_item
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|rep_part
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t. Place LHS before RHS, if the latter belongs to  * a newer revision.  */
end_comment

begin_function
specifier|static
name|int
name|compare_p2l_info_rev
parameter_list|(
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
specifier|const
modifier|*
name|lhs_p
parameter_list|,
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
specifier|const
modifier|*
name|rhs_p
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|lhs
init|=
operator|*
name|lhs_p
decl_stmt|;
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|rhs
init|=
operator|*
name|rhs_p
decl_stmt|;
if|if
condition|(
name|lhs
operator|->
name|item
operator|.
name|revision
operator|==
name|rhs
operator|->
name|item
operator|.
name|revision
condition|)
return|return
literal|0
return|;
return|return
name|lhs
operator|->
name|item
operator|.
name|revision
operator|<
name|rhs
operator|->
name|item
operator|.
name|revision
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Write the log-to-phys proto index file for CONTEXT and use POOL for  * temporary allocations.  All items in all buckets must have been placed  * by now.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_l2p_index
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|prev_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|int
name|i
decl_stmt|,
name|dest
decl_stmt|;
comment|/* eliminate empty entries from CONTEXT->REPS */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|dest
operator|=
literal|0
init|;
name|i
operator|<
name|context
operator|->
name|reps
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
condition|)
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|dest
operator|++
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
block|}
name|context
operator|->
name|reps
operator|->
name|nelts
operator|=
name|dest
expr_stmt|;
comment|/* we need to write the l2p index revision by revision */
name|svn_sort__array
argument_list|(
name|context
operator|->
name|reps
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_p2l_info_rev
argument_list|)
expr_stmt|;
comment|/* write index entries */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|context
operator|->
name|reps
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|p2l_entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|p2l_entry
operator|==
name|NULL
condition|)
continue|continue;
comment|/* next revision? */
if|if
condition|(
name|prev_rev
operator|!=
name|p2l_entry
operator|->
name|item
operator|.
name|revision
condition|)
block|{
name|prev_rev
operator|=
name|p2l_entry
operator|->
name|item
operator|.
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_add_revision
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* add entry */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|p2l_entry
operator|->
name|offset
argument_list|,
name|p2l_entry
operator|->
name|item
operator|.
name|number
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep memory usage in check */
if|if
condition|(
name|i
operator|%
literal|256
operator|==
literal|0
condition|)
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Pack the current revision range of CONTEXT, i.e. this covers phases 2  * to 4.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_range
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|revpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool2
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Phase 2: Copy items into various buckets and build tracking info */
name|svn_revnum_t
name|revision
decl_stmt|;
for|for
control|(
name|revision
operator|=
name|context
operator|->
name|start_rev
init|;
name|revision
operator|<
name|context
operator|->
name|end_rev
condition|;
operator|++
name|revision
control|)
block|{
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
comment|/* Get the rev file dimensions (mainly index locations). */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|revpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__auto_read_footer
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store the indirect array index */
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|rev_offsets
argument_list|,
name|int
argument_list|)
operator|=
name|context
operator|->
name|reps
operator|->
name|nelts
expr_stmt|;
comment|/* read the phys-to-log index file until we covered the whole rev file.        * That index contains enough info to build both target indexes from it. */
while|while
condition|(
name|offset
operator|<
name|rev_file
operator|->
name|l2p_offset
condition|)
block|{
comment|/* read one cluster */
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* skip first entry if that was duplicated due crossing a                  cluster boundary */
if|if
condition|(
name|offset
operator|>
name|entry
operator|->
name|offset
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
comment|/* process entry while inside the rev file */
name|offset
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|rev_file
operator|->
name|l2p_offset
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_CHANGES
condition|)
name|SVN_ERR
argument_list|(
name|copy_item_to_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|changes
argument_list|,
name|context
operator|->
name|changes_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_FILE_PROPS
condition|)
name|SVN_ERR
argument_list|(
name|copy_item_to_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|file_props
argument_list|,
name|context
operator|->
name|file_props_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_DIR_PROPS
condition|)
name|SVN_ERR
argument_list|(
name|copy_item_to_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|dir_props
argument_list|,
name|context
operator|->
name|dir_props_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_FILE_REP
operator|||
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_DIR_REP
condition|)
name|SVN_ERR
argument_list|(
name|copy_rep_to_temp
argument_list|(
name|context
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_NODEREV
condition|)
name|SVN_ERR
argument_list|(
name|copy_node_to_temp
argument_list|(
name|context
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool2
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_UNUSED
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|context
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|context
operator|->
name|cancel_func
argument_list|(
name|context
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* phase 3: placement.    * Use "newest first" placement for simple items. */
name|sort_items
argument_list|(
name|context
operator|->
name|changes
argument_list|)
expr_stmt|;
name|sort_items
argument_list|(
name|context
operator|->
name|file_props
argument_list|)
expr_stmt|;
name|sort_items
argument_list|(
name|context
operator|->
name|dir_props
argument_list|)
expr_stmt|;
comment|/* follow dependencies recursively for noderevs and data representations */
name|sort_reps
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* phase 4: copy bucket data to pack file.  Write P2L index. */
name|SVN_ERR
argument_list|(
name|store_items
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|changes_file
argument_list|,
name|context
operator|->
name|changes
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_items
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|file_props_file
argument_list|,
name|context
operator|->
name|file_props
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|store_items
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|dir_props_file
argument_list|,
name|context
operator|->
name|dir_props
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_reps_from_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
comment|/* write L2P index as well (now that we know all target offsets) */
name|SVN_ERR
argument_list|(
name|write_l2p_index
argument_list|(
name|context
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Append CONTEXT->START_REV to the context's pack file with no re-ordering.  * This function will only be used for very large revisions (>>100k changes).  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|append_revision
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
comment|/* Get the size of the file. */
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_dirent_join
argument_list|(
name|context
operator|->
name|shard_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|context
operator|->
name|start_rev
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy all the bits from the rev file to the end of the pack file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|context
operator|->
name|start_rev
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|pack_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|finfo
operator|.
name|size
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark the start of a new revision */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_add_revision
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read the phys-to-log index file until we covered the whole rev file.    * That index contains enough info to build both target indexes from it. */
while|while
condition|(
name|offset
operator|<
name|finfo
operator|.
name|size
condition|)
block|{
comment|/* read one cluster */
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|rev_file
argument_list|,
name|context
operator|->
name|start_rev
argument_list|,
name|offset
argument_list|,
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* skip first entry if that was duplicated due crossing a              cluster boundary */
if|if
condition|(
name|offset
operator|>
name|entry
operator|->
name|offset
condition|)
continue|continue;
comment|/* process entry while inside the rev file */
name|offset
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|finfo
operator|.
name|size
condition|)
block|{
name|entry
operator|->
name|offset
operator|+=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|offset
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|entry
operator|->
name|item
operator|.
name|number
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|+=
name|finfo
operator|.
name|size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Logical addressing mode packing logic.  *  * Pack the revision shard starting at SHARD_REV in filesystem FS from  * SHARD_DIR into the PACK_FILE_DIR, using POOL for allocations.  Limit  * the extra memory consumption to MAX_MEM bytes.  CANCEL_FUNC and  * CANCEL_BATON are what you think they are.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_log_addressed
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_dir
parameter_list|,
name|svn_revnum_t
name|shard_rev
parameter_list|,
name|apr_size_t
name|max_mem
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
enum|enum
block|{
comment|/* estimated amount of memory used to represent one item in memory        * during rev file packing */
name|PER_ITEM_MEM
init|=
name|APR_ALIGN_DEFAULT
argument_list|(
sizeof|sizeof
argument_list|(
name|path_order_t
argument_list|)
argument_list|)
operator|+
name|APR_ALIGN_DEFAULT
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|+
name|APR_ALIGN_DEFAULT
argument_list|(
sizeof|sizeof
argument_list|(
name|reference_t
argument_list|)
argument_list|)
operator|+
name|APR_ALIGN_DEFAULT
argument_list|(
sizeof|sizeof
argument_list|(
name|svn_fs_fs__p2l_entry_t
argument_list|)
argument_list|)
operator|+
literal|6
operator|*
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
name|int
name|max_items
decl_stmt|;
name|apr_array_header_t
modifier|*
name|max_ids
decl_stmt|;
name|pack_context_t
name|context
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_size_t
name|item_count
init|=
literal|0
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Prevent integer overflow.  We use apr arrays to process the items so    * the maximum number of items is INT_MAX. */
block|{
name|apr_size_t
name|temp
init|=
name|max_mem
operator|/
name|PER_ITEM_MEM
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|temp
operator|<=
name|INT_MAX
argument_list|)
expr_stmt|;
name|max_items
operator|=
operator|(
name|int
operator|)
name|temp
expr_stmt|;
block|}
comment|/* set up a pack context */
name|SVN_ERR
argument_list|(
name|initialize_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|fs
argument_list|,
name|pack_file_dir
argument_list|,
name|shard_dir
argument_list|,
name|shard_rev
argument_list|,
name|max_items
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* phase 1: determine the size of the revisions to pack */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_get_max_ids
argument_list|(
operator|&
name|max_ids
argument_list|,
name|fs
argument_list|,
name|shard_rev
argument_list|,
name|context
operator|.
name|shard_end_rev
operator|-
name|shard_rev
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pack revisions in ranges that don't exceed MAX_MEM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ids
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|APR_ARRAY_IDX
argument_list|(
name|max_ids
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
operator|+
name|item_count
operator|<=
name|max_items
condition|)
block|{
name|context
operator|.
name|end_rev
operator|++
expr_stmt|;
block|}
else|else
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* some unpacked revisions before this one? */
if|if
condition|(
name|context
operator|.
name|start_rev
operator|<
name|context
operator|.
name|end_rev
condition|)
block|{
comment|/* pack them intelligently (might be just 1 rev but still ...) */
name|SVN_ERR
argument_list|(
name|pack_range
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reset_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|item_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* next revision range is to start with the current revision */
name|context
operator|.
name|start_rev
operator|=
name|i
operator|+
name|context
operator|.
name|shard_rev
expr_stmt|;
name|context
operator|.
name|end_rev
operator|=
name|context
operator|.
name|start_rev
operator|+
literal|1
expr_stmt|;
comment|/* if this is a very large revision, we must place it as is */
if|if
condition|(
name|APR_ARRAY_IDX
argument_list|(
name|max_ids
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
operator|>
name|max_items
condition|)
block|{
name|SVN_ERR
argument_list|(
name|append_revision
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|start_rev
operator|++
expr_stmt|;
block|}
else|else
name|item_count
operator|+=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|max_ids
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
expr_stmt|;
block|}
comment|/* non-empty revision range at the end? */
if|if
condition|(
name|context
operator|.
name|start_rev
operator|<
name|context
operator|.
name|end_rev
condition|)
name|SVN_ERR
argument_list|(
name|pack_range
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* last phase: finalize indexes and clean up */
name|SVN_ERR
argument_list|(
name|reset_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|close_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given REV in FS, set *REV_OFFSET to REV's offset in the packed file.    Use POOL for temporary allocations. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_packed_offset
parameter_list|(
name|apr_off_t
modifier|*
name|rev_offset
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|svn_revnum_t
name|shard
decl_stmt|;
name|apr_int64_t
name|shard_pos
decl_stmt|;
name|apr_array_header_t
modifier|*
name|manifest
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|shard
operator|=
name|rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* position of the shard within the manifest */
name|shard_pos
operator|=
name|rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* fetch exactly that element into *rev_offset, if the manifest is found      in the cache */
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|rev_offset
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|packed_offset_cache
argument_list|,
operator|&
name|shard
argument_list|,
name|svn_fs_fs__get_sharded_offset
argument_list|,
operator|&
name|shard_pos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Open the manifest file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|manifest_stream
argument_list|,
name|svn_fs_fs__path_rev_packed
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* While we're here, let's just read the entire manifest file into an array,      so we can cache the entire thing. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|manifest
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_number_from_stream
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|eof
argument_list|,
name|manifest_stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
break|break;
name|APR_ARRAY_PUSH
argument_list|(
name|manifest
argument_list|,
name|apr_off_t
argument_list|)
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|rev_offset
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|manifest
argument_list|,
name|rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|apr_off_t
argument_list|)
expr_stmt|;
comment|/* Close up shop and cache the array. */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|packed_offset_cache
argument_list|,
operator|&
name|shard
argument_list|,
name|manifest
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Packing logic for physical addresssing mode:  * Simply concatenate all revision contents.  *  * Pack the revision shard starting at SHARD_REV containing exactly  * MAX_FILES_PER_DIR revisions from SHARD_PATH into the PACK_FILE_DIR,  * using POOL for allocations.  CANCEL_FUNC and CANCEL_BATON are what you  * think they are.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_phys_addressed
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pack_file_path
decl_stmt|,
modifier|*
name|manifest_file_path
decl_stmt|;
name|apr_file_t
modifier|*
name|pack_file
decl_stmt|;
name|apr_file_t
modifier|*
name|manifest_file
decl_stmt|;
name|svn_stream_t
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_revnum_t
name|end_rev
decl_stmt|,
name|rev
decl_stmt|;
name|apr_off_t
name|next_offset
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Some useful paths. */
name|pack_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_PACKED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Create the new directory and pack file.    * Use unbuffered apr_file_t since we're going to write using 16kb    * chunks. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|pack_file
argument_list|,
name|pack_file_path
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_EXCL
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the manifest file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|manifest_file
argument_list|,
name|manifest_file_path
argument_list|,
name|APR_WRITE
operator||
name|APR_BUFFERED
operator||
name|APR_CREATE
operator||
name|APR_EXCL
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|manifest_stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|manifest_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|end_rev
operator|=
name|start_rev
operator|+
name|max_files_per_dir
operator|-
literal|1
expr_stmt|;
name|next_offset
operator|=
literal|0
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Iterate over the revisions in this shard, squashing them together. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|svn_stream_t
modifier|*
name|rev_stream
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the size of the file. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* build manifest */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|manifest_stream
argument_list|,
name|iterpool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
literal|"\n"
argument_list|,
name|next_offset
argument_list|)
argument_list|)
expr_stmt|;
name|next_offset
operator|+=
name|finfo
operator|.
name|size
expr_stmt|;
comment|/* Copy all the bits from the rev file to the end of the pack file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|rev_stream
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|rev_stream
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|pack_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Close stream over APR file. */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure that pack file is written to disk. */
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|manifest_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|manifest_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* disallow write access to the manifest file */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|manifest_file_path
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ensure that pack file is written to disk. */
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|pack_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|pack_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In filesystem FS, pack the revision SHARD containing exactly  * MAX_FILES_PER_DIR revisions from SHARD_PATH into the PACK_FILE_DIR,  * using POOL for allocations.  Try to limit the amount of temporary  * memory needed to MAX_MEM bytes.  CANCEL_FUNC and CANCEL_BATON are what  * you think they are.  *  * If for some reason we detect a partial packing already performed, we  * remove the pack file and start again.  *  * The actual packing will be done in a format-specific sub-function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_rev_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_size_t
name|max_mem
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pack_file_path
decl_stmt|;
name|svn_revnum_t
name|shard_rev
init|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|shard
operator|*
name|max_files_per_dir
argument_list|)
decl_stmt|;
comment|/* Some useful paths. */
name|pack_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_PACKED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Remove any existing pack file for this shard, since it is incomplete. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|pack_file_dir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory and pack file. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|pack_file_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Index information files */
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|pack_log_addressed
argument_list|(
name|fs
argument_list|,
name|pack_file_dir
argument_list|,
name|shard_path
argument_list|,
name|shard_rev
argument_list|,
name|max_mem
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|pack_phys_addressed
argument_list|(
name|pack_file_dir
argument_list|,
name|shard_path
argument_list|,
name|shard_rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|shard_path
argument_list|,
name|pack_file_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|pack_file_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton struct used by pack_body(), pack_shard() and synced_pack_shard().    These calls are nested and for every level additional fields will be    available. */
end_comment

begin_struct
struct|struct
name|pack_baton
block|{
comment|/* Valid when entering pack_body(). */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_pack_notify_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* Additional entries valid when entering pack_shard(). */
specifier|const
name|char
modifier|*
name|revs_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|revsprops_dir
decl_stmt|;
name|apr_int64_t
name|shard
decl_stmt|;
comment|/* Additional entries valid when entering synced_pack_shard(). */
specifier|const
name|char
modifier|*
name|rev_shard_path
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Part of the pack process that requires global (write) synchronization.  * We pack the revision properties of the shard described by BATON and  * In the file system at FS_PATH, pack the SHARD in REVS_DIR and replace  * the non-packed revprop& rev shard folder(s) with the packed ones.  * The packed rev folder has been created prior to calling this function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|synced_pack_shard
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pack_baton
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|pb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|,
modifier|*
name|revprops_pack_file_dir
decl_stmt|;
comment|/* if enabled, pack the revprops in an equivalent way */
if|if
condition|(
name|pb
operator|->
name|revsprops_dir
condition|)
block|{
name|revprops_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|pool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|pb->shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|pb
operator|->
name|shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__pack_revprops_shard
argument_list|(
name|revprops_pack_file_dir
argument_list|,
name|revprops_shard_path
argument_list|,
name|pb
operator|->
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|0.9
operator|*
name|ffd
operator|->
name|revprop_pack_size
argument_list|)
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN__COMPRESSION_ZLIB_DEFAULT
else|:
name|SVN__COMPRESSION_NONE
argument_list|,
name|pb
operator|->
name|cancel_func
argument_list|,
name|pb
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update the min-unpacked-rev file to reflect our newly packed shard. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_min_unpacked_rev
argument_list|(
name|pb
operator|->
name|fs
argument_list|,
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|pb
operator|->
name|shard
operator|+
literal|1
operator|)
operator|*
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|min_unpacked_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|pb
operator|->
name|shard
operator|+
literal|1
operator|)
operator|*
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
expr_stmt|;
comment|/* Finally, remove the existing shard directories.    * For revprops, clean up older obsolete shards as well as they might    * have been left over from an interrupted FS upgrade. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|pb
operator|->
name|rev_shard_path
argument_list|,
name|TRUE
argument_list|,
name|pb
operator|->
name|cancel_func
argument_list|,
name|pb
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|revsprops_dir
condition|)
block|{
name|svn_node_kind_t
name|kind
init|=
name|svn_node_dir
decl_stmt|;
name|apr_int64_t
name|to_cleanup
init|=
name|pb
operator|->
name|shard
decl_stmt|;
do|do
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__delete_revprops_shard
argument_list|(
name|revprops_shard_path
argument_list|,
name|to_cleanup
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|pb
operator|->
name|cancel_func
argument_list|,
name|pb
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the previous shard exists, clean it up as well.              Don't try to clean up shard 0 as it we can't tell quickly              whether it actually needs cleaning up. */
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
operator|--
name|to_cleanup
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|revprops_shard_path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|kind
operator|==
name|svn_node_dir
operator|&&
name|to_cleanup
operator|>
literal|0
condition|)
do|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Pack the shard described by BATON.  *  * If for some reason we detect a partial packing already performed,  * we remove the pack file and start again.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_shard
parameter_list|(
name|struct
name|pack_baton
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|baton
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_pack_file_dir
decl_stmt|;
comment|/* Notify caller we're starting to pack this shard. */
if|if
condition|(
name|baton
operator|->
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|baton
operator|->
name|notify_func
argument_list|(
name|baton
operator|->
name|notify_baton
argument_list|,
name|baton
operator|->
name|shard
argument_list|,
name|svn_fs_pack_notify_start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some useful paths. */
name|rev_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|baton
operator|->
name|revs_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|pool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|baton->shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|rev_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|baton
operator|->
name|revs_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|baton
operator|->
name|shard
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* pack the revision content */
name|SVN_ERR
argument_list|(
name|pack_rev_shard
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|rev_pack_file_dir
argument_list|,
name|baton
operator|->
name|rev_shard_path
argument_list|,
name|baton
operator|->
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|DEFAULT_MAX_MEM
argument_list|,
name|baton
operator|->
name|cancel_func
argument_list|,
name|baton
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For newer repo formats, we only acquired the pack lock so far.      Before modifying the repo state by switching over to the packed      data, we need to acquire the global (write) lock. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACK_LOCK_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__with_write_lock
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|synced_pack_shard
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|synced_pack_shard
argument_list|(
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notify caller we're starting to pack this shard. */
if|if
condition|(
name|baton
operator|->
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|baton
operator|->
name|notify_func
argument_list|(
name|baton
operator|->
name|notify_baton
argument_list|,
name|baton
operator|->
name|shard
argument_list|,
name|svn_fs_pack_notify_end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The work-horse for svn_fs_fs__pack, called with the FS write lock.    This implements the svn_fs_fs__with_write_lock() 'body' callback    type.  BATON is a 'struct pack_baton *'.     WARNING: if you add a call to this function, please note:      The code currently assumes that any piece of code running with      the write-lock set can rely on the ffd->min_unpacked_rev and      ffd->min_unpacked_revprop caches to be up-to-date (and, by      extension, on not having to use a retry when calling      svn_fs_fs__path_rev_absolute() and friends).  If you add a call      to this function, consider whether you have to call      svn_fs_fs__update_min_unpacked_rev().      See this thread: http://thread.gmane.org/1291206765.3782.3309.camel@edith  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pack_baton
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|pb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_int64_t
name|completed_shards
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* If the repository isn't a new enough format, we don't support packing.      Return a friendly error to that effect. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"FSFS format (%d) too old to pack; please upgrade the filesystem."
argument_list|)
argument_list|,
name|ffd
operator|->
name|format
argument_list|)
return|;
comment|/* If we aren't using sharding, we can't do any packing, so quit. */
if|if
condition|(
operator|!
name|ffd
operator|->
name|max_files_per_dir
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_min_unpacked_rev
argument_list|(
operator|&
name|ffd
operator|->
name|min_unpacked_rev
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|completed_shards
operator|=
operator|(
name|youngest
operator|+
literal|1
operator|)
operator|/
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* See if we've already completed all possible shards thus far. */
if|if
condition|(
name|ffd
operator|->
name|min_unpacked_rev
operator|==
operator|(
name|completed_shards
operator|*
name|ffd
operator|->
name|max_files_per_dir
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|pb
operator|->
name|revs_dir
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
name|pb
operator|->
name|revsprops_dir
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|pb
operator|->
name|shard
operator|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
init|;
name|pb
operator|->
name|shard
operator|<
name|completed_shards
condition|;
name|pb
operator|->
name|shard
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|pb
operator|->
name|cancel_func
argument_list|(
name|pb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|pack_shard
argument_list|(
name|pb
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__pack
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_pack_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|pack_baton
name|pb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|pb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|pb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|pb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|pb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|pb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACK_LOCK_FORMAT
condition|)
block|{
comment|/* Newer repositories provide a pack operation specific lock.          Acquire it to prevent concurrent packs.           Since the file lock's lifetime is bound to a pool, we create a          separate subpool here to release the lock immediately after the          operation finished.        */
name|err
operator|=
name|svn_fs_fs__with_pack_lock
argument_list|(
name|fs
argument_list|,
name|pack_body
argument_list|,
operator|&
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Use the global write lock for older repos. */
name|err
operator|=
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|pack_body
argument_list|,
operator|&
name|pb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

