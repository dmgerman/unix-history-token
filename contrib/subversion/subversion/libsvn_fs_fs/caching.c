begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* caching.c : in-memory caching  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_cache_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_debug.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_comment
comment|/* Take the ORIGINAL string and replace all occurrences of ":" without  * limiting the key space.  Allocate the result in POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|normalize_key_part
parameter_list|(
specifier|const
name|char
modifier|*
name|original
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|original
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|normalized
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|len
argument_list|,
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
operator|++
name|i
control|)
block|{
name|char
name|c
init|=
name|original
index|[
name|i
index|]
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|':'
case|:
name|svn_stringbuf_appendbytes
argument_list|(
name|normalized
argument_list|,
literal|"%_"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
name|svn_stringbuf_appendbytes
argument_list|(
name|normalized
argument_list|,
literal|"%%"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
break|break;
default|default :
name|svn_stringbuf_appendbyte
argument_list|(
name|normalized
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|normalized
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Return a memcache in *MEMCACHE_P for FS if it's configured to use    memcached, or NULL otherwise.  Also, sets *FAIL_STOP to a boolean    indicating whether cache errors should be returned to the caller or    just passed to the FS warning handler.     *CACHE_TXDELTAS, *CACHE_FULLTEXTS and *CACHE_REVPROPS flags will be set    according to FS->CONFIG.  *CACHE_NAMESPACE receives the cache prefix    to use.     Use FS->pool for allocating the memcache and CACHE_NAMESPACE, and POOL    for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_config
parameter_list|(
name|svn_memcache_t
modifier|*
modifier|*
name|memcache_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|fail_stop
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cache_namespace
parameter_list|,
name|svn_boolean_t
modifier|*
name|cache_txdeltas
parameter_list|,
name|svn_boolean_t
modifier|*
name|cache_fulltexts
parameter_list|,
name|svn_boolean_t
modifier|*
name|cache_revprops
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__make_memcache_from_config
argument_list|(
name|memcache_p
argument_list|,
name|ffd
operator|->
name|config
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No cache namespace by default.  I.e. all FS instances share the    * cached data.  If you specify different namespaces, the data will    * share / compete for the same cache memory but keys will not match    * across namespaces and, thus, cached data will not be shared between    * namespaces.    *    * Since the namespace will be concatenated with other elements to form    * the complete key prefix, we must make sure that the resulting string    * is unique and cannot be created by any other combination of elements.    */
operator|*
name|cache_namespace
operator|=
name|normalize_key_part
argument_list|(
name|svn_hash__get_cstring
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_NS
argument_list|,
literal|""
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* don't cache text deltas by default.    * Once we reconstructed the fulltexts from the deltas,    * these deltas are rarely re-used. Therefore, only tools    * like svnadmin will activate this to speed up operations    * dump and verify.    */
operator|*
name|cache_txdeltas
operator|=
name|svn_hash__get_bool
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_DELTAS
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* by default, cache fulltexts.    * Most SVN tools care about reconstructed file content.    * Thus, this is a reasonable default.    * SVN admin tools may set that to FALSE because fulltexts    * won't be re-used rendering the cache less effective    * by squeezing wanted data out.    */
operator|*
name|cache_fulltexts
operator|=
name|svn_hash__get_bool
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* don't cache revprops by default.    * Revprop caching significantly speeds up operations like    * svn ls -v. However, it requires synchronization that may    * not be available or efficient in the current server setup.    *    * If the caller chose option "2", enable revprop caching if    * the required API support is there to make it efficient.    */
if|if
condition|(
name|strcmp
argument_list|(
name|svn_hash__get_cstring
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_REVPROPS
argument_list|,
literal|""
argument_list|)
argument_list|,
literal|"2"
argument_list|)
condition|)
operator|*
name|cache_revprops
operator|=
name|svn_hash__get_bool
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_REVPROPS
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
operator|*
name|cache_revprops
operator|=
name|svn_named_atomic__is_efficient
argument_list|()
expr_stmt|;
return|return
name|svn_config_get_bool
argument_list|(
name|ffd
operator|->
name|config
argument_list|,
name|fail_stop
argument_list|,
name|CONFIG_SECTION_CACHES
argument_list|,
name|CONFIG_OPTION_FAIL_STOP
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_cache__error_handler_t  * This variant clears the error after logging it.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|warn_and_continue_on_cache_errors
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|baton
decl_stmt|;
call|(
name|fs
operator|->
name|warning
call|)
argument_list|(
name|fs
operator|->
name|warning_baton
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_cache__error_handler_t  * This variant logs the error and passes it on to the callers.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|warn_and_fail_on_cache_errors
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|baton
decl_stmt|;
call|(
name|fs
operator|->
name|warning
call|)
argument_list|(
name|fs
operator|->
name|warning_baton
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_DEBUG_CACHE_DUMP_STATS
end_ifdef

begin_comment
comment|/* Baton to be used for the dump_cache_statistics() pool cleanup function, */
end_comment

begin_struct
struct|struct
name|dump_cache_baton_t
block|{
comment|/* the pool about to be cleaned up. Will be used for temp. allocations. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* the cache to dump the statistics for */
name|svn_cache__t
modifier|*
name|cache
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* APR pool cleanup handler that will printf the statistics of the    cache referenced by the baton in BATON_VOID. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|dump_cache_statistics
parameter_list|(
name|void
modifier|*
name|baton_void
parameter_list|)
block|{
name|struct
name|dump_cache_baton_t
modifier|*
name|baton
init|=
name|baton_void
decl_stmt|;
name|apr_status_t
name|result
init|=
name|APR_SUCCESS
decl_stmt|;
name|svn_cache__info_t
name|info
decl_stmt|;
name|svn_string_t
modifier|*
name|text_stats
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lines
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_cache__get_info
argument_list|(
name|baton
operator|->
name|cache
argument_list|,
operator|&
name|info
argument_list|,
name|TRUE
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|text_stats
operator|=
name|svn_cache__format_info
argument_list|(
operator|&
name|info
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
name|lines
operator|=
name|svn_cstring_split
argument_list|(
name|text_stats
operator|->
name|data
argument_list|,
literal|"\n"
argument_list|,
name|FALSE
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|line
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lines
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|SVN_DEBUG
name|SVN_DBG
argument_list|(
operator|(
literal|"%s\n"
operator|,
name|line
operator|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
comment|/* process error returns */
if|if
condition|(
name|err
condition|)
block|{
name|result
operator|=
name|err
operator|->
name|apr_err
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_DEBUG_CACHE_DUMP_STATS */
end_comment

begin_comment
comment|/* This function sets / registers the required callbacks for a given  * not transaction-specific CACHE object in FS, if CACHE is not NULL.  *  * All these svn_cache__t instances shall be handled uniformly. Unless  * ERROR_HANDLER is NULL, register it for the given CACHE in FS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_callbacks
parameter_list|(
name|svn_cache__t
modifier|*
name|cache
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_cache__error_handler_t
name|error_handler
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|cache
operator|!=
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|SVN_DEBUG_CACHE_DUMP_STATS
comment|/* schedule printing the access statistics upon pool cleanup,        * i.e. end of FSFS session.        */
name|struct
name|dump_cache_baton_t
modifier|*
name|baton
decl_stmt|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|baton
operator|->
name|cache
operator|=
name|cache
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|baton
argument_list|,
name|dump_cache_statistics
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|error_handler
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set_error_handler
argument_list|(
name|cache
argument_list|,
name|error_handler
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Sets *CACHE_P to cache instance based on provided options.  * Creates memcache if MEMCACHE is not NULL. Creates membuffer cache if  * MEMBUFFER is not NULL. Fallbacks to inprocess cache if MEMCACHE and  * MEMBUFFER are NULL and pages is non-zero.  Sets *CACHE_P to NULL  * otherwise.  *  * Unless NO_HANDLER is true, register an error handler that reports errors  * as warnings to the FS warning callback.  *  * Cache is allocated in POOL.  * */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_cache
parameter_list|(
name|svn_cache__t
modifier|*
modifier|*
name|cache_p
parameter_list|,
name|svn_memcache_t
modifier|*
name|memcache
parameter_list|,
name|svn_membuffer_t
modifier|*
name|membuffer
parameter_list|,
name|apr_int64_t
name|pages
parameter_list|,
name|apr_int64_t
name|items_per_page
parameter_list|,
name|svn_cache__serialize_func_t
name|serializer
parameter_list|,
name|svn_cache__deserialize_func_t
name|deserializer
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|no_handler
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cache__error_handler_t
name|error_handler
init|=
name|no_handler
condition|?
name|NULL
else|:
name|warn_and_fail_on_cache_errors
decl_stmt|;
if|if
condition|(
name|memcache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__create_memcache
argument_list|(
name|cache_p
argument_list|,
name|memcache
argument_list|,
name|serializer
argument_list|,
name|deserializer
argument_list|,
name|klen
argument_list|,
name|prefix
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|error_handler
operator|=
name|no_handler
condition|?
name|NULL
else|:
name|warn_and_continue_on_cache_errors
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|membuffer
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__create_membuffer_cache
argument_list|(
name|cache_p
argument_list|,
name|membuffer
argument_list|,
name|serializer
argument_list|,
name|deserializer
argument_list|,
name|klen
argument_list|,
name|prefix
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pages
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__create_inprocess
argument_list|(
name|cache_p
argument_list|,
name|serializer
argument_list|,
name|deserializer
argument_list|,
name|klen
argument_list|,
name|pages
argument_list|,
name|items_per_page
argument_list|,
name|FALSE
argument_list|,
name|prefix
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cache_p
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|init_callbacks
argument_list|(
operator|*
name|cache_p
argument_list|,
name|fs
argument_list|,
name|error_handler
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__initialize_caches
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|prefix
init|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"fsfs:"
argument_list|,
name|fs
operator|->
name|uuid
argument_list|,
literal|"/"
argument_list|,
name|normalize_key_part
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|":"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
name|svn_memcache_t
modifier|*
name|memcache
decl_stmt|;
name|svn_membuffer_t
modifier|*
name|membuffer
decl_stmt|;
name|svn_boolean_t
name|no_handler
decl_stmt|;
name|svn_boolean_t
name|cache_txdeltas
decl_stmt|;
name|svn_boolean_t
name|cache_fulltexts
decl_stmt|;
name|svn_boolean_t
name|cache_revprops
decl_stmt|;
specifier|const
name|char
modifier|*
name|cache_namespace
decl_stmt|;
comment|/* Evaluating the cache configuration. */
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
operator|&
name|memcache
argument_list|,
operator|&
name|no_handler
argument_list|,
operator|&
name|cache_namespace
argument_list|,
operator|&
name|cache_txdeltas
argument_list|,
operator|&
name|cache_fulltexts
argument_list|,
operator|&
name|cache_revprops
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"ns:"
argument_list|,
name|cache_namespace
argument_list|,
literal|":"
argument_list|,
name|prefix
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|membuffer
operator|=
name|svn_cache__get_global_membuffer_cache
argument_list|()
expr_stmt|;
comment|/* Make the cache for revision roots.  For the vast majority of    * commands, this is only going to contain a few entries (svnadmin    * dump/verify is an exception here), so to reduce overhead let's    * try to keep it to just one page.  I estimate each entry has about    * 72 bytes of overhead (svn_revnum_t key, svn_fs_id_t +    * id_private_t + 3 strings for value, and the cache_entry); the    * default pool size is 8192, so about a hundred should fit    * comfortably. */
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|rev_root_id_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|1
argument_list|,
literal|100
argument_list|,
name|svn_fs_fs__serialize_id
argument_list|,
name|svn_fs_fs__deserialize_id
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"RRI"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rough estimate: revision DAG nodes have size around 320 bytes, so    * let's put 16 on a page. */
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|rev_node_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|1024
argument_list|,
literal|16
argument_list|,
name|svn_fs_fs__dag_serialize
argument_list|,
name|svn_fs_fs__dag_deserialize
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"DAG"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 1st level DAG node cache */
name|ffd
operator|->
name|dag_node_cache
operator|=
name|svn_fs_fs__create_dag_cache
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Very rough estimate: 1K per directory. */
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|dir_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|1024
argument_list|,
literal|8
argument_list|,
name|svn_fs_fs__serialize_dir_entries
argument_list|,
name|svn_fs_fs__deserialize_dir_entries
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"DIR"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only 16 bytes per entry (a revision number + the corresponding offset).      Since we want ~8k pages, that means 512 entries per page. */
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|packed_offset_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|32
argument_list|,
literal|1
argument_list|,
name|svn_fs_fs__serialize_manifest
argument_list|,
name|svn_fs_fs__deserialize_manifest
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"PACK-MANIFEST"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize node revision cache, if caching has been enabled */
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|node_revision_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
name|svn_fs_fs__serialize_node_revision
argument_list|,
name|svn_fs_fs__deserialize_node_revision
argument_list|,
sizeof|sizeof
argument_list|(
name|pair_cache_key_t
argument_list|)
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"NODEREVS"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize node change list cache, if caching has been enabled */
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|changes_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
name|svn_fs_fs__serialize_changes
argument_list|,
name|svn_fs_fs__deserialize_changes
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"CHANGES"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if enabled, cache fulltext and other derived information */
if|if
condition|(
name|cache_fulltexts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|fulltext_cache
operator|)
argument_list|,
name|memcache
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
comment|/* Values are svn_stringbuf_t */
name|NULL
argument_list|,
name|NULL
argument_list|,
sizeof|sizeof
argument_list|(
name|pair_cache_key_t
argument_list|)
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"TEXT"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|properties_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
name|svn_fs_fs__serialize_properties
argument_list|,
name|svn_fs_fs__deserialize_properties
argument_list|,
sizeof|sizeof
argument_list|(
name|pair_cache_key_t
argument_list|)
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"PROP"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|mergeinfo_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
name|svn_fs_fs__serialize_mergeinfo
argument_list|,
name|svn_fs_fs__deserialize_mergeinfo
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"MERGEINFO"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|mergeinfo_existence_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
comment|/* Values are svn_stringbuf_t */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"HAS_MERGEINFO"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|fulltext_cache
operator|=
name|NULL
expr_stmt|;
name|ffd
operator|->
name|properties_cache
operator|=
name|NULL
expr_stmt|;
name|ffd
operator|->
name|mergeinfo_cache
operator|=
name|NULL
expr_stmt|;
name|ffd
operator|->
name|mergeinfo_existence_cache
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* initialize revprop cache, if full-text caching has been enabled */
if|if
condition|(
name|cache_revprops
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|revprop_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
name|svn_fs_fs__serialize_properties
argument_list|,
name|svn_fs_fs__deserialize_properties
argument_list|,
sizeof|sizeof
argument_list|(
name|pair_cache_key_t
argument_list|)
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"REVPROP"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|revprop_cache
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* if enabled, cache text deltas and their combinations */
if|if
condition|(
name|cache_txdeltas
condition|)
block|{
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|txdelta_window_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
name|svn_fs_fs__serialize_txdelta_window
argument_list|,
name|svn_fs_fs__deserialize_txdelta_window
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"TXDELTA_WINDOW"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|combined_window_cache
operator|)
argument_list|,
name|NULL
argument_list|,
name|membuffer
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
comment|/* Do not use inprocess cache */
comment|/* Values are svn_stringbuf_t */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"COMBINED_WINDOW"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|no_handler
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ffd
operator|->
name|txdelta_window_cache
operator|=
name|NULL
expr_stmt|;
name|ffd
operator|->
name|combined_window_cache
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton to be used for the remove_txn_cache() pool cleanup function, */
end_comment

begin_struct
struct|struct
name|txn_cleanup_baton_t
block|{
comment|/* the cache to reset */
name|svn_cache__t
modifier|*
name|txn_cache
decl_stmt|;
comment|/* the position where to reset it */
name|svn_cache__t
modifier|*
modifier|*
name|to_reset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* APR pool cleanup handler that will reset the cache pointer given in    BATON_VOID. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|remove_txn_cache
parameter_list|(
name|void
modifier|*
name|baton_void
parameter_list|)
block|{
name|struct
name|txn_cleanup_baton_t
modifier|*
name|baton
init|=
name|baton_void
decl_stmt|;
comment|/* be careful not to hurt performance by resetting newer txn's caches. */
if|if
condition|(
operator|*
name|baton
operator|->
name|to_reset
operator|==
name|baton
operator|->
name|txn_cache
condition|)
block|{
comment|/* This is equivalent to calling svn_fs_fs__reset_txn_caches(). */
operator|*
name|baton
operator|->
name|to_reset
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* This function sets / registers the required callbacks for a given  * transaction-specific *CACHE object, if CACHE is not NULL and a no-op  * otherwise. In particular, it will ensure that *CACHE gets reset to NULL  * upon POOL destruction latest.  */
end_comment

begin_function
specifier|static
name|void
name|init_txn_callbacks
parameter_list|(
name|svn_cache__t
modifier|*
modifier|*
name|cache
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|*
name|cache
operator|!=
name|NULL
condition|)
block|{
name|struct
name|txn_cleanup_baton_t
modifier|*
name|baton
decl_stmt|;
name|baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|txn_cache
operator|=
operator|*
name|cache
expr_stmt|;
name|baton
operator|->
name|to_reset
operator|=
name|cache
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|baton
argument_list|,
name|remove_txn_cache
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__initialize_txn_caches
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Transaction content needs to be carefully prefixed to virtually      eliminate any chance for conflicts. The (repo, txn_id) pair      should be unique but if a transaction fails, it might be possible      to start a new transaction later that receives the same id.      Therefore, throw in a uuid as well - just to be sure. */
specifier|const
name|char
modifier|*
name|prefix
init|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"fsfs:"
argument_list|,
name|fs
operator|->
name|uuid
argument_list|,
literal|"/"
argument_list|,
name|fs
operator|->
name|path
argument_list|,
literal|":"
argument_list|,
name|txn_id
argument_list|,
literal|":"
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|,
literal|":"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
decl_stmt|;
comment|/* We don't support caching for concurrent transactions in the SAME    * FSFS session. Maybe, you forgot to clean POOL. */
if|if
condition|(
name|ffd
operator|->
name|txn_dir_cache
operator|!=
name|NULL
operator|||
name|ffd
operator|->
name|concurrent_transactions
condition|)
block|{
name|ffd
operator|->
name|txn_dir_cache
operator|=
name|NULL
expr_stmt|;
name|ffd
operator|->
name|concurrent_transactions
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* create a txn-local directory cache */
name|SVN_ERR
argument_list|(
name|create_cache
argument_list|(
operator|&
name|ffd
operator|->
name|txn_dir_cache
argument_list|,
name|NULL
argument_list|,
name|svn_cache__get_global_membuffer_cache
argument_list|()
argument_list|,
literal|1024
argument_list|,
literal|8
argument_list|,
name|svn_fs_fs__serialize_dir_entries
argument_list|,
name|svn_fs_fs__deserialize_dir_entries
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|prefix
argument_list|,
literal|"TXNDIR"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
argument_list|,
name|fs
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reset the transaction-specific cache if the pool gets cleaned up. */
name|init_txn_callbacks
argument_list|(
operator|&
operator|(
name|ffd
operator|->
name|txn_dir_cache
operator|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_fs_fs__reset_txn_caches
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
comment|/* we can always just reset the caches. This may degrade performance but    * can never cause in incorrect behavior. */
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|ffd
operator|->
name|txn_dir_cache
operator|=
name|NULL
expr_stmt|;
block|}
end_function

end_unit

