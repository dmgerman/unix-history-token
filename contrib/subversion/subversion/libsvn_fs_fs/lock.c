begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lock.c :  functions for manipulating filesystem locks.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Names of hash keys used to store a lock for writing to disk. */
end_comment

begin_define
define|#
directive|define
name|PATH_KEY
value|"path"
end_define

begin_define
define|#
directive|define
name|TOKEN_KEY
value|"token"
end_define

begin_define
define|#
directive|define
name|OWNER_KEY
value|"owner"
end_define

begin_define
define|#
directive|define
name|CREATION_DATE_KEY
value|"creation_date"
end_define

begin_define
define|#
directive|define
name|EXPIRATION_DATE_KEY
value|"expiration_date"
end_define

begin_define
define|#
directive|define
name|COMMENT_KEY
value|"comment"
end_define

begin_define
define|#
directive|define
name|IS_DAV_COMMENT_KEY
value|"is_dav_comment"
end_define

begin_define
define|#
directive|define
name|CHILDREN_KEY
value|"children"
end_define

begin_comment
comment|/* Number of characters from the head of a digest file name used to    calculate a subdirectory in which to drop that file. */
end_comment

begin_define
define|#
directive|define
name|DIGEST_SUBDIR_LEN
value|3
end_define

begin_escape
end_escape

begin_comment
comment|/*** Generic helper functions. ***/
end_comment

begin_comment
comment|/* Set *DIGEST to the MD5 hash of STR. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_digest
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|digest
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|digest
operator|=
name|svn_checksum_to_cstring_display
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the value of KEY (whose size is KEY_LEN, or APR_HASH_KEY_STRING    if unknown) to an svn_string_t-ized version of VALUE (whose size is    VALUE_LEN, or APR_HASH_KEY_STRING if unknown) in HASH.  The value    will be allocated in POOL; KEY will not be duped.  If either KEY or VALUE    is NULL, this function will do nothing. */
end_comment

begin_function
specifier|static
name|void
name|hash_store
parameter_list|(
name|apr_hash_t
modifier|*
name|hash
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|key_len
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|apr_ssize_t
name|value_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|key
operator|&&
name|value
operator|)
condition|)
return|return;
if|if
condition|(
name|value_len
operator|==
name|APR_HASH_KEY_STRING
condition|)
name|value_len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|,
name|svn_string_ncreate
argument_list|(
name|value
argument_list|,
name|value_len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch the value of KEY from HASH, returning only the cstring data    of that value (if it exists). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hash_fetch
parameter_list|(
name|apr_hash_t
modifier|*
name|hash
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|str
init|=
name|svn_hash_gets
argument_list|(
name|hash
argument_list|,
name|key
argument_list|)
decl_stmt|;
return|return
name|str
condition|?
name|str
operator|->
name|data
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* SVN_ERR_FS_CORRUPT: the lockfile for PATH in FS is corrupt.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|err_corrupt_lockfile
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Corrupt lockfile for path '%s' in filesystem '%s'"
argument_list|)
argument_list|,
name|path
argument_list|,
name|fs_path
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Digest file handling functions. ***/
end_comment

begin_comment
comment|/* Return the path of the lock/entries file for which DIGEST is the    hashed repository relative path. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|digest_path_from_digest
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs_path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|digest
argument_list|,
name|DIGEST_SUBDIR_LEN
argument_list|)
argument_list|,
name|digest
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *DIGEST_PATH to the path to the lock/entries digest file associate    with PATH, where PATH is the path to the lock file or lock entries file    in FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|digest_path_from_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|digest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_digest
argument_list|(
operator|&
name|digest
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|digest_path
operator|=
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs_path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|digest
argument_list|,
name|DIGEST_SUBDIR_LEN
argument_list|)
argument_list|,
name|digest
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write to DIGEST_PATH a representation of CHILDREN (which may be    empty, if the versioned path in FS represented by DIGEST_PATH has    no children) and LOCK (which may be NULL if that versioned path is    lock itself locked).  Set the permissions of DIGEST_PATH to those of    PERMS_REFERENCE.  Use POOL for all allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_digest_file
parameter_list|(
name|apr_hash_t
modifier|*
name|children
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|hash
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_dir_exists
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs_path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_dir_exists
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
block|{
specifier|const
name|char
modifier|*
name|creation_date
init|=
name|NULL
decl_stmt|,
modifier|*
name|expiration_date
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|creation_date
condition|)
name|creation_date
operator|=
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|creation_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|expiration_date
condition|)
name|expiration_date
operator|=
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|expiration_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|PATH_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|PATH_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|TOKEN_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|TOKEN_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|token
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|OWNER_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|OWNER_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|owner
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|COMMENT_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|COMMENT_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|comment
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|IS_DAV_COMMENT_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|IS_DAV_COMMENT_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|is_dav_comment
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|CREATION_DATE_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|CREATION_DATE_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|creation_date
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|EXPIRATION_DATE_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|EXPIRATION_DATE_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|expiration_date
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|children
argument_list|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|children_list
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|children_list
argument_list|,
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
argument_list|,
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|children_list
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|hash_store
argument_list|(
name|hash
argument_list|,
name|CHILDREN_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|CHILDREN_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|children_list
operator|->
name|data
argument_list|,
name|children_list
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_hash_write2
argument_list|(
name|hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Cannot write lock/entries hashfile '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|tmp_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|tmp_path
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|perms_reference
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the file at DIGEST_PATH, populating the lock LOCK_P in that    file (if it exists, and if *LOCK_P is non-NULL) and the hash of    CHILDREN_P (if any exist, and if *CHILDREN_P is non-NULL).  Use POOL    for all allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_digest_file
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|children_p
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|apr_hash_t
modifier|*
name|hash
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
if|if
condition|(
name|lock_p
condition|)
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|children_p
condition|)
operator|*
name|children_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* If our caller doesn't care about anything but the presence of the      file... whatever. */
if|if
condition|(
operator|!
operator|(
name|lock_p
operator|||
name|children_p
operator|)
condition|)
return|return
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
return|;
name|hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_hash_read2
argument_list|(
name|hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Can't parse lock/entries hashfile '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If our caller cares, see if we have a lock path in our hash. If      so, we'll assume we have a lock here. */
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|PATH_KEY
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|lock_p
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|val
decl_stmt|;
comment|/* Create our lock and load it up. */
name|lock
operator|=
name|svn_lock_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|lock
operator|->
name|path
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|lock
operator|->
name|token
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|TOKEN_KEY
argument_list|,
name|pool
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|lock
operator|->
name|owner
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|OWNER_KEY
argument_list|,
name|pool
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|IS_DAV_COMMENT_KEY
argument_list|,
name|pool
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
name|lock
operator|->
name|is_dav_comment
operator|=
operator|(
name|val
index|[
literal|0
index|]
operator|==
literal|'1'
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|CREATION_DATE_KEY
argument_list|,
name|pool
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|creation_date
operator|)
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|EXPIRATION_DATE_KEY
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|expiration_date
operator|)
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|comment
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|COMMENT_KEY
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|lock
expr_stmt|;
block|}
comment|/* If our caller cares, see if we have any children for this path. */
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|CHILDREN_KEY
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|children_p
condition|)
block|{
name|apr_array_header_t
modifier|*
name|kiddos
init|=
name|svn_cstring_split
argument_list|(
name|val
argument_list|,
literal|"\n"
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kiddos
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_hash_sets
argument_list|(
operator|*
name|children_p
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|kiddos
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Lock helper functions (path here are still FS paths, not on-disk      schema-supporting paths) ***/
end_comment

begin_comment
comment|/* Write LOCK in FS to the actual OS filesystem.     Use PERMS_REFERENCE for the permissions of any digest files.     Note: this takes an FS_PATH because it's called from the hotcopy logic.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_lock
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|this_path
init|=
name|svn_stringbuf_create
argument_list|(
name|lock
operator|->
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_digest_path
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* Iterate in reverse, creating the lock for LOCK->path, and then      just adding entries for its parent, until we reach a parent      that's already listed in *its* parent. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1729
condition|)
block|{
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|,
modifier|*
name|digest_file
decl_stmt|;
name|apr_hash_t
modifier|*
name|this_children
decl_stmt|;
name|svn_lock_t
modifier|*
name|this_lock
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Calculate the DIGEST_PATH for the currently FS path, and then          get its DIGEST_FILE basename. */
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs_path
argument_list|,
name|this_path
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|digest_file
operator|=
name|svn_dirent_basename
argument_list|(
name|digest_path
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
operator|&
name|this_children
argument_list|,
operator|&
name|this_lock
argument_list|,
name|fs_path
argument_list|,
name|digest_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're either writing a new lock (first time through only) or          a new entry (every time but the first). */
if|if
condition|(
name|lock
condition|)
block|{
name|this_lock
operator|=
name|lock
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
name|lock_digest_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|digest_file
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If we already have an entry for this path, we're done. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|this_children
argument_list|,
name|lock_digest_path
argument_list|)
condition|)
break|break;
name|svn_hash_sets
argument_list|(
name|this_children
argument_list|,
name|lock_digest_path
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|write_digest_file
argument_list|(
name|this_children
argument_list|,
name|this_lock
argument_list|,
name|fs_path
argument_list|,
name|digest_path
argument_list|,
name|perms_reference
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prep for next iteration, or bail if we're done. */
if|if
condition|(
name|svn_fspath__is_root
argument_list|(
name|this_path
operator|->
name|data
argument_list|,
name|this_path
operator|->
name|len
argument_list|)
condition|)
break|break;
name|svn_stringbuf_set
argument_list|(
name|this_path
argument_list|,
name|svn_fspath__dirname
argument_list|(
name|this_path
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Delete LOCK from FS in the actual OS filesystem. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|this_path
init|=
name|svn_stringbuf_create
argument_list|(
name|lock
operator|->
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_to_kill
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|lock
argument_list|)
expr_stmt|;
comment|/* Iterate in reverse, deleting the lock for LOCK->path, and then      deleting its entry as it appears in each of its parents. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1729
condition|)
block|{
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|,
modifier|*
name|digest_file
decl_stmt|;
name|apr_hash_t
modifier|*
name|this_children
decl_stmt|;
name|svn_lock_t
modifier|*
name|this_lock
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Calculate the DIGEST_PATH for the currently FS path, and then          get its DIGEST_FILE basename. */
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|this_path
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|digest_file
operator|=
name|svn_dirent_basename
argument_list|(
name|digest_path
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
operator|&
name|this_children
argument_list|,
operator|&
name|this_lock
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|digest_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete the lock (first time through only). */
if|if
condition|(
name|lock
condition|)
block|{
name|this_lock
operator|=
name|NULL
expr_stmt|;
name|lock
operator|=
name|NULL
expr_stmt|;
name|child_to_kill
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|digest_file
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|child_to_kill
condition|)
name|svn_hash_sets
argument_list|(
name|this_children
argument_list|,
name|child_to_kill
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|this_lock
operator|||
name|apr_hash_count
argument_list|(
name|this_children
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Special case:  no goodz, no file.  And remember to nix              the entry for it in its parent. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|digest_path
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|rev_0_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__path_rev_absolute
argument_list|(
operator|&
name|rev_0_path
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_digest_file
argument_list|(
name|this_children
argument_list|,
name|this_lock
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|digest_path
argument_list|,
name|rev_0_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Prep for next iteration, or bail if we're done. */
if|if
condition|(
name|svn_fspath__is_root
argument_list|(
name|this_path
operator|->
name|data
argument_list|,
name|this_path
operator|->
name|len
argument_list|)
condition|)
break|break;
name|svn_stringbuf_set
argument_list|(
name|this_path
argument_list|,
name|svn_fspath__dirname
argument_list|(
name|this_path
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *LOCK_P to the lock for PATH in FS.  HAVE_WRITE_LOCK should be    TRUE if the caller (or one of its callers) has taken out the    repository-wide write lock, FALSE otherwise.  If MUST_EXIST is    not set, the function will simply return NULL in *LOCK_P instead    of creating an SVN_FS__ERR_NO_SUCH_LOCK error in case the lock    was not found (much faster).  Use POOL for allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_lock_t
modifier|*
name|lock
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|digest_path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
name|NULL
argument_list|,
operator|&
name|lock
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
name|must_exist
condition|?
name|SVN_FS__ERR_NO_SUCH_LOCK
argument_list|(
name|fs
argument_list|,
name|path
argument_list|)
else|:
name|SVN_NO_ERROR
return|;
comment|/* Don't return an expired lock. */
if|if
condition|(
name|lock
operator|->
name|expiration_date
operator|&&
operator|(
name|apr_time_now
argument_list|()
operator|>
name|lock
operator|->
name|expiration_date
operator|)
condition|)
block|{
comment|/* Only remove the lock if we have the write lock.          Read operations shouldn't change the filesystem. */
if|if
condition|(
name|have_write_lock
condition|)
name|SVN_ERR
argument_list|(
name|delete_lock
argument_list|(
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_FS__ERR_LOCK_EXPIRED
argument_list|(
name|fs
argument_list|,
name|lock
operator|->
name|token
argument_list|)
return|;
block|}
operator|*
name|lock_p
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *LOCK_P to the lock for PATH in FS.  HAVE_WRITE_LOCK should be    TRUE if the caller (or one of its callers) has taken out the    repository-wide write lock, FALSE otherwise.  Use POOL for    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock_helper
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
name|have_write_lock
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We've deliberately decided that this function doesn't tell the      caller *why* the lock is unavailable.  */
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_LOCK
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_LOCK_EXPIRED
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for locks_walker(). */
end_comment

begin_struct
struct|struct
name|walk_locks_baton
block|{
name|svn_fs_get_locks_callback_t
name|get_locks_func
decl_stmt|;
name|void
modifier|*
name|get_locks_baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements walk_digests_callback_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|locks_walker
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
name|apr_hash_t
modifier|*
name|children
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|walk_locks_baton
modifier|*
name|wlb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|lock
condition|)
block|{
comment|/* Don't report an expired lock. */
if|if
condition|(
name|lock
operator|->
name|expiration_date
operator|==
literal|0
operator|||
operator|(
name|apr_time_now
argument_list|()
operator|<=
name|lock
operator|->
name|expiration_date
operator|)
condition|)
block|{
if|if
condition|(
name|wlb
operator|->
name|get_locks_func
condition|)
name|SVN_ERR
argument_list|(
name|wlb
operator|->
name|get_locks_func
argument_list|(
name|wlb
operator|->
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Only remove the lock if we have the write lock.              Read operations shouldn't change the filesystem. */
if|if
condition|(
name|have_write_lock
condition|)
name|SVN_ERR
argument_list|(
name|delete_lock
argument_list|(
name|wlb
operator|->
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback type for walk_digest_files().  *  * CHILDREN and LOCK come from a read_digest_file(digest_path) call.  */
end_comment

begin_typedef
typedef|typedef
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|walk_digests_callback_t
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
name|apr_hash_t
modifier|*
name|children
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* A recursive function that calls WALK_DIGESTS_FUNC/WALK_DIGESTS_BATON for    all lock digest files in and under PATH in FS.    HAVE_WRITE_LOCK should be true if the caller (directly or indirectly)    has the FS write lock. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|walk_digest_files
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
name|walk_digests_callback_t
name|walk_digests_func
parameter_list|,
name|void
modifier|*
name|walk_digests_baton
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|children
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
comment|/* First, send up any locks in the current digest file. */
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
operator|&
name|children
argument_list|,
operator|&
name|lock
argument_list|,
name|fs_path
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walk_digests_func
argument_list|(
name|walk_digests_baton
argument_list|,
name|fs_path
argument_list|,
name|digest_path
argument_list|,
name|children
argument_list|,
name|lock
argument_list|,
name|have_write_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, recurse on this thing's child entries (if any; bail otherwise). */
if|if
condition|(
operator|!
name|apr_hash_count
argument_list|(
name|children
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|digest
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walk_digest_files
argument_list|(
name|fs_path
argument_list|,
name|digest_path_from_digest
argument_list|(
name|fs_path
argument_list|,
name|digest
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|walk_digests_func
argument_list|,
name|walk_digests_baton
argument_list|,
name|have_write_lock
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A recursive function that calls GET_LOCKS_FUNC/GET_LOCKS_BATON for    all locks in and under PATH in FS.    HAVE_WRITE_LOCK should be true if the caller (directly or indirectly)    has the FS write lock. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|walk_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
name|svn_fs_get_locks_callback_t
name|get_locks_func
parameter_list|,
name|void
modifier|*
name|get_locks_baton
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|walk_locks_baton
name|wlb
decl_stmt|;
name|wlb
operator|.
name|get_locks_func
operator|=
name|get_locks_func
expr_stmt|;
name|wlb
operator|.
name|get_locks_baton
operator|=
name|get_locks_baton
expr_stmt|;
name|wlb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walk_digest_files
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|digest_path
argument_list|,
name|locks_walker
argument_list|,
operator|&
name|wlb
argument_list|,
name|have_write_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function:  verify that a lock can be used.  Interesting    errors returned from this function:        SVN_ERR_FS_NO_USER: No username attached to FS.       SVN_ERR_FS_LOCK_OWNER_MISMATCH: FS's username doesn't match LOCK's owner.       SVN_ERR_FS_BAD_LOCK_TOKEN: FS doesn't hold matching lock-token for LOCK.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|fs
operator|->
name|access_ctx
operator|)
operator|||
operator|(
operator|!
name|fs
operator|->
name|access_ctx
operator|->
name|username
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_USER
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot verify lock on path '%s'; no username available"
argument_list|)
argument_list|,
name|lock
operator|->
name|path
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_LOCK_OWNER_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"User '%s' does not own lock on path '%s' (currently locked by '%s')"
argument_list|)
argument_list|,
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|access_ctx
operator|->
name|lock_tokens
argument_list|,
name|lock
operator|->
name|token
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_BAD_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot verify lock on path '%s'; no matching lock-token available"
argument_list|)
argument_list|,
name|lock
operator|->
name|path
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the svn_fs_get_locks_callback_t interface, where    BATON is just an svn_fs_t object. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locks_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|verify_lock
argument_list|(
name|baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The main routine for lock enforcement, used throughout libsvn_fs_fs. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__allow_locked_operation
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|recurse
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|recurse
condition|)
block|{
comment|/* Discover all locks at or below the path. */
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walk_locks
argument_list|(
name|fs
argument_list|,
name|digest_path
argument_list|,
name|get_locks_callback
argument_list|,
name|fs
argument_list|,
name|have_write_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Discover and verify any lock attached to the path. */
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_lock_helper
argument_list|(
name|fs
argument_list|,
operator|&
name|lock
argument_list|,
name|path
argument_list|,
name|have_write_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|SVN_ERR
argument_list|(
name|verify_lock
argument_list|(
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for lock_body below. */
end_comment

begin_struct
struct|struct
name|lock_baton
block|{
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|svn_boolean_t
name|is_dav_comment
decl_stmt|;
name|apr_time_t
name|expiration_date
decl_stmt|;
name|svn_revnum_t
name|current_rev
decl_stmt|;
name|svn_boolean_t
name|steal_lock
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements the svn_fs_fs__with_write_lock() 'body' callback    type, and assumes that the write lock is held.    BATON is a 'struct lock_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|lock_baton
modifier|*
name|lb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_lock_t
modifier|*
name|existing_lock
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_0_path
decl_stmt|;
comment|/* Until we implement directory locks someday, we only allow locks      on files or non-existent paths. */
comment|/* Use fs->vtable->foo instead of svn_fs_foo to avoid circular      library dependencies, which are not portable. */
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|fs
operator|->
name|vtable
operator|->
name|youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|lb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|fs
operator|->
name|vtable
operator|->
name|revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|lb
operator|->
name|fs
argument_list|,
name|youngest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|lb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
return|return
name|SVN_FS__ERR_NOT_FILE
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
name|lb
operator|->
name|path
argument_list|)
return|;
comment|/* While our locking implementation easily supports the locking of      nonexistent paths, we deliberately choose not to allow such madness. */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|lb
operator|->
name|current_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|lb
operator|->
name|path
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|lb
operator|->
name|path
argument_list|)
return|;
block|}
comment|/* We need to have a username attached to the fs. */
if|if
condition|(
operator|!
name|lb
operator|->
name|fs
operator|->
name|access_ctx
operator|||
operator|!
name|lb
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
condition|)
return|return
name|SVN_FS__ERR_NO_USER
argument_list|(
name|lb
operator|->
name|fs
argument_list|)
return|;
comment|/* Is the caller attempting to lock an out-of-date working file? */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|lb
operator|->
name|current_rev
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|created_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_created_rev
argument_list|(
operator|&
name|created_rev
argument_list|,
name|root
argument_list|,
name|lb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SVN_INVALID_REVNUM means the path doesn't exist.  So          apparently somebody is trying to lock something in their          working copy, but somebody else has deleted the thing          from HEAD.  That counts as being 'out of date'. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|created_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|lb
operator|->
name|path
argument_list|)
return|;
if|if
condition|(
name|lb
operator|->
name|current_rev
operator|<
name|created_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Lock failed: newer version of '%s' exists"
argument_list|)
argument_list|,
name|lb
operator|->
name|path
argument_list|)
return|;
block|}
comment|/* If the caller provided a TOKEN, we *really* need to see      if a lock already exists with that token, and if so, verify that      the lock's path matches PATH.  Otherwise we run the risk of      breaking the 1-to-1 mapping of lock tokens to locked paths. */
comment|/* ### TODO:  actually do this check.  This is tough, because the      schema doesn't supply a lookup-by-token mechanism. */
comment|/* Is the path already locked?       Note that this next function call will automatically ignore any      errors about {the path not existing as a key, the path's token      not existing as a key, the lock just having been expired}.  And      that's totally fine.  Any of these three errors are perfectly      acceptable to ignore; it means that the path is now free and      clear for locking, because the fsfs funcs just cleared out both      of the tables for us.   */
name|SVN_ERR
argument_list|(
name|get_lock_helper
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
operator|&
name|existing_lock
argument_list|,
name|lb
operator|->
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|existing_lock
condition|)
block|{
if|if
condition|(
operator|!
name|lb
operator|->
name|steal_lock
condition|)
block|{
comment|/* Sorry, the path is already locked. */
return|return
name|SVN_FS__ERR_PATH_ALREADY_LOCKED
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
name|existing_lock
argument_list|)
return|;
block|}
else|else
block|{
comment|/* STEAL_LOCK was passed, so fs_username is "stealing" the              lock from lock->owner.  Destroy the existing lock. */
name|SVN_ERR
argument_list|(
name|delete_lock
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
name|existing_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create our new lock, and add it to the tables.      Ensure that the lock is created in the correct pool. */
name|lock
operator|=
name|svn_lock_create
argument_list|(
name|lb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lb
operator|->
name|token
condition|)
name|lock
operator|->
name|token
operator|=
name|apr_pstrdup
argument_list|(
name|lb
operator|->
name|pool
argument_list|,
name|lb
operator|->
name|token
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_fs__generate_lock_token
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|token
operator|)
argument_list|,
name|lb
operator|->
name|fs
argument_list|,
name|lb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|lb
operator|->
name|pool
argument_list|,
name|lb
operator|->
name|path
argument_list|)
expr_stmt|;
name|lock
operator|->
name|owner
operator|=
name|apr_pstrdup
argument_list|(
name|lb
operator|->
name|pool
argument_list|,
name|lb
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|)
expr_stmt|;
name|lock
operator|->
name|comment
operator|=
name|apr_pstrdup
argument_list|(
name|lb
operator|->
name|pool
argument_list|,
name|lb
operator|->
name|comment
argument_list|)
expr_stmt|;
name|lock
operator|->
name|is_dav_comment
operator|=
name|lb
operator|->
name|is_dav_comment
expr_stmt|;
name|lock
operator|->
name|creation_date
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
name|lock
operator|->
name|expiration_date
operator|=
name|lb
operator|->
name|expiration_date
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__path_rev_absolute
argument_list|(
operator|&
name|rev_0_path
argument_list|,
name|lb
operator|->
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|set_lock
argument_list|(
name|lb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|lock
argument_list|,
name|rev_0_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lb
operator|->
name|lock_p
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for unlock_body below. */
end_comment

begin_struct
struct|struct
name|unlock_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|svn_boolean_t
name|break_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements the svn_fs_fs__with_write_lock() 'body' callback    type, and assumes that the write lock is held.    BATON is a 'struct unlock_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_baton
modifier|*
name|ub
init|=
name|baton
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
comment|/* This could return SVN_ERR_FS_BAD_LOCK_TOKEN or SVN_ERR_FS_LOCK_EXPIRED. */
name|SVN_ERR
argument_list|(
name|get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|ub
operator|->
name|fs
argument_list|,
name|ub
operator|->
name|path
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unless breaking the lock, we do some checks. */
if|if
condition|(
operator|!
name|ub
operator|->
name|break_lock
condition|)
block|{
comment|/* Sanity check:  the incoming token should match lock->token. */
if|if
condition|(
name|strcmp
argument_list|(
name|ub
operator|->
name|token
argument_list|,
name|lock
operator|->
name|token
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SVN_FS__ERR_NO_SUCH_LOCK
argument_list|(
name|ub
operator|->
name|fs
argument_list|,
name|lock
operator|->
name|path
argument_list|)
return|;
comment|/* There better be a username attached to the fs. */
if|if
condition|(
operator|!
operator|(
name|ub
operator|->
name|fs
operator|->
name|access_ctx
operator|&&
name|ub
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
operator|)
condition|)
return|return
name|SVN_FS__ERR_NO_USER
argument_list|(
name|ub
operator|->
name|fs
argument_list|)
return|;
comment|/* And that username better be the same as the lock's owner. */
if|if
condition|(
name|strcmp
argument_list|(
name|ub
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SVN_FS__ERR_LOCK_OWNER_MISMATCH
argument_list|(
name|ub
operator|->
name|fs
argument_list|,
name|ub
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
return|;
block|}
comment|/* Remove lock and lock token files. */
return|return
name|delete_lock
argument_list|(
name|ub
operator|->
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public API implementations ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|is_dav_comment
parameter_list|,
name|apr_time_t
name|expiration_date
parameter_list|,
name|svn_revnum_t
name|current_rev
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|lock_baton
name|lb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|lb
operator|.
name|lock_p
operator|=
name|lock_p
expr_stmt|;
name|lb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|lb
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|lb
operator|.
name|token
operator|=
name|token
expr_stmt|;
name|lb
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
name|lb
operator|.
name|is_dav_comment
operator|=
name|is_dav_comment
expr_stmt|;
name|lb
operator|.
name|expiration_date
operator|=
name|expiration_date
expr_stmt|;
name|lb
operator|.
name|current_rev
operator|=
name|current_rev
expr_stmt|;
name|lb
operator|.
name|steal_lock
operator|=
name|steal_lock
expr_stmt|;
name|lb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|lock_body
argument_list|,
operator|&
name|lb
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__generate_lock_token
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|token
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notice that 'fs' is currently unused.  But perhaps someday, we'll      want to use the fs UUID + some incremented number?  For now, we      generate a URI that matches the DAV RFC.  We could change this to      some other URI scheme someday, if we wish. */
operator|*
name|token
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"opaquelocktoken:"
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__unlock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_baton
name|ub
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|ub
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|ub
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|ub
operator|.
name|token
operator|=
name|token
expr_stmt|;
name|ub
operator|.
name|break_lock
operator|=
name|break_lock
expr_stmt|;
return|return
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|unlock_body
argument_list|,
operator|&
name|ub
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|get_lock_helper
argument_list|(
name|fs
argument_list|,
name|lock_p
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for get_locks_filter_func(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|get_locks_filter_baton_t
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_depth_t
name|requested_depth
decl_stmt|;
name|svn_fs_get_locks_callback_t
name|get_locks_func
decl_stmt|;
name|void
modifier|*
name|get_locks_baton
decl_stmt|;
block|}
name|get_locks_filter_baton_t
typedef|;
end_typedef

begin_comment
comment|/* A wrapper for the GET_LOCKS_FUNC passed to svn_fs_fs__get_locks()    which filters out locks on paths that aren't within    BATON->requested_depth of BATON->path before called    BATON->get_locks_func() with BATON->get_locks_baton.     NOTE: See issue #3660 for details about how the FSFS lock    management code is inconsistent.  Until that inconsistency is    resolved, we take this filtering approach rather than honoring    depth requests closer to the crawling code.  In other words, once    we decide how to resolve issue #3660, there might be a more    performant way to honor the depth passed to svn_fs_fs__get_locks().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locks_filter_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|get_locks_filter_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* Filter out unwanted paths.  Since Subversion only allows      locks on files, we can treat depth=immediates the same as      depth=files for filtering purposes.  Meaning, we'll keep      this lock if:       a) its path is the very path we queried, or      b) we've asked for a fully recursive answer, or      c) we've asked for depth=files or depth=immediates, and this         lock is on an immediate child of our query path.   */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|path
argument_list|,
name|lock
operator|->
name|path
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|b
operator|->
name|requested_depth
operator|==
name|svn_depth_infinity
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|b
operator|->
name|get_locks_func
argument_list|(
name|b
operator|->
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|requested_depth
operator|==
name|svn_depth_files
operator|)
operator|||
operator|(
name|b
operator|->
name|requested_depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|rel_uri
init|=
name|svn_fspath__skip_ancestor
argument_list|(
name|b
operator|->
name|path
argument_list|,
name|lock
operator|->
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel_uri
operator|&&
operator|(
name|svn_path_component_count
argument_list|(
name|rel_uri
argument_list|)
operator|==
literal|1
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|get_locks_func
argument_list|(
name|b
operator|->
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_fs_get_locks_callback_t
name|get_locks_func
parameter_list|,
name|void
modifier|*
name|get_locks_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|get_locks_filter_baton_t
name|glfb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|glfb
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|glfb
operator|.
name|requested_depth
operator|=
name|depth
expr_stmt|;
name|glfb
operator|.
name|get_locks_func
operator|=
name|get_locks_func
expr_stmt|;
name|glfb
operator|.
name|get_locks_baton
operator|=
name|get_locks_baton
expr_stmt|;
comment|/* Get the top digest path in our tree of interest, and then walk it. */
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walk_locks
argument_list|(
name|fs
argument_list|,
name|digest_path
argument_list|,
name|get_locks_filter_func
argument_list|,
operator|&
name|glfb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

