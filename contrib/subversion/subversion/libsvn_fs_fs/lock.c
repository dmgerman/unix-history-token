begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lock.c :  functions for manipulating filesystem locks.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Names of hash keys used to store a lock for writing to disk. */
end_comment

begin_define
define|#
directive|define
name|PATH_KEY
value|"path"
end_define

begin_define
define|#
directive|define
name|TOKEN_KEY
value|"token"
end_define

begin_define
define|#
directive|define
name|OWNER_KEY
value|"owner"
end_define

begin_define
define|#
directive|define
name|CREATION_DATE_KEY
value|"creation_date"
end_define

begin_define
define|#
directive|define
name|EXPIRATION_DATE_KEY
value|"expiration_date"
end_define

begin_define
define|#
directive|define
name|COMMENT_KEY
value|"comment"
end_define

begin_define
define|#
directive|define
name|IS_DAV_COMMENT_KEY
value|"is_dav_comment"
end_define

begin_define
define|#
directive|define
name|CHILDREN_KEY
value|"children"
end_define

begin_comment
comment|/* Number of characters from the head of a digest file name used to    calculate a subdirectory in which to drop that file. */
end_comment

begin_define
define|#
directive|define
name|DIGEST_SUBDIR_LEN
value|3
end_define

begin_escape
end_escape

begin_comment
comment|/*** Generic helper functions. ***/
end_comment

begin_comment
comment|/* Set *DIGEST to the MD5 hash of STR. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_digest
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|digest
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|digest
operator|=
name|svn_checksum_to_cstring_display
argument_list|(
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the value of KEY (whose size is KEY_LEN, or APR_HASH_KEY_STRING    if unknown) to an svn_string_t-ized version of VALUE (whose size is    VALUE_LEN, or APR_HASH_KEY_STRING if unknown) in HASH.  The value    will be allocated in POOL; KEY will not be duped.  If either KEY or VALUE    is NULL, this function will do nothing. */
end_comment

begin_function
specifier|static
name|void
name|hash_store
parameter_list|(
name|apr_hash_t
modifier|*
name|hash
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|key_len
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|apr_ssize_t
name|value_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|(
name|key
operator|&&
name|value
operator|)
condition|)
return|return;
if|if
condition|(
name|value_len
operator|==
name|APR_HASH_KEY_STRING
condition|)
name|value_len
operator|=
name|strlen
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|key
argument_list|,
name|key_len
argument_list|,
name|svn_string_ncreate
argument_list|(
name|value
argument_list|,
name|value_len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Fetch the value of KEY from HASH, returning only the cstring data    of that value (if it exists). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|hash_fetch
parameter_list|(
name|apr_hash_t
modifier|*
name|hash
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|str
init|=
name|svn_hash_gets
argument_list|(
name|hash
argument_list|,
name|key
argument_list|)
decl_stmt|;
return|return
name|str
condition|?
name|str
operator|->
name|data
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* SVN_ERR_FS_CORRUPT: the lockfile for PATH in FS is corrupt.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|err_corrupt_lockfile
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Corrupt lockfile for path '%s' in filesystem '%s'"
argument_list|)
argument_list|,
name|path
argument_list|,
name|fs_path
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Digest file handling functions. ***/
end_comment

begin_comment
comment|/* Return the path of the lock/entries file for which DIGEST is the    hashed repository relative path. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|digest_path_from_digest
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs_path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|digest
argument_list|,
name|DIGEST_SUBDIR_LEN
argument_list|)
argument_list|,
name|digest
argument_list|,
name|SVN_VA_NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *DIGEST_PATH to the path to the lock/entries digest file associate    with PATH, where PATH is the path to the lock file or lock entries file    in FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|digest_path_from_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|digest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_digest
argument_list|(
operator|&
name|digest
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|digest_path
operator|=
name|svn_dirent_join_many
argument_list|(
name|pool
argument_list|,
name|fs_path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|digest
argument_list|,
name|DIGEST_SUBDIR_LEN
argument_list|)
argument_list|,
name|digest
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write to DIGEST_PATH a representation of CHILDREN (which may be    empty, if the versioned path in FS represented by DIGEST_PATH has    no children) and LOCK (which may be NULL if that versioned path is    lock itself locked).  Set the permissions of DIGEST_PATH to those of    PERMS_REFERENCE.  Use POOL for all allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_digest_file
parameter_list|(
name|apr_hash_t
modifier|*
name|children
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|hash
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_dir_exists
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs_path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_dir_exists
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fs_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
block|{
specifier|const
name|char
modifier|*
name|creation_date
init|=
name|NULL
decl_stmt|,
modifier|*
name|expiration_date
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|lock
operator|->
name|creation_date
condition|)
name|creation_date
operator|=
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|creation_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|expiration_date
condition|)
name|expiration_date
operator|=
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|expiration_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|PATH_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|PATH_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|TOKEN_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|TOKEN_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|token
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|OWNER_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|OWNER_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|owner
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|COMMENT_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|COMMENT_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|comment
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|IS_DAV_COMMENT_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|IS_DAV_COMMENT_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|lock
operator|->
name|is_dav_comment
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|CREATION_DATE_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|CREATION_DATE_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|creation_date
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|hash_store
argument_list|(
name|hash
argument_list|,
name|EXPIRATION_DATE_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|EXPIRATION_DATE_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|expiration_date
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|children
argument_list|)
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|children_list
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_stringbuf_appendbytes
argument_list|(
name|children_list
argument_list|,
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
argument_list|,
name|apr_hash_this_key_len
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|children_list
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|hash_store
argument_list|(
name|hash
argument_list|,
name|CHILDREN_KEY
argument_list|,
sizeof|sizeof
argument_list|(
name|CHILDREN_KEY
argument_list|)
operator|-
literal|1
argument_list|,
name|children_list
operator|->
name|data
argument_list|,
name|children_list
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_hash_write2
argument_list|(
name|hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Cannot write lock/entries hashfile '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|tmp_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|tmp_path
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|perms_reference
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the file at DIGEST_PATH, populating the lock LOCK_P in that    file (if it exists, and if *LOCK_P is non-NULL) and the hash of    CHILDREN_P (if any exist, and if *CHILDREN_P is non-NULL).  Use POOL    for all allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_digest_file
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|children_p
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|apr_hash_t
modifier|*
name|hash
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
name|lock_p
condition|)
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|children_p
condition|)
operator|*
name|children_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|digest_path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If our caller doesn't care about anything but the presence of the      file... whatever. */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|&&
operator|!
name|lock_p
operator|&&
operator|!
name|children_p
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hash
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_hash_read2
argument_list|(
name|hash
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Can't parse lock/entries hashfile '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If our caller cares, see if we have a lock path in our hash. If      so, we'll assume we have a lock here. */
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|PATH_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|lock_p
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|val
decl_stmt|;
comment|/* Create our lock and load it up. */
name|lock
operator|=
name|svn_lock_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|lock
operator|->
name|path
operator|=
name|path
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|lock
operator|->
name|token
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|TOKEN_KEY
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|lock
operator|->
name|owner
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|OWNER_KEY
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|IS_DAV_COMMENT_KEY
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
name|lock
operator|->
name|is_dav_comment
operator|=
operator|(
name|val
index|[
literal|0
index|]
operator|==
literal|'1'
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|CREATION_DATE_KEY
argument_list|)
operator|)
operator|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err_corrupt_lockfile
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|creation_date
operator|)
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|EXPIRATION_DATE_KEY
argument_list|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|expiration_date
operator|)
argument_list|,
name|val
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|comment
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|COMMENT_KEY
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|lock
expr_stmt|;
block|}
comment|/* If our caller cares, see if we have any children for this path. */
name|val
operator|=
name|hash_fetch
argument_list|(
name|hash
argument_list|,
name|CHILDREN_KEY
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|&&
name|children_p
condition|)
block|{
name|apr_array_header_t
modifier|*
name|kiddos
init|=
name|svn_cstring_split
argument_list|(
name|val
argument_list|,
literal|"\n"
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|kiddos
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_hash_sets
argument_list|(
operator|*
name|children_p
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|kiddos
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Lock helper functions (path here are still FS paths, not on-disk      schema-supporting paths) ***/
end_comment

begin_comment
comment|/* Write LOCK in FS to the actual OS filesystem.     Use PERMS_REFERENCE for the permissions of any digest files.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_lock
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|children
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs_path
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We could get away without reading the file as children should      always come back empty. */
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
operator|&
name|children
argument_list|,
name|NULL
argument_list|,
name|fs_path
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_digest_file
argument_list|(
name|children
argument_list|,
name|lock
argument_list|,
name|fs_path
argument_list|,
name|digest_path
argument_list|,
name|perms_reference
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_lock
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|digest_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_to_digest
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
specifier|const
name|char
modifier|*
name|index_path
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|index_digest_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|children
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|original_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|index_digest_path
argument_list|,
name|fs_path
argument_list|,
name|index_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
operator|&
name|children
argument_list|,
operator|&
name|lock
argument_list|,
name|fs_path
argument_list|,
name|index_digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|original_count
operator|=
name|apr_hash_count
argument_list|(
name|children
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|,
modifier|*
name|digest_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|digest_file
operator|=
name|svn_dirent_basename
argument_list|(
name|digest_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|children
argument_list|,
name|digest_file
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|children
argument_list|)
operator|!=
name|original_count
condition|)
name|SVN_ERR
argument_list|(
name|write_digest_file
argument_list|(
name|children
argument_list|,
name|lock
argument_list|,
name|fs_path
argument_list|,
name|index_digest_path
argument_list|,
name|perms_reference
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_from_digest
parameter_list|(
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
specifier|const
name|char
modifier|*
name|index_path
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|index_digest_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|children
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|index_digest_path
argument_list|,
name|fs_path
argument_list|,
name|index_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
operator|&
name|children
argument_list|,
operator|&
name|lock
argument_list|,
name|fs_path
argument_list|,
name|index_digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|,
modifier|*
name|digest_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|digest_file
operator|=
name|svn_dirent_basename
argument_list|(
name|digest_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|children
argument_list|,
name|digest_file
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|children
argument_list|)
operator|||
name|lock
condition|)
name|SVN_ERR
argument_list|(
name|write_digest_file
argument_list|(
name|children
argument_list|,
name|lock
argument_list|,
name|fs_path
argument_list|,
name|index_digest_path
argument_list|,
name|perms_reference
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|index_digest_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|unlock_single
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Check if LOCK has been already expired. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|lock_expired
parameter_list|(
specifier|const
name|svn_lock_t
modifier|*
name|lock
parameter_list|)
block|{
return|return
name|lock
operator|->
name|expiration_date
operator|&&
operator|(
name|apr_time_now
argument_list|()
operator|>
name|lock
operator|->
name|expiration_date
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Set *LOCK_P to the lock for PATH in FS.  HAVE_WRITE_LOCK should be    TRUE if the caller (or one of its callers) has taken out the    repository-wide write lock, FALSE otherwise.  If MUST_EXIST is    not set, the function will simply return NULL in *LOCK_P instead    of creating an SVN_FS__ERR_NO_SUCH_LOCK error in case the lock    was not found (much faster).  Use POOL for allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|svn_boolean_t
name|must_exist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_lock_t
modifier|*
name|lock
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|digest_path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
name|NULL
argument_list|,
operator|&
name|lock
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|lock
condition|)
return|return
name|must_exist
condition|?
name|SVN_FS__ERR_NO_SUCH_LOCK
argument_list|(
name|fs
argument_list|,
name|path
argument_list|)
else|:
name|SVN_NO_ERROR
return|;
comment|/* Don't return an expired lock. */
if|if
condition|(
name|lock_expired
argument_list|(
name|lock
argument_list|)
condition|)
block|{
comment|/* Only remove the lock if we have the write lock.          Read operations shouldn't change the filesystem. */
if|if
condition|(
name|have_write_lock
condition|)
name|SVN_ERR
argument_list|(
name|unlock_single
argument_list|(
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_FS__ERR_LOCK_EXPIRED
argument_list|(
name|fs
argument_list|,
name|lock
operator|->
name|token
argument_list|)
return|;
block|}
operator|*
name|lock_p
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *LOCK_P to the lock for PATH in FS.  HAVE_WRITE_LOCK should be    TRUE if the caller (or one of its callers) has taken out the    repository-wide write lock, FALSE otherwise.  Use POOL for    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_lock_helper
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|fs
argument_list|,
name|path
argument_list|,
name|have_write_lock
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We've deliberately decided that this function doesn't tell the      caller *why* the lock is unavailable.  */
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_LOCK
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_LOCK_EXPIRED
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A function that calls GET_LOCKS_FUNC/GET_LOCKS_BATON for    all locks in and under PATH in FS.    HAVE_WRITE_LOCK should be true if the caller (directly or indirectly)    has the FS write lock. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|walk_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|digest_path
parameter_list|,
name|svn_fs_get_locks_callback_t
name|get_locks_func
parameter_list|,
name|void
modifier|*
name|get_locks_baton
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|children
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
comment|/* First, send up any locks in the current digest file. */
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
operator|&
name|children
argument_list|,
operator|&
name|lock
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|digest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|&&
name|lock_expired
argument_list|(
name|lock
argument_list|)
condition|)
block|{
comment|/* Only remove the lock if we have the write lock.          Read operations shouldn't change the filesystem. */
if|if
condition|(
name|have_write_lock
condition|)
name|SVN_ERR
argument_list|(
name|unlock_single
argument_list|(
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_locks_func
argument_list|(
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now, report all the child entries (if any; bail otherwise). */
if|if
condition|(
operator|!
name|apr_hash_count
argument_list|(
name|children
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|digest
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_digest_file
argument_list|(
name|NULL
argument_list|,
operator|&
name|lock
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|digest_path_from_digest
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|digest
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|&&
name|lock_expired
argument_list|(
name|lock
argument_list|)
condition|)
block|{
comment|/* Only remove the lock if we have the write lock.              Read operations shouldn't change the filesystem. */
if|if
condition|(
name|have_write_lock
condition|)
name|SVN_ERR
argument_list|(
name|unlock_single
argument_list|(
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|lock
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_locks_func
argument_list|(
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function:  verify that a lock can be used.  Interesting    errors returned from this function:        SVN_ERR_FS_NO_USER: No username attached to FS.       SVN_ERR_FS_LOCK_OWNER_MISMATCH: FS's username doesn't match LOCK's owner.       SVN_ERR_FS_BAD_LOCK_TOKEN: FS doesn't hold matching lock-token for LOCK.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|fs
operator|->
name|access_ctx
operator|)
operator|||
operator|(
operator|!
name|fs
operator|->
name|access_ctx
operator|->
name|username
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_USER
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot verify lock on path '%s'; no username available"
argument_list|)
argument_list|,
name|lock
operator|->
name|path
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_LOCK_OWNER_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"User '%s' does not own lock on path '%s' (currently locked by '%s')"
argument_list|)
argument_list|,
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|access_ctx
operator|->
name|lock_tokens
argument_list|,
name|lock
operator|->
name|token
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_BAD_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot verify lock on path '%s'; no matching lock-token available"
argument_list|)
argument_list|,
name|lock
operator|->
name|path
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the svn_fs_get_locks_callback_t interface, where    BATON is just an svn_fs_t object. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locks_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|verify_lock
argument_list|(
name|baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The main routine for lock enforcement, used throughout libsvn_fs_fs. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__allow_locked_operation
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|recurse
parameter_list|,
name|svn_boolean_t
name|have_write_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|recurse
condition|)
block|{
comment|/* Discover all locks at or below the path. */
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walk_locks
argument_list|(
name|fs
argument_list|,
name|digest_path
argument_list|,
name|get_locks_callback
argument_list|,
name|fs
argument_list|,
name|have_write_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Discover and verify any lock attached to the path. */
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_lock_helper
argument_list|(
name|fs
argument_list|,
operator|&
name|lock
argument_list|,
name|path
argument_list|,
name|have_write_lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|SVN_ERR
argument_list|(
name|verify_lock
argument_list|(
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function called from the lock and unlock code.    UPDATES is a map from "const char *" parent paths to "apr_array_header_t *"    arrays of child paths.  For all of the parent paths of PATH this function    adds PATH to the corresponding array of child paths. */
end_comment

begin_function
specifier|static
name|void
name|schedule_index_update
parameter_list|(
name|apr_hash_t
modifier|*
name|updates
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|hashpool
init|=
name|apr_hash_pool_get
argument_list|(
name|updates
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_path
init|=
name|path
decl_stmt|;
while|while
condition|(
operator|!
name|svn_fspath__is_root
argument_list|(
name|parent_path
argument_list|,
name|strlen
argument_list|(
name|parent_path
argument_list|)
argument_list|)
condition|)
block|{
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|parent_path
operator|=
name|svn_fspath__dirname
argument_list|(
name|parent_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|children
operator|=
name|svn_hash_gets
argument_list|(
name|updates
argument_list|,
name|parent_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|children
condition|)
block|{
name|children
operator|=
name|apr_array_make
argument_list|(
name|hashpool
argument_list|,
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|updates
argument_list|,
name|apr_pstrdup
argument_list|(
name|hashpool
argument_list|,
name|parent_path
argument_list|)
argument_list|,
name|children
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|children
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* The effective arguments for lock_body() below. */
end_comment

begin_struct
struct|struct
name|lock_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|apr_array_header_t
modifier|*
name|infos
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|svn_boolean_t
name|is_dav_comment
decl_stmt|;
name|apr_time_t
name|expiration_date
decl_stmt|;
name|svn_boolean_t
name|steal_lock
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lock
parameter_list|(
name|svn_error_t
modifier|*
modifier|*
name|fs_err
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_fs_lock_target_t
modifier|*
name|target
parameter_list|,
name|struct
name|lock_baton
modifier|*
name|lb
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_revnum_t
name|youngest_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_lock_t
modifier|*
name|existing_lock
decl_stmt|;
operator|*
name|fs_err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
operator|*
name|fs_err
operator|=
name|SVN_FS__ERR_NOT_FILE
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* While our locking implementation easily supports the locking of      nonexistent paths, we deliberately choose not to allow such madness. */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|target
operator|->
name|current_rev
argument_list|)
condition|)
operator|*
name|fs_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
else|else
operator|*
name|fs_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Is the caller attempting to lock an out-of-date working file? */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|target
operator|->
name|current_rev
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|created_rev
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|current_rev
operator|>
name|youngest_rev
condition|)
block|{
operator|*
name|fs_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|target
operator|->
name|current_rev
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_created_rev
argument_list|(
operator|&
name|created_rev
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SVN_INVALID_REVNUM means the path doesn't exist.  So          apparently somebody is trying to lock something in their          working copy, but somebody else has deleted the thing          from HEAD.  That counts as being 'out of date'. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|created_rev
argument_list|)
condition|)
block|{
operator|*
name|fs_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|target
operator|->
name|current_rev
operator|<
name|created_rev
condition|)
block|{
operator|*
name|fs_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Lock failed: newer version of '%s' exists"
argument_list|)
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* If the caller provided a TOKEN, we *really* need to see      if a lock already exists with that token, and if so, verify that      the lock's path matches PATH.  Otherwise we run the risk of      breaking the 1-to-1 mapping of lock tokens to locked paths. */
comment|/* ### TODO:  actually do this check.  This is tough, because the      schema doesn't supply a lookup-by-token mechanism. */
comment|/* Is the path already locked?       Note that this next function call will automatically ignore any      errors about {the path not existing as a key, the path's token      not existing as a key, the lock just having been expired}.  And      that's totally fine.  Any of these three errors are perfectly      acceptable to ignore; it means that the path is now free and      clear for locking, because the fsfs funcs just cleared out both      of the tables for us.   */
name|SVN_ERR
argument_list|(
name|get_lock_helper
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
operator|&
name|existing_lock
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|existing_lock
condition|)
block|{
if|if
condition|(
operator|!
name|lb
operator|->
name|steal_lock
condition|)
block|{
comment|/* Sorry, the path is already locked. */
operator|*
name|fs_err
operator|=
name|SVN_FS__ERR_PATH_ALREADY_LOCKED
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
name|existing_lock
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|lock_info_t
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_error_t
modifier|*
name|fs_err
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The body of svn_fs_fs__lock(), which see.     BATON is a 'struct lock_baton *' holding the effective arguments.    BATON->targets is an array of 'svn_sort__item_t' targets, sorted by    path, mapping canonical path to 'svn_fs_lock_target_t'.  Set    BATON->infos to an array of 'lock_info_t' holding the results.  For    the other arguments, see svn_fs_lock_many().     This implements the svn_fs_fs__with_write_lock() 'body' callback    type, and assumes that the write lock is held.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lock_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|lock_baton
modifier|*
name|lb
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_0_path
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_hash_t
modifier|*
name|index_updates
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Until we implement directory locks someday, we only allow locks      on files or non-existent paths. */
comment|/* Use fs->vtable->foo instead of svn_fs_foo to avoid circular      library dependencies, which are not portable. */
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|fs
operator|->
name|vtable
operator|->
name|youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|lb
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lb
operator|->
name|fs
operator|->
name|vtable
operator|->
name|revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|lb
operator|->
name|fs
argument_list|,
name|youngest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lb
operator|->
name|targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_sort__item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|lb
operator|->
name|targets
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
name|struct
name|lock_info_t
name|info
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|info
operator|.
name|path
operator|=
name|item
operator|->
name|key
expr_stmt|;
name|info
operator|.
name|lock
operator|=
name|NULL
expr_stmt|;
name|info
operator|.
name|fs_err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_lock
argument_list|(
operator|&
name|info
operator|.
name|fs_err
argument_list|,
name|info
operator|.
name|path
argument_list|,
name|item
operator|->
name|value
argument_list|,
name|lb
argument_list|,
name|root
argument_list|,
name|youngest
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If no error occurred while pre-checking, schedule the index updates for          this path. */
if|if
condition|(
operator|!
name|info
operator|.
name|fs_err
condition|)
name|schedule_index_update
argument_list|(
name|index_updates
argument_list|,
name|info
operator|.
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|lb
operator|->
name|infos
argument_list|,
expr|struct
name|lock_info_t
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
name|rev_0_path
operator|=
name|svn_fs_fs__path_rev_absolute
argument_list|(
name|lb
operator|->
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We apply the scheduled index updates before writing the actual locks.       Writing indices before locks is correct: if interrupted it leaves      indices without locks rather than locks without indices.  An      index without a lock is consistent in that it always shows up as      unlocked in svn_fs_fs__allow_locked_operation.  A lock without an      index is inconsistent, svn_fs_fs__allow_locked_operation will      show locked on the file but unlocked on the parent. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|index_updates
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|children
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_to_digest
argument_list|(
name|lb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|children
argument_list|,
name|path
argument_list|,
name|rev_0_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lb
operator|->
name|infos
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|lock_info_t
modifier|*
name|info
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|lb
operator|->
name|infos
argument_list|,
name|i
argument_list|,
expr|struct
name|lock_info_t
argument_list|)
decl_stmt|;
name|svn_sort__item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|lb
operator|->
name|targets
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
name|svn_fs_lock_target_t
modifier|*
name|target
init|=
name|item
operator|->
name|value
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|fs_err
condition|)
block|{
name|info
operator|->
name|lock
operator|=
name|svn_lock_create
argument_list|(
name|lb
operator|->
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|token
condition|)
name|info
operator|->
name|lock
operator|->
name|token
operator|=
name|apr_pstrdup
argument_list|(
name|lb
operator|->
name|result_pool
argument_list|,
name|target
operator|->
name|token
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_fs__generate_lock_token
argument_list|(
operator|&
operator|(
name|info
operator|->
name|lock
operator|->
name|token
operator|)
argument_list|,
name|lb
operator|->
name|fs
argument_list|,
name|lb
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The INFO->PATH is already allocated in LB->RESULT_POOL as a result              of svn_fspath__canonicalize() (see svn_fs_fs__lock()). */
name|info
operator|->
name|lock
operator|->
name|path
operator|=
name|info
operator|->
name|path
expr_stmt|;
name|info
operator|->
name|lock
operator|->
name|owner
operator|=
name|apr_pstrdup
argument_list|(
name|lb
operator|->
name|result_pool
argument_list|,
name|lb
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|)
expr_stmt|;
name|info
operator|->
name|lock
operator|->
name|comment
operator|=
name|apr_pstrdup
argument_list|(
name|lb
operator|->
name|result_pool
argument_list|,
name|lb
operator|->
name|comment
argument_list|)
expr_stmt|;
name|info
operator|->
name|lock
operator|->
name|is_dav_comment
operator|=
name|lb
operator|->
name|is_dav_comment
expr_stmt|;
name|info
operator|->
name|lock
operator|->
name|creation_date
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
name|info
operator|->
name|lock
operator|->
name|expiration_date
operator|=
name|lb
operator|->
name|expiration_date
expr_stmt|;
name|info
operator|->
name|fs_err
operator|=
name|set_lock
argument_list|(
name|lb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|info
operator|->
name|lock
argument_list|,
name|rev_0_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The effective arguments for unlock_body() below. */
end_comment

begin_struct
struct|struct
name|unlock_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|apr_array_header_t
modifier|*
name|infos
decl_stmt|;
comment|/* Set skip_check TRUE to prevent the checks that set infos[].fs_err. */
name|svn_boolean_t
name|skip_check
decl_stmt|;
name|svn_boolean_t
name|break_lock
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_unlock
parameter_list|(
name|svn_error_t
modifier|*
modifier|*
name|fs_err
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|struct
name|unlock_baton
modifier|*
name|ub
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
operator|*
name|fs_err
operator|=
name|get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|ub
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|fs_err
operator|&&
operator|!
name|ub
operator|->
name|break_lock
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|token
argument_list|,
name|lock
operator|->
name|token
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|fs_err
operator|=
name|SVN_FS__ERR_NO_SUCH_LOCK
argument_list|(
name|ub
operator|->
name|fs
argument_list|,
name|path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|ub
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
operator|*
name|fs_err
operator|=
name|SVN_FS__ERR_LOCK_OWNER_MISMATCH
argument_list|(
name|ub
operator|->
name|fs
argument_list|,
name|ub
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|unlock_info_t
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_error_t
modifier|*
name|fs_err
decl_stmt|;
name|svn_boolean_t
name|done
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The body of svn_fs_fs__unlock(), which see.     BATON is a 'struct unlock_baton *' holding the effective arguments.    BATON->targets is an array of 'svn_sort__item_t' targets, sorted by    path, mapping canonical path to (const char *) token.  Set    BATON->infos to an array of 'unlock_info_t' results.  For the other    arguments, see svn_fs_unlock_many().     This implements the svn_fs_fs__with_write_lock() 'body' callback    type, and assumes that the write lock is held.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_baton
modifier|*
name|ub
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_0_path
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_hash_t
modifier|*
name|indices_updates
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ub
operator|->
name|fs
operator|->
name|vtable
operator|->
name|youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|ub
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ub
operator|->
name|fs
operator|->
name|vtable
operator|->
name|revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|ub
operator|->
name|fs
argument_list|,
name|youngest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ub
operator|->
name|targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_sort__item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|ub
operator|->
name|targets
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|item
operator|->
name|value
decl_stmt|;
name|struct
name|unlock_info_t
name|info
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|info
operator|.
name|path
operator|=
name|item
operator|->
name|key
expr_stmt|;
name|info
operator|.
name|fs_err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|info
operator|.
name|done
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|ub
operator|->
name|skip_check
condition|)
name|SVN_ERR
argument_list|(
name|check_unlock
argument_list|(
operator|&
name|info
operator|.
name|fs_err
argument_list|,
name|info
operator|.
name|path
argument_list|,
name|token
argument_list|,
name|ub
argument_list|,
name|root
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If no error occurred while pre-checking, schedule the index updates for          this path. */
if|if
condition|(
operator|!
name|info
operator|.
name|fs_err
condition|)
name|schedule_index_update
argument_list|(
name|indices_updates
argument_list|,
name|info
operator|.
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|ub
operator|->
name|infos
argument_list|,
expr|struct
name|unlock_info_t
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
name|rev_0_path
operator|=
name|svn_fs_fs__path_rev_absolute
argument_list|(
name|ub
operator|->
name|fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Unlike the lock_body(), we need to delete locks *before* we start to      update indices. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ub
operator|->
name|infos
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|unlock_info_t
modifier|*
name|info
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|ub
operator|->
name|infos
argument_list|,
name|i
argument_list|,
expr|struct
name|unlock_info_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|info
operator|->
name|fs_err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|delete_lock
argument_list|(
name|ub
operator|->
name|fs
operator|->
name|path
argument_list|,
name|info
operator|->
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|indices_updates
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|children
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delete_from_digest
argument_list|(
name|ub
operator|->
name|fs
operator|->
name|path
argument_list|,
name|children
argument_list|,
name|path
argument_list|,
name|rev_0_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Unlock the lock described by LOCK->path and LOCK->token in FS.     This assumes that the write lock is held.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|unlock_single
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_baton
name|ub
decl_stmt|;
name|svn_sort__item_t
name|item
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_sort__item_t
argument_list|)
argument_list|)
decl_stmt|;
name|item
operator|.
name|key
operator|=
name|lock
operator|->
name|path
expr_stmt|;
name|item
operator|.
name|klen
operator|=
name|strlen
argument_list|(
name|item
operator|.
name|key
argument_list|)
expr_stmt|;
name|item
operator|.
name|value
operator|=
operator|(
name|char
operator|*
operator|)
name|lock
operator|->
name|token
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|targets
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|=
name|item
expr_stmt|;
name|ub
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|ub
operator|.
name|targets
operator|=
name|targets
expr_stmt|;
name|ub
operator|.
name|infos
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unlock_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|ub
operator|.
name|skip_check
operator|=
name|TRUE
expr_stmt|;
name|ub
operator|.
name|result_pool
operator|=
name|pool
expr_stmt|;
comment|/* No ub.infos[].fs_err error because skip_check is TRUE. */
name|SVN_ERR
argument_list|(
name|unlock_body
argument_list|(
operator|&
name|ub
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public API implementations ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|targets
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|is_dav_comment
parameter_list|,
name|apr_time_t
name|expiration_date
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|svn_fs_lock_callback_t
name|lock_callback
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|lock_baton
name|lb
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_targets
decl_stmt|;
name|apr_hash_t
modifier|*
name|canonical_targets
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|cb_err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to have a username attached to the fs. */
if|if
condition|(
operator|!
name|fs
operator|->
name|access_ctx
operator|||
operator|!
name|fs
operator|->
name|access_ctx
operator|->
name|username
condition|)
return|return
name|SVN_FS__ERR_NO_USER
argument_list|(
name|fs
argument_list|)
return|;
comment|/* The FS locking API allows both canonical and non-canonical      paths which means that the same canonical path could be      represented more than once in the TARGETS hash.  We just keep      one, choosing one with a token if possible. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|targets
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_lock_target_t
modifier|*
name|target
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_fs_lock_target_t
modifier|*
name|other
decl_stmt|;
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|other
operator|=
name|svn_hash_gets
argument_list|(
name|canonical_targets
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|other
operator|||
operator|(
operator|!
name|other
operator|->
name|token
operator|&&
name|target
operator|->
name|token
operator|)
condition|)
name|svn_hash_sets
argument_list|(
name|canonical_targets
argument_list|,
name|path
argument_list|,
name|target
argument_list|)
expr_stmt|;
block|}
name|sorted_targets
operator|=
name|svn_sort__hash
argument_list|(
name|canonical_targets
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|lb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|lb
operator|.
name|targets
operator|=
name|sorted_targets
expr_stmt|;
name|lb
operator|.
name|infos
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|sorted_targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|lock_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|lb
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
name|lb
operator|.
name|is_dav_comment
operator|=
name|is_dav_comment
expr_stmt|;
name|lb
operator|.
name|expiration_date
operator|=
name|expiration_date
expr_stmt|;
name|lb
operator|.
name|steal_lock
operator|=
name|steal_lock
expr_stmt|;
name|lb
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|lock_body
argument_list|,
operator|&
name|lb
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lb
operator|.
name|infos
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|lock_info_t
modifier|*
name|info
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|lb
operator|.
name|infos
argument_list|,
name|i
argument_list|,
expr|struct
name|lock_info_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb_err
operator|&&
name|lock_callback
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|lock
operator|&&
operator|!
name|info
operator|->
name|fs_err
condition|)
name|info
operator|->
name|fs_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_LOCK_OPERATION_FAILED
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Failed to lock '%s'"
argument_list|)
argument_list|,
name|info
operator|->
name|path
argument_list|)
expr_stmt|;
name|cb_err
operator|=
name|lock_callback
argument_list|(
name|lock_baton
argument_list|,
name|info
operator|->
name|path
argument_list|,
name|info
operator|->
name|lock
argument_list|,
name|info
operator|->
name|fs_err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|info
operator|->
name|fs_err
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|cb_err
condition|)
name|svn_error_compose
argument_list|(
name|err
argument_list|,
name|cb_err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|cb_err
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__generate_lock_token
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|token
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Notice that 'fs' is currently unused.  But perhaps someday, we'll      want to use the fs UUID + some incremented number?  For now, we      generate a URI that matches the DAV RFC.  We could change this to      some other URI scheme someday, if we wish. */
operator|*
name|token
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"opaquelocktoken:"
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__unlock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|targets
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|svn_fs_lock_callback_t
name|lock_callback
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|unlock_baton
name|ub
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_targets
decl_stmt|;
name|apr_hash_t
modifier|*
name|canonical_targets
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|cb_err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to have a username attached to the fs. */
if|if
condition|(
operator|!
name|fs
operator|->
name|access_ctx
operator|||
operator|!
name|fs
operator|->
name|access_ctx
operator|->
name|username
condition|)
return|return
name|SVN_FS__ERR_NO_USER
argument_list|(
name|fs
argument_list|)
return|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|targets
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|other
decl_stmt|;
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|other
operator|=
name|svn_hash_gets
argument_list|(
name|canonical_targets
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|other
condition|)
name|svn_hash_sets
argument_list|(
name|canonical_targets
argument_list|,
name|path
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
name|sorted_targets
operator|=
name|svn_sort__hash
argument_list|(
name|canonical_targets
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|ub
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|ub
operator|.
name|targets
operator|=
name|sorted_targets
expr_stmt|;
name|ub
operator|.
name|infos
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|sorted_targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|unlock_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|ub
operator|.
name|skip_check
operator|=
name|FALSE
expr_stmt|;
name|ub
operator|.
name|break_lock
operator|=
name|break_lock
expr_stmt|;
name|ub
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_fs__with_write_lock
argument_list|(
name|fs
argument_list|,
name|unlock_body
argument_list|,
operator|&
name|ub
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ub
operator|.
name|infos
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|unlock_info_t
modifier|*
name|info
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|ub
operator|.
name|infos
argument_list|,
name|i
argument_list|,
expr|struct
name|unlock_info_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cb_err
operator|&&
name|lock_callback
condition|)
block|{
if|if
condition|(
operator|!
name|info
operator|->
name|done
operator|&&
operator|!
name|info
operator|->
name|fs_err
condition|)
name|info
operator|->
name|fs_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_LOCK_OPERATION_FAILED
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Failed to unlock '%s'"
argument_list|)
argument_list|,
name|info
operator|->
name|path
argument_list|)
expr_stmt|;
name|cb_err
operator|=
name|lock_callback
argument_list|(
name|lock_baton
argument_list|,
name|info
operator|->
name|path
argument_list|,
name|NULL
argument_list|,
name|info
operator|->
name|fs_err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|info
operator|->
name|fs_err
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|cb_err
condition|)
name|svn_error_compose
argument_list|(
name|err
argument_list|,
name|cb_err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|cb_err
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|get_lock_helper
argument_list|(
name|fs
argument_list|,
name|lock_p
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for get_locks_filter_func(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|get_locks_filter_baton_t
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_depth_t
name|requested_depth
decl_stmt|;
name|svn_fs_get_locks_callback_t
name|get_locks_func
decl_stmt|;
name|void
modifier|*
name|get_locks_baton
decl_stmt|;
block|}
name|get_locks_filter_baton_t
typedef|;
end_typedef

begin_comment
comment|/* A wrapper for the GET_LOCKS_FUNC passed to svn_fs_fs__get_locks()    which filters out locks on paths that aren't within    BATON->requested_depth of BATON->path before called    BATON->get_locks_func() with BATON->get_locks_baton.     NOTE: See issue #3660 for details about how the FSFS lock    management code is inconsistent.  Until that inconsistency is    resolved, we take this filtering approach rather than honoring    depth requests closer to the crawling code.  In other words, once    we decide how to resolve issue #3660, there might be a more    performant way to honor the depth passed to svn_fs_fs__get_locks().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locks_filter_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|get_locks_filter_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* Filter out unwanted paths.  Since Subversion only allows      locks on files, we can treat depth=immediates the same as      depth=files for filtering purposes.  Meaning, we'll keep      this lock if:       a) its path is the very path we queried, or      b) we've asked for a fully recursive answer, or      c) we've asked for depth=files or depth=immediates, and this         lock is on an immediate child of our query path.   */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|b
operator|->
name|path
argument_list|,
name|lock
operator|->
name|path
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|b
operator|->
name|requested_depth
operator|==
name|svn_depth_infinity
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|b
operator|->
name|get_locks_func
argument_list|(
name|b
operator|->
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|b
operator|->
name|requested_depth
operator|==
name|svn_depth_files
operator|)
operator|||
operator|(
name|b
operator|->
name|requested_depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|rel_uri
init|=
name|svn_fspath__skip_ancestor
argument_list|(
name|b
operator|->
name|path
argument_list|,
name|lock
operator|->
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|rel_uri
operator|&&
operator|(
name|svn_path_component_count
argument_list|(
name|rel_uri
argument_list|)
operator|==
literal|1
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|get_locks_func
argument_list|(
name|b
operator|->
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_fs_get_locks_callback_t
name|get_locks_func
parameter_list|,
name|void
modifier|*
name|get_locks_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_path
decl_stmt|;
name|get_locks_filter_baton_t
name|glfb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|glfb
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|glfb
operator|.
name|requested_depth
operator|=
name|depth
expr_stmt|;
name|glfb
operator|.
name|get_locks_func
operator|=
name|get_locks_func
expr_stmt|;
name|glfb
operator|.
name|get_locks_baton
operator|=
name|get_locks_baton
expr_stmt|;
comment|/* Get the top digest path in our tree of interest, and then walk it. */
name|SVN_ERR
argument_list|(
name|digest_path_from_path
argument_list|(
operator|&
name|digest_path
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|walk_locks
argument_list|(
name|fs
argument_list|,
name|digest_path
argument_list|,
name|get_locks_filter_func
argument_list|,
operator|&
name|glfb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

