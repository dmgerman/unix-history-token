begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* index.c indexing support for FSFS support  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_comment
comment|/* maximum length of a uint64 in an 7/8b encoding */
end_comment

begin_define
define|#
directive|define
name|ENCODED_INT_LENGTH
value|10
end_define

begin_comment
comment|/* APR is missing an APR_OFF_T_MAX.  So, define one.  We will use it to  * limit file offsets stored in the indexes.  *  * We assume that everything shorter than 64 bits, it is at least 32 bits.  * We also assume that the type is always signed meaning we only have an  * effective positive range of 63 or 31 bits, respectively.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|apr_uint64_t
name|off_t_max
init|=
operator|(
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|apr_int64_t
argument_list|)
operator|)
condition|?
name|APR_INT64_MAX
else|:
name|APR_INT32_MAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* We store P2L proto-index entries as 6 values, 64 bits each on disk.  * See also svn_fs_fs__p2l_proto_index_add_entry().  */
end_comment

begin_define
define|#
directive|define
name|P2L_PROTO_INDEX_ENTRY_SIZE
value|(6 * sizeof(apr_uint64_t))
end_define

begin_comment
comment|/* We put this string in front of the L2P index header. */
end_comment

begin_define
define|#
directive|define
name|L2P_STREAM_PREFIX
value|"L2P-INDEX\n"
end_define

begin_comment
comment|/* We put this string in front of the P2L index header. */
end_comment

begin_define
define|#
directive|define
name|P2L_STREAM_PREFIX
value|"P2L-INDEX\n"
end_define

begin_comment
comment|/* Size of the buffer that will fit the index header prefixes. */
end_comment

begin_define
define|#
directive|define
name|STREAM_PREFIX_LEN
value|MAX(sizeof(L2P_STREAM_PREFIX), \                               sizeof(P2L_STREAM_PREFIX))
end_define

begin_comment
comment|/* Page tables in the log-to-phys index file exclusively contain entries  * of this type to describe position and size of a given page.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2p_page_table_entry_t
block|{
comment|/* global offset on the page within the index file */
name|apr_uint64_t
name|offset
decl_stmt|;
comment|/* number of mapping entries in that page */
name|apr_uint32_t
name|entry_count
decl_stmt|;
comment|/* size of the page on disk (in the index file) */
name|apr_uint32_t
name|size
decl_stmt|;
block|}
name|l2p_page_table_entry_t
typedef|;
end_typedef

begin_comment
comment|/* Master run-time data structure of an log-to-phys index.  It contains  * the page tables of every revision covered by that index - but not the  * pages themselves.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2p_header_t
block|{
comment|/* first revision covered by this index */
name|svn_revnum_t
name|first_revision
decl_stmt|;
comment|/* number of revisions covered */
name|apr_size_t
name|revision_count
decl_stmt|;
comment|/* (max) number of entries per page */
name|apr_uint32_t
name|page_size
decl_stmt|;
comment|/* indexes into PAGE_TABLE that mark the first page of the respective    * revision.  PAGE_TABLE_INDEX[REVISION_COUNT] points to the end of    * PAGE_TABLE.    */
name|apr_size_t
modifier|*
name|page_table_index
decl_stmt|;
comment|/* Page table covering all pages in the index */
name|l2p_page_table_entry_t
modifier|*
name|page_table
decl_stmt|;
block|}
name|l2p_header_t
typedef|;
end_typedef

begin_comment
comment|/* Run-time data structure containing a single log-to-phys index page.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2p_page_t
block|{
comment|/* number of entries in the OFFSETS array */
name|apr_uint32_t
name|entry_count
decl_stmt|;
comment|/* global file offsets (item index is the array index) within the    * packed or non-packed rev file.  Offset will be -1 for unused /    * invalid item index values. */
name|apr_uint64_t
modifier|*
name|offsets
decl_stmt|;
block|}
name|l2p_page_t
typedef|;
end_typedef

begin_comment
comment|/* All of the log-to-phys proto index file consist of entries of this type.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2p_proto_entry_t
block|{
comment|/* phys offset + 1 of the data container. 0 for "new revision" entries. */
name|apr_uint64_t
name|offset
decl_stmt|;
comment|/* corresponding item index. 0 for "new revision" entries. */
name|apr_uint64_t
name|item_index
decl_stmt|;
block|}
name|l2p_proto_entry_t
typedef|;
end_typedef

begin_comment
comment|/* Master run-time data structure of an phys-to-log index.  It contains  * an array with one offset value for each rev file cluster.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|p2l_header_t
block|{
comment|/* first revision covered by the index (and rev file) */
name|svn_revnum_t
name|first_revision
decl_stmt|;
comment|/* number of bytes in the rev files covered by each p2l page */
name|apr_uint64_t
name|page_size
decl_stmt|;
comment|/* number of pages / clusters in that rev file */
name|apr_size_t
name|page_count
decl_stmt|;
comment|/* number of bytes in the rev file */
name|apr_uint64_t
name|file_size
decl_stmt|;
comment|/* offsets of the pages / cluster descriptions within the index file */
name|apr_off_t
modifier|*
name|offsets
decl_stmt|;
block|}
name|p2l_header_t
typedef|;
end_typedef

begin_comment
comment|/*  * packed stream  *  * This is a utility object that will read files containing 7b/8b encoded  * unsigned integers.  It decodes them in batches to minimize overhead  * and supports random access to random file locations.  */
end_comment

begin_comment
comment|/* How many numbers we will pre-fetch and buffer in a packed number stream.  */
end_comment

begin_enum
enum|enum
block|{
name|MAX_NUMBER_PREFETCH
init|=
literal|64
block|}
enum|;
end_enum

begin_comment
comment|/* Prefetched number entry in a packed number stream.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|value_position_pair_t
block|{
comment|/* prefetched number */
name|apr_uint64_t
name|value
decl_stmt|;
comment|/* number of bytes read, *including* this number, since the buffer start */
name|apr_size_t
name|total_len
decl_stmt|;
block|}
name|value_position_pair_t
typedef|;
end_typedef

begin_comment
comment|/* State of a prefetching packed number stream.  It will read compressed  * index data efficiently and present it as a series of non-packed uint64.  */
end_comment

begin_struct
struct|struct
name|svn_fs_fs__packed_number_stream_t
block|{
comment|/* underlying data file containing the packed values */
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* Offset within FILE at which the stream data starts    * (i.e. which offset will reported as offset 0 by packed_stream_offset). */
name|apr_off_t
name|stream_start
decl_stmt|;
comment|/* First offset within FILE after the stream data.    * Attempts to read beyond this will cause an "Unexpected End Of Stream"    * error. */
name|apr_off_t
name|stream_end
decl_stmt|;
comment|/* number of used entries in BUFFER (starting at index 0) */
name|apr_size_t
name|used
decl_stmt|;
comment|/* index of the next number to read from the BUFFER (0 .. USED).    * If CURRENT == USED, we need to read more data upon get() */
name|apr_size_t
name|current
decl_stmt|;
comment|/* offset in FILE from which the first entry in BUFFER has been read */
name|apr_off_t
name|start_offset
decl_stmt|;
comment|/* offset in FILE from which the next number has to be read */
name|apr_off_t
name|next_offset
decl_stmt|;
comment|/* read the file in chunks of this size */
name|apr_size_t
name|block_size
decl_stmt|;
comment|/* pool to be used for file ops etc. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* buffer for prefetched values */
name|value_position_pair_t
name|buffer
index|[
name|MAX_NUMBER_PREFETCH
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return an svn_error_t * object for error ERR on STREAM with the given  * MESSAGE string.  The latter must have a placeholder for the index file  * name ("%s") and the current read offset (e.g. "0x%lx").  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_error_create
parameter_list|(
name|svn_fs_fs__packed_number_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_status_t
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|file_name
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|file_name
argument_list|,
name|stream
operator|->
name|file
argument_list|,
name|stream
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|stream
operator|->
name|file
argument_list|,
name|stream
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
name|message
argument_list|,
name|file_name
argument_list|,
name|apr_psprintf
argument_list|(
name|stream
operator|->
name|pool
argument_list|,
literal|"%"
name|APR_UINT64_T_HEX_FMT
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read up to MAX_NUMBER_PREFETCH numbers from the STREAM->NEXT_OFFSET in  * STREAM->FILE and buffer them.  *  * We don't want GCC and others to inline this (infrequently called)  * function into packed_stream_get() because it prevents the latter from  * being inlined itself.  */
end_comment

begin_function
name|SVN__PREVENT_INLINE
specifier|static
name|svn_error_t
modifier|*
name|packed_stream_read
parameter_list|(
name|svn_fs_fs__packed_number_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
name|MAX_NUMBER_PREFETCH
index|]
decl_stmt|;
name|apr_size_t
name|read
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|value_position_pair_t
modifier|*
name|target
decl_stmt|;
name|apr_off_t
name|block_start
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|block_left
init|=
literal|0
decl_stmt|;
name|apr_status_t
name|err
decl_stmt|;
comment|/* all buffered data will have been read starting here */
name|stream
operator|->
name|start_offset
operator|=
name|stream
operator|->
name|next_offset
expr_stmt|;
comment|/* packed numbers are usually not aligned to MAX_NUMBER_PREFETCH blocks,    * i.e. the last number has been incomplete (and not buffered in stream)    * and need to be re-read.  Therefore, always correct the file pointer.    */
name|SVN_ERR
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|stream
operator|->
name|file
argument_list|,
name|stream
operator|->
name|block_size
argument_list|,
operator|&
name|block_start
argument_list|,
name|stream
operator|->
name|next_offset
argument_list|,
name|stream
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prefetch at least one number but, if feasible, don't cross block    * boundaries.  This shall prevent jumping back and forth between two    * blocks because the extra data was not actually request _now_.    */
name|read
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|block_left
operator|=
name|stream
operator|->
name|block_size
operator|-
operator|(
name|stream
operator|->
name|next_offset
operator|-
name|block_start
operator|)
expr_stmt|;
if|if
condition|(
name|block_left
operator|>=
literal|10
operator|&&
name|block_left
operator|<
name|read
condition|)
name|read
operator|=
operator|(
name|apr_size_t
operator|)
name|block_left
expr_stmt|;
comment|/* Don't read beyond the end of the file section that belongs to this    * index / stream. */
name|read
operator|=
operator|(
name|apr_size_t
operator|)
name|MIN
argument_list|(
name|read
argument_list|,
name|stream
operator|->
name|stream_end
operator|-
name|stream
operator|->
name|next_offset
argument_list|)
expr_stmt|;
name|err
operator|=
name|apr_file_read
argument_list|(
name|stream
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
operator|&
name|read
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|APR_STATUS_IS_EOF
argument_list|(
name|err
argument_list|)
condition|)
return|return
name|stream_error_create
argument_list|(
name|stream
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Can't read index file '%s' at offset 0x%s"
argument_list|)
argument_list|)
return|;
comment|/* if the last number is incomplete, trim it from the buffer */
while|while
condition|(
name|read
operator|>
literal|0
operator|&&
name|buffer
index|[
name|read
operator|-
literal|1
index|]
operator|>=
literal|0x80
condition|)
operator|--
name|read
expr_stmt|;
comment|/* we call read() only if get() requires more data.  So, there must be    * at least *one* further number. */
if|if SVN__PREDICT_FALSE
condition|(
name|read
operator|==
literal|0
condition|)
return|return
name|stream_error_create
argument_list|(
name|stream
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of index file %s at offset 0x%s"
argument_list|)
argument_list|)
return|;
comment|/* parse file buffer and expand into stream buffer */
name|target
operator|=
name|stream
operator|->
name|buffer
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|read
condition|;
control|)
block|{
if|if
condition|(
name|buffer
index|[
name|i
index|]
operator|<
literal|0x80
condition|)
block|{
comment|/* numbers< 128 are relatively frequent and particularly easy            * to decode.  Give them special treatment. */
name|target
operator|->
name|value
operator|=
name|buffer
index|[
name|i
index|]
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|target
operator|->
name|total_len
operator|=
name|i
expr_stmt|;
operator|++
name|target
expr_stmt|;
block|}
else|else
block|{
name|apr_uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|buffer
index|[
name|i
index|]
operator|>=
literal|0x80
condition|)
block|{
name|value
operator|+=
operator|(
operator|(
name|apr_uint64_t
operator|)
name|buffer
index|[
name|i
index|]
operator|&
literal|0x7f
operator|)
operator|<<
name|shift
expr_stmt|;
name|shift
operator|+=
literal|7
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
name|target
operator|->
name|value
operator|=
name|value
operator|+
operator|(
operator|(
name|apr_uint64_t
operator|)
name|buffer
index|[
name|i
index|]
operator|<<
name|shift
operator|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|target
operator|->
name|total_len
operator|=
name|i
expr_stmt|;
operator|++
name|target
expr_stmt|;
comment|/* let's catch corrupted data early.  It would surely cause            * havoc further down the line. */
if|if SVN__PREDICT_FALSE
condition|(
name|shift
operator|>
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Corrupt index: number too large"
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* update stream state */
name|stream
operator|->
name|used
operator|=
name|target
operator|-
name|stream
operator|->
name|buffer
expr_stmt|;
name|stream
operator|->
name|next_offset
operator|=
name|stream
operator|->
name|start_offset
operator|+
name|i
expr_stmt|;
name|stream
operator|->
name|current
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create and open a packed number stream reading from offsets START to  * END in FILE and return it in *STREAM.  Access the file in chunks of  * BLOCK_SIZE bytes.  Expect the stream to be prefixed by STREAM_PREFIX.  * Allocate *STREAM in RESULT_POOL and use SCRATCH_POOL for temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|packed_stream_open
parameter_list|(
name|svn_fs_fs__packed_number_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_off_t
name|start
parameter_list|,
name|apr_off_t
name|end
parameter_list|,
specifier|const
name|char
modifier|*
name|stream_prefix
parameter_list|,
name|apr_size_t
name|block_size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|char
name|buffer
index|[
name|STREAM_PREFIX_LEN
operator|+
literal|1
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|stream_prefix
argument_list|)
decl_stmt|;
name|svn_fs_fs__packed_number_stream_t
modifier|*
name|result
decl_stmt|;
comment|/* If this is violated, we forgot to adjust STREAM_PREFIX_LEN after    * changing the index header prefixes. */
name|SVN_ERR_ASSERT
argument_list|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the header prefix and compare it with the expected prefix */
name|SVN_ERR
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|file
argument_list|,
name|block_size
argument_list|,
name|NULL
argument_list|,
name|start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|buffer
argument_list|,
name|stream_prefix
argument_list|,
name|len
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Index stream header prefix mismatch.\n"
literal|"  expected: %s"
literal|"  found: %s"
argument_list|)
argument_list|,
name|stream_prefix
argument_list|,
name|buffer
argument_list|)
return|;
comment|/* Construct the actual stream object. */
name|result
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|result
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|result
operator|->
name|stream_start
operator|=
name|start
operator|+
name|len
expr_stmt|;
name|result
operator|->
name|stream_end
operator|=
name|end
expr_stmt|;
name|result
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|start_offset
operator|=
name|result
operator|->
name|stream_start
expr_stmt|;
name|result
operator|->
name|next_offset
operator|=
name|result
operator|->
name|stream_start
expr_stmt|;
name|result
operator|->
name|block_size
operator|=
name|block_size
expr_stmt|;
operator|*
name|stream
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * The forced inline is required for performance reasons:  This is a very  * hot code path (called for every item we read) but e.g. GCC would rather  * chose to inline packed_stream_read() here, preventing packed_stream_get  * from being inlined itself.  */
end_comment

begin_function
name|SVN__FORCE_INLINE
specifier|static
name|svn_error_t
modifier|*
name|packed_stream_get
parameter_list|(
name|apr_uint64_t
modifier|*
name|value
parameter_list|,
name|svn_fs_fs__packed_number_stream_t
modifier|*
name|stream
parameter_list|)
block|{
if|if
condition|(
name|stream
operator|->
name|current
operator|==
name|stream
operator|->
name|used
condition|)
name|SVN_ERR
argument_list|(
name|packed_stream_read
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value
operator|=
name|stream
operator|->
name|buffer
index|[
name|stream
operator|->
name|current
index|]
operator|.
name|value
expr_stmt|;
operator|++
name|stream
operator|->
name|current
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Navigate STREAM to packed stream offset OFFSET.  There will be no checks  * whether the given OFFSET is valid.  */
end_comment

begin_function
specifier|static
name|void
name|packed_stream_seek
parameter_list|(
name|svn_fs_fs__packed_number_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_off_t
name|offset
parameter_list|)
block|{
name|apr_off_t
name|file_offset
init|=
name|offset
operator|+
name|stream
operator|->
name|stream_start
decl_stmt|;
if|if
condition|(
name|stream
operator|->
name|used
operator|==
literal|0
operator|||
name|offset
operator|<
name|stream
operator|->
name|start_offset
operator|||
name|offset
operator|>=
name|stream
operator|->
name|next_offset
condition|)
block|{
comment|/* outside buffered data.  Next get() will read() from OFFSET. */
name|stream
operator|->
name|start_offset
operator|=
name|file_offset
expr_stmt|;
name|stream
operator|->
name|next_offset
operator|=
name|file_offset
expr_stmt|;
name|stream
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|stream
operator|->
name|used
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Find the suitable location in the stream buffer.        * Since our buffer is small, it is efficient enough to simply scan        * it for the desired position. */
name|apr_size_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|stream
operator|->
name|used
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|stream
operator|->
name|buffer
index|[
name|i
index|]
operator|.
name|total_len
operator|>
name|file_offset
operator|-
name|stream
operator|->
name|start_offset
condition|)
break|break;
name|stream
operator|->
name|current
operator|=
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Return the packed stream offset of at which the next number in the stream  * can be found.  */
end_comment

begin_function
specifier|static
name|apr_off_t
name|packed_stream_offset
parameter_list|(
name|svn_fs_fs__packed_number_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|apr_off_t
name|file_offset
init|=
name|stream
operator|->
name|current
operator|==
literal|0
condition|?
name|stream
operator|->
name|start_offset
else|:
name|stream
operator|->
name|buffer
index|[
name|stream
operator|->
name|current
operator|-
literal|1
index|]
operator|.
name|total_len
operator|+
name|stream
operator|->
name|start_offset
decl_stmt|;
return|return
name|file_offset
operator|-
name|stream
operator|->
name|stream_start
return|;
block|}
end_function

begin_comment
comment|/* Encode VALUE as 7/8b into P and return the number of bytes written.  * This will be used when _writing_ packed data.  packed_stream_* is for  * read operations only.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|encode_uint
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|apr_uint64_t
name|value
parameter_list|)
block|{
name|unsigned
name|char
modifier|*
name|start
init|=
name|p
decl_stmt|;
while|while
condition|(
name|value
operator|>=
literal|0x80
condition|)
block|{
operator|*
name|p
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
operator|(
name|value
operator|%
literal|0x80
operator|)
operator|+
literal|0x80
argument_list|)
expr_stmt|;
name|value
operator|/=
literal|0x80
expr_stmt|;
operator|++
name|p
expr_stmt|;
block|}
operator|*
name|p
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|value
operator|%
literal|0x80
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|-
name|start
operator|)
operator|+
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Encode VALUE as 7/8b into P and return the number of bytes written.  * This maps signed ints onto unsigned ones.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|encode_int
parameter_list|(
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
name|apr_int64_t
name|value
parameter_list|)
block|{
return|return
name|encode_uint
argument_list|(
name|p
argument_list|,
call|(
name|apr_uint64_t
call|)
argument_list|(
name|value
operator|<
literal|0
condition|?
operator|-
literal|1
operator|-
literal|2
operator|*
name|value
else|:
literal|2
operator|*
name|value
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Append VALUE to STREAM in 7/8b encoding.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|stream_write_encoded
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_uint64_t
name|value
parameter_list|)
block|{
name|unsigned
name|char
name|encoded
index|[
name|ENCODED_INT_LENGTH
index|]
decl_stmt|;
name|apr_size_t
name|len
init|=
name|encode_uint
argument_list|(
name|encoded
argument_list|,
name|value
argument_list|)
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
operator|(
name|char
operator|*
operator|)
name|encoded
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Map unsigned VALUE back to signed integer.  */
end_comment

begin_function
specifier|static
name|apr_int64_t
name|decode_int
parameter_list|(
name|apr_uint64_t
name|value
parameter_list|)
block|{
return|return
call|(
name|apr_int64_t
call|)
argument_list|(
name|value
operator|%
literal|2
condition|?
operator|-
literal|1
operator|-
name|value
operator|/
literal|2
else|:
name|value
operator|/
literal|2
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write VALUE to the PROTO_INDEX file, using SCRATCH_POOL for temporary  * allocations.  *  * The point of this function is to ensure an architecture-independent  * proto-index file format.  All data is written as unsigned 64 bits ints  * in little endian byte order.  64 bits is the largest portable integer  * we have and unsigned values have well-defined conversions in C.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_uint64_to_proto_index
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|apr_uint64_t
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_byte_t
name|buffer
index|[
sizeof|sizeof
argument_list|(
name|value
argument_list|)
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_size_t
name|written
decl_stmt|;
comment|/* Split VALUE into 8 bytes using LE ordering. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|;
operator|++
name|i
control|)
block|{
comment|/* Unsigned conversions are well-defined ... */
name|buffer
index|[
name|i
index|]
operator|=
operator|(
name|apr_byte_t
operator|)
name|value
expr_stmt|;
name|value
operator|>>=
name|CHAR_BIT
expr_stmt|;
block|}
comment|/* Write it all to disk. */
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|proto_index
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|&
name|written
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|written
operator|==
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read one unsigned 64 bit value from PROTO_INDEX file and return it in  * *VALUE_P.  If EOF is NULL, error out when trying to read beyond EOF.  * Use SCRATCH_POOL for temporary allocations.  *  * This function is the inverse to write_uint64_to_proto_index (see there),  * reading the external LE byte order and convert it into host byte order.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_uint64_from_proto_index
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|apr_uint64_t
modifier|*
name|value_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_byte_t
name|buffer
index|[
sizeof|sizeof
argument_list|(
operator|*
name|value_p
argument_list|)
index|]
decl_stmt|;
name|apr_size_t
name|read
decl_stmt|;
comment|/* Read the full 8 bytes or our 64 bit value, unless we hit EOF.    * Assert that we never read partial values. */
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|proto_index
argument_list|,
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
operator|&
name|read
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|eof
operator|&&
operator|*
name|eof
operator|)
operator|||
name|read
operator|==
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we did not hit EOF, reconstruct the uint64 value and return it. */
if|if
condition|(
operator|!
name|eof
operator|||
operator|!
operator|*
name|eof
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_uint64_t
name|value
decl_stmt|;
comment|/* This could only overflow if CHAR_BIT had a value that is not        * a divisor of 64. */
name|value
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
name|value
operator|=
operator|(
name|value
operator|<<
name|CHAR_BIT
operator|)
operator|+
name|buffer
index|[
name|i
index|]
expr_stmt|;
operator|*
name|value_p
operator|=
name|value
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Convenience function similar to read_uint64_from_proto_index, but returns  * an uint32 value in VALUE_P.  Return an error if the value does not fit.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_uint32_from_proto_index
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|apr_uint32_t
modifier|*
name|value_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_uint64_t
name|value
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_uint64_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|value
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
operator|||
operator|!
operator|*
name|eof
condition|)
block|{
if|if
condition|(
name|value
operator|>
name|APR_UINT32_MAX
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"UINT32 0x%s too large, max = 0x%s"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_HEX_FMT
argument_list|,
name|value
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_HEX_FMT
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|APR_UINT32_MAX
argument_list|)
argument_list|)
return|;
comment|/* This conversion is not lossy because the value can be represented        * in the target type. */
operator|*
name|value_p
operator|=
operator|(
name|apr_uint32_t
operator|)
name|value
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Convenience function similar to read_uint64_from_proto_index, but returns  * an off_t value in VALUE_P.  Return an error if the value does not fit.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_off_t_from_proto_index
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|apr_off_t
modifier|*
name|value_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_uint64_t
name|value
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_uint64_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|value
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
operator|||
operator|!
operator|*
name|eof
condition|)
block|{
if|if
condition|(
name|value
operator|>
name|off_t_max
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"File offset 0x%s too large, max = 0x%s"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_HEX_FMT
argument_list|,
name|value
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_HEX_FMT
argument_list|,
name|off_t_max
argument_list|)
argument_list|)
return|;
comment|/* Shortening conversion from unsigned to signed int is well-defined        * and not lossy in C because the value can be represented in the        * target type. */
operator|*
name|value_p
operator|=
operator|(
name|apr_off_t
operator|)
name|value
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * log-to-phys index  */
end_comment

begin_comment
comment|/* Append ENTRY to log-to-phys PROTO_INDEX file.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_l2p_entry_to_proto_index
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|l2p_proto_entry_t
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|.
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|.
name|item_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read *ENTRY from log-to-phys PROTO_INDEX file and indicate end-of-file  * in *EOF, or error out in that case if EOF is NULL.  *ENTRY is in an  * undefined state if an end-of-file occurred.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_l2p_entry_from_proto_index
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|l2p_proto_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|read_uint64_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_uint64_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
operator|->
name|item_index
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the log-2-phys index page description for the l2p_page_entry_t  * array ENTRIES, starting with element START up to but not including END.  * Write the resulting representation into BUFFER.  Use SCRATCH_POOL for  * temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|encode_l2p_page
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|svn_spillbuf_t
modifier|*
name|buffer
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|unsigned
name|char
name|encoded
index|[
name|ENCODED_INT_LENGTH
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|apr_uint64_t
modifier|*
name|values
init|=
operator|(
specifier|const
name|apr_uint64_t
operator|*
operator|)
name|entries
operator|->
name|elts
decl_stmt|;
name|apr_uint64_t
name|last_value
init|=
literal|0
decl_stmt|;
comment|/* encode items */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
name|apr_int64_t
name|diff
init|=
name|values
index|[
name|i
index|]
operator|-
name|last_value
decl_stmt|;
name|last_value
operator|=
name|values
index|[
name|i
index|]
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|encoded
argument_list|,
name|encode_int
argument_list|(
name|encoded
argument_list|,
name|diff
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__l2p_proto_index_open
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|proto_index
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
name|proto_index
argument_list|,
name|file_name
argument_list|,
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_APPEND
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__l2p_proto_index_add_revision
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|l2p_proto_entry_t
name|entry
decl_stmt|;
name|entry
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|item_index
operator|=
literal|0
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|write_l2p_entry_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__l2p_proto_index_add_entry
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|l2p_proto_entry_t
name|entry
decl_stmt|;
comment|/* make sure the conversion to uint64 works */
name|SVN_ERR_ASSERT
argument_list|(
name|offset
operator|>=
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* we support offset '-1' as a "not used" indication */
name|entry
operator|.
name|offset
operator|=
operator|(
name|apr_uint64_t
operator|)
name|offset
operator|+
literal|1
expr_stmt|;
comment|/* make sure we can use item_index as an array index when building the    * final index file */
name|SVN_ERR_ASSERT
argument_list|(
name|item_index
operator|<
name|UINT_MAX
operator|/
literal|2
argument_list|)
expr_stmt|;
name|entry
operator|.
name|item_index
operator|=
name|item_index
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|write_l2p_entry_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__l2p_index_append
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_file_t
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|proto_file_name
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_file_t
modifier|*
name|proto_index
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_uint64_t
name|entry
decl_stmt|;
name|svn_boolean_t
name|eof
init|=
name|FALSE
decl_stmt|;
name|int
name|last_page_count
init|=
literal|0
decl_stmt|;
comment|/* total page count at the start of                                        the current revision */
comment|/* temporary data structures that collect the data which will be moved      to the target file in a second step */
name|apr_pool_t
modifier|*
name|local_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|local_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|page_counts
init|=
name|apr_array_make
argument_list|(
name|local_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|page_sizes
init|=
name|apr_array_make
argument_list|(
name|local_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entry_counts
init|=
name|apr_array_make
argument_list|(
name|local_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* collect the item offsets and sub-item value for the current revision */
name|apr_array_header_t
modifier|*
name|entries
init|=
name|apr_array_make
argument_list|(
name|local_pool
argument_list|,
literal|256
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 64k blocks, spill after 16MB */
name|svn_spillbuf_t
modifier|*
name|buffer
init|=
name|svn_spillbuf__create
argument_list|(
literal|0x10000
argument_list|,
literal|0x1000000
argument_list|,
name|local_pool
argument_list|)
decl_stmt|;
comment|/* Paranoia check that makes later casting to int32 safe.    * The current implementation is limited to 2G entries per page. */
if|if
condition|(
name|ffd
operator|->
name|l2p_page_size
operator|>
name|APR_INT32_MAX
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"L2P index page size  %s"
literal|" exceeds current limit of 2G entries"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|local_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|ffd
operator|->
name|l2p_page_size
argument_list|)
argument_list|)
return|;
comment|/* start at the beginning of the source file */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|proto_index
argument_list|,
name|proto_file_name
argument_list|,
name|APR_READ
operator||
name|APR_CREATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process all entries until we fail due to EOF */
for|for
control|(
name|entry
operator|=
literal|0
init|;
operator|!
name|eof
condition|;
operator|++
name|entry
control|)
block|{
name|l2p_proto_entry_t
name|proto_entry
decl_stmt|;
comment|/* (attempt to) read the next entry from the source */
name|SVN_ERR
argument_list|(
name|read_l2p_entry_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|proto_entry
argument_list|,
operator|&
name|eof
argument_list|,
name|local_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* handle new revision */
if|if
condition|(
operator|(
name|entry
operator|>
literal|0
operator|&&
name|proto_entry
operator|.
name|offset
operator|==
literal|0
operator|)
operator|||
name|eof
condition|)
block|{
comment|/* dump entries, grouped into pages */
name|int
name|entry_count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
name|i
operator|+=
name|entry_count
control|)
block|{
comment|/* 1 page with up to L2P_PAGE_SIZE entries.                * fsfs.conf settings validation guarantees this to fit into                * our address space. */
name|apr_uint64_t
name|last_buffer_size
init|=
operator|(
name|apr_uint64_t
operator|)
name|svn_spillbuf__get_size
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|entry_count
operator|=
name|ffd
operator|->
name|l2p_page_size
operator|<
name|entries
operator|->
name|nelts
operator|-
name|i
condition|?
operator|(
name|int
operator|)
name|ffd
operator|->
name|l2p_page_size
else|:
name|entries
operator|->
name|nelts
operator|-
name|i
expr_stmt|;
name|SVN_ERR
argument_list|(
name|encode_l2p_page
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|i
operator|+
name|entry_count
argument_list|,
name|buffer
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|entry_counts
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
name|entry_count
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|page_sizes
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
name|svn_spillbuf__get_size
argument_list|(
name|buffer
argument_list|)
operator|-
name|last_buffer_size
expr_stmt|;
block|}
name|apr_array_clear
argument_list|(
name|entries
argument_list|)
expr_stmt|;
comment|/* store the number of pages in this revision */
name|APR_ARRAY_PUSH
argument_list|(
name|page_counts
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
name|page_sizes
operator|->
name|nelts
operator|-
name|last_page_count
expr_stmt|;
name|last_page_count
operator|=
name|page_sizes
operator|->
name|nelts
expr_stmt|;
block|}
else|else
block|{
name|int
name|idx
decl_stmt|;
comment|/* store the mapping in our array */
if|if
condition|(
name|proto_entry
operator|.
name|item_index
operator|>
name|APR_INT32_MAX
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Item index %s too large "
literal|"in l2p proto index for revision %ld"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|local_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|proto_entry
operator|.
name|item_index
argument_list|)
argument_list|,
name|revision
operator|+
name|page_counts
operator|->
name|nelts
argument_list|)
return|;
name|idx
operator|=
operator|(
name|int
operator|)
name|proto_entry
operator|.
name|item_index
expr_stmt|;
while|while
condition|(
name|idx
operator|>=
name|entries
operator|->
name|nelts
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
literal|0
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|idx
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
name|proto_entry
operator|.
name|offset
expr_stmt|;
block|}
block|}
comment|/* close the source file */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|proto_index
argument_list|,
name|local_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Paranoia check that makes later casting to int32 safe.    * The current implementation is limited to 2G pages per index. */
if|if
condition|(
name|page_counts
operator|->
name|nelts
operator|>
name|APR_INT32_MAX
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"L2P index page count  %d"
literal|" exceeds current limit of 2G pages"
argument_list|)
argument_list|,
name|page_counts
operator|->
name|nelts
argument_list|)
return|;
comment|/* open target stream. */
name|stream
operator|=
name|svn_stream_checksummed2
argument_list|(
name|svn_stream_from_aprfile2
argument_list|(
name|index_file
argument_list|,
name|TRUE
argument_list|,
name|local_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* write header info */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|L2P_STREAM_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|ffd
operator|->
name|l2p_page_size
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|page_counts
operator|->
name|nelts
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|page_sizes
operator|->
name|nelts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the revision table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_counts
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint64_t
name|value
init|=
name|APR_ARRAY_IDX
argument_list|(
name|page_counts
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write the page table */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|page_sizes
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint64_t
name|value
init|=
name|APR_ARRAY_IDX
argument_list|(
name|page_sizes
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|entry_counts
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* append page contents and implicitly close STREAM */
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|svn_stream__from_spillbuf
argument_list|(
name|buffer
argument_list|,
name|local_pool
argument_list|)
argument_list|,
name|stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|local_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|local_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If REV_FILE->L2P_STREAM is NULL, create a new stream for the log-to-phys  * index for REVISION in FS and return it in REV_FILE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_open_l2p_index
parameter_list|(
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|)
block|{
if|if
condition|(
name|rev_file
operator|->
name|l2p_stream
operator|==
name|NULL
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__auto_read_footer
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|packed_stream_open
argument_list|(
operator|&
name|rev_file
operator|->
name|l2p_stream
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|rev_file
operator|->
name|l2p_offset
argument_list|,
name|rev_file
operator|->
name|p2l_offset
argument_list|,
name|L2P_STREAM_PREFIX
argument_list|,
operator|(
name|apr_size_t
operator|)
name|ffd
operator|->
name|block_size
argument_list|,
name|rev_file
operator|->
name|pool
argument_list|,
name|rev_file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the header data structure of the log-to-phys index for REVISION  * in FS and return it in *HEADER, allocated in RESULT_POOL.  Use REV_FILE  * to access on-disk data.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_l2p_header_body
parameter_list|(
name|l2p_header_t
modifier|*
modifier|*
name|header
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_uint64_t
name|value
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|page
decl_stmt|,
name|page_count
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|l2p_header_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|apr_size_t
name|page_table_index
decl_stmt|;
name|svn_revnum_t
name|next_rev
decl_stmt|;
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_file
operator|->
name|start_revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_open_l2p_index
argument_list|(
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|packed_stream_seek
argument_list|(
name|rev_file
operator|->
name|l2p_stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Read the table sizes.  Check the data for plausibility and    * consistency with other bits. */
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|first_revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|first_revision
operator|!=
name|rev_file
operator|->
name|start_revision
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Index rev / pack file revision numbers do not match"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|page_size
operator|=
operator|(
name|apr_uint32_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|->
name|page_size
operator|||
operator|(
name|result
operator|->
name|page_size
operator|&
operator|(
name|result
operator|->
name|page_size
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"L2P index page size is not a power of two"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|revision_count
operator|=
operator|(
name|int
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|revision_count
operator|!=
literal|1
operator|&&
name|result
operator|->
name|revision_count
operator|!=
operator|(
name|apr_uint64_t
operator|)
name|ffd
operator|->
name|max_files_per_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid number of revisions in L2P index"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
name|page_count
operator|=
operator|(
name|apr_size_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|page_count
operator|<
name|result
operator|->
name|revision_count
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Fewer L2P index pages than revisions"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|page_count
operator|>
operator|(
name|rev_file
operator|->
name|p2l_offset
operator|-
name|rev_file
operator|->
name|l2p_offset
operator|)
operator|/
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"L2P index page count implausibly large"
argument_list|)
argument_list|)
return|;
name|next_rev
operator|=
name|result
operator|->
name|first_revision
operator|+
operator|(
name|svn_revnum_t
operator|)
name|result
operator|->
name|revision_count
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|first_revision
operator|>
name|revision
operator|||
name|next_rev
operator|<=
name|revision
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Corrupt L2P index for r%ld only covers r%ld:%ld"
argument_list|)
argument_list|,
name|revision
argument_list|,
name|result
operator|->
name|first_revision
argument_list|,
name|next_rev
argument_list|)
return|;
comment|/* allocate the page tables */
name|result
operator|->
name|page_table
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
name|page_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|result
operator|->
name|page_table
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|page_table_index
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
operator|(
name|result
operator|->
name|revision_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|result
operator|->
name|page_table_index
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read per-revision page table sizes (i.e. number of pages per rev) */
name|page_table_index
operator|=
literal|0
expr_stmt|;
name|result
operator|->
name|page_table_index
index|[
literal|0
index|]
operator|=
name|page_table_index
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
operator|->
name|revision_count
condition|;
operator|++
name|i
control|)
block|{
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision with no L2P index pages"
argument_list|)
argument_list|)
return|;
name|page_table_index
operator|+=
operator|(
name|apr_size_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|page_table_index
operator|>
name|page_count
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"L2P page table exceeded"
argument_list|)
argument_list|)
return|;
name|result
operator|->
name|page_table_index
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|page_table_index
expr_stmt|;
block|}
if|if
condition|(
name|page_table_index
operator|!=
name|page_count
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revisions do not cover the full L2P index page table"
argument_list|)
argument_list|)
return|;
comment|/* read actual page tables */
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
name|page_count
condition|;
operator|++
name|page
control|)
block|{
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Empty L2P index page"
argument_list|)
argument_list|)
return|;
name|result
operator|->
name|page_table
index|[
name|page
index|]
operator|.
name|size
operator|=
operator|(
name|apr_uint32_t
operator|)
name|value
expr_stmt|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|>
name|result
operator|->
name|page_size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Page exceeds L2P index page size"
argument_list|)
argument_list|)
return|;
name|result
operator|->
name|page_table
index|[
name|page
index|]
operator|.
name|entry_count
operator|=
operator|(
name|apr_uint32_t
operator|)
name|value
expr_stmt|;
block|}
comment|/* correct the page description offsets */
name|offset
operator|=
name|packed_stream_offset
argument_list|(
name|rev_file
operator|->
name|l2p_stream
argument_list|)
expr_stmt|;
for|for
control|(
name|page
operator|=
literal|0
init|;
name|page
operator|<
name|page_count
condition|;
operator|++
name|page
control|)
block|{
name|result
operator|->
name|page_table
index|[
name|page
index|]
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|result
operator|->
name|page_table
index|[
name|page
index|]
operator|.
name|size
expr_stmt|;
block|}
comment|/* return and cache the header */
operator|*
name|header
operator|=
name|result
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|l2p_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Data structure that describes which l2p page info shall be extracted  * from the cache and contains the fields that receive the result.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2p_page_info_baton_t
block|{
comment|/* input data: we want the page covering (REVISION,ITEM_INDEX) */
name|svn_revnum_t
name|revision
decl_stmt|;
name|apr_uint64_t
name|item_index
decl_stmt|;
comment|/* out data */
comment|/* page location and size of the page within the l2p index file */
name|l2p_page_table_entry_t
name|entry
decl_stmt|;
comment|/* page number within the pages for REVISION (not l2p index global!) */
name|apr_uint32_t
name|page_no
decl_stmt|;
comment|/* offset of ITEM_INDEX within that page */
name|apr_uint32_t
name|page_offset
decl_stmt|;
comment|/* revision identifying the l2p index file, also the first rev in that */
name|svn_revnum_t
name|first_revision
decl_stmt|;
block|}
name|l2p_page_info_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Utility function that copies the info requested by BATON->REVISION and  * BATON->ITEM_INDEX and from HEADER and PAGE_TABLE into the output fields  * of *BATON.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|l2p_page_info_copy
parameter_list|(
name|l2p_page_info_baton_t
modifier|*
name|baton
parameter_list|,
specifier|const
name|l2p_header_t
modifier|*
name|header
parameter_list|,
specifier|const
name|l2p_page_table_entry_t
modifier|*
name|page_table
parameter_list|,
specifier|const
name|apr_size_t
modifier|*
name|page_table_index
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* revision offset within the index file */
name|apr_size_t
name|rel_revision
init|=
name|baton
operator|->
name|revision
operator|-
name|header
operator|->
name|first_revision
decl_stmt|;
if|if
condition|(
name|rel_revision
operator|>=
name|header
operator|->
name|revision_count
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld not covered by item index"
argument_list|)
argument_list|,
name|baton
operator|->
name|revision
argument_list|)
return|;
comment|/* select the relevant page */
if|if
condition|(
name|baton
operator|->
name|item_index
operator|<
name|header
operator|->
name|page_size
condition|)
block|{
comment|/* most revs fit well into a single page */
name|baton
operator|->
name|page_offset
operator|=
operator|(
name|apr_uint32_t
operator|)
name|baton
operator|->
name|item_index
expr_stmt|;
name|baton
operator|->
name|page_no
operator|=
literal|0
expr_stmt|;
name|baton
operator|->
name|entry
operator|=
name|page_table
index|[
name|page_table_index
index|[
name|rel_revision
index|]
index|]
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|l2p_page_table_entry_t
modifier|*
name|first_entry
decl_stmt|;
specifier|const
name|l2p_page_table_entry_t
modifier|*
name|last_entry
decl_stmt|;
name|apr_uint64_t
name|max_item_index
decl_stmt|;
comment|/* range of pages for this rev */
name|first_entry
operator|=
name|page_table
operator|+
name|page_table_index
index|[
name|rel_revision
index|]
expr_stmt|;
name|last_entry
operator|=
name|page_table
operator|+
name|page_table_index
index|[
name|rel_revision
operator|+
literal|1
index|]
expr_stmt|;
comment|/* do we hit a valid index page? */
name|max_item_index
operator|=
operator|(
name|apr_uint64_t
operator|)
name|header
operator|->
name|page_size
operator|*
operator|(
name|last_entry
operator|-
name|first_entry
operator|)
expr_stmt|;
if|if
condition|(
name|baton
operator|->
name|item_index
operator|>=
name|max_item_index
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Item index %s exceeds l2p limit "
literal|"of %s for revision %ld"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|baton
operator|->
name|item_index
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|max_item_index
argument_list|)
argument_list|,
name|baton
operator|->
name|revision
argument_list|)
return|;
comment|/* all pages are of the same size and full, except for the last one */
name|baton
operator|->
name|page_offset
operator|=
call|(
name|apr_uint32_t
call|)
argument_list|(
name|baton
operator|->
name|item_index
operator|%
name|header
operator|->
name|page_size
argument_list|)
expr_stmt|;
name|baton
operator|->
name|page_no
operator|=
call|(
name|apr_uint32_t
call|)
argument_list|(
name|baton
operator|->
name|item_index
operator|/
name|header
operator|->
name|page_size
argument_list|)
expr_stmt|;
name|baton
operator|->
name|entry
operator|=
name|first_entry
index|[
name|baton
operator|->
name|page_no
index|]
expr_stmt|;
block|}
name|baton
operator|->
name|first_revision
operator|=
name|header
operator|->
name|first_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t: copy the data requested in  * l2p_page_info_baton_t *BATON from l2p_header_t *DATA into the output  * fields in *BATON.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|l2p_page_info_access_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* resolve all pointer values of in-cache data */
specifier|const
name|l2p_header_t
modifier|*
name|header
init|=
name|data
decl_stmt|;
specifier|const
name|l2p_page_table_entry_t
modifier|*
name|page_table
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|header
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table
argument_list|)
decl_stmt|;
specifier|const
name|apr_size_t
modifier|*
name|page_table_index
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|header
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table_index
argument_list|)
decl_stmt|;
comment|/* copy the info */
return|return
name|l2p_page_info_copy
argument_list|(
name|baton
argument_list|,
name|header
argument_list|,
name|page_table
argument_list|,
name|page_table_index
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the page info requested in *BATON from FS and set the output fields  * in *BATON.  Use REV_FILE for on-disk file access.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_l2p_page_info
parameter_list|(
name|l2p_page_info_baton_t
modifier|*
name|baton
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|l2p_header_t
modifier|*
name|result
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|void
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
comment|/* try to find the info in the cache */
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_file
operator|->
name|start_revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dummy
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|l2p_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|l2p_page_info_access_func
argument_list|,
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* read from disk, cache and copy the result */
name|SVN_ERR
argument_list|(
name|get_l2p_header_body
argument_list|(
operator|&
name|result
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|baton
operator|->
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|l2p_page_info_copy
argument_list|(
name|baton
argument_list|,
name|result
argument_list|,
name|result
operator|->
name|page_table
argument_list|,
name|result
operator|->
name|page_table_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Data request structure used by l2p_page_table_access_func.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2p_page_table_baton_t
block|{
comment|/* revision for which to read the page table */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* page table entries (of type l2p_page_table_entry_t).    * Must be created by caller and will be filled by callee. */
name|apr_array_header_t
modifier|*
name|pages
decl_stmt|;
block|}
name|l2p_page_table_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t: copy the data requested in  * l2p_page_baton_t *BATON from l2p_page_t *DATA into BATON->PAGES and *OUT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|l2p_page_table_access_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* resolve in-cache pointers */
name|l2p_page_table_baton_t
modifier|*
name|table_baton
init|=
name|baton
decl_stmt|;
specifier|const
name|l2p_header_t
modifier|*
name|header
init|=
operator|(
specifier|const
name|l2p_header_t
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|l2p_page_table_entry_t
modifier|*
name|page_table
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|header
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table
argument_list|)
decl_stmt|;
specifier|const
name|apr_size_t
modifier|*
name|page_table_index
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|header
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table_index
argument_list|)
decl_stmt|;
comment|/* copy the revision's page table into BATON */
name|apr_size_t
name|rel_revision
init|=
name|table_baton
operator|->
name|revision
operator|-
name|header
operator|->
name|first_revision
decl_stmt|;
if|if
condition|(
name|rel_revision
operator|<
name|header
operator|->
name|revision_count
condition|)
block|{
specifier|const
name|l2p_page_table_entry_t
modifier|*
name|entry
init|=
name|page_table
operator|+
name|page_table_index
index|[
name|rel_revision
index|]
decl_stmt|;
specifier|const
name|l2p_page_table_entry_t
modifier|*
name|last_entry
init|=
name|page_table
operator|+
name|page_table_index
index|[
name|rel_revision
operator|+
literal|1
index|]
decl_stmt|;
for|for
control|(
init|;
name|entry
operator|<
name|last_entry
condition|;
operator|++
name|entry
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|table_baton
operator|->
name|pages
argument_list|,
name|l2p_page_table_entry_t
argument_list|)
operator|=
operator|*
name|entry
expr_stmt|;
block|}
comment|/* set output as a courtesy to the caller */
operator|*
name|out
operator|=
name|table_baton
operator|->
name|pages
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the l2p index page table for REVISION in FS from cache and return  * it in PAGES.  The later must be provided by the caller (and can be  * re-used); existing entries will be removed before writing the result.  * If the data cannot be found in the cache, the result will be empty  * (it never can be empty for a valid REVISION if the data is cached).  * Use the info from REV_FILE to determine pack / rev file properties.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_l2p_page_table
parameter_list|(
name|apr_array_header_t
modifier|*
name|pages
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|l2p_page_table_baton_t
name|baton
decl_stmt|;
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_file
operator|->
name|start_revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|apr_array_clear
argument_list|(
name|pages
argument_list|)
expr_stmt|;
name|baton
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|baton
operator|.
name|pages
operator|=
name|pages
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|pages
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|l2p_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|l2p_page_table_access_func
argument_list|,
operator|&
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* From the log-to-phys index file starting at START_REVISION in FS, read  * the mapping page identified by TABLE_ENTRY and return it in *PAGE.  * Use REV_FILE to access on-disk files.  * Use RESULT_POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_l2p_page
parameter_list|(
name|l2p_page_t
modifier|*
modifier|*
name|page
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|l2p_page_table_entry_t
modifier|*
name|table_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_uint32_t
name|i
decl_stmt|;
name|l2p_page_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|apr_uint64_t
name|last_value
init|=
literal|0
decl_stmt|;
comment|/* open index file and select page */
name|SVN_ERR
argument_list|(
name|auto_open_l2p_index
argument_list|(
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|packed_stream_seek
argument_list|(
name|rev_file
operator|->
name|l2p_stream
argument_list|,
name|table_entry
operator|->
name|offset
argument_list|)
expr_stmt|;
comment|/* initialize the page content */
name|result
operator|->
name|entry_count
operator|=
name|table_entry
operator|->
name|entry_count
expr_stmt|;
name|result
operator|->
name|offsets
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
name|result
operator|->
name|entry_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|result
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read all page entries (offsets in rev file and container sub-items) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
operator|->
name|entry_count
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|l2p_stream
argument_list|)
argument_list|)
expr_stmt|;
name|last_value
operator|+=
name|decode_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|result
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|last_value
operator|-
literal|1
expr_stmt|;
block|}
comment|/* After reading all page entries, the read cursor must have moved by    * TABLE_ENTRY->SIZE bytes. */
if|if
condition|(
name|packed_stream_offset
argument_list|(
name|rev_file
operator|->
name|l2p_stream
argument_list|)
operator|!=
name|table_entry
operator|->
name|offset
operator|+
name|table_entry
operator|->
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"L2P actual page size does not match page table value."
argument_list|)
argument_list|)
return|;
operator|*
name|page
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function.  Read the l2p index pages for REVISION in FS from  * REV_FILE and put them into the cache.  Skip page number EXLCUDED_PAGE_NO  * (use -1 for 'skip none') and pages outside the MIN_OFFSET, MAX_OFFSET  * range in the l2p index file.  The index is being identified by  * FIRST_REVISION.  PAGES is a scratch container provided by the caller.  * SCRATCH_POOL is used for temporary allocations.  *  * This function may be a no-op if the header cache lookup fails / misses.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prefetch_l2p_pages
parameter_list|(
name|svn_boolean_t
modifier|*
name|end
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|first_revision
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_array_header_t
modifier|*
name|pages
parameter_list|,
name|int
name|exlcuded_page_no
parameter_list|,
name|apr_off_t
name|min_offset
parameter_list|,
name|apr_off_t
name|max_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_fs_fs__page_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* Parameter check. */
if|if
condition|(
name|min_offset
operator|<
literal|0
condition|)
name|min_offset
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|max_offset
operator|<=
literal|0
condition|)
block|{
comment|/* Nothing to do */
operator|*
name|end
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* get the page table for REVISION from cache */
operator|*
name|end
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_l2p_page_table
argument_list|(
name|pages
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pages
operator|->
name|nelts
operator|==
literal|0
operator|||
name|rev_file
operator|->
name|l2p_stream
operator|==
name|NULL
condition|)
block|{
comment|/* not found -> we can't continue without hitting the disk again */
operator|*
name|end
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* prefetch pages individually until all are done or we found one in    * the cache */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|revision
operator|<=
name|APR_UINT32_MAX
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
operator|(
name|apr_uint32_t
operator|)
name|revision
expr_stmt|;
name|key
operator|.
name|is_packed
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pages
operator|->
name|nelts
operator|&&
operator|!
operator|*
name|end
condition|;
operator|++
name|i
control|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|l2p_page_table_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|pages
argument_list|,
name|i
argument_list|,
name|l2p_page_table_entry_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|exlcuded_page_no
condition|)
continue|continue;
comment|/* skip pages outside the specified index file range */
if|if
condition|(
name|entry
operator|->
name|offset
operator|<
operator|(
name|apr_uint64_t
operator|)
name|min_offset
operator|||
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
operator|>
operator|(
name|apr_uint64_t
operator|)
name|max_offset
condition|)
block|{
operator|*
name|end
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* page already in cache? */
name|key
operator|.
name|page
operator|=
name|i
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|l2p_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_cached
condition|)
block|{
comment|/* no in cache -> read from stream (data already buffered in APR)            * and cache the result */
name|l2p_page_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_l2p_page
argument_list|(
operator|&
name|page
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|first_revision
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|l2p_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|page
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Request data structure for l2p_entry_access_func.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|l2p_entry_baton_t
block|{
comment|/* in data */
comment|/* revision. Used for error messages only */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* item index to look up. Used for error messages only */
name|apr_uint64_t
name|item_index
decl_stmt|;
comment|/* offset within the cached page */
name|apr_uint32_t
name|page_offset
decl_stmt|;
comment|/* out data */
comment|/* absolute item or container offset in rev / pack file */
name|apr_uint64_t
name|offset
decl_stmt|;
block|}
name|l2p_entry_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Return the rev / pack file offset of the item at BATON->PAGE_OFFSET in  * OFFSETS of PAGE and write it to *OFFSET.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|l2p_page_get_entry
parameter_list|(
name|l2p_entry_baton_t
modifier|*
name|baton
parameter_list|,
specifier|const
name|l2p_page_t
modifier|*
name|page
parameter_list|,
specifier|const
name|apr_uint64_t
modifier|*
name|offsets
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* overflow check */
if|if
condition|(
name|page
operator|->
name|entry_count
operator|<=
name|baton
operator|->
name|page_offset
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Item index %s"
literal|" too large in revision %ld"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|baton
operator|->
name|item_index
argument_list|)
argument_list|,
name|baton
operator|->
name|revision
argument_list|)
return|;
comment|/* return the result */
name|baton
operator|->
name|offset
operator|=
name|offsets
index|[
name|baton
operator|->
name|page_offset
index|]
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t: copy the data requested in  * l2p_entry_baton_t *BATON from l2p_page_t *DATA into BATON->OFFSET.  * *OUT remains unchanged.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|l2p_entry_access_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* resolve all in-cache pointers */
specifier|const
name|l2p_page_t
modifier|*
name|page
init|=
name|data
decl_stmt|;
specifier|const
name|apr_uint64_t
modifier|*
name|offsets
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|page
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|page
operator|->
name|offsets
argument_list|)
decl_stmt|;
comment|/* return the requested data */
return|return
name|l2p_page_get_entry
argument_list|(
name|baton
argument_list|,
name|page
argument_list|,
name|offsets
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Using the log-to-phys indexes in FS, find the absolute offset in the  * rev file for (REVISION, ITEM_INDEX) and return it in *OFFSET.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|l2p_index_lookup
parameter_list|(
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|l2p_page_info_baton_t
name|info_baton
decl_stmt|;
name|l2p_entry_baton_t
name|page_baton
decl_stmt|;
name|l2p_page_t
modifier|*
name|page
init|=
name|NULL
decl_stmt|;
name|svn_fs_fs__page_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|void
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
comment|/* read index master data structure and extract the info required to    * access the l2p index page for (REVISION,ITEM_INDEX)*/
name|info_baton
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|info_baton
operator|.
name|item_index
operator|=
name|item_index
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_l2p_page_info
argument_list|(
operator|&
name|info_baton
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* try to find the page in the cache and get the OFFSET from it */
name|page_baton
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|page_baton
operator|.
name|item_index
operator|=
name|item_index
expr_stmt|;
name|page_baton
operator|.
name|page_offset
operator|=
name|info_baton
operator|.
name|page_offset
expr_stmt|;
name|assert
argument_list|(
name|revision
operator|<=
name|APR_UINT32_MAX
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
operator|(
name|apr_uint32_t
operator|)
name|revision
expr_stmt|;
name|key
operator|.
name|is_packed
operator|=
name|svn_fs_fs__is_packed_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|page
operator|=
name|info_baton
operator|.
name|page_no
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|&
name|dummy
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|l2p_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|l2p_entry_access_func
argument_list|,
operator|&
name|page_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_cached
condition|)
block|{
comment|/* we need to read the info from disk (might already be in the        * APR file buffer, though) */
name|apr_array_header_t
modifier|*
name|pages
decl_stmt|;
name|svn_revnum_t
name|prefetch_revision
decl_stmt|;
name|svn_revnum_t
name|last_revision
init|=
name|info_baton
operator|.
name|first_revision
operator|+
operator|(
name|key
operator|.
name|is_packed
condition|?
name|ffd
operator|->
name|max_files_per_dir
else|:
literal|1
operator|)
decl_stmt|;
name|svn_boolean_t
name|end
decl_stmt|;
name|apr_off_t
name|max_offset
init|=
name|APR_ALIGN
argument_list|(
name|info_baton
operator|.
name|entry
operator|.
name|offset
operator|+
name|info_baton
operator|.
name|entry
operator|.
name|size
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
decl_stmt|;
name|apr_off_t
name|min_offset
init|=
name|max_offset
operator|-
name|ffd
operator|->
name|block_size
decl_stmt|;
comment|/* read the relevant page */
name|SVN_ERR
argument_list|(
name|get_l2p_page
argument_list|(
operator|&
name|page
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|info_baton
operator|.
name|first_revision
argument_list|,
operator|&
name|info_baton
operator|.
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cache the page and extract the result we need */
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|l2p_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|page
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|l2p_page_get_entry
argument_list|(
operator|&
name|page_baton
argument_list|,
name|page
argument_list|,
name|page
operator|->
name|offsets
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|use_block_read
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* prefetch pages from following and preceding revisions */
name|pages
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|l2p_page_table_entry_t
argument_list|)
argument_list|)
expr_stmt|;
name|end
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|prefetch_revision
operator|=
name|revision
init|;
name|prefetch_revision
operator|<
name|last_revision
operator|&&
operator|!
name|end
condition|;
operator|++
name|prefetch_revision
control|)
block|{
name|int
name|excluded_page_no
init|=
name|prefetch_revision
operator|==
name|revision
condition|?
name|info_baton
operator|.
name|page_no
else|:
operator|-
literal|1
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prefetch_l2p_pages
argument_list|(
operator|&
name|end
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|info_baton
operator|.
name|first_revision
argument_list|,
name|prefetch_revision
argument_list|,
name|pages
argument_list|,
name|excluded_page_no
argument_list|,
name|min_offset
argument_list|,
name|max_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|end
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|prefetch_revision
operator|=
name|revision
operator|-
literal|1
init|;
name|prefetch_revision
operator|>=
name|info_baton
operator|.
name|first_revision
operator|&&
operator|!
name|end
condition|;
operator|--
name|prefetch_revision
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prefetch_l2p_pages
argument_list|(
operator|&
name|end
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|info_baton
operator|.
name|first_revision
argument_list|,
name|prefetch_revision
argument_list|,
name|pages
argument_list|,
operator|-
literal|1
argument_list|,
name|min_offset
argument_list|,
name|max_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|offset
operator|=
name|page_baton
operator|.
name|offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Using the log-to-phys proto index in transaction TXN_ID in FS, find the  * absolute offset in the proto rev file for the given ITEM_INDEX and return  * it in *OFFSET.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|l2p_proto_index_lookup
parameter_list|(
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|eof
init|=
name|FALSE
decl_stmt|;
name|apr_file_t
modifier|*
name|file
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|svn_fs_fs__path_l2p_proto_index
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process all entries until we fail due to EOF */
operator|*
name|offset
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|l2p_proto_entry_t
name|entry
decl_stmt|;
comment|/* (attempt to) read the next entry from the source */
name|SVN_ERR
argument_list|(
name|read_l2p_entry_from_proto_index
argument_list|(
name|file
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* handle new revision */
if|if
condition|(
operator|!
name|eof
operator|&&
name|entry
operator|.
name|item_index
operator|==
name|item_index
condition|)
block|{
operator|*
name|offset
operator|=
operator|(
name|apr_off_t
operator|)
name|entry
operator|.
name|offset
operator|-
literal|1
expr_stmt|;
break|break;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the log-to-phys header info of the index covering REVISION from FS  * and return it in *HEADER.  REV_FILE provides the pack / rev status.  * Allocate *HEADER in RESULT_POOL, use SCRATCH_POOL for temporary  * allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_l2p_header
parameter_list|(
name|l2p_header_t
modifier|*
modifier|*
name|header
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
comment|/* first, try cache lookop */
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_file
operator|->
name|start_revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|header
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|l2p_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* read from disk and cache the result */
name|SVN_ERR
argument_list|(
name|get_l2p_header_body
argument_list|(
name|header
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__l2p_get_max_ids
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|max_ids
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|apr_size_t
name|count
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|l2p_header_t
modifier|*
name|header
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_revnum_t
name|last_rev
init|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|start_rev
operator|+
name|count
argument_list|)
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_pool_t
modifier|*
name|header_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* read index master data structure for the index covering START_REV */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start_rev
argument_list|,
name|header_pool
argument_list|,
name|header_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_l2p_header
argument_list|(
operator|&
name|header
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start_rev
argument_list|,
name|header_pool
argument_list|,
name|header_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the length of the item index list for each rev.    * Read new index headers as required. */
operator|*
name|max_ids
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|revision
operator|=
name|start_rev
init|;
name|revision
operator|<
name|last_rev
condition|;
operator|++
name|revision
control|)
block|{
name|apr_uint64_t
name|full_page_count
decl_stmt|;
name|apr_uint64_t
name|item_count
decl_stmt|;
name|apr_size_t
name|first_page_index
decl_stmt|,
name|last_page_index
decl_stmt|;
if|if
condition|(
name|revision
operator|>=
name|header
operator|->
name|first_revision
operator|+
name|header
operator|->
name|revision_count
condition|)
block|{
comment|/* need to read the next index. Clear up memory used for the            * previous one.  Note that intermittent pack runs do not change            * the number of items in a revision, i.e. there is no consistency            * issue here. */
name|svn_pool_clear
argument_list|(
name|header_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|header_pool
argument_list|,
name|header_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_l2p_header
argument_list|(
operator|&
name|header
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|header_pool
argument_list|,
name|header_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* in a revision with N index pages, the first N-1 index pages are        * "full", i.e. contain HEADER->PAGE_SIZE entries */
name|first_page_index
operator|=
name|header
operator|->
name|page_table_index
index|[
name|revision
operator|-
name|header
operator|->
name|first_revision
index|]
expr_stmt|;
name|last_page_index
operator|=
name|header
operator|->
name|page_table_index
index|[
name|revision
operator|-
name|header
operator|->
name|first_revision
operator|+
literal|1
index|]
expr_stmt|;
name|full_page_count
operator|=
name|last_page_index
operator|-
name|first_page_index
operator|-
literal|1
expr_stmt|;
name|item_count
operator|=
name|full_page_count
operator|*
name|header
operator|->
name|page_size
operator|+
name|header
operator|->
name|page_table
index|[
name|last_page_index
operator|-
literal|1
index|]
operator|.
name|entry_count
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|max_ids
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
name|item_count
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|header_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__item_offset
parameter_list|(
name|apr_off_t
modifier|*
name|absolute_position
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
if|if
condition|(
name|txn_id
condition|)
block|{
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* the txn is going to produce a rev with logical addressing.              So, we need to get our info from the (proto) index file. */
name|SVN_ERR
argument_list|(
name|l2p_proto_index_lookup
argument_list|(
name|absolute_position
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|item_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* for data in txns, item_index *is* the offset */
operator|*
name|absolute_position
operator|=
name|item_index
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* ordinary index lookup */
name|SVN_ERR
argument_list|(
name|l2p_index_lookup
argument_list|(
name|absolute_position
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|item_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rev_file
operator|->
name|is_packed
condition|)
block|{
comment|/* pack file with physical addressing */
name|apr_off_t
name|rev_offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_packed_offset
argument_list|(
operator|&
name|rev_offset
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|absolute_position
operator|=
name|rev_offset
operator|+
name|item_index
expr_stmt|;
block|}
else|else
block|{
comment|/* for non-packed revs with physical addressing,          item_index *is* the offset */
operator|*
name|absolute_position
operator|=
name|item_index
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * phys-to-log index  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_proto_index_open
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|proto_index
parameter_list|,
specifier|const
name|char
modifier|*
name|file_name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
name|proto_index
argument_list|,
name|file_name
argument_list|,
name|APR_READ
operator||
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_APPEND
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_proto_index_add_entry
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_uint64_t
name|revision
decl_stmt|;
comment|/* Make sure all signed elements of ENTRY have non-negative values.    *    * For file offsets and sizes, this is a given as we use them to describe    * absolute positions and sizes.  For revisions, SVN_INVALID_REVNUM is    * valid, hence we have to shift it by 1.    */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|offset
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|size
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|item
operator|.
name|revision
operator|>=
literal|0
operator|||
name|entry
operator|->
name|item
operator|.
name|revision
operator|==
name|SVN_INVALID_REVNUM
argument_list|)
expr_stmt|;
name|revision
operator|=
name|entry
operator|->
name|item
operator|.
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|?
literal|0
else|:
operator|(
operator|(
name|apr_uint64_t
operator|)
name|entry
operator|->
name|item
operator|.
name|revision
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* Now, all values will nicely convert to uint64. */
comment|/* Make sure to keep P2L_PROTO_INDEX_ENTRY_SIZE consistent with this: */
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|->
name|type
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|->
name|fnv1_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_uint64_to_proto_index
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|->
name|item
operator|.
name|number
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read *ENTRY from log-to-phys PROTO_INDEX file and indicate end-of-file  * in *EOF, or error out in that case if EOF is NULL.  *ENTRY is in an  * undefined state if an end-of-file occurred.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_p2l_entry_from_proto_index
parameter_list|(
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_uint64_t
name|revision
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_off_t_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_off_t_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
operator|->
name|size
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_uint32_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
operator|->
name|type
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_uint32_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
operator|->
name|fnv1_checksum
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_uint64_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|revision
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_uint64_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
operator|->
name|item
operator|.
name|number
argument_list|,
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the inverse REVSION number conversion (see    * svn_fs_fs__p2l_proto_index_add_entry), if we actually read a complete    * record.    */
if|if
condition|(
operator|!
name|eof
operator|||
operator|!
operator|*
name|eof
condition|)
block|{
comment|/* Be careful with the arithmetics here (overflows and wrap-around): */
if|if
condition|(
name|revision
operator|>
literal|0
operator|&&
name|revision
operator|-
literal|1
operator|>
name|LONG_MAX
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision 0x%s too large, max = 0x%s"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_HEX_FMT
argument_list|,
name|revision
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_HEX_FMT
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|LONG_MAX
argument_list|)
argument_list|)
return|;
comment|/* Shortening conversion from unsigned to signed int is well-defined        * and not lossy in C because the value can be represented in the        * target type.  Also, cast to 'long' instead of 'svn_revnum_t' here        * to provoke a compiler warning if those types should differ and we        * would need to change the overflow checking logic.        */
name|entry
operator|->
name|item
operator|.
name|revision
operator|=
name|revision
operator|==
literal|0
condition|?
name|SVN_INVALID_REVNUM
else|:
call|(
name|long
call|)
argument_list|(
name|revision
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_proto_index_next_offset
parameter_list|(
name|apr_off_t
modifier|*
name|next_offset
parameter_list|,
name|apr_file_t
modifier|*
name|proto_index
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
comment|/* Empty index file? */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|proto_index
argument_list|,
name|APR_END
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|*
name|next_offset
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* At least one entry.  Read last entry. */
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
name|offset
operator|-=
name|P2L_PROTO_INDEX_ENTRY_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|proto_index
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_p2l_entry_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return next offset. */
operator|*
name|next_offset
operator|=
name|entry
operator|.
name|offset
operator|+
name|entry
operator|.
name|size
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_index_append
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_file_t
modifier|*
name|index_file
parameter_list|,
specifier|const
name|char
modifier|*
name|proto_file_name
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_uint64_t
name|page_size
init|=
name|ffd
operator|->
name|p2l_page_size
decl_stmt|;
name|apr_file_t
modifier|*
name|proto_index
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|eof
init|=
name|FALSE
decl_stmt|;
name|unsigned
name|char
name|encoded
index|[
name|ENCODED_INT_LENGTH
index|]
decl_stmt|;
name|svn_revnum_t
name|last_revision
init|=
name|revision
decl_stmt|;
name|apr_uint64_t
name|last_compound
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|last_entry_end
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|last_page_end
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|last_buffer_size
init|=
literal|0
decl_stmt|;
comment|/* byte offset in the spill buffer at                                          the begin of the current revision */
name|apr_uint64_t
name|file_size
init|=
literal|0
decl_stmt|;
comment|/* temporary data structures that collect the data which will be moved      to the target file in a second step */
name|apr_pool_t
modifier|*
name|local_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|table_sizes
init|=
name|apr_array_make
argument_list|(
name|local_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 64k blocks, spill after 16MB */
name|svn_spillbuf_t
modifier|*
name|buffer
init|=
name|svn_spillbuf__create
argument_list|(
literal|0x10000
argument_list|,
literal|0x1000000
argument_list|,
name|local_pool
argument_list|)
decl_stmt|;
comment|/* for loop temps ... */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* start at the beginning of the source file */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|proto_index
argument_list|,
name|proto_file_name
argument_list|,
name|APR_READ
operator||
name|APR_CREATE
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process all entries until we fail due to EOF */
while|while
condition|(
operator|!
name|eof
condition|)
block|{
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
name|apr_uint64_t
name|entry_end
decl_stmt|;
name|svn_boolean_t
name|new_page
init|=
name|svn_spillbuf__get_size
argument_list|(
name|buffer
argument_list|)
operator|==
literal|0
decl_stmt|;
name|apr_uint64_t
name|compound
decl_stmt|;
name|apr_int64_t
name|rev_diff
decl_stmt|,
name|compound_diff
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* (attempt to) read the next entry from the source */
name|SVN_ERR
argument_list|(
name|read_p2l_entry_from_proto_index
argument_list|(
name|proto_index
argument_list|,
operator|&
name|entry
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "unused" (and usually non-existent) section to cover the offsets          at the end the of the last page. */
if|if
condition|(
name|eof
condition|)
block|{
name|file_size
operator|=
name|last_entry_end
expr_stmt|;
name|entry
operator|.
name|offset
operator|=
name|last_entry_end
expr_stmt|;
name|entry
operator|.
name|size
operator|=
name|APR_ALIGN
argument_list|(
name|entry
operator|.
name|offset
argument_list|,
name|page_size
argument_list|)
operator|-
name|entry
operator|.
name|offset
expr_stmt|;
name|entry
operator|.
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_UNUSED
expr_stmt|;
name|entry
operator|.
name|fnv1_checksum
operator|=
literal|0
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|revision
operator|=
name|last_revision
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|number
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* fix-up items created when the txn's target rev was unknown */
if|if
condition|(
name|entry
operator|.
name|item
operator|.
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|entry
operator|.
name|item
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
block|}
comment|/* end pages if entry is extending beyond their boundaries */
name|entry_end
operator|=
name|entry
operator|.
name|offset
operator|+
name|entry
operator|.
name|size
expr_stmt|;
while|while
condition|(
name|entry_end
operator|-
name|last_page_end
operator|>
name|page_size
condition|)
block|{
name|apr_uint64_t
name|buffer_size
init|=
name|svn_spillbuf__get_size
argument_list|(
name|buffer
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|table_sizes
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
name|buffer_size
operator|-
name|last_buffer_size
expr_stmt|;
name|last_buffer_size
operator|=
name|buffer_size
expr_stmt|;
name|last_page_end
operator|+=
name|page_size
expr_stmt|;
name|new_page
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* this entry starts a new table -> store its offset          (all following entries in the same table will store sizes only) */
if|if
condition|(
name|new_page
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|encoded
argument_list|,
name|encode_uint
argument_list|(
name|encoded
argument_list|,
name|entry
operator|.
name|offset
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|last_revision
operator|=
name|revision
expr_stmt|;
name|last_compound
operator|=
literal|0
expr_stmt|;
block|}
comment|/* write simple item entry */
name|SVN_ERR
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|encoded
argument_list|,
name|encode_uint
argument_list|(
name|encoded
argument_list|,
name|entry
operator|.
name|size
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rev_diff
operator|=
name|entry
operator|.
name|item
operator|.
name|revision
operator|-
name|last_revision
expr_stmt|;
name|last_revision
operator|=
name|entry
operator|.
name|item
operator|.
name|revision
expr_stmt|;
name|compound
operator|=
name|entry
operator|.
name|item
operator|.
name|number
operator|*
literal|8
operator|+
name|entry
operator|.
name|type
expr_stmt|;
name|compound_diff
operator|=
name|compound
operator|-
name|last_compound
expr_stmt|;
name|last_compound
operator|=
name|compound
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|encoded
argument_list|,
name|encode_int
argument_list|(
name|encoded
argument_list|,
name|compound_diff
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|encoded
argument_list|,
name|encode_int
argument_list|(
name|encoded
argument_list|,
name|rev_diff
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_spillbuf__write
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|encoded
argument_list|,
name|encode_uint
argument_list|(
name|encoded
argument_list|,
name|entry
operator|.
name|fnv1_checksum
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|last_entry_end
operator|=
name|entry_end
expr_stmt|;
block|}
comment|/* close the source file */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|proto_index
argument_list|,
name|local_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store length of last table */
name|APR_ARRAY_PUSH
argument_list|(
name|table_sizes
argument_list|,
name|apr_uint64_t
argument_list|)
operator|=
name|svn_spillbuf__get_size
argument_list|(
name|buffer
argument_list|)
operator|-
name|last_buffer_size
expr_stmt|;
comment|/* Open target stream. */
name|stream
operator|=
name|svn_stream_checksummed2
argument_list|(
name|svn_stream_from_aprfile2
argument_list|(
name|index_file
argument_list|,
name|TRUE
argument_list|,
name|local_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* write the start revision, file size and page size */
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|P2L_STREAM_PREFIX
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|file_size
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|page_size
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the page table (actually, the sizes of each page description) */
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|table_sizes
operator|->
name|nelts
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table_sizes
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint64_t
name|value
init|=
name|APR_ARRAY_IDX
argument_list|(
name|table_sizes
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|stream_write_encoded
argument_list|(
name|stream
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* append page contents and implicitly close STREAM */
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|svn_stream__from_spillbuf
argument_list|(
name|buffer
argument_list|,
name|local_pool
argument_list|)
argument_list|,
name|stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|local_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|local_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If REV_FILE->P2L_STREAM is NULL, create a new stream for the phys-to-log  * index for REVISION in FS using the rev / pack file provided by REV_FILE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_open_p2l_index
parameter_list|(
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|)
block|{
if|if
condition|(
name|rev_file
operator|->
name|p2l_stream
operator|==
name|NULL
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__auto_read_footer
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|packed_stream_open
argument_list|(
operator|&
name|rev_file
operator|->
name|p2l_stream
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|rev_file
operator|->
name|p2l_offset
argument_list|,
name|rev_file
operator|->
name|footer_offset
argument_list|,
name|P2L_STREAM_PREFIX
argument_list|,
operator|(
name|apr_size_t
operator|)
name|ffd
operator|->
name|block_size
argument_list|,
name|rev_file
operator|->
name|pool
argument_list|,
name|rev_file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the header data structure of the phys-to-log index for REVISION in  * FS and return it in *HEADER, allocated in RESULT_POOL. Use REV_FILE to  * access on-disk data.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_p2l_header
parameter_list|(
name|p2l_header_t
modifier|*
modifier|*
name|header
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_uint64_t
name|value
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|p2l_header_t
modifier|*
name|result
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
comment|/* look for the header data in our cache */
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_file
operator|->
name|start_revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|header
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|p2l_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* not found -> must read it from disk.    * Open index file or position read pointer to the begin of the file */
if|if
condition|(
name|rev_file
operator|->
name|p2l_stream
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|auto_open_p2l_index
argument_list|(
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rev_file
operator|->
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|packed_stream_seek
argument_list|(
name|rev_file
operator|->
name|p2l_stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* allocate result data structure */
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read table sizes, check them for plausibility and allocate page array. */
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|p2l_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|first_revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|first_revision
operator|!=
name|rev_file
operator|->
name|start_revision
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Index rev / pack file revision numbers do not match"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|p2l_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|file_size
operator|=
name|value
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|file_size
operator|!=
operator|(
name|apr_uint64_t
operator|)
name|rev_file
operator|->
name|l2p_offset
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Index offset and rev / pack file size do not match"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|p2l_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|page_size
operator|=
name|value
expr_stmt|;
if|if
condition|(
operator|!
name|result
operator|->
name|page_size
operator|||
operator|(
name|result
operator|->
name|page_size
operator|&
operator|(
name|result
operator|->
name|page_size
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"P2L index page size is not a power of two"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|p2l_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|page_count
operator|=
operator|(
name|apr_size_t
operator|)
name|value
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|page_count
operator|!=
operator|(
name|result
operator|->
name|file_size
operator|-
literal|1
operator|)
operator|/
name|result
operator|->
name|page_size
operator|+
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"P2L page count does not match rev / pack file size"
argument_list|)
argument_list|)
return|;
name|result
operator|->
name|offsets
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
operator|(
name|result
operator|->
name|page_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|result
operator|->
name|offsets
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read page sizes and derive page description offsets from them */
name|result
operator|->
name|offsets
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
operator|->
name|page_count
condition|;
operator|++
name|i
control|)
block|{
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|p2l_stream
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|offsets
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|result
operator|->
name|offsets
index|[
name|i
index|]
operator|+
operator|(
name|apr_off_t
operator|)
name|value
expr_stmt|;
block|}
comment|/* correct the offset values */
name|offset
operator|=
name|packed_stream_offset
argument_list|(
name|rev_file
operator|->
name|p2l_stream
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|result
operator|->
name|page_count
condition|;
operator|++
name|i
control|)
name|result
operator|->
name|offsets
index|[
name|i
index|]
operator|+=
name|offset
expr_stmt|;
comment|/* cache the header data */
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|p2l_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return the result */
operator|*
name|header
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Data structure that describes which p2l page info shall be extracted  * from the cache and contains the fields that receive the result.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|p2l_page_info_baton_t
block|{
comment|/* input variables */
comment|/* revision identifying the index file */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* offset within the page in rev / pack file */
name|apr_off_t
name|offset
decl_stmt|;
comment|/* output variables */
comment|/* page containing OFFSET */
name|apr_size_t
name|page_no
decl_stmt|;
comment|/* first revision in this p2l index */
name|svn_revnum_t
name|first_revision
decl_stmt|;
comment|/* offset within the p2l index file describing this page */
name|apr_off_t
name|start_offset
decl_stmt|;
comment|/* offset within the p2l index file describing the following page */
name|apr_off_t
name|next_offset
decl_stmt|;
comment|/* PAGE_NO * PAGE_SIZE (if<= OFFSET) */
name|apr_off_t
name|page_start
decl_stmt|;
comment|/* total number of pages indexed */
name|apr_size_t
name|page_count
decl_stmt|;
comment|/* size of each page in pack / rev file */
name|apr_uint64_t
name|page_size
decl_stmt|;
block|}
name|p2l_page_info_baton_t
typedef|;
end_typedef

begin_comment
comment|/* From HEADER and the list of all OFFSETS, fill BATON with the page info  * requested by BATON->OFFSET.  */
end_comment

begin_function
specifier|static
name|void
name|p2l_page_info_copy
parameter_list|(
name|p2l_page_info_baton_t
modifier|*
name|baton
parameter_list|,
specifier|const
name|p2l_header_t
modifier|*
name|header
parameter_list|,
specifier|const
name|apr_off_t
modifier|*
name|offsets
parameter_list|)
block|{
comment|/* if the requested offset is out of bounds, return info for    * a zero-sized empty page right behind the last page.    */
if|if
condition|(
name|baton
operator|->
name|offset
operator|/
name|header
operator|->
name|page_size
operator|<
name|header
operator|->
name|page_count
condition|)
block|{
comment|/* This cast is safe because the value is< header->page_count. */
name|baton
operator|->
name|page_no
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|baton
operator|->
name|offset
operator|/
name|header
operator|->
name|page_size
argument_list|)
expr_stmt|;
name|baton
operator|->
name|start_offset
operator|=
name|offsets
index|[
name|baton
operator|->
name|page_no
index|]
expr_stmt|;
name|baton
operator|->
name|next_offset
operator|=
name|offsets
index|[
name|baton
operator|->
name|page_no
operator|+
literal|1
index|]
expr_stmt|;
name|baton
operator|->
name|page_size
operator|=
name|header
operator|->
name|page_size
expr_stmt|;
block|}
else|else
block|{
comment|/* Beyond the last page. */
name|baton
operator|->
name|page_no
operator|=
name|header
operator|->
name|page_count
expr_stmt|;
name|baton
operator|->
name|start_offset
operator|=
name|offsets
index|[
name|baton
operator|->
name|page_no
index|]
expr_stmt|;
name|baton
operator|->
name|next_offset
operator|=
name|offsets
index|[
name|baton
operator|->
name|page_no
index|]
expr_stmt|;
name|baton
operator|->
name|page_size
operator|=
literal|0
expr_stmt|;
block|}
name|baton
operator|->
name|first_revision
operator|=
name|header
operator|->
name|first_revision
expr_stmt|;
name|baton
operator|->
name|page_start
operator|=
call|(
name|apr_off_t
call|)
argument_list|(
name|header
operator|->
name|page_size
operator|*
name|baton
operator|->
name|page_no
argument_list|)
expr_stmt|;
name|baton
operator|->
name|page_count
operator|=
name|header
operator|->
name|page_count
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t: extract the p2l page info  * requested by BATON and return it in BATON.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|p2l_page_info_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* all the pointers to cached data we need */
specifier|const
name|p2l_header_t
modifier|*
name|header
init|=
name|data
decl_stmt|;
specifier|const
name|apr_off_t
modifier|*
name|offsets
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|header
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|offsets
argument_list|)
decl_stmt|;
comment|/* copy data from cache to BATON */
name|p2l_page_info_copy
argument_list|(
name|baton
argument_list|,
name|header
argument_list|,
name|offsets
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the header data structure of the phys-to-log index for revision  * BATON->REVISION in FS.  Return in *BATON all info relevant to read the  * index page for the rev / pack file offset BATON->OFFSET.  Use REV_FILE  * to access on-disk data.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_p2l_page_info
parameter_list|(
name|p2l_page_info_baton_t
modifier|*
name|baton
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|p2l_header_t
modifier|*
name|header
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|void
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
comment|/* look for the header data in our cache */
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_file
operator|->
name|start_revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|&
name|dummy
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|p2l_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|p2l_page_info_func
argument_list|,
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|get_p2l_header
argument_list|(
operator|&
name|header
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|baton
operator|->
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy the requested info into *BATON */
name|p2l_page_info_copy
argument_list|(
name|baton
argument_list|,
name|header
argument_list|,
name|header
operator|->
name|offsets
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a mapping entry from the phys-to-log index STREAM and append it to  * RESULT.  *ITEM_INDEX contains the phys offset for the entry and will  * be moved forward by the size of entry.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_entry
parameter_list|(
name|svn_fs_fs__packed_number_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_off_t
modifier|*
name|item_offset
parameter_list|,
name|svn_revnum_t
modifier|*
name|last_revision
parameter_list|,
name|apr_uint64_t
modifier|*
name|last_compound
parameter_list|,
name|apr_array_header_t
modifier|*
name|result
parameter_list|)
block|{
name|apr_uint64_t
name|value
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
name|entry
decl_stmt|;
name|entry
operator|.
name|offset
operator|=
operator|*
name|item_offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|size
operator|=
operator|(
name|apr_off_t
operator|)
name|value
expr_stmt|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|last_compound
operator|+=
name|decode_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|entry
operator|.
name|type
operator|=
operator|*
name|last_compound
operator|&
literal|7
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|number
operator|=
operator|*
name|last_compound
operator|/
literal|8
expr_stmt|;
comment|/* Verify item type. */
if|if
condition|(
name|entry
operator|.
name|type
operator|>
name|SVN_FS_FS__ITEM_TYPE_CHANGES
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid item type in P2L index"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|entry
operator|.
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_CHANGES
operator|&&
name|entry
operator|.
name|item
operator|.
name|number
operator|!=
name|SVN_FS_FS__ITEM_INDEX_CHANGES
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Changed path list must have item number 1"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|last_revision
operator|+=
operator|(
name|svn_revnum_t
operator|)
name|decode_int
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|entry
operator|.
name|item
operator|.
name|revision
operator|=
operator|*
name|last_revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|.
name|fnv1_checksum
operator|=
operator|(
name|apr_uint32_t
operator|)
name|value
expr_stmt|;
comment|/* Truncating the checksum to 32 bits may have hidden random data in the    * unused extra bits of the on-disk representation (7/8 bit representation    * uses 5 bytes on disk for the 32 bit value, leaving 3 bits unused). */
if|if
condition|(
name|value
operator|>
name|APR_UINT32_MAX
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid FNV1 checksum in P2L index"
argument_list|)
argument_list|)
return|;
comment|/* Some of the index data for empty rev / pack file sections will not be    * used during normal operation.  Thus, we have strict rules for the    * contents of those unused fields. */
if|if
condition|(
name|entry
operator|.
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_UNUSED
condition|)
if|if
condition|(
name|entry
operator|.
name|item
operator|.
name|number
operator|!=
name|SVN_FS_FS__ITEM_INDEX_UNUSED
operator|||
name|entry
operator|.
name|fnv1_checksum
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Empty regions must have item number 0 and checksum 0"
argument_list|)
argument_list|)
return|;
name|APR_ARRAY_PUSH
argument_list|(
name|result
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
operator|=
name|entry
expr_stmt|;
operator|*
name|item_offset
operator|+=
name|entry
operator|.
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the phys-to-log mappings for the cluster beginning at rev file  * offset PAGE_START from the index for START_REVISION in FS.  The data  * can be found in the index page beginning at START_OFFSET with the next  * page beginning at NEXT_OFFSET.  PAGE_SIZE is the L2P index page size.  * Return the relevant index entries in *ENTRIES.  Use REV_FILE to access  * on-disk data.  Allocate *ENTRIES in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_p2l_page
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|apr_off_t
name|start_offset
parameter_list|,
name|apr_off_t
name|next_offset
parameter_list|,
name|apr_off_t
name|page_start
parameter_list|,
name|apr_uint64_t
name|page_size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_uint64_t
name|value
decl_stmt|;
name|apr_array_header_t
modifier|*
name|result
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_fs__p2l_entry_t
argument_list|)
argument_list|)
decl_stmt|;
name|apr_off_t
name|item_offset
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|svn_revnum_t
name|last_revision
decl_stmt|;
name|apr_uint64_t
name|last_compound
decl_stmt|;
comment|/* open index and navigate to page start */
name|SVN_ERR
argument_list|(
name|auto_open_p2l_index
argument_list|(
name|rev_file
argument_list|,
name|fs
argument_list|,
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|packed_stream_seek
argument_list|(
name|rev_file
operator|->
name|p2l_stream
argument_list|,
name|start_offset
argument_list|)
expr_stmt|;
comment|/* read rev file offset of the first page entry (all page entries will    * only store their sizes). */
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|p2l_stream
argument_list|)
argument_list|)
expr_stmt|;
name|item_offset
operator|=
operator|(
name|apr_off_t
operator|)
name|value
expr_stmt|;
comment|/* read all entries of this page */
name|last_revision
operator|=
name|start_revision
expr_stmt|;
name|last_compound
operator|=
literal|0
expr_stmt|;
comment|/* Special case: empty pages. */
if|if
condition|(
name|start_offset
operator|==
name|next_offset
condition|)
block|{
comment|/* Empty page. This only happens if the first entry of the next page        * also covers this page (and possibly more) completely. */
name|SVN_ERR
argument_list|(
name|read_entry
argument_list|(
name|rev_file
operator|->
name|p2l_stream
argument_list|,
operator|&
name|item_offset
argument_list|,
operator|&
name|last_revision
argument_list|,
operator|&
name|last_compound
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Read non-empty page. */
do|do
block|{
name|SVN_ERR
argument_list|(
name|read_entry
argument_list|(
name|rev_file
operator|->
name|p2l_stream
argument_list|,
operator|&
name|item_offset
argument_list|,
operator|&
name|last_revision
argument_list|,
operator|&
name|last_compound
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|packed_stream_offset
argument_list|(
name|rev_file
operator|->
name|p2l_stream
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|offset
operator|<
name|next_offset
condition|)
do|;
comment|/* We should now be exactly at the next offset, i.e. the numbers in        * the stream cannot overlap into the next page description. */
if|if
condition|(
name|offset
operator|!=
name|next_offset
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INDEX_CORRUPTION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"P2L page description overlaps with next page description"
argument_list|)
argument_list|)
return|;
comment|/* if we haven't covered the cluster end yet, we must read the first        * entry of the next page */
if|if
condition|(
name|item_offset
operator|<
name|page_start
operator|+
name|page_size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|packed_stream_get
argument_list|(
operator|&
name|value
argument_list|,
name|rev_file
operator|->
name|p2l_stream
argument_list|)
argument_list|)
expr_stmt|;
name|item_offset
operator|=
operator|(
name|apr_off_t
operator|)
name|value
expr_stmt|;
name|last_revision
operator|=
name|start_revision
expr_stmt|;
name|last_compound
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_entry
argument_list|(
name|rev_file
operator|->
name|p2l_stream
argument_list|,
operator|&
name|item_offset
argument_list|,
operator|&
name|last_revision
argument_list|,
operator|&
name|last_compound
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|entries
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If it cannot be found in FS's caches, read the p2l index page selected  * by BATON->OFFSET from REV_FILE.  Don't read the page if it precedes  * MIN_OFFSET.  Set *END to TRUE if the caller should stop refeching.  *  * *BATON will be updated with the selected page's info and SCRATCH_POOL  * will be used for temporary allocations.  If the data is alread in the  * cache, descrease *LEAKING_BUCKET and increase it otherwise.  With that  * pattern we will still read all pages from the block even if some of  * them survived in the cached.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prefetch_p2l_page
parameter_list|(
name|svn_boolean_t
modifier|*
name|end
parameter_list|,
name|int
modifier|*
name|leaking_bucket
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|p2l_page_info_baton_t
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|min_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|already_cached
decl_stmt|;
name|apr_array_header_t
modifier|*
name|page
decl_stmt|;
name|svn_fs_fs__page_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* fetch the page info */
operator|*
name|end
operator|=
name|FALSE
expr_stmt|;
name|baton
operator|->
name|revision
operator|=
name|baton
operator|->
name|first_revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_p2l_page_info
argument_list|(
name|baton
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|baton
operator|->
name|start_offset
operator|<
name|min_offset
operator|||
operator|!
name|rev_file
operator|->
name|p2l_stream
condition|)
block|{
comment|/* page outside limits -> stop prefetching */
operator|*
name|end
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* do we have that page in our caches already? */
name|assert
argument_list|(
name|baton
operator|->
name|first_revision
operator|<=
name|APR_UINT32_MAX
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
operator|(
name|apr_uint32_t
operator|)
name|baton
operator|->
name|first_revision
expr_stmt|;
name|key
operator|.
name|is_packed
operator|=
name|svn_fs_fs__is_packed_rev
argument_list|(
name|fs
argument_list|,
name|baton
operator|->
name|first_revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|page
operator|=
name|baton
operator|->
name|page_no
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|already_cached
argument_list|,
name|ffd
operator|->
name|p2l_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* yes, already cached */
if|if
condition|(
name|already_cached
condition|)
block|{
comment|/* stop prefetching if most pages are already cached. */
if|if
condition|(
operator|!
operator|--
operator|*
name|leaking_bucket
condition|)
operator|*
name|end
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|++
operator|*
name|leaking_bucket
expr_stmt|;
comment|/* read from disk */
name|SVN_ERR
argument_list|(
name|get_p2l_page
argument_list|(
operator|&
name|page
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|baton
operator|->
name|first_revision
argument_list|,
name|baton
operator|->
name|start_offset
argument_list|,
name|baton
operator|->
name|next_offset
argument_list|,
name|baton
operator|->
name|page_start
argument_list|,
name|baton
operator|->
name|page_size
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* and put it into our cache */
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|p2l_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|page
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Lookup& construct the baton and key information that we will need for  * a P2L page cache lookup.  We want the page covering OFFSET in the rev /  * pack file containing REVSION in FS.  Return the results in *PAGE_INFO_P  * and *KEY_P.  Read data through REV_FILE.  Use SCRATCH_POOL for temporary  * allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_p2l_keys
parameter_list|(
name|p2l_page_info_baton_t
modifier|*
name|page_info_p
parameter_list|,
name|svn_fs_fs__page_cache_key_t
modifier|*
name|key_p
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|p2l_page_info_baton_t
name|page_info
decl_stmt|;
comment|/* request info for the index pages that describes the pack / rev file    * contents at pack / rev file position OFFSET. */
name|page_info
operator|.
name|offset
operator|=
name|offset
expr_stmt|;
name|page_info
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_p2l_page_info
argument_list|(
operator|&
name|page_info
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the offset refers to a non-existent page, bail out */
if|if
condition|(
name|page_info
operator|.
name|page_count
operator|<=
name|page_info
operator|.
name|page_no
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Offset %s too large in revision %ld"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|offset
argument_list|)
argument_list|,
name|revision
argument_list|)
return|;
comment|/* return results */
if|if
condition|(
name|page_info_p
condition|)
operator|*
name|page_info_p
operator|=
name|page_info
expr_stmt|;
comment|/* construct cache key */
if|if
condition|(
name|key_p
condition|)
block|{
name|svn_fs_fs__page_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|assert
argument_list|(
name|page_info
operator|.
name|first_revision
operator|<=
name|APR_UINT32_MAX
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
operator|(
name|apr_uint32_t
operator|)
name|page_info
operator|.
name|first_revision
expr_stmt|;
name|key
operator|.
name|is_packed
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|key
operator|.
name|page
operator|=
name|page_info
operator|.
name|page_no
expr_stmt|;
operator|*
name|key_p
operator|=
name|key
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* qsort-compatible compare function that compares the OFFSET of the  * svn_fs_fs__p2l_entry_t in *LHS with the apr_off_t in *RHS. */
end_comment

begin_function
specifier|static
name|int
name|compare_start_p2l_entry
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
name|lhs
decl_stmt|;
name|apr_off_t
name|start
init|=
operator|*
operator|(
specifier|const
name|apr_off_t
operator|*
operator|)
name|rhs
decl_stmt|;
name|apr_off_t
name|diff
init|=
name|entry
operator|->
name|offset
operator|-
name|start
decl_stmt|;
comment|/* restrict result to int */
return|return
name|diff
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
operator|(
name|diff
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* From the PAGE_ENTRIES array of svn_fs_fs__p2l_entry_t, ordered  * by their OFFSET member, copy all elements overlapping the range  * [BLOCK_START, BLOCK_END) to ENTRIES. */
end_comment

begin_function
specifier|static
name|void
name|append_p2l_entries
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_array_header_t
modifier|*
name|page_entries
parameter_list|,
name|apr_off_t
name|block_start
parameter_list|,
name|apr_off_t
name|block_end
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|int
name|idx
init|=
name|svn_sort__bsearch_lower_bound
argument_list|(
name|page_entries
argument_list|,
operator|&
name|block_start
argument_list|,
name|compare_start_p2l_entry
argument_list|)
decl_stmt|;
comment|/* start at the first entry that overlaps with BLOCK_START */
if|if
condition|(
name|idx
operator|>
literal|0
condition|)
block|{
name|entry
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|page_entries
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
operator|>
name|block_start
condition|)
operator|--
name|idx
expr_stmt|;
block|}
comment|/* copy all entries covering the requested range */
for|for
control|(
init|;
name|idx
operator|<
name|page_entries
operator|->
name|nelts
condition|;
operator|++
name|idx
control|)
block|{
name|entry
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|page_entries
argument_list|,
name|idx
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|offset
operator|>=
name|block_end
condition|)
break|break;
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
operator|=
operator|*
name|entry
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Auxilliary struct passed to p2l_entries_func selecting the relevant  * data range. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|p2l_entries_baton_t
block|{
name|apr_off_t
name|start
decl_stmt|;
name|apr_off_t
name|end
decl_stmt|;
block|}
name|p2l_entries_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t: extract p2l entries from  * the page in DATA which overlap the p2l_entries_baton_t in BATON.  * The target array is already provided in *OUT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|p2l_entries_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|entries
init|=
operator|*
operator|(
name|apr_array_header_t
operator|*
operator|*
operator|)
name|out
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|raw_page
init|=
name|data
decl_stmt|;
name|p2l_entries_baton_t
modifier|*
name|block
init|=
name|baton
decl_stmt|;
comment|/* Make PAGE a readable APR array. */
name|apr_array_header_t
name|page
init|=
operator|*
name|raw_page
decl_stmt|;
name|page
operator|.
name|elts
operator|=
operator|(
name|void
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
name|raw_page
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|raw_page
operator|->
name|elts
argument_list|)
expr_stmt|;
comment|/* append relevant information to result */
name|append_p2l_entries
argument_list|(
name|entries
argument_list|,
operator|&
name|page
argument_list|,
name|block
operator|->
name|start
argument_list|,
name|block
operator|->
name|end
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Body of svn_fs_fs__p2l_index_lookup.  However, do a single index page  * lookup and append the result to the ENTRIES array provided by the caller.  * Use successive calls to cover larger ranges.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|p2l_index_lookup
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_off_t
name|block_start
parameter_list|,
name|apr_off_t
name|block_end
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_fs__page_cache_key_t
name|key
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|p2l_page_info_baton_t
name|page_info
decl_stmt|;
name|apr_array_header_t
modifier|*
name|local_result
init|=
name|entries
decl_stmt|;
comment|/* baton selecting the relevant entries from the one page we access */
name|p2l_entries_baton_t
name|block
decl_stmt|;
name|block
operator|.
name|start
operator|=
name|block_start
expr_stmt|;
name|block
operator|.
name|end
operator|=
name|block_end
expr_stmt|;
comment|/* if we requested an empty range, the result would be empty */
name|SVN_ERR_ASSERT
argument_list|(
name|block_start
operator|<
name|block_end
argument_list|)
expr_stmt|;
comment|/* look for the fist page of the range in our cache */
name|SVN_ERR
argument_list|(
name|get_p2l_keys
argument_list|(
operator|&
name|page_info
argument_list|,
operator|&
name|key
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|block_start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|local_result
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|p2l_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|p2l_entries_func
argument_list|,
operator|&
name|block
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_cached
condition|)
block|{
name|svn_boolean_t
name|end
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_off_t
name|original_page_start
init|=
name|page_info
operator|.
name|page_start
decl_stmt|;
name|int
name|leaking_bucket
init|=
literal|4
decl_stmt|;
name|p2l_page_info_baton_t
name|prefetch_info
init|=
name|page_info
decl_stmt|;
name|apr_array_header_t
modifier|*
name|page_entries
decl_stmt|;
name|apr_off_t
name|max_offset
init|=
name|APR_ALIGN
argument_list|(
name|page_info
operator|.
name|next_offset
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
decl_stmt|;
name|apr_off_t
name|min_offset
init|=
name|APR_ALIGN
argument_list|(
name|page_info
operator|.
name|start_offset
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
operator|-
name|ffd
operator|->
name|block_size
decl_stmt|;
comment|/* Since we read index data in larger chunks, we probably got more        * page data than we requested.  Parse& cache that until either we        * encounter pages already cached or reach the end of the buffer.        */
comment|/* pre-fetch preceding pages */
if|if
condition|(
name|ffd
operator|->
name|use_block_read
condition|)
block|{
name|end
operator|=
name|FALSE
expr_stmt|;
name|prefetch_info
operator|.
name|offset
operator|=
name|original_page_start
expr_stmt|;
while|while
condition|(
name|prefetch_info
operator|.
name|offset
operator|>=
name|prefetch_info
operator|.
name|page_size
operator|&&
operator|!
name|end
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|prefetch_info
operator|.
name|offset
operator|-=
name|prefetch_info
operator|.
name|page_size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prefetch_p2l_page
argument_list|(
operator|&
name|end
argument_list|,
operator|&
name|leaking_bucket
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
operator|&
name|prefetch_info
argument_list|,
name|min_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* fetch page from disk and put it into the cache */
name|SVN_ERR
argument_list|(
name|get_p2l_page
argument_list|(
operator|&
name|page_entries
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|page_info
operator|.
name|first_revision
argument_list|,
name|page_info
operator|.
name|start_offset
argument_list|,
name|page_info
operator|.
name|next_offset
argument_list|,
name|page_info
operator|.
name|page_start
argument_list|,
name|page_info
operator|.
name|page_size
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The last cache entry must not end beyond the range covered by        * this index.  The same applies for any subset of entries. */
if|if
condition|(
name|page_entries
operator|->
name|nelts
condition|)
block|{
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|page_entries
argument_list|,
name|page_entries
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
operator|>
name|page_info
operator|.
name|page_size
operator|*
name|page_info
operator|.
name|page_count
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_INDEX_OVERFLOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Last P2L index entry extends beyond "
literal|"the last page in revision %ld."
argument_list|)
argument_list|,
name|revision
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|p2l_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|page_entries
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* append relevant information to result */
name|append_p2l_entries
argument_list|(
name|entries
argument_list|,
name|page_entries
argument_list|,
name|block_start
argument_list|,
name|block_end
argument_list|)
expr_stmt|;
comment|/* pre-fetch following pages */
if|if
condition|(
name|ffd
operator|->
name|use_block_read
condition|)
block|{
name|end
operator|=
name|FALSE
expr_stmt|;
name|leaking_bucket
operator|=
literal|4
expr_stmt|;
name|prefetch_info
operator|=
name|page_info
expr_stmt|;
name|prefetch_info
operator|.
name|offset
operator|=
name|original_page_start
expr_stmt|;
while|while
condition|(
name|prefetch_info
operator|.
name|next_offset
operator|<
name|max_offset
operator|&&
name|prefetch_info
operator|.
name|page_no
operator|+
literal|1
operator|<
name|prefetch_info
operator|.
name|page_count
operator|&&
operator|!
name|end
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|prefetch_info
operator|.
name|offset
operator|+=
name|prefetch_info
operator|.
name|page_size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prefetch_p2l_page
argument_list|(
operator|&
name|end
argument_list|,
operator|&
name|leaking_bucket
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
operator|&
name|prefetch_info
argument_list|,
name|min_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* We access a valid page (otherwise, we had seen an error in the    * get_p2l_keys request).  Hence, at least one entry must be found. */
name|SVN_ERR_ASSERT
argument_list|(
name|entries
operator|->
name|nelts
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Add an "unused" entry if it extends beyond the end of the data file.    * Since the index page size might be smaller than the current data    * read block size, the trailing "unused" entry in this index may not    * fully cover the end of the last block. */
if|if
condition|(
name|page_info
operator|.
name|page_no
operator|+
literal|1
operator|>=
name|page_info
operator|.
name|page_count
condition|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|entries
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
decl_stmt|;
name|apr_off_t
name|entry_end
init|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
decl_stmt|;
if|if
condition|(
name|entry_end
operator|<
name|block_end
condition|)
block|{
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_UNUSED
condition|)
block|{
comment|/* extend the terminal filler */
name|entry
operator|->
name|size
operator|=
name|block_end
operator|-
name|entry
operator|->
name|offset
expr_stmt|;
block|}
else|else
block|{
comment|/* No terminal filler. Add one. */
name|entry
operator|=
name|apr_array_push
argument_list|(
name|entries
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
name|entry_end
expr_stmt|;
name|entry
operator|->
name|size
operator|=
name|block_end
operator|-
name|entry_end
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|SVN_FS_FS__ITEM_TYPE_UNUSED
expr_stmt|;
name|entry
operator|->
name|fnv1_checksum
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|entry
operator|->
name|item
operator|.
name|number
operator|=
name|SVN_FS_FS__ITEM_INDEX_UNUSED
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_index_lookup
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_off_t
name|block_start
parameter_list|,
name|apr_off_t
name|block_size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|block_end
init|=
name|block_start
operator|+
name|block_size
decl_stmt|;
comment|/* the receiving container */
name|int
name|last_count
init|=
literal|0
decl_stmt|;
name|apr_array_header_t
modifier|*
name|result
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_fs__p2l_entry_t
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Fetch entries page-by-page.  Since the p2l index is supposed to cover    * every single byte in the rev / pack file - even unused sections -    * every iteration must result in some progress. */
while|while
condition|(
name|block_start
operator|<
name|block_end
condition|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|SVN_ERR
argument_list|(
name|p2l_index_lookup
argument_list|(
name|result
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|block_start
argument_list|,
name|block_end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|result
operator|->
name|nelts
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* continue directly behind last item */
name|entry
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|result
argument_list|,
name|result
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
expr_stmt|;
name|block_start
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
expr_stmt|;
comment|/* Some paranoia check.  Successive iterations should never return        * duplicates but if it did, we might get into trouble later on. */
if|if
condition|(
name|last_count
operator|>
literal|0
operator|&&
name|last_count
operator|<
name|result
operator|->
name|nelts
condition|)
block|{
name|entry
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|result
argument_list|,
name|last_count
operator|-
literal|1
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|result
argument_list|,
name|last_count
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
operator|.
name|offset
operator|>=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
argument_list|)
expr_stmt|;
block|}
name|last_count
operator|=
name|result
operator|->
name|nelts
expr_stmt|;
block|}
operator|*
name|entries
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* compare_fn_t comparing a svn_fs_fs__p2l_entry_t at LHS with an offset  * RHS.  */
end_comment

begin_function
specifier|static
name|int
name|compare_p2l_entry_offsets
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
operator|(
specifier|const
name|svn_fs_fs__p2l_entry_t
operator|*
operator|)
name|lhs
decl_stmt|;
name|apr_off_t
name|offset
init|=
operator|*
operator|(
specifier|const
name|apr_off_t
operator|*
operator|)
name|rhs
decl_stmt|;
return|return
name|entry
operator|->
name|offset
operator|<
name|offset
condition|?
operator|-
literal|1
else|:
operator|(
name|entry
operator|->
name|offset
operator|==
name|offset
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Cached data extraction utility.  DATA is a P2L index page, e.g. an APR  * array of svn_fs_fs__p2l_entry_t elements.  Return the entry for the item,  * allocated in RESULT_POOL, starting at OFFSET or NULL if that's not an  * the start offset of any item. Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_fs_fs__p2l_entry_t
modifier|*
name|get_p2l_entry_from_cached_page
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_uint64_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* resolve all pointer values of in-cache data */
specifier|const
name|apr_array_header_t
modifier|*
name|page
init|=
name|data
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
init|=
name|apr_pmemdup
argument_list|(
name|scratch_pool
argument_list|,
name|page
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|page
argument_list|)
argument_list|)
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|entries
operator|->
name|elts
operator|=
operator|(
name|char
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
name|page
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|page
operator|->
name|elts
argument_list|)
expr_stmt|;
comment|/* search of the offset we want */
name|entry
operator|=
name|svn_sort__array_lookup
argument_list|(
name|entries
argument_list|,
operator|&
name|offset
argument_list|,
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_p2l_entry_offsets
argument_list|)
expr_stmt|;
comment|/* return it, if it is a perfect match */
return|return
name|entry
condition|?
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_cache__partial_getter_func_t for P2L index pages, copying  * the entry for the apr_off_t at BATON into *OUT.  *OUT will be NULL if  * there is no matching entry in the index page at DATA.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|p2l_entry_lookup_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
name|get_p2l_entry_from_cached_page
argument_list|(
name|data
argument_list|,
operator|*
operator|(
name|apr_off_t
operator|*
operator|)
name|baton
argument_list|,
name|result_pool
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
operator|*
name|out
operator|=
name|entry
operator|&&
name|entry
operator|->
name|offset
operator|==
operator|*
operator|(
name|apr_off_t
operator|*
operator|)
name|baton
condition|?
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_entry_lookup
parameter_list|(
name|svn_fs_fs__p2l_entry_t
modifier|*
modifier|*
name|entry_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_fs__page_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|p2l_page_info_baton_t
name|page_info
decl_stmt|;
operator|*
name|entry_p
operator|=
name|NULL
expr_stmt|;
comment|/* look for this info in our cache */
name|SVN_ERR
argument_list|(
name|get_p2l_keys
argument_list|(
operator|&
name|page_info
argument_list|,
operator|&
name|key
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|entry_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|p2l_page_cache
argument_list|,
operator|&
name|key
argument_list|,
name|p2l_entry_lookup_func
argument_list|,
operator|&
name|offset
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|is_cached
condition|)
block|{
comment|/* do a standard index lookup.  This is will automatically prefetch        * data to speed up future lookups. */
name|apr_array_header_t
modifier|*
name|entries
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|entry_p
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|p2l_index_lookup
argument_list|(
name|entries
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|offset
operator|+
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the entry that we want. */
operator|*
name|entry_p
operator|=
name|svn_sort__array_lookup
argument_list|(
name|entries
argument_list|,
operator|&
name|offset
argument_list|,
name|NULL
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_p2l_entry_offsets
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_cache__partial_getter_func_t for P2L headers, setting *OUT  * to the largest the first offset not covered by this P2L index.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|p2l_get_max_offset_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|p2l_header_t
modifier|*
name|header
init|=
name|data
decl_stmt|;
name|apr_off_t
name|max_offset
init|=
name|header
operator|->
name|file_size
decl_stmt|;
operator|*
name|out
operator|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
operator|&
name|max_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|max_offset
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Core functionality of to svn_fs_fs__p2l_get_max_offset with identical  * signature. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|p2l_get_max_offset
parameter_list|(
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|p2l_header_t
modifier|*
name|header
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|apr_off_t
modifier|*
name|offset_p
decl_stmt|;
comment|/* look for the header data in our cache */
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_file
operator|->
name|start_revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_file
operator|->
name|is_packed
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|offset_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|p2l_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|p2l_get_max_offset_func
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
operator|*
name|offset
operator|=
operator|*
name|offset_p
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_p2l_header
argument_list|(
operator|&
name|header
argument_list|,
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|offset
operator|=
name|header
operator|->
name|file_size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_get_max_offset
parameter_list|(
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|p2l_get_max_offset
argument_list|(
name|offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Calculate the FNV1 checksum over the offset range in REV_FILE, covered by  * ENTRY.  Store the result in ENTRY->FNV1_CHECKSUM.  Use SCRATCH_POOL for  * temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|calc_fnv1
parameter_list|(
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|unsigned
name|char
name|buffer
index|[
literal|4096
index|]
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|context
init|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_fnv1a_32x4
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_off_t
name|size
init|=
name|entry
operator|->
name|size
decl_stmt|;
comment|/* Special rules apply to unused sections / items.  The data must be a    * sequence of NUL bytes (not checked here) and the checksum is fixed to 0.    */
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_UNUSED
condition|)
block|{
name|entry
operator|->
name|fnv1_checksum
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Read the block and feed it to the checksum calculator. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|to_read
init|=
name|size
operator|>
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|?
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
else|:
operator|(
name|apr_size_t
operator|)
name|size
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|to_read
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|context
argument_list|,
name|buffer
argument_list|,
name|to_read
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|to_read
expr_stmt|;
block|}
comment|/* Store final checksum in ENTRY. */
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|checksum
argument_list|,
name|context
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|fnv1_checksum
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
specifier|const
name|apr_uint32_t
operator|*
operator|)
name|checksum
operator|->
name|digest
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Index (re-)creation utilities.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__p2l_index_from_p2l_entries
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|protoname
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|proto_index
decl_stmt|;
comment|/* Use a subpool for immediate temp file cleanup at the end of this    * function. */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create a proto-index file. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
name|protoname
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_open
argument_list|(
operator|&
name|proto_index
argument_list|,
operator|*
name|protoname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write ENTRIES to proto-index file and calculate checksums as we go. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|calc_fnv1
argument_list|(
name|entry
argument_list|,
name|rev_file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_proto_index_add_entry
argument_list|(
name|proto_index
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert proto-index into final index and move it into position.    * Note that REV_FILE contains the start revision of the shard file if it    * has been packed while REVISION may be somewhere in the middle.  For    * non-packed shards, they will have identical values. */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|proto_index
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Temp file cleanup. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A svn_sort__array compatible comparator function, sorting the  * svn_fs_fs__p2l_entry_t** given in LHS, RHS by revision. */
end_comment

begin_function
specifier|static
name|int
name|compare_p2l_entry_revision
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|lhs_entry
init|=
operator|*
operator|(
specifier|const
name|svn_fs_fs__p2l_entry_t
operator|*
operator|*
operator|)
name|lhs
decl_stmt|;
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|rhs_entry
init|=
operator|*
operator|(
specifier|const
name|svn_fs_fs__p2l_entry_t
operator|*
operator|*
operator|)
name|rhs
decl_stmt|;
if|if
condition|(
name|lhs_entry
operator|->
name|item
operator|.
name|revision
operator|<
name|rhs_entry
operator|->
name|item
operator|.
name|revision
condition|)
return|return
operator|-
literal|1
return|;
return|return
name|lhs_entry
operator|->
name|item
operator|.
name|revision
operator|==
name|rhs_entry
operator|->
name|item
operator|.
name|revision
condition|?
literal|0
else|:
literal|1
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__l2p_index_from_p2l_entries
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|protoname
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|proto_index
decl_stmt|;
comment|/* Use a subpool for immediate temp file cleanup at the end of this    * function. */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_revnum_t
name|last_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* L2P index must be written in revision order.    * Sort ENTRIES accordingly. */
name|svn_sort__array
argument_list|(
name|entries
argument_list|,
name|compare_p2l_entry_revision
argument_list|)
expr_stmt|;
comment|/* Find the first revision in the index    * (must exist since no truly empty revs are allowed). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|;
operator|++
name|i
control|)
name|revision
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
operator|->
name|item
operator|.
name|revision
expr_stmt|;
comment|/* Create the temporary proto-rev file. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
name|protoname
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_open
argument_list|(
operator|&
name|proto_index
argument_list|,
operator|*
name|protoname
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*  Write all entries. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_fs_fs__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_UNUSED
condition|)
continue|continue;
if|if
condition|(
name|last_revision
operator|!=
name|entry
operator|->
name|item
operator|.
name|revision
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_add_revision
argument_list|(
name|proto_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|last_revision
operator|=
name|entry
operator|->
name|item
operator|.
name|revision
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__l2p_proto_index_add_entry
argument_list|(
name|proto_index
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|entry
operator|->
name|item
operator|.
name|number
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Convert proto-index into final index and move it into position. */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|proto_index
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Temp file cleanup. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*  * Standard (de-)serialization functions  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_l2p_header
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|l2p_header_t
modifier|*
name|header
init|=
name|in
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_size_t
name|page_count
init|=
name|header
operator|->
name|page_table_index
index|[
name|header
operator|->
name|revision_count
index|]
decl_stmt|;
name|apr_size_t
name|page_table_size
init|=
name|page_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|header
operator|->
name|page_table
argument_list|)
decl_stmt|;
name|apr_size_t
name|index_size
init|=
operator|(
name|header
operator|->
name|revision_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|header
operator|->
name|page_table_index
argument_list|)
decl_stmt|;
name|apr_size_t
name|data_size
init|=
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|+
name|index_size
operator|+
name|page_table_size
decl_stmt|;
comment|/* serialize header and all its elements */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
name|header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|,
name|data_size
operator|+
literal|32
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* page table index array */
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table_index
argument_list|,
name|index_size
argument_list|)
expr_stmt|;
comment|/* page table array */
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table
argument_list|,
name|page_table_size
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_l2p_header
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|l2p_header_t
modifier|*
name|header
init|=
operator|(
name|l2p_header_t
operator|*
operator|)
name|data
decl_stmt|;
comment|/* resolve the pointers in the struct */
name|svn_temp_deserializer__resolve
argument_list|(
name|header
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table_index
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|header
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|header
operator|->
name|page_table
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|out
operator|=
name|header
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_l2p_page
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|l2p_page_t
modifier|*
name|page
init|=
name|in
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_size_t
name|of_table_size
init|=
name|page
operator|->
name|entry_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|page
operator|->
name|offsets
argument_list|)
decl_stmt|;
comment|/* serialize struct and all its elements */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
name|page
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|page
argument_list|)
argument_list|,
name|of_table_size
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|page
argument_list|)
operator|+
literal|32
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* offsets and sub_items arrays */
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|page
operator|->
name|offsets
argument_list|,
name|of_table_size
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_l2p_page
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|l2p_page_t
modifier|*
name|page
init|=
name|data
decl_stmt|;
comment|/* resolve the pointers in the struct */
name|svn_temp_deserializer__resolve
argument_list|(
name|page
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|page
operator|->
name|offsets
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|out
operator|=
name|page
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_p2l_header
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|p2l_header_t
modifier|*
name|header
init|=
name|in
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_size_t
name|table_size
init|=
operator|(
name|header
operator|->
name|page_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|header
operator|->
name|offsets
argument_list|)
decl_stmt|;
comment|/* serialize header and all its elements */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
name|header
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
argument_list|,
name|table_size
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|header
argument_list|)
operator|+
literal|32
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* offsets array */
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|header
operator|->
name|offsets
argument_list|,
name|table_size
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_p2l_header
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|p2l_header_t
modifier|*
name|header
init|=
name|data
decl_stmt|;
comment|/* resolve the only pointer in the struct */
name|svn_temp_deserializer__resolve
argument_list|(
name|header
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|header
operator|->
name|offsets
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|out
operator|=
name|header
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_p2l_page
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|page
init|=
name|in
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_size_t
name|table_size
init|=
name|page
operator|->
name|elt_size
operator|*
name|page
operator|->
name|nelts
decl_stmt|;
comment|/* serialize array header and all its elements */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
name|page
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|page
argument_list|)
argument_list|,
name|table_size
operator|+
sizeof|sizeof
argument_list|(
operator|*
name|page
argument_list|)
operator|+
literal|32
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* items in the array */
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|page
operator|->
name|elts
argument_list|,
name|table_size
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_p2l_page
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|page
init|=
operator|(
name|apr_array_header_t
operator|*
operator|)
name|data
decl_stmt|;
comment|/* resolve the only pointer in the struct */
name|svn_temp_deserializer__resolve
argument_list|(
name|page
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|page
operator|->
name|elts
argument_list|)
expr_stmt|;
comment|/* patch up members */
name|page
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|page
operator|->
name|nalloc
operator|=
name|page
operator|->
name|nelts
expr_stmt|;
comment|/* done */
operator|*
name|out
operator|=
name|page
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

