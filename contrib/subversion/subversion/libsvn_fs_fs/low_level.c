begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* low_level.c --- low level r/w access to fs_fs file structures  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_comment
comment|/* Headers used to describe node-revision in the revision file. */
end_comment

begin_define
define|#
directive|define
name|HEADER_ID
value|"id"
end_define

begin_define
define|#
directive|define
name|HEADER_TYPE
value|"type"
end_define

begin_define
define|#
directive|define
name|HEADER_COUNT
value|"count"
end_define

begin_define
define|#
directive|define
name|HEADER_PROPS
value|"props"
end_define

begin_define
define|#
directive|define
name|HEADER_TEXT
value|"text"
end_define

begin_define
define|#
directive|define
name|HEADER_CPATH
value|"cpath"
end_define

begin_define
define|#
directive|define
name|HEADER_PRED
value|"pred"
end_define

begin_define
define|#
directive|define
name|HEADER_COPYFROM
value|"copyfrom"
end_define

begin_define
define|#
directive|define
name|HEADER_COPYROOT
value|"copyroot"
end_define

begin_define
define|#
directive|define
name|HEADER_FRESHTXNRT
value|"is-fresh-txn-root"
end_define

begin_define
define|#
directive|define
name|HEADER_MINFO_HERE
value|"minfo-here"
end_define

begin_define
define|#
directive|define
name|HEADER_MINFO_CNT
value|"minfo-cnt"
end_define

begin_comment
comment|/* Kinds that a change can be. */
end_comment

begin_define
define|#
directive|define
name|ACTION_MODIFY
value|"modify"
end_define

begin_define
define|#
directive|define
name|ACTION_ADD
value|"add"
end_define

begin_define
define|#
directive|define
name|ACTION_DELETE
value|"delete"
end_define

begin_define
define|#
directive|define
name|ACTION_REPLACE
value|"replace"
end_define

begin_define
define|#
directive|define
name|ACTION_RESET
value|"reset"
end_define

begin_comment
comment|/* True and False flags. */
end_comment

begin_define
define|#
directive|define
name|FLAG_TRUE
value|"true"
end_define

begin_define
define|#
directive|define
name|FLAG_FALSE
value|"false"
end_define

begin_comment
comment|/* Kinds of representation. */
end_comment

begin_define
define|#
directive|define
name|REP_PLAIN
value|"PLAIN"
end_define

begin_define
define|#
directive|define
name|REP_DELTA
value|"DELTA"
end_define

begin_comment
comment|/* An arbitrary maximum path length, so clients can't run us out of memory  * by giving us arbitrarily large paths. */
end_comment

begin_define
define|#
directive|define
name|FSFS_MAX_PATH_LEN
value|4096
end_define

begin_comment
comment|/* The 256 is an arbitrary size large enough to hold the node id and the  * various flags. */
end_comment

begin_define
define|#
directive|define
name|MAX_CHANGE_LINE_LEN
value|FSFS_MAX_PATH_LEN + 256
end_define

begin_comment
comment|/* Convert the C string in *TEXT to a revision number and return it in *REV.  * Overflows, negative values other than -1 and terminating characters other  * than 0x20 or 0x0 will cause an error.  Set *TEXT to the first char after  * the initial separator or to EOS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|text
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|string
init|=
operator|*
name|text
decl_stmt|;
if|if
condition|(
operator|(
name|string
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|&&
operator|(
name|string
index|[
literal|1
index|]
operator|==
literal|'1'
operator|)
condition|)
block|{
operator|*
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|string
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_revnum_parse
argument_list|(
name|rev
argument_list|,
name|string
argument_list|,
operator|&
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|string
operator|==
literal|' '
condition|)
operator|++
name|string
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|string
operator|!=
literal|'\0'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid character in revision number"
argument_list|)
argument_list|)
return|;
operator|*
name|text
operator|=
name|string
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__parse_revision_trailer
parameter_list|(
name|apr_off_t
modifier|*
name|root_offset
parameter_list|,
name|apr_off_t
modifier|*
name|changes_offset
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|trailer
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|num_bytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* This cast should be safe since the maximum amount read, 64, will      never be bigger than the size of an int. */
name|num_bytes
operator|=
operator|(
name|int
operator|)
name|trailer
operator|->
name|len
expr_stmt|;
comment|/* The last byte should be a newline. */
if|if
condition|(
name|trailer
operator|->
name|len
operator|==
literal|0
operator|||
name|trailer
operator|->
name|data
index|[
name|trailer
operator|->
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision file (r%ld) lacks trailing newline"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
comment|/* Look for the next previous newline. */
for|for
control|(
name|i
operator|=
name|num_bytes
operator|-
literal|2
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
if|if
condition|(
name|trailer
operator|->
name|data
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Final line in revision file (r%ld) longer "
literal|"than 64 characters"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
name|i
operator|++
expr_stmt|;
name|str
operator|=
operator|&
name|trailer
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
comment|/* find the next space */
for|for
control|(
init|;
name|i
operator|<
operator|(
name|num_bytes
operator|-
literal|2
operator|)
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|trailer
operator|->
name|data
index|[
name|i
index|]
operator|==
literal|' '
condition|)
break|break;
if|if
condition|(
name|i
operator|==
operator|(
name|num_bytes
operator|-
literal|2
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Final line in revision file r%ld missing space"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
if|if
condition|(
name|root_offset
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|trailer
operator|->
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_offset
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
block|}
name|i
operator|++
expr_stmt|;
name|str
operator|=
operator|&
name|trailer
operator|->
name|data
index|[
name|i
index|]
expr_stmt|;
comment|/* find the next newline */
for|for
control|(
init|;
name|i
operator|<
name|num_bytes
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|trailer
operator|->
name|data
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|changes_offset
condition|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|trailer
operator|->
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|changes_offset
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_fs_fs__unparse_revision_trailer
parameter_list|(
name|apr_off_t
name|root_offset
parameter_list|,
name|apr_off_t
name|changes_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
literal|" %"
name|APR_OFF_T_FMT
literal|"\n"
argument_list|,
name|root_offset
argument_list|,
name|changes_offset
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__parse_footer
parameter_list|(
name|apr_off_t
modifier|*
name|l2p_offset
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|l2p_checksum
parameter_list|,
name|apr_off_t
modifier|*
name|p2l_offset
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|p2l_checksum
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|footer
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_int64_t
name|val
decl_stmt|;
name|char
modifier|*
name|last_str
init|=
name|footer
operator|->
name|data
decl_stmt|;
comment|/* Get the L2P offset. */
specifier|const
name|char
modifier|*
name|str
init|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
decl_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision footer"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|l2p_offset
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
comment|/* Get the L2P checksum. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision footer"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
name|l2p_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|str
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the P2L offset. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision footer"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|p2l_offset
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
comment|/* Get the P2L checksum. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision footer"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
name|p2l_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|str
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_fs_fs__unparse_footer
parameter_list|(
name|apr_off_t
name|l2p_offset
parameter_list|,
name|svn_checksum_t
modifier|*
name|l2p_checksum
parameter_list|,
name|apr_off_t
name|p2l_offset
parameter_list|,
name|svn_checksum_t
modifier|*
name|p2l_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
literal|" %s %"
name|APR_OFF_T_FMT
literal|" %s"
argument_list|,
name|l2p_offset
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|l2p_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|p2l_offset
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|p2l_checksum
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the next entry in the changes record from file FILE and store    the resulting change in *CHANGE_P.  If there is no next record,    store NULL there.  Perform all allocations from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_change
parameter_list|(
name|change_t
modifier|*
modifier|*
name|change_p
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|svn_boolean_t
name|eof
init|=
name|TRUE
decl_stmt|;
name|change_t
modifier|*
name|change
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|last_str
decl_stmt|,
modifier|*
name|kind_str
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|info
decl_stmt|;
comment|/* Default return value. */
operator|*
name|change_p
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|line
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for a blank line. */
if|if
condition|(
name|eof
operator|||
operator|(
name|line
operator|->
name|len
operator|==
literal|0
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|change
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|change
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|=
operator|&
name|change
operator|->
name|info
expr_stmt|;
name|last_str
operator|=
name|line
operator|->
name|data
expr_stmt|;
comment|/* Get the node-id of the change. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_parse
argument_list|(
operator|&
name|info
operator|->
name|node_rev_id
argument_list|,
name|str
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|node_rev_id
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
comment|/* Get the change type. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
comment|/* Don't bother to check the format number before looking for    * node-kinds: just read them if you find them. */
name|info
operator|->
name|node_kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|kind_str
operator|=
name|strchr
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind_str
condition|)
block|{
comment|/* Cap off the end of "str" (the action). */
operator|*
name|kind_str
operator|=
literal|'\0'
expr_stmt|;
name|kind_str
operator|++
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|kind_str
argument_list|,
name|SVN_FS_FS__KIND_FILE
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|->
name|node_kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|kind_str
argument_list|,
name|SVN_FS_FS__KIND_DIR
argument_list|)
operator|==
literal|0
condition|)
name|info
operator|->
name|node_kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_MODIFY
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_modify
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_ADD
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_add
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_DELETE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_delete
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_REPLACE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|ACTION_RESET
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_reset
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change kind in rev file"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get the text-mod flag. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_TRUE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|text_mod
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|text_mod
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid text-mod flag in rev-file"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get the prop-mod flag. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_TRUE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|prop_mod
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|prop_mod
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid prop-mod flag in rev-file"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Get the mergeinfo-mod flag if given.  Otherwise, the next thing      is the path starting with a slash.  Also, we must initialize the      flag explicitly because 0 is not valid for a svn_tristate_t. */
name|info
operator|->
name|mergeinfo_mod
operator|=
name|svn_tristate_unknown
expr_stmt|;
if|if
condition|(
operator|*
name|last_str
operator|!=
literal|'/'
condition|)
block|{
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid changes line in rev-file"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_TRUE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|mergeinfo_mod
operator|=
name|svn_tristate_true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|FLAG_FALSE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|mergeinfo_mod
operator|=
name|svn_tristate_false
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid mergeinfo-mod flag in rev-file"
argument_list|)
argument_list|)
return|;
block|}
block|}
comment|/* Get the changed path. */
if|if
condition|(
operator|!
name|svn_fspath__is_canonical
argument_list|(
name|last_str
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid path in changes line"
argument_list|)
argument_list|)
return|;
name|change
operator|->
name|path
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|last_str
argument_list|)
expr_stmt|;
name|change
operator|->
name|path
operator|.
name|data
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
comment|/* Read the next line, the copyfrom line. */
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|line
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|copyfrom_known
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eof
operator|||
name|line
operator|->
name|len
operator|==
literal|0
condition|)
block|{
name|info
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|info
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|last_str
operator|=
name|line
operator|->
name|data
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_revnum
argument_list|(
operator|&
name|info
operator|->
name|copyfrom_rev
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|last_str
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fspath__is_canonical
argument_list|(
name|last_str
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid copy-from path in changes line"
argument_list|)
argument_list|)
return|;
name|info
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|last_str
argument_list|)
expr_stmt|;
block|}
operator|*
name|change_p
operator|=
name|change
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__read_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|change_t
modifier|*
name|change
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Pre-allocate enough room for most change lists.      (will be auto-expanded as necessary).       Chose the default to just below 2^N such that the doubling reallocs      will request roughly 2^M bytes from the OS without exceeding the      respective two-power by just a few bytes (leaves room array and APR      node overhead for large enough M).    */
operator|*
name|changes
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|63
argument_list|,
sizeof|sizeof
argument_list|(
name|change_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_change
argument_list|(
operator|&
name|change
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|change
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|changes
argument_list|,
name|change_t
operator|*
argument_list|)
operator|=
name|change
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_change
argument_list|(
operator|&
name|change
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__read_changes_incrementally
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_fs_fs__change_receiver_t
name|change_receiver
parameter_list|,
name|void
modifier|*
name|change_receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|change_t
modifier|*
name|change
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_change
argument_list|(
operator|&
name|change
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
condition|)
name|SVN_ERR
argument_list|(
name|change_receiver
argument_list|(
name|change_receiver_baton
argument_list|,
name|change
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|change
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write a single change entry, path PATH, change CHANGE, to STREAM.     Only include the node kind field if INCLUDE_NODE_KIND is true.  Only    include the mergeinfo-mod field if INCLUDE_MERGEINFO_MODS is true.    All temporary allocations are in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_change_entry
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_path_change2_t
modifier|*
name|change
parameter_list|,
name|svn_boolean_t
name|include_node_kind
parameter_list|,
name|svn_boolean_t
name|include_mergeinfo_mods
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|idstr
decl_stmt|;
specifier|const
name|char
modifier|*
name|change_string
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|kind_string
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|mergeinfo_string
init|=
literal|""
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|change
operator|->
name|change_kind
condition|)
block|{
case|case
name|svn_fs_path_change_modify
case|:
name|change_string
operator|=
name|ACTION_MODIFY
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_add
case|:
name|change_string
operator|=
name|ACTION_ADD
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
name|change_string
operator|=
name|ACTION_DELETE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_replace
case|:
name|change_string
operator|=
name|ACTION_REPLACE
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_reset
case|:
name|change_string
operator|=
name|ACTION_RESET
expr_stmt|;
break|break;
default|default:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change type %d"
argument_list|)
argument_list|,
name|change
operator|->
name|change_kind
argument_list|)
return|;
block|}
if|if
condition|(
name|change
operator|->
name|node_rev_id
condition|)
name|idstr
operator|=
name|svn_fs_fs__id_unparse
argument_list|(
name|change
operator|->
name|node_rev_id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
expr_stmt|;
else|else
name|idstr
operator|=
name|ACTION_RESET
expr_stmt|;
if|if
condition|(
name|include_node_kind
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
operator|||
name|change
operator|->
name|node_kind
operator|==
name|svn_node_file
argument_list|)
expr_stmt|;
name|kind_string
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"-%s"
argument_list|,
name|change
operator|->
name|node_kind
operator|==
name|svn_node_dir
condition|?
name|SVN_FS_FS__KIND_DIR
else|:
name|SVN_FS_FS__KIND_FILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|include_mergeinfo_mods
operator|&&
name|change
operator|->
name|mergeinfo_mod
operator|!=
name|svn_tristate_unknown
condition|)
name|mergeinfo_string
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|" %s"
argument_list|,
name|change
operator|->
name|mergeinfo_mod
operator|==
name|svn_tristate_true
condition|?
name|FLAG_TRUE
else|:
name|FLAG_FALSE
argument_list|)
expr_stmt|;
name|buf
operator|=
name|svn_stringbuf_createf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s %s%s %s %s%s %s\n"
argument_list|,
name|idstr
argument_list|,
name|change_string
argument_list|,
name|kind_string
argument_list|,
name|change
operator|->
name|text_mod
condition|?
name|FLAG_TRUE
else|:
name|FLAG_FALSE
argument_list|,
name|change
operator|->
name|prop_mod
condition|?
name|FLAG_TRUE
else|:
name|FLAG_FALSE
argument_list|,
name|mergeinfo_string
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|change
operator|->
name|copyfrom_rev
argument_list|)
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|buf
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld %s"
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendbyte
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Write all change info in one write call. */
name|len
operator|=
name|buf
operator|->
name|len
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__write_changes
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|changes
parameter_list|,
name|svn_boolean_t
name|terminate_list
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|include_node_kinds
init|=
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_KIND_IN_CHANGED_FORMAT
decl_stmt|;
name|svn_boolean_t
name|include_mergeinfo_mods
init|=
name|ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_MERGEINFO_IN_CHANGED_FORMAT
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_changed_paths
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* For the sake of the repository administrator sort the changes so      that the final file is deterministic and repeatable, however the      rest of the FSFS code doesn't require any particular order here.       Also, this sorting is only effective in writing all entries with      a single call as write_final_changed_path_info() does.  For the      list being written incrementally during transaction, we actually      *must not* change the order of entries from different calls.    */
name|sorted_changed_paths
operator|=
name|svn_sort__hash
argument_list|(
name|changes
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Write all items to disk in the new order. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_changed_paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|change
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_changed_paths
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|value
expr_stmt|;
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_changed_paths
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|key
expr_stmt|;
comment|/* Write out the new entry into the final rev-file. */
name|SVN_ERR
argument_list|(
name|write_change_entry
argument_list|(
name|stream
argument_list|,
name|path
argument_list|,
name|change
argument_list|,
name|include_node_kinds
argument_list|,
name|include_mergeinfo_mods
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|terminate_list
condition|)
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a revision file FILE that has been pre-positioned at the    beginning of a Node-Rev header block, read in that header block and    store it in the apr_hash_t HEADERS.  All allocations will be from    RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_header_block
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|headers
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
operator|*
name|headers
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|header_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|value
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|name_len
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|header_str
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
operator|||
name|header_str
operator|->
name|len
operator|==
literal|0
condition|)
break|break;
comment|/* end of header block */
while|while
condition|(
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|!=
literal|':'
condition|)
block|{
if|if
condition|(
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Found malformed header '%s' in "
literal|"revision file"
argument_list|)
argument_list|,
name|header_str
operator|->
name|data
argument_list|)
return|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* Create a 'name' string and point to it. */
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|=
name|header_str
operator|->
name|data
expr_stmt|;
name|name_len
operator|=
name|i
expr_stmt|;
comment|/* Check if we have enough data to parse. */
if|if
condition|(
name|i
operator|+
literal|2
operator|>
name|header_str
operator|->
name|len
condition|)
block|{
comment|/* Restore the original line for the error. */
name|header_str
operator|->
name|data
index|[
name|i
index|]
operator|=
literal|':'
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Found malformed header '%s' in "
literal|"revision file"
argument_list|)
argument_list|,
name|header_str
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Skip over the NULL byte and the space following it. */
name|i
operator|+=
literal|2
expr_stmt|;
name|value
operator|=
name|header_str
operator|->
name|data
operator|+
name|i
expr_stmt|;
comment|/* header_str is safely in our pool, so we can use bits of it as          key and value. */
name|apr_hash_set
argument_list|(
operator|*
name|headers
argument_list|,
name|name
argument_list|,
name|name_len
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__parse_representation
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|rep_p
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|text
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|text
operator|->
name|data
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
decl_stmt|;
name|rep
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rep_p
operator|=
name|rep
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_revnum
argument_list|(
operator|&
name|rep
operator|->
name|revision
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize transaction info (never stored) */
name|svn_fs_fs__id_txn_reset
argument_list|(
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
expr_stmt|;
comment|/* while in transactions, it is legal to simply write "-1" */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|rep
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|item_index
operator|=
operator|(
name|apr_uint64_t
operator|)
name|val
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|size
operator|=
operator|(
name|svn_filesize_t
operator|)
name|val
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|expanded_size
operator|=
operator|(
name|svn_filesize_t
operator|)
name|val
expr_stmt|;
comment|/* Read in the MD5 hash. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|str
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|!=
operator|(
name|APR_MD5_DIGESTSIZE
operator|*
literal|2
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|str
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The remaining fields are only used for formats>= 4, so check that. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Read the SHA1 hash. */
if|if
condition|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|!=
operator|(
name|APR_SHA1_DIGESTSIZE
operator|*
literal|2
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|str
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|->
name|has_sha1
operator|=
name|checksum
operator|!=
name|NULL
expr_stmt|;
name|memcpy
argument_list|(
name|rep
operator|->
name|sha1_digest
argument_list|,
name|checksum
operator|->
name|digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|->
name|sha1_digest
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the uniquifier. */
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|"/"
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_txn_parse
argument_list|(
operator|&
name|rep
operator|->
name|uniquifier
operator|.
name|noderev_txn_id
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
operator|||
operator|*
name|str
operator|!=
literal|'_'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
operator|++
name|str
expr_stmt|;
name|rep
operator|->
name|uniquifier
operator|.
name|number
operator|=
name|svn__base36toui64
argument_list|(
operator|&
name|end
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed text representation offset line in node-rev"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrap svn_fs_fs__parse_representation(), extracting its TXN_ID from our    NODEREV_ID, and adding an error message. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_rep_offsets
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|rep_p
parameter_list|,
name|char
modifier|*
name|string
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|noderev_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_fs__parse_representation
argument_list|(
name|rep_p
argument_list|,
name|svn_stringbuf_create_wrap
argument_list|(
name|string
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|id_unparsed
decl_stmt|;
specifier|const
name|char
modifier|*
name|where
decl_stmt|;
name|id_unparsed
operator|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev_id
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|where
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"While reading representation offsets "
literal|"for node-revision '%s':"
argument_list|)
argument_list|,
name|noderev_id
condition|?
name|id_unparsed
operator|->
name|data
else|:
literal|"(null)"
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|where
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|*
name|rep_p
operator|)
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
if|if
condition|(
name|noderev_id
condition|)
operator|(
operator|*
name|rep_p
operator|)
operator|->
name|txn_id
operator|=
operator|*
name|svn_fs_fs__id_txn_id
argument_list|(
name|noderev_id
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__read_noderev
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|headers
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|char
modifier|*
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|noderev_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_header_block
argument_list|(
operator|&
name|headers
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the node-rev id. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_ID
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
comment|/* ### More information: filename/offset coordinates */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing id field in node-rev"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_parse
argument_list|(
operator|&
name|noderev
operator|->
name|id
argument_list|,
name|value
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev_id
operator|=
name|value
expr_stmt|;
comment|/* for error messages later */
comment|/* Read the type. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|value
operator|==
name|NULL
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|SVN_FS_FS__KIND_FILE
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
name|SVN_FS_FS__KIND_DIR
argument_list|)
operator|)
condition|)
comment|/* ### s/kind/type/ */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing kind field in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|kind
operator|=
operator|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|SVN_FS_FS__KIND_FILE
argument_list|)
operator|==
literal|0
operator|)
condition|?
name|svn_node_file
else|:
name|svn_node_dir
expr_stmt|;
comment|/* Read the 'count' field. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_COUNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
operator|&
name|noderev
operator|->
name|predecessor_count
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|noderev
operator|->
name|predecessor_count
operator|=
literal|0
expr_stmt|;
comment|/* Get the properties location. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_PROPS
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_rep_offsets
argument_list|(
operator|&
name|noderev
operator|->
name|prop_rep
argument_list|,
name|value
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the data location. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_TEXT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_rep_offsets
argument_list|(
operator|&
name|noderev
operator|->
name|data_rep
argument_list|,
name|value
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the created path. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_CPATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing cpath field in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|svn_fspath__is_canonical
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Non-canonical cpath field in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Get the predecessor ID. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_PRED
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_parse
argument_list|(
operator|&
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|value
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the copyroot. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_COPYROOT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|parse_revnum
argument_list|(
operator|&
name|noderev
operator|->
name|copyroot_rev
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fspath__is_canonical
argument_list|(
name|value
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed copyroot line in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Get the copyfrom. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_COPYFROM
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|parse_revnum
argument_list|(
operator|&
name|noderev
operator|->
name|copyfrom_rev
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|value
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed copyfrom line in node-rev '%s'"
argument_list|)
argument_list|,
name|noderev_id
argument_list|)
return|;
name|noderev
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
comment|/* Get whether this is a fresh txn root. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_FRESHTXNRT
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|is_fresh_txn_root
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* Get the mergeinfo count. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_MINFO_CNT
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|noderev
operator|->
name|mergeinfo_count
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|noderev
operator|->
name|mergeinfo_count
operator|=
literal|0
expr_stmt|;
comment|/* Get whether *this* node has mergeinfo. */
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|HEADER_MINFO_HERE
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|has_mergeinfo
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
expr_stmt|;
operator|*
name|noderev_p
operator|=
name|noderev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a textual representation of the DIGEST of given KIND.  * If IS_NULL is TRUE, no digest is available.  * Allocate the result in RESULT_POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|format_digest
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|digest
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|svn_boolean_t
name|is_null
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_checksum_t
name|checksum
decl_stmt|;
name|checksum
operator|.
name|digest
operator|=
name|digest
expr_stmt|;
name|checksum
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
if|if
condition|(
name|is_null
condition|)
return|return
literal|"(null)"
return|;
return|return
name|svn_checksum_to_cstring_display
argument_list|(
operator|&
name|checksum
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stringbuf_t
modifier|*
name|svn_fs_fs__unparse_representation
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|int
name|format
parameter_list|,
name|svn_boolean_t
name|mutable_rep_truncated
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|char
name|buffer
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
if|if
condition|(
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
operator|&&
name|mutable_rep_truncated
condition|)
return|return
name|svn_stringbuf_ncreate
argument_list|(
literal|"-1"
argument_list|,
literal|2
argument_list|,
name|result_pool
argument_list|)
return|;
if|if
condition|(
name|format
operator|<
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
operator|||
operator|!
name|rep
operator|->
name|has_sha1
condition|)
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"%ld %"
name|APR_UINT64_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %s"
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|rep
operator|->
name|size
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|,
name|format_digest
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|,
name|svn_checksum_md5
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|svn__ui64tobase36
argument_list|(
name|buffer
argument_list|,
name|rep
operator|->
name|uniquifier
operator|.
name|number
argument_list|)
expr_stmt|;
return|return
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"%ld %"
name|APR_UINT64_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|" %s %s %s/_%s"
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|rep
operator|->
name|size
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|,
name|format_digest
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|,
name|svn_checksum_md5
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|format_digest
argument_list|(
name|rep
operator|->
name|sha1_digest
argument_list|,
name|svn_checksum_sha1
argument_list|,
operator|!
name|rep
operator|->
name|has_sha1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_fs_fs__id_txn_unparse
argument_list|(
operator|&
name|rep
operator|->
name|uniquifier
operator|.
name|noderev_txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|buffer
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__write_noderev
parameter_list|(
name|svn_stream_t
modifier|*
name|outfile
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|int
name|format
parameter_list|,
name|svn_boolean_t
name|include_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_ID
literal|": %s\n"
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_TYPE
literal|": %s\n"
argument_list|,
operator|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
condition|?
name|SVN_FS_FS__KIND_FILE
else|:
name|SVN_FS_FS__KIND_DIR
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_id
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_PRED
literal|": %s\n"
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_COUNT
literal|": %d\n"
argument_list|,
name|noderev
operator|->
name|predecessor_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_TEXT
literal|": %s\n"
argument_list|,
name|svn_fs_fs__unparse_representation
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|format
argument_list|,
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_PROPS
literal|": %s\n"
argument_list|,
name|svn_fs_fs__unparse_representation
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|format
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_CPATH
literal|": %s\n"
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|copyfrom_path
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_COPYFROM
literal|": %ld"
literal|" %s\n"
argument_list|,
name|noderev
operator|->
name|copyfrom_rev
argument_list|,
name|noderev
operator|->
name|copyfrom_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|noderev
operator|->
name|copyroot_rev
operator|!=
name|svn_fs_fs__id_rev
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|noderev
operator|->
name|copyroot_path
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_COPYROOT
literal|": %ld"
literal|" %s\n"
argument_list|,
name|noderev
operator|->
name|copyroot_rev
argument_list|,
name|noderev
operator|->
name|copyroot_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|is_fresh_txn_root
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|outfile
argument_list|,
name|HEADER_FRESHTXNRT
literal|": y\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_mergeinfo
condition|)
block|{
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|outfile
argument_list|,
name|scratch_pool
argument_list|,
name|HEADER_MINFO_CNT
literal|": %"
name|APR_INT64_T_FMT
literal|"\n"
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|has_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_puts
argument_list|(
name|outfile
argument_list|,
name|HEADER_MINFO_HERE
literal|": y\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_stream_puts
argument_list|(
name|outfile
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__read_rep_header
parameter_list|(
name|svn_fs_fs__rep_header_t
modifier|*
modifier|*
name|header
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|last_str
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|svn_boolean_t
name|eol
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buffer
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eol
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|header
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|header
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|header
operator|)
operator|->
name|header_size
operator|=
name|buffer
operator|->
name|len
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
operator|->
name|data
argument_list|,
name|REP_PLAIN
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
operator|*
name|header
operator|)
operator|->
name|type
operator|=
name|svn_fs_fs__rep_plain
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|buffer
operator|->
name|data
argument_list|,
name|REP_DELTA
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* This is a delta against the empty stream. */
operator|(
operator|*
name|header
operator|)
operator|->
name|type
operator|=
name|svn_fs_fs__rep_self_delta
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|(
operator|*
name|header
operator|)
operator|->
name|type
operator|=
name|svn_fs_fs__rep_delta
expr_stmt|;
comment|/* We have hopefully a DELTA vs. a non-empty base revision. */
name|last_str
operator|=
name|buffer
operator|->
name|data
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
operator|||
operator|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|REP_DELTA
argument_list|)
operator|!=
literal|0
operator|)
condition|)
goto|goto
name|error
goto|;
name|SVN_ERR
argument_list|(
name|parse_revnum
argument_list|(
operator|&
operator|(
operator|*
name|header
operator|)
operator|->
name|base_revision
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|last_str
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|error
goto|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|header
operator|)
operator|->
name|base_item_index
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|last_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|str
condition|)
goto|goto
name|error
goto|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|header
operator|)
operator|->
name|base_length
operator|=
operator|(
name|svn_filesize_t
operator|)
name|val
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
name|error
label|:
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed representation header"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__write_rep_header
parameter_list|(
name|svn_fs_fs__rep_header_t
modifier|*
name|header
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
switch|switch
condition|(
name|header
operator|->
name|type
condition|)
block|{
case|case
name|svn_fs_fs__rep_plain
case|:
name|text
operator|=
name|REP_PLAIN
literal|"\n"
expr_stmt|;
break|break;
case|case
name|svn_fs_fs__rep_self_delta
case|:
name|text
operator|=
name|REP_DELTA
literal|"\n"
expr_stmt|;
break|break;
default|default:
name|text
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|REP_DELTA
literal|" %ld %"
name|APR_OFF_T_FMT
literal|" %"
name|SVN_FILESIZE_T_FMT
literal|"\n"
argument_list|,
name|header
operator|->
name|base_revision
argument_list|,
name|header
operator|->
name|base_item_index
argument_list|,
name|header
operator|->
name|base_length
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_puts
argument_list|(
name|stream
argument_list|,
name|text
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

