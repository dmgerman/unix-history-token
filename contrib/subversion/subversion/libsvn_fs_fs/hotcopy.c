begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* hotcopy.c --- FS hotcopy functionality for FSFS  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"hotcopy.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"recovery.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Like svn_io_dir_file_copy(), but doesn't copy files that exist at  * the destination and do not differ in terms of kind, size, and mtime.  * Set *SKIPPED_P to FALSE only if the file was copied, do not change  * the value in *SKIPPED_P otherwise. SKIPPED_P may be NULL if not  * required. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_io_dir_file_copy
parameter_list|(
name|svn_boolean_t
modifier|*
name|skipped_p
parameter_list|,
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_io_dirent2_t
modifier|*
name|src_dirent
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dst_dirent
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_target
decl_stmt|;
comment|/* Does the destination already exist? If not, we must copy it. */
name|dst_target
operator|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dst_dirent
argument_list|,
name|dst_target
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_dirent
operator|->
name|kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* If the destination's stat information indicates that the file        * is equal to the source, don't bother copying the file again. */
name|src_target
operator|=
name|svn_dirent_join
argument_list|(
name|src_path
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|src_dirent
argument_list|,
name|src_target
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_dirent
operator|->
name|kind
operator|==
name|dst_dirent
operator|->
name|kind
operator|&&
name|src_dirent
operator|->
name|special
operator|==
name|dst_dirent
operator|->
name|special
operator|&&
name|src_dirent
operator|->
name|filesize
operator|==
name|dst_dirent
operator|->
name|filesize
operator|&&
name|src_dirent
operator|->
name|mtime
operator|<=
name|dst_dirent
operator|->
name|mtime
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|skipped_p
condition|)
operator|*
name|skipped_p
operator|=
name|FALSE
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_dir_file_copy
argument_list|(
name|src_path
argument_list|,
name|dst_path
argument_list|,
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *NAME_P to the UTF-8 representation of directory entry NAME.  * NAME is in the internal encoding used by APR; PARENT is in  * UTF-8 and in internal (not local) style.  *  * Use PARENT only for generating an error string if the conversion  * fails because NAME could not be represented in UTF-8.  In that  * case, return a two-level error in which the outer error's message  * mentions PARENT, but the inner error's message does not mention  * NAME (except possibly in hex) since NAME may not be printable.  * Such a compound error at least allows the user to go looking in the  * right directory for the problem.  *  * If there is any other error, just return that error directly.  *  * If there is any error, the effect on *NAME_P is undefined.  *  * *NAME_P and NAME may refer to the same storage.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|entry_name_to_utf8
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|name_p
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|parent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_path_cstring_to_utf8
argument_list|(
name|name_p
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|APR_EINVAL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Error converting entry "
literal|"in directory '%s' to UTF-8"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* Like svn_io_copy_dir_recursively() but doesn't copy regular files that  * exist in the destination and do not differ from the source in terms of  * kind, size, and mtime. Set *SKIPPED_P to FALSE only if at least one  * file was copied, do not change the value in *SKIPPED_P otherwise.  * SKIPPED_P may be NULL if not required. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_io_copy_dir_recursively
parameter_list|(
name|svn_boolean_t
modifier|*
name|skipped_p
parameter_list|,
specifier|const
name|char
modifier|*
name|src
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_parent
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_basename
parameter_list|,
name|svn_boolean_t
name|copy_perms
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_path
decl_stmt|;
name|apr_dir_t
modifier|*
name|this_dir
decl_stmt|;
name|apr_finfo_t
name|this_entry
decl_stmt|;
name|apr_int32_t
name|flags
init|=
name|APR_FINFO_TYPE
operator||
name|APR_FINFO_NAME
decl_stmt|;
comment|/* Make a subpool for recursion */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* The 'dst_path' is simply dst_parent/dst_basename */
name|dst_path
operator|=
name|svn_dirent_join
argument_list|(
name|dst_parent
argument_list|,
name|dst_basename
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Sanity checks:  SRC and DST_PARENT are directories, and      DST_BASENAME doesn't already exist in DST_PARENT. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Source '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_parent
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination '%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dst_parent
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_path
argument_list|,
operator|&
name|kind
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory. */
comment|/* ### TODO: copy permissions (needs apr_file_attrs_get()) */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop over the dirents in SRC.  ('.' and '..' are auto-excluded) */
name|SVN_ERR
argument_list|(
name|svn_io_dir_open
argument_list|(
operator|&
name|this_dir
argument_list|,
name|src
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
init|;
name|status
operator|==
name|APR_SUCCESS
condition|;
name|status
operator|=
name|apr_dir_read
argument_list|(
operator|&
name|this_entry
argument_list|,
name|flags
argument_list|,
name|this_dir
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|this_entry
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|this_entry
operator|.
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
continue|continue;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|entryname_utf8
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|entry_name_to_utf8
argument_list|(
operator|&
name|entryname_utf8
argument_list|,
name|this_entry
operator|.
name|name
argument_list|,
name|src
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_REG
condition|)
comment|/* regular file */
block|{
name|SVN_ERR
argument_list|(
name|hotcopy_io_dir_file_copy
argument_list|(
name|skipped_p
argument_list|,
name|src
argument_list|,
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_LNK
condition|)
comment|/* symlink */
block|{
specifier|const
name|char
modifier|*
name|src_target
init|=
name|svn_dirent_join
argument_list|(
name|src
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_target
init|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_link
argument_list|(
name|src_target
argument_list|,
name|dst_target
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|this_entry
operator|.
name|filetype
operator|==
name|APR_DIR
condition|)
comment|/* recurse */
block|{
specifier|const
name|char
modifier|*
name|src_target
decl_stmt|;
comment|/* Prevent infinite recursion by filtering off our                  newly created destination path. */
if|if
condition|(
name|strcmp
argument_list|(
name|src
argument_list|,
name|dst_parent
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|entryname_utf8
argument_list|,
name|dst_basename
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
name|src_target
operator|=
name|svn_dirent_join
argument_list|(
name|src
argument_list|,
name|entryname_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|skipped_p
argument_list|,
name|src_target
argument_list|,
name|dst_path
argument_list|,
name|entryname_utf8
argument_list|,
name|copy_perms
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### support other APR node types someday?? */
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|status
argument_list|)
operator|)
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't read directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|status
operator|=
name|apr_dir_close
argument_list|(
name|this_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Error closing directory '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* Free any memory used by recursion */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy an un-packed revision or revprop file for revision REV from SRC_SUBDIR  * to DST_SUBDIR. Assume a sharding layout based on MAX_FILES_PER_DIR.  * Set *SKIPPED_P to FALSE only if the file was copied, do not change the  * value in *SKIPPED_P otherwise. SKIPPED_P may be NULL if not required.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_copy_shard_file
parameter_list|(
name|svn_boolean_t
modifier|*
name|skipped_p
parameter_list|,
specifier|const
name|char
modifier|*
name|src_subdir
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_subdir
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src_subdir_shard
init|=
name|src_subdir
decl_stmt|,
modifier|*
name|dst_subdir_shard
init|=
name|dst_subdir
decl_stmt|;
if|if
condition|(
name|max_files_per_dir
condition|)
block|{
specifier|const
name|char
modifier|*
name|shard
init|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
decl_stmt|;
name|src_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|src_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|dst_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|dst_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|%
name|max_files_per_dir
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|dst_subdir_shard
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|dst_subdir
argument_list|,
name|dst_subdir_shard
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|hotcopy_io_dir_file_copy
argument_list|(
name|skipped_p
argument_list|,
name|src_subdir_shard
argument_list|,
name|dst_subdir_shard
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy a packed shard containing revision REV, and which contains  * MAX_FILES_PER_DIR revisions, from SRC_FS to DST_FS.  * Update *DST_MIN_UNPACKED_REV in case the shard is new in DST_FS.  * Do not re-copy data which already exists in DST_FS.  * Set *SKIPPED_P to FALSE only if at least one part of the shard  * was copied, do not change the value in *SKIPPED_P otherwise.  * SKIPPED_P may be NULL if not required.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_copy_packed_shard
parameter_list|(
name|svn_boolean_t
modifier|*
name|skipped_p
parameter_list|,
name|svn_revnum_t
modifier|*
name|dst_min_unpacked_rev
parameter_list|,
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|src_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|packed_shard
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_subdir_packed_shard
decl_stmt|;
name|svn_revnum_t
name|revprop_rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Copy the packed shard. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|packed_shard
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
name|PATH_EXT_PACKED_SHARD
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|src_subdir_packed_shard
operator|=
name|svn_dirent_join
argument_list|(
name|src_subdir
argument_list|,
name|packed_shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|skipped_p
argument_list|,
name|src_subdir_packed_shard
argument_list|,
name|dst_subdir
argument_list|,
name|packed_shard
argument_list|,
name|TRUE
comment|/* copy_perms */
argument_list|,
name|NULL
comment|/* cancel_func */
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy revprops belonging to revisions in this pack. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
operator|||
name|src_ffd
operator|->
name|min_unpacked_rev
operator|<
name|rev
operator|+
name|max_files_per_dir
condition|)
block|{
comment|/* copy unpacked revprops rev by rev */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|revprop_rev
operator|=
name|rev
init|;
name|revprop_rev
operator|<
name|rev
operator|+
name|max_files_per_dir
condition|;
name|revprop_rev
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_copy_shard_file
argument_list|(
name|skipped_p
argument_list|,
name|src_subdir
argument_list|,
name|dst_subdir
argument_list|,
name|revprop_rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* revprop for revision 0 will never be packed */
if|if
condition|(
name|rev
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|hotcopy_copy_shard_file
argument_list|(
name|skipped_p
argument_list|,
name|src_subdir
argument_list|,
name|dst_subdir
argument_list|,
literal|0
argument_list|,
name|max_files_per_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* packed revprops folder */
name|packed_shard
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
name|PATH_EXT_PACKED_SHARD
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|src_subdir_packed_shard
operator|=
name|svn_dirent_join
argument_list|(
name|src_subdir
argument_list|,
name|packed_shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|skipped_p
argument_list|,
name|src_subdir_packed_shard
argument_list|,
name|dst_subdir
argument_list|,
name|packed_shard
argument_list|,
name|TRUE
comment|/* copy_perms */
argument_list|,
name|NULL
comment|/* cancel_func */
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If necessary, update the min-unpacked rev file in the hotcopy. */
if|if
condition|(
operator|*
name|dst_min_unpacked_rev
operator|<
name|rev
operator|+
name|max_files_per_dir
condition|)
block|{
operator|*
name|dst_min_unpacked_rev
operator|=
name|rev
operator|+
name|max_files_per_dir
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_min_unpacked_rev
argument_list|(
name|dst_fs
argument_list|,
operator|*
name|dst_min_unpacked_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove file PATH, if it exists - even if it is read-only.  * Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_remove_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Make the rev file writable and remove it. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove revision or revprop files between START_REV (inclusive) and  * END_REV (non-inclusive) from folder DST_SUBDIR in DST_FS.  Assume  * sharding as per MAX_FILES_PER_DIR.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_remove_files
parameter_list|(
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_subdir
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|shard
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_subdir_shard
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Pre-compute paths for initial shard. */
name|shard
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|start_rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|dst_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|dst_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If necessary, update paths for shard. */
if|if
condition|(
name|rev
operator|!=
name|start_rev
operator|&&
name|rev
operator|%
name|max_files_per_dir
operator|==
literal|0
condition|)
block|{
name|shard
operator|=
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
operator|/
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|dst_subdir_shard
operator|=
name|svn_dirent_join
argument_list|(
name|dst_subdir
argument_list|,
name|shard
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* remove files for REV */
name|SVN_ERR
argument_list|(
name|hotcopy_remove_file
argument_list|(
name|svn_dirent_join
argument_list|(
name|dst_subdir_shard
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove revisions between START_REV (inclusive) and END_REV (non-inclusive)  * from DST_FS. Assume sharding as per MAX_FILES_PER_DIR.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_remove_rev_files
parameter_list|(
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|start_rev
operator|<=
name|end_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_remove_files
argument_list|(
name|dst_fs
argument_list|,
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove revision properties between START_REV (inclusive) and END_REV  * (non-inclusive) from DST_FS. Assume sharding as per MAX_FILES_PER_DIR.  * Use SCRATCH_POOL for temporary allocations.  Revision 0 revprops will  * not be deleted. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_remove_revprop_files
parameter_list|(
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|start_rev
operator|<=
name|end_rev
argument_list|)
expr_stmt|;
comment|/* don't delete rev 0 props */
name|SVN_ERR
argument_list|(
name|hotcopy_remove_files
argument_list|(
name|dst_fs
argument_list|,
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|start_rev
condition|?
name|start_rev
else|:
literal|1
argument_list|,
name|end_rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that DST_FS is a suitable destination for an incremental  * hotcopy from SRC_FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_incremental_check_preconditions
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* We only support incremental hotcopy between the same format. */
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|!=
name|dst_ffd
operator|->
name|format
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The FSFS format (%d) of the hotcopy source does not match the "
literal|"FSFS format (%d) of the hotcopy destination; please upgrade "
literal|"both repositories to the same format"
argument_list|)
argument_list|,
name|src_ffd
operator|->
name|format
argument_list|,
name|dst_ffd
operator|->
name|format
argument_list|)
return|;
comment|/* Make sure the UUID of source and destination match up.    * We don't want to copy over a different repository. */
if|if
condition|(
name|strcmp
argument_list|(
name|src_fs
operator|->
name|uuid
argument_list|,
name|dst_fs
operator|->
name|uuid
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_UUID_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The UUID of the hotcopy source does "
literal|"not match the UUID of the hotcopy "
literal|"destination"
argument_list|)
argument_list|)
return|;
comment|/* Also require same shard size. */
if|if
condition|(
name|src_ffd
operator|->
name|max_files_per_dir
operator|!=
name|dst_ffd
operator|->
name|max_files_per_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The sharding layout configuration "
literal|"of the hotcopy source does not match "
literal|"the sharding layout configuration of "
literal|"the hotcopy destination"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Remove folder PATH.  Ignore errors due to the sub-tree not being empty.  * CANCEL_FUNC and CANCEL_BATON do the usual thing.  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_folder
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_remove_dir2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Copy the revision and revprop files (possibly sharded / packed) from  * SRC_FS to DST_FS.  Do not re-copy data which already exists in DST_FS.  * When copying packed or unpacked shards, checkpoint the result in DST_FS  * for every shard by updating the 'current' file if necessary.  Assume  * the>= SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT filesystem format without  * global next-ID counters.  Indicate progress via the optional NOTIFY_FUNC  * callback using NOTIFY_BATON.  Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_revisions
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|src_youngest
parameter_list|,
name|svn_revnum_t
name|dst_youngest
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
specifier|const
name|char
modifier|*
name|src_revs_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_revs_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|src_revprops_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_revprops_dir
parameter_list|,
name|svn_fs_hotcopy_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|max_files_per_dir
init|=
name|src_ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|svn_revnum_t
name|src_min_unpacked_rev
decl_stmt|;
name|svn_revnum_t
name|dst_min_unpacked_rev
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Copy the min unpacked rev, and read its value. */
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_min_unpacked_rev
argument_list|(
operator|&
name|src_min_unpacked_rev
argument_list|,
name|src_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_min_unpacked_rev
argument_list|(
operator|&
name|dst_min_unpacked_rev
argument_list|,
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only support packs coming from the hotcopy source.        * The destination should not be packed independently from        * the source. This also catches the case where users accidentally        * swap the source and destination arguments. */
if|if
condition|(
name|src_min_unpacked_rev
operator|<
name|dst_min_unpacked_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The hotcopy destination already contains "
literal|"more packed revisions (%lu) than the "
literal|"hotcopy source contains (%lu)"
argument_list|)
argument_list|,
name|dst_min_unpacked_rev
operator|-
literal|1
argument_list|,
name|src_min_unpacked_rev
operator|-
literal|1
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_dir_file_copy
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_MIN_UNPACKED_REV
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|src_min_unpacked_rev
operator|=
literal|0
expr_stmt|;
name|dst_min_unpacked_rev
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * Copy the necessary rev files.    */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* First, copy packed shards. */
for|for
control|(
name|rev
operator|=
literal|0
init|;
name|rev
operator|<
name|src_min_unpacked_rev
condition|;
name|rev
operator|+=
name|max_files_per_dir
control|)
block|{
name|svn_boolean_t
name|skipped
init|=
name|TRUE
decl_stmt|;
name|svn_revnum_t
name|pack_end_rev
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the packed shard. */
name|SVN_ERR
argument_list|(
name|hotcopy_copy_packed_shard
argument_list|(
operator|&
name|skipped
argument_list|,
operator|&
name|dst_min_unpacked_rev
argument_list|,
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|pack_end_rev
operator|=
name|rev
operator|+
name|max_files_per_dir
operator|-
literal|1
expr_stmt|;
comment|/* Whenever this pack did not previously exist in the destination,        * update 'current' to the most recent packed rev (so readers can see        * new revisions which arrived in this pack). */
if|if
condition|(
name|pack_end_rev
operator|>
name|dst_youngest
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_current
argument_list|(
name|dst_fs
argument_list|,
name|pack_end_rev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* When notifying about packed shards, make things simpler by either        * reporting a full revision range, i.e [pack start, pack end] or        * reporting nothing. There is one case when this approach might not        * be exact (incremental hotcopy with a pack replacing last unpacked        * revisions), but generally this is good enough. */
if|if
condition|(
name|notify_func
operator|&&
operator|!
name|skipped
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|rev
argument_list|,
name|pack_end_rev
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Remove revision files which are now packed. */
if|if
condition|(
name|incremental
condition|)
block|{
name|SVN_ERR
argument_list|(
name|hotcopy_remove_rev_files
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|rev
operator|+
name|max_files_per_dir
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|hotcopy_remove_revprop_files
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|rev
operator|+
name|max_files_per_dir
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now that all revisions have moved into the pack, the original        * rev dir can be removed. */
name|SVN_ERR
argument_list|(
name|remove_folder
argument_list|(
name|svn_fs_fs__path_rev_shard
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev
operator|>
literal|0
operator|&&
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_PACKED_REVPROP_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|remove_folder
argument_list|(
name|svn_fs_fs__path_revprops_shard
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rev
operator|==
name|src_min_unpacked_rev
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|src_min_unpacked_rev
operator|==
name|dst_min_unpacked_rev
argument_list|)
expr_stmt|;
comment|/* Now, copy pairs of non-packed revisions and revprop files.    * If necessary, update 'current' after copying all files from a shard. */
for|for
control|(
init|;
name|rev
operator|<=
name|src_youngest
condition|;
name|rev
operator|++
control|)
block|{
name|svn_boolean_t
name|skipped
init|=
name|TRUE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copying non-packed revisions is racy in case the source repository is        * being packed concurrently with this hotcopy operation. The race can        * happen with FS formats prior to SVN_FS_FS__MIN_PACK_LOCK_FORMAT that        * support packed revisions. With the pack lock, however, the race is        * impossible, because hotcopy and pack operations block each other.        *        * We assume that all revisions coming after 'min-unpacked-rev' really        * are unpacked and that's not necessarily true with concurrent packing.        * Don't try to be smart in this edge case, because handling it properly        * might require copying *everything* from the start. Just abort the        * hotcopy with an ENOENT (revision file moved to a pack, so it is no        * longer where we expect it to be). */
comment|/* Copy the rev file. */
name|SVN_ERR
argument_list|(
name|hotcopy_copy_shard_file
argument_list|(
operator|&
name|skipped
argument_list|,
name|src_revs_dir
argument_list|,
name|dst_revs_dir
argument_list|,
name|rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the revprop file. */
name|SVN_ERR
argument_list|(
name|hotcopy_copy_shard_file
argument_list|(
operator|&
name|skipped
argument_list|,
name|src_revprops_dir
argument_list|,
name|dst_revprops_dir
argument_list|,
name|rev
argument_list|,
name|max_files_per_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Whenever this revision did not previously exist in the destination,        * checkpoint the progress via 'current' (do that once per full shard        * in order not to slow things down). */
if|if
condition|(
name|rev
operator|>
name|dst_youngest
condition|)
block|{
if|if
condition|(
name|max_files_per_dir
operator|&&
operator|(
name|rev
operator|%
name|max_files_per_dir
operator|==
literal|0
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_current
argument_list|(
name|dst_fs
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|notify_func
operator|&&
operator|!
name|skipped
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|rev
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* We assume that all revisions were copied now, i.e. we didn't exit the    * above loop early. 'rev' was last incremented during exit of the loop. */
name|SVN_ERR_ASSERT
argument_list|(
name|rev
operator|==
name|src_youngest
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Shortcut for the revision and revprop copying for old (1 or 2) format  * filesystems without sharding and packing.  Copy the non-sharded revision  * and revprop files from SRC_FS to DST_FS.  Do not re-copy data which  * already exists in DST_FS.  Do not somehow checkpoint the results in  * the 'current' file in DST_FS.  Indicate progress via the optional  * NOTIFY_FUNC callback using NOTIFY_BATON.  Use POOL for temporary  * allocations.  Also see hotcopy_revisions().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_revisions_old
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_revnum_t
name|src_youngest
parameter_list|,
specifier|const
name|char
modifier|*
name|src_revs_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_revs_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|src_revprops_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_revprops_dir
parameter_list|,
name|svn_fs_hotcopy_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
for|for
control|(
name|rev
operator|=
literal|0
init|;
name|rev
operator|<=
name|src_youngest
condition|;
name|rev
operator|++
control|)
block|{
name|svn_boolean_t
name|skipped
init|=
name|TRUE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_dir_file_copy
argument_list|(
operator|&
name|skipped
argument_list|,
name|src_revs_dir
argument_list|,
name|dst_revs_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_io_dir_file_copy
argument_list|(
operator|&
name|skipped
argument_list|,
name|src_revprops_dir
argument_list|,
name|dst_revprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
operator|&&
operator|!
name|skipped
condition|)
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|rev
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for hotcopy_body(). */
end_comment

begin_struct
struct|struct
name|hotcopy_body_baton
block|{
name|svn_fs_t
modifier|*
name|src_fs
decl_stmt|;
name|svn_fs_t
modifier|*
name|dst_fs
decl_stmt|;
name|svn_boolean_t
name|incremental
decl_stmt|;
name|svn_fs_hotcopy_notify_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Perform a hotcopy, either normal or incremental.  *  * Normal hotcopy assumes that the destination exists as an empty  * directory. It behaves like an incremental hotcopy except that  * none of the copied files already exist in the destination.  *  * An incremental hotcopy copies only changed or new files to the destination,  * and removes files from the destination no longer present in the source.  * While the incremental hotcopy is running, readers should still be able  * to access the destintation repository without error and should not see  * revisions currently in progress of being copied. Readers are able to see  * new fully copied revisions even if the entire incremental hotcopy procedure  * has not yet completed.  *  * Writers are blocked out completely during the entire incremental hotcopy  * process to ensure consistency. This function assumes that the repository  * write-lock is held.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|hotcopy_body_baton
modifier|*
name|hbb
init|=
name|baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|src_fs
init|=
name|hbb
operator|->
name|src_fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|dst_fs
init|=
name|hbb
operator|->
name|dst_fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|dst_ffd
init|=
name|dst_fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|incremental
init|=
name|hbb
operator|->
name|incremental
decl_stmt|;
name|svn_fs_hotcopy_notify_t
name|notify_func
init|=
name|hbb
operator|->
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
init|=
name|hbb
operator|->
name|notify_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
init|=
name|hbb
operator|->
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
init|=
name|hbb
operator|->
name|cancel_baton
decl_stmt|;
name|svn_revnum_t
name|src_youngest
decl_stmt|;
name|apr_uint64_t
name|src_next_node_id
decl_stmt|;
name|apr_uint64_t
name|src_next_copy_id
decl_stmt|;
name|svn_revnum_t
name|dst_youngest
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_revprops_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_revprops_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_revs_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_revs_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_subdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_subdir
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* Try to copy the config.    *    * ### We try copying the config file before doing anything else,    * ### because higher layers will abort the hotcopy if we throw    * ### an error from this function, and that renders the hotcopy    * ### unusable anyway. */
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_CONFIG_FILE
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_io_dir_file_copy
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* 1.6.0 to 1.6.11 did not copy the configuration file during                * hotcopy. So if we're hotcopying a repository which has been                * created as a hotcopy itself, it's possible that fsfs.conf                * does not exist. Ask the user to re-create it.                *                * ### It would be nice to make this a non-fatal error,                * ### but this function does not get an svn_fs_t object                * ### so we have no way of just printing a warning via                * ### the fs->warning() callback. */
specifier|const
name|char
modifier|*
name|src_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_relpath
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|config_relpath
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err2
operator|=
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|src_abspath
argument_list|,
name|src_fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
name|err2
operator|=
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|dst_abspath
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|err2
argument_list|)
argument_list|)
return|;
comment|/* ### hack: strip off the 'db/' directory from paths so                * ### they make sense to the user */
name|src_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|src_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|dst_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrapf
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Failed to create hotcopy at '%s'. "
literal|"The file '%s' is missing from the source "
literal|"repository. Please create this file, for "
literal|"instance by running 'svnadmin upgrade %s'"
argument_list|)
argument_list|,
name|dst_abspath
argument_list|,
name|config_relpath
argument_list|,
name|src_abspath
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the youngest revision in the source and destination.    * We only support hotcopies from sources with an equal or greater amount    * of revisions than the destination.    * This also catches the case where users accidentally swap the    * source and destination arguments. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_current
argument_list|(
operator|&
name|src_youngest
argument_list|,
operator|&
name|src_next_node_id
argument_list|,
operator|&
name|src_next_copy_id
argument_list|,
name|src_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|incremental
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|dst_youngest
argument_list|,
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_youngest
operator|<
name|dst_youngest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The hotcopy destination already contains more revisions "
literal|"(%lu) than the hotcopy source contains (%lu); are source "
literal|"and destination swapped?"
argument_list|)
argument_list|,
name|dst_youngest
argument_list|,
name|src_youngest
argument_list|)
return|;
block|}
else|else
name|dst_youngest
operator|=
literal|0
expr_stmt|;
name|src_revs_dir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_revs_dir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|src_revprops_dir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_revprops_dir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Ensure that the required folders exist in the destination    * before actually copying the revisions and revprops. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|dst_revs_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|dst_revprops_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Split the logic for new and old FS formats. The latter is much simpler    * due to the absense of sharding and packing. However, it requires special    * care when updating the 'current' file (which contains not just the    * revision number, but also the next-ID counters). */
if|if
condition|(
name|src_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|hotcopy_revisions
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|src_youngest
argument_list|,
name|dst_youngest
argument_list|,
name|incremental
argument_list|,
name|src_revs_dir
argument_list|,
name|dst_revs_dir
argument_list|,
name|src_revprops_dir
argument_list|,
name|dst_revprops_dir
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_current
argument_list|(
name|dst_fs
argument_list|,
name|src_youngest
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|hotcopy_revisions_old
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|src_youngest
argument_list|,
name|src_revs_dir
argument_list|,
name|dst_revs_dir
argument_list|,
name|src_revprops_dir
argument_list|,
name|dst_revprops_dir
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_current
argument_list|(
name|dst_fs
argument_list|,
name|src_youngest
argument_list|,
name|src_next_node_id
argument_list|,
name|src_next_copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the locks tree.    * This is racy in case readers are currently trying to list locks in    * the destination. However, we need to get rid of stale locks.    * This is the simplest way of doing this, so we accept this small race. */
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|dst_subdir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_subdir
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_copy_dir_recursively
argument_list|(
name|src_subdir
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_LOCKS_DIR
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now copy the node-origins cache tree. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|PATH_NODE_ORIGINS_DIR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_subdir
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|hotcopy_io_copy_dir_recursively
argument_list|(
name|NULL
argument_list|,
name|src_subdir
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_NODE_ORIGINS_DIR
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*    * NB: Data copied below is only read by writers, not readers.    *     Writers are still locked out at this point.    */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_REP_SHARING_FORMAT
condition|)
block|{
comment|/* Copy the rep cache and then remove entries for revisions        * that did not make it into the destination. */
name|src_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|REP_CACHE_DB_NAME
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dst_subdir
operator|=
name|svn_dirent_join
argument_list|(
name|dst_fs
operator|->
name|path
argument_list|,
name|REP_CACHE_DB_NAME
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|src_subdir
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_sqlite__hotcopy
argument_list|(
name|src_subdir
argument_list|,
name|dst_subdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The source might have r/o flags set on it - which would be              carried over to the copy. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_write
argument_list|(
name|dst_subdir
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__del_rep_reference
argument_list|(
name|dst_fs
argument_list|,
name|src_youngest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Copy the txn-current file. */
if|if
condition|(
name|dst_ffd
operator|->
name|format
operator|>=
name|SVN_FS_FS__MIN_TXN_CURRENT_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_dir_file_copy
argument_list|(
name|src_fs
operator|->
name|path
argument_list|,
name|dst_fs
operator|->
name|path
argument_list|,
name|PATH_TXN_CURRENT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create an empty filesystem at DST_FS at DST_PATH with the same  * configuration as SRC_FS (uuid, format, and other parameters).  * After creation DST_FS has no revisions, not even revision zero. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|hotcopy_create_empty_dest
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|src_ffd
init|=
name|src_fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Create the DST_FS repository with the same layout as SRC_FS. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__create_file_tree
argument_list|(
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|src_ffd
operator|->
name|format
argument_list|,
name|src_ffd
operator|->
name|max_files_per_dir
argument_list|,
name|src_ffd
operator|->
name|use_log_addressing
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy the UUID.  Hotcopy destination receives a new instance ID, but    * has the same filesystem UUID as the source. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_uuid
argument_list|(
name|dst_fs
argument_list|,
name|src_fs
operator|->
name|uuid
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove revision 0 contents.  Otherwise, it may not get overwritten    * due to having a newer timestamp. */
name|SVN_ERR
argument_list|(
name|hotcopy_remove_file
argument_list|(
name|svn_fs_fs__path_rev
argument_list|(
name|dst_fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_remove_file
argument_list|(
name|svn_fs_fs__path_revprops
argument_list|(
name|dst_fs
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This filesystem is ready.  Stamp it with a format number.  Fail if    * the 'format' file should already exist. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__write_format
argument_list|(
name|dst_fs
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__hotcopy_prepare_target
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|incremental
condition|)
block|{
specifier|const
name|char
modifier|*
name|dst_format_abspath
decl_stmt|;
name|svn_node_kind_t
name|dst_format_kind
decl_stmt|;
comment|/* Check destination format to be sure we know how to incrementally        * hotcopy to the destination FS. */
name|dst_format_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dst_path
argument_list|,
name|PATH_FORMAT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|dst_format_abspath
argument_list|,
operator|&
name|dst_format_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst_format_kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Destination doesn't exist yet. Perform a normal hotcopy to a            * empty destination using the same configuration as the source. */
name|SVN_ERR
argument_list|(
name|hotcopy_create_empty_dest
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Check the existing repository. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open
argument_list|(
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|hotcopy_incremental_check_preconditions
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Start out with an empty destination using the same configuration        * as the source. */
name|SVN_ERR
argument_list|(
name|hotcopy_create_empty_dest
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__hotcopy
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|svn_fs_hotcopy_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|hotcopy_body_baton
name|hbb
decl_stmt|;
name|hbb
operator|.
name|src_fs
operator|=
name|src_fs
expr_stmt|;
name|hbb
operator|.
name|dst_fs
operator|=
name|dst_fs
expr_stmt|;
name|hbb
operator|.
name|incremental
operator|=
name|incremental
expr_stmt|;
name|hbb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|hbb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|hbb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|hbb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__with_all_locks
argument_list|(
name|dst_fs
argument_list|,
name|hotcopy_body
argument_list|,
operator|&
name|hbb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

