begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cached_data.c --- cached (read) access to FSFS data  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_delta_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_delta/delta.h"
end_include

begin_comment
comment|/* for SVN_DELTA_WINDOW_SIZE */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* forward-declare. See implementation for the docstring */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|block_read
parameter_list|(
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|revision_file
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Defined this to enable access logging via dgb__log_access #define SVN_FS_FS__LOG_ACCESS  */
end_comment

begin_comment
comment|/* When SVN_FS_FS__LOG_ACCESS has been defined, write a line to console  * showing where REVISION, ITEM_INDEX is located in FS and use ITEM to  * show details on it's contents if not NULL.  To support format 6 and  * earlier repos, ITEM_TYPE (SVN_FS_FS__ITEM_TYPE_*) must match ITEM.  * Use SCRATCH_POOL for temporary allocations.  *  * For pre-format7 repos, the display will be restricted.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dbg_log_access
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|apr_uint32_t
name|item_type
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* no-op if this macro is not defined */
ifdef|#
directive|ifdef
name|SVN_FS_FS__LOG_ACCESS
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|end_offset
init|=
literal|0
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|types
index|[]
init|=
block|{
literal|"<n/a>"
block|,
literal|"frep "
block|,
literal|"drep "
block|,
literal|"fprop"
block|,
literal|"dprop"
block|,
literal|"node "
block|,
literal|"chgs "
block|,
literal|"rep  "
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|types
index|[
name|item_type
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pack
init|=
literal|""
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* determine rev / pack file offset */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|item_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* constructing the pack file description */
if|if
condition|(
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
condition|)
name|pack
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%4ld|"
argument_list|,
name|revision
operator|/
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
expr_stmt|;
comment|/* construct description if possible */
if|if
condition|(
name|item_type
operator|==
name|SVN_FS_FS__ITEM_TYPE_NODEREV
operator|&&
name|item
operator|!=
name|NULL
condition|)
block|{
name|node_revision_t
modifier|*
name|node
init|=
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|data_rep
init|=
name|node
operator|->
name|data_rep
condition|?
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|" d=%ld/%"
name|APR_UINT64_T_FMT
argument_list|,
name|node
operator|->
name|data_rep
operator|->
name|revision
argument_list|,
name|node
operator|->
name|data_rep
operator|->
name|item_index
argument_list|)
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_rep
init|=
name|node
operator|->
name|prop_rep
condition|?
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|" p=%ld/%"
name|APR_UINT64_T_FMT
argument_list|,
name|node
operator|->
name|prop_rep
operator|->
name|revision
argument_list|,
name|node
operator|->
name|prop_rep
operator|->
name|item_index
argument_list|)
else|:
literal|""
decl_stmt|;
name|description
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s   (pc=%d%s%s)"
argument_list|,
name|node
operator|->
name|created_path
argument_list|,
name|node
operator|->
name|predecessor_count
argument_list|,
name|data_rep
argument_list|,
name|prop_rep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item_type
operator|==
name|SVN_FS_FS__ITEM_TYPE_ANY_REP
condition|)
block|{
name|svn_fs_fs__rep_header_t
modifier|*
name|header
init|=
name|item
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
name|description
operator|=
literal|"  (txdelta window)"
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_plain
condition|)
name|description
operator|=
literal|"  PLAIN"
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_self_delta
condition|)
name|description
operator|=
literal|"  DELTA"
expr_stmt|;
else|else
name|description
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"  DELTA against %ld/%"
name|APR_UINT64_T_FMT
argument_list|,
name|header
operator|->
name|base_revision
argument_list|,
name|header
operator|->
name|base_item_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item_type
operator|==
name|SVN_FS_FS__ITEM_TYPE_CHANGES
operator|&&
name|item
operator|!=
name|NULL
condition|)
block|{
name|apr_array_header_t
modifier|*
name|changes
init|=
name|item
decl_stmt|;
switch|switch
condition|(
name|changes
operator|->
name|nelts
condition|)
block|{
case|case
literal|0
case|:
name|description
operator|=
literal|"  no change"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|description
operator|=
literal|"  1 change"
expr_stmt|;
break|break;
default|default:
name|description
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"  %d changes"
argument_list|,
name|changes
operator|->
name|nelts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* some info is only available in format7 repos */
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* reverse index lookup: get item description in ENTRY */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_entry_lookup
argument_list|(
operator|&
name|entry
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
comment|/* more details */
name|end_offset
operator|=
name|offset
operator|+
name|entry
operator|->
name|size
expr_stmt|;
name|type
operator|=
name|types
index|[
name|entry
operator|->
name|type
index|]
expr_stmt|;
block|}
comment|/* line output */
name|printf
argument_list|(
literal|"%5s%4lx:%04lx -%4lx:%04lx %s %7ld %5"
name|APR_UINT64_T_FMT
literal|"   %s\n"
argument_list|,
name|pack
argument_list|,
call|(
name|long
call|)
argument_list|(
name|offset
operator|/
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|offset
operator|%
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|end_offset
operator|/
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|end_offset
operator|%
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
name|type
argument_list|,
name|revision
argument_list|,
name|item_index
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* reduced logging for format 6 and earlier */
name|printf
argument_list|(
literal|"%5s%10"
name|APR_UINT64_T_HEX_FMT
literal|" %s %7ld %7"
name|APR_UINT64_T_FMT
expr|\
literal|"   %s\n"
argument_list|,
name|pack
argument_list|,
call|(
name|apr_uint64_t
call|)
argument_list|(
name|offset
argument_list|)
argument_list|,
name|type
argument_list|,
name|revision
argument_list|,
name|item_index
argument_list|,
name|description
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Convenience wrapper around svn_io_file_aligned_seek, taking filesystem    FS instead of a block size. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|aligned_seek
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_off_t
modifier|*
name|buffer_start
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|file
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|buffer_start
argument_list|,
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open the revision file for revision REV in filesystem FS and store    the newly opened file in FILE.  Seek to location OFFSET before    returning.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_revision
parameter_list|(
name|svn_fs_fs__revision_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_uint64_t
name|item
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_off_t
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|item
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|rev_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the representation REP for a node-revision in filesystem FS, seek    to its position and store the newly opened file in FILE.  Perform    temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_transaction
parameter_list|(
name|svn_fs_fs__revision_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_proto_rev_file
argument_list|(
name|file
argument_list|,
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
operator|(
operator|*
name|file
operator|)
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a node-id ID, and a representation REP in filesystem FS, open    the correct file and seek to the correction location.  Store this    file in *FILE_P.  Perform any allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_representation
parameter_list|(
name|svn_fs_fs__revision_file_t
modifier|*
modifier|*
name|file_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
condition|)
return|return
name|open_and_seek_revision
argument_list|(
name|file_p
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|open_and_seek_transaction
argument_list|(
name|file_p
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|err_dangling_id
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ID_NOT_FOUND
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Reference to non-existent node '%s' in filesystem '%s'"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if FS is of a format that supports block-read and the    feature has been enabled. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|use_block_read
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
operator|&&
name|ffd
operator|->
name|use_block_read
return|;
block|}
end_function

begin_comment
comment|/* Get the node-revision for the node ID in FS.    Set *NODEREV_P to the new node-revision structure, allocated in POOL.    See svn_fs_fs__get_node_revision, which wraps this and adds another    error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_revision_body
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|svn_fs_fs__id_is_txn
argument_list|(
name|id
argument_list|)
condition|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* This is a transaction node-rev.  Its storage logic is very          different from that of rev / pack files. */
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|svn_fs_fs__path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err_dangling_id
argument_list|(
name|fs
argument_list|,
name|id
argument_list|)
argument_list|)
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
name|noderev_p
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_fs__revision_file_t
modifier|*
name|revision_file
decl_stmt|;
comment|/* noderevs in rev / pack files can be cached */
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|rev_item
init|=
name|svn_fs_fs__id_rev_item
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev_item
operator|->
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rev_item
operator|->
name|number
expr_stmt|;
comment|/* Not found or not applicable. Try a noderev cache lookup.        * If that succeeds, we are done here. */
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|noderev_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|node_revision_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* read the data from disk */
name|SVN_ERR
argument_list|(
name|open_and_seek_revision
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev_item
operator|->
name|revision
argument_list|,
name|rev_item
operator|->
name|number
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_block_read
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* block-read will parse the whole block and will also return              the one noderev that we need right now. */
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|noderev_p
argument_list|,
name|fs
argument_list|,
name|rev_item
operator|->
name|revision
argument_list|,
name|rev_item
operator|->
name|number
argument_list|,
name|revision_file
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* physical addressing mode reading, parsing and caching */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
name|noderev_p
argument_list|,
name|revision_file
operator|->
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Workaround issue #4031: is-fresh-txn-root in revision files. */
operator|(
operator|*
name|noderev_p
operator|)
operator|->
name|is_fresh_txn_root
operator|=
name|FALSE
expr_stmt|;
comment|/* The noderev is not in cache, yet. Add it, if caching has been enabled. */
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|node_revision_cache
argument_list|,
operator|&
name|key
argument_list|,
operator|*
name|noderev_p
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|revision_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_node_revision
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|rev_item
init|=
name|svn_fs_fs__id_rev_item
argument_list|(
name|id
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|get_node_revision_body
argument_list|(
name|noderev_p
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
condition|)
block|{
name|svn_string_t
modifier|*
name|id_string
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
literal|"Corrupt node-revision '%s'"
argument_list|,
name|id_string
operator|->
name|data
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|dbg_log_access
argument_list|(
name|fs
argument_list|,
name|rev_item
operator|->
name|revision
argument_list|,
name|rev_item
operator|->
name|number
argument_list|,
operator|*
name|noderev_p
argument_list|,
name|SVN_FS_FS__ITEM_TYPE_NODEREV
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a revision file REV_FILE, opened to REV in FS, find the Node-ID    of the header located at OFFSET and store it in *ID_P.  Allocate    temporary variables from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_fs_id_at_offset
parameter_list|(
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
operator|&
name|noderev
argument_list|,
name|rev_file
operator|->
name|stream
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* noderev->id is const, get rid of that */
operator|*
name|id_p
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* assert that the txn_id is REV    * (asserting on offset would be harder because we the rev_offset is not    * known here) */
name|assert
argument_list|(
name|svn_fs_fs__id_rev
argument_list|(
operator|*
name|id_p
argument_list|)
operator|==
name|rev
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given an open revision file REV_FILE in FS for REV, locate the trailer that    specifies the offset to the root node-id and to the changed path    information.  Store the root node offset in *ROOT_OFFSET and the    changed path offset in *CHANGES_OFFSET.  If either of these    pointers is NULL, do nothing with it.     Allocate temporary variables from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_root_changes_offset
parameter_list|(
name|apr_off_t
modifier|*
name|root_offset
parameter_list|,
name|apr_off_t
modifier|*
name|changes_offset
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|rev_offset
decl_stmt|;
name|apr_seek_where_t
name|seek_relative
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|trailer
decl_stmt|;
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|apr_off_t
name|start
decl_stmt|;
name|apr_off_t
name|end
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* Determine where to seek to in the file.       If we've got a pack file, we want to seek to the end of the desired      revision.  But we don't track that, so we seek to the beginning of the      next revision.       Unless the next revision is in a different file, in which case, we can      just seek to the end of the pack file -- just like we do in the      non-packed case. */
if|if
condition|(
name|rev_file
operator|->
name|is_packed
operator|&&
operator|(
operator|(
name|rev
operator|+
literal|1
operator|)
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|!=
literal|0
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_packed_offset
argument_list|(
operator|&
name|end
argument_list|,
name|fs
argument_list|,
name|rev
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|seek_relative
operator|=
name|APR_SET
expr_stmt|;
block|}
else|else
block|{
name|seek_relative
operator|=
name|APR_END
expr_stmt|;
name|end
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Offset of the revision from the start of the pack file, if applicable. */
if|if
condition|(
name|rev_file
operator|->
name|is_packed
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_packed_offset
argument_list|(
operator|&
name|rev_offset
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|rev_offset
operator|=
literal|0
expr_stmt|;
comment|/* We will assume that the last line containing the two offsets      will never be longer than 64 characters. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|seek_relative
argument_list|,
operator|&
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|end
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|-
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
comment|/* Read in this last block, from which we will identify the last line. */
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse the last line. */
name|trailer
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__parse_revision_trailer
argument_list|(
name|root_offset
argument_list|,
name|changes_offset
argument_list|,
name|trailer
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return absolute offsets */
if|if
condition|(
name|root_offset
condition|)
operator|*
name|root_offset
operator|+=
name|rev_offset
expr_stmt|;
if|if
condition|(
name|changes_offset
condition|)
operator|*
name|changes_offset
operator|+=
name|rev_offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__rev_get_root
parameter_list|(
name|svn_fs_id_t
modifier|*
modifier|*
name|root_id_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
operator|*
name|root_id_p
operator|=
name|svn_fs_fs__id_create_root
argument_list|(
name|rev
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_fs__revision_file_t
modifier|*
name|revision_file
decl_stmt|;
name|apr_off_t
name|root_offset
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|root_id
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|root_id_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|rev_root_id_cache
argument_list|,
operator|&
name|rev
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_root_changes_offset
argument_list|(
operator|&
name|root_offset
argument_list|,
name|NULL
argument_list|,
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_fs_id_at_offset
argument_list|(
operator|&
name|root_id
argument_list|,
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|root_offset
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|revision_file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|rev_root_id_cache
argument_list|,
operator|&
name|rev
argument_list|,
name|root_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_id_p
operator|=
name|root_id
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Describes a lazily opened rev / pack file.  Instances will be shared    between multiple instances of rep_state_t. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|shared_file_t
block|{
comment|/* The opened file. NULL while file is not open, yet. */
name|svn_fs_fs__revision_file_t
modifier|*
name|rfile
decl_stmt|;
comment|/* file system to open the file in */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* a revision contained in the FILE.  Since this file may be shared,      that value may be different from REP_STATE_T->REVISION. */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* pool to use when creating the FILE.  This guarantees that the file      remains open / valid beyond the respective local context that required      the file to be opened eventually. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|shared_file_t
typedef|;
end_typedef

begin_comment
comment|/* Represents where in the current svndiff data block each    representation is. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rep_state_t
block|{
comment|/* shared lazy-open rev/pack file structure */
name|shared_file_t
modifier|*
name|sfile
decl_stmt|;
comment|/* The txdelta window cache to use or NULL. */
name|svn_cache__t
modifier|*
name|raw_window_cache
decl_stmt|;
comment|/* Caches raw (unparsed) windows. May be NULL. */
name|svn_cache__t
modifier|*
name|window_cache
decl_stmt|;
comment|/* Caches un-deltified windows. May be NULL. */
name|svn_cache__t
modifier|*
name|combined_cache
decl_stmt|;
comment|/* revision containing the representation */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* representation's item index in REVISION */
name|apr_uint64_t
name|item_index
decl_stmt|;
comment|/* length of the header at the start of the rep.                        0 iff this is rep is stored in a container                        (i.e. does not have a header) */
name|apr_size_t
name|header_size
decl_stmt|;
name|apr_off_t
name|start
decl_stmt|;
comment|/* The starting offset for the raw                        svndiff/plaintext data minus header.                        -1 if the offset is yet unknown. */
name|apr_off_t
name|current
decl_stmt|;
comment|/* The current offset relative to START. */
name|apr_off_t
name|size
decl_stmt|;
comment|/* The on-disk size of the representation. */
name|int
name|ver
decl_stmt|;
comment|/* If a delta, what svndiff version?                        -1 for unknown delta version. */
name|int
name|chunk_index
decl_stmt|;
comment|/* number of the window to read */
block|}
name|rep_state_t
typedef|;
end_typedef

begin_comment
comment|/* Simple wrapper around svn_fs_fs__get_file_offset to simplify callers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_offset
parameter_list|(
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_fs_fs__get_file_offset
argument_list|(
name|offset
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simple wrapper around svn_io_file_aligned_seek to simplify callers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rs_aligned_seek
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_off_t
modifier|*
name|buffer_start
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|rs
operator|->
name|sfile
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|buffer_start
argument_list|,
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open FILE->FILE and FILE->STREAM if they haven't been opened, yet. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_open_shared_file
parameter_list|(
name|shared_file_t
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|rfile
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|file
operator|->
name|rfile
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|file
operator|->
name|revision
argument_list|,
name|file
operator|->
name|pool
argument_list|,
name|file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set RS->START to the begin of the representation raw in RS->FILE->FILE,    if that hasn't been done yet.  Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_set_start_offset
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|start
operator|==
operator|-
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|rs
operator|->
name|start
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|fs
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|rs
operator|->
name|revision
argument_list|,
name|NULL
argument_list|,
name|rs
operator|->
name|item_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|start
operator|+=
name|rs
operator|->
name|header_size
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set RS->VER depending on what is found in the already open RS->FILE->FILE    if the diff version is still unknown.  Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_read_diff_version
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|ver
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|rs
operator|->
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Layering violation */
if|if
condition|(
operator|!
operator|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'V'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'N'
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed svndiff data in representation"
argument_list|)
argument_list|)
return|;
name|rs
operator|->
name|ver
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|current
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* See create_rep_state, which wraps this and adds another error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_rep_state_body
parameter_list|(
name|rep_state_t
modifier|*
modifier|*
name|rep_state
parameter_list|,
name|svn_fs_fs__rep_header_t
modifier|*
modifier|*
name|rep_header
parameter_list|,
name|shared_file_t
modifier|*
modifier|*
name|shared_file
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
decl_stmt|;
name|svn_fs_fs__rep_header_t
modifier|*
name|rh
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|apr_uint64_t
name|estimated_window_storage
decl_stmt|;
comment|/* If the hint is    * - given,    * - refers to a valid revision,    * - refers to a packed revision,    * - as does the rep we want to read, and    * - refers to the same pack file as the rep    * we can re-use the same, already open file object    */
name|svn_boolean_t
name|reuse_shared_file
init|=
name|shared_file
operator|&&
operator|*
name|shared_file
operator|&&
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|rfile
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|revision
argument_list|)
operator|&&
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|&&
name|rep
operator|->
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|&&
operator|(
operator|(
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|revision
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|==
operator|(
name|rep
operator|->
name|revision
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|)
decl_stmt|;
name|pair_cache_key_t
name|key
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
comment|/* continue constructing RS and RA */
name|rs
operator|->
name|size
operator|=
name|rep
operator|->
name|size
expr_stmt|;
name|rs
operator|->
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|rs
operator|->
name|item_index
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
name|rs
operator|->
name|raw_window_cache
operator|=
name|ffd
operator|->
name|raw_window_cache
expr_stmt|;
name|rs
operator|->
name|ver
operator|=
operator|-
literal|1
expr_stmt|;
name|rs
operator|->
name|start
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Very long files stored as self-delta will produce a huge number of      delta windows.  Don't cache them lest we don't thrash the cache.      Since we don't know the depth of the delta chain, let's assume, the      whole contents get rewritten 3 times.    */
name|estimated_window_storage
operator|=
literal|4
operator|*
operator|(
operator|(
name|rep
operator|->
name|expanded_size
condition|?
name|rep
operator|->
name|expanded_size
else|:
name|rep
operator|->
name|size
operator|)
operator|+
name|SVN_DELTA_WINDOW_SIZE
operator|)
expr_stmt|;
name|estimated_window_storage
operator|=
name|MIN
argument_list|(
name|estimated_window_storage
argument_list|,
name|APR_SIZE_MAX
argument_list|)
expr_stmt|;
name|rs
operator|->
name|window_cache
operator|=
name|ffd
operator|->
name|txdelta_window_cache
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|txdelta_window_cache
argument_list|,
operator|(
name|apr_size_t
operator|)
name|estimated_window_storage
argument_list|)
condition|?
name|ffd
operator|->
name|txdelta_window_cache
else|:
name|NULL
expr_stmt|;
name|rs
operator|->
name|combined_cache
operator|=
name|ffd
operator|->
name|combined_window_cache
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|combined_window_cache
argument_list|,
operator|(
name|apr_size_t
operator|)
name|estimated_window_storage
argument_list|)
condition|?
name|ffd
operator|->
name|combined_window_cache
else|:
name|NULL
expr_stmt|;
comment|/* cache lookup, i.e. skip reading the rep header if possible */
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
operator|&&
operator|!
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rh
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|rep_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize the (shared) FILE member in RS */
if|if
condition|(
name|reuse_shared_file
condition|)
block|{
name|rs
operator|->
name|sfile
operator|=
operator|*
name|shared_file
expr_stmt|;
block|}
else|else
block|{
name|shared_file_t
modifier|*
name|file
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
decl_stmt|;
name|file
operator|->
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|file
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|file
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|rs
operator|->
name|sfile
operator|=
name|file
expr_stmt|;
comment|/* remember the current file, if suggested by the caller */
if|if
condition|(
name|shared_file
condition|)
operator|*
name|shared_file
operator|=
name|file
expr_stmt|;
block|}
comment|/* read rep header, if necessary */
if|if
condition|(
operator|!
name|is_cached
condition|)
block|{
comment|/* ensure file is open and navigate to the start of rep header */
if|if
condition|(
name|reuse_shared_file
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
comment|/* ... we can re-use the same, already open file object.            * This implies that we don't read from a txn.            */
name|rs
operator|->
name|sfile
operator|=
operator|*
name|shared_file
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_open_shared_file
argument_list|(
name|rs
operator|->
name|sfile
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|NULL
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, create a new file object.  May or may not be            * an in-txn file.            */
name|SVN_ERR
argument_list|(
name|open_and_seek_representation
argument_list|(
operator|&
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_rep_header
argument_list|(
operator|&
name|rh
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rs
operator|->
name|start
argument_list|,
name|rs
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* populate the cache if appropriate */
if|if
condition|(
operator|!
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
condition|)
block|{
if|if
condition|(
name|use_block_read
argument_list|(
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
name|NULL
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|rep_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|rh
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* finalize */
name|SVN_ERR
argument_list|(
name|dbg_log_access
argument_list|(
name|fs
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|rh
argument_list|,
name|SVN_FS_FS__ITEM_TYPE_ANY_REP
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|header_size
operator|=
name|rh
operator|->
name|header_size
expr_stmt|;
operator|*
name|rep_state
operator|=
name|rs
expr_stmt|;
operator|*
name|rep_header
operator|=
name|rh
expr_stmt|;
if|if
condition|(
name|rh
operator|->
name|type
operator|==
name|svn_fs_fs__rep_plain
condition|)
comment|/* This is a plaintext, so just return the current rep_state. */
return|return
name|SVN_NO_ERROR
return|;
comment|/* skip "SVNx" diff marker */
name|rs
operator|->
name|current
operator|=
literal|4
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the rep args for REP in filesystem FS and create a rep_state    for reading the representation.  Return the rep_state in *REP_STATE    and the rep header in *REP_HEADER, both allocated in POOL.     When reading multiple reps, i.e. a skip delta chain, you may provide    non-NULL SHARED_FILE.  (If SHARED_FILE is not NULL, in the first    call it should be a pointer to NULL.)  The function will use this    variable to store the previous call results and tries to re-use it.    This may result in significant savings in I/O for packed files and    number of open file handles.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_rep_state
parameter_list|(
name|rep_state_t
modifier|*
modifier|*
name|rep_state
parameter_list|,
name|svn_fs_fs__rep_header_t
modifier|*
modifier|*
name|rep_header
parameter_list|,
name|shared_file_t
modifier|*
modifier|*
name|shared_file
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|create_rep_state_body
argument_list|(
name|rep_state
argument_list|,
name|rep_header
argument_list|,
name|shared_file
argument_list|,
name|rep
argument_list|,
name|fs
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|rep_str
decl_stmt|;
comment|/* ### This always returns "-1" for transaction reps, because          ### this particular bit of code doesn't know if the rep is          ### stored in the protorev or in the mutable area (for props          ### or dir contents).  It is pretty rare for FSFS to *read*          ### from the protorev file, though, so this is probably OK.          ### And anyone going to debug corruption errors is probably          ### going to jump straight to this comment anyway! */
name|rep_str
operator|=
name|rep
condition|?
name|svn_fs_fs__unparse_representation
argument_list|(
name|rep
argument_list|,
name|ffd
operator|->
name|format
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
else|:
literal|"(null)"
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
literal|"Corrupt representation '%s'"
argument_list|,
name|rep_str
argument_list|)
return|;
block|}
comment|/* ### Call representation_string() ? */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__check_rep
parameter_list|(
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|void
modifier|*
modifier|*
name|hint
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
init|=
name|NULL
decl_stmt|;
comment|/* Reuse the revision file provided by *HINT, if it is given and        * actually the rev / pack file that we want. */
name|svn_revnum_t
name|start_rev
init|=
name|svn_fs_fs__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|rep
operator|->
name|revision
argument_list|)
decl_stmt|;
if|if
condition|(
name|hint
condition|)
name|rev_file
operator|=
operator|*
operator|(
name|svn_fs_fs__revision_file_t
operator|*
operator|*
operator|)
name|hint
expr_stmt|;
if|if
condition|(
name|rev_file
operator|==
name|NULL
operator|||
name|rev_file
operator|->
name|start_revision
operator|!=
name|start_rev
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|hint
condition|)
operator|*
name|hint
operator|=
name|rev_file
expr_stmt|;
comment|/* This will auto-retry if there was a background pack. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|NULL
argument_list|,
name|rep
operator|->
name|item_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This may fail if there is a background pack operation (can't auto-          retry because the item offset lookup has to be redone as well). */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_entry_lookup
argument_list|(
operator|&
name|entry
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|==
name|NULL
operator|||
name|entry
operator|->
name|type
operator|<
name|SVN_FS_FS__ITEM_TYPE_FILE_REP
operator|||
name|entry
operator|->
name|type
operator|>
name|SVN_FS_FS__ITEM_TYPE_DIR_PROPS
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No representation found at offset %s "
literal|"for item %s in revision %ld"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|offset
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|rep
operator|->
name|item_index
argument_list|)
argument_list|,
name|rep
operator|->
name|revision
argument_list|)
return|;
block|}
else|else
block|{
name|rep_state_t
modifier|*
name|rs
decl_stmt|;
name|svn_fs_fs__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
comment|/* ### Should this be using read_rep_line() directly? */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_header
argument_list|,
operator|(
name|shared_file_t
operator|*
operator|*
operator|)
name|hint
argument_list|,
name|rep
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__rep_chain_length
parameter_list|(
name|int
modifier|*
name|chain_length
parameter_list|,
name|int
modifier|*
name|shard_count
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|shard_size
init|=
name|ffd
operator|->
name|max_files_per_dir
condition|?
name|ffd
operator|->
name|max_files_per_dir
else|:
literal|1
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|is_delta
init|=
name|FALSE
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|shards
init|=
literal|1
decl_stmt|;
name|svn_revnum_t
name|last_shard
init|=
name|rep
operator|->
name|revision
operator|/
name|shard_size
decl_stmt|;
comment|/* Check whether the length of the deltification chain is acceptable.    * Otherwise, shared reps may form a non-skipping delta chain in    * extreme cases. */
name|representation_t
name|base_rep
init|=
operator|*
name|rep
decl_stmt|;
comment|/* re-use open files between iterations */
name|shared_file_t
modifier|*
name|file_hint
init|=
name|NULL
decl_stmt|;
name|svn_fs_fs__rep_header_t
modifier|*
name|header
decl_stmt|;
comment|/* follow the delta chain towards the end but for at most    * MAX_CHAIN_LENGTH steps. */
do|do
block|{
name|rep_state_t
modifier|*
name|rep_state
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_rep
operator|.
name|revision
operator|/
name|shard_size
operator|!=
name|last_shard
condition|)
block|{
name|last_shard
operator|=
name|base_rep
operator|.
name|revision
operator|/
name|shard_size
expr_stmt|;
operator|++
name|shards
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|create_rep_state_body
argument_list|(
operator|&
name|rep_state
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|file_hint
argument_list|,
operator|&
name|base_rep
argument_list|,
name|fs
argument_list|,
name|subpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|base_rep
operator|.
name|revision
operator|=
name|header
operator|->
name|base_revision
expr_stmt|;
name|base_rep
operator|.
name|item_index
operator|=
name|header
operator|->
name|base_item_index
expr_stmt|;
name|base_rep
operator|.
name|size
operator|=
name|header
operator|->
name|base_length
expr_stmt|;
name|svn_fs_fs__id_txn_reset
argument_list|(
operator|&
name|base_rep
operator|.
name|txn_id
argument_list|)
expr_stmt|;
name|is_delta
operator|=
name|header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_delta
expr_stmt|;
comment|/* Clear it the SUBPOOL once in a while.  Doing it too frequently        * renders the FILE_HINT ineffective.  Doing too infrequently, may        * leave us with too many open file handles.        *        * Note that this is mostly about efficiency, with larger values        * being more efficient, and any non-zero value is legal here.  When        * reading deltified contents, we may keep 10s of rev files open at        * the same time and the system has to cope with that.  Thus, the        * limit of 16 chosen below is in the same ballpark.        */
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|%
literal|16
operator|==
literal|0
condition|)
block|{
name|file_hint
operator|=
name|NULL
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|is_delta
operator|&&
name|base_rep
operator|.
name|revision
condition|)
do|;
operator|*
name|chain_length
operator|=
name|count
expr_stmt|;
operator|*
name|shard_count
operator|=
name|shards
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|rep_read_baton
block|{
comment|/* The FS from which we're reading. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* Representation to read. */
name|representation_t
name|rep
decl_stmt|;
comment|/* If not NULL, this is the base for the first delta window in rs_list */
name|svn_stringbuf_t
modifier|*
name|base_window
decl_stmt|;
comment|/* The state of all prior delta representations. */
name|apr_array_header_t
modifier|*
name|rs_list
decl_stmt|;
comment|/* The plaintext state, if there is a plaintext. */
name|rep_state_t
modifier|*
name|src_state
decl_stmt|;
comment|/* The index of the current delta chunk, if we are reading a delta. */
name|int
name|chunk_index
decl_stmt|;
comment|/* The buffer where we store undeltified data. */
name|char
modifier|*
name|buf
decl_stmt|;
name|apr_size_t
name|buf_pos
decl_stmt|;
name|apr_size_t
name|buf_len
decl_stmt|;
comment|/* A checksum context for summing the data read in order to verify it.      Note: we don't need to use the sha1 checksum because we're only doing      data verification, for which md5 is perfectly safe.  */
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
name|svn_boolean_t
name|checksum_finalized
decl_stmt|;
comment|/* The stored checksum of the representation we are reading, its      length, and the amount we've read so far.  Some of this      information is redundant with rs_list and src_state, but it's      convenient for the checksumming code to have it here. */
name|unsigned
name|char
name|md5_digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|svn_filesize_t
name|len
decl_stmt|;
name|svn_filesize_t
name|off
decl_stmt|;
comment|/* The key for the fulltext cache for this rep, if there is a      fulltext cache. */
name|pair_cache_key_t
name|fulltext_cache_key
decl_stmt|;
comment|/* The text we've been reading, if we're going to cache it. */
name|svn_stringbuf_t
modifier|*
name|current_fulltext
decl_stmt|;
comment|/* If not NULL, attempt to read the data from this cache.      Once that lookup fails, reset it to NULL. */
name|svn_cache__t
modifier|*
name|fulltext_cache
decl_stmt|;
comment|/* Bytes delivered from the FULLTEXT_CACHE so far.  If the next      lookup fails, we need to skip that much data from the reconstructed      window stream before we continue normal operation. */
name|svn_filesize_t
name|fulltext_delivered
decl_stmt|;
comment|/* Used for temporary allocations during the read. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Pool used to store file handles and other data that is persistant      for the entire stream read. */
name|apr_pool_t
modifier|*
name|filehandle_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Set window key in *KEY to address the window described by RS.    For convenience, return the KEY. */
end_comment

begin_function
specifier|static
name|window_cache_key_t
modifier|*
name|get_window_key
parameter_list|(
name|window_cache_key_t
modifier|*
name|key
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|)
block|{
name|assert
argument_list|(
name|rs
operator|->
name|revision
operator|<=
name|APR_UINT32_MAX
argument_list|)
expr_stmt|;
name|key
operator|->
name|revision
operator|=
operator|(
name|apr_uint32_t
operator|)
name|rs
operator|->
name|revision
expr_stmt|;
name|key
operator|->
name|item_index
operator|=
name|rs
operator|->
name|item_index
expr_stmt|;
name|key
operator|->
name|chunk_index
operator|=
name|rs
operator|->
name|chunk_index
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t for raw txdelta windows.  * Parse the raw data and return a svn_fs_fs__txdelta_cached_window_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_raw_window
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_string_t
name|raw_window
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* unparsed and parsed window */
specifier|const
name|svn_fs_fs__raw_cached_window_t
modifier|*
name|window
init|=
operator|(
specifier|const
name|svn_fs_fs__raw_cached_window_t
operator|*
operator|)
name|data
decl_stmt|;
name|svn_fs_fs__txdelta_cached_window_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
comment|/* create a read stream taking the raw window as input */
name|raw_window
operator|.
name|data
operator|=
name|svn_temp_deserializer__ptr
argument_list|(
name|window
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|window
operator|->
name|window
operator|.
name|data
argument_list|)
expr_stmt|;
name|raw_window
operator|.
name|len
operator|=
name|window
operator|->
name|window
operator|.
name|len
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_string
argument_list|(
operator|&
name|raw_window
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* parse it */
name|SVN_ERR
argument_list|(
name|svn_txdelta_read_svndiff_window
argument_list|(
operator|&
name|result
operator|->
name|window
argument_list|,
name|stream
argument_list|,
literal|1
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* complete the window and return it */
name|result
operator|->
name|end_offset
operator|=
name|window
operator|->
name|end_offset
expr_stmt|;
operator|*
name|out
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the WINDOW_P number CHUNK_INDEX for the representation given in  * rep state RS from the current FSFS session's cache.  This will be a  * no-op and IS_CACHED will be set to FALSE if no cache has been given.  * If a cache is available IS_CACHED will inform the caller about the  * success of the lookup. Allocations of the window in will be made  * from RESULT_POOL. Use SCRATCH_POOL for temporary allocations.  *  * If the information could be found, put RS to CHUNK_INDEX.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|int
name|chunk_index
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|->
name|window_cache
condition|)
block|{
comment|/* txdelta window has not been enabled */
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* ask the cache for the desired txdelta window */
name|svn_fs_fs__txdelta_cached_window_t
modifier|*
name|cached_window
decl_stmt|;
name|window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|key
operator|.
name|chunk_index
operator|=
name|chunk_index
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cached_window
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|window_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we did not find a parsed txdelta window, we might have a raw          version of it in our cache.  If so, read, parse and re-cache it. */
if|if
condition|(
operator|!
operator|*
name|is_cached
operator|&&
name|rs
operator|->
name|raw_window_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cached_window
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|raw_window_cache
argument_list|,
operator|&
name|key
argument_list|,
name|parse_raw_window
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|is_cached
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|window_cache
argument_list|,
operator|&
name|key
argument_list|,
name|cached_window
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return cached information. */
if|if
condition|(
operator|*
name|is_cached
condition|)
block|{
comment|/* found it. Pass it back to the caller. */
operator|*
name|window_p
operator|=
name|cached_window
operator|->
name|window
expr_stmt|;
comment|/* manipulate the RS as if we just read the data */
name|rs
operator|->
name|current
operator|=
name|cached_window
operator|->
name|end_offset
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
name|chunk_index
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store the WINDOW read for the rep state RS in the current FSFS  * session's cache.  This will be a no-op if no cache has been given.  * Temporary allocations will be made from SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_cached_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|window_cache
condition|)
block|{
comment|/* store the window and the first offset _past_ it */
name|svn_fs_fs__txdelta_cached_window_t
name|cached_window
decl_stmt|;
name|window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cached_window
operator|.
name|window
operator|=
name|window
expr_stmt|;
name|cached_window
operator|.
name|end_offset
operator|=
name|rs
operator|->
name|current
expr_stmt|;
comment|/* but key it with the start offset because that is the known state        * when we will look it up */
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|window_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
operator|&
name|cached_window
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the WINDOW_P for the rep state RS from the current FSFS session's  * cache. This will be a no-op and IS_CACHED will be set to FALSE if no  * cache has been given. If a cache is available IS_CACHED will inform  * the caller about the success of the lookup. Allocations (of the window  * in particular) will be made from POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|->
name|combined_cache
condition|)
block|{
comment|/* txdelta window has not been enabled */
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* ask the cache for the desired txdelta window */
name|window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
return|return
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|window_p
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|combined_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store the WINDOW read for the rep state RS in the current FSFS session's  * cache. This will be a no-op if no cache has been given.  * Temporary allocations will be made from SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_cached_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|window
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|combined_cache
condition|)
block|{
comment|/* but key it with the start offset because that is the known state        * when we will look it up */
name|window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|combined_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
name|window
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Build an array of rep_state structures in *LIST giving the delta    reps from first_rep to a plain-text or self-compressed rep.  Set    *SRC_STATE to the plain-text rep we find at the end of the chain,    or to NULL if the final delta representation is self-compressed.    The representation to start from is designated by filesystem FS, id    ID, and representation REP.    Also, set *WINDOW_P to the base window content for *LIST, if it    could be found in cache. Otherwise, *LIST will contain the base    representation for the whole delta chain.    Finally, return the expanded size of the representation in    *EXPANDED_SIZE. It will take care of cases where only the on-disk    size is known.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_rep_list
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|list
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|rep_state_t
modifier|*
modifier|*
name|src_state
parameter_list|,
name|svn_filesize_t
modifier|*
name|expanded_size
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|first_rep
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
name|rep
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
init|=
name|NULL
decl_stmt|;
name|svn_fs_fs__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|shared_file_t
modifier|*
name|shared_file
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
operator|*
name|list
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_state_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
operator|*
name|first_rep
expr_stmt|;
comment|/* The value as stored in the data struct.      0 is either for unknown length or actually zero length. */
operator|*
name|expanded_size
operator|=
name|first_rep
operator|->
name|expanded_size
expr_stmt|;
comment|/* for the top-level rep, we need the rep_args */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_header
argument_list|,
operator|&
name|shared_file
argument_list|,
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unknown size or empty representation?      That implies the this being the first iteration.      Usually size equals on-disk size, except for empty,      compressed representations (delta, size = 4).      Please note that for all non-empty deltas have      a 4-byte header _plus_ some data. */
if|if
condition|(
operator|*
name|expanded_size
operator|==
literal|0
condition|)
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_plain
operator|||
name|first_rep
operator|->
name|size
operator|!=
literal|4
condition|)
operator|*
name|expanded_size
operator|=
name|first_rep
operator|->
name|size
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* fetch state, if that has not been done already */
if|if
condition|(
operator|!
name|rs
condition|)
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_header
argument_list|,
operator|&
name|shared_file
argument_list|,
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for txn reps, there won't be a cached combined window */
if|if
condition|(
operator|!
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|rep
operator|.
name|txn_id
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|get_cached_combined_window
argument_list|(
name|window_p
argument_list|,
name|rs
argument_list|,
operator|&
name|is_cached
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
comment|/* We already have a reconstructed window in our cache.              Write a pseudo rep_state with the full length. */
name|rs
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|size
operator|=
operator|(
operator|*
name|window_p
operator|)
operator|->
name|len
expr_stmt|;
operator|*
name|src_state
operator|=
name|rs
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_plain
condition|)
block|{
comment|/* This is a plaintext, so just return the current rep_state. */
operator|*
name|src_state
operator|=
name|rs
expr_stmt|;
break|break;
block|}
comment|/* Push this rep onto the list.  If it's self-compressed, we're done. */
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|list
argument_list|,
name|rep_state_t
operator|*
argument_list|)
operator|=
name|rs
expr_stmt|;
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_self_delta
condition|)
block|{
operator|*
name|src_state
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|rep
operator|.
name|revision
operator|=
name|rep_header
operator|->
name|base_revision
expr_stmt|;
name|rep
operator|.
name|item_index
operator|=
name|rep_header
operator|->
name|base_item_index
expr_stmt|;
name|rep
operator|.
name|size
operator|=
name|rep_header
operator|->
name|base_length
expr_stmt|;
name|svn_fs_fs__id_txn_reset
argument_list|(
operator|&
name|rep
operator|.
name|txn_id
argument_list|)
expr_stmt|;
name|rs
operator|=
name|NULL
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a rep_read_baton structure for node revision NODEREV in    filesystem FS and store it in *RB_P.  Perform all allocations in    POOL.  If rep is mutable, it must be for file contents. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_get_baton
parameter_list|(
name|struct
name|rep_read_baton
modifier|*
modifier|*
name|rb_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|pair_cache_key_t
name|fulltext_cache_key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|->
name|rep
operator|=
operator|*
name|rep
expr_stmt|;
name|b
operator|->
name|base_window
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|checksum_finalized
operator|=
name|FALSE
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|md5_digest
argument_list|,
name|rep
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|len
operator|=
name|rep
operator|->
name|expanded_size
expr_stmt|;
name|b
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|fulltext_cache_key
operator|=
name|fulltext_cache_key
expr_stmt|;
name|b
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|filehandle_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|fulltext_cache
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|fulltext_delivered
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|current_fulltext
operator|=
name|NULL
expr_stmt|;
comment|/* Save our output baton. */
operator|*
name|rb_p
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Skip forwards to THIS_CHUNK in REP_STATE and then read the next delta    window into *NWIN.  Note that RS->CHUNK_INDEX will be THIS_CHUNK rather    than THIS_CHUNK + 1 when this function returns. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_delta_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|nwin
parameter_list|,
name|int
name|this_chunk
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|apr_off_t
name|start_offset
decl_stmt|;
name|apr_off_t
name|end_offset
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rs
operator|->
name|chunk_index
operator|<=
name|this_chunk
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dbg_log_access
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|fs
argument_list|,
name|rs
operator|->
name|revision
argument_list|,
name|rs
operator|->
name|item_index
argument_list|,
name|NULL
argument_list|,
name|SVN_FS_FS__ITEM_TYPE_ANY_REP
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the next window.  But first, try to find it in the cache. */
name|SVN_ERR
argument_list|(
name|get_cached_window
argument_list|(
name|nwin
argument_list|,
name|rs
argument_list|,
name|this_chunk
argument_list|,
operator|&
name|is_cached
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* someone has to actually read the data from file.  Open it */
name|SVN_ERR
argument_list|(
name|auto_open_shared_file
argument_list|(
name|rs
operator|->
name|sfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* invoke the 'block-read' feature for non-txn data.      However, don't do that if we are in the middle of some representation,      because the block is unlikely to contain other data. */
if|if
condition|(
name|rs
operator|->
name|chunk_index
operator|==
literal|0
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rs
operator|->
name|revision
argument_list|)
operator|&&
name|use_block_read
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|fs
argument_list|)
operator|&&
name|rs
operator|->
name|raw_window_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
name|NULL
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|fs
argument_list|,
name|rs
operator|->
name|revision
argument_list|,
name|rs
operator|->
name|item_index
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reading the whole block probably also provided us with the          desired txdelta window */
name|SVN_ERR
argument_list|(
name|get_cached_window
argument_list|(
name|nwin
argument_list|,
name|rs
argument_list|,
name|this_chunk
argument_list|,
operator|&
name|is_cached
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* data is still not cached -> we need to read it.      Make sure we have all the necessary info. */
name|SVN_ERR
argument_list|(
name|auto_set_start_offset
argument_list|(
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_read_diff_version
argument_list|(
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RS->FILE may be shared between RS instances -> make sure we point    * to the right data. */
name|start_offset
operator|=
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|start_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip windows to reach the current chunk if we aren't there yet. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|->
name|chunk_index
operator|<
name|this_chunk
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_skip_svndiff_window
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|rs
operator|->
name|ver
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|start_offset
argument_list|,
name|rs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|current
operator|=
name|start_offset
operator|-
name|rs
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|current
operator|>=
name|rs
operator|->
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read "
literal|"beyond the end of the "
literal|"representation"
argument_list|)
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Actually read the next window. */
name|SVN_ERR
argument_list|(
name|svn_txdelta_read_svndiff_window
argument_list|(
name|nwin
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|stream
argument_list|,
name|rs
operator|->
name|ver
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|end_offset
argument_list|,
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|current
operator|=
name|end_offset
operator|-
name|rs
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|current
operator|>
name|rs
operator|->
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read beyond "
literal|"the end of the representation"
argument_list|)
argument_list|)
return|;
comment|/* the window has not been cached before, thus cache it now    * (if caching is used for them at all) */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rs
operator|->
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|set_cached_window
argument_list|(
operator|*
name|nwin
argument_list|,
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read SIZE bytes from the representation RS and return it in *NWIN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_plain_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|nwin
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
comment|/* RS->FILE may be shared between RS instances -> make sure we point    * to the right data. */
name|SVN_ERR
argument_list|(
name|auto_open_shared_file
argument_list|(
name|rs
operator|->
name|sfile
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_set_start_offset
argument_list|(
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the plain data. */
operator|*
name|nwin
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|size
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
operator|(
operator|*
name|nwin
operator|)
operator|->
name|data
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|nwin
operator|)
operator|->
name|data
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Update RS. */
name|rs
operator|->
name|current
operator|+=
operator|(
name|apr_off_t
operator|)
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Skip SIZE bytes from the PLAIN representation RS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_plain_window
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_size_t
name|size
parameter_list|)
block|{
comment|/* Update RS. */
name|rs
operator|->
name|current
operator|+=
operator|(
name|apr_off_t
operator|)
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the undeltified window that is a result of combining all deltas    from the current desired representation identified in *RB with its    base representation.  Store the window in *RESULT. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|result
parameter_list|,
name|struct
name|rep_read_baton
modifier|*
name|rb
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|,
modifier|*
name|new_pool
decl_stmt|,
modifier|*
name|window_pool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|windows
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|source
decl_stmt|,
modifier|*
name|buf
init|=
name|rb
operator|->
name|base_window
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Read all windows that we need to combine. This is fine because      the size of each window is relatively small (100kB) and skip-      delta limits the number of deltas in a chain to well under 100.      Stop early if one of them does not depend on its predecessors. */
name|window_pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|windows
operator|=
name|apr_array_make
argument_list|(
name|window_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_txdelta_window_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rb
operator|->
name|rs_list
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
name|i
argument_list|,
name|rep_state_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_delta_window
argument_list|(
operator|&
name|window
argument_list|,
name|rb
operator|->
name|chunk_index
argument_list|,
name|rs
argument_list|,
name|window_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|windows
argument_list|,
name|svn_txdelta_window_t
operator|*
argument_list|)
operator|=
name|window
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|src_ops
operator|==
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Combine in the windows from the other delta reps. */
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
name|i
argument_list|,
name|rep_state_t
operator|*
argument_list|)
expr_stmt|;
name|window
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|windows
argument_list|,
name|i
argument_list|,
name|svn_txdelta_window_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Maybe, we've got a PLAIN start representation.  If we do, read          as much data from it as the needed for the txdelta window's source          view.          Note that BUF / SOURCE may only be NULL in the first iteration.          Also note that we may have short-cut reading the delta chain --          in which case SRC_OPS is 0 and it might not be a PLAIN rep. */
name|source
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
operator|&&
name|rb
operator|->
name|src_state
operator|!=
name|NULL
condition|)
block|{
comment|/* Even if we don't need the source rep now, we still must keep            * its read offset in sync with what we might need for the next            * window. */
if|if
condition|(
name|window
operator|->
name|src_ops
condition|)
name|SVN_ERR
argument_list|(
name|read_plain_window
argument_list|(
operator|&
name|source
argument_list|,
name|rb
operator|->
name|src_state
argument_list|,
name|window
operator|->
name|sview_len
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|skip_plain_window
argument_list|(
name|rb
operator|->
name|src_state
argument_list|,
name|window
operator|->
name|sview_len
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Combine this window with the current one. */
name|new_pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|buf
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|window
operator|->
name|tview_len
argument_list|,
name|new_pool
argument_list|)
expr_stmt|;
name|buf
operator|->
name|len
operator|=
name|window
operator|->
name|tview_len
expr_stmt|;
name|svn_txdelta_apply_instructions
argument_list|(
name|window
argument_list|,
name|source
condition|?
name|source
operator|->
name|data
else|:
name|NULL
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|!=
name|window
operator|->
name|tview_len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"svndiff window length is "
literal|"corrupt"
argument_list|)
argument_list|)
return|;
comment|/* Cache windows only if the whole rep content could be read as a          single chunk.  Only then will no other chunk need a deeper RS          list than the cached chunk. */
if|if
condition|(
operator|(
name|rb
operator|->
name|chunk_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rs
operator|->
name|current
operator|==
name|rs
operator|->
name|size
operator|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rs
operator|->
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|set_cached_combined_window
argument_list|(
name|buf
argument_list|,
name|rs
argument_list|,
name|new_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
comment|/* Cycle pools so that we only need to hold three windows at a time. */
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|=
name|new_pool
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|window_pool
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Returns whether or not the expanded fulltext of the file is cachable  * based on its size SIZE.  The decision depends on the cache used by RB.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|fulltext_size_is_cachable
parameter_list|(
name|fs_fs_data_t
modifier|*
name|ffd
parameter_list|,
name|svn_filesize_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|<
name|APR_SIZE_MAX
operator|)
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|(
name|apr_size_t
operator|)
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close method used on streams returned by read_representation().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_contents_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|filehandle_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the next *LEN bytes of the rep from our plain / delta windows    and store them in *BUF. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_contents_from_windows
parameter_list|(
name|struct
name|rep_read_baton
modifier|*
name|rb
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_size_t
name|copy_len
decl_stmt|,
name|remaining
init|=
operator|*
name|len
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
decl_stmt|;
comment|/* Special case for when there are no delta reps, only a plain      text. */
if|if
condition|(
name|rb
operator|->
name|rs_list
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
name|copy_len
operator|=
name|remaining
expr_stmt|;
name|rs
operator|=
name|rb
operator|->
name|src_state
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|base_window
operator|!=
name|NULL
condition|)
block|{
comment|/* We got the desired rep directly from the cache.              This is where we need the pseudo rep_state created              by build_rep_list(). */
name|apr_size_t
name|offset
init|=
operator|(
name|apr_size_t
operator|)
name|rs
operator|->
name|current
decl_stmt|;
if|if
condition|(
name|copy_len
operator|+
name|offset
operator|>
name|rb
operator|->
name|base_window
operator|->
name|len
condition|)
name|copy_len
operator|=
name|offset
operator|<
name|rb
operator|->
name|base_window
operator|->
name|len
condition|?
name|rb
operator|->
name|base_window
operator|->
name|len
operator|-
name|offset
else|:
literal|0ul
expr_stmt|;
name|memcpy
argument_list|(
name|cur
argument_list|,
name|rb
operator|->
name|base_window
operator|->
name|data
operator|+
name|offset
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_off_t
name|offset
decl_stmt|;
if|if
condition|(
operator|(
operator|(
name|apr_off_t
operator|)
name|copy_len
operator|)
operator|>
name|rs
operator|->
name|size
operator|-
name|rs
operator|->
name|current
condition|)
name|copy_len
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|rs
operator|->
name|size
operator|-
name|rs
operator|->
name|current
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_open_shared_file
argument_list|(
name|rs
operator|->
name|sfile
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_set_start_offset
argument_list|(
name|rs
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|cur
argument_list|,
name|copy_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|->
name|current
operator|+=
name|copy_len
expr_stmt|;
operator|*
name|len
operator|=
name|copy_len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
comment|/* If we have buffered data from a previous chunk, use that. */
if|if
condition|(
name|rb
operator|->
name|buf
condition|)
block|{
comment|/* Determine how much to copy from the buffer. */
name|copy_len
operator|=
name|rb
operator|->
name|buf_len
operator|-
name|rb
operator|->
name|buf_pos
expr_stmt|;
if|if
condition|(
name|copy_len
operator|>
name|remaining
condition|)
name|copy_len
operator|=
name|remaining
expr_stmt|;
comment|/* Actually copy the data. */
name|memcpy
argument_list|(
name|cur
argument_list|,
name|rb
operator|->
name|buf
operator|+
name|rb
operator|->
name|buf_pos
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|rb
operator|->
name|buf_pos
operator|+=
name|copy_len
expr_stmt|;
name|cur
operator|+=
name|copy_len
expr_stmt|;
name|remaining
operator|-=
name|copy_len
expr_stmt|;
comment|/* If the buffer is all used up, clear it and empty the              local pool. */
if|if
condition|(
name|rb
operator|->
name|buf_pos
operator|==
name|rb
operator|->
name|buf_len
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|rb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|rb
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|svn_stringbuf_t
modifier|*
name|sbuf
init|=
name|NULL
decl_stmt|;
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
literal|0
argument_list|,
name|rep_state_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|current
operator|==
name|rs
operator|->
name|size
condition|)
break|break;
comment|/* Get more buffered data by evaluating a chunk. */
name|SVN_ERR
argument_list|(
name|get_combined_window
argument_list|(
operator|&
name|sbuf
argument_list|,
name|rb
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|rb
operator|->
name|buf_len
operator|=
name|sbuf
operator|->
name|len
expr_stmt|;
name|rb
operator|->
name|buf
operator|=
name|sbuf
operator|->
name|data
expr_stmt|;
name|rb
operator|->
name|buf_pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|len
operator|=
name|cur
operator|-
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton type for get_fulltext_partial. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fulltext_baton_t
block|{
comment|/* Target buffer to write to; of at least LEN bytes. */
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Offset within the respective fulltext at which we shall start to      copy data into BUFFER. */
name|apr_size_t
name|start
decl_stmt|;
comment|/* Number of bytes to copy.  The actual amount may be less in case      the fulltext is short(er). */
name|apr_size_t
name|len
decl_stmt|;
comment|/* Number of bytes actually copied into BUFFER. */
name|apr_size_t
name|read
decl_stmt|;
block|}
name|fulltext_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t for fulltext caches.  * From the fulltext in DATA, we copy the range specified by the  * fulltext_baton_t* BATON into the buffer provided by that baton.  * OUT and RESULT_POOL are not used.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_fulltext_partial
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|fulltext_baton_t
modifier|*
name|fulltext_baton
init|=
name|baton
decl_stmt|;
comment|/* We cached the fulltext with an NUL appended to it. */
name|apr_size_t
name|fulltext_len
init|=
name|data_len
operator|-
literal|1
decl_stmt|;
comment|/* Clip the copy range to what the fulltext size allows. */
name|apr_size_t
name|start
init|=
name|MIN
argument_list|(
name|fulltext_baton
operator|->
name|start
argument_list|,
name|fulltext_len
argument_list|)
decl_stmt|;
name|fulltext_baton
operator|->
name|read
operator|=
name|MIN
argument_list|(
name|fulltext_len
operator|-
name|start
argument_list|,
name|fulltext_baton
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the data to the output buffer and be done. */
name|memcpy
argument_list|(
name|fulltext_baton
operator|->
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|+
name|start
argument_list|,
name|fulltext_baton
operator|->
name|read
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the fulltext specified in BATON in the fulltext cache given  * as well by BATON.  If that succeeds, set *CACHED to TRUE and copy  * up to the next *LEN bytes into BUFFER.  Set *LEN to the actual  * number of bytes copied.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_contents_from_fulltext
parameter_list|(
name|svn_boolean_t
modifier|*
name|cached
parameter_list|,
name|struct
name|rep_read_baton
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|void
modifier|*
name|dummy
decl_stmt|;
name|fulltext_baton_t
name|fulltext_baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|apr_size_t
operator|)
name|baton
operator|->
name|fulltext_delivered
operator|==
name|baton
operator|->
name|fulltext_delivered
argument_list|)
expr_stmt|;
name|fulltext_baton
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|fulltext_baton
operator|.
name|start
operator|=
operator|(
name|apr_size_t
operator|)
name|baton
operator|->
name|fulltext_delivered
expr_stmt|;
name|fulltext_baton
operator|.
name|len
operator|=
operator|*
name|len
expr_stmt|;
name|fulltext_baton
operator|.
name|read
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|&
name|dummy
argument_list|,
name|cached
argument_list|,
name|baton
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|baton
operator|->
name|fulltext_cache_key
argument_list|,
name|get_fulltext_partial
argument_list|,
operator|&
name|fulltext_baton
argument_list|,
name|baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cached
condition|)
block|{
name|baton
operator|->
name|fulltext_delivered
operator|+=
name|fulltext_baton
operator|.
name|read
expr_stmt|;
operator|*
name|len
operator|=
name|fulltext_baton
operator|.
name|read
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine the optimal size of a string buf that shall receive a  * (full-) text of NEEDED bytes.  *  * The critical point is that those buffers may be very large and  * can cause memory fragmentation.  We apply simple heuristics to  * make fragmentation less likely.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|optimimal_allocation_size
parameter_list|(
name|apr_size_t
name|needed
parameter_list|)
block|{
comment|/* For all allocations, assume some overhead that is shared between    * OS memory managemnt, APR memory management and svn_stringbuf_t. */
specifier|const
name|apr_size_t
name|overhead
init|=
literal|0x400
decl_stmt|;
name|apr_size_t
name|optimal
decl_stmt|;
comment|/* If an allocation size if safe for other ephemeral buffers, it should    * be safe for ours. */
if|if
condition|(
name|needed
operator|<=
name|SVN__STREAM_CHUNK_SIZE
condition|)
return|return
name|needed
return|;
comment|/* Paranoia edge case:    * Skip our heuristics if they created arithmetical overflow.    * Beware to make this test work for NEEDED = APR_SIZE_MAX as well! */
if|if
condition|(
name|needed
operator|>=
name|APR_SIZE_MAX
operator|/
literal|2
operator|-
name|overhead
condition|)
return|return
name|needed
return|;
comment|/* As per definition SVN__STREAM_CHUNK_SIZE is a power of two.    * Since we know NEEDED to be larger than that, use it as the    * starting point.    *    * Heuristics: Allocate a power-of-two number of bytes that fit    *             NEEDED plus some OVERHEAD.  The APR allocator    *             will round it up to the next full page size.    */
name|optimal
operator|=
name|SVN__STREAM_CHUNK_SIZE
expr_stmt|;
while|while
condition|(
name|optimal
operator|-
name|overhead
operator|<
name|needed
condition|)
name|optimal
operator|*=
literal|2
expr_stmt|;
comment|/* This is above or equal to NEEDED. */
return|return
name|optimal
operator|-
name|overhead
return|;
block|}
end_function

begin_comment
comment|/* After a fulltext cache lookup failure, we will continue to read from  * combined delta or plain windows.  However, we must first make that data  * stream in BATON catch up tho the position LEN already delivered from the  * fulltext cache.  Also, we need to store the reconstructed fulltext if we  * want to cache it at the end.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_contents
parameter_list|(
name|struct
name|rep_read_baton
modifier|*
name|baton
parameter_list|,
name|svn_filesize_t
name|len
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Do we want to cache the reconstructed fulltext? */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|baton
operator|->
name|fulltext_cache_key
operator|.
name|revision
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|svn_filesize_t
name|to_alloc
init|=
name|MAX
argument_list|(
name|len
argument_list|,
name|baton
operator|->
name|len
argument_list|)
decl_stmt|;
comment|/* This should only be happening if BATON->LEN and LEN are        * cacheable, implying they fit into memory. */
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|apr_size_t
operator|)
name|to_alloc
operator|==
name|to_alloc
argument_list|)
expr_stmt|;
comment|/* Allocate the fulltext buffer. */
name|baton
operator|->
name|current_fulltext
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|optimimal_allocation_size
argument_list|(
operator|(
name|apr_size_t
operator|)
name|to_alloc
argument_list|)
argument_list|,
name|baton
operator|->
name|filehandle_pool
argument_list|)
expr_stmt|;
comment|/* Read LEN bytes from the window stream and store the data        * in the fulltext buffer (will be filled by further reads later). */
name|baton
operator|->
name|current_fulltext
operator|->
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|len
expr_stmt|;
name|baton
operator|->
name|current_fulltext
operator|->
name|data
index|[
operator|(
name|apr_size_t
operator|)
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
operator|=
name|baton
operator|->
name|current_fulltext
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|!
name|err
condition|)
block|{
name|apr_size_t
name|to_read
init|=
operator|(
name|apr_size_t
operator|)
name|len
decl_stmt|;
name|err
operator|=
name|get_contents_from_windows
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
operator|&
name|to_read
argument_list|)
expr_stmt|;
name|len
operator|-=
name|to_read
expr_stmt|;
name|buffer
operator|+=
name|to_read
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Simply drain LEN bytes from the window stream. */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|baton
operator|->
name|pool
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|!
name|err
condition|)
block|{
name|apr_size_t
name|to_read
init|=
name|len
operator|>
name|SVN__STREAM_CHUNK_SIZE
condition|?
name|SVN__STREAM_CHUNK_SIZE
else|:
operator|(
name|apr_size_t
operator|)
name|len
decl_stmt|;
name|err
operator|=
name|get_contents_from_windows
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
operator|&
name|to_read
argument_list|)
expr_stmt|;
name|len
operator|-=
name|to_read
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* BATON is of type `rep_read_baton'; read the next *LEN bytes of the    representation and store them in *BUF.  Sum as we read and verify    the MD5 sum at the end. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|rep_read_baton
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
comment|/* Get data from the fulltext cache for as long as we can. */
if|if
condition|(
name|rb
operator|->
name|fulltext_cache
condition|)
block|{
name|svn_boolean_t
name|cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_contents_from_fulltext
argument_list|(
operator|&
name|cached
argument_list|,
name|rb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Cache miss.  From now on, we will never read from the fulltext        * cache for this representation anymore. */
name|rb
operator|->
name|fulltext_cache
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* No fulltext cache to help us.  We must read from the window stream. */
if|if
condition|(
operator|!
name|rb
operator|->
name|rs_list
condition|)
block|{
comment|/* Window stream not initialized, yet.  Do it now. */
name|SVN_ERR
argument_list|(
name|build_rep_list
argument_list|(
operator|&
name|rb
operator|->
name|rs_list
argument_list|,
operator|&
name|rb
operator|->
name|base_window
argument_list|,
operator|&
name|rb
operator|->
name|src_state
argument_list|,
operator|&
name|rb
operator|->
name|len
argument_list|,
name|rb
operator|->
name|fs
argument_list|,
operator|&
name|rb
operator|->
name|rep
argument_list|,
name|rb
operator|->
name|filehandle_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In case we did read from the fulltext cache before, make the        * window stream catch up.  Also, initialize the fulltext buffer        * if we want to cache the fulltext at the end. */
name|SVN_ERR
argument_list|(
name|skip_contents
argument_list|(
name|rb
argument_list|,
name|rb
operator|->
name|fulltext_delivered
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the next block of data. */
name|SVN_ERR
argument_list|(
name|get_contents_from_windows
argument_list|(
name|rb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|current_fulltext
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|rb
operator|->
name|current_fulltext
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
comment|/* Perform checksumming.  We want to check the checksum as soon as      the last byte of data is read, in case the caller never performs      a short read, but we don't want to finalize the MD5 context      twice. */
if|if
condition|(
operator|!
name|rb
operator|->
name|checksum_finalized
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|off
operator|+=
operator|*
name|len
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|off
operator|==
name|rb
operator|->
name|len
condition|)
block|{
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|svn_checksum_t
name|expected
decl_stmt|;
name|expected
operator|.
name|kind
operator|=
name|svn_checksum_md5
expr_stmt|;
name|expected
operator|.
name|digest
operator|=
name|rb
operator|->
name|md5_digest
expr_stmt|;
name|rb
operator|->
name|checksum_finalized
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|md5_checksum
argument_list|,
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|md5_checksum
argument_list|,
operator|&
name|expected
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|svn_checksum_mismatch_err
argument_list|(
operator|&
name|expected
argument_list|,
name|md5_checksum
argument_list|,
name|rb
operator|->
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch while reading representation"
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|rb
operator|->
name|off
operator|==
name|rb
operator|->
name|len
operator|&&
name|rb
operator|->
name|current_fulltext
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|rb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|rb
operator|->
name|fulltext_cache_key
argument_list|,
name|rb
operator|->
name|current_fulltext
argument_list|,
name|rb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|current_fulltext
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|svn_boolean_t
name|cache_fulltext
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rep
condition|)
block|{
operator|*
name|contents_p
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_filesize_t
name|len
init|=
name|rep
operator|->
name|expanded_size
condition|?
name|rep
operator|->
name|expanded_size
else|:
name|rep
operator|->
name|size
decl_stmt|;
name|struct
name|rep_read_baton
modifier|*
name|rb
decl_stmt|;
name|pair_cache_key_t
name|fulltext_cache_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|fulltext_cache_key
operator|.
name|second
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
comment|/* Initialize the reader baton.  Some members may added lazily        * while reading from the stream */
name|SVN_ERR
argument_list|(
name|rep_read_get_baton
argument_list|(
operator|&
name|rb
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|fulltext_cache_key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the stream attempt fulltext cache lookups if the fulltext        * is cacheable.  If it is not, then also don't try to buffer and        * cache it. */
if|if
condition|(
name|ffd
operator|->
name|fulltext_cache
operator|&&
name|cache_fulltext
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
operator|&&
name|fulltext_size_is_cachable
argument_list|(
name|ffd
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|rb
operator|->
name|fulltext_cache
operator|=
name|ffd
operator|->
name|fulltext_cache
expr_stmt|;
block|}
else|else
block|{
comment|/* This will also prevent the reconstructed fulltext from being              put into the cache. */
name|rb
operator|->
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
operator|*
name|contents_p
operator|=
name|svn_stream_create
argument_list|(
name|rb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
operator|*
name|contents_p
argument_list|,
name|NULL
comment|/* only full read support */
argument_list|,
name|rep_read_contents
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_read_contents_close
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for cache_access_wrapper. Wraps the original parameters of  * svn_fs_fs__try_process_file_content().  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cache_access_wrapper_baton_t
block|{
name|svn_fs_process_contents_func_t
name|func
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
block|}
name|cache_access_wrapper_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Wrapper to translate between svn_fs_process_contents_func_t and  * svn_cache__partial_getter_func_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cache_access_wrapper
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|cache_access_wrapper_baton_t
modifier|*
name|wrapper_baton
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|wrapper_baton
operator|->
name|func
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
name|data_len
operator|-
literal|1
argument_list|,
comment|/* cache adds terminating 0 */
name|wrapper_baton
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* non-NULL value to signal the calling cache that all went well */
operator|*
name|out
operator|=
name|baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__try_process_file_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|svn_fs_process_contents_func_t
name|processor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
init|=
name|noderev
operator|->
name|data_rep
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|pair_cache_key_t
name|fulltext_cache_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|fulltext_cache_key
operator|.
name|second
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|fulltext_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
operator|&&
name|fulltext_size_is_cachable
argument_list|(
name|ffd
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|)
condition|)
block|{
name|cache_access_wrapper_baton_t
name|wrapper_baton
decl_stmt|;
name|void
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|wrapper_baton
operator|.
name|func
operator|=
name|processor
expr_stmt|;
name|wrapper_baton
operator|.
name|baton
operator|=
name|baton
expr_stmt|;
return|return
name|svn_cache__get_partial
argument_list|(
operator|&
name|dummy
argument_list|,
name|success
argument_list|,
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|fulltext_cache_key
argument_list|,
name|cache_access_wrapper
argument_list|,
operator|&
name|wrapper_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
operator|*
name|success
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used when reading delta windows. */
end_comment

begin_struct
struct|struct
name|delta_read_baton
block|{
name|rep_state_t
modifier|*
name|rs
decl_stmt|;
name|unsigned
name|char
name|md5_digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements the svn_txdelta_next_window_fn_t interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_read_next_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|delta_read_baton
modifier|*
name|drb
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
operator|*
name|window
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|drb
operator|->
name|rs
operator|->
name|current
operator|<
name|drb
operator|->
name|rs
operator|->
name|size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_delta_window
argument_list|(
name|window
argument_list|,
name|drb
operator|->
name|rs
operator|->
name|chunk_index
argument_list|,
name|drb
operator|->
name|rs
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|drb
operator|->
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the svn_txdelta_md5_digest_fn_t interface. */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|delta_read_md5_digest
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|delta_read_baton
modifier|*
name|drb
init|=
name|baton
decl_stmt|;
return|return
name|drb
operator|->
name|md5_digest
return|;
block|}
end_function

begin_comment
comment|/* Return a txdelta stream for on-disk representation REP_STATE  * of TARGET.  Allocate the result in POOL.  */
end_comment

begin_function
specifier|static
name|svn_txdelta_stream_t
modifier|*
name|get_storaged_delta_stream
parameter_list|(
name|rep_state_t
modifier|*
name|rep_state
parameter_list|,
name|node_revision_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Create the delta read baton. */
name|struct
name|delta_read_baton
modifier|*
name|drb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drb
argument_list|)
argument_list|)
decl_stmt|;
name|drb
operator|->
name|rs
operator|=
name|rep_state
expr_stmt|;
name|memcpy
argument_list|(
name|drb
operator|->
name|md5_digest
argument_list|,
name|target
operator|->
name|data_rep
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|drb
operator|->
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_txdelta_stream_create
argument_list|(
name|drb
argument_list|,
name|delta_read_next_window
argument_list|,
name|delta_read_md5_digest
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|source
parameter_list|,
name|node_revision_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|,
modifier|*
name|target_stream
decl_stmt|;
name|rep_state_t
modifier|*
name|rep_state
decl_stmt|;
name|svn_fs_fs__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Try a shortcut: if the target is stored as a delta against the source,      then just use that delta.  However, prefer using the fulltext cache      whenever that is available. */
if|if
condition|(
name|target
operator|->
name|data_rep
operator|&&
operator|(
name|source
operator|||
operator|!
name|ffd
operator|->
name|fulltext_cache
operator|)
condition|)
block|{
comment|/* Read target's base rep if any. */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rep_state
argument_list|,
operator|&
name|rep_header
argument_list|,
name|NULL
argument_list|,
name|target
operator|->
name|data_rep
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|&&
name|source
operator|->
name|data_rep
operator|&&
name|target
operator|->
name|data_rep
condition|)
block|{
comment|/* If that matches source, then use this delta as is.              Note that we want an actual delta here.  E.g. a self-delta would              not be good enough. */
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_delta
operator|&&
name|rep_header
operator|->
name|base_revision
operator|==
name|source
operator|->
name|data_rep
operator|->
name|revision
operator|&&
name|rep_header
operator|->
name|base_item_index
operator|==
name|source
operator|->
name|data_rep
operator|->
name|item_index
condition|)
block|{
operator|*
name|stream_p
operator|=
name|get_storaged_delta_stream
argument_list|(
name|rep_state
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|source
condition|)
block|{
comment|/* We want a self-delta. There is a fair chance that TARGET got              added in this revision and is already stored in the requested              format. */
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_self_delta
condition|)
block|{
operator|*
name|stream_p
operator|=
name|get_storaged_delta_stream
argument_list|(
name|rep_state
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Don't keep file handles open for longer than necessary. */
if|if
condition|(
name|rep_state
operator|->
name|sfile
operator|->
name|rfile
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rep_state
operator|->
name|sfile
operator|->
name|rfile
argument_list|)
argument_list|)
expr_stmt|;
name|rep_state
operator|->
name|sfile
operator|->
name|rfile
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Read both fulltexts and construct a delta. */
if|if
condition|(
name|source
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|source_stream
argument_list|,
name|fs
argument_list|,
name|source
operator|->
name|data_rep
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|source_stream
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|target_stream
argument_list|,
name|fs
argument_list|,
name|target
operator|->
name|data_rep
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because source and target stream will already verify their content,    * there is no need to do this once more.  In particular if the stream    * content is being fetched from cache. */
name|svn_txdelta2
argument_list|(
name|stream_p
argument_list|,
name|source_stream
argument_list|,
name|target_stream
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE when all svn_fs_dirent_t* in ENTRIES are already sorted    by their respective name. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|sorted
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
specifier|const
modifier|*
name|dirents
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|entries
operator|->
name|elts
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|dirents
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|dirents
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Compare the names of the two dirents given in **A and **B. */
end_comment

begin_function
specifier|static
name|int
name|compare_dirents
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|lhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
name|rhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|lhs
operator|->
name|name
argument_list|,
name|rhs
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the name of the dirents given in **A with the C string in *B. */
end_comment

begin_function
specifier|static
name|int
name|compare_dirent_name
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|lhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rhs
init|=
name|b
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|lhs
operator|->
name|name
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Into ENTRIES, read all directories entries from the key-value text in  * STREAM.  If INCREMENTAL is TRUE, read until the end of the STREAM and  * update the data.  ID is provided for nicer error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_dir_entries
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|hash
init|=
name|incremental
condition|?
name|svn_hash__make
argument_list|(
name|scratch_pool
argument_list|)
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|terminator
init|=
name|SVN_HASH_TERMINATOR
decl_stmt|;
comment|/* Read until the terminator (non-incremental) or the end of STREAM      (incremental mode).  In the latter mode, we use a temporary HASH      to make updating and removing entries cheaper. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_hash__entry_t
name|entry
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash__read_entry
argument_list|(
operator|&
name|entry
argument_list|,
name|stream
argument_list|,
name|terminator
argument_list|,
name|incremental
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* End of directory? */
if|if
condition|(
name|entry
operator|.
name|key
operator|==
name|NULL
condition|)
block|{
comment|/* In incremental mode, we skip the terminator and read the              increments following it until the end of the stream. */
if|if
condition|(
name|incremental
operator|&&
name|terminator
condition|)
name|terminator
operator|=
name|NULL
expr_stmt|;
else|else
break|break;
block|}
comment|/* Deleted entry? */
if|if
condition|(
name|entry
operator|.
name|val
operator|==
name|NULL
condition|)
block|{
comment|/* We must be in incremental mode */
name|assert
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|entry
operator|.
name|key
argument_list|,
name|entry
operator|.
name|keylen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add a new directory entry. */
name|dirent
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dirent
argument_list|)
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|name
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|entry
operator|.
name|key
argument_list|,
name|entry
operator|.
name|keylen
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|entry
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|SVN_FS_FS__KIND_FILE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dirent
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|SVN_FS_FS__KIND_DIR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dirent
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
block|}
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|entry
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|svn_fs_fs__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_parse
argument_list|(
operator|&
name|dirent
operator|->
name|id
argument_list|,
name|str
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In incremental mode, update the hash; otherwise, write to the        * final array.  Be sure to use hash keys that survive this iteration.        */
if|if
condition|(
name|incremental
condition|)
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|dirent
operator|->
name|name
argument_list|,
name|entry
operator|.
name|keylen
argument_list|,
name|dirent
argument_list|)
expr_stmt|;
else|else
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
operator|=
name|dirent
expr_stmt|;
block|}
comment|/* Convert container to a sorted array. */
if|if
condition|(
name|incremental
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|hash
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
operator|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sorted
argument_list|(
name|entries
argument_list|)
condition|)
name|svn_sort__array
argument_list|(
name|entries
argument_list|,
name|compare_dirents
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch the contents of a directory into ENTRIES.  Values are stored    as filename to string mappings; further conversion is necessary to    convert them into svn_fs_dirent_t values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir_contents
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
operator|*
name|entries
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_dirent_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|noderev
operator|->
name|data_rep
operator|->
name|txn_id
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|svn_fs_fs__path_txn_node_children
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* The representation is mutable.  Read the old directory          contents from the mutable children file, followed by the          changes we've made in this transaction. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|contents
argument_list|,
name|filename
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_dir_entries
argument_list|(
operator|*
name|entries
argument_list|,
name|contents
argument_list|,
name|TRUE
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
comment|/* Undeltify content before parsing it. Otherwise, we could only        * parse it byte-by-byte.        */
name|apr_size_t
name|len
init|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
condition|?
operator|(
name|apr_size_t
operator|)
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
else|:
operator|(
name|apr_size_t
operator|)
name|noderev
operator|->
name|data_rep
operator|->
name|size
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|text
decl_stmt|;
comment|/* The representation is immutable.  Read it normally. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_stream
argument_list|(
operator|&
name|text
argument_list|,
name|contents
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
comment|/* de-serialize hash */
name|contents
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|text
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_dir_entries
argument_list|(
operator|*
name|entries
argument_list|,
name|contents
argument_list|,
name|FALSE
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the cache object in FS responsible to storing the directory the  * NODEREV plus the corresponding *KEY.  If no cache exists, return NULL.  * PAIR_KEY must point to some key struct, which does not need to be  * initialized.  We use it to avoid dynamic allocation.  */
end_comment

begin_function
specifier|static
name|svn_cache__t
modifier|*
name|locate_dir_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|void
modifier|*
modifier|*
name|key
parameter_list|,
name|pair_cache_key_t
modifier|*
name|pair_key
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|svn_fs_fs__id_is_txn
argument_list|(
name|noderev
operator|->
name|id
argument_list|)
condition|)
block|{
comment|/* data in txns requires the expensive fs_id-based addressing mode */
operator|*
name|key
operator|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
expr_stmt|;
return|return
name|ffd
operator|->
name|txn_dir_cache
return|;
block|}
else|else
block|{
comment|/* committed data can use simple rev,item pairs */
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
name|pair_key
operator|->
name|revision
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|revision
expr_stmt|;
name|pair_key
operator|->
name|second
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|item_index
expr_stmt|;
operator|*
name|key
operator|=
name|pair_key
expr_stmt|;
block|}
else|else
block|{
comment|/* no data rep -> empty directory.              A NULL key causes a cache miss. */
operator|*
name|key
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|ffd
operator|->
name|dir_cache
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__rep_contents_dir
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|entries_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|pair_cache_key_t
name|pair_key
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
comment|/* find the cache we may use */
name|svn_cache__t
modifier|*
name|cache
init|=
name|locate_dir_cache
argument_list|(
name|fs
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|pair_key
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|svn_boolean_t
name|found
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|entries_p
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Read in the directory contents. */
name|SVN_ERR
argument_list|(
name|get_dir_contents
argument_list|(
name|entries_p
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the cache, if we are to use one.    *    * Don't even attempt to serialize very large directories; it would cause    * an unnecessary memory allocation peak.  150 bytes/entry is about right.    */
if|if
condition|(
name|cache
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|cache
argument_list|,
literal|150
operator|*
operator|(
operator|*
name|entries_p
operator|)
operator|->
name|nelts
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|cache
argument_list|,
name|key
argument_list|,
operator|*
name|entries_p
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_fs_dirent_t
modifier|*
name|svn_fs_fs__find_dir_entry
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|hint
parameter_list|)
block|{
name|svn_fs_dirent_t
modifier|*
modifier|*
name|result
init|=
name|svn_sort__array_lookup
argument_list|(
name|entries
argument_list|,
name|name
argument_list|,
name|hint
argument_list|,
name|compare_dirent_name
argument_list|)
decl_stmt|;
return|return
name|result
condition|?
operator|*
name|result
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__rep_contents_dir_entry
parameter_list|(
name|svn_fs_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
comment|/* find the cache we may use */
name|pair_cache_key_t
name|pair_key
init|=
block|{
literal|0
block|}
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|svn_cache__t
modifier|*
name|cache
init|=
name|locate_dir_cache
argument_list|(
name|fs
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|pair_key
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
comment|/* Cache lookup. */
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|dirent
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|svn_fs_fs__extract_dir_entry
argument_list|,
operator|(
name|void
operator|*
operator|)
name|name
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* fetch data from disk if we did not find it in the cache */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|entry
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|entry_copy
init|=
name|NULL
decl_stmt|;
comment|/* read the dir from the file system. It will probably be put it          into the cache for faster lookup in future calls. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find desired entry and return a copy in POOL, if found */
name|entry
operator|=
name|svn_fs_fs__find_dir_entry
argument_list|(
name|entries
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|entry_copy
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry_copy
argument_list|)
argument_list|)
expr_stmt|;
name|entry_copy
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|entry_copy
operator|->
name|id
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|entry
operator|->
name|id
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|entry_copy
operator|->
name|kind
operator|=
name|entry
operator|->
name|kind
expr_stmt|;
block|}
operator|*
name|dirent
operator|=
name|entry_copy
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
name|svn_fs_fs__id_txn_used
argument_list|(
operator|&
name|noderev
operator|->
name|prop_rep
operator|->
name|txn_id
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|svn_fs_fs__path_txn_node_props
argument_list|(
name|fs
argument_list|,
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrapf
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"malformed property list for node-revision '%s' in '%s'"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|,
name|filename
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|representation_t
modifier|*
name|rep
init|=
name|noderev
operator|->
name|prop_rep
decl_stmt|;
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rep
operator|->
name|item_index
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|properties_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|proplist_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|properties_cache
argument_list|,
operator|&
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_contents
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|prop_rep
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrapf
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"malformed property list for node-revision '%s'"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|properties_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|properties_cache
argument_list|,
operator|&
name|key
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return an empty prop list if the node doesn't have any props */
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|proplist_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_off_t
name|changes_offset
init|=
name|SVN_FS_FS__ITEM_INDEX_CHANGES
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|revision_file
decl_stmt|;
name|svn_boolean_t
name|found
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
comment|/* try cache lookup first */
if|if
condition|(
name|ffd
operator|->
name|changes_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|changes
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|rev
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|found
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* read changes from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_block_read
argument_list|(
name|fs
argument_list|)
condition|)
block|{
comment|/* 'block-read' will also provide us with the desired data */
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|changes
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|SVN_FS_FS__ITEM_INDEX_CHANGES
argument_list|,
name|revision_file
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Addressing is very different for old formats            * (needs to read the revision trailer). */
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|changes_offset
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|SVN_FS_FS__ITEM_INDEX_CHANGES
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|get_root_changes_offset
argument_list|(
name|NULL
argument_list|,
operator|&
name|changes_offset
argument_list|,
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Actual reading and parsing are the same, though. */
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|revision_file
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|changes_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_changes
argument_list|(
name|changes
argument_list|,
name|revision_file
operator|->
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cache for future reference */
if|if
condition|(
name|ffd
operator|->
name|changes_cache
condition|)
block|{
comment|/* Guesstimate for the size of the in-cache representation. */
name|apr_size_t
name|estimated_size
init|=
operator|(
name|apr_size_t
operator|)
literal|250
operator|*
operator|(
operator|*
name|changes
operator|)
operator|->
name|nelts
decl_stmt|;
comment|/* Don't even serialize data that probably won't fit into the                * cache.  This often implies that either CHANGES is very                * large, memory is scarce or both.  Having a huge temporary                * copy would not be a good thing in either case. */
if|if
condition|(
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|changes_cache
argument_list|,
name|estimated_size
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|rev
argument_list|,
operator|*
name|changes
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|revision_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|dbg_log_access
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|changes_offset
argument_list|,
operator|*
name|changes
argument_list|,
name|SVN_FS_FS__ITEM_TYPE_CHANGES
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Inialize the representation read state RS for the given REP_HEADER and  * p2l index ENTRY.  If not NULL, assign FILE and STREAM to RS.  * Use RESULT_POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_rep_state
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|svn_fs_fs__rep_header_t
modifier|*
name|rep_header
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|shared_file_t
modifier|*
name|shared_file
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shared_file
argument_list|)
argument_list|)
decl_stmt|;
comment|/* this function does not apply to representation containers */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|type
operator|>=
name|SVN_FS_FS__ITEM_TYPE_FILE_REP
operator|&&
name|entry
operator|->
name|type
operator|<=
name|SVN_FS_FS__ITEM_TYPE_DIR_PROPS
argument_list|)
expr_stmt|;
name|shared_file
operator|->
name|rfile
operator|=
name|file
expr_stmt|;
name|shared_file
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|shared_file
operator|->
name|revision
operator|=
name|entry
operator|->
name|item
operator|.
name|revision
expr_stmt|;
name|shared_file
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|rs
operator|->
name|sfile
operator|=
name|shared_file
expr_stmt|;
name|rs
operator|->
name|revision
operator|=
name|entry
operator|->
name|item
operator|.
name|revision
expr_stmt|;
name|rs
operator|->
name|item_index
operator|=
name|entry
operator|->
name|item
operator|.
name|number
expr_stmt|;
name|rs
operator|->
name|header_size
operator|=
name|rep_header
operator|->
name|header_size
expr_stmt|;
name|rs
operator|->
name|start
operator|=
name|entry
operator|->
name|offset
operator|+
name|rs
operator|->
name|header_size
expr_stmt|;
name|rs
operator|->
name|current
operator|=
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_plain
condition|?
literal|0
else|:
literal|4
expr_stmt|;
name|rs
operator|->
name|size
operator|=
name|entry
operator|->
name|size
operator|-
name|rep_header
operator|->
name|header_size
operator|-
literal|7
expr_stmt|;
name|rs
operator|->
name|ver
operator|=
literal|1
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|raw_window_cache
operator|=
name|ffd
operator|->
name|raw_window_cache
expr_stmt|;
name|rs
operator|->
name|window_cache
operator|=
name|ffd
operator|->
name|txdelta_window_cache
expr_stmt|;
name|rs
operator|->
name|combined_cache
operator|=
name|ffd
operator|->
name|combined_window_cache
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t for txdelta windows.  * Instead of the whole window data, return only END_OFFSET member.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_txdelta_window_end
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__txdelta_cached_window_t
modifier|*
name|window
init|=
operator|(
specifier|const
name|svn_fs_fs__txdelta_cached_window_t
operator|*
operator|)
name|data
decl_stmt|;
operator|*
operator|(
name|apr_off_t
operator|*
operator|)
name|out
operator|=
name|window
operator|->
name|end_offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t for raw windows.  * Instead of the whole window data, return only END_OFFSET member.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_raw_window_end
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|svn_fs_fs__raw_cached_window_t
modifier|*
name|window
init|=
operator|(
specifier|const
name|svn_fs_fs__raw_cached_window_t
operator|*
operator|)
name|data
decl_stmt|;
operator|*
operator|(
name|apr_off_t
operator|*
operator|)
name|out
operator|=
name|window
operator|->
name|end_offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Walk through all windows in the representation addressed by RS in FS  * (excluding the delta bases) and put those not already cached into the  * window caches.  If MAX_OFFSET is not -1, don't read windows that start  * at or beyond that offset.  Use POOL for temporary allocations.  *  * This function requires RS->RAW_WINDOW_CACHE and RS->WINDOW_CACHE to  * be non-NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cache_windows
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_off_t
name|max_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
while|while
condition|(
name|rs
operator|->
name|current
operator|<
name|rs
operator|->
name|size
condition|)
block|{
name|apr_off_t
name|end_offset
decl_stmt|;
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
name|window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_offset
operator|!=
operator|-
literal|1
operator|&&
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
operator|>=
name|max_offset
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We don't need to read the data again if it is already in cache.        * It might be cached as either raw or parsed window.        */
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|end_offset
argument_list|,
operator|&
name|found
argument_list|,
name|rs
operator|->
name|raw_window_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
name|get_raw_window_end
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|found
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|end_offset
argument_list|,
operator|&
name|found
argument_list|,
name|rs
operator|->
name|window_cache
argument_list|,
operator|&
name|key
argument_list|,
name|get_txdelta_window_end
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
name|rs
operator|->
name|current
operator|=
name|end_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* Read, decode and cache the window. */
name|svn_fs_fs__raw_cached_window_t
name|window
decl_stmt|;
name|apr_off_t
name|start_offset
init|=
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
decl_stmt|;
name|apr_size_t
name|window_len
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* navigate to the current window */
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|start_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta__read_raw_window_len
argument_list|(
operator|&
name|window_len
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the raw window. */
name|buf
operator|=
name|apr_palloc
argument_list|(
name|iterpool
argument_list|,
name|window_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|start_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|buf
argument_list|,
name|window_len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|buf
index|[
name|window_len
index|]
operator|=
literal|0
expr_stmt|;
comment|/* update relative offset in representation */
name|rs
operator|->
name|current
operator|+=
name|window_len
expr_stmt|;
comment|/* Construct the cachable raw window object. */
name|window
operator|.
name|end_offset
operator|=
name|rs
operator|->
name|current
expr_stmt|;
name|window
operator|.
name|window
operator|.
name|len
operator|=
name|window_len
expr_stmt|;
name|window
operator|.
name|window
operator|.
name|data
operator|=
name|buf
expr_stmt|;
comment|/* cache the window now */
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|raw_window_cache
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|window
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rs
operator|->
name|current
operator|>
name|rs
operator|->
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read beyond "
literal|"the end of the representation"
argument_list|)
argument_list|)
return|;
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read all txdelta / plain windows following REP_HEADER in FS as described  * by ENTRY.  Read the data from the already open FILE and the wrapping  * STREAM object.  If MAX_OFFSET is not -1, don't read windows that start  * at or beyond that offset.  Use SCRATCH_POOL for temporary allocations.  * If caching is not enabled, this is a no-op.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_windows
parameter_list|(
name|svn_fs_fs__rep_header_t
modifier|*
name|rep_header
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_off_t
name|max_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|rep_state_t
name|rs
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
operator|(
name|rep_header
operator|->
name|type
operator|!=
name|svn_fs_fs__rep_plain
operator|&&
operator|(
operator|!
name|ffd
operator|->
name|txdelta_window_cache
operator|||
operator|!
name|ffd
operator|->
name|raw_window_cache
operator|)
operator|)
operator|||
operator|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_plain
operator|&&
operator|!
name|ffd
operator|->
name|combined_window_cache
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|init_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
name|rep_header
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RS->FILE may be shared between RS instances -> make sure we point    * to the right data. */
name|offset
operator|=
name|rs
operator|.
name|start
operator|+
name|rs
operator|.
name|current
expr_stmt|;
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_fs__rep_plain
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|plaintext
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
comment|/* already in cache? */
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|rs
operator|.
name|combined_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|rs
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* for larger reps, the header may have crossed a block boundary.        * make sure we still read blocks properly aligned, i.e. don't use        * plain seek here. */
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|plaintext
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|rs
operator|.
name|size
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|plaintext
operator|->
name|data
argument_list|,
name|rs
operator|.
name|size
argument_list|,
operator|&
name|plaintext
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|plaintext
operator|->
name|data
index|[
name|plaintext
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|rs
operator|.
name|current
operator|+=
name|rs
operator|.
name|size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|set_cached_combined_window
argument_list|(
name|plaintext
argument_list|,
operator|&
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|cache_windows
argument_list|(
name|fs
argument_list|,
operator|&
name|rs
argument_list|,
name|max_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Try to get the representation header identified by KEY from FS's cache.  * If it has not been cached, read it from the current position in STREAM  * and put it into the cache (if caching has been enabled for rep headers).  * Return the result in *REP_HEADER.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_rep_header
parameter_list|(
name|svn_fs_fs__rep_header_t
modifier|*
modifier|*
name|rep_header
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|pair_cache_key_t
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|rep_header
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|rep_header_cache
argument_list|,
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_rep_header
argument_list|(
name|rep_header
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|rep_header_cache
argument_list|,
name|key
argument_list|,
operator|*
name|rep_header
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch the representation data (header, txdelta / plain windows)  * addressed by ENTRY->ITEM in FS and cache it if caches are enabled.  * Read the data from the already open FILE and the wrapping  * STREAM object.  If MAX_OFFSET is not -1, don't read windows that start  * at or beyond that offset.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_contents
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_off_t
name|max_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|pair_cache_key_t
name|header_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_fs_fs__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
name|header_key
operator|.
name|revision
operator|=
operator|(
name|apr_int32_t
operator|)
name|entry
operator|->
name|item
operator|.
name|revision
expr_stmt|;
name|header_key
operator|.
name|second
operator|=
name|entry
operator|->
name|item
operator|.
name|number
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_rep_header
argument_list|(
operator|&
name|rep_header
argument_list|,
name|fs
argument_list|,
name|rev_file
operator|->
name|stream
argument_list|,
operator|&
name|header_key
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|block_read_windows
argument_list|(
name|rep_header
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|max_offset
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For the given REV_FILE in FS, in *STREAM return a stream covering the  * item specified by ENTRY.  Also, verify the item's content by low-level  * checksum.  Allocate the result in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_item
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint32_t
name|digest
decl_stmt|;
name|svn_checksum_t
modifier|*
name|expected
decl_stmt|,
modifier|*
name|actual
decl_stmt|;
name|apr_uint32_t
name|plain_digest
decl_stmt|;
comment|/* Read item into string buffer. */
name|svn_stringbuf_t
modifier|*
name|text
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|entry
operator|->
name|size
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|text
operator|->
name|len
operator|=
name|entry
operator|->
name|size
expr_stmt|;
name|text
operator|->
name|data
index|[
name|text
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|text
operator|->
name|data
argument_list|,
name|text
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return (construct, calculate) stream and checksum. */
operator|*
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|text
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|digest
operator|=
name|svn__fnv1a_32x4
argument_list|(
name|text
operator|->
name|data
argument_list|,
name|text
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Checksums will match most of the time. */
if|if
condition|(
name|entry
operator|->
name|fnv1_checksum
operator|==
name|digest
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Construct proper checksum objects from their digests to allow for    * nice error messages. */
name|plain_digest
operator|=
name|htonl
argument_list|(
name|entry
operator|->
name|fnv1_checksum
argument_list|)
expr_stmt|;
name|expected
operator|=
name|svn_checksum__from_digest_fnv1a_32x4
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|plain_digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|plain_digest
operator|=
name|htonl
argument_list|(
name|digest
argument_list|)
expr_stmt|;
name|actual
operator|=
name|svn_checksum__from_digest_fnv1a_32x4
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|plain_digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Construct the full error message with all the info we have. */
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Low-level checksum mismatch while reading\n"
literal|"%s bytes of meta data at offset %s "
literal|"for item %s in revision %ld"
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
argument_list|,
name|entry
operator|->
name|size
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
argument_list|,
name|entry
operator|->
name|offset
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|entry
operator|->
name|item
operator|.
name|number
argument_list|)
argument_list|,
name|entry
operator|->
name|item
operator|.
name|revision
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* If not already cached or if MUST_READ is set, read the changed paths  * list addressed by ENTRY in FS and retÃºrn it in *CHANGES.  Cache the  * result if caching is enabled.  Read the data from the already open  * FILE and wrapping FILE_STREAM.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_boolean_t
name|must_read
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
operator|!
name|must_read
operator|&&
operator|!
name|ffd
operator|->
name|changes_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* already in cache? */
if|if
condition|(
operator|!
name|must_read
operator|&&
name|ffd
operator|->
name|changes_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|entry
operator|->
name|item
operator|.
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read changes from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_changes
argument_list|(
name|changes
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cache for future reference */
if|if
condition|(
name|ffd
operator|->
name|changes_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|entry
operator|->
name|item
operator|.
name|revision
argument_list|,
operator|*
name|changes
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If not already cached or if MUST_READ is set, read the nod revision  * addressed by ENTRY in FS and retÃºrn it in *NODEREV_P.  Cache the  * result if caching is enabled.  Read the data from the already open  * FILE and wrapping FILE_STREAM. Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_noderev
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_boolean_t
name|must_read
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|entry
operator|->
name|item
operator|.
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|entry
operator|->
name|item
operator|.
name|number
expr_stmt|;
if|if
condition|(
operator|!
name|must_read
operator|&&
operator|!
name|ffd
operator|->
name|node_revision_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* already in cache? */
if|if
condition|(
operator|!
name|must_read
operator|&&
name|ffd
operator|->
name|node_revision_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|node_revision_cache
argument_list|,
operator|&
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read node rev from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
name|noderev_p
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Workaround issue #4031: is-fresh-txn-root in revision files. */
operator|(
operator|*
name|noderev_p
operator|)
operator|->
name|is_fresh_txn_root
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|node_revision_cache
argument_list|,
operator|&
name|key
argument_list|,
operator|*
name|noderev_p
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the whole (e.g. 64kB) block containing ITEM_INDEX of REVISION in FS  * and put all data into cache.  If necessary and depending on heuristics,  * neighboring blocks may also get read.  The data is being read from  * already open REVISION_FILE, which must be the correct rev / pack file  * w.r.t. REVISION.  *  * For noderevs and changed path lists, the item fetched can be allocated  * RESULT_POOL and returned in *RESULT.  Otherwise, RESULT must be NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read
parameter_list|(
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_uint64_t
name|item_index
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|revision_file
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|,
name|wanted_offset
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|block_start
init|=
literal|0
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|int
name|run_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Block read is an optional feature. If the caller does not want anything    * specific we may not have to read anything. */
if|if
condition|(
operator|!
name|result
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* don't try this on transaction protorev files */
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* index lookup: find the OFFSET of the item we *must* read plus (in the    * "do-while" block) the list of items in the same block. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|wanted_offset
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|item_index
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|wanted_offset
expr_stmt|;
comment|/* Heuristics:    *    * Read this block.  If the last item crosses the block boundary, read    * the next block but stop there.  Because cross-boundary items cause    * blocks to be read twice, this heuristics will limit this effect to    * approx. 50% of blocks, probably less, while providing a sensible    * amount of read-ahead.    */
do|do
block|{
comment|/* fetch list of items in the block surrounding OFFSET */
name|block_start
operator|=
name|offset
operator|-
operator|(
name|offset
operator|%
name|ffd
operator|->
name|block_size
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|revision
argument_list|,
name|block_start
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|revision_file
operator|->
name|file
argument_list|,
operator|&
name|block_start
argument_list|,
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read all items from the block */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_boolean_t
name|is_result
decl_stmt|,
name|is_wanted
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* skip empty sections */
name|entry
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_UNUSED
condition|)
continue|continue;
comment|/* the item / container we were looking for? */
name|is_wanted
operator|=
name|entry
operator|->
name|offset
operator|==
name|wanted_offset
operator|&&
name|entry
operator|->
name|item
operator|.
name|revision
operator|==
name|revision
operator|&&
name|entry
operator|->
name|item
operator|.
name|number
operator|==
name|item_index
expr_stmt|;
name|is_result
operator|=
name|result
operator|&&
name|is_wanted
expr_stmt|;
comment|/* select the pool that we want the item to be allocated in */
name|pool
operator|=
name|is_result
condition|?
name|result_pool
else|:
name|iterpool
expr_stmt|;
comment|/* handle all items that start within this block and are relatively            * small (i.e.< block size).  Always read the item we need to return.            */
if|if
condition|(
name|is_result
operator|||
operator|(
name|entry
operator|->
name|offset
operator|>=
name|block_start
operator|&&
name|entry
operator|->
name|size
operator|<
name|ffd
operator|->
name|block_size
operator|)
condition|)
block|{
name|void
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|revision_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|type
condition|)
block|{
case|case
name|SVN_FS_FS__ITEM_TYPE_FILE_REP
case|:
case|case
name|SVN_FS_FS__ITEM_TYPE_DIR_REP
case|:
case|case
name|SVN_FS_FS__ITEM_TYPE_FILE_PROPS
case|:
case|case
name|SVN_FS_FS__ITEM_TYPE_DIR_PROPS
case|:
name|SVN_ERR
argument_list|(
name|block_read_contents
argument_list|(
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
name|is_wanted
condition|?
operator|-
literal|1
else|:
name|block_start
operator|+
name|ffd
operator|->
name|block_size
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVN_FS_FS__ITEM_TYPE_NODEREV
case|:
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
operator|||
name|is_result
condition|)
name|SVN_ERR
argument_list|(
name|block_read_noderev
argument_list|(
operator|(
name|node_revision_t
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
name|is_result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVN_FS_FS__ITEM_TYPE_CHANGES
case|:
name|SVN_ERR
argument_list|(
name|block_read_changes
argument_list|(
operator|(
name|apr_array_header_t
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
name|is_result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|is_result
condition|)
operator|*
name|result
operator|=
name|item
expr_stmt|;
comment|/* if we crossed a block boundary, read the remainder of                * the last block as well */
name|offset
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|block_start
operator|+
name|ffd
operator|->
name|block_size
condition|)
operator|++
name|run_count
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|run_count
operator|++
operator|==
literal|1
condition|)
do|;
comment|/* can only be true once and only if a block                             * boundary got crossed */
comment|/* if the caller requested a result, we must have provided one by now */
name|assert
argument_list|(
operator|!
name|result
operator|||
operator|*
name|result
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

