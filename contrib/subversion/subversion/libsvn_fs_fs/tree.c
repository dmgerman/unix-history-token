begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tree.c : tree-like filesystem, built on DAG filesystem  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* The job of this layer is to take a filesystem with lots of node    sharing going on --- the real DAG filesystem as it appears in the    database --- and make it look and act like an ordinary tree    filesystem, with no sharing.     We do just-in-time cloning: you can walk from some unfinished    transaction's root down into directories and files shared with    committed revisions; as soon as you try to change something, the    appropriate nodes get cloned (and parent directory entries updated)    invisibly, behind your back.  Any other references you have to    nodes that have been cloned by other changes, even made by other    processes, are automatically updated to point to the right clones.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* The root structures.     Why do they contain different data?  Well, transactions are mutable    enough that it isn't safe to cache the DAG node for the root    directory or the hash of copyfrom data: somebody else might modify    them concurrently on disk!  (Why is the DAG node cache safer than    the root DAG node?  When cloning transaction DAG nodes in and out    of the cache, all of the possibly-mutable data from the    node_revision_t inside the dag_node_t is dropped.)  Additionally,    revisions are immutable enough that their DAG node cache can be    kept in the FS object and shared among multiple revision root    objects. */
end_comment

begin_typedef
typedef|typedef
name|dag_node_t
name|fs_rev_root_data_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|fs_txn_root_data_t
block|{
comment|/* TXN_ID value from the main struct but as a struct instead of a string */
name|svn_fs_fs__id_part_t
name|txn_id
decl_stmt|;
comment|/* Cache of txn DAG nodes (without their nested noderevs, because    * it's mutable). Same keys/values as ffd->rev_node_cache. */
name|svn_cache__t
modifier|*
name|txn_node_cache
decl_stmt|;
block|}
name|fs_txn_root_data_t
typedef|;
end_typedef

begin_comment
comment|/* Declared here to resolve the circular dependencies. */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|get_dag
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|dag_node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_fs_root_t
modifier|*
name|make_revision_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|root_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|make_txn_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn
parameter_list|,
name|svn_revnum_t
name|base_rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|fs_closest_copy
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*** Node Caching ***/
end_comment

begin_comment
comment|/* 1st level cache */
end_comment

begin_comment
comment|/* An entry in the first-level cache.  REVISION and PATH form the key that    will ultimately be matched.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cache_entry_t
block|{
comment|/* hash value derived from PATH, REVISION.      Used to short-circuit failed lookups. */
name|apr_uint32_t
name|hash_value
decl_stmt|;
comment|/* revision to which the NODE belongs */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* path of the NODE */
name|char
modifier|*
name|path
decl_stmt|;
comment|/* cached value of strlen(PATH). */
name|apr_size_t
name|path_len
decl_stmt|;
comment|/* the node allocated in the cache's pool. NULL for empty entries. */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
block|}
name|cache_entry_t
typedef|;
end_typedef

begin_comment
comment|/* Number of entries in the cache.  Keep this low to keep pressure on the    CPU caches low as well.  A binary value is most efficient.  If we walk    a directory tree, we want enough entries to store nodes for all files    without overwriting the nodes for the parent folder.  That way, there    will be no unnecessary misses (except for a few random ones caused by    hash collision).     The actual number of instances may be higher but entries that got    overwritten are no longer visible.  */
end_comment

begin_enum
enum|enum
block|{
name|BUCKET_COUNT
init|=
literal|256
block|}
enum|;
end_enum

begin_comment
comment|/* The actual cache structure.  All nodes will be allocated in POOL.    When the number of INSERTIONS (i.e. objects created form that pool)    exceeds a certain threshold, the pool will be cleared and the cache    with it.  */
end_comment

begin_struct
struct|struct
name|fs_fs_dag_cache_t
block|{
comment|/* fixed number of (possibly empty) cache entries */
name|cache_entry_t
name|buckets
index|[
name|BUCKET_COUNT
index|]
decl_stmt|;
comment|/* pool used for all node allocation */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* number of entries created from POOL since the last cleanup */
name|apr_size_t
name|insertions
decl_stmt|;
comment|/* Property lookups etc. have a very high locality (75% re-hit).      Thus, remember the last hit location for optimistic lookup. */
name|apr_size_t
name|last_hit
decl_stmt|;
comment|/* Position of the last bucket hit that actually had a DAG node in it.      LAST_HIT may refer to a bucket that matches path@rev but has not      its NODE element set, yet.      This value is a mere hint for optimistic lookup and any value is      valid (as long as it is< BUCKET_COUNT). */
name|apr_size_t
name|last_non_empty
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|fs_fs_dag_cache_t
modifier|*
name|svn_fs_fs__create_dag_cache
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_fs_dag_cache_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Clears the CACHE at regular intervals (destroying all cached nodes)  */
end_comment

begin_function
specifier|static
name|void
name|auto_clear_dag_cache
parameter_list|(
name|fs_fs_dag_cache_t
modifier|*
name|cache
parameter_list|)
block|{
if|if
condition|(
name|cache
operator|->
name|insertions
operator|>
name|BUCKET_COUNT
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|cache
operator|->
name|pool
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|cache
operator|->
name|buckets
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|cache
operator|->
name|buckets
argument_list|)
argument_list|)
expr_stmt|;
name|cache
operator|->
name|insertions
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* For the given REVISION and PATH, return the respective entry in CACHE.    If the entry is empty, its NODE member will be NULL and the caller    may then set it to the corresponding DAG node allocated in CACHE->POOL.  */
end_comment

begin_function
specifier|static
name|cache_entry_t
modifier|*
name|cache_lookup
parameter_list|(
name|fs_fs_dag_cache_t
modifier|*
name|cache
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|bucket_index
decl_stmt|;
name|apr_size_t
name|path_len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
name|apr_uint32_t
name|hash_value
init|=
operator|(
name|apr_uint32_t
operator|)
name|revision
decl_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* "randomizing" / distributing factor used in our hash function */
specifier|const
name|apr_uint32_t
name|factor
init|=
literal|0xd1f3da69
decl_stmt|;
endif|#
directive|endif
comment|/* optimistic lookup: hit the same bucket again? */
name|cache_entry_t
modifier|*
name|result
init|=
operator|&
name|cache
operator|->
name|buckets
index|[
name|cache
operator|->
name|last_hit
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|result
operator|->
name|revision
operator|==
name|revision
operator|)
operator|&&
operator|(
name|result
operator|->
name|path_len
operator|==
name|path_len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|result
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
condition|)
block|{
comment|/* Remember the position of the last node we found in this cache. */
if|if
condition|(
name|result
operator|->
name|node
condition|)
name|cache
operator|->
name|last_non_empty
operator|=
name|cache
operator|->
name|last_hit
expr_stmt|;
return|return
name|result
return|;
block|}
comment|/* need to do a full lookup.  Calculate the hash value      (HASH_VALUE has been initialized to REVISION).       Note that the actual hash function is arbitrary as long as its result      in HASH_VALUE only depends on REVISION and *PATH.  However, we try to      make as much of *PATH influence the result as possible to get an "even"      spread across the hash buckets (maximizes our cache retention rate and      thus the hit rates).       When chunked access is possible (independent of the PATH pointer's      value!), we read 4 bytes at once and multiply the hash value with a      FACTOR that mirror / pattern / shift all 4 input bytes to various bits      of the result.  The final result will be taken from the MSBs.       When chunked access is not possible (not supported by CPU or odd bytes      at the end of *PATH), we use the simple traditional "* 33" hash      function that works very well with texts / paths and that e.g. APR uses.       Please note that the bytewise and the chunked calculation are *NOT*      interchangeable as they will yield different results for the same input.      For any given machine and *PATH, we must use a fixed combination of the      two functions.    */
name|i
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* We relax the dependency chain between iterations by processing      two chunks from the input per hash_value self-multiplication.      The HASH_VALUE update latency is now 1 MUL latency + 1 ADD latency      per 2 chunks instead of 1 chunk.    */
for|for
control|(
init|;
name|i
operator|+
literal|8
operator|<=
name|path_len
condition|;
name|i
operator|+=
literal|8
control|)
name|hash_value
operator|=
name|hash_value
operator|*
name|factor
operator|*
name|factor
operator|+
operator|(
operator|*
operator|(
specifier|const
name|apr_uint32_t
operator|*
operator|)
operator|(
name|path
operator|+
name|i
operator|)
operator|*
name|factor
operator|+
operator|*
operator|(
specifier|const
name|apr_uint32_t
operator|*
operator|)
operator|(
name|path
operator|+
name|i
operator|+
literal|4
operator|)
operator|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
name|i
operator|<
name|path_len
condition|;
operator|++
name|i
control|)
comment|/* Help GCC to minimize the HASH_VALUE update latency by splitting the        MUL 33 of the naive implementation: h = h * 33 + path[i].  This        shortens the dependency chain from 1 shift + 2 ADDs to 1 shift + 1 ADD.      */
name|hash_value
operator|=
name|hash_value
operator|*
literal|32
operator|+
operator|(
name|hash_value
operator|+
operator|(
name|unsigned
name|char
operator|)
name|path
index|[
name|i
index|]
operator|)
expr_stmt|;
name|bucket_index
operator|=
name|hash_value
operator|+
operator|(
name|hash_value
operator|>>
literal|16
operator|)
expr_stmt|;
name|bucket_index
operator|=
operator|(
name|bucket_index
operator|+
operator|(
name|bucket_index
operator|>>
literal|8
operator|)
operator|)
operator|%
name|BUCKET_COUNT
expr_stmt|;
comment|/* access the corresponding bucket and remember its location */
name|result
operator|=
operator|&
name|cache
operator|->
name|buckets
index|[
name|bucket_index
index|]
expr_stmt|;
name|cache
operator|->
name|last_hit
operator|=
name|bucket_index
expr_stmt|;
comment|/* if it is *NOT* a match,  clear the bucket, expect the caller to fill      in the node and count it as an insertion */
if|if
condition|(
operator|(
name|result
operator|->
name|hash_value
operator|!=
name|hash_value
operator|)
operator|||
operator|(
name|result
operator|->
name|revision
operator|!=
name|revision
operator|)
operator|||
operator|(
name|result
operator|->
name|path_len
operator|!=
name|path_len
operator|)
operator|||
name|memcmp
argument_list|(
name|result
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
condition|)
block|{
name|result
operator|->
name|hash_value
operator|=
name|hash_value
expr_stmt|;
name|result
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|path_len
operator|<
name|path_len
condition|)
name|result
operator|->
name|path
operator|=
name|apr_palloc
argument_list|(
name|cache
operator|->
name|pool
argument_list|,
name|path_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|->
name|path_len
operator|=
name|path_len
expr_stmt|;
name|memcpy
argument_list|(
name|result
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|path_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|result
operator|->
name|node
operator|=
name|NULL
expr_stmt|;
name|cache
operator|->
name|insertions
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|result
operator|->
name|node
condition|)
block|{
comment|/* This bucket is valid& has a suitable DAG node in it.          Remember its location. */
name|cache
operator|->
name|last_non_empty
operator|=
name|bucket_index
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Optimistic lookup using the last seen non-empty location in CACHE.    Return the node of that entry, if it is still in use and matches PATH.    Return NULL otherwise.  Since the caller usually already knows the path    length, provide it in PATH_LEN. */
end_comment

begin_function
specifier|static
name|dag_node_t
modifier|*
name|cache_lookup_last_path
parameter_list|(
name|fs_fs_dag_cache_t
modifier|*
name|cache
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_size_t
name|path_len
parameter_list|)
block|{
name|cache_entry_t
modifier|*
name|result
init|=
operator|&
name|cache
operator|->
name|buckets
index|[
name|cache
operator|->
name|last_non_empty
index|]
decl_stmt|;
name|assert
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|==
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|->
name|node
operator|&&
operator|(
name|result
operator|->
name|path_len
operator|==
name|path_len
operator|)
operator|&&
operator|!
name|memcmp
argument_list|(
name|result
operator|->
name|path
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
condition|)
block|{
return|return
name|result
operator|->
name|node
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* 2nd level cache */
end_comment

begin_comment
comment|/* Find and return the DAG node cache for ROOT and the key that    should be used for PATH.     Pool will only be used for allocating a new keys if necessary */
end_comment

begin_function
specifier|static
name|void
name|locate_cache
parameter_list|(
name|svn_cache__t
modifier|*
modifier|*
name|cache
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
block|{
name|fs_txn_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|cache
condition|)
operator|*
name|cache
operator|=
name|frd
operator|->
name|txn_node_cache
expr_stmt|;
if|if
condition|(
name|key
operator|&&
name|path
condition|)
operator|*
name|key
operator|=
name|path
expr_stmt|;
block|}
else|else
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|cache
condition|)
operator|*
name|cache
operator|=
name|ffd
operator|->
name|rev_node_cache
expr_stmt|;
if|if
condition|(
name|key
operator|&&
name|path
condition|)
operator|*
name|key
operator|=
name|svn_fs_fs__combine_number_and_string
argument_list|(
name|root
operator|->
name|rev
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* In *NODE_P, return the DAG node for PATH from ROOT's node cache, or NULL    if the node isn't cached.  *NODE_P is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dag_node_cache_get
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|found
decl_stmt|;
name|dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
name|svn_cache__t
modifier|*
name|cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|path
operator|==
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
block|{
comment|/* immutable DAG node. use the global caches for it */
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|cache_entry_t
modifier|*
name|bucket
decl_stmt|;
name|auto_clear_dag_cache
argument_list|(
name|ffd
operator|->
name|dag_node_cache
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|cache_lookup
argument_list|(
name|ffd
operator|->
name|dag_node_cache
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|bucket
operator|->
name|node
operator|==
name|NULL
condition|)
block|{
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|node
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
name|node
condition|)
block|{
comment|/* Patch up the FS, since this might have come from an old FS                * object. */
name|svn_fs_fs__dag_set_fs
argument_list|(
name|node
argument_list|,
name|root
operator|->
name|fs
argument_list|)
expr_stmt|;
comment|/* Retain the DAG node in L1 cache. */
name|bucket
operator|->
name|node
operator|=
name|svn_fs_fs__dag_dup
argument_list|(
name|node
argument_list|,
name|ffd
operator|->
name|dag_node_cache
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Copy the node from L1 cache into the passed-in POOL. */
name|node
operator|=
name|svn_fs_fs__dag_dup
argument_list|(
name|bucket
operator|->
name|node
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* DAG is mutable / may become invalid. Use the TXN-local cache */
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|node
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
name|node
condition|)
block|{
comment|/* Patch up the FS, since this might have come from an old FS            * object. */
name|svn_fs_fs__dag_set_fs
argument_list|(
name|node
argument_list|,
name|root
operator|->
name|fs
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add the NODE for PATH to ROOT's node cache. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dag_node_cache_set
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cache__t
modifier|*
name|cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|path
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|cache
argument_list|,
name|key
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton for find_descendants_in_cache. */
end_comment

begin_struct
struct|struct
name|fdic_baton
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If the given item is a descendant of BATON->PATH, push  * it onto BATON->LIST (copying into BATON->POOL).  Implements  * the svn_iter_apr_hash_cb_t prototype. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_descendants_in_cache
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|fdic_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|item_path
init|=
name|key
decl_stmt|;
if|if
condition|(
name|svn_fspath__skip_ancestor
argument_list|(
name|b
operator|->
name|path
argument_list|,
name|item_path
argument_list|)
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|b
operator|->
name|list
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|item_path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Invalidate cache entries for PATH and any of its children.  This    should *only* be called on a transaction root! */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dag_node_cache_invalidate
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|fdic_baton
name|b
decl_stmt|;
name|svn_cache__t
modifier|*
name|cache
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|b
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|b
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|b
operator|.
name|list
operator|=
name|apr_array_make
argument_list|(
name|b
operator|.
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|root
operator|->
name|is_txn_root
argument_list|)
expr_stmt|;
name|locate_cache
argument_list|(
operator|&
name|cache
argument_list|,
name|NULL
argument_list|,
name|root
argument_list|,
name|NULL
argument_list|,
name|b
operator|.
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__iter
argument_list|(
name|NULL
argument_list|,
name|cache
argument_list|,
name|find_descendants_in_cache
argument_list|,
operator|&
name|b
argument_list|,
name|b
operator|.
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|b
operator|.
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|b
operator|.
name|list
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|descendant
init|=
name|APR_ARRAY_IDX
argument_list|(
name|b
operator|.
name|list
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|cache
argument_list|,
name|descendant
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|b
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creating transaction and revision root nodes.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__txn_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint32_t
name|flags
init|=
literal|0
decl_stmt|;
name|apr_hash_t
modifier|*
name|txnprops
decl_stmt|;
comment|/* Look for the temporary txn props representing 'flags'. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__txn_proplist
argument_list|(
operator|&
name|txnprops
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txnprops
condition|)
block|{
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|)
condition|)
name|flags
operator||=
name|SVN_FS_TXN_CHECK_OOD
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|)
condition|)
name|flags
operator||=
name|SVN_FS_TXN_CHECK_LOCKS
expr_stmt|;
block|}
return|return
name|make_txn_root
argument_list|(
name|root_p
argument_list|,
name|txn
operator|->
name|fs
argument_list|,
name|svn_fs_fs__txn_get_id
argument_list|(
name|txn
argument_list|)
argument_list|,
name|txn
operator|->
name|base_rev
argument_list|,
name|flags
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__revision_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_revision_root
argument_list|(
operator|&
name|root_dir
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_p
operator|=
name|make_revision_root
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|root_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Getting dag nodes for roots.  */
end_comment

begin_comment
comment|/* Return the transaction ID to a given transaction ROOT. */
end_comment

begin_function
specifier|static
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|root_txn_id
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|)
block|{
name|fs_txn_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
name|assert
argument_list|(
name|root
operator|->
name|is_txn_root
argument_list|)
expr_stmt|;
return|return
operator|&
name|frd
operator|->
name|txn_id
return|;
block|}
end_function

begin_comment
comment|/* Set *NODE_P to a freshly opened dag node referring to the root    directory of ROOT, allocating from POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|root_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
block|{
comment|/* It's a transaction root.  Open a fresh copy.  */
return|return
name|svn_fs_fs__dag_txn_root
argument_list|(
name|node_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root_txn_id
argument_list|(
name|root
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
else|else
block|{
comment|/* It's a revision root, so we already have its root directory          opened.  */
name|dag_node_t
modifier|*
name|root_dir
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|node_p
operator|=
name|svn_fs_fs__dag_dup
argument_list|(
name|root_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set *NODE_P to a mutable root directory for ROOT, cloning if    necessary, allocating in POOL.  ROOT must be a transaction root.    Use ERROR_PATH in error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mutable_root_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|error_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
block|{
comment|/* It's a transaction root.  Open a fresh copy.  */
return|return
name|svn_fs_fs__dag_clone_root
argument_list|(
name|node_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root_txn_id
argument_list|(
name|root
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
else|else
comment|/* If it's not a transaction root, we can't change its contents.  */
return|return
name|SVN_FS__ERR_NOT_MUTABLE
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|error_path
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Traversing directory paths.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|copy_id_inherit_t
block|{
name|copy_id_inherit_unknown
init|=
literal|0
block|,
name|copy_id_inherit_self
block|,
name|copy_id_inherit_parent
block|,
name|copy_id_inherit_new
block|}
name|copy_id_inherit_t
typedef|;
end_typedef

begin_comment
comment|/* A linked list representing the path from a node up to a root    directory.  We use this for cloning, and for operations that need    to deal with both a node and its parent directory.  For example, a    `delete' operation needs to know that the node actually exists, but    also needs to change the parent directory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|parent_path_t
block|{
comment|/* A node along the path.  This could be the final node, one of its      parents, or the root.  Every parent path ends with an element for      the root directory.  */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* The name NODE has in its parent directory.  This is zero for the      root directory, which (obviously) has no name in its parent.  */
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* The parent of NODE, or zero if NODE is the root directory.  */
name|struct
name|parent_path_t
modifier|*
name|parent
decl_stmt|;
comment|/* The copy ID inheritance style. */
name|copy_id_inherit_t
name|copy_inherit
decl_stmt|;
comment|/* If copy ID inheritance style is copy_id_inherit_new, this is the      path which should be implicitly copied; otherwise, this is NULL. */
specifier|const
name|char
modifier|*
name|copy_src_path
decl_stmt|;
block|}
name|parent_path_t
typedef|;
end_typedef

begin_comment
comment|/* Return a text string describing the absolute path of parent_path    PARENT_PATH.  It will be allocated in POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parent_path_path
parameter_list|(
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|"/"
decl_stmt|;
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
name|path_so_far
operator|=
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|parent_path
operator|->
name|entry
condition|?
name|svn_fspath__join
argument_list|(
name|path_so_far
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|pool
argument_list|)
else|:
name|path_so_far
return|;
block|}
end_function

begin_comment
comment|/* Return the FS path for the parent path chain object CHILD relative    to its ANCESTOR in the same chain, allocated in POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parent_path_relpath
parameter_list|(
name|parent_path_t
modifier|*
name|child
parameter_list|,
name|parent_path_t
modifier|*
name|ancestor
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|""
decl_stmt|;
name|parent_path_t
modifier|*
name|this_node
init|=
name|child
decl_stmt|;
while|while
condition|(
name|this_node
operator|!=
name|ancestor
condition|)
block|{
name|assert
argument_list|(
name|this_node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|path_so_far
operator|=
name|svn_relpath_join
argument_list|(
name|this_node
operator|->
name|entry
argument_list|,
name|path_so_far
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|this_node
operator|=
name|this_node
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|path_so_far
return|;
block|}
end_function

begin_comment
comment|/* Choose a copy ID inheritance method *INHERIT_P to be used in the    event that immutable node CHILD in FS needs to be made mutable.  If    the inheritance method is copy_id_inherit_new, also return a    *COPY_SRC_PATH on which to base the new copy ID (else return NULL    for that path).  CHILD must have a parent (it cannot be the root    node).  Allocations are taken from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_copy_inheritance
parameter_list|(
name|copy_id_inherit_t
modifier|*
name|inherit_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|copy_src_path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|parent_path_t
modifier|*
name|child
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|child_id
decl_stmt|,
modifier|*
name|parent_id
decl_stmt|,
modifier|*
name|copyroot_id
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|child_copy_id
decl_stmt|,
modifier|*
name|parent_copy_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|id_path
init|=
name|NULL
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyroot_root
decl_stmt|;
name|dag_node_t
modifier|*
name|copyroot_node
decl_stmt|;
name|svn_revnum_t
name|copyroot_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyroot_path
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
operator|&&
name|child
operator|->
name|parent
argument_list|)
expr_stmt|;
comment|/* Initialize some convenience variables. */
name|child_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|child
operator|->
name|node
argument_list|)
expr_stmt|;
name|parent_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|child
operator|->
name|parent
operator|->
name|node
argument_list|)
expr_stmt|;
name|child_copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|child_id
argument_list|)
expr_stmt|;
name|parent_copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|parent_id
argument_list|)
expr_stmt|;
comment|/* If this child is already mutable, we have nothing to do. */
if|if
condition|(
name|svn_fs_fs__id_is_txn
argument_list|(
name|child_id
argument_list|)
condition|)
block|{
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_self
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* From this point on, we'll assume that the child will just take      its copy ID from its parent. */
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_parent
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
comment|/* Special case: if the child's copy ID is '0', use the parent's      copy ID. */
if|if
condition|(
name|svn_fs_fs__id_part_is_root
argument_list|(
name|child_copy_id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Compare the copy IDs of the child and its parent.  If they are      the same, then the child is already on the same branch as the      parent, and should use the same mutability copy ID that the      parent will use. */
if|if
condition|(
name|svn_fs_fs__id_part_eq
argument_list|(
name|child_copy_id
argument_list|,
name|parent_copy_id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the child is on the same branch that the parent is on, the      child should just use the same copy ID that the parent would use.      Else, the child needs to generate a new copy ID to use should it      need to be made mutable.  We will claim that child is on the same      branch as its parent if the child itself is not a branch point,      or if it is a branch point that we are accessing via its original      copy destination path. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyroot
argument_list|(
operator|&
name|copyroot_rev
argument_list|,
operator|&
name|copyroot_path
argument_list|,
name|child
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copyroot_root
argument_list|,
name|fs
argument_list|,
name|copyroot_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|copyroot_node
argument_list|,
name|copyroot_root
argument_list|,
name|copyroot_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copyroot_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|copyroot_node
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__id_compare
argument_list|(
name|copyroot_id
argument_list|,
name|child_id
argument_list|)
operator|==
name|svn_fs_node_unrelated
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Determine if we are looking at the child via its original path or      as a subtree item of a copied tree. */
name|id_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|child
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|id_path
argument_list|,
name|parent_path_path
argument_list|(
name|child
argument_list|,
name|pool
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_self
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We are pretty sure that the child node is an unedited nested      branched node.  When it needs to be made mutable, it should claim      a new copy ID. */
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_new
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|id_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new parent_path_t node from POOL, referring to NODE,    ENTRY, PARENT, and COPY_ID.  */
end_comment

begin_function
specifier|static
name|parent_path_t
modifier|*
name|make_parent_path
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|entry
parameter_list|,
name|parent_path_t
modifier|*
name|parent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parent_path
argument_list|)
argument_list|)
decl_stmt|;
name|parent_path
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|parent_path
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|parent_path
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|copy_id_inherit_unknown
expr_stmt|;
name|parent_path
operator|->
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
return|return
name|parent_path
return|;
block|}
end_function

begin_comment
comment|/* Flags for open_path.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|open_path_flags_t
block|{
comment|/* The last component of the PATH need not exist.  (All parent      directories must exist, as usual.)  If the last component doesn't      exist, simply leave the `node' member of the bottom parent_path      component zero.  */
name|open_path_last_optional
init|=
literal|1
block|,
comment|/* When this flag is set, don't bother to lookup the DAG node in      our caches because we already tried this.  Ignoring this flag      has no functional impact.  */
name|open_path_uncached
init|=
literal|2
block|,
comment|/* The caller does not care about the parent node chain but only      the final DAG node. */
name|open_path_node_only
init|=
literal|4
block|,
comment|/* The caller wants a NULL path object instead of an error if the      path cannot be found. */
name|open_path_allow_null
init|=
literal|8
block|}
name|open_path_flags_t
typedef|;
end_typedef

begin_comment
comment|/* Try a short-cut for the open_path() function using the last node accessed.  * If that ROOT is that nodes's "created rev" and PATH of PATH_LEN chars is  * its "created path", return the node in *NODE_P.  Set it to NULL otherwise.  *  * This function is used to support ra_serf-style access patterns where we  * are first asked for path@rev and then for path@c_rev of the same node.  * The shortcut works by ignoring the "rev" part of the cache key and then  * checking whether we got lucky.  Lookup and verification are both quick  * plus there are many early outs for common types of mismatch.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|try_match_last_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_size_t
name|path_len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Optimistic lookup: if the last node returned from the cache applied to      the same PATH, return it in NODE. */
name|dag_node_t
modifier|*
name|node
init|=
name|cache_lookup_last_path
argument_list|(
name|ffd
operator|->
name|dag_node_cache
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
decl_stmt|;
comment|/* Did we get a bucket with a committed node? */
if|if
condition|(
name|node
operator|&&
operator|!
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
comment|/* Get the path&rev pair at which this node was created.          This is repository location for which this node is _known_ to be          the right lookup result irrespective of how we found it. */
specifier|const
name|char
modifier|*
name|created_path
init|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|revision
argument_list|,
name|node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is it an exact match? */
if|if
condition|(
name|revision
operator|==
name|root
operator|->
name|rev
operator|&&
name|strcmp
argument_list|(
name|created_path
argument_list|,
name|path
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Cache it under its full path@rev access path. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|path
argument_list|,
name|node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
operator|*
name|node_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the node identified by PATH in ROOT, allocating in POOL.  Set    *PARENT_PATH_P to a path from the node up to ROOT.  The resulting    **PARENT_PATH_P value is guaranteed to contain at least one    *element, for the root directory.  PATH must be in canonical form.     If resulting *PARENT_PATH_P will eventually be made mutable and    modified, or if copy ID inheritance information is otherwise needed,    IS_TXN_PATH must be set.  If IS_TXN_PATH is FALSE, no copy ID    inheritance information will be calculated for the *PARENT_PATH_P chain.     If FLAGS& open_path_last_optional is zero, return the error    SVN_ERR_FS_NOT_FOUND if the node PATH refers to does not exist.  If    non-zero, require all the parent directories to exist as normal,    but if the final path component doesn't exist, simply return a path    whose bottom `node' member is zero.  This option is useful for    callers that create new nodes --- we find the parent directory for    them, and tell them whether the entry exists already.     The remaining bits in FLAGS are hints that allow this function    to take shortcuts based on knowledge that the caller provides,    such as the caller is not actually being interested in PARENT_PATH_P,    but only in (*PARENT_PATH_P)->NODE.     NOTE: Public interfaces which only *read* from the filesystem    should not call this function directly, but should instead use    get_dag(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_path
parameter_list|(
name|parent_path_t
modifier|*
modifier|*
name|parent_path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
name|svn_boolean_t
name|is_txn_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|dag_node_t
modifier|*
name|here
init|=
name|NULL
decl_stmt|;
comment|/* The directory we're currently looking at.  */
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
comment|/* The path from HERE up to the root. */
specifier|const
name|char
modifier|*
name|rest
init|=
name|NULL
decl_stmt|;
comment|/* The portion of PATH we haven't traversed yet. */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* path to the currently processed entry without trailing '/'.      We will reuse this across iterations by simply putting a NUL terminator      at the respective position and replacing that with a '/' in the next      iteration.  This is correct as we assert() PATH to be canonical. */
name|svn_stringbuf_t
modifier|*
name|path_so_far
init|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_size_t
name|path_len
init|=
name|path_so_far
operator|->
name|len
decl_stmt|;
comment|/* Callers often traverse the DAG in some path-based order or along the      history segments.  That allows us to try a few guesses about where to      find the next item.  This is only useful if the caller didn't request      the full parent chain. */
name|assert
argument_list|(
name|svn_fs__is_canonical_abspath
argument_list|(
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|path_so_far
operator|->
name|len
operator|=
literal|0
expr_stmt|;
comment|/* "" */
if|if
condition|(
name|flags
operator|&
name|open_path_node_only
condition|)
block|{
specifier|const
name|char
modifier|*
name|directory
decl_stmt|;
comment|/* First attempt: Assume that we access the DAG for the same path as          in the last lookup but for a different revision that happens to be          the last revision that touched the respective node.  This is a          common pattern when e.g. checking out over ra_serf.  Note that this          will only work for committed data as the revision info for nodes in          txns is bogus.           This shortcut is quick and will exit this function upon success.          So, try it first. */
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|try_match_last_node
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did the shortcut work? */
if|if
condition|(
name|node
condition|)
block|{
comment|/* Construct and return the result. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|node
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|copy_id_inherit_self
expr_stmt|;
operator|*
name|parent_path_p
operator|=
name|parent_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Second attempt: Try starting the lookup immediately at the parent          node.  We will often have recently accessed either a sibling or          said parent DIRECTORY itself for the same revision. */
name|directory
operator|=
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|directory
index|[
literal|1
index|]
operator|!=
literal|0
condition|)
comment|/* root nodes are covered anyway */
block|{
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|here
argument_list|,
name|root
argument_list|,
name|directory
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did the shortcut work? */
if|if
condition|(
name|here
condition|)
block|{
name|apr_size_t
name|dirname_len
init|=
name|strlen
argument_list|(
name|directory
argument_list|)
decl_stmt|;
name|path_so_far
operator|->
name|len
operator|=
name|dirname_len
expr_stmt|;
name|rest
operator|=
name|path
operator|+
name|dirname_len
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
comment|/* did the shortcut work? */
if|if
condition|(
operator|!
name|here
condition|)
block|{
comment|/* Make a parent_path item for the root node, using its own current          copy id.  */
name|SVN_ERR
argument_list|(
name|root_node
argument_list|(
operator|&
name|here
argument_list|,
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|path
operator|+
literal|1
expr_stmt|;
comment|/* skip the leading '/', it saves in iteration */
block|}
name|path_so_far
operator|->
name|data
index|[
name|path_so_far
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|here
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|copy_id_inherit_self
expr_stmt|;
comment|/* Whenever we are at the top of this loop:      - HERE is our current directory,      - ID is the node revision ID of HERE,      - REST is the path we're going to find in HERE, and      - PARENT_PATH includes HERE and all its parents.  */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Parse out the next entry from the path.  */
name|entry
operator|=
name|svn_fs__next_entry_name
argument_list|(
operator|&
name|next
argument_list|,
name|rest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Update the path traversed thus far. */
name|path_so_far
operator|->
name|data
index|[
name|path_so_far
operator|->
name|len
index|]
operator|=
literal|'/'
expr_stmt|;
name|path_so_far
operator|->
name|len
operator|+=
name|strlen
argument_list|(
name|entry
argument_list|)
operator|+
literal|1
expr_stmt|;
name|path_so_far
operator|->
name|data
index|[
name|path_so_far
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|entry
operator|==
literal|'\0'
condition|)
block|{
comment|/* Given the behavior of svn_fs__next_entry_name(), this              happens when the path either starts or ends with a slash.              In either case, we stay put: the current directory stays              the same, and we add nothing to the parent path. */
name|child
operator|=
name|here
expr_stmt|;
block|}
else|else
block|{
name|copy_id_inherit_t
name|inherit
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
init|=
name|NULL
decl_stmt|;
name|dag_node_t
modifier|*
name|cached_node
init|=
name|NULL
decl_stmt|;
comment|/* If we found a directory entry, follow it.  First, we              check our node cache, and, failing that, we hit the DAG              layer.  Don't bother to contact the cache for the last              element if we already know the lookup to fail for the              complete path. */
if|if
condition|(
name|next
operator|||
operator|!
operator|(
name|flags
operator|&
name|open_path_uncached
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|cached_node
argument_list|,
name|root
argument_list|,
name|path_so_far
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_node
condition|)
name|child
operator|=
name|cached_node
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_open
argument_list|(
operator|&
name|child
argument_list|,
name|here
argument_list|,
name|entry
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "file not found" requires special handling.  */
if|if
condition|(
name|child
operator|==
name|NULL
condition|)
block|{
comment|/* If this was the last path component, and the caller                  said it was optional, then don't return an error;                  just put a NULL node pointer in the path.  */
if|if
condition|(
operator|(
name|flags
operator|&
name|open_path_last_optional
operator|)
operator|&&
operator|(
operator|!
name|next
operator|||
operator|*
name|next
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|NULL
argument_list|,
name|entry
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|flags
operator|&
name|open_path_allow_null
condition|)
block|{
name|parent_path
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Build a better error message than svn_fs_fs__dag_open                      can provide, giving the root and full path name.  */
return|return
name|SVN_FS__NOT_FOUND
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|open_path_node_only
condition|)
block|{
comment|/* Shortcut: the caller only wants the final DAG node. */
name|parent_path
operator|->
name|node
operator|=
name|child
expr_stmt|;
block|}
else|else
block|{
comment|/* Now, make a parent_path item for CHILD. */
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|child
argument_list|,
name|entry
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_txn_path
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_copy_inheritance
argument_list|(
operator|&
name|inherit
argument_list|,
operator|&
name|copy_path
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|inherit
expr_stmt|;
name|parent_path
operator|->
name|copy_src_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|copy_path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Cache the node we found (if it wasn't already cached). */
if|if
condition|(
operator|!
name|cached_node
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|path_so_far
operator|->
name|data
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Are we finished traversing the path?  */
if|if
condition|(
operator|!
name|next
condition|)
break|break;
comment|/* The path isn't finished yet; we'd better be in a directory.  */
if|if
condition|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|child
argument_list|)
operator|!=
name|svn_node_dir
condition|)
name|SVN_ERR_W
argument_list|(
name|SVN_FS__ERR_NOT_DIRECTORY
argument_list|(
name|fs
argument_list|,
name|path_so_far
operator|->
name|data
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Failure opening '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|next
expr_stmt|;
name|here
operator|=
name|child
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|parent_path_p
operator|=
name|parent_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make the node referred to by PARENT_PATH mutable, if it isn't    already, allocating from POOL.  ROOT must be the root from which    PARENT_PATH descends.  Clone any parent directories as needed.    Adjust the dag nodes in PARENT_PATH to refer to the clones.  Use    ERROR_PATH in error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_path_mutable
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|error_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|clone
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|root_txn_id
argument_list|(
name|root
argument_list|)
decl_stmt|;
comment|/* Is the node mutable already?  */
if|if
condition|(
name|svn_fs_fs__dag_check_mutable
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Are we trying to clone the root, or somebody's child node?  */
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|parent_id
decl_stmt|,
modifier|*
name|child_id
decl_stmt|,
modifier|*
name|copyroot_id
decl_stmt|;
name|svn_fs_fs__id_part_t
name|copy_id
init|=
block|{
name|SVN_INVALID_REVNUM
block|,
literal|0
block|}
decl_stmt|;
name|svn_fs_fs__id_part_t
modifier|*
name|copy_id_ptr
init|=
operator|&
name|copy_id
decl_stmt|;
name|copy_id_inherit_t
name|inherit
init|=
name|parent_path
operator|->
name|copy_inherit
decl_stmt|;
specifier|const
name|char
modifier|*
name|clone_path
decl_stmt|,
modifier|*
name|copyroot_path
decl_stmt|;
name|svn_revnum_t
name|copyroot_rev
decl_stmt|;
name|svn_boolean_t
name|is_parent_copyroot
init|=
name|FALSE
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyroot_root
decl_stmt|;
name|dag_node_t
modifier|*
name|copyroot_node
decl_stmt|;
comment|/* We're trying to clone somebody's child.  Make sure our parent          is mutable.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|error_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inherit
condition|)
block|{
case|case
name|copy_id_inherit_parent
case|:
name|parent_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|)
expr_stmt|;
name|copy_id
operator|=
operator|*
name|svn_fs_fs__id_copy_id
argument_list|(
name|parent_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_new
case|:
name|SVN_ERR
argument_list|(
name|svn_fs_fs__reserve_copy_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_self
case|:
name|copy_id_ptr
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_unknown
case|:
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* uh-oh -- somebody didn't calculate copy-ID                       inheritance data. */
block|}
comment|/* Determine what copyroot our new child node should use. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyroot
argument_list|(
operator|&
name|copyroot_rev
argument_list|,
operator|&
name|copyroot_path
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copyroot_root
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|copyroot_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|copyroot_node
argument_list|,
name|copyroot_root
argument_list|,
name|copyroot_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|child_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
expr_stmt|;
name|copyroot_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|copyroot_node
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|child_id
argument_list|)
argument_list|,
name|svn_fs_fs__id_node_id
argument_list|(
name|copyroot_id
argument_list|)
argument_list|)
condition|)
name|is_parent_copyroot
operator|=
name|TRUE
expr_stmt|;
comment|/* Now make this node mutable.  */
name|clone_path
operator|=
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_clone_child
argument_list|(
operator|&
name|clone
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|clone_path
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|copy_id_ptr
argument_list|,
name|txn_id
argument_list|,
name|is_parent_copyroot
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|clone
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're trying to clone the root directory.  */
name|SVN_ERR
argument_list|(
name|mutable_root_node
argument_list|(
operator|&
name|clone
argument_list|,
name|root
argument_list|,
name|error_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update the PARENT_PATH link to refer to the clone.  */
name|parent_path
operator|->
name|node
operator|=
name|clone
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the node identified by PATH in ROOT.  Set DAG_NODE_P to the    node we find, allocated in POOL.  Return the error    SVN_ERR_FS_NOT_FOUND if this node doesn't exist. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dag
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|dag_node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
comment|/* First we look for the DAG in our cache      (if the path may be canonical). */
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
comment|/* Canonicalize the input PATH.  As it turns out,>95% of all paths        * seen here during e.g. svnadmin verify are non-canonical, i.e.        * miss the leading '/'.  Unconditional canonicalization has a net        * performance benefit over previously checking path for being        * canonical. */
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dag_node_cache_get
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
comment|/* Call open_path with no flags, as we want this to return an            * error if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_uncached
operator||
name|open_path_node_only
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
comment|/* No need to cache our find -- open_path() will do that for us. */
block|}
block|}
operator|*
name|dag_node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Populating the `changes' table. */
end_comment

begin_comment
comment|/* Add a change to the changes table in FS, keyed on transaction id    TXN_ID, and indicated that a change of kind CHANGE_KIND occurred on    PATH (whose node revision id is--or was, in the case of a    deletion--NODEREV_ID), and optionally that TEXT_MODs, PROP_MODs or    MERGEINFO_MODs occurred.  If the change resulted from a copy,    COPYFROM_REV and COPYFROM_PATH specify under which revision and path    the node was copied from.  If this was not part of a copy, COPYFROM_REV    should be SVN_INVALID_REVNUM.  Do all this as part of POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|noderev_id
parameter_list|,
name|svn_fs_path_change_kind_t
name|change_kind
parameter_list|,
name|svn_boolean_t
name|text_mod
parameter_list|,
name|svn_boolean_t
name|prop_mod
parameter_list|,
name|svn_boolean_t
name|mergeinfo_mod
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_fs_fs__add_change
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|noderev_id
argument_list|,
name|change_kind
argument_list|,
name|text_mod
argument_list|,
name|prop_mod
argument_list|,
name|mergeinfo_mod
argument_list|,
name|node_kind
argument_list|,
name|copyfrom_rev
argument_list|,
name|copyfrom_path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic node operations.  */
end_comment

begin_comment
comment|/* Get the id of a node referenced by path PATH in ROOT.  Return the    id in *ID_P allocated in POOL. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__node_id
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|root
operator|->
name|is_txn_root
operator|)
operator|&&
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Optimize the case where we don't need any db access at all.          The root directory ("" or "/") node is stored in the          svn_fs_root_t object, and never changes when it's a revision          root, so we can just reach in and grab it directly. */
name|dag_node_t
modifier|*
name|root_dir
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|id_p
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|root_dir
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|svn_fs_fs__id_copy
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_relation
parameter_list|(
name|svn_fs_node_relation_t
modifier|*
name|relation
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root_a
parameter_list|,
specifier|const
name|char
modifier|*
name|path_a
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root_b
parameter_list|,
specifier|const
name|char
modifier|*
name|path_b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id_a
decl_stmt|,
modifier|*
name|id_b
decl_stmt|;
name|svn_fs_fs__id_part_t
name|node_id_a
decl_stmt|,
name|node_id_b
decl_stmt|;
comment|/* Root paths are a common special case. */
name|svn_boolean_t
name|a_is_root_dir
init|=
operator|(
name|path_a
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|path_a
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|path_a
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
decl_stmt|;
name|svn_boolean_t
name|b_is_root_dir
init|=
operator|(
name|path_b
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
name|path_b
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|path_b
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
decl_stmt|;
comment|/* Another useful thing to know: Both are txns but not the same txn. */
name|svn_boolean_t
name|different_txn
init|=
name|root_a
operator|->
name|is_txn_root
operator|&&
name|root_b
operator|->
name|is_txn_root
operator|&&
name|strcmp
argument_list|(
name|root_a
operator|->
name|txn
argument_list|,
name|root_b
operator|->
name|txn
argument_list|)
decl_stmt|;
comment|/* Path from different repository are always unrelated. */
if|if
condition|(
name|root_a
operator|->
name|fs
operator|!=
name|root_b
operator|->
name|fs
condition|)
block|{
operator|*
name|relation
operator|=
name|svn_fs_node_unrelated
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Are both (!) root paths? Then, they are related and we only test how    * direct the relation is. */
if|if
condition|(
name|a_is_root_dir
operator|&&
name|b_is_root_dir
condition|)
block|{
comment|/* For txn roots, root->REV is the base revision of that TXN. */
operator|*
name|relation
operator|=
operator|(
operator|(
name|root_a
operator|->
name|rev
operator|==
name|root_b
operator|->
name|rev
operator|)
operator|&&
operator|(
name|root_a
operator|->
name|is_txn_root
operator|==
name|root_b
operator|->
name|is_txn_root
operator|)
operator|&&
operator|!
name|different_txn
operator|)
condition|?
name|svn_fs_node_unchanged
else|:
name|svn_fs_node_common_ancestor
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We checked for all separations between ID spaces (repos, txn).    * Now, we can simply test for the ID values themselves. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root_a
argument_list|,
name|path_a
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|id_a
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node_id_a
operator|=
operator|*
name|svn_fs_fs__id_node_id
argument_list|(
name|id_a
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root_b
argument_list|,
name|path_b
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|id_b
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|node_id_b
operator|=
operator|*
name|svn_fs_fs__id_node_id
argument_list|(
name|id_b
argument_list|)
expr_stmt|;
comment|/* Noderevs from different nodes are unrelated. */
if|if
condition|(
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
operator|&
name|node_id_a
argument_list|,
operator|&
name|node_id_b
argument_list|)
condition|)
block|{
operator|*
name|relation
operator|=
name|svn_fs_node_unrelated
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Noderevs have the same node-ID now. So, they *seem* to be related.    *    * Special case: Different txns may create the same (txn-local) node ID.    * Only when they are committed can they actually be related to others. */
if|if
condition|(
name|different_txn
operator|&&
name|node_id_a
operator|.
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
operator|*
name|relation
operator|=
name|svn_fs_node_unrelated
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The noderevs are actually related.  Are they the same? */
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|id_a
argument_list|,
name|id_b
argument_list|)
condition|)
operator|*
name|relation
operator|=
name|svn_fs_node_unchanged
expr_stmt|;
else|else
operator|*
name|relation
operator|=
name|svn_fs_node_common_ancestor
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__node_created_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_get_revision
argument_list|(
name|revision
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *CREATED_PATH to the path at which PATH under ROOT was created.    Return a string allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_created_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|created_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|created_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *KIND_P to the type of node located at PATH under ROOT.    Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|node_kind
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Get the node id. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|node_id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the node id to get the real kind. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|kind_p
operator|=
name|svn_fs_fs__dag_node_kind
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *KIND_P to the type of node present at PATH under ROOT.  If    PATH does not exist under ROOT, set *KIND_P to svn_node_none.  Use    POOL for temporary allocation. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__check_path
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|node_kind
argument_list|(
name|kind_p
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
operator|*
name|kind_p
operator|=
name|svn_node_none
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *VALUE_P to the value of the property named PROPNAME of PATH in    ROOT.  If the node has no property by that name, set *VALUE_P to    zero.  Allocate the result in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|proplist
condition|)
operator|*
name|value_p
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|propname
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *TABLE_P to the entire property list of PATH under ROOT, as an    APR hash table allocated in POOL.  The resulting property table    maps property names to pointers to svn_string_t objects containing    the property value. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|table_p
operator|=
name|table
condition|?
name|table
else|:
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_has_props
parameter_list|(
name|svn_boolean_t
modifier|*
name|has_props
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_fs_fs__dag_has_props
argument_list|(
name|has_props
argument_list|,
name|node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|increment_mergeinfo_up_tree
parameter_list|(
name|parent_path_t
modifier|*
name|pp
parameter_list|,
name|apr_int64_t
name|increment
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
for|for
control|(
init|;
name|pp
condition|;
name|pp
operator|=
name|pp
operator|->
name|parent
control|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_increment_mergeinfo_count
argument_list|(
name|pp
operator|->
name|node
argument_list|,
name|increment
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Change, add, or delete a node's property value.  The affected node    is PATH under ROOT, the property value to modify is NAME, and VALUE    points to either a string value to set the new contents to, or NULL    if the property should be deleted.  Perform temporary allocations    in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_change_node_prop
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
decl_stmt|;
name|svn_boolean_t
name|mergeinfo_mod
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|root
argument_list|)
return|;
name|txn_id
operator|=
name|root_txn_id
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (non-recursively) to see if path is locked; if so, check      that we can use it. */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|parent_path
operator|->
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's no proplist, but we're just deleting a property, exit now. */
if|if
condition|(
operator|(
operator|!
name|proplist
operator|)
operator|&&
operator|(
operator|!
name|value
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Now, if there's no proplist, we know we need to make one. */
if|if
condition|(
operator|!
name|proplist
condition|)
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|root
operator|->
name|fs
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_int64_t
name|increment
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|had_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|had_mergeinfo
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
operator|!
name|had_mergeinfo
condition|)
name|increment
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|value
operator|&&
name|had_mergeinfo
condition|)
name|increment
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|increment
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|increment_mergeinfo_up_tree
argument_list|(
name|parent_path
argument_list|,
name|increment
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_has_mergeinfo
argument_list|(
name|parent_path
operator|->
name|node
argument_list|,
operator|(
name|value
operator|!=
name|NULL
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mergeinfo_mod
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Set the property. */
name|svn_hash_sets
argument_list|(
name|proplist
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
comment|/* Overwrite the node's proplist. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_proplist
argument_list|(
name|parent_path
operator|->
name|node
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|mergeinfo_mod
argument_list|,
name|svn_fs_fs__dag_node_kind
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Determine if the properties of two path/root combinations are    different.  Set *CHANGED_P to TRUE if the properties at PATH1 under    ROOT1 differ from those at PATH2 under ROOT2, or FALSE otherwise.    Both roots must be in the same filesystem. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_props_changed
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
comment|/* Check that roots are in the same fs. */
if|if
condition|(
name|root1
operator|->
name|fs
operator|!=
name|root2
operator|->
name|fs
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot compare property value between two different filesystems"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node1
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node2
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_things_different
argument_list|(
name|changed_p
argument_list|,
name|NULL
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|,
name|strict
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Merges and commits. */
end_comment

begin_comment
comment|/* Set *NODE to the root node of ROOT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|get_dag
argument_list|(
name|node
argument_list|,
name|root
argument_list|,
literal|"/"
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the contents of CONFLICT_PATH to PATH, and return an    SVN_ERR_FS_CONFLICT error that indicates that there was a conflict    at PATH.  Perform all allocations in POOL (except the allocation of    CONFLICT_PATH, which should be handled outside this function).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict_err
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|conflict_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|svn_stringbuf_set
argument_list|(
name|conflict_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict at '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the directory representations at nodes LHS and RHS and set  * *CHANGED to TRUE, if at least one entry has been added or removed them.  * Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|compare_dir_structure
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed
parameter_list|,
name|dag_node_t
modifier|*
name|lhs
parameter_list|,
name|dag_node_t
modifier|*
name|rhs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|lhs_entries
decl_stmt|;
name|apr_array_header_t
modifier|*
name|rhs_entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|lhs_entries
argument_list|,
name|lhs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|rhs_entries
argument_list|,
name|rhs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* different number of entries -> some addition / removal */
if|if
condition|(
name|lhs_entries
operator|->
name|nelts
operator|!=
name|rhs_entries
operator|->
name|nelts
condition|)
block|{
operator|*
name|changed
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Since directories are sorted by name, we can simply compare their      entries one-by-one without binary lookup etc. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lhs_entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|lhs_entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lhs_entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|rhs_entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rhs_entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lhs_entry
operator|->
name|name
argument_list|,
name|rhs_entry
operator|->
name|name
argument_list|)
operator|||
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|lhs_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_node_id
argument_list|(
name|rhs_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|||
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
name|svn_fs_fs__id_copy_id
argument_list|(
name|lhs_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_copy_id
argument_list|(
name|rhs_entry
operator|->
name|id
argument_list|)
argument_list|)
condition|)
block|{
operator|*
name|changed
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
operator|*
name|changed
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Merge changes between ANCESTOR and SOURCE into TARGET.  ANCESTOR  * and TARGET must be distinct node revisions.  TARGET_PATH should  * correspond to TARGET's full path in its filesystem, and is used for  * reporting conflict location.  *  * SOURCE, TARGET, and ANCESTOR are generally directories; this  * function recursively merges the directories' contents.  If any are  * files, this function simply returns an error whenever SOURCE,  * TARGET, and ANCESTOR are all distinct node revisions.  *  * If there are differences between ANCESTOR and SOURCE that conflict  * with changes between ANCESTOR and TARGET, this function returns an  * SVN_ERR_FS_CONFLICT error, and updates CONFLICT_P to the name of the  * conflicting node in TARGET, with TARGET_PATH prepended as a path.  *  * If there are no conflicting differences, CONFLICT_P is updated to  * the empty string.  *  * CONFLICT_P must point to a valid svn_stringbuf_t.  *  * Do any necessary temporary allocation in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|conflict_p
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|dag_node_t
modifier|*
name|ancestor
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
parameter_list|,
name|apr_int64_t
modifier|*
name|mergeinfo_increment_out
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|source_id
decl_stmt|,
modifier|*
name|target_id
decl_stmt|,
modifier|*
name|ancestor_id
decl_stmt|;
name|apr_array_header_t
modifier|*
name|s_entries
decl_stmt|,
modifier|*
name|t_entries
decl_stmt|,
modifier|*
name|a_entries
decl_stmt|;
name|int
name|i
decl_stmt|,
name|s_idx
init|=
operator|-
literal|1
decl_stmt|,
name|t_idx
init|=
operator|-
literal|1
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_int64_t
name|mergeinfo_increment
init|=
literal|0
decl_stmt|;
name|svn_boolean_t
name|fs_supports_mergeinfo
decl_stmt|;
comment|/* Make sure everyone comes from the same filesystem. */
name|fs
operator|=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|!=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|source
argument_list|)
operator|)
operator|||
operator|(
name|fs
operator|!=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|target
argument_list|)
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; ancestor, source, and target not all in same fs"
argument_list|)
argument_list|)
return|;
block|}
comment|/* We have the same fs, now check it. */
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|source_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|ancestor_id
operator|=
name|svn_fs_fs__dag_get_id
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
comment|/* It's improper to call this function with ancestor == target. */
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|ancestor_id
argument_list|,
name|target_id
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|target_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; target '%s' has id '%s', same as ancestor"
argument_list|)
argument_list|,
name|target_path
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
name|svn_stringbuf_setempty
argument_list|(
name|conflict_p
argument_list|)
expr_stmt|;
comment|/* Base cases:    * Either no change made in source, or same change as made in target.    * Both mean nothing to merge here.    */
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|ancestor_id
argument_list|,
name|source_id
argument_list|)
operator|||
operator|(
name|svn_fs_fs__id_eq
argument_list|(
name|source_id
argument_list|,
name|target_id
argument_list|)
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Else proceed, knowing all three are distinct node revisions.    *    * How to merge from this point:    *    * if (not all 3 are directories)    *   {    *     early exit with conflict;    *   }    *    * // Property changes may only be made to up-to-date    * // directories, because once the client commits the prop    * // change, it bumps the directory's revision, and therefore    * // must be able to depend on there being no other changes to    * // that directory in the repository.    * if (target's property list differs from ancestor's)    *    conflict;    *    * For each entry NAME in the directory ANCESTOR:    *    *   Let ANCESTOR-ENTRY, SOURCE-ENTRY, and TARGET-ENTRY be the IDs of    *   the name within ANCESTOR, SOURCE, and TARGET respectively.    *   (Possibly null if NAME does not exist in SOURCE or TARGET.)    *    *   If ANCESTOR-ENTRY == SOURCE-ENTRY, then:    *     No changes were made to this entry while the transaction was in    *     progress, so do nothing to the target.    *    *   Else if ANCESTOR-ENTRY == TARGET-ENTRY, then:    *     A change was made to this entry while the transaction was in    *     process, but the transaction did not touch this entry.  Replace    *     TARGET-ENTRY with SOURCE-ENTRY.    *    *   Else:    *     Changes were made to this entry both within the transaction and    *     to the repository while the transaction was in progress.  They    *     must be merged or declared to be in conflict.    *    *     If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a    *     double delete; flag a conflict.    *    *     If any of the three entries is of type file, declare a conflict.    *    *     If either SOURCE-ENTRY or TARGET-ENTRY is not a direct    *     modification of ANCESTOR-ENTRY (determine by comparing the    *     node-id fields), declare a conflict.  A replacement is    *     incompatible with a modification or other replacement--even    *     an identical replacement.    *    *     Direct modifications were made to the directory ANCESTOR-ENTRY    *     in both SOURCE and TARGET.  Recursively merge these    *     modifications.    *    * For each leftover entry NAME in the directory SOURCE:    *    *   If NAME exists in TARGET, declare a conflict.  Even if SOURCE and    *   TARGET are adding exactly the same thing, two additions are not    *   auto-mergeable with each other.    *    *   Add NAME to TARGET with the entry from SOURCE.    *    * Now that we are done merging the changes from SOURCE into the    * directory TARGET, update TARGET's predecessor to be SOURCE.    */
if|if
condition|(
operator|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|source
argument_list|)
operator|!=
name|svn_node_dir
operator|)
operator|||
operator|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|target
argument_list|)
operator|!=
name|svn_node_dir
operator|)
operator|||
operator|(
name|svn_fs_fs__dag_node_kind
argument_list|(
name|ancestor
argument_list|)
operator|!=
name|svn_node_dir
operator|)
condition|)
block|{
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
block|}
comment|/* Possible early merge failure: if target and ancestor have      different property lists, then the merge should fail.      Propchanges can *only* be committed on an up-to-date directory.      ### TODO: see issue #418 about the inelegance of this.       Another possible, similar, early merge failure: if source and      ancestor have different property lists (meaning someone else      changed directory properties while our commit transaction was      happening), the merge should fail.  See issue #2751.   */
block|{
name|node_revision_t
modifier|*
name|tgt_nr
decl_stmt|,
modifier|*
name|anc_nr
decl_stmt|,
modifier|*
name|src_nr
decl_stmt|;
name|svn_boolean_t
name|same
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
comment|/* Get node revisions for our id's. */
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|tgt_nr
argument_list|,
name|fs
argument_list|,
name|target_id
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|anc_nr
argument_list|,
name|fs
argument_list|,
name|ancestor_id
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|src_nr
argument_list|,
name|fs
argument_list|,
name|source_id
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Now compare the prop-keys of the skels.  Note that just because        the keys are different -doesn't- mean the proplists have        different contents. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__prop_rep_equal
argument_list|(
operator|&
name|same
argument_list|,
name|fs
argument_list|,
name|src_nr
argument_list|,
name|anc_nr
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
comment|/* The directory entries got changed in the repository but the directory        properties did not. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__prop_rep_equal
argument_list|(
operator|&
name|same
argument_list|,
name|fs
argument_list|,
name|tgt_nr
argument_list|,
name|anc_nr
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same
condition|)
block|{
comment|/* There is an incoming prop change for this directory.            We will accept it only if the directory changes were mere updates            to its entries, i.e. there were no additions or removals.            Those could cause update problems to the working copy. */
name|svn_boolean_t
name|changed
decl_stmt|;
name|SVN_ERR
argument_list|(
name|compare_dir_structure
argument_list|(
operator|&
name|changed
argument_list|,
name|source
argument_list|,
name|ancestor
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|changed
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
block|}
block|}
comment|/* ### todo: it would be more efficient to simply check for a NULL      entries hash where necessary below than to allocate an empty hash      here, but another day, another day... */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|s_entries
argument_list|,
name|source
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|t_entries
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|a_entries
argument_list|,
name|ancestor
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs_supports_mergeinfo
operator|=
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|fs
argument_list|)
expr_stmt|;
comment|/* for each entry E in a_entries... */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|a_entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|,
modifier|*
name|a_entry
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|a_entry
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|a_entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|svn_fs_fs__find_dir_entry
argument_list|(
name|s_entries
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
operator|&
name|s_idx
argument_list|)
expr_stmt|;
name|t_entry
operator|=
name|svn_fs_fs__find_dir_entry
argument_list|(
name|t_entries
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
operator|&
name|t_idx
argument_list|)
expr_stmt|;
comment|/* No changes were made to this entry while the transaction was          in progress, so do nothing to the target. */
if|if
condition|(
name|s_entry
operator|&&
name|svn_fs_fs__id_eq
argument_list|(
name|a_entry
operator|->
name|id
argument_list|,
name|s_entry
operator|->
name|id
argument_list|)
condition|)
continue|continue;
comment|/* A change was made to this entry while the transaction was in          process, but the transaction did not touch this entry. */
elseif|else
if|if
condition|(
name|t_entry
operator|&&
name|svn_fs_fs__id_eq
argument_list|(
name|a_entry
operator|->
name|id
argument_list|,
name|t_entry
operator|->
name|id
argument_list|)
condition|)
block|{
name|dag_node_t
modifier|*
name|t_ent_node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|t_ent_node
argument_list|,
name|fs
argument_list|,
name|t_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
block|{
name|apr_int64_t
name|mergeinfo_start
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_start
argument_list|,
name|t_ent_node
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|-=
name|mergeinfo_start
expr_stmt|;
block|}
if|if
condition|(
name|s_entry
condition|)
block|{
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
block|{
name|apr_int64_t
name|mergeinfo_end
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_end
argument_list|,
name|s_ent_node
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|+=
name|mergeinfo_end
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_entry
argument_list|(
name|target
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|s_entry
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_delete
argument_list|(
name|target
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|txn_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Changes were made to this entry both within the transaction          and to the repository while the transaction was in progress.          They must be merged or declared to be in conflict. */
else|else
block|{
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|,
modifier|*
name|t_ent_node
decl_stmt|,
modifier|*
name|a_ent_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_tpath
decl_stmt|;
name|apr_int64_t
name|sub_mergeinfo_increment
decl_stmt|;
comment|/* If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a              double delete; if one of them is null, that's a delete versus              a modification. In any of these cases, flag a conflict. */
if|if
condition|(
name|s_entry
operator|==
name|NULL
operator|||
name|t_entry
operator|==
name|NULL
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* If any of the three entries is of type file, flag a conflict. */
if|if
condition|(
name|s_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|t_entry
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|a_entry
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* If either SOURCE-ENTRY or TARGET-ENTRY is not a direct              modification of ANCESTOR-ENTRY, declare a conflict. */
if|if
condition|(
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|s_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_node_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|||
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
name|svn_fs_fs__id_copy_id
argument_list|(
name|s_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_copy_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|||
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
name|svn_fs_fs__id_node_id
argument_list|(
name|t_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_node_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|||
operator|!
name|svn_fs_fs__id_part_eq
argument_list|(
name|svn_fs_fs__id_copy_id
argument_list|(
name|t_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_fs__id_copy_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* Direct modifications were made to the directory              ANCESTOR-ENTRY in both SOURCE and TARGET.  Recursively              merge these modifications. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|t_ent_node
argument_list|,
name|fs
argument_list|,
name|t_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|a_ent_node
argument_list|,
name|fs
argument_list|,
name|a_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|new_tpath
operator|=
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|merge
argument_list|(
name|conflict_p
argument_list|,
name|new_tpath
argument_list|,
name|t_ent_node
argument_list|,
name|s_ent_node
argument_list|,
name|a_ent_node
argument_list|,
name|txn_id
argument_list|,
operator|&
name|sub_mergeinfo_increment
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
name|mergeinfo_increment
operator|+=
name|sub_mergeinfo_increment
expr_stmt|;
block|}
block|}
comment|/* For each entry E in source but not in ancestor */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|s_entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|a_entry
decl_stmt|,
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|;
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|s_entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
expr_stmt|;
name|a_entry
operator|=
name|svn_fs_fs__find_dir_entry
argument_list|(
name|a_entries
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
operator|&
name|s_idx
argument_list|)
expr_stmt|;
name|t_entry
operator|=
name|svn_fs_fs__find_dir_entry
argument_list|(
name|t_entries
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
operator|&
name|t_idx
argument_list|)
expr_stmt|;
comment|/* Process only entries in source that are NOT in ancestor. */
if|if
condition|(
name|a_entry
condition|)
continue|continue;
comment|/* If NAME exists in TARGET, declare a conflict. */
if|if
condition|(
name|t_entry
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
block|{
name|apr_int64_t
name|mergeinfo_s
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_s
argument_list|,
name|s_ent_node
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|+=
name|mergeinfo_s
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_set_entry
argument_list|(
name|target
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|s_entry
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_update_ancestry
argument_list|(
name|target
argument_list|,
name|source
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fs_supports_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_increment_mergeinfo_count
argument_list|(
name|target
argument_list|,
name|mergeinfo_increment
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo_increment_out
condition|)
operator|*
name|mergeinfo_increment_out
operator|=
name|mergeinfo_increment
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Merge changes between an ancestor and SOURCE_NODE into    TXN.  The ancestor is either ANCESTOR_NODE, or if    that is null, TXN's base node.     If the merge is successful, TXN's base will become    SOURCE_NODE, and its root node will have a new ID, a    successor of SOURCE_NODE.     If a conflict results, update *CONFLICT to the path in the txn that    conflicted; see the CONFLICT_P parameter of merge() for details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_changes
parameter_list|(
name|dag_node_t
modifier|*
name|ancestor_node
parameter_list|,
name|dag_node_t
modifier|*
name|source_node
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|conflict
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|txn_root_node
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|svn_fs_fs__txn_get_id
argument_list|(
name|txn
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_txn_root
argument_list|(
operator|&
name|txn_root_node
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ancestor_node
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_txn_base_root
argument_list|(
operator|&
name|ancestor_node
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|ancestor_node
argument_list|)
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|txn_root_node
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If no changes have been made in TXN since its current base,          then it can't conflict with any changes since that base.          The caller isn't supposed to call us in that case. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|merge
argument_list|(
name|conflict
argument_list|,
literal|"/"
argument_list|,
name|txn_root_node
argument_list|,
name|source_node
argument_list|,
name|ancestor_node
argument_list|,
name|txn_id
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__commit_txn
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_revnum_t
modifier|*
name|new_rev
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* How do commits work in Subversion?    *    * When you're ready to commit, here's what you have:    *    *    1. A transaction, with a mutable tree hanging off it.    *    2. A base revision, against which TXN_TREE was made.    *    3. A latest revision, which may be newer than the base rev.    *    * The problem is that if latest != base, then one can't simply    * attach the txn root as the root of the new revision, because that    * would lose all the changes between base and latest.  It is also    * not acceptable to insist that base == latest; in a busy    * repository, commits happen too fast to insist that everyone keep    * their entire tree up-to-date at all times.  Non-overlapping    * changes should not interfere with each other.    *    * The solution is to merge the changes between base and latest into    * the txn tree [see the function merge()].  The txn tree is the    * only one of the three trees that is mutable, so it has to be the    * one to adjust.    *    * You might have to adjust it more than once, if a new latest    * revision gets committed while you were merging in the previous    * one.  For example:    *    *    1. Jane starts txn T, based at revision 6.    *    2. Someone commits (or already committed) revision 7.    *    3. Jane's starts merging the changes between 6 and 7 into T.    *    4. Meanwhile, someone commits revision 8.    *    5. Jane finishes the 6-->7 merge.  T could now be committed    *       against a latest revision of 7, if only that were still the    *       latest.  Unfortunately, 8 is now the latest, so...    *    6. Jane starts merging the changes between 7 and 8 into T.    *    7. Meanwhile, no one commits any new revisions.  Whew.    *    8. Jane commits T, creating revision 9, whose tree is exactly    *       T's tree, except immutable now.    *    * Lather, rinse, repeat.    */
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|conflict
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Limit memory usage when the repository has a high commit rate and      needs to run the following while loop multiple times.  The memory      growth without an iteration pool is very noticeable when the      transaction modifies a node that has 20,000 sibling nodes. */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Initialize output params. */
operator|*
name|new_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1729
condition|)
block|{
name|svn_revnum_t
name|youngish_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|youngish_root
decl_stmt|;
name|dag_node_t
modifier|*
name|youngish_root_node
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the *current* youngest revision.  We call it "youngish"          because new revisions might get committed after we've          obtained it. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|youngish_rev
argument_list|,
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|youngish_root
argument_list|,
name|fs
argument_list|,
name|youngish_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the dag node for the youngest revision.  Later we'll use          it as the SOURCE argument to a merge, and if the merge          succeeds, this youngest root node will become the new base          root for the svn txn that was the target of the merge (but          note that the youngest rev may have changed by then -- that's          why we're careful to get this root in its own bdb txn          here). */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|youngish_root_node
argument_list|,
name|youngish_root
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to merge.  If the merge succeeds, the base root node of          TARGET's txn will become the same as youngish_root_node, so          any future merges will only be between that node and whatever          the root node of the youngest rev is by then. */
name|err
operator|=
name|merge_changes
argument_list|(
name|NULL
argument_list|,
name|youngish_root_node
argument_list|,
name|txn
argument_list|,
name|conflict
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CONFLICT
operator|)
operator|&&
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|conflict
operator|->
name|data
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|txn
operator|->
name|base_rev
operator|=
name|youngish_rev
expr_stmt|;
comment|/* Try to commit. */
name|err
operator|=
name|svn_fs_fs__commit
argument_list|(
name|new_rev
argument_list|,
name|fs
argument_list|,
name|txn
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_TXN_OUT_OF_DATE
operator|)
condition|)
block|{
comment|/* Did someone else finish committing a new revision while we              were in mid-merge or mid-commit?  If so, we'll need to              loop again to merge the new changes in, then try to              commit again.  Or if that's not what happened, then just              return the error. */
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_rev
operator|==
name|youngish_rev
condition|)
goto|goto
name|cleanup
goto|;
else|else
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
goto|goto
name|cleanup
goto|;
block|}
else|else
block|{
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
name|cleanup
label|:
name|svn_fs_fs__reset_txn_caches
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|pack_after_commit
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__pack
argument_list|(
name|fs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Merge changes between two nodes into a third node.  Given nodes    SOURCE_PATH under SOURCE_ROOT, TARGET_PATH under TARGET_ROOT and    ANCESTOR_PATH under ANCESTOR_ROOT, modify target to contain all the    changes between the ancestor and source.  If there are conflicts,    return SVN_ERR_FS_CONFLICT and set *CONFLICT_P to a textual    description of the offending changes.  Perform any temporary    allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_merge
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|ancestor_root
parameter_list|,
specifier|const
name|char
modifier|*
name|ancestor_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|source
decl_stmt|,
modifier|*
name|ancestor
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|conflict
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|target_root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|target_root
argument_list|)
return|;
comment|/* Paranoia. */
if|if
condition|(
operator|(
name|source_root
operator|->
name|fs
operator|!=
name|ancestor_root
operator|->
name|fs
operator|)
operator|||
operator|(
name|target_root
operator|->
name|fs
operator|!=
name|ancestor_root
operator|->
name|fs
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; ancestor, source, and target not all in same fs"
argument_list|)
argument_list|)
return|;
block|}
comment|/* ### kff todo: is there any compelling reason to get the nodes in      one db transaction?  Right now we don't; txn_body_get_root() gets      one node at a time.  This will probably need to change:       Jim Blandy<jimb@zwingli.cygnus.com> writes:> svn_fs_merge needs to be a single transaction, to protect it against> people deleting parents of nodes it's working on, etc.   */
comment|/* Get the ancestor node. */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|ancestor
argument_list|,
name|ancestor_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the source node. */
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|source
argument_list|,
name|source_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open a txn for the txn root into which we're merging. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|ancestor_root
operator|->
name|fs
argument_list|,
name|target_root
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge changes between ANCESTOR and SOURCE into TXN. */
name|err
operator|=
name|merge_changes
argument_list|(
name|ancestor
argument_list|,
name|source
argument_list|,
name|txn
argument_list|,
name|conflict
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CONFLICT
operator|)
operator|&&
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|conflict
operator|->
name|data
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deltify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Deltify is a no-op for fs_fs. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Directories.  */
end_comment

begin_comment
comment|/* Set *TABLE_P to a newly allocated APR hash table containing the    entries of the directory at PATH in ROOT.  The keys of the table    are entry names, as byte strings, excluding the final null    character; the table's values are pointers to svn_fs_dirent_t    structures.  Allocate the table and its contents in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|apr_hash_t
modifier|*
name|hash
init|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|table
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Get the entries for this path in the caller's pool. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|table
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert directory array to hash. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|table
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|hash
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
operator|*
name|table_p
operator|=
name|hash
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_dir_optimal_order
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|ordered_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|ordered_p
operator|=
name|svn_fs_fs__order_dir_entries
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|entries
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Raise an error if PATH contains a newline because FSFS cannot handle  * such paths. See issue #4340. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_newline
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|c
init|=
name|strchr
argument_list|(
name|path
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PATH_SYNTAX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid control character '0x%02x' in path '%s'"
argument_list|)
argument_list|,
operator|(
name|unsigned
name|char
operator|)
operator|*
name|c
argument_list|,
name|svn_path_illegal_path_escape
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a new directory named PATH in ROOT.  The new directory has    no entries, and no properties.  ROOT must be the root of a    transaction, not a revision.  Do any necessary temporary allocation    in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_make_dir
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|sub_dir
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|root_txn_id
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_newline
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_last_optional
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (recursively) to see if some lock is 'reserving' a path at      that location, or even some child-path; if so, check that we can      use it. */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's already a sub-directory by that name, complain.  This      also catches the case of trying to make a subdirectory named `/'.  */
if|if
condition|(
name|parent_path
operator|->
name|node
condition|)
return|return
name|SVN_FS__ALREADY_EXISTS
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Create the subdirectory.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_make_dir
argument_list|(
operator|&
name|sub_dir
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this directory to the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|sub_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|sub_dir
argument_list|)
argument_list|,
name|svn_fs_path_change_add
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_dir
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete the node at PATH under ROOT.  ROOT must be a transaction    root.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_delete_node
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
decl_stmt|;
name|apr_int64_t
name|mergeinfo_count
init|=
literal|0
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|root
argument_list|)
return|;
name|txn_id
operator|=
name|root_txn_id
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|svn_fs_fs__dag_node_kind
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* We can't remove the root of the filesystem.  */
if|if
condition|(
operator|!
name|parent_path
operator|->
name|parent
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_ROOT_DIR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The root directory cannot be deleted"
argument_list|)
argument_list|)
return|;
comment|/* Check to see if path (or any child thereof) is locked; if so,      check that we can use the existing lock(s). */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the parent directory mutable, and do the deletion.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|root
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_count
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_delete
argument_list|(
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove this node and any children from the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_invalidate
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update mergeinfo counts for parents */
if|if
condition|(
name|mergeinfo_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|increment_mergeinfo_up_tree
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
operator|-
name|mergeinfo_count
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_delete
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|kind
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *SAME_P to TRUE if FS1 and FS2 have the same UUID, else set to FALSE.    Use POOL for temporary allocation only.    Note: this code is duplicated between libsvn_fs_fs and libsvn_fs_base. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_same_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|same_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs1
parameter_list|,
name|svn_fs_t
modifier|*
name|fs2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|same_p
operator|=
operator|!
name|strcmp
argument_list|(
name|fs1
operator|->
name|uuid
argument_list|,
name|fs2
operator|->
name|uuid
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the node at FROM_PATH under FROM_ROOT to TO_PATH under    TO_ROOT.  If PRESERVE_HISTORY is set, then the copy is recorded in    the copies table.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_helper
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|svn_boolean_t
name|preserve_history
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|from_node
decl_stmt|;
name|parent_path_t
modifier|*
name|to_parent_path
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|root_txn_id
argument_list|(
name|to_root
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|same_p
decl_stmt|;
comment|/* Use an error check, not an assert, because even the caller cannot      guarantee that a filesystem's UUID has not changed "on the fly". */
name|SVN_ERR
argument_list|(
name|fs_same_p
argument_list|(
operator|&
name|same_p
argument_list|,
name|from_root
operator|->
name|fs
argument_list|,
name|to_root
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_p
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy between two different filesystems ('%s' and '%s')"
argument_list|)
argument_list|,
name|from_root
operator|->
name|fs
operator|->
name|path
argument_list|,
name|to_root
operator|->
name|fs
operator|->
name|path
argument_list|)
return|;
comment|/* more things that we can't do ATM */
if|if
condition|(
name|from_root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copy from mutable tree not currently supported"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|to_root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copy immutable tree not supported"
argument_list|)
argument_list|)
return|;
comment|/* Get the NODE for FROM_PATH in FROM_ROOT.*/
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|from_node
argument_list|,
name|from_root
argument_list|,
name|from_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up the parent path from TO_PATH in TO_ROOT.  If the last      component does not exist, it's not that big a deal.  We'll just      make one there. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|to_parent_path
argument_list|,
name|to_root
argument_list|,
name|to_path
argument_list|,
name|open_path_last_optional
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if path (or any child thereof) is locked; if so,      check that we can use the existing lock(s). */
if|if
condition|(
name|to_root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|to_path
argument_list|,
name|to_root
operator|->
name|fs
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the destination node already exists as the same node as the      source (in other words, this operation would result in nothing      happening at all), just do nothing an return successfully,      proud that you saved yourself from a tiresome task. */
if|if
condition|(
name|to_parent_path
operator|->
name|node
operator|&&
name|svn_fs_fs__id_eq
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|from_node
argument_list|)
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|to_parent_path
operator|->
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|from_root
operator|->
name|is_txn_root
condition|)
block|{
name|svn_fs_path_change_kind_t
name|kind
decl_stmt|;
name|dag_node_t
modifier|*
name|new_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_canonpath
decl_stmt|;
name|apr_int64_t
name|mergeinfo_start
decl_stmt|;
name|apr_int64_t
name|mergeinfo_end
decl_stmt|;
comment|/* If TO_PATH already existed prior to the copy, note that this          operation is a replacement, not an addition. */
if|if
condition|(
name|to_parent_path
operator|->
name|node
condition|)
block|{
name|kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|to_root
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_start
argument_list|,
name|to_parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|kind
operator|=
name|svn_fs_path_change_add
expr_stmt|;
name|mergeinfo_start
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|to_root
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_end
argument_list|,
name|from_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the target node's parents are mutable.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|to_root
argument_list|,
name|to_parent_path
operator|->
name|parent
argument_list|,
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Canonicalize the copyfrom path. */
name|from_canonpath
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|from_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_copy
argument_list|(
name|to_parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|to_parent_path
operator|->
name|entry
argument_list|,
name|from_node
argument_list|,
name|preserve_history
argument_list|,
name|from_root
operator|->
name|rev
argument_list|,
name|from_canonpath
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_fs_path_change_add
condition|)
name|SVN_ERR
argument_list|(
name|dag_node_cache_invalidate
argument_list|(
name|to_root
argument_list|,
name|parent_path_path
argument_list|(
name|to_parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|to_root
operator|->
name|fs
argument_list|)
operator|&&
name|mergeinfo_start
operator|!=
name|mergeinfo_end
condition|)
name|SVN_ERR
argument_list|(
name|increment_mergeinfo_up_tree
argument_list|(
name|to_parent_path
operator|->
name|parent
argument_list|,
name|mergeinfo_end
operator|-
name|mergeinfo_start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|new_node
argument_list|,
name|to_root
argument_list|,
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_change
argument_list|(
name|to_root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|to_path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|new_node
argument_list|)
argument_list|,
name|kind
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|svn_fs_fs__dag_node_kind
argument_list|(
name|from_node
argument_list|)
argument_list|,
name|from_root
operator|->
name|rev
argument_list|,
name|from_canonpath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* See IZ Issue #436 */
comment|/* Copying from transaction roots not currently available.           ### cmpilato todo someday: make this not so. :-) Note that          when copying from mutable trees, you have to make sure that          you aren't creating a cyclic graph filesystem, and a simple          referencing operation won't cut it.  Currently, we should not          be able to reach this clause, and the interface reports that          this only works from immutable trees anyway, but JimB has          stated that this requirement need not be necessary in the          future. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a copy of FROM_PATH in FROM_ROOT named TO_PATH in TO_ROOT.    If FROM_PATH is a directory, copy it recursively.  Temporary    allocations are from POOL.*/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_copy
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|check_newline
argument_list|(
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|copy_helper
argument_list|(
name|from_root
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|from_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|to_root
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a copy of FROM_PATH in FROM_ROOT named TO_PATH in TO_ROOT.    If FROM_PATH is a directory, copy it recursively.  No history is    preserved.  Temporary allocations are from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_revision_link
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|to_root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|to_root
argument_list|)
return|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|copy_helper
argument_list|(
name|from_root
argument_list|,
name|path
argument_list|,
name|to_root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Discover the copy ancestry of PATH under ROOT.  Return a relevant    ancestor/revision combination in *PATH_P and *REV_P.  Temporary    allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_copied_from
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* There is no cached entry, look it up the old-fashioned       way. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_rev
argument_list|(
name|rev_p
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_path
argument_list|(
name|path_p
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Files.  */
end_comment

begin_comment
comment|/* Create the empty file PATH under ROOT.  Temporary allocations are    in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_make_file
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|root_txn_id
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_newline
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_last_optional
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's already a file by that name, complain.      This also catches the case of trying to make a file named `/'.  */
if|if
condition|(
name|parent_path
operator|->
name|node
condition|)
return|return
name|SVN_FS__ALREADY_EXISTS
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Check (non-recursively) to see if path is locked;  if so, check      that we can use it. */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the file.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_make_file
argument_list|(
operator|&
name|child
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add this file to the path cache. */
name|SVN_ERR
argument_list|(
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|child
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|child
argument_list|)
argument_list|,
name|svn_fs_path_change_add
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_file
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *LENGTH_P to the size of the file PATH under ROOT.  Temporary    allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|file
decl_stmt|;
comment|/* First create a dag_node_t from the root/path pair. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|file
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now fetch its length */
return|return
name|svn_fs_fs__dag_file_length
argument_list|(
name|length_p
argument_list|,
name|file
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *CHECKSUM to the checksum of type KIND for PATH under ROOT, or    NULL if that information isn't available.  Temporary allocations    are from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|file
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_file_checksum
argument_list|(
name|checksum
argument_list|,
name|file
argument_list|,
name|kind
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --- Machinery for svn_fs_file_contents() ---  */
end_comment

begin_comment
comment|/* Set *CONTENTS to a readable stream that will return the contents of    PATH under ROOT.  The stream is allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_file_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
comment|/* First create a dag_node_t from the root/path pair. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Then create a readable stream from the dag_node_t. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_contents
argument_list|(
operator|&
name|file_stream
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|file_stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_file_contents() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_try_process_file_contents() ---  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_try_process_file_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_process_contents_func_t
name|processor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_try_process_file_contents
argument_list|(
name|success
argument_list|,
name|node
argument_list|,
name|processor
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_try_process_file_contents() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_apply_textdelta() ---  */
end_comment

begin_comment
comment|/* Local baton type for all the helper functions below. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|txdelta_baton_t
block|{
comment|/* This is the custom-built window consumer given to us by the delta      library;  it uniquely knows how to read data from our designated      "source" stream, interpret the window, and write data to our      designated "target" stream (in this case, our repos file.) */
name|svn_txdelta_window_handler_t
name|interpreter
decl_stmt|;
name|void
modifier|*
name|interpreter_baton
decl_stmt|;
comment|/* The original file info */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Derived from the file info */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|target_stream
decl_stmt|;
comment|/* MD5 digest for the base text against which a delta is to be      applied, and for the resultant fulltext, respectively.  Either or      both may be null, in which case ignored. */
name|svn_checksum_t
modifier|*
name|base_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|result_checksum
decl_stmt|;
comment|/* Pool used by db txns */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|txdelta_baton_t
typedef|;
end_typedef

begin_comment
comment|/* The main window handler returned by svn_fs_apply_textdelta. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_consumer
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
comment|/* Send the window right through to the custom window interpreter.      In theory, the interpreter will then write more data to      cb->target_string. */
name|SVN_ERR
argument_list|(
name|tb
operator|->
name|interpreter
argument_list|(
name|window
argument_list|,
name|tb
operator|->
name|interpreter_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is the window NULL?  If so, we're done.  The stream has already been      closed by the interpreter. */
if|if
condition|(
operator|!
name|window
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_finalize_edits
argument_list|(
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|result_checksum
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for fs_apply_textdelta.  BATON is of type    txdelta_baton_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|root_txn_id
argument_list|(
name|tb
operator|->
name|root
argument_list|)
decl_stmt|;
comment|/* Call open_path with no flags, as we want this to return an error      if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|tb
operator|->
name|root
argument_list|,
name|tb
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (non-recursively) to see if path is locked; if so, check      that we can use it. */
if|if
condition|(
name|tb
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|tb
operator|->
name|path
argument_list|,
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, make sure this path is mutable. */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|tb
operator|->
name|root
argument_list|,
name|parent_path
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|base_checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
comment|/* Until we finalize the node, its data_key points to the old          contents, in other words, the base text. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|base_checksum
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|tb
operator|->
name|base_checksum
argument_list|,
name|checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|tb
operator|->
name|base_checksum
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Base checksum mismatch on '%s'"
argument_list|)
argument_list|,
name|tb
operator|->
name|path
argument_list|)
return|;
block|}
comment|/* Make a readable "source" stream out of the current contents of      ROOT/PATH; obviously, this must done in the context of a db_txn.      The stream is returned in tb->source_stream. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_contents
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|source_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a writable "target" stream */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_edit_stream
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|target_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, create a custom window handler that uses our two streams. */
name|svn_txdelta_apply
argument_list|(
name|tb
operator|->
name|source_stream
argument_list|,
name|tb
operator|->
name|target_stream
argument_list|,
name|NULL
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|tb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|tb
operator|->
name|interpreter
operator|)
argument_list|,
operator|&
operator|(
name|tb
operator|->
name|interpreter_baton
operator|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|tb
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_file
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set *CONTENTS_P and *CONTENTS_BATON_P to a window handler and baton    that will accept text delta windows to modify the contents of PATH    under ROOT.  Allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_apply_textdelta
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|contents_p
parameter_list|,
name|void
modifier|*
modifier|*
name|contents_baton_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_checksum_t
modifier|*
name|base_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
name|result_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
decl_stmt|;
name|tb
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|tb
operator|->
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|tb
operator|->
name|base_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|base_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|result_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|result_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|apply_textdelta
argument_list|(
name|tb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|window_consumer
expr_stmt|;
operator|*
name|contents_baton_p
operator|=
name|tb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_apply_textdelta() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_apply_text() ---  */
end_comment

begin_comment
comment|/* Baton for svn_fs_apply_text(). */
end_comment

begin_struct
struct|struct
name|text_baton_t
block|{
comment|/* The original file info */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Derived from the file info */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* The returned stream that will accept the file's new contents. */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* The actual fs stream that the returned stream will write to. */
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
comment|/* MD5 digest for the final fulltext written to the file.  May      be null, in which case ignored. */
name|svn_checksum_t
modifier|*
name|result_checksum
decl_stmt|;
comment|/* Pool used by db txns */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A wrapper around svn_fs_fs__dag_finalize_edits, but for  * fulltext data, not text deltas.  Closes BATON->file_stream.  *  * Note: If you're confused about how this function relates to another  * of similar name, think of it this way:  *  * svn_fs_apply_textdelta() ==> ... ==> txn_body_txdelta_finalize_edits()  * svn_fs_apply_text()      ==> ... ==> txn_body_fulltext_finalize_edits()  */
end_comment

begin_comment
comment|/* Write function for the publically returned stream. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|text_stream_writer
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
comment|/* Psst, here's some data.  Pass it on to the -real- file stream. */
return|return
name|svn_stream_write
argument_list|(
name|tb
operator|->
name|file_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close function for the publically returned stream. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|text_stream_closer
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
comment|/* Close the internal-use stream.  ### This used to be inside of      txn_body_fulltext_finalize_edits(), but that invoked a nested      Berkeley DB transaction -- scandalous! */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|tb
operator|->
name|file_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Need to tell fs that we're done sending text */
return|return
name|svn_fs_fs__dag_finalize_edits
argument_list|(
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|result_checksum
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for fs_apply_text.  BATON is of type    text_baton_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_text
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn_id
init|=
name|root_txn_id
argument_list|(
name|tb
operator|->
name|root
argument_list|)
decl_stmt|;
comment|/* Call open_path with no flags, as we want this to return an error      if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|tb
operator|->
name|root
argument_list|,
name|tb
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check (non-recursively) to see if path is locked; if so, check      that we can use it. */
if|if
condition|(
name|tb
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__allow_locked_operation
argument_list|(
name|tb
operator|->
name|path
argument_list|,
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, make sure this path is mutable. */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|tb
operator|->
name|root
argument_list|,
name|parent_path
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
comment|/* Make a writable stream for replacing the file's text. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_edit_stream
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|file_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a 'returnable' stream which writes to the file_stream. */
name|tb
operator|->
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|tb
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|tb
operator|->
name|stream
argument_list|,
name|text_stream_writer
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|tb
operator|->
name|stream
argument_list|,
name|text_stream_closer
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|tb
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|svn_node_file
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a writable stream that will set the contents of PATH under    ROOT.  RESULT_CHECKSUM is the MD5 checksum of the final result.    Temporary allocations are in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_apply_text
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_checksum_t
modifier|*
name|result_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
decl_stmt|;
name|tb
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|tb
operator|->
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|tb
operator|->
name|result_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|result_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|apply_text
argument_list|(
name|tb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|tb
operator|->
name|stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_apply_text() ---  */
end_comment

begin_comment
comment|/* Check if the contents of PATH1 under ROOT1 are different from the    contents of PATH2 under ROOT2.  If they are different set    *CHANGED_P to TRUE, otherwise set it to FALSE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_contents_changed
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
comment|/* Check that roots are in the same fs. */
if|if
condition|(
name|root1
operator|->
name|fs
operator|!=
name|root2
operator|->
name|fs
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot compare file contents between two different filesystems"
argument_list|)
argument_list|)
return|;
comment|/* Check that both paths are files. */
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|path1
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|path2
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node1
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node2
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__dag_things_different
argument_list|(
name|NULL
argument_list|,
name|changed_p
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|,
name|strict
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Public interface to computing file text deltas.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|source_node
decl_stmt|,
modifier|*
name|target_node
decl_stmt|;
if|if
condition|(
name|source_root
operator|&&
name|source_path
condition|)
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|source_node
argument_list|,
name|source_root
argument_list|,
name|source_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|source_node
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|target_node
argument_list|,
name|target_root
argument_list|,
name|target_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a delta stream that turns the source into the target.  */
return|return
name|svn_fs_fs__dag_get_file_delta_stream
argument_list|(
name|stream_p
argument_list|,
name|source_node
argument_list|,
name|target_node
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finding Changes */
end_comment

begin_comment
comment|/* Set *CHANGED_PATHS_P to a newly allocated hash containing    descriptions of the paths changed under ROOT.  The hash is keyed    with const char * paths and has svn_fs_path_change2_t * values.  Use    POOL for all allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_paths_changed
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changed_paths_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_fs_fs__txn_changes_fetch
argument_list|(
name|changed_paths_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root_txn_id
argument_list|(
name|root
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|svn_fs_fs__paths_changed
argument_list|(
name|changed_paths_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Our coolio opaque history object. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fs_history_data_t
block|{
comment|/* filesystem object */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* path and revision of historical location */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* internal-use hints about where to resume the history search. */
specifier|const
name|char
modifier|*
name|path_hint
decl_stmt|;
name|svn_revnum_t
name|rev_hint
decl_stmt|;
comment|/* FALSE until the first call to svn_fs_history_prev(). */
name|svn_boolean_t
name|is_interesting
decl_stmt|;
block|}
name|fs_history_data_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|svn_fs_history_t
modifier|*
name|assemble_history
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|is_interesting
parameter_list|,
specifier|const
name|char
modifier|*
name|path_hint
parameter_list|,
name|svn_revnum_t
name|rev_hint
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Set *HISTORY_P to an opaque node history object which represents    PATH under ROOT.  ROOT must be a revision root.  Use POOL for all    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_history
parameter_list|(
name|svn_fs_history_t
modifier|*
modifier|*
name|history_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* We require a revision root. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_REVISION_ROOT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* And we require that the path exist in the root. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|SVN_FS__NOT_FOUND
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Okay, all seems well.  Build our history object and return it. */
operator|*
name|history_p
operator|=
name|assemble_history
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the youngest copyroot for path PARENT_PATH or its parents in    filesystem FS, and store the copyroot in *REV_P and *PATH_P.    Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_youngest_copyroot
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|rev_mine
decl_stmt|;
name|svn_revnum_t
name|rev_parent
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_mine
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_parent
init|=
name|NULL
decl_stmt|;
comment|/* First find our parent's youngest copyroot. */
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
name|SVN_ERR
argument_list|(
name|find_youngest_copyroot
argument_list|(
operator|&
name|rev_parent
argument_list|,
operator|&
name|path_parent
argument_list|,
name|fs
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find our copyroot. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyroot
argument_list|(
operator|&
name|rev_mine
argument_list|,
operator|&
name|path_mine
argument_list|,
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a parent and child were copied to in the same revision, prefer      the child copy target, since it is the copy relevant to the      history of the child. */
if|if
condition|(
name|rev_mine
operator|>=
name|rev_parent
condition|)
block|{
operator|*
name|rev_p
operator|=
name|rev_mine
expr_stmt|;
operator|*
name|path_p
operator|=
name|path_mine
expr_stmt|;
block|}
else|else
block|{
operator|*
name|rev_p
operator|=
name|rev_parent
expr_stmt|;
operator|*
name|path_p
operator|=
name|path_parent
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_closest_copy
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|,
modifier|*
name|copy_dst_parent_path
decl_stmt|;
name|svn_revnum_t
name|copy_dst_rev
decl_stmt|,
name|created_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_dst_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copy_dst_root
decl_stmt|;
name|dag_node_t
modifier|*
name|copy_dst_node
decl_stmt|;
comment|/* Initialize return values. */
operator|*
name|root_p
operator|=
name|NULL
expr_stmt|;
operator|*
name|path_p
operator|=
name|NULL
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the youngest copyroot in the path of this node-rev, which      will indicate the target of the innermost copy affecting the      node-rev. */
name|SVN_ERR
argument_list|(
name|find_youngest_copyroot
argument_list|(
operator|&
name|copy_dst_rev
argument_list|,
operator|&
name|copy_dst_path
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_dst_rev
operator|==
literal|0
condition|)
comment|/* There are no copies affecting this node-rev. */
return|return
name|SVN_NO_ERROR
return|;
comment|/* It is possible that this node was created from scratch at some      revision between COPY_DST_REV and REV.  Make sure that PATH      exists as of COPY_DST_REV and is related to this node-rev. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copy_dst_root
argument_list|,
name|fs
argument_list|,
name|copy_dst_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|copy_dst_parent_path
argument_list|,
name|copy_dst_root
argument_list|,
name|path
argument_list|,
name|open_path_node_only
operator||
name|open_path_allow_null
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_dst_parent_path
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|copy_dst_node
operator|=
name|copy_dst_parent_path
operator|->
name|node
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__id_check_related
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|copy_dst_node
argument_list|)
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* One final check must be done here.  If you copy a directory and      create a new entity somewhere beneath that directory in the same      txn, then we can't claim that the copy affected the new entity.      For example, if you do:          copy dir1 dir2         create dir2/new-thing         commit       then dir2/new-thing was not affected by the copy of dir1 to dir2.      We detect this situation by asking if PATH@COPY_DST_REV's      created-rev is COPY_DST_REV, and that node-revision has no      predecessors, then there is no relevant closest copy.   */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|created_rev
argument_list|,
name|copy_dst_node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|created_rev
operator|==
name|copy_dst_rev
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|pred
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred
argument_list|,
name|copy_dst_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pred
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The copy destination checks out.  Return it. */
operator|*
name|root_p
operator|=
name|copy_dst_root
expr_stmt|;
operator|*
name|path_p
operator|=
name|copy_dst_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *PREV_PATH and *PREV_REV to the path and revision which    represent the location at which PATH in FS was located immediately    prior to REVISION iff there was a copy operation (to PATH or one of    its parent directories) between that previous location and    PATH@REVISION.     If there was no such copy operation in that portion of PATH's    history, set *PREV_PATH to NULL and *PREV_REV to SVN_INVALID_REVNUM.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prev_location
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|prev_path
parameter_list|,
name|svn_revnum_t
modifier|*
name|prev_rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|,
modifier|*
name|copy_src_path
decl_stmt|,
modifier|*
name|remainder_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copy_root
decl_stmt|;
name|svn_revnum_t
name|copy_src_rev
decl_stmt|;
comment|/* Ask about the most recent copy which affected PATH@REVISION.  If      there was no such copy, we're done.  */
name|SVN_ERR
argument_list|(
name|fs_closest_copy
argument_list|(
operator|&
name|copy_root
argument_list|,
operator|&
name|copy_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_root
condition|)
block|{
operator|*
name|prev_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|prev_path
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Ultimately, it's not the path of the closest copy's source that      we care about -- it's our own path's location in the copy source      revision.  So we'll tack the relative path that expresses the      difference between the copy destination and our path in the copy      revision onto the copy source path to determine this information.       In other words, if our path is "/branches/my-branch/foo/bar", and      we know that the closest relevant copy was a copy of "/trunk" to      "/branches/my-branch", then that relative path under the copy      destination is "/foo/bar".  Tacking that onto the copy source      path tells us that our path was located at "/trunk/foo/bar"      before the copy.   */
name|SVN_ERR
argument_list|(
name|fs_copied_from
argument_list|(
operator|&
name|copy_src_rev
argument_list|,
operator|&
name|copy_src_path
argument_list|,
name|copy_root
argument_list|,
name|copy_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|remainder_path
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|copy_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|prev_path
operator|=
name|svn_fspath__join
argument_list|(
name|copy_src_path
argument_list|,
name|remainder_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|prev_rev
operator|=
name|copy_src_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_node_origin_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|given_noderev_id
decl_stmt|,
modifier|*
name|cached_origin_id
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|node_id
decl_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Check the cache first. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|given_noderev_id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id
operator|=
name|svn_fs_fs__id_node_id
argument_list|(
name|given_noderev_id
argument_list|)
expr_stmt|;
comment|/* Is it a brand new uncommitted node or a new-style node ID?    * (committed old-style nodes will have a 0 revision value;    * rev 0, number 0 is rev 0 root node). Note that != 0 includes    * SVN_INVALID_REVNUM for uncommitted nodes. */
if|if
condition|(
name|node_id
operator|->
name|revision
operator|!=
literal|0
operator|||
name|node_id
operator|->
name|number
operator|==
literal|0
condition|)
block|{
operator|*
name|revision
operator|=
name|node_id
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* OK, it's an old-style ID?  Maybe it's cached. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_origin
argument_list|(
operator|&
name|cached_origin_id
argument_list|,
name|fs
argument_list|,
name|node_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_origin_id
operator|!=
name|NULL
condition|)
block|{
operator|*
name|revision
operator|=
name|svn_fs_fs__id_rev
argument_list|(
name|cached_origin_id
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|{
comment|/* Ah well, the answer isn't in the ID itself or in the cache.        Let's actually calculate it, then. */
name|svn_fs_root_t
modifier|*
name|curroot
init|=
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|predidpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|lastpath
init|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|lastrev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
comment|/* Walk the closest-copy chain back to the first copy in our history.         NOTE: We merely *assume* that this is faster than walking the        predecessor chain, because we *assume* that copies of parent        directories happen less often than modifications to a given item. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_revnum_t
name|currev
decl_stmt|;
specifier|const
name|char
modifier|*
name|curpath
init|=
name|lastpath
operator|->
name|data
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Get a root pointing to LASTREV.  (The first time around,            LASTREV is invalid, but that's cool because CURROOT is            already initialized.)  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|lastrev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|curroot
argument_list|,
name|fs
argument_list|,
name|lastrev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the previous location using the closest-copy shortcut. */
name|SVN_ERR
argument_list|(
name|prev_location
argument_list|(
operator|&
name|curpath
argument_list|,
operator|&
name|currev
argument_list|,
name|fs
argument_list|,
name|curroot
argument_list|,
name|curpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curpath
condition|)
break|break;
comment|/* Update our LASTPATH and LASTREV variables (which survive            SUBPOOL). */
name|svn_stringbuf_set
argument_list|(
name|lastpath
argument_list|,
name|curpath
argument_list|)
expr_stmt|;
name|lastrev
operator|=
name|currev
expr_stmt|;
block|}
comment|/* Walk the predecessor links back to origin. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__node_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|curroot
argument_list|,
name|lastpath
operator|->
name|data
argument_list|,
name|predidpool
argument_list|)
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|pred_id
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Why not just fetch the predecessor ID in PREDIDPOOL?            Because svn_fs_fs__dag_get_predecessor_id() doesn't            necessarily honor the passed-in pool, and might return a            value cached in the node (which is allocated in            SUBPOOL... maybe). */
name|svn_pool_clear
argument_list|(
name|predidpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|pred_id
operator|=
name|pred_id
condition|?
name|svn_fs_fs__id_copy
argument_list|(
name|pred_id
argument_list|,
name|predidpool
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
do|while
condition|(
name|pred_id
condition|)
do|;
comment|/* When we get here, NODE should be the first node-revision in our        chain. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
name|revision
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wow, I don't want to have to do all that again.  Let's cache        the result. */
if|if
condition|(
name|node_id
operator|->
name|revision
operator|!=
name|SVN_INVALID_REVNUM
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_node_origin
argument_list|(
name|fs
argument_list|,
name|node_id
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|predidpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|history_prev
parameter_list|(
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history
parameter_list|,
name|svn_fs_history_t
modifier|*
name|history
parameter_list|,
name|svn_boolean_t
name|cross_copies
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_path
decl_stmt|,
modifier|*
name|src_path
decl_stmt|,
modifier|*
name|path
init|=
name|fhd
operator|->
name|path
decl_stmt|;
name|svn_revnum_t
name|commit_rev
decl_stmt|,
name|src_rev
decl_stmt|,
name|dst_rev
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|fhd
operator|->
name|revision
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|fhd
operator|->
name|fs
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_boolean_t
name|reported
init|=
name|fhd
operator|->
name|is_interesting
decl_stmt|;
name|svn_revnum_t
name|copyroot_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyroot_path
decl_stmt|;
comment|/* Initialize our return value. */
operator|*
name|prev_history
operator|=
name|NULL
expr_stmt|;
comment|/* If our last history report left us hints about where to pickup      the chase, then our last report was on the destination of a      copy.  If we are crossing copies, start from those locations,      otherwise, we're all done here.  */
if|if
condition|(
name|fhd
operator|->
name|path_hint
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|fhd
operator|->
name|rev_hint
argument_list|)
condition|)
block|{
name|reported
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|cross_copies
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|path
operator|=
name|fhd
operator|->
name|path_hint
expr_stmt|;
name|revision
operator|=
name|fhd
operator|->
name|rev_hint
expr_stmt|;
block|}
comment|/* Construct a ROOT for the current revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open PATH/REVISION, and get its node and a bunch of other      goodies.  */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
name|commit_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|commit_rev
argument_list|,
name|node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The Subversion filesystem is written in such a way that a given      line of history may have at most one interesting history point      per filesystem revision.  Either that node was edited (and      possibly copied), or it was copied but not edited.  And a copy      source cannot be from the same revision as its destination.  So,      if our history revision matches its node's commit revision, we      know that ... */
if|if
condition|(
name|revision
operator|==
name|commit_rev
condition|)
block|{
if|if
condition|(
operator|!
name|reported
condition|)
block|{
comment|/* ... we either have not yet reported on this revision (and              need now to do so) ... */
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|commit_path
argument_list|,
name|commit_rev
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* ... or we *have* reported on this revision, and must now              progress toward this node's predecessor (unless there is              no predecessor, in which case we're all done!). */
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pred_id
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Replace NODE and friends with the information from its              predecessor. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|pred_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|commit_path
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_revision
argument_list|(
operator|&
name|commit_rev
argument_list|,
name|node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find the youngest copyroot in the path of this node, including      itself. */
name|SVN_ERR
argument_list|(
name|find_youngest_copyroot
argument_list|(
operator|&
name|copyroot_rev
argument_list|,
operator|&
name|copyroot_path
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize some state variables. */
name|src_path
operator|=
name|NULL
expr_stmt|;
name|src_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|dst_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|copyroot_rev
operator|>
name|commit_rev
condition|)
block|{
specifier|const
name|char
modifier|*
name|remainder_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_dst
decl_stmt|,
modifier|*
name|copy_src
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copyroot_root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__revision_root
argument_list|(
operator|&
name|copyroot_root
argument_list|,
name|fs
argument_list|,
name|copyroot_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|copyroot_root
argument_list|,
name|copyroot_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|copy_dst
operator|=
name|svn_fs_fs__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* If our current path was the very destination of the copy,          then our new current path will be the copy source.  If our          current path was instead the *child* of the destination of          the copy, then figure out its previous location by taking its          path relative to the copy destination and appending that to          the copy source.  Finally, if our current path doesn't meet          one of these other criteria ... ### for now just fallback to          the old copy hunt algorithm. */
name|remainder_path
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|copy_dst
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder_path
condition|)
block|{
comment|/* If we get here, then our current path is the destination              of, or the child of the destination of, a copy.  Fill              in the return values and get outta here.  */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_rev
argument_list|(
operator|&
name|src_rev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_copyfrom_path
argument_list|(
operator|&
name|copy_src
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|dst_rev
operator|=
name|copyroot_rev
expr_stmt|;
name|src_path
operator|=
name|svn_fspath__join
argument_list|(
name|copy_src
argument_list|,
name|remainder_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we calculated a copy source path and revision, we'll make a      'copy-style' history object. */
if|if
condition|(
name|src_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|src_rev
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|retry
init|=
name|FALSE
decl_stmt|;
comment|/* It's possible for us to find a copy location that is the same          as the history point we've just reported.  If that happens,          we simply need to take another trip through this history          search. */
if|if
condition|(
operator|(
name|dst_rev
operator|==
name|revision
operator|)
operator|&&
name|reported
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|dst_rev
argument_list|,
operator|!
name|retry
argument_list|,
name|src_path
argument_list|,
name|src_rev
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|commit_path
argument_list|,
name|commit_rev
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implement svn_fs_history_prev, set *PREV_HISTORY_P to a new    svn_fs_history_t object that represents the predecessory of    HISTORY.  If CROSS_COPIES is true, *PREV_HISTORY_P may be related    only through a copy operation.  Perform all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_history_prev
parameter_list|(
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history_p
parameter_list|,
name|svn_fs_history_t
modifier|*
name|history
parameter_list|,
name|svn_boolean_t
name|cross_copies
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_history_t
modifier|*
name|prev_history
init|=
name|NULL
decl_stmt|;
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|fhd
operator|->
name|fs
decl_stmt|;
comment|/* Special case: the root directory changes in every single      revision, no exceptions.  And, the root can't be the target (or      child of a target -- duh) of a copy.  So, if that's our path,      then we need only decrement our revision by 1, and there you go. */
if|if
condition|(
name|strcmp
argument_list|(
name|fhd
operator|->
name|path
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|fhd
operator|->
name|is_interesting
condition|)
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
literal|"/"
argument_list|,
name|fhd
operator|->
name|revision
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fhd
operator|->
name|revision
operator|>
literal|0
condition|)
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
literal|"/"
argument_list|,
name|fhd
operator|->
name|revision
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|prev_history
operator|=
name|history
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|history_prev
argument_list|(
operator|&
name|prev_history
argument_list|,
name|prev_history
argument_list|,
name|cross_copies
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_history
condition|)
break|break;
name|fhd
operator|=
name|prev_history
operator|->
name|fsap_data
expr_stmt|;
if|if
condition|(
name|fhd
operator|->
name|is_interesting
condition|)
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
operator|*
name|prev_history_p
operator|=
name|prev_history
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *PATH and *REVISION to the path and revision for the HISTORY    object.  Use POOL for all allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_history_location
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_history_t
modifier|*
name|history
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|fhd
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|revision
operator|=
name|fhd
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|history_vtable_t
name|history_vtable
init|=
block|{
name|fs_history_prev
block|,
name|fs_history_location
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a new history object (marked as "interesting") for PATH and    REVISION, allocated in POOL, and with its members set to the values    of the parameters provided.  Note that PATH and PATH_HINT get    normalized and duplicated in POOL. */
end_comment

begin_function
specifier|static
name|svn_fs_history_t
modifier|*
name|assemble_history
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|is_interesting
parameter_list|,
specifier|const
name|char
modifier|*
name|path_hint
parameter_list|,
name|svn_revnum_t
name|rev_hint
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_history_t
modifier|*
name|history
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|history
argument_list|)
argument_list|)
decl_stmt|;
name|fs_history_data_t
modifier|*
name|fhd
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fhd
argument_list|)
argument_list|)
decl_stmt|;
name|fhd
operator|->
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fhd
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|fhd
operator|->
name|is_interesting
operator|=
name|is_interesting
expr_stmt|;
name|fhd
operator|->
name|path_hint
operator|=
name|path_hint
condition|?
name|svn_fs__canonicalize_abspath
argument_list|(
name|path_hint
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|fhd
operator|->
name|rev_hint
operator|=
name|rev_hint
expr_stmt|;
name|fhd
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|history
operator|->
name|vtable
operator|=
operator|&
name|history_vtable
expr_stmt|;
name|history
operator|->
name|fsap_data
operator|=
name|fhd
expr_stmt|;
return|return
name|history
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* mergeinfo queries */
end_comment

begin_comment
comment|/* DIR_DAG is a directory DAG node which has mergeinfo in its    descendants.  This function iterates over its children.  For each    child with immediate mergeinfo, it adds its mergeinfo to    RESULT_CATALOG.  appropriate arguments.  For each child with    descendants with mergeinfo, it recurses.  Note that it does *not*    call the action on the path for DIR_DAG itself.     POOL is used for temporary allocations, including the mergeinfo    hashes passed to actions; RESULT_POOL is used for the mergeinfo added    to RESULT_CATALOG.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|crawl_directory_dag_for_mergeinfo
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|this_path
parameter_list|,
name|dag_node_t
modifier|*
name|dir_dag
parameter_list|,
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|dir_dag
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|kid_path
decl_stmt|;
name|dag_node_t
modifier|*
name|kid_dag
decl_stmt|;
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|,
name|go_down
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|kid_path
operator|=
name|svn_fspath__join
argument_list|(
name|this_path
argument_list|,
name|dirent
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|kid_dag
argument_list|,
name|root
argument_list|,
name|kid_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
name|kid_dag
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_descendants_with_mergeinfo
argument_list|(
operator|&
name|go_down
argument_list|,
name|kid_dag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mergeinfo
condition|)
block|{
comment|/* Save this particular node's mergeinfo. */
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_mergeinfo_t
name|kid_mergeinfo
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|kid_dag
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_string
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mergeinfo_string
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|dirent
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node-revision #'%s' claims to have mergeinfo but doesn't"
argument_list|)
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Issue #3896: If a node has syntactically invalid mergeinfo, then              treat it as if no mergeinfo is present rather than raising a parse              error. */
name|err
operator|=
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|kid_mergeinfo
argument_list|,
name|mergeinfo_string
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
name|svn_hash_sets
argument_list|(
name|result_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|kid_path
argument_list|)
argument_list|,
name|kid_mergeinfo
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|go_down
condition|)
name|SVN_ERR
argument_list|(
name|crawl_directory_dag_for_mergeinfo
argument_list|(
name|root
argument_list|,
name|kid_path
argument_list|,
name|kid_dag
argument_list|,
name|result_catalog
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the cache key as a combination of REV_ROOT->REV, the inheritance    flags INHERIT and ADJUST_INHERITED_MERGEINFO, and the PATH.  The result    will be allocated in POOL..  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|mergeinfo_cache_key
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|rev_root
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_int64_t
name|number
init|=
name|rev_root
operator|->
name|rev
decl_stmt|;
name|number
operator|=
name|number
operator|*
literal|4
operator|+
operator|(
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
condition|?
literal|2
else|:
literal|0
operator|)
operator|+
operator|(
name|adjust_inherited_mergeinfo
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|svn_fs_fs__combine_number_and_string
argument_list|(
name|number
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Calculates the mergeinfo for PATH under REV_ROOT using inheritance    type INHERIT.  Returns it in *MERGEINFO, or NULL if there is none.    The result is allocated in RESULT_POOL; SCRATCH_POOL is    used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfo_for_path_internal
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_fs_root_t
modifier|*
name|rev_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|,
modifier|*
name|nearest_ancestor
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|rev_root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
operator|&&
operator|!
name|parent_path
operator|->
name|parent
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
condition|)
name|nearest_ancestor
operator|=
name|parent_path
operator|->
name|parent
expr_stmt|;
else|else
name|nearest_ancestor
operator|=
name|parent_path
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
name|nearest_ancestor
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mergeinfo
condition|)
break|break;
comment|/* No need to loop if we're looking for explicit mergeinfo. */
if|if
condition|(
name|inherit
operator|==
name|svn_mergeinfo_explicit
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
name|nearest_ancestor
operator|=
name|nearest_ancestor
operator|->
name|parent
expr_stmt|;
comment|/* Run out?  There's no mergeinfo. */
if|if
condition|(
operator|!
name|nearest_ancestor
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|nearest_ancestor
operator|->
name|node
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_string
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mergeinfo_string
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node-revision '%s@%ld' claims to have mergeinfo but doesn't"
argument_list|)
argument_list|,
name|parent_path_path
argument_list|(
name|nearest_ancestor
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|rev_root
operator|->
name|rev
argument_list|)
return|;
comment|/* Parse the mergeinfo; store the result in *MERGEINFO. */
block|{
comment|/* Issue #3896: If a node has syntactically invalid mergeinfo, then        treat it as if no mergeinfo is present rather than raising a parse        error. */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_mergeinfo_parse
argument_list|(
name|mergeinfo
argument_list|,
name|mergeinfo_string
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
operator|*
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* If our nearest ancestor is the very path we inquired about, we      can return the mergeinfo results directly.  Otherwise, we're      inheriting the mergeinfo, so we need to a) remove non-inheritable      ranges and b) telescope the merged-from paths. */
if|if
condition|(
name|adjust_inherited_mergeinfo
operator|&&
operator|(
name|nearest_ancestor
operator|!=
name|parent_path
operator|)
condition|)
block|{
name|svn_mergeinfo_t
name|tmp_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_inheritable2
argument_list|(
operator|&
name|tmp_mergeinfo
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__append_to_merged_froms
argument_list|(
name|mergeinfo
argument_list|,
name|tmp_mergeinfo
argument_list|,
name|parent_path_relpath
argument_list|(
name|parent_path
argument_list|,
name|nearest_ancestor
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Caching wrapper around get_mergeinfo_for_path_internal().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfo_for_path
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_fs_root_t
modifier|*
name|rev_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|rev_root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|cache_key
decl_stmt|;
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|mergeinfo_exists
decl_stmt|;
operator|*
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
name|cache_key
operator|=
name|mergeinfo_cache_key
argument_list|(
name|path
argument_list|,
name|rev_root
argument_list|,
name|inherit
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|mergeinfo_existence_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|mergeinfo_exists
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|mergeinfo_existence_cache
argument_list|,
name|cache_key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
operator|&&
name|mergeinfo_exists
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'1'
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|mergeinfo
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|mergeinfo_cache
argument_list|,
name|cache_key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_mergeinfo_for_path_internal
argument_list|(
name|mergeinfo
argument_list|,
name|rev_root
argument_list|,
name|path
argument_list|,
name|inherit
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|mergeinfo_existence_cache
condition|)
block|{
name|mergeinfo_exists
operator|=
name|svn_stringbuf_create
argument_list|(
operator|*
name|mergeinfo
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|mergeinfo_existence_cache
argument_list|,
name|cache_key
argument_list|,
name|mergeinfo_exists
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|mergeinfo_cache
argument_list|,
name|cache_key
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Adds mergeinfo for each descendant of PATH (but not PATH itself)    under ROOT to RESULT_CATALOG.  Returned values are allocated in    RESULT_POOL; temporary values in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_descendant_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|this_dag
decl_stmt|;
name|svn_boolean_t
name|go_down
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|this_dag
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_descendants_with_mergeinfo
argument_list|(
operator|&
name|go_down
argument_list|,
name|this_dag
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|go_down
condition|)
name|SVN_ERR
argument_list|(
name|crawl_directory_dag_for_mergeinfo
argument_list|(
name|root
argument_list|,
name|path
argument_list|,
name|this_dag
argument_list|,
name|result_catalog
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the mergeinfo for a set of paths, returned in    *MERGEINFO_CATALOG.  Returned values are allocated in    POOL, while temporary values are allocated in a sub-pool. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfos_for_paths
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|mergeinfo_catalog
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_catalog_t
name|result_catalog
init|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_mergeinfo_t
name|path_mergeinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_mergeinfo_for_path
argument_list|(
operator|&
name|path_mergeinfo
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|inherit
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|path_mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|path_mergeinfo
condition|)
name|svn_hash_sets
argument_list|(
name|result_catalog
argument_list|,
name|path
argument_list|,
name|path_mergeinfo
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_descendants
condition|)
name|SVN_ERR
argument_list|(
name|add_descendant_mergeinfo
argument_list|(
name|result_catalog
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|mergeinfo_catalog
operator|=
name|result_catalog
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_fs_get_mergeinfo. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_get_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|catalog
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|root
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* We require a revision root. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_REVISION_ROOT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* We have to actually be able to find the mergeinfo metadata! */
if|if
condition|(
operator|!
name|svn_fs_fs__fs_supports_mergeinfo
argument_list|(
name|root
operator|->
name|fs
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Querying mergeinfo requires version %d of the FSFS filesystem "
literal|"schema; filesystem '%s' uses only version %d"
argument_list|)
argument_list|,
name|SVN_FS_FS__MIN_MERGEINFO_FORMAT
argument_list|,
name|root
operator|->
name|fs
operator|->
name|path
argument_list|,
name|ffd
operator|->
name|format
argument_list|)
return|;
comment|/* Retrieve a path -> mergeinfo hash mapping. */
return|return
name|get_mergeinfos_for_paths
argument_list|(
name|root
argument_list|,
name|catalog
argument_list|,
name|paths
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The vtable associated with root objects. */
end_comment

begin_decl_stmt
specifier|static
name|root_vtable_t
name|root_vtable
init|=
block|{
name|fs_paths_changed
block|,
name|svn_fs_fs__check_path
block|,
name|fs_node_history
block|,
name|svn_fs_fs__node_id
block|,
name|fs_node_relation
block|,
name|svn_fs_fs__node_created_rev
block|,
name|fs_node_origin_rev
block|,
name|fs_node_created_path
block|,
name|fs_delete_node
block|,
name|fs_copy
block|,
name|fs_revision_link
block|,
name|fs_copied_from
block|,
name|fs_closest_copy
block|,
name|fs_node_prop
block|,
name|fs_node_proplist
block|,
name|fs_node_has_props
block|,
name|fs_change_node_prop
block|,
name|fs_props_changed
block|,
name|fs_dir_entries
block|,
name|fs_dir_optimal_order
block|,
name|fs_make_dir
block|,
name|fs_file_length
block|,
name|fs_file_checksum
block|,
name|fs_file_contents
block|,
name|fs_try_process_file_contents
block|,
name|fs_make_file
block|,
name|fs_apply_textdelta
block|,
name|fs_apply_text
block|,
name|fs_contents_changed
block|,
name|fs_get_file_delta_stream
block|,
name|fs_merge
block|,
name|fs_get_mergeinfo
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct a new root object in FS, allocated from POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_root_t
modifier|*
name|make_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|root
argument_list|)
argument_list|)
decl_stmt|;
name|root
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|root
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|root
operator|->
name|vtable
operator|=
operator|&
name|root_vtable
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

begin_comment
comment|/* Construct a root object referring to the root of REVISION in FS,    whose root directory is ROOT_DIR.  Create the new root in POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_root_t
modifier|*
name|make_revision_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|root_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|make_root
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|root
operator|->
name|is_txn_root
operator|=
name|FALSE
expr_stmt|;
name|root
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
name|root
operator|->
name|fsap_data
operator|=
name|root_dir
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

begin_comment
comment|/* Construct a root object referring to the root of the transaction    named TXN and based on revision BASE_REV in FS, with FLAGS to    describe transaction's behavior.  Create the new root in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_txn_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|txn
parameter_list|,
name|svn_revnum_t
name|base_rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|make_root
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|fs_txn_root_data_t
modifier|*
name|frd
init|=
name|apr_pcalloc
argument_list|(
name|root
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frd
argument_list|)
argument_list|)
decl_stmt|;
name|frd
operator|->
name|txn_id
operator|=
operator|*
name|txn
expr_stmt|;
name|root
operator|->
name|is_txn_root
operator|=
name|TRUE
expr_stmt|;
name|root
operator|->
name|txn
operator|=
name|svn_fs_fs__id_txn_unparse
argument_list|(
name|txn
argument_list|,
name|root
operator|->
name|pool
argument_list|)
expr_stmt|;
name|root
operator|->
name|txn_flags
operator|=
name|flags
expr_stmt|;
name|root
operator|->
name|rev
operator|=
name|base_rev
expr_stmt|;
comment|/* Because this cache actually tries to invalidate elements, keep      the number of elements per page down.       Note that since dag_node_cache_invalidate uses svn_cache__iter,      this *cannot* be a memcache-based cache.  */
name|SVN_ERR
argument_list|(
name|svn_cache__create_inprocess
argument_list|(
operator|&
operator|(
name|frd
operator|->
name|txn_node_cache
operator|)
argument_list|,
name|svn_fs_fs__dag_serialize
argument_list|,
name|svn_fs_fs__dag_deserialize
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
literal|32
argument_list|,
literal|20
argument_list|,
name|FALSE
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|txn
argument_list|,
literal|":TXN"
argument_list|,
name|SVN_VA_NULL
argument_list|)
argument_list|,
name|root
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize transaction-local caches in FS.       Note that we cannot put those caches in frd because that content      fs root object is not available where we would need it. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__initialize_txn_caches
argument_list|(
name|fs
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|root
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|->
name|fsap_data
operator|=
name|frd
expr_stmt|;
operator|*
name|root_p
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Verify. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|stringify_node
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* ### TODO: print some PATH@REV to it, too. */
return|return
name|svn_fs_fs__id_unparse
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|pool
argument_list|)
operator|->
name|data
return|;
block|}
end_function

begin_comment
comment|/* Check metadata sanity on NODE, and on its children.  Manually verify    information for DAG nodes in revision REV, and trust the metadata    accuracy for nodes belonging to older revisions.  To detect cycles,    provide all parent dag_node_t * in PARENT_NODES. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_node
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_array_header_t
modifier|*
name|parent_nodes
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|;
name|apr_int64_t
name|mergeinfo_count
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_fs__dag_get_fs
argument_list|(
name|node
argument_list|)
decl_stmt|;
name|int
name|pred_count
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Detect (non-)DAG cycles. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|parent_nodes
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|dag_node_t
modifier|*
name|parent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|parent_nodes
argument_list|,
name|i
argument_list|,
name|dag_node_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_fs_fs__id_eq
argument_list|(
name|svn_fs_fs__dag_get_id
argument_list|(
name|parent
argument_list|)
argument_list|,
name|svn_fs_fs__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Node is its own direct or indirect parent '%s'"
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Fetch some data. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_has_mergeinfo
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|mergeinfo_count
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_count
argument_list|(
operator|&
name|pred_count
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|svn_fs_fs__dag_node_kind
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Sanity check. */
if|if
condition|(
name|mergeinfo_count
operator|<
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Negative mergeinfo-count %"
name|APR_INT64_T_FMT
literal|" on node '%s'"
argument_list|,
name|mergeinfo_count
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* Issue #4129. (This check will explicitly catch non-root instances too.) */
if|if
condition|(
name|pred_id
condition|)
block|{
name|dag_node_t
modifier|*
name|pred
decl_stmt|;
name|int
name|pred_pred_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|pred
argument_list|,
name|fs
argument_list|,
name|pred_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_count
argument_list|(
operator|&
name|pred_pred_count
argument_list|,
name|pred
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pred_pred_count
operator|+
literal|1
operator|!=
name|pred_count
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Predecessor count mismatch: "
literal|"%s has %d, but %s has %d"
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|pred_count
argument_list|,
name|stringify_node
argument_list|(
name|pred
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|pred_pred_count
argument_list|)
return|;
block|}
comment|/* Kind-dependent verifications. */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Node '%s' has kind 'none'"
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
if|if
condition|(
name|has_mergeinfo
operator|!=
name|mergeinfo_count
condition|)
comment|/* comparing int to bool */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"File node '%s' has inconsistent mergeinfo: "
literal|"has_mergeinfo=%d, "
literal|"mergeinfo_count=%"
name|APR_INT64_T_FMT
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|has_mergeinfo
argument_list|,
name|mergeinfo_count
argument_list|)
return|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|apr_int64_t
name|children_mergeinfo
init|=
literal|0
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|parent_nodes
argument_list|,
name|dag_node_t
operator|*
argument_list|)
operator|=
name|node
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|node
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compute CHILDREN_MERGEINFO. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
name|apr_int64_t
name|child_mergeinfo
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Compute CHILD_REV. */
if|if
condition|(
name|svn_fs_fs__id_rev
argument_list|(
name|dirent
operator|->
name|id
argument_list|)
operator|==
name|rev
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_node
argument_list|(
operator|&
name|child
argument_list|,
name|fs
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_node
argument_list|(
name|child
argument_list|,
name|rev
argument_list|,
name|parent_nodes
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_mergeinfo_count
argument_list|(
operator|&
name|child_mergeinfo
argument_list|,
name|child
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* access mergeinfo counter with minimal overhead */
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|dirent
operator|->
name|id
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|child_mergeinfo
operator|=
name|noderev
operator|->
name|mergeinfo_count
expr_stmt|;
block|}
name|children_mergeinfo
operator|+=
name|child_mergeinfo
expr_stmt|;
block|}
comment|/* Side-effect of issue #4129. */
if|if
condition|(
name|children_mergeinfo
operator|+
name|has_mergeinfo
operator|!=
name|mergeinfo_count
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Mergeinfo-count discrepancy on '%s': "
literal|"expected %"
name|APR_INT64_T_FMT
literal|"+%d, "
literal|"counted %"
name|APR_INT64_T_FMT
argument_list|,
name|stringify_node
argument_list|(
name|node
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|mergeinfo_count
argument_list|,
name|has_mergeinfo
argument_list|,
name|children_mergeinfo
argument_list|)
return|;
comment|/* If we don't make it here, there was an error / corruption.        * In that case, nobody will need PARENT_NODES anymore. */
name|apr_array_pop
argument_list|(
name|parent_nodes
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__verify_root
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|;
name|apr_array_header_t
modifier|*
name|parent_nodes
decl_stmt|;
comment|/* Issue #4129: bogus pred-counts and minfo-cnt's on the root node-rev      (and elsewhere).  This code makes more thorough checks than the      commit-time checks in validate_root_noderev(). */
comment|/* Callers should disable caches by setting SVN_FS_CONFIG_FSFS_CACHE_NS;      see r1462436.       When this code is called in the library, we want to ensure we      use the on-disk data --- rather than some data that was read      in the possibly-distance past and cached since. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
block|{
name|fs_txn_root_data_t
modifier|*
name|frd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_txn_root
argument_list|(
operator|&
name|root_dir
argument_list|,
name|fs
argument_list|,
operator|&
name|frd
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|root_dir
operator|=
name|root
operator|->
name|fsap_data
expr_stmt|;
block|}
comment|/* Recursively verify ROOT_DIR. */
name|parent_nodes
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|dag_node_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_node
argument_list|(
name|root_dir
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|parent_nodes
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify explicitly the predecessor of the root. */
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
comment|/* Only r0 should have no predecessor. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|root_dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
operator|&&
operator|!
operator|!
name|pred_id
operator|!=
operator|!
operator|!
name|root
operator|->
name|rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"r%ld's root node's predecessor is "
literal|"unexpectedly '%s'"
argument_list|,
name|root
operator|->
name|rev
argument_list|,
operator|(
name|pred_id
condition|?
name|svn_fs_fs__id_unparse
argument_list|(
name|pred_id
argument_list|,
name|pool
argument_list|)
operator|->
name|data
else|:
literal|"(null)"
operator|)
argument_list|)
return|;
if|if
condition|(
name|root
operator|->
name|is_txn_root
operator|&&
operator|!
name|pred_id
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Transaction '%s''s root node's predecessor is "
literal|"unexpectedly NULL"
argument_list|,
name|root
operator|->
name|txn
argument_list|)
return|;
comment|/* Check the predecessor's revision. */
if|if
condition|(
name|pred_id
condition|)
block|{
name|svn_revnum_t
name|pred_rev
init|=
name|svn_fs_fs__id_rev
argument_list|(
name|pred_id
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
operator|&&
name|pred_rev
operator|+
literal|1
operator|!=
name|root
operator|->
name|rev
condition|)
comment|/* Issue #4129. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"r%ld's root node's predecessor is r%ld"
literal|" but should be r%ld"
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|pred_rev
argument_list|,
name|root
operator|->
name|rev
operator|-
literal|1
argument_list|)
return|;
if|if
condition|(
name|root
operator|->
name|is_txn_root
operator|&&
name|pred_rev
operator|!=
name|root
operator|->
name|rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
literal|"Transaction '%s''s root node's predecessor"
literal|" is r%ld"
literal|" but should be r%ld"
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|pred_rev
argument_list|,
name|root
operator|->
name|rev
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

