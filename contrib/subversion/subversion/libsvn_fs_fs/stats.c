begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* stats.c -- implements the svn_fs_fs__get_stats private API.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cache.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_fs_private.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"rev_file.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"fs_fs.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* We group representations into 2x2 different kinds plus one default:  * [dir / file] x [text / prop]. The assignment is done by the first node  * that references the respective representation.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|rep_kind_t
block|{
comment|/* The representation is not used _directly_, i.e. not referenced by any    * noderev. However, some other representation may use it as delta base.    * Null value. Should not occur in real-word repositories. */
name|unused_rep
block|,
comment|/* a properties on directory rep  */
name|dir_property_rep
block|,
comment|/* a properties on file rep  */
name|file_property_rep
block|,
comment|/* a directory rep  */
name|dir_rep
block|,
comment|/* a file rep  */
name|file_rep
block|}
name|rep_kind_t
typedef|;
end_typedef

begin_comment
comment|/* A representation fragment.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rep_stats_t
block|{
comment|/* absolute offset in the file */
name|apr_off_t
name|offset
decl_stmt|;
comment|/* item length in bytes */
name|apr_uint64_t
name|size
decl_stmt|;
comment|/* item length after de-deltification */
name|apr_uint64_t
name|expanded_size
decl_stmt|;
comment|/* revision that contains this representation    * (may be referenced by other revisions, though) */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* number of nodes that reference this representation */
name|apr_uint32_t
name|ref_count
decl_stmt|;
comment|/* length of the PLAIN / DELTA line in the source file in bytes */
name|apr_uint16_t
name|header_size
decl_stmt|;
comment|/* classification of the representation. values of rep_kind_t */
name|char
name|kind
decl_stmt|;
block|}
name|rep_stats_t
typedef|;
end_typedef

begin_comment
comment|/* Represents a single revision.  * There will be only one instance per revision. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|revision_info_t
block|{
comment|/* number of this revision */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* pack file offset (manifest value), 0 for non-packed files */
name|apr_off_t
name|offset
decl_stmt|;
comment|/* length of the changes list on bytes */
name|apr_uint64_t
name|changes_len
decl_stmt|;
comment|/* offset of the changes list relative to OFFSET */
name|apr_uint64_t
name|change_count
decl_stmt|;
comment|/* first offset behind the revision data in the pack file (file length    * for non-packed revs) */
name|apr_off_t
name|end
decl_stmt|;
comment|/* number of directory noderevs in this revision */
name|apr_uint64_t
name|dir_noderev_count
decl_stmt|;
comment|/* number of file noderevs in this revision */
name|apr_uint64_t
name|file_noderev_count
decl_stmt|;
comment|/* total size of directory noderevs (i.e. the structs - not the rep) */
name|apr_uint64_t
name|dir_noderev_size
decl_stmt|;
comment|/* total size of file noderevs (i.e. the structs - not the rep) */
name|apr_uint64_t
name|file_noderev_size
decl_stmt|;
comment|/* all rep_stats_t of this revision (in no particular order),    * i.e. those that point back to this struct */
name|apr_array_header_t
modifier|*
name|representations
decl_stmt|;
comment|/* Temporary rev / pack file access object, used in phys. addressing    * mode only.  NULL when done reading this revision. */
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
block|}
name|revision_info_t
typedef|;
end_typedef

begin_comment
comment|/* Root data structure containing all information about a given repository.  * We use it as a wrapper around svn_fs_t and pass it around where we would  * otherwise just use a svn_fs_t.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|query_t
block|{
comment|/* FS API object*/
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* The HEAD revision. */
name|svn_revnum_t
name|head
decl_stmt|;
comment|/* Number of revs per shard; 0 for non-sharded repos. */
name|int
name|shard_size
decl_stmt|;
comment|/* First non-packed revision. */
name|svn_revnum_t
name|min_unpacked_rev
decl_stmt|;
comment|/* all revisions */
name|apr_array_header_t
modifier|*
name|revisions
decl_stmt|;
comment|/* empty representation.    * Used as a dummy base for DELTA reps without base. */
name|rep_stats_t
modifier|*
name|null_base
decl_stmt|;
comment|/* collected statistics */
name|svn_fs_fs__stats_t
modifier|*
name|stats
decl_stmt|;
comment|/* Progress notification callback to call after each shard.  May be NULL. */
name|svn_fs_progress_notify_func_t
name|progress_func
decl_stmt|;
comment|/* Baton for PROGRESS_FUNC. */
name|void
modifier|*
name|progress_baton
decl_stmt|;
comment|/* Cancellation support callback to call once in a while.  May be NULL. */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
comment|/* Baton for CANCEL_FUNC. */
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
name|query_t
typedef|;
end_typedef

begin_comment
comment|/* Return the length of REV_FILE in *FILE_SIZE.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_size
parameter_list|(
name|apr_off_t
modifier|*
name|file_size
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_info_get
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file_size
operator|=
name|finfo
operator|.
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Initialize the LARGEST_CHANGES member in STATS with a capacity of COUNT  * entries.  Allocate the result in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|void
name|initialize_largest_changes
parameter_list|(
name|svn_fs_fs__stats_t
modifier|*
name|stats
parameter_list|,
name|apr_size_t
name|count
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|stats
operator|->
name|largest_changes
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
operator|->
name|largest_changes
argument_list|)
argument_list|)
expr_stmt|;
name|stats
operator|->
name|largest_changes
operator|->
name|count
operator|=
name|count
expr_stmt|;
name|stats
operator|->
name|largest_changes
operator|->
name|min_size
operator|=
literal|1
expr_stmt|;
name|stats
operator|->
name|largest_changes
operator|->
name|changes
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|stats
operator|->
name|largest_changes
operator|->
name|changes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* allocate *all* entries before the path stringbufs.  This increases    * cache locality and enhances performance significantly. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|stats
operator|->
name|largest_changes
operator|->
name|changes
index|[
name|i
index|]
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|stats
operator|->
name|largest_changes
operator|->
name|changes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now initialize them and allocate the stringbufs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|stats
operator|->
name|largest_changes
operator|->
name|changes
index|[
name|i
index|]
operator|->
name|size
operator|=
literal|0
expr_stmt|;
name|stats
operator|->
name|largest_changes
operator|->
name|changes
index|[
name|i
index|]
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|stats
operator|->
name|largest_changes
operator|->
name|changes
index|[
name|i
index|]
operator|->
name|path
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|1024
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Add entry for SIZE to HISTOGRAM.  */
end_comment

begin_function
specifier|static
name|void
name|add_to_histogram
parameter_list|(
name|svn_fs_fs__histogram_t
modifier|*
name|histogram
parameter_list|,
name|apr_int64_t
name|size
parameter_list|)
block|{
name|apr_int64_t
name|shift
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
call|(
name|apr_int64_t
call|)
argument_list|(
literal|1
argument_list|)
operator|<<
name|shift
operator|)
operator|<=
name|size
condition|)
name|shift
operator|++
expr_stmt|;
name|histogram
operator|->
name|total
operator|.
name|count
operator|++
expr_stmt|;
name|histogram
operator|->
name|total
operator|.
name|sum
operator|+=
name|size
expr_stmt|;
name|histogram
operator|->
name|lines
index|[
operator|(
name|apr_size_t
operator|)
name|shift
index|]
operator|.
name|count
operator|++
expr_stmt|;
name|histogram
operator|->
name|lines
index|[
operator|(
name|apr_size_t
operator|)
name|shift
index|]
operator|.
name|sum
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Update data aggregators in STATS with this representation of type KIND,  * on-disk REP_SIZE and expanded node size EXPANDED_SIZE for PATH in REVSION.  * PLAIN_ADDED indicates whether the node has a deltification predecessor.  */
end_comment

begin_function
specifier|static
name|void
name|add_change
parameter_list|(
name|svn_fs_fs__stats_t
modifier|*
name|stats
parameter_list|,
name|apr_uint64_t
name|rep_size
parameter_list|,
name|apr_uint64_t
name|expanded_size
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|rep_kind_t
name|kind
parameter_list|,
name|svn_boolean_t
name|plain_added
parameter_list|)
block|{
comment|/* identify largest reps */
if|if
condition|(
name|rep_size
operator|>=
name|stats
operator|->
name|largest_changes
operator|->
name|min_size
condition|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|svn_fs_fs__largest_changes_t
modifier|*
name|largest_changes
init|=
name|stats
operator|->
name|largest_changes
decl_stmt|;
name|svn_fs_fs__large_change_info_t
modifier|*
name|info
init|=
name|largest_changes
operator|->
name|changes
index|[
name|largest_changes
operator|->
name|count
operator|-
literal|1
index|]
decl_stmt|;
name|info
operator|->
name|size
operator|=
name|rep_size
expr_stmt|;
name|info
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|svn_stringbuf_set
argument_list|(
name|info
operator|->
name|path
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* linear insertion but not too bad since count is low and insertions        * near the end are more likely than close to front */
for|for
control|(
name|i
operator|=
name|largest_changes
operator|->
name|count
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
if|if
condition|(
name|largest_changes
operator|->
name|changes
index|[
name|i
operator|-
literal|1
index|]
operator|->
name|size
operator|>=
name|rep_size
condition|)
break|break;
else|else
name|largest_changes
operator|->
name|changes
index|[
name|i
index|]
operator|=
name|largest_changes
operator|->
name|changes
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|largest_changes
operator|->
name|changes
index|[
name|i
index|]
operator|=
name|info
expr_stmt|;
name|largest_changes
operator|->
name|min_size
operator|=
name|largest_changes
operator|->
name|changes
index|[
name|largest_changes
operator|->
name|count
operator|-
literal|1
index|]
operator|->
name|size
expr_stmt|;
block|}
comment|/* global histograms */
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|rep_size_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|node_size_histogram
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|plain_added
condition|)
block|{
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|added_rep_size_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|added_node_size_histogram
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
block|}
comment|/* specific histograms by type */
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|unused_rep
case|:
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|unused_rep_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_property_rep
case|:
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|dir_prop_rep_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|dir_prop_histogram
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|file_property_rep
case|:
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|file_prop_rep_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|file_prop_histogram
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_rep
case|:
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|dir_rep_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|dir_histogram
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
break|break;
case|case
name|file_rep
case|:
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|file_rep_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
name|add_to_histogram
argument_list|(
operator|&
name|stats
operator|->
name|file_histogram
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* by extension */
if|if
condition|(
name|kind
operator|==
name|file_rep
condition|)
block|{
comment|/* determine extension */
name|svn_fs_fs__extension_info_t
modifier|*
name|info
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_name
init|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|extension
init|=
name|file_name
condition|?
name|strrchr
argument_list|(
name|file_name
argument_list|,
literal|'.'
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|extension
operator|==
name|NULL
operator|||
name|extension
operator|==
name|file_name
operator|+
literal|1
condition|)
name|extension
operator|=
literal|"(none)"
expr_stmt|;
comment|/* get / auto-insert entry for this extension */
name|info
operator|=
name|apr_hash_get
argument_list|(
name|stats
operator|->
name|by_extension
argument_list|,
name|extension
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|apr_hash_pool_get
argument_list|(
name|stats
operator|->
name|by_extension
argument_list|)
decl_stmt|;
name|info
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|extension
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|extension
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|stats
operator|->
name|by_extension
argument_list|,
name|info
operator|->
name|extension
argument_list|,
name|APR_HASH_KEY_STRING
argument_list|,
name|info
argument_list|)
expr_stmt|;
block|}
comment|/* update per-extension histogram */
name|add_to_histogram
argument_list|(
operator|&
name|info
operator|->
name|node_histogram
argument_list|,
name|expanded_size
argument_list|)
expr_stmt|;
name|add_to_histogram
argument_list|(
operator|&
name|info
operator|->
name|rep_histogram
argument_list|,
name|rep_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Comparator used for binary search comparing the absolute file offset  * of a representation to some other offset. DATA is a *rep_stats_t,  * KEY is a pointer to an apr_off_t.  */
end_comment

begin_function
specifier|static
name|int
name|compare_representation_offsets
parameter_list|(
specifier|const
name|void
modifier|*
name|data
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|)
block|{
name|apr_off_t
name|lhs
init|=
operator|(
operator|*
operator|(
specifier|const
name|rep_stats_t
operator|*
specifier|const
operator|*
operator|)
name|data
operator|)
operator|->
name|offset
decl_stmt|;
name|apr_off_t
name|rhs
init|=
operator|*
operator|(
specifier|const
name|apr_off_t
operator|*
operator|)
name|key
decl_stmt|;
if|if
condition|(
name|lhs
operator|<
name|rhs
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|lhs
operator|>
name|rhs
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Find the revision_info_t object to the given REVISION in QUERY and  * return it in *REVISION_INFO. For performance reasons, we skip the  * lookup if the info is already provided.  *  * In that revision, look for the rep_stats_t object for offset OFFSET.  * If it already exists, set *IDX to its index in *REVISION_INFO's  * representations list and return the representation object. Otherwise,  * set the index to where it must be inserted and return NULL.  */
end_comment

begin_function
specifier|static
name|rep_stats_t
modifier|*
name|find_representation
parameter_list|(
name|int
modifier|*
name|idx
parameter_list|,
name|query_t
modifier|*
name|query
parameter_list|,
name|revision_info_t
modifier|*
modifier|*
name|revision_info
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_off_t
name|offset
parameter_list|)
block|{
name|revision_info_t
modifier|*
name|info
decl_stmt|;
operator|*
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* first let's find the revision */
name|info
operator|=
name|revision_info
condition|?
operator|*
name|revision_info
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|info
operator|==
name|NULL
operator|||
name|info
operator|->
name|revision
operator|!=
name|revision
condition|)
block|{
name|info
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
name|revision
argument_list|,
name|revision_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision_info
condition|)
operator|*
name|revision_info
operator|=
name|info
expr_stmt|;
block|}
comment|/* not found -> no result */
if|if
condition|(
name|info
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* look for the representation */
operator|*
name|idx
operator|=
name|svn_sort__bsearch_lower_bound
argument_list|(
name|info
operator|->
name|representations
argument_list|,
operator|&
name|offset
argument_list|,
name|compare_representation_offsets
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|idx
operator|<
name|info
operator|->
name|representations
operator|->
name|nelts
condition|)
block|{
comment|/* return the representation, if this is the one we were looking for */
name|rep_stats_t
modifier|*
name|result
init|=
name|APR_ARRAY_IDX
argument_list|(
name|info
operator|->
name|representations
argument_list|,
operator|*
name|idx
argument_list|,
name|rep_stats_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|result
operator|->
name|offset
operator|==
name|offset
condition|)
return|return
name|result
return|;
block|}
comment|/* not parsed, yet */
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find / auto-construct the representation stats for REP in QUERY and  * return it in *REPRESENTATION.  *  * If necessary, allocate the result in RESULT_POOL; use SCRATCH_POOL for  * temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_representation
parameter_list|(
name|rep_stats_t
modifier|*
modifier|*
name|representation
parameter_list|,
name|query_t
modifier|*
name|query
parameter_list|,
name|representation_t
modifier|*
name|rep
parameter_list|,
name|revision_info_t
modifier|*
name|revision_info
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|rep_stats_t
modifier|*
name|result
decl_stmt|;
name|int
name|idx
decl_stmt|;
comment|/* read location (revision, offset) and size */
comment|/* look it up */
name|result
operator|=
name|find_representation
argument_list|(
operator|&
name|idx
argument_list|,
name|query
argument_list|,
operator|&
name|revision_info
argument_list|,
name|rep
operator|->
name|revision
argument_list|,
operator|(
name|apr_off_t
operator|)
name|rep
operator|->
name|item_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
block|{
comment|/* not parsed, yet (probably a rep in the same revision).        * Create a new rep object and determine its base rep as well.        */
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|revision
operator|=
name|rep
operator|->
name|revision
expr_stmt|;
name|result
operator|->
name|expanded_size
operator|=
operator|(
name|rep
operator|->
name|expanded_size
condition|?
name|rep
operator|->
name|expanded_size
else|:
name|rep
operator|->
name|size
operator|)
expr_stmt|;
name|result
operator|->
name|offset
operator|=
operator|(
name|apr_off_t
operator|)
name|rep
operator|->
name|item_index
expr_stmt|;
name|result
operator|->
name|size
operator|=
name|rep
operator|->
name|size
expr_stmt|;
comment|/* In phys. addressing mode, follow link to the actual representation.        * In log. addressing mode, we will find it already as part of our        * linear walk through the whole file. */
if|if
condition|(
operator|!
name|svn_fs_fs__use_log_addressing
argument_list|(
name|query
operator|->
name|fs
argument_list|)
condition|)
block|{
name|svn_fs_fs__rep_header_t
modifier|*
name|header
decl_stmt|;
name|apr_off_t
name|offset
init|=
name|revision_info
operator|->
name|offset
operator|+
name|result
operator|->
name|offset
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|revision_info
operator|->
name|rev_file
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|revision_info
operator|->
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_rep_header
argument_list|(
operator|&
name|header
argument_list|,
name|revision_info
operator|->
name|rev_file
operator|->
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|header_size
operator|=
name|header
operator|->
name|header_size
expr_stmt|;
block|}
name|svn_sort__array_insert
argument_list|(
name|revision_info
operator|->
name|representations
argument_list|,
operator|&
name|result
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
operator|*
name|representation
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* forward declaration */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|read_noderev
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|noderev_str
parameter_list|,
name|revision_info_t
modifier|*
name|revision_info
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Read the noderev item at OFFSET in REVISION_INFO from the filesystem  * provided by QUERY.  Return it in *NODEREV, allocated in RESULT_POOL.  * Use SCRATCH_POOL for temporary allocations.  *  * The textual representation of the noderev will be used to determine  * the on-disk size of the noderev.  Only called in phys. addressing mode.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_phsy_noderev
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|noderev
parameter_list|,
name|query_t
modifier|*
name|query
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|revision_info_t
modifier|*
name|revision_info
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|noderev_str
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|line
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Navigate the file stream to the start of noderev. */
name|SVN_ERR_ASSERT
argument_list|(
name|revision_info
operator|->
name|rev_file
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|revision_info
operator|->
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|revision_info
operator|->
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read it (terminated by an empty line) */
do|do
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|revision_info
operator|->
name|rev_file
operator|->
name|stream
argument_list|,
operator|&
name|line
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendstr
argument_list|(
name|noderev_str
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|noderev_str
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|line
operator|->
name|len
operator|>
literal|0
operator|&&
operator|!
name|eof
condition|)
do|;
comment|/* Return the result. */
operator|*
name|noderev
operator|=
name|noderev_str
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Starting at the directory in NODEREV's text, read all DAG nodes,  * directories and representations linked in that tree structure.  * Store them in QUERY and REVISION_INFO.  Also, read them only once.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_dir
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|revision_info_t
modifier|*
name|revision_info
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|dirent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_fs_fs__id_rev
argument_list|(
name|dirent
operator|->
name|id
argument_list|)
operator|==
name|revision_info
operator|->
name|revision
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|noderev_str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_phsy_noderev
argument_list|(
operator|&
name|noderev_str
argument_list|,
name|query
argument_list|,
name|svn_fs_fs__id_item
argument_list|(
name|dirent
operator|->
name|id
argument_list|)
argument_list|,
name|revision_info
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_noderev
argument_list|(
name|query
argument_list|,
name|noderev_str
argument_list|,
name|revision_info
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the noderev given as NODEREV_STR and store the info in QUERY and  * REVISION_INFO.  In phys. addressing mode, continue reading all DAG nodes,  * directories and representations linked in that tree structure.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_noderev
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|noderev_str
parameter_list|,
name|revision_info_t
modifier|*
name|revision_info
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|rep_stats_t
modifier|*
name|text
init|=
name|NULL
decl_stmt|;
name|rep_stats_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
init|=
name|svn_stream_from_stringbuf
argument_list|(
name|noderev_str
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
operator|&
name|noderev
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_representation
argument_list|(
operator|&
name|text
argument_list|,
name|query
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|,
name|revision_info
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if we are the first to use this rep, mark it as "text rep" */
if|if
condition|(
operator|++
name|text
operator|->
name|ref_count
operator|==
literal|1
condition|)
name|text
operator|->
name|kind
operator|=
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
name|dir_rep
else|:
name|file_rep
expr_stmt|;
block|}
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_representation
argument_list|(
operator|&
name|props
argument_list|,
name|query
argument_list|,
name|noderev
operator|->
name|prop_rep
argument_list|,
name|revision_info
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if we are the first to use this rep, mark it as "prop rep" */
if|if
condition|(
operator|++
name|props
operator|->
name|ref_count
operator|==
literal|1
condition|)
name|props
operator|->
name|kind
operator|=
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
name|dir_property_rep
else|:
name|file_property_rep
expr_stmt|;
block|}
comment|/* record largest changes */
if|if
condition|(
name|text
operator|&&
name|text
operator|->
name|ref_count
operator|==
literal|1
condition|)
name|add_change
argument_list|(
name|query
operator|->
name|stats
argument_list|,
name|text
operator|->
name|size
argument_list|,
name|text
operator|->
name|expanded_size
argument_list|,
name|text
operator|->
name|revision
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|,
name|text
operator|->
name|kind
argument_list|,
operator|!
name|noderev
operator|->
name|predecessor_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|&&
name|props
operator|->
name|ref_count
operator|==
literal|1
condition|)
name|add_change
argument_list|(
name|query
operator|->
name|stats
argument_list|,
name|props
operator|->
name|size
argument_list|,
name|props
operator|->
name|expanded_size
argument_list|,
name|props
operator|->
name|revision
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|,
name|props
operator|->
name|kind
argument_list|,
operator|!
name|noderev
operator|->
name|predecessor_id
argument_list|)
expr_stmt|;
comment|/* if this is a directory and has not been processed, yet, read and    * process it recursively */
if|if
condition|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
name|text
operator|&&
name|text
operator|->
name|ref_count
operator|==
literal|1
operator|&&
operator|!
name|svn_fs_fs__use_log_addressing
argument_list|(
name|query
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|parse_dir
argument_list|(
name|query
argument_list|,
name|noderev
argument_list|,
name|revision_info
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* update stats */
if|if
condition|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|revision_info
operator|->
name|dir_noderev_size
operator|+=
name|noderev_str
operator|->
name|len
expr_stmt|;
name|revision_info
operator|->
name|dir_noderev_count
operator|++
expr_stmt|;
block|}
else|else
block|{
name|revision_info
operator|->
name|file_noderev_size
operator|+=
name|noderev_str
operator|->
name|len
expr_stmt|;
name|revision_info
operator|->
name|file_noderev_count
operator|++
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For the revision given as REVISION_INFO within QUERY, determine the number  * of entries in its changed paths list and store that info in REVISION_INFO.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_phys_change_count
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|revision_info_t
modifier|*
name|revision_info
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* We are going to use our own sub-pool here because the changes object    * may well be>100MB and SCRATCH_POOL may not get cleared until all other    * info has been read by read_phys_revision().  Therefore, tidy up early.    */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changes
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_changes
argument_list|(
operator|&
name|changes
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|revision_info
operator|->
name|revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|revision_info
operator|->
name|change_count
operator|=
name|changes
operator|->
name|nelts
expr_stmt|;
comment|/* Release potentially tons of memory. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read header information for the revision stored in FILE_CONTENT (one  * whole revision).  Return the offsets within FILE_CONTENT for the  * *ROOT_NODEREV, the list of *CHANGES and its len in *CHANGES_LEN.  * Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_phys_revision
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|revision_info_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|apr_off_t
name|root_node_offset
decl_stmt|;
name|apr_off_t
name|changes_offset
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|trailer
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|noderev_str
decl_stmt|;
comment|/* Read the last 64 bytes of the revision (if long enough). */
name|apr_off_t
name|start
init|=
name|MAX
argument_list|(
name|info
operator|->
name|offset
argument_list|,
name|info
operator|->
name|end
operator|-
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
decl_stmt|;
name|apr_size_t
name|len
init|=
call|(
name|apr_size_t
call|)
argument_list|(
name|info
operator|->
name|end
operator|-
name|start
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|info
operator|->
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|info
operator|->
name|rev_file
operator|->
name|file
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|trailer
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|buf
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Parse that trailer. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__parse_revision_trailer
argument_list|(
operator|&
name|root_node_offset
argument_list|,
operator|&
name|changes_offset
argument_list|,
name|trailer
argument_list|,
name|info
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_phys_change_count
argument_list|(
name|query
argument_list|,
name|info
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate the length of the changes list. */
name|trailer
operator|=
name|svn_fs_fs__unparse_revision_trailer
argument_list|(
name|root_node_offset
argument_list|,
name|changes_offset
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|info
operator|->
name|changes_len
operator|=
name|info
operator|->
name|end
operator|-
name|info
operator|->
name|offset
operator|-
name|changes_offset
operator|-
name|trailer
operator|->
name|len
expr_stmt|;
comment|/* Recursively read nodes added in this rev. */
name|SVN_ERR
argument_list|(
name|read_phsy_noderev
argument_list|(
operator|&
name|noderev_str
argument_list|,
name|query
argument_list|,
name|root_node_offset
argument_list|,
name|info
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_noderev
argument_list|(
name|query
argument_list|,
name|noderev_str
argument_list|,
name|info
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the content of the pack file staring at revision BASE physical  * addressing mode and store it in QUERY.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_phys_pack_file
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|svn_revnum_t
name|base
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_off_t
name|file_size
init|=
literal|0
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|base
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_size
argument_list|(
operator|&
name|file_size
argument_list|,
name|rev_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process each revision in the pack file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|query
operator|->
name|shard_size
condition|;
operator|++
name|i
control|)
block|{
name|revision_info_t
modifier|*
name|info
decl_stmt|;
comment|/* cancellation support */
if|if
condition|(
name|query
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|query
operator|->
name|cancel_func
argument_list|(
name|query
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create the revision info for the current rev */
name|info
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|representations
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_stats_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|rev_file
operator|=
name|rev_file
expr_stmt|;
name|info
operator|->
name|revision
operator|=
name|base
operator|+
name|i
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_packed_offset
argument_list|(
operator|&
name|info
operator|->
name|offset
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|base
operator|+
name|i
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|query
operator|->
name|shard_size
condition|)
name|info
operator|->
name|end
operator|=
name|file_size
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_fs__get_packed_offset
argument_list|(
operator|&
name|info
operator|->
name|end
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|base
operator|+
name|i
operator|+
literal|1
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_phys_revision
argument_list|(
name|query
argument_list|,
name|info
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|representations
operator|=
name|apr_array_copy
argument_list|(
name|result_pool
argument_list|,
name|info
operator|->
name|representations
argument_list|)
expr_stmt|;
comment|/* Done with this revision. */
name|info
operator|->
name|rev_file
operator|=
name|NULL
expr_stmt|;
comment|/* put it into our container */
name|APR_ARRAY_PUSH
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
name|revision_info_t
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
comment|/* destroy temps */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Done with this pack file. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* one more pack file processed */
if|if
condition|(
name|query
operator|->
name|progress_func
condition|)
name|query
operator|->
name|progress_func
argument_list|(
name|base
argument_list|,
name|query
operator|->
name|progress_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the content of the file for REVISION in physical addressing mode  * and store its contents in QUERY.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_phys_revision_file
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|revision_info_t
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|apr_off_t
name|file_size
init|=
literal|0
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
comment|/* cancellation support */
if|if
condition|(
name|query
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|query
operator|->
name|cancel_func
argument_list|(
name|query
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read the whole pack file into memory */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_size
argument_list|(
operator|&
name|file_size
argument_list|,
name|rev_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create the revision info for the current rev */
name|info
operator|->
name|representations
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_stats_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|rev_file
operator|=
name|rev_file
expr_stmt|;
name|info
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|info
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|end
operator|=
name|file_size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_phys_revision
argument_list|(
name|query
argument_list|,
name|info
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done with this revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|rev_file
operator|=
name|NULL
expr_stmt|;
comment|/* put it into our container */
name|APR_ARRAY_PUSH
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
name|revision_info_t
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
comment|/* show progress every 1000 revs or so */
if|if
condition|(
name|query
operator|->
name|progress_func
condition|)
block|{
if|if
condition|(
name|query
operator|->
name|shard_size
operator|&&
operator|(
name|revision
operator|%
name|query
operator|->
name|shard_size
operator|==
literal|0
operator|)
condition|)
name|query
operator|->
name|progress_func
argument_list|(
name|revision
argument_list|,
name|query
operator|->
name|progress_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|shard_size
operator|&&
operator|(
name|revision
operator|%
literal|1000
operator|==
literal|0
operator|)
condition|)
name|query
operator|->
name|progress_func
argument_list|(
name|revision
argument_list|,
name|query
operator|->
name|progress_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given the unparsed changes list in CHANGES with LEN chars, return the  * number of changed paths encoded in it.  Only used in log. addressing  * mode.  */
end_comment

begin_function
specifier|static
name|apr_uint64_t
name|get_log_change_count
parameter_list|(
specifier|const
name|char
modifier|*
name|changes
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|apr_size_t
name|lines
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|changes
operator|+
name|len
decl_stmt|;
comment|/* line count */
for|for
control|(
init|;
name|changes
operator|<
name|end
condition|;
operator|++
name|changes
control|)
if|if
condition|(
operator|*
name|changes
operator|==
literal|'\n'
condition|)
operator|++
name|lines
expr_stmt|;
comment|/* two lines per change */
return|return
name|lines
operator|/
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Read the item described by ENTRY from the REV_FILE and return the  * respective byte sequence in *CONTENTS, allocated in RESULT_POOL.  * Use SCRATCH_POOL for temporary allocations  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_item
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|item
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|entry
operator|->
name|size
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|item
operator|->
name|len
operator|=
name|entry
operator|->
name|size
expr_stmt|;
name|item
operator|->
name|data
index|[
name|item
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|rev_file
operator|->
name|block_size
argument_list|,
name|NULL
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|item
operator|->
name|data
argument_list|,
name|item
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|item
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Process the logically addressed revision contents of revisions BASE to  * BASE + COUNT - 1 in QUERY.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_log_rev_or_packfile
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|svn_revnum_t
name|base
parameter_list|,
name|int
name|count
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|query
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_off_t
name|max_offset
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
comment|/* we will process every revision in the rev / pack file */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
comment|/* create the revision info for the current rev */
name|revision_info_t
modifier|*
name|info
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|->
name|representations
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_stats_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|revision
operator|=
name|base
operator|+
name|i
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
name|revision_info_t
operator|*
argument_list|)
operator|=
name|info
expr_stmt|;
block|}
comment|/* open the pack / rev file that is covered by the p2l index */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|base
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_get_max_offset
argument_list|(
operator|&
name|max_offset
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|rev_file
argument_list|,
name|base
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* record the whole pack size in the first rev so the total sum will      still be correct */
name|APR_ARRAY_IDX
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
name|base
argument_list|,
name|revision_info_t
operator|*
argument_list|)
operator|->
name|end
operator|=
name|max_offset
expr_stmt|;
comment|/* for all offsets in the file, get the P2L index entries and process      the interesting items (change lists, noderevs) */
for|for
control|(
name|offset
operator|=
literal|0
init|;
name|offset
operator|<
name|max_offset
condition|;
control|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* cancellation support */
if|if
condition|(
name|query
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|query
operator|->
name|cancel_func
argument_list|(
name|query
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get all entries for the current block */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|query
operator|->
name|fs
argument_list|,
name|rev_file
argument_list|,
name|base
argument_list|,
name|offset
argument_list|,
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* process all entries (and later continue with the next block) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_fs__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_fs__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* skip bits we previously processed */
if|if
condition|(
name|i
operator|==
literal|0
operator|&&
name|entry
operator|->
name|offset
operator|<
name|offset
condition|)
continue|continue;
comment|/* skip zero-sized entries */
if|if
condition|(
name|entry
operator|->
name|size
operator|==
literal|0
condition|)
continue|continue;
comment|/* read and process interesting items */
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_NODEREV
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|item
decl_stmt|;
name|revision_info_t
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
name|entry
operator|->
name|item
operator|.
name|revision
argument_list|,
name|revision_info_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|item
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_noderev
argument_list|(
name|query
argument_list|,
name|item
argument_list|,
name|info
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_FS__ITEM_TYPE_CHANGES
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|item
decl_stmt|;
name|revision_info_t
modifier|*
name|info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
name|entry
operator|->
name|item
operator|.
name|revision
argument_list|,
name|revision_info_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|item
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|info
operator|->
name|change_count
operator|=
name|get_log_change_count
argument_list|(
name|item
operator|->
name|data
operator|+
literal|0
argument_list|,
name|item
operator|->
name|len
argument_list|)
expr_stmt|;
name|info
operator|->
name|changes_len
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
block|}
comment|/* advance offset */
name|offset
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
block|}
block|}
comment|/* clean up and close file handles */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the content of the pack file staring at revision BASE logical  * addressing mode and store it in QUERY.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_log_pack_file
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|svn_revnum_t
name|base
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|read_log_rev_or_packfile
argument_list|(
name|query
argument_list|,
name|base
argument_list|,
name|query
operator|->
name|shard_size
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* one more pack file processed */
if|if
condition|(
name|query
operator|->
name|progress_func
condition|)
name|query
operator|->
name|progress_func
argument_list|(
name|base
argument_list|,
name|query
operator|->
name|progress_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the content of the file for REVISION in logical addressing mode  * and store its contents in QUERY.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_log_revision_file
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|read_log_rev_or_packfile
argument_list|(
name|query
argument_list|,
name|revision
argument_list|,
literal|1
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* show progress every 1000 revs or so */
if|if
condition|(
name|query
operator|->
name|progress_func
condition|)
block|{
if|if
condition|(
name|query
operator|->
name|shard_size
operator|&&
operator|(
name|revision
operator|%
name|query
operator|->
name|shard_size
operator|==
literal|0
operator|)
condition|)
name|query
operator|->
name|progress_func
argument_list|(
name|revision
argument_list|,
name|query
operator|->
name|progress_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|query
operator|->
name|shard_size
operator|&&
operator|(
name|revision
operator|%
literal|1000
operator|==
literal|0
operator|)
condition|)
name|query
operator|->
name|progress_func
argument_list|(
name|revision
argument_list|,
name|query
operator|->
name|progress_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the repository and collect the stats info in QUERY.  *  * Use RESULT_POOL for persistent allocations and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_revisions
parameter_list|(
name|query_t
modifier|*
name|query
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* read all packed revs */
for|for
control|(
name|revision
operator|=
literal|0
init|;
name|revision
operator|<
name|query
operator|->
name|min_unpacked_rev
condition|;
name|revision
operator|+=
name|query
operator|->
name|shard_size
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|query
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|read_log_pack_file
argument_list|(
name|query
argument_list|,
name|revision
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|read_phys_pack_file
argument_list|(
name|query
argument_list|,
name|revision
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* read non-packed revs */
for|for
control|(
init|;
name|revision
operator|<=
name|query
operator|->
name|head
condition|;
operator|++
name|revision
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_fs__use_log_addressing
argument_list|(
name|query
operator|->
name|fs
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|read_log_revision_file
argument_list|(
name|query
argument_list|,
name|revision
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|read_phys_revision_file
argument_list|(
name|query
argument_list|,
name|revision
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Accumulate stats of REP in STATS.  */
end_comment

begin_function
specifier|static
name|void
name|add_rep_pack_stats
parameter_list|(
name|svn_fs_fs__rep_pack_stats_t
modifier|*
name|stats
parameter_list|,
name|rep_stats_t
modifier|*
name|rep
parameter_list|)
block|{
name|stats
operator|->
name|count
operator|++
expr_stmt|;
name|stats
operator|->
name|packed_size
operator|+=
name|rep
operator|->
name|size
expr_stmt|;
name|stats
operator|->
name|expanded_size
operator|+=
name|rep
operator|->
name|expanded_size
expr_stmt|;
name|stats
operator|->
name|overhead_size
operator|+=
name|rep
operator|->
name|header_size
operator|+
literal|7
comment|/* ENDREP\n */
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Accumulate stats of REP in STATS.  */
end_comment

begin_function
specifier|static
name|void
name|add_rep_stats
parameter_list|(
name|svn_fs_fs__representation_stats_t
modifier|*
name|stats
parameter_list|,
name|rep_stats_t
modifier|*
name|rep
parameter_list|)
block|{
name|add_rep_pack_stats
argument_list|(
operator|&
name|stats
operator|->
name|total
argument_list|,
name|rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|ref_count
operator|==
literal|1
condition|)
name|add_rep_pack_stats
argument_list|(
operator|&
name|stats
operator|->
name|uniques
argument_list|,
name|rep
argument_list|)
expr_stmt|;
else|else
name|add_rep_pack_stats
argument_list|(
operator|&
name|stats
operator|->
name|shared
argument_list|,
name|rep
argument_list|)
expr_stmt|;
name|stats
operator|->
name|references
operator|+=
name|rep
operator|->
name|ref_count
expr_stmt|;
name|stats
operator|->
name|expanded_size
operator|+=
name|rep
operator|->
name|ref_count
operator|*
name|rep
operator|->
name|expanded_size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Aggregate the info the in revision_info_t * array REVISIONS into the  * respectve fields of STATS.  */
end_comment

begin_function
specifier|static
name|void
name|aggregate_stats
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|revisions
parameter_list|,
name|svn_fs_fs__stats_t
modifier|*
name|stats
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* aggregate info from all revisions */
name|stats
operator|->
name|revision_count
operator|=
name|revisions
operator|->
name|nelts
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revisions
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|revision_info_t
modifier|*
name|revision
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revisions
argument_list|,
name|i
argument_list|,
name|revision_info_t
operator|*
argument_list|)
decl_stmt|;
comment|/* data gathered on a revision level */
name|stats
operator|->
name|change_count
operator|+=
name|revision
operator|->
name|change_count
expr_stmt|;
name|stats
operator|->
name|change_len
operator|+=
name|revision
operator|->
name|changes_len
expr_stmt|;
name|stats
operator|->
name|total_size
operator|+=
name|revision
operator|->
name|end
operator|-
name|revision
operator|->
name|offset
expr_stmt|;
name|stats
operator|->
name|dir_node_stats
operator|.
name|count
operator|+=
name|revision
operator|->
name|dir_noderev_count
expr_stmt|;
name|stats
operator|->
name|dir_node_stats
operator|.
name|size
operator|+=
name|revision
operator|->
name|dir_noderev_size
expr_stmt|;
name|stats
operator|->
name|file_node_stats
operator|.
name|count
operator|+=
name|revision
operator|->
name|file_noderev_count
expr_stmt|;
name|stats
operator|->
name|file_node_stats
operator|.
name|size
operator|+=
name|revision
operator|->
name|file_noderev_size
expr_stmt|;
name|stats
operator|->
name|total_node_stats
operator|.
name|count
operator|+=
name|revision
operator|->
name|dir_noderev_count
operator|+
name|revision
operator|->
name|file_noderev_count
expr_stmt|;
name|stats
operator|->
name|total_node_stats
operator|.
name|size
operator|+=
name|revision
operator|->
name|dir_noderev_size
operator|+
name|revision
operator|->
name|file_noderev_size
expr_stmt|;
comment|/* process representations */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|revision
operator|->
name|representations
operator|->
name|nelts
condition|;
operator|++
name|k
control|)
block|{
name|rep_stats_t
modifier|*
name|rep
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revision
operator|->
name|representations
argument_list|,
name|k
argument_list|,
name|rep_stats_t
operator|*
argument_list|)
decl_stmt|;
comment|/* accumulate in the right bucket */
switch|switch
condition|(
name|rep
operator|->
name|kind
condition|)
block|{
case|case
name|file_rep
case|:
name|add_rep_stats
argument_list|(
operator|&
name|stats
operator|->
name|file_rep_stats
argument_list|,
name|rep
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_rep
case|:
name|add_rep_stats
argument_list|(
operator|&
name|stats
operator|->
name|dir_rep_stats
argument_list|,
name|rep
argument_list|)
expr_stmt|;
break|break;
case|case
name|file_property_rep
case|:
name|add_rep_stats
argument_list|(
operator|&
name|stats
operator|->
name|file_prop_rep_stats
argument_list|,
name|rep
argument_list|)
expr_stmt|;
break|break;
case|case
name|dir_property_rep
case|:
name|add_rep_stats
argument_list|(
operator|&
name|stats
operator|->
name|dir_prop_rep_stats
argument_list|,
name|rep
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
name|add_rep_stats
argument_list|(
operator|&
name|stats
operator|->
name|total_rep_stats
argument_list|,
name|rep
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Return a new svn_fs_fs__stats_t instance, allocated in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_fs__stats_t
modifier|*
name|create_stats
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_fs__stats_t
modifier|*
name|stats
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stats
argument_list|)
argument_list|)
decl_stmt|;
name|initialize_largest_changes
argument_list|(
name|stats
argument_list|,
literal|64
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|stats
operator|->
name|by_extension
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|stats
return|;
block|}
end_function

begin_comment
comment|/* Create a *QUERY, allocated in RESULT_POOL, reading filesystem FS and  * collecting results in STATS.  Store the optional PROCESS_FUNC and  * PROGRESS_BATON as well as CANCEL_FUNC and CANCEL_BATON in *QUERY, too.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_query
parameter_list|(
name|query_t
modifier|*
modifier|*
name|query
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_fs__stats_t
modifier|*
name|stats
parameter_list|,
name|svn_fs_progress_notify_func_t
name|progress_func
parameter_list|,
name|void
modifier|*
name|progress_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|query
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|query
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read repository dimensions. */
operator|(
operator|*
name|query
operator|)
operator|->
name|shard_size
operator|=
name|svn_fs_fs__shard_size
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
operator|(
operator|*
name|query
operator|)
operator|->
name|head
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__min_unpacked_rev
argument_list|(
operator|&
operator|(
operator|*
name|query
operator|)
operator|->
name|min_unpacked_rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create data containers and caches    * Note: this assumes that int is at least 32-bits and that we only support    * 32-bit wide revision numbers (actually 31-bits due to the signedness    * of both the nelts field of the array and our revision numbers). This    * means this code will fail on platforms where int is less than 32-bits    * and the repository has more revisions than int can hold. */
operator|(
operator|*
name|query
operator|)
operator|->
name|revisions
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|query
argument_list|)
operator|->
name|head
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|revision_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|query
operator|)
operator|->
name|null_base
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
operator|*
name|query
operator|)
operator|->
name|null_base
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store other parameters */
operator|(
operator|*
name|query
operator|)
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
operator|(
operator|*
name|query
operator|)
operator|->
name|stats
operator|=
name|stats
expr_stmt|;
operator|(
operator|*
name|query
operator|)
operator|->
name|progress_func
operator|=
name|progress_func
expr_stmt|;
operator|(
operator|*
name|query
operator|)
operator|->
name|progress_baton
operator|=
name|progress_baton
expr_stmt|;
operator|(
operator|*
name|query
operator|)
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
operator|(
operator|*
name|query
operator|)
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_stats
parameter_list|(
name|svn_fs_fs__stats_t
modifier|*
modifier|*
name|stats
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_progress_notify_func_t
name|progress_func
parameter_list|,
name|void
modifier|*
name|progress_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|query_t
modifier|*
name|query
decl_stmt|;
operator|*
name|stats
operator|=
name|create_stats
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|create_query
argument_list|(
operator|&
name|query
argument_list|,
name|fs
argument_list|,
operator|*
name|stats
argument_list|,
name|progress_func
argument_list|,
name|progress_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_revisions
argument_list|(
name|query
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|aggregate_stats
argument_list|(
name|query
operator|->
name|revisions
argument_list|,
operator|*
name|stats
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

