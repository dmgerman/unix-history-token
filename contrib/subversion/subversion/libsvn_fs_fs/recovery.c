begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* recovery.c --- FSFS recovery functionality *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"recovery.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Part of the recovery procedure.  Return the largest revision *REV in    filesystem FS.  Use POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_get_largest_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Discovering the largest revision in the filesystem would be an      expensive operation if we did a readdir() or searched linearly,      so we'll do a form of binary search.  left is a revision that we      know exists, right a revision that we know does not exist. */
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_revnum_t
name|left
decl_stmt|,
name|right
init|=
literal|1
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Keep doubling right, until we find a revision that doesn't exist. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|file
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|right
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|right
operator|<<=
literal|1
expr_stmt|;
block|}
name|left
operator|=
name|right
operator|>>
literal|1
expr_stmt|;
comment|/* We know that left exists and right doesn't.  Do a normal bsearch to find      the last revision. */
while|while
condition|(
name|left
operator|+
literal|1
operator|<
name|right
condition|)
block|{
name|svn_revnum_t
name|probe
init|=
name|left
operator|+
operator|(
operator|(
name|right
operator|-
name|left
operator|)
operator|/
literal|2
operator|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_fs__revision_file_t
modifier|*
name|file
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|probe
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|right
operator|=
name|probe
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|left
operator|=
name|probe
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* left is now the largest revision that exists. */
operator|*
name|rev
operator|=
name|left
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A baton for reading a fixed amount from an open file.  For    recover_find_max_ids() below. */
end_comment

begin_struct
struct|struct
name|recover_read_from_file_baton
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_off_t
name|remaining
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A stream read handler used by recover_find_max_ids() below.    Read and return at most BATON->REMAINING bytes from the stream,    returning nothing after that to indicate EOF. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_handler_recover
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|recover_read_from_file_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|bytes_to_read
init|=
operator|*
name|len
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|remaining
operator|==
literal|0
condition|)
block|{
comment|/* Return a successful read of zero bytes to signal EOF. */
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|apr_int64_t
operator|)
name|bytes_to_read
operator|>
operator|(
name|apr_int64_t
operator|)
name|b
operator|->
name|remaining
condition|)
name|bytes_to_read
operator|=
operator|(
name|apr_size_t
operator|)
name|b
operator|->
name|remaining
expr_stmt|;
name|b
operator|->
name|remaining
operator|-=
name|bytes_to_read
expr_stmt|;
return|return
name|svn_stream_read_full
argument_list|(
name|b
operator|->
name|stream
argument_list|,
name|buffer
argument_list|,
operator|&
name|bytes_to_read
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Part of the recovery procedure.  Read the directory noderev at offset    OFFSET of file REV_FILE (the revision file of revision REV of    filesystem FS), and set MAX_NODE_ID and MAX_COPY_ID to be the node-id    and copy-id of that node, if greater than the current value stored    in either.  Recurse into any child directories that were modified in    this revision.     MAX_NODE_ID and MAX_COPY_ID must be arrays of at least MAX_KEY_SIZE.     Perform temporary allocation in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_find_max_ids
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_uint64_t
modifier|*
name|max_node_id
parameter_list|,
name|apr_uint64_t
modifier|*
name|max_copy_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_fs__rep_header_t
modifier|*
name|header
decl_stmt|;
name|struct
name|recover_read_from_file_baton
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|baton
operator|.
name|stream
operator|=
name|rev_file
operator|->
name|stream
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_noderev
argument_list|(
operator|&
name|noderev
argument_list|,
name|baton
operator|.
name|stream
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that this is a directory.  It should be. */
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Recovery encountered a non-directory node"
argument_list|)
argument_list|)
return|;
comment|/* Get the data location.  No data location indicates an empty directory. */
if|if
condition|(
operator|!
name|noderev
operator|->
name|data_rep
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the directory's data representation wasn't changed in this revision,      we've already scanned the directory's contents for noderevs, so we don't      need to again.  This will occur if a property is changed on a directory      without changing the directory's contents. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|->
name|revision
operator|!=
name|rev
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We could use get_dir_contents(), but this is much cheaper.  It does      rely on directory entries being stored as PLAIN reps, though. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|noderev
operator|->
name|data_rep
operator|->
name|item_index
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__read_rep_header
argument_list|(
operator|&
name|header
argument_list|,
name|baton
operator|.
name|stream
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|header
operator|->
name|type
operator|!=
name|svn_fs_fs__rep_plain
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Recovery encountered a deltified directory "
literal|"representation"
argument_list|)
argument_list|)
return|;
comment|/* Now create a stream that's allowed to read only as much data as is      stored in the representation.  Note that this is a directory, i.e.      represented using the hash format on disk and can never have 0 length. */
name|baton
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|baton
operator|.
name|remaining
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
condition|?
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
else|:
name|noderev
operator|->
name|data_rep
operator|->
name|size
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
operator|&
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
name|stream
argument_list|,
name|NULL
comment|/* only full read support */
argument_list|,
name|read_handler_recover
argument_list|)
expr_stmt|;
comment|/* Now read the entries from that stream. */
name|entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_hash_read2
argument_list|(
name|entries
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_fs__id_unparse
argument_list|(
name|noderev
operator|->
name|id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_clear
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_quick_wrapf
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"malformed representation for node-revision '%s'"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now check each of the entries in our directory to find new node and      copy ids, and recurse into new subdirectories. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|char
modifier|*
name|str_val
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
specifier|const
name|svn_fs_fs__id_part_t
modifier|*
name|rev_item
decl_stmt|;
name|apr_uint64_t
name|node_id
decl_stmt|,
name|copy_id
decl_stmt|;
name|apr_off_t
name|child_dir_offset
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|path
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|str_val
operator|=
name|apr_pstrdup
argument_list|(
name|iterpool
argument_list|,
name|path
operator|->
name|data
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|str_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|SVN_FS_FS__KIND_FILE
argument_list|)
operator|==
literal|0
condition|)
name|kind
operator|=
name|svn_node_file
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|SVN_FS_FS__KIND_DIR
argument_list|)
operator|==
literal|0
condition|)
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt"
argument_list|)
argument_list|)
return|;
block|}
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|str_val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__id_parse
argument_list|(
operator|&
name|id
argument_list|,
name|str
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rev_item
operator|=
name|svn_fs_fs__id_rev_item
argument_list|(
name|id
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev_item
operator|->
name|revision
operator|!=
name|rev
condition|)
block|{
comment|/* If the node wasn't modified in this revision, we've already              checked the node and copy id. */
continue|continue;
block|}
name|node_id
operator|=
name|svn_fs_fs__id_node_id
argument_list|(
name|id
argument_list|)
operator|->
name|number
expr_stmt|;
name|copy_id
operator|=
name|svn_fs_fs__id_copy_id
argument_list|(
name|id
argument_list|)
operator|->
name|number
expr_stmt|;
if|if
condition|(
name|node_id
operator|>
operator|*
name|max_node_id
condition|)
operator|*
name|max_node_id
operator|=
name|node_id
expr_stmt|;
if|if
condition|(
name|copy_id
operator|>
operator|*
name|max_copy_id
condition|)
operator|*
name|max_copy_id
operator|=
name|copy_id
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__item_offset
argument_list|(
operator|&
name|child_dir_offset
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|rev
argument_list|,
name|NULL
argument_list|,
name|rev_item
operator|->
name|number
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|recover_find_max_ids
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|rev_file
argument_list|,
name|child_dir_offset
argument_list|,
name|max_node_id
argument_list|,
name|max_copy_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Part of the recovery procedure.  Given an open non-packed revision file    REV_FILE for REV, locate the trailer that specifies the offset to the root    node-id and store this offset in *ROOT_OFFSET.  Do temporary allocations in    POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_get_root_offset
parameter_list|(
name|apr_off_t
modifier|*
name|root_offset
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
name|buffer
index|[
literal|64
index|]
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|trailer
decl_stmt|;
name|apr_off_t
name|start
decl_stmt|;
name|apr_off_t
name|end
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|rev_file
operator|->
name|is_packed
argument_list|)
expr_stmt|;
comment|/* We will assume that the last line containing the two offsets (to the root      node-id and to the changed path information) will never be longer than 64      characters. */
name|end
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_END
argument_list|,
operator|&
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|<
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
condition|)
block|{
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|end
expr_stmt|;
name|start
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
name|start
operator|=
name|end
operator|-
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|buffer
argument_list|,
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|trailer
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|buffer
argument_list|,
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__parse_revision_trailer
argument_list|(
name|root_offset
argument_list|,
name|NULL
argument_list|,
name|trailer
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for recover_body below. */
end_comment

begin_struct
struct|struct
name|recover_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The work-horse for svn_fs_fs__recover, called with the FS    write lock.  This implements the svn_fs_fs__with_write_lock()    'body' callback type.  BATON is a 'struct recover_baton *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|recover_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|b
operator|->
name|fs
decl_stmt|;
name|fs_fs_data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|max_rev
decl_stmt|;
name|apr_uint64_t
name|next_node_id
init|=
literal|0
decl_stmt|;
name|apr_uint64_t
name|next_copy_id
init|=
literal|0
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_node_kind_t
name|youngest_revprops_kind
decl_stmt|;
comment|/* The admin may have created a plain copy of this repo before attempting      to recover it (hotcopy may or may not work with corrupted repos).      Bump the instance ID. */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__set_uuid
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|uuid
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to know the largest revision in the filesystem. */
name|SVN_ERR
argument_list|(
name|recover_get_largest_revision
argument_list|(
name|fs
argument_list|,
operator|&
name|max_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the expected youngest revision */
name|SVN_ERR
argument_list|(
name|svn_fs_fs__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Policy note:       Since the revprops file is written after the revs file, the true      maximum available revision is the youngest one for which both are      present.  That's probably the same as the max_rev we just found,      but if it's not, we could, in theory, repeatedly decrement      max_rev until we find a revision that has both a revs and      revprops file, then write db/current with that.       But we choose not to.  If a repository is so corrupt that it's      missing at least one revprops file, we shouldn't assume that the      youngest revision for which both the revs and revprops files are      present is healthy.  In other words, we're willing to recover      from a missing or out-of-date db/current file, because db/current      is truly redundant -- it's basically a cache so we don't have to      find max_rev each time, albeit a cache with unusual semantics,      since it also officially defines when a revision goes live.  But      if we're missing more than the cache, it's time to back out and      let the admin reconstruct things by hand: correctness at that      point may depend on external things like checking a commit email      list, looking in particular working copies, etc.       This policy matches well with a typical naive backup scenario.      Say you're rsyncing your FSFS repository nightly to the same      location.  Once revs and revprops are written, you've got the      maximum rev; if the backup should bomb before db/current is      written, then db/current could stay arbitrarily out-of-date, but      we can still recover.  It's a small window, but we might as well      do what we can. */
comment|/* Even if db/current were missing, it would be created with 0 by      get_youngest(), so this conditional remains valid. */
if|if
condition|(
name|youngest_rev
operator|>
name|max_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected current rev to be<= %ld "
literal|"but found %ld"
argument_list|)
argument_list|,
name|max_rev
argument_list|,
name|youngest_rev
argument_list|)
return|;
comment|/* We only need to search for maximum IDs for old FS formats which      se global ID counters. */
if|if
condition|(
name|ffd
operator|->
name|format
operator|<
name|SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT
condition|)
block|{
comment|/* Next we need to find the maximum node id and copy id in use across the          filesystem.  Unfortunately, the only way we can get this information          is to scan all the noderevs of all the revisions and keep track as          we go along. */
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|rev
operator|=
literal|0
init|;
name|rev
operator|<=
name|max_rev
condition|;
name|rev
operator|++
control|)
block|{
name|svn_fs_fs__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_off_t
name|root_offset
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|b
operator|->
name|cancel_func
argument_list|(
name|b
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|recover_get_root_offset
argument_list|(
operator|&
name|root_offset
argument_list|,
name|rev
argument_list|,
name|rev_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|recover_find_max_ids
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|rev_file
argument_list|,
name|root_offset
argument_list|,
operator|&
name|next_node_id
argument_list|,
operator|&
name|next_copy_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Now that we finally have the maximum revision, node-id and copy-id, we          can bump the two ids to get the next of each. */
name|next_node_id
operator|++
expr_stmt|;
name|next_copy_id
operator|++
expr_stmt|;
block|}
comment|/* Before setting current, verify that there is a revprops file      for the youngest revision.  (Issue #2992) */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|svn_fs_fs__path_revprops
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|&
name|youngest_revprops_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_revprops_kind
operator|==
name|svn_node_none
condition|)
block|{
name|svn_boolean_t
name|missing
init|=
name|TRUE
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fs_fs__packed_revprop_available
argument_list|(
operator|&
name|missing
argument_list|,
name|fs
argument_list|,
name|max_rev
argument_list|,
name|pool
argument_list|)
condition|)
block|{
if|if
condition|(
name|missing
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a revs file but no "
literal|"revprops file"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a revs file but the "
literal|"revprops file is inaccessible"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|youngest_revprops_kind
operator|!=
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a non-file where its "
literal|"revprops file should be"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
comment|/* Prune younger-than-(newfound-youngest) revisions from the rep      cache if sharing is enabled taking care not to create the cache      if it does not exist. */
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
name|svn_boolean_t
name|rep_cache_exists
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__exists_rep_cache
argument_list|(
operator|&
name|rep_cache_exists
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_cache_exists
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_fs__del_rep_reference
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now store the discovered youngest revision, and the next IDs if      relevant, in a new 'current' file. */
return|return
name|svn_fs_fs__write_current
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|next_node_id
argument_list|,
name|next_copy_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the fs_library_vtable_t.recover() API. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__recover
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|recover_baton
name|b
decl_stmt|;
comment|/* We have no way to take out an exclusive lock in FSFS, so we're      restricted as to the types of recovery we can do.  Luckily,      we just want to recreate the 'current' file, and we can do that just      by blocking other writers. */
name|b
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|b
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|svn_fs_fs__with_all_locks
argument_list|(
name|fs
argument_list|,
name|recover_body
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

end_unit

