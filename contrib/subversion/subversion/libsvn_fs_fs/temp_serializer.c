begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* temp_serializer.c: serialization functions for caching of FSFS structures  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_comment
comment|/* Utility to encode a signed NUMBER into a variable-length sequence of  * 8-bit chars in KEY_BUFFER and return the last writen position.  *  * Numbers will be stored in 7 bits / byte and using byte values above  * 32 (' ') to make them combinable with other string by simply separating  * individual parts with spaces.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|encode_number
parameter_list|(
name|apr_int64_t
name|number
parameter_list|,
name|char
modifier|*
name|key_buffer
parameter_list|)
block|{
comment|/* encode the sign in the first byte */
if|if
condition|(
name|number
operator|<
literal|0
condition|)
block|{
name|number
operator|=
operator|-
name|number
expr_stmt|;
operator|*
name|key_buffer
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|number
operator|&
literal|63
operator|)
operator|+
literal|' '
operator|+
literal|65
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|key_buffer
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|number
operator|&
literal|63
operator|)
operator|+
literal|' '
operator|+
literal|1
argument_list|)
expr_stmt|;
name|number
operator|/=
literal|64
expr_stmt|;
comment|/* write 7 bits / byte until no significant bits are left */
while|while
condition|(
name|number
condition|)
block|{
operator|*
operator|++
name|key_buffer
operator|=
call|(
name|char
call|)
argument_list|(
operator|(
name|number
operator|&
literal|127
operator|)
operator|+
literal|' '
operator|+
literal|1
argument_list|)
expr_stmt|;
name|number
operator|/=
literal|128
expr_stmt|;
block|}
comment|/* return the last written position */
return|return
name|key_buffer
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_fs__combine_number_and_string
parameter_list|(
name|apr_int64_t
name|number
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|strlen
argument_list|(
name|string
argument_list|)
decl_stmt|;
comment|/* number part requires max. 10x7 bits + 1 space.    * Add another 1 for the terminal 0 */
name|char
modifier|*
name|key_buffer
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|len
operator|+
literal|12
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
init|=
name|key_buffer
decl_stmt|;
comment|/* Prepend the number to the string and separate them by space. No other    * number can result in the same prefix, no other string in the same    * postfix nor can the boundary between them be ambiguous. */
name|key_buffer
operator|=
name|encode_number
argument_list|(
name|number
argument_list|,
name|key_buffer
argument_list|)
expr_stmt|;
operator|*
operator|++
name|key_buffer
operator|=
literal|' '
expr_stmt|;
name|memcpy
argument_list|(
operator|++
name|key_buffer
argument_list|,
name|string
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* return the start of the key */
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize string S in the given serialization CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|serialize_svn_string
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|s
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|string
init|=
operator|*
name|s
decl_stmt|;
comment|/* Nothing to do for NULL string references. */
if|if
condition|(
name|string
operator|==
name|NULL
condition|)
return|return;
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|s
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|string
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the "string" content may actually be arbitrary binary data.    * Thus, we cannot use svn_temp_serializer__add_string. */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|string
operator|->
name|data
argument_list|,
name|string
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* back to the caller's nesting level */
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to deserialize the STRING inside the BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|deserialize_svn_string
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|string
parameter_list|)
block|{
name|svn_temp_deserializer__resolve
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|string
operator|==
name|NULL
condition|)
return|return;
name|svn_temp_deserializer__resolve
argument_list|(
operator|*
name|string
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|string
operator|)
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize checkum CS within the given serialization  * CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|serialize_checksum
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|svn_checksum_t
modifier|*
specifier|const
modifier|*
name|cs
parameter_list|)
block|{
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
init|=
operator|*
name|cs
decl_stmt|;
if|if
condition|(
name|checksum
operator|==
name|NULL
condition|)
return|return;
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|cs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The digest is arbitrary binary data.    * Thus, we cannot use svn_temp_serializer__add_string. */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|checksum
operator|->
name|digest
argument_list|,
name|svn_checksum_size
argument_list|(
name|checksum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return to the caller's nesting level */
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to deserialize the checksum CS inside the BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|deserialize_checksum
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|cs
parameter_list|)
block|{
name|svn_temp_deserializer__resolve
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|cs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cs
operator|==
name|NULL
condition|)
return|return;
name|svn_temp_deserializer__resolve
argument_list|(
operator|*
name|cs
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|cs
operator|)
operator|->
name|digest
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize the REPRESENTATION within the given  * serialization CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|serialize_representation
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|representation_t
modifier|*
specifier|const
modifier|*
name|representation
parameter_list|)
block|{
specifier|const
name|representation_t
modifier|*
name|rep
init|=
operator|*
name|representation
decl_stmt|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
return|return;
comment|/* serialize the representation struct itself */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|representation
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize sub-structures */
name|serialize_checksum
argument_list|(
name|context
argument_list|,
operator|&
name|rep
operator|->
name|md5_checksum
argument_list|)
expr_stmt|;
name|serialize_checksum
argument_list|(
name|context
argument_list|,
operator|&
name|rep
operator|->
name|sha1_checksum
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|rep
operator|->
name|uniquifier
argument_list|)
expr_stmt|;
comment|/* return to the caller's nesting level */
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to deserialize the REPRESENTATIONS inside the BUFFER.  */
end_comment

begin_function
specifier|static
name|void
name|deserialize_representation
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|representation_t
modifier|*
modifier|*
name|representation
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
comment|/* fixup the reference to the representation itself */
name|svn_temp_deserializer__resolve
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|representation
argument_list|)
expr_stmt|;
name|rep
operator|=
operator|*
name|representation
expr_stmt|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
return|return;
comment|/* fixup of sub-structures */
name|deserialize_checksum
argument_list|(
name|rep
argument_list|,
operator|&
name|rep
operator|->
name|md5_checksum
argument_list|)
expr_stmt|;
name|deserialize_checksum
argument_list|(
name|rep
argument_list|,
operator|&
name|rep
operator|->
name|sha1_checksum
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|rep
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rep
operator|->
name|txn_id
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|rep
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rep
operator|->
name|uniquifier
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* auxilliary structure representing the content of a directory hash */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|hash_data_t
block|{
comment|/* number of entries in the directory */
name|apr_size_t
name|count
decl_stmt|;
comment|/* number of unused dir entry buckets in the index */
name|apr_size_t
name|over_provision
decl_stmt|;
comment|/* internal modifying operations counter    * (used to repack data once in a while) */
name|apr_size_t
name|operations
decl_stmt|;
comment|/* size of the serialization buffer actually used.    * (we will allocate more than we actually need such that we may    * append more data in situ later) */
name|apr_size_t
name|len
decl_stmt|;
comment|/* reference to the entries */
name|svn_fs_dirent_t
modifier|*
modifier|*
name|entries
decl_stmt|;
comment|/* size of the serialized entries and don't be too wasteful    * (needed since the entries are no longer in sequence) */
name|apr_uint32_t
modifier|*
name|lengths
decl_stmt|;
block|}
name|hash_data_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|compare_dirent_id_names
parameter_list|(
specifier|const
name|void
modifier|*
name|lhs
parameter_list|,
specifier|const
name|void
modifier|*
name|rhs
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|(
operator|*
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
specifier|const
operator|*
operator|)
name|lhs
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
specifier|const
operator|*
operator|)
name|rhs
operator|)
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize the *ENTRY_P into a the given  * serialization CONTEXT. Return the serialized size of the  * dir entry in *LENGTH.  */
end_comment

begin_function
specifier|static
name|void
name|serialize_dir_entry
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_dirent_t
modifier|*
modifier|*
name|entry_p
parameter_list|,
name|apr_uint32_t
modifier|*
name|length
parameter_list|)
block|{
name|svn_fs_dirent_t
modifier|*
name|entry
init|=
operator|*
name|entry_p
decl_stmt|;
name|apr_size_t
name|initial_length
init|=
name|svn_temp_serializer__get_length
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|entry_p
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_dirent_t
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_fs__id_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|entry
operator|->
name|id
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
operator|*
name|length
operator|=
call|(
name|apr_uint32_t
call|)
argument_list|(
name|svn_temp_serializer__get_length
argument_list|(
name|context
argument_list|)
operator|-
name|APR_ALIGN_DEFAULT
argument_list|(
name|initial_length
argument_list|)
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize the ENTRIES into a new serialization  * context to be returned. Allocation will be made form POOL.  */
end_comment

begin_function
specifier|static
name|svn_temp_serializer__context_t
modifier|*
name|serialize_dir
parameter_list|(
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|hash_data_t
name|hash_data
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_size_t
name|i
init|=
literal|0
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
comment|/* calculate sizes */
name|apr_size_t
name|count
init|=
name|apr_hash_count
argument_list|(
name|entries
argument_list|)
decl_stmt|;
name|apr_size_t
name|over_provision
init|=
literal|2
operator|+
name|count
operator|/
literal|4
decl_stmt|;
name|apr_size_t
name|entries_len
init|=
operator|(
name|count
operator|+
name|over_provision
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|svn_fs_dirent_t
operator|*
argument_list|)
decl_stmt|;
name|apr_size_t
name|lengths_len
init|=
operator|(
name|count
operator|+
name|over_provision
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
decl_stmt|;
comment|/* copy the hash entries to an auxilliary struct of known layout */
name|hash_data
operator|.
name|count
operator|=
name|count
expr_stmt|;
name|hash_data
operator|.
name|over_provision
operator|=
name|over_provision
expr_stmt|;
name|hash_data
operator|.
name|operations
operator|=
literal|0
expr_stmt|;
name|hash_data
operator|.
name|entries
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|entries_len
argument_list|)
expr_stmt|;
name|hash_data
operator|.
name|lengths
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|lengths_len
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
operator|,
operator|++
name|i
control|)
name|hash_data
operator|.
name|entries
index|[
name|i
index|]
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
comment|/* sort entry index by ID name */
name|qsort
argument_list|(
name|hash_data
operator|.
name|entries
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hash_data
operator|.
name|entries
argument_list|)
argument_list|,
name|compare_dirent_id_names
argument_list|)
expr_stmt|;
comment|/* Serialize that aux. structure into a new one. Also, provide a good    * estimate for the size of the buffer that we will need. */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
operator|&
name|hash_data
argument_list|,
sizeof|sizeof
argument_list|(
name|hash_data
argument_list|)
argument_list|,
literal|50
operator|+
name|count
operator|*
literal|200
operator|+
name|entries_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* serialize entries references */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|hash_data
operator|.
name|entries
argument_list|,
name|entries_len
argument_list|)
expr_stmt|;
comment|/* serialize the individual entries and their sub-structures */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|serialize_dir_entry
argument_list|(
name|context
argument_list|,
operator|&
name|hash_data
operator|.
name|entries
index|[
name|i
index|]
argument_list|,
operator|&
name|hash_data
operator|.
name|lengths
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* serialize entries references */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|hash_data
operator|.
name|lengths
argument_list|,
name|lengths_len
argument_list|)
expr_stmt|;
return|return
name|context
return|;
block|}
end_function

begin_comment
comment|/* Utility function to reconstruct a dir entries hash from serialized data  * in BUFFER and HASH_DATA. Allocation will be made form POOL.  */
end_comment

begin_function
specifier|static
name|apr_hash_t
modifier|*
name|deserialize_dir
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|hash_data_t
modifier|*
name|hash_data
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|result
init|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|count
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|entry
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
modifier|*
name|entries
decl_stmt|;
comment|/* resolve the reference to the entries array */
name|svn_temp_deserializer__resolve
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|hash_data
operator|->
name|entries
argument_list|)
expr_stmt|;
name|entries
operator|=
name|hash_data
operator|->
name|entries
expr_stmt|;
comment|/* fixup the references within each entry and add it to the hash */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|count
operator|=
name|hash_data
operator|->
name|count
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|svn_temp_deserializer__resolve
argument_list|(
name|entries
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|entry
operator|=
name|hash_data
operator|->
name|entries
index|[
name|i
index|]
expr_stmt|;
comment|/* pointer fixup */
name|svn_temp_deserializer__resolve
argument_list|(
name|entry
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|svn_fs_fs__id_deserialize
argument_list|(
name|entry
argument_list|,
operator|(
name|svn_fs_id_t
operator|*
operator|*
operator|)
operator|&
name|entry
operator|->
name|id
argument_list|)
expr_stmt|;
comment|/* add the entry to the hash */
name|svn_hash_sets
argument_list|(
name|result
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
comment|/* return the now complete hash */
return|return
name|result
return|;
block|}
end_function

begin_function
name|void
name|svn_fs_fs__noderev_serialize
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|node_revision_t
modifier|*
specifier|const
modifier|*
name|noderev_p
parameter_list|)
block|{
specifier|const
name|node_revision_t
modifier|*
name|noderev
init|=
operator|*
name|noderev_p
decl_stmt|;
if|if
condition|(
name|noderev
operator|==
name|NULL
condition|)
return|return;
comment|/* serialize the representation struct itself */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|noderev_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize sub-structures */
name|svn_fs_fs__id_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|svn_fs_fs__id_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
operator|->
name|predecessor_id
argument_list|)
expr_stmt|;
name|serialize_representation
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
operator|->
name|prop_rep
argument_list|)
expr_stmt|;
name|serialize_representation
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
operator|->
name|data_rep
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
comment|/* return to the caller's nesting level */
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_fs_fs__noderev_deserialize
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* fixup the reference to the representation itself,    * if this is part of a parent structure. */
if|if
condition|(
name|buffer
operator|!=
operator|*
name|noderev_p
condition|)
name|svn_temp_deserializer__resolve
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|noderev_p
argument_list|)
expr_stmt|;
name|noderev
operator|=
operator|*
name|noderev_p
expr_stmt|;
if|if
condition|(
name|noderev
operator|==
name|NULL
condition|)
return|return;
comment|/* fixup of sub-structures */
name|svn_fs_fs__id_deserialize
argument_list|(
name|noderev
argument_list|,
operator|(
name|svn_fs_id_t
operator|*
operator|*
operator|)
operator|&
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|svn_fs_fs__id_deserialize
argument_list|(
name|noderev
argument_list|,
operator|(
name|svn_fs_id_t
operator|*
operator|*
operator|)
operator|&
name|noderev
operator|->
name|predecessor_id
argument_list|)
expr_stmt|;
name|deserialize_representation
argument_list|(
name|noderev
argument_list|,
operator|&
name|noderev
operator|->
name|prop_rep
argument_list|)
expr_stmt|;
name|deserialize_representation
argument_list|(
name|noderev
argument_list|,
operator|&
name|noderev
operator|->
name|data_rep
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|noderev
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|noderev
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|noderev
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|noderev
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize COUNT svn_txdelta_op_t objects  * at OPS in the given serialization CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|serialize_txdelta_ops
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|svn_txdelta_op_t
modifier|*
specifier|const
modifier|*
name|ops
parameter_list|,
name|apr_size_t
name|count
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ops
operator|==
name|NULL
condition|)
return|return;
comment|/* the ops form a contiguous chunk of memory with no further references */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|ops
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
name|svn_txdelta_op_t
argument_list|)
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize W in the given serialization CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|serialize_txdeltawindow
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|svn_txdelta_window_t
modifier|*
specifier|const
modifier|*
name|w
parameter_list|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
init|=
operator|*
name|w
decl_stmt|;
comment|/* serialize the window struct itself */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|w
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_txdelta_window_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize its sub-structures */
name|serialize_txdelta_ops
argument_list|(
name|context
argument_list|,
operator|&
name|window
operator|->
name|ops
argument_list|,
name|window
operator|->
name|num_ops
argument_list|)
expr_stmt|;
name|serialize_svn_string
argument_list|(
name|context
argument_list|,
operator|&
name|window
operator|->
name|new_data
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_txdelta_window
parameter_list|(
name|void
modifier|*
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|buffer_size
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_fs__txdelta_cached_window_t
modifier|*
name|window_info
init|=
name|item
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
comment|/* initialize the serialization process and allocate a buffer large    * enough to do without the need of re-allocations in most cases. */
name|apr_size_t
name|text_len
init|=
name|window_info
operator|->
name|window
operator|->
name|new_data
condition|?
name|window_info
operator|->
name|window
operator|->
name|new_data
operator|->
name|len
else|:
literal|0
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|svn_temp_serializer__init
argument_list|(
name|window_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|window_info
argument_list|)
argument_list|,
literal|500
operator|+
name|text_len
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* serialize the sub-structure(s) */
name|serialize_txdeltawindow
argument_list|(
name|context
argument_list|,
operator|&
name|window_info
operator|->
name|window
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|buffer_size
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_txdelta_window
parameter_list|(
name|void
modifier|*
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
name|buffer_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
comment|/* Copy the _full_ buffer as it also contains the sub-structures. */
name|svn_fs_fs__txdelta_cached_window_t
modifier|*
name|window_info
init|=
operator|(
name|svn_fs_fs__txdelta_cached_window_t
operator|*
operator|)
name|buffer
decl_stmt|;
comment|/* pointer reference fixup */
name|svn_temp_deserializer__resolve
argument_list|(
name|window_info
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|window_info
operator|->
name|window
argument_list|)
expr_stmt|;
name|window
operator|=
name|window_info
operator|->
name|window
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|window
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|window
operator|->
name|ops
argument_list|)
expr_stmt|;
name|deserialize_svn_string
argument_list|(
name|window
argument_list|,
operator|(
name|svn_string_t
operator|*
operator|*
operator|)
operator|&
name|window
operator|->
name|new_data
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|item
operator|=
name|window_info
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_manifest
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|manifest
init|=
name|in
decl_stmt|;
operator|*
name|data_len
operator|=
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
operator|*
name|manifest
operator|->
name|nelts
expr_stmt|;
operator|*
name|data
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
operator|*
name|data_len
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|*
name|data
argument_list|,
name|manifest
operator|->
name|elts
argument_list|,
operator|*
name|data_len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_manifest
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|manifest
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
decl_stmt|;
name|manifest
operator|->
name|nelts
operator|=
call|(
name|int
call|)
argument_list|(
name|data_len
operator|/
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|manifest
operator|->
name|nalloc
operator|=
call|(
name|int
call|)
argument_list|(
name|data_len
operator|/
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|manifest
operator|->
name|elts
operator|=
operator|(
name|char
operator|*
operator|)
name|data
expr_stmt|;
operator|*
name|out
operator|=
name|manifest
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Auxilliary structure representing the content of a properties hash.    This structure is much easier to (de-)serialize than an apr_hash.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|properties_data_t
block|{
comment|/* number of entries in the hash */
name|apr_size_t
name|count
decl_stmt|;
comment|/* reference to the keys */
specifier|const
name|char
modifier|*
modifier|*
name|keys
decl_stmt|;
comment|/* reference to the values */
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|values
decl_stmt|;
block|}
name|properties_data_t
typedef|;
end_typedef

begin_comment
comment|/* Serialize COUNT C-style strings from *STRINGS into CONTEXT. */
end_comment

begin_function
specifier|static
name|void
name|serialize_cstring_array
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|strings
parameter_list|,
name|apr_size_t
name|count
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|entries
init|=
operator|*
name|strings
decl_stmt|;
comment|/* serialize COUNT entries pointers (the array) */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|strings
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize array elements */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Serialize COUNT svn_string_t* items from *STRINGS into CONTEXT. */
end_comment

begin_function
specifier|static
name|void
name|serialize_svn_string_array
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
modifier|*
name|strings
parameter_list|,
name|apr_size_t
name|count
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|entries
init|=
operator|*
name|strings
decl_stmt|;
comment|/* serialize COUNT entries pointers (the array) */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|strings
argument_list|,
name|count
operator|*
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize array elements */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
name|serialize_svn_string
argument_list|(
name|context
argument_list|,
operator|&
name|entries
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_properties
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|hash
init|=
name|in
decl_stmt|;
name|properties_data_t
name|properties
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
comment|/* create our auxilliary data structure */
name|properties
operator|.
name|count
operator|=
name|apr_hash_count
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|properties
operator|.
name|keys
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
operator|(
name|properties
operator|.
name|count
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|properties
operator|.
name|values
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
operator|*
name|properties
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* populate it with the hash entries */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|hash
argument_list|)
operator|,
name|i
operator|=
literal|0
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|properties
operator|.
name|keys
index|[
name|i
index|]
operator|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|properties
operator|.
name|values
index|[
name|i
index|]
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
comment|/* serialize it */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
operator|&
name|properties
argument_list|,
sizeof|sizeof
argument_list|(
name|properties
argument_list|)
argument_list|,
name|properties
operator|.
name|count
operator|*
literal|100
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|properties
operator|.
name|keys
index|[
name|i
index|]
operator|=
literal|""
expr_stmt|;
name|serialize_cstring_array
argument_list|(
name|context
argument_list|,
operator|&
name|properties
operator|.
name|keys
argument_list|,
name|properties
operator|.
name|count
operator|+
literal|1
argument_list|)
expr_stmt|;
name|serialize_svn_string_array
argument_list|(
name|context
argument_list|,
operator|&
name|properties
operator|.
name|values
argument_list|,
name|properties
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_properties
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|hash
init|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|properties_data_t
modifier|*
name|properties
init|=
operator|(
name|properties_data_t
operator|*
operator|)
name|data
decl_stmt|;
name|size_t
name|i
decl_stmt|;
comment|/* de-serialize our auxilliary data structure */
name|svn_temp_deserializer__resolve
argument_list|(
name|properties
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|properties
operator|->
name|keys
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|properties
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|properties
operator|->
name|values
argument_list|)
expr_stmt|;
comment|/* de-serialize each entry and put it into the hash */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|properties
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
name|apr_size_t
name|len
init|=
name|properties
operator|->
name|keys
index|[
name|i
operator|+
literal|1
index|]
operator|-
name|properties
operator|->
name|keys
index|[
name|i
index|]
operator|-
literal|1
decl_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
operator|(
name|void
operator|*
operator|)
name|properties
operator|->
name|keys
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|properties
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|deserialize_svn_string
argument_list|(
operator|(
name|void
operator|*
operator|)
name|properties
operator|->
name|values
argument_list|,
operator|(
name|svn_string_t
operator|*
operator|*
operator|)
operator|&
name|properties
operator|->
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|properties
operator|->
name|keys
index|[
name|i
index|]
argument_list|,
name|len
argument_list|,
name|properties
operator|->
name|values
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* done */
operator|*
name|out
operator|=
name|hash
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_id
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
init|=
name|in
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
comment|/* create an (empty) serialization context with plenty of buffer space */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|svn_temp_serializer__init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|250
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* serialize the id */
name|svn_fs_fs__id_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* return serialized data */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_id
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Copy the _full_ buffer as it also contains the sub-structures. */
name|svn_fs_id_t
modifier|*
name|id
init|=
operator|(
name|svn_fs_id_t
operator|*
operator|)
name|data
decl_stmt|;
comment|/* fixup of all pointers etc. */
name|svn_fs_fs__id_deserialize
argument_list|(
name|id
argument_list|,
operator|&
name|id
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|out
operator|=
name|id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Caching node_revision_t objects. **/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_node_revision
parameter_list|(
name|void
modifier|*
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|buffer_size
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|node_revision_t
modifier|*
name|noderev
init|=
name|item
decl_stmt|;
comment|/* create an (empty) serialization context with plenty of (initial)    * buffer space. */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|svn_temp_serializer__init
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|1024
operator|-
name|SVN_TEMP_SERIALIZER__OVERHEAD
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* serialize the noderev */
name|svn_fs_fs__noderev_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|noderev
argument_list|)
expr_stmt|;
comment|/* return serialized data */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|buffer_size
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_node_revision
parameter_list|(
name|void
modifier|*
modifier|*
name|item
parameter_list|,
name|void
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
name|buffer_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Copy the _full_ buffer as it also contains the sub-structures. */
name|node_revision_t
modifier|*
name|noderev
init|=
operator|(
name|node_revision_t
operator|*
operator|)
name|buffer
decl_stmt|;
comment|/* fixup of all pointers etc. */
name|svn_fs_fs__noderev_deserialize
argument_list|(
name|noderev
argument_list|,
operator|&
name|noderev
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|item
operator|=
name|noderev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function that returns the directory serialized inside CONTEXT  * to DATA and DATA_LEN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|return_serialized_dir_context
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|serialized
init|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
decl_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|blocksize
expr_stmt|;
operator|(
operator|(
name|hash_data_t
operator|*
operator|)
name|serialized
operator|->
name|data
operator|)
operator|->
name|len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_dir_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|dir
init|=
name|in
decl_stmt|;
comment|/* serialize the dir content into a new serialization context    * and return the serialized data */
return|return
name|return_serialized_dir_context
argument_list|(
name|serialize_dir
argument_list|(
name|dir
argument_list|,
name|pool
argument_list|)
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_dir_entries
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Copy the _full_ buffer as it also contains the sub-structures. */
name|hash_data_t
modifier|*
name|hash_data
init|=
operator|(
name|hash_data_t
operator|*
operator|)
name|data
decl_stmt|;
comment|/* reconstruct the hash from the serialized data */
operator|*
name|out
operator|=
name|deserialize_dir
argument_list|(
name|hash_data
argument_list|,
name|hash_data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__get_sharded_offset
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|apr_off_t
modifier|*
name|manifest
init|=
name|data
decl_stmt|;
name|apr_int64_t
name|shard_pos
init|=
operator|*
operator|(
name|apr_int64_t
operator|*
operator|)
name|baton
decl_stmt|;
operator|*
operator|(
name|apr_off_t
operator|*
operator|)
name|out
operator|=
name|manifest
index|[
name|shard_pos
index|]
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function that returns the lowest index of the first entry in  * *ENTRIES that points to a dir entry with a name equal or larger than NAME.  * If an exact match has been found, *FOUND will be set to TRUE. COUNT is  * the number of valid entries in ENTRIES.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|find_entry
parameter_list|(
name|svn_fs_dirent_t
modifier|*
modifier|*
name|entries
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_size_t
name|count
parameter_list|,
name|svn_boolean_t
modifier|*
name|found
parameter_list|)
block|{
comment|/* binary search for the desired entry by name */
name|apr_size_t
name|lower
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|upper
init|=
name|count
decl_stmt|;
name|apr_size_t
name|middle
decl_stmt|;
for|for
control|(
name|middle
operator|=
name|upper
operator|/
literal|2
init|;
name|lower
operator|<
name|upper
condition|;
name|middle
operator|=
operator|(
name|upper
operator|+
name|lower
operator|)
operator|/
literal|2
control|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|entry
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|entries
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|entries
index|[
name|middle
index|]
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_name
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|entry
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|entry
operator|->
name|name
argument_list|)
decl_stmt|;
name|int
name|diff
init|=
name|strcmp
argument_list|(
name|entry_name
argument_list|,
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
name|lower
operator|=
name|middle
operator|+
literal|1
expr_stmt|;
else|else
name|upper
operator|=
name|middle
expr_stmt|;
block|}
comment|/* check whether we actually found a match */
operator|*
name|found
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|lower
operator|<
name|count
condition|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|entry
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|entries
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|entries
index|[
name|lower
index|]
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|entry_name
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|entry
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|entry
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|entry_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|found
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|lower
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__extract_dir_entry
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|hash_data_t
modifier|*
name|hash_data
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|found
decl_stmt|;
comment|/* resolve the reference to the entries array */
specifier|const
name|svn_fs_dirent_t
modifier|*
specifier|const
modifier|*
name|entries
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|data
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|hash_data
operator|->
name|entries
argument_list|)
decl_stmt|;
comment|/* resolve the reference to the lengths array */
specifier|const
name|apr_uint32_t
modifier|*
name|lengths
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|data
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|hash_data
operator|->
name|lengths
argument_list|)
decl_stmt|;
comment|/* binary search for the desired entry by name */
name|apr_size_t
name|pos
init|=
name|find_entry
argument_list|(
operator|(
name|svn_fs_dirent_t
operator|*
operator|*
operator|)
name|entries
argument_list|,
name|name
argument_list|,
name|hash_data
operator|->
name|count
argument_list|,
operator|&
name|found
argument_list|)
decl_stmt|;
comment|/* de-serialize that entry or return NULL, if no match has been found */
operator|*
name|out
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|found
condition|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|source
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|entries
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|entries
index|[
name|pos
index|]
argument_list|)
decl_stmt|;
comment|/* Entries have been serialized one-by-one, each time including all        * nested structures and strings. Therefore, they occupy a single        * block of memory whose end-offset is either the beginning of the        * next entry or the end of the buffer        */
name|apr_size_t
name|size
init|=
name|lengths
index|[
name|pos
index|]
decl_stmt|;
comment|/* copy& deserialize the entry */
name|svn_fs_dirent_t
modifier|*
name|new_entry
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|size
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|new_entry
argument_list|,
name|source
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|new_entry
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|new_entry
operator|->
name|name
argument_list|)
expr_stmt|;
name|svn_fs_fs__id_deserialize
argument_list|(
name|new_entry
argument_list|,
operator|(
name|svn_fs_id_t
operator|*
operator|*
operator|)
operator|&
name|new_entry
operator|->
name|id
argument_list|)
expr_stmt|;
operator|*
operator|(
name|svn_fs_dirent_t
operator|*
operator|*
operator|)
name|out
operator|=
name|new_entry
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function for svn_fs_fs__replace_dir_entry that implements the  * modification as a simply deserialize / modify / serialize sequence.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|slowly_replace_dir_entry
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|replace_baton_t
modifier|*
name|replace_baton
init|=
operator|(
name|replace_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|hash_data_t
modifier|*
name|hash_data
init|=
operator|(
name|hash_data_t
operator|*
operator|)
operator|*
name|data
decl_stmt|;
name|apr_hash_t
modifier|*
name|dir
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_fs__deserialize_dir_entries
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|dir
argument_list|,
operator|*
name|data
argument_list|,
name|hash_data
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|dir
argument_list|,
name|replace_baton
operator|->
name|name
argument_list|,
name|replace_baton
operator|->
name|new_entry
argument_list|)
expr_stmt|;
return|return
name|svn_fs_fs__serialize_dir_entries
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|,
name|dir
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__replace_dir_entry
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|replace_baton_t
modifier|*
name|replace_baton
init|=
operator|(
name|replace_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|hash_data_t
modifier|*
name|hash_data
init|=
operator|(
name|hash_data_t
operator|*
operator|)
operator|*
name|data
decl_stmt|;
name|svn_boolean_t
name|found
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
modifier|*
name|entries
decl_stmt|;
name|apr_uint32_t
modifier|*
name|lengths
decl_stmt|;
name|apr_uint32_t
name|length
decl_stmt|;
name|apr_size_t
name|pos
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
comment|/* after quite a number of operations, let's re-pack everything.    * This is to limit the number of vasted space as we cannot overwrite    * existing data but must always append. */
if|if
condition|(
name|hash_data
operator|->
name|operations
operator|>
literal|2
operator|+
name|hash_data
operator|->
name|count
operator|/
literal|4
condition|)
return|return
name|slowly_replace_dir_entry
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
return|;
comment|/* resolve the reference to the entries array */
name|entries
operator|=
operator|(
name|svn_fs_dirent_t
operator|*
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|hash_data
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|hash_data
operator|->
name|entries
argument_list|)
expr_stmt|;
comment|/* resolve the reference to the lengths array */
name|lengths
operator|=
operator|(
name|apr_uint32_t
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|hash_data
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|hash_data
operator|->
name|lengths
argument_list|)
expr_stmt|;
comment|/* binary search for the desired entry by name */
name|pos
operator|=
name|find_entry
argument_list|(
name|entries
argument_list|,
name|replace_baton
operator|->
name|name
argument_list|,
name|hash_data
operator|->
name|count
argument_list|,
operator|&
name|found
argument_list|)
expr_stmt|;
comment|/* handle entry removal (if found at all) */
if|if
condition|(
name|replace_baton
operator|->
name|new_entry
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|found
condition|)
block|{
comment|/* remove reference to the entry from the index */
name|memmove
argument_list|(
operator|&
name|entries
index|[
name|pos
index|]
argument_list|,
operator|&
name|entries
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|entries
index|[
name|pos
index|]
argument_list|)
operator|*
operator|(
name|hash_data
operator|->
name|count
operator|-
name|pos
operator|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lengths
index|[
name|pos
index|]
argument_list|,
operator|&
name|lengths
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|lengths
index|[
name|pos
index|]
argument_list|)
operator|*
operator|(
name|hash_data
operator|->
name|count
operator|-
name|pos
operator|)
argument_list|)
expr_stmt|;
name|hash_data
operator|->
name|count
operator|--
expr_stmt|;
name|hash_data
operator|->
name|over_provision
operator|++
expr_stmt|;
name|hash_data
operator|->
name|operations
operator|++
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* if not found, prepare to insert the new entry */
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* fallback to slow operation if there is no place left to insert an        * new entry to index. That will automatically give add some spare        * entries ("overprovision"). */
if|if
condition|(
name|hash_data
operator|->
name|over_provision
operator|==
literal|0
condition|)
return|return
name|slowly_replace_dir_entry
argument_list|(
name|data
argument_list|,
name|data_len
argument_list|,
name|baton
argument_list|,
name|pool
argument_list|)
return|;
comment|/* make entries[index] available for pointing to the new entry */
name|memmove
argument_list|(
operator|&
name|entries
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
operator|&
name|entries
index|[
name|pos
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|entries
index|[
name|pos
index|]
argument_list|)
operator|*
operator|(
name|hash_data
operator|->
name|count
operator|-
name|pos
operator|)
argument_list|)
expr_stmt|;
name|memmove
argument_list|(
operator|&
name|lengths
index|[
name|pos
operator|+
literal|1
index|]
argument_list|,
operator|&
name|lengths
index|[
name|pos
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|lengths
index|[
name|pos
index|]
argument_list|)
operator|*
operator|(
name|hash_data
operator|->
name|count
operator|-
name|pos
operator|)
argument_list|)
expr_stmt|;
name|hash_data
operator|->
name|count
operator|++
expr_stmt|;
name|hash_data
operator|->
name|over_provision
operator|--
expr_stmt|;
name|hash_data
operator|->
name|operations
operator|++
expr_stmt|;
block|}
comment|/* de-serialize the new entry */
name|entries
index|[
name|pos
index|]
operator|=
name|replace_baton
operator|->
name|new_entry
expr_stmt|;
name|context
operator|=
name|svn_temp_serializer__init_append
argument_list|(
name|hash_data
argument_list|,
name|entries
argument_list|,
name|hash_data
operator|->
name|len
argument_list|,
operator|*
name|data_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|serialize_dir_entry
argument_list|(
name|context
argument_list|,
operator|&
name|entries
index|[
name|pos
index|]
argument_list|,
operator|&
name|length
argument_list|)
expr_stmt|;
comment|/* return the updated serialized data */
name|SVN_ERR
argument_list|(
name|return_serialized_dir_context
argument_list|(
name|context
argument_list|,
name|data
argument_list|,
name|data_len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* since the previous call may have re-allocated the buffer, the lengths    * pointer may no longer point to the entry in that buffer. Therefore,    * re-map it again and store the length value after that. */
name|hash_data
operator|=
operator|(
name|hash_data_t
operator|*
operator|)
operator|*
name|data
expr_stmt|;
name|lengths
operator|=
operator|(
name|apr_uint32_t
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|hash_data
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|hash_data
operator|->
name|lengths
argument_list|)
expr_stmt|;
name|lengths
index|[
name|pos
index|]
operator|=
name|length
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize change CHANGE_P in the given serialization  * CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|serialize_change
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|change_t
modifier|*
specifier|const
modifier|*
name|change_p
parameter_list|)
block|{
specifier|const
name|change_t
modifier|*
name|change
init|=
operator|*
name|change_p
decl_stmt|;
if|if
condition|(
name|change
operator|==
name|NULL
condition|)
return|return;
comment|/* serialize the change struct itself */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|change_p
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|change
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize sub-structures */
name|svn_fs_fs__id_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|change
operator|->
name|noderev_id
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|change
operator|->
name|path
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|change
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
comment|/* return to the caller's nesting level */
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Utility function to serialize the CHANGE_P within the given  * serialization CONTEXT.  */
end_comment

begin_function
specifier|static
name|void
name|deserialize_change
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|change_t
modifier|*
modifier|*
name|change_p
parameter_list|)
block|{
name|change_t
modifier|*
name|change
decl_stmt|;
comment|/* fix-up of the pointer to the struct in question */
name|svn_temp_deserializer__resolve
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|change_p
argument_list|)
expr_stmt|;
name|change
operator|=
operator|*
name|change_p
expr_stmt|;
if|if
condition|(
name|change
operator|==
name|NULL
condition|)
return|return;
comment|/* fix-up of sub-structures */
name|svn_fs_fs__id_deserialize
argument_list|(
name|change
argument_list|,
operator|(
name|svn_fs_id_t
operator|*
operator|*
operator|)
operator|&
name|change
operator|->
name|noderev_id
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|change
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|change
operator|->
name|path
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|change
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|change
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Auxiliary structure representing the content of a change_t array.    This structure is much easier to (de-)serialize than an APR array.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|changes_data_t
block|{
comment|/* number of entries in the array */
name|int
name|count
decl_stmt|;
comment|/* reference to the changes */
name|change_t
modifier|*
modifier|*
name|changes
decl_stmt|;
block|}
name|changes_data_t
typedef|;
end_typedef

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_changes
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|array
init|=
name|in
decl_stmt|;
name|changes_data_t
name|changes
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* initialize our auxiliary data structure */
name|changes
operator|.
name|count
operator|=
name|array
operator|->
name|nelts
expr_stmt|;
name|changes
operator|.
name|changes
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|change_t
operator|*
argument_list|)
operator|*
name|changes
operator|.
name|count
argument_list|)
expr_stmt|;
comment|/* populate it with the array elements */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changes
operator|.
name|count
condition|;
operator|++
name|i
control|)
name|changes
operator|.
name|changes
index|[
name|i
index|]
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|array
argument_list|,
name|i
argument_list|,
name|change_t
operator|*
argument_list|)
expr_stmt|;
comment|/* serialize it and all its elements */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
operator|&
name|changes
argument_list|,
sizeof|sizeof
argument_list|(
name|changes
argument_list|)
argument_list|,
name|changes
operator|.
name|count
operator|*
literal|100
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|changes
operator|.
name|changes
argument_list|,
name|changes
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
name|change_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changes
operator|.
name|count
condition|;
operator|++
name|i
control|)
name|serialize_change
argument_list|(
name|context
argument_list|,
operator|&
name|changes
operator|.
name|changes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_changes
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|changes_data_t
modifier|*
name|changes
init|=
operator|(
name|changes_data_t
operator|*
operator|)
name|data
decl_stmt|;
name|apr_array_header_t
modifier|*
name|array
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|changes
operator|->
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|change_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* de-serialize our auxiliary data structure */
name|svn_temp_deserializer__resolve
argument_list|(
name|changes
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|changes
operator|->
name|changes
argument_list|)
expr_stmt|;
comment|/* de-serialize each entry and add it to the array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changes
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
name|deserialize_change
argument_list|(
operator|(
name|void
operator|*
operator|)
name|changes
operator|->
name|changes
argument_list|,
operator|(
name|change_t
operator|*
operator|*
operator|)
operator|&
name|changes
operator|->
name|changes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
name|change_t
operator|*
argument_list|)
operator|=
name|changes
operator|->
name|changes
index|[
name|i
index|]
expr_stmt|;
block|}
comment|/* done */
operator|*
name|out
operator|=
name|array
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Auxiliary structure representing the content of a svn_mergeinfo_t hash.    This structure is much easier to (de-)serialize than an APR array.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|mergeinfo_data_t
block|{
comment|/* number of paths in the hash */
name|unsigned
name|count
decl_stmt|;
comment|/* COUNT keys (paths) */
specifier|const
name|char
modifier|*
modifier|*
name|keys
decl_stmt|;
comment|/* COUNT keys lengths (strlen of path) */
name|apr_ssize_t
modifier|*
name|key_lengths
decl_stmt|;
comment|/* COUNT entries, each giving the number of ranges for the key */
name|int
modifier|*
name|range_counts
decl_stmt|;
comment|/* all ranges in a single, concatenated buffer */
name|svn_merge_range_t
modifier|*
name|ranges
decl_stmt|;
block|}
name|mergeinfo_data_t
typedef|;
end_typedef

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__serialize_mergeinfo
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|in
decl_stmt|;
name|mergeinfo_data_t
name|merges
decl_stmt|;
name|svn_temp_serializer__context_t
modifier|*
name|context
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|unsigned
name|i
decl_stmt|;
name|int
name|k
decl_stmt|;
name|apr_size_t
name|range_count
decl_stmt|;
comment|/* initialize our auxiliary data structure */
name|merges
operator|.
name|count
operator|=
name|apr_hash_count
argument_list|(
name|mergeinfo
argument_list|)
expr_stmt|;
name|merges
operator|.
name|keys
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|keys
argument_list|)
operator|*
name|merges
operator|.
name|count
argument_list|)
expr_stmt|;
name|merges
operator|.
name|key_lengths
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|key_lengths
argument_list|)
operator|*
name|merges
operator|.
name|count
argument_list|)
expr_stmt|;
name|merges
operator|.
name|range_counts
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|range_counts
argument_list|)
operator|*
name|merges
operator|.
name|count
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|range_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
operator|,
operator|++
name|i
control|)
block|{
name|svn_rangelist_t
modifier|*
name|ranges
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|merges
operator|.
name|keys
index|[
name|i
index|]
argument_list|,
operator|&
name|merges
operator|.
name|key_lengths
index|[
name|i
index|]
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|ranges
argument_list|)
expr_stmt|;
name|merges
operator|.
name|range_counts
index|[
name|i
index|]
operator|=
name|ranges
operator|->
name|nelts
expr_stmt|;
name|range_count
operator|+=
name|ranges
operator|->
name|nelts
expr_stmt|;
block|}
name|merges
operator|.
name|ranges
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|ranges
argument_list|)
operator|*
name|range_count
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_rangelist_t
modifier|*
name|ranges
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|ranges
operator|->
name|nelts
condition|;
operator|++
name|k
operator|,
operator|++
name|i
control|)
name|merges
operator|.
name|ranges
index|[
name|i
index|]
operator|=
operator|*
name|APR_ARRAY_IDX
argument_list|(
name|ranges
argument_list|,
name|k
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
block|}
comment|/* serialize it and all its elements */
name|context
operator|=
name|svn_temp_serializer__init
argument_list|(
operator|&
name|merges
argument_list|,
sizeof|sizeof
argument_list|(
name|merges
argument_list|)
argument_list|,
name|range_count
operator|*
literal|30
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* keys array */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|merges
operator|.
name|keys
argument_list|,
name|merges
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|keys
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merges
operator|.
name|count
condition|;
operator|++
name|i
control|)
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|merges
operator|.
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* key lengths array */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|merges
operator|.
name|key_lengths
argument_list|,
name|merges
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|key_lengths
argument_list|)
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* range counts array */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|merges
operator|.
name|range_counts
argument_list|,
name|merges
operator|.
name|count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|range_counts
argument_list|)
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* ranges */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|merges
operator|.
name|ranges
argument_list|,
name|range_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|merges
operator|.
name|ranges
argument_list|)
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_fs__deserialize_mergeinfo
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|unsigned
name|i
decl_stmt|;
name|int
name|k
decl_stmt|,
name|n
decl_stmt|;
name|mergeinfo_data_t
modifier|*
name|merges
init|=
operator|(
name|mergeinfo_data_t
operator|*
operator|)
name|data
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
comment|/* de-serialize our auxiliary data structure */
name|svn_temp_deserializer__resolve
argument_list|(
name|merges
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|merges
operator|->
name|keys
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|merges
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|merges
operator|->
name|key_lengths
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|merges
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|merges
operator|->
name|range_counts
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|merges
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|merges
operator|->
name|ranges
argument_list|)
expr_stmt|;
comment|/* de-serialize keys and add entries to the result */
name|n
operator|=
literal|0
expr_stmt|;
name|mergeinfo
operator|=
name|svn_hash__make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merges
operator|->
name|count
condition|;
operator|++
name|i
control|)
block|{
name|svn_rangelist_t
modifier|*
name|ranges
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|merges
operator|->
name|range_counts
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|merges
operator|->
name|range_counts
index|[
name|i
index|]
condition|;
operator|++
name|k
operator|,
operator|++
name|n
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|ranges
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
operator|&
name|merges
operator|->
name|ranges
index|[
name|n
index|]
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
operator|(
name|void
operator|*
operator|)
name|merges
operator|->
name|keys
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|merges
operator|->
name|keys
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|mergeinfo
argument_list|,
name|merges
operator|->
name|keys
index|[
name|i
index|]
argument_list|,
name|merges
operator|->
name|key_lengths
index|[
name|i
index|]
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
block|}
comment|/* done */
operator|*
name|out
operator|=
name|mergeinfo
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

