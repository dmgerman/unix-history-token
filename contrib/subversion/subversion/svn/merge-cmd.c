begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * merge-cmd.c -- Merging changes into a working copy.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Throw an error if PATH_OR_URL is a path and REVISION isn't a repository  * revision. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_wc_path_has_repo_revision
parameter_list|(
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_number
operator|&&
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_date
operator|&&
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_head
operator|&&
operator|!
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid merge source '%s'; a working copy path can only be "
literal|"used with a repository revision (a number, a date, or head)"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Run a merge.  *  * (No docs yet, as this code was just hoisted out of svn_cl__merge().)  *  * Having FIRST_RANGE_START/_END params is ugly -- we should be able to use  * PEG_REVISION1/2 and/or RANGES_TO_MERGE instead, maybe adjusting the caller.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_merge
parameter_list|(
name|svn_boolean_t
name|two_sources_specified
parameter_list|,
specifier|const
name|char
modifier|*
name|sourcepath1
parameter_list|,
name|svn_opt_revision_t
name|peg_revision1
parameter_list|,
specifier|const
name|char
modifier|*
name|sourcepath2
parameter_list|,
specifier|const
name|char
modifier|*
name|targetpath
parameter_list|,
name|apr_array_header_t
modifier|*
name|ranges_to_merge
parameter_list|,
name|svn_opt_revision_t
name|first_range_start
parameter_list|,
name|svn_opt_revision_t
name|first_range_end
parameter_list|,
name|svn_cl__opt_state_t
modifier|*
name|opt_state
parameter_list|,
name|apr_array_header_t
modifier|*
name|options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|merge_err
decl_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|reintegrate
condition|)
block|{
name|merge_err
operator|=
name|svn_cl__deprecated_merge_reintegrate
argument_list|(
name|sourcepath1
argument_list|,
operator|&
name|peg_revision1
argument_list|,
name|targetpath
argument_list|,
name|opt_state
operator|->
name|dry_run
argument_list|,
name|options
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|two_sources_specified
condition|)
block|{
comment|/* If we don't have at least one valid revision range, pick a          good one that spans the entire set of revisions on our          source. */
if|if
condition|(
operator|(
name|first_range_start
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|&&
operator|(
name|first_range_end
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
condition|)
block|{
name|ranges_to_merge
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|opt_state
operator|->
name|verbose
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"--- Merging\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|merge_err
operator|=
name|svn_client_merge_peg5
argument_list|(
name|sourcepath1
argument_list|,
name|ranges_to_merge
argument_list|,
operator|&
name|peg_revision1
argument_list|,
name|targetpath
argument_list|,
name|opt_state
operator|->
name|depth
argument_list|,
name|opt_state
operator|->
name|ignore_ancestry
argument_list|,
name|opt_state
operator|->
name|ignore_ancestry
argument_list|,
name|opt_state
operator|->
name|force
argument_list|,
comment|/* force_delete */
name|opt_state
operator|->
name|record_only
argument_list|,
name|opt_state
operator|->
name|dry_run
argument_list|,
name|opt_state
operator|->
name|allow_mixed_rev
argument_list|,
name|options
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|sourcepath1
argument_list|)
operator|!=
name|svn_path_is_url
argument_list|(
name|sourcepath2
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Merge sources must both be "
literal|"either paths or URLs"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|targetpath
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Merge target '%s' must be a local path "
literal|"but looks like a URL"
argument_list|)
argument_list|,
name|targetpath
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|verbose
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"--- Merging\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|merge_err
operator|=
name|svn_client_merge5
argument_list|(
name|sourcepath1
argument_list|,
operator|&
name|first_range_start
argument_list|,
name|sourcepath2
argument_list|,
operator|&
name|first_range_end
argument_list|,
name|targetpath
argument_list|,
name|opt_state
operator|->
name|depth
argument_list|,
name|opt_state
operator|->
name|ignore_ancestry
argument_list|,
name|opt_state
operator|->
name|ignore_ancestry
argument_list|,
name|opt_state
operator|->
name|force
argument_list|,
comment|/* force_delete */
name|opt_state
operator|->
name|record_only
argument_list|,
name|opt_state
operator|->
name|dry_run
argument_list|,
name|opt_state
operator|->
name|allow_mixed_rev
argument_list|,
name|options
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|merge_err
return|;
block|}
end_function

begin_comment
comment|/* This implements the `svn_opt_subcommand_t' interface. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cl__merge
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cl__opt_state_t
modifier|*
name|opt_state
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|opt_state
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|ctx
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
specifier|const
name|char
modifier|*
name|sourcepath1
init|=
name|NULL
decl_stmt|,
modifier|*
name|sourcepath2
init|=
name|NULL
decl_stmt|,
modifier|*
name|targetpath
init|=
literal|""
decl_stmt|;
name|svn_boolean_t
name|two_sources_specified
init|=
name|TRUE
decl_stmt|;
name|svn_error_t
modifier|*
name|merge_err
decl_stmt|;
name|svn_opt_revision_t
name|first_range_start
decl_stmt|,
name|first_range_end
decl_stmt|,
name|peg_revision1
decl_stmt|,
name|peg_revision2
decl_stmt|;
name|apr_array_header_t
modifier|*
name|options
decl_stmt|,
modifier|*
name|ranges_to_merge
init|=
name|opt_state
operator|->
name|revision_ranges
decl_stmt|;
name|svn_boolean_t
name|has_explicit_target
init|=
name|FALSE
decl_stmt|;
comment|/* Merge doesn't support specifying a revision or revision range      when using --reintegrate. */
if|if
condition|(
name|opt_state
operator|->
name|reintegrate
operator|&&
name|opt_state
operator|->
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"-r and -c can't be used with --reintegrate"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cl__args_to_target_array_print_reserved
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|opt_state
operator|->
name|targets
argument_list|,
name|ctx
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For now, we require at least one source.  That may change in      future versions of Subversion, for example if we have support for      negated mergeinfo.  See this IRC conversation:<bhuvan>   kfogel: yeah, i think you are correct; we should                   specify the source url<kfogel>   bhuvan: I'll change the help output and propose for                   backport.  Thanks.<bhuvan>   kfogel: np; while we are at it, 'svn merge' simply                   returns nothing; i think we should say: """svn: Not                   enough arguments provided; try 'svn help' for more                   info"""<kfogel>   good idea<kfogel>   (in the future, 'svn merge' might actually do                   something, but that's all the more reason to make                   sure it errors now)<cmpilato> actually, i'm pretty sure 'svn merge' does something<cmpilato> it says "please merge any unmerged changes from                   myself to myself."<cmpilato> :-)<kfogel>   har har<cmpilato> kfogel: i was serious.<kfogel>   cmpilato: urrr, uh.  Is that meaningful?  Is there                   ever a reason for a user to run it?<cmpilato> kfogel: not while we don't have support for negated                   mergeinfo.<kfogel>   cmpilato: do you concur that until it does something                   useful it should error?<cmpilato> kfogel: yup.<kfogel>   cool   */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<
literal|1
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Merge source required"
argument_list|)
argument_list|)
return|;
block|}
else|else
comment|/* Parse at least one, and possible two, sources. */
block|{
name|SVN_ERR
argument_list|(
name|svn_opt_parse_path
argument_list|(
operator|&
name|peg_revision1
argument_list|,
operator|&
name|sourcepath1
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>=
literal|2
condition|)
name|SVN_ERR
argument_list|(
name|svn_opt_parse_path
argument_list|(
operator|&
name|peg_revision2
argument_list|,
operator|&
name|sourcepath2
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We could have one or two sources.  Deliberately written to stay      correct even if we someday permit implied merge source. */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<=
literal|1
condition|)
block|{
name|two_sources_specified
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|sourcepath1
argument_list|)
operator|&&
operator|!
name|svn_path_is_url
argument_list|(
name|sourcepath2
argument_list|)
condition|)
name|two_sources_specified
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|opt_state
operator|->
name|revision_ranges
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|first_range_start
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|opt_state
operator|->
name|revision_ranges
argument_list|,
literal|0
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
operator|->
name|start
expr_stmt|;
name|first_range_end
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|opt_state
operator|->
name|revision_ranges
argument_list|,
literal|0
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
operator|->
name|end
expr_stmt|;
block|}
else|else
block|{
name|first_range_start
operator|.
name|kind
operator|=
name|first_range_end
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
block|}
comment|/* If revision_ranges has at least one real range at this point, then      we know the user must have used the '-r' and/or '-c' switch(es).      This means we're *not* doing two distinct sources. */
if|if
condition|(
name|first_range_start
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
comment|/* A revision *range* is required. */
if|if
condition|(
name|first_range_end
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Second revision required"
argument_list|)
argument_list|)
return|;
name|two_sources_specified
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|two_sources_specified
condition|)
comment|/* TODO: Switch order of if */
block|{
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Too many arguments given"
argument_list|)
argument_list|)
return|;
comment|/* Set the default value for unspecified paths and peg revision. */
comment|/* targets->nelts is 1 ("svn merge SOURCE") or 2 ("svn merge          SOURCE WCPATH") here. */
name|sourcepath2
operator|=
name|sourcepath1
expr_stmt|;
if|if
condition|(
name|peg_revision1
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|peg_revision1
operator|.
name|kind
operator|=
name|svn_path_is_url
argument_list|(
name|sourcepath1
argument_list|)
condition|?
name|svn_opt_revision_head
else|:
name|svn_opt_revision_working
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|2
condition|)
block|{
name|targetpath
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|has_explicit_target
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|targetpath
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot specify a revision range "
literal|"with two URLs"
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
comment|/* using @rev syntax */
block|{
if|if
condition|(
name|targets
operator|->
name|nelts
operator|<
literal|2
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|3
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Too many arguments given"
argument_list|)
argument_list|)
return|;
name|first_range_start
operator|=
name|peg_revision1
expr_stmt|;
name|first_range_end
operator|=
name|peg_revision2
expr_stmt|;
comment|/* Catch 'svn merge wc_path1 wc_path2 [target]' without explicit          revisions--since it ignores local modifications it may not do what          the user expects.  That is, it doesn't read from the WC itself, it          reads from the WC's URL.  Forcing the user to specify a repository          revision should avoid any confusion. */
name|SVN_ERR
argument_list|(
name|ensure_wc_path_has_repo_revision
argument_list|(
name|sourcepath1
argument_list|,
operator|&
name|first_range_start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_wc_path_has_repo_revision
argument_list|(
name|sourcepath2
argument_list|,
operator|&
name|first_range_end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Default peg revisions to each URL's youngest revision. */
if|if
condition|(
name|first_range_start
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|first_range_start
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
if|if
condition|(
name|first_range_end
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|first_range_end
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
comment|/* Decide where to apply the delta (defaulting to "."). */
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|3
condition|)
block|{
name|targetpath
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|2
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|has_explicit_target
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* If no targetpath was specified, see if we can infer it from the      sourcepaths. */
if|if
condition|(
operator|!
name|has_explicit_target
operator|&&
name|sourcepath1
operator|&&
name|sourcepath2
operator|&&
name|strcmp
argument_list|(
name|targetpath
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* If the sourcepath is a URL, it can only refer to a target in          the current working directory or which is the current working          directory.  However, if the sourcepath is a local path, it can          refer to a target somewhere deeper in the directory structure. */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|sourcepath1
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|sp1_basename
init|=
name|svn_uri_basename
argument_list|(
name|sourcepath1
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|sp2_basename
init|=
name|svn_uri_basename
argument_list|(
name|sourcepath2
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|sp1_basename
argument_list|,
name|sp2_basename
argument_list|)
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|target_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_base
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_url_from_path2
argument_list|(
operator|&
name|target_url
argument_list|,
name|targetpath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|target_base
operator|=
name|svn_uri_basename
argument_list|(
name|target_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If the basename of the source is the same as the basename of                  the cwd assume the cwd is the target. */
if|if
condition|(
name|strcmp
argument_list|(
name|sp1_basename
argument_list|,
name|target_base
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* If the basename of the source differs from the basename                      of the target.  We still might assume the cwd is the                      target, but first check if there is a file in the cwd                      with the same name as the source basename.  If there is,                      then assume that file is the target. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|sp1_basename
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|targetpath
operator|=
name|sp1_basename
expr_stmt|;
block|}
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|sourcepath1
argument_list|,
name|sourcepath2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|sourcepath1
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|targetpath
operator|=
name|sourcepath1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|opt_state
operator|->
name|extensions
condition|)
name|options
operator|=
name|svn_cstring_split
argument_list|(
name|opt_state
operator|->
name|extensions
argument_list|,
literal|" \t\n\r"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|options
operator|=
name|NULL
expr_stmt|;
comment|/* More input validation. */
if|if
condition|(
name|opt_state
operator|->
name|reintegrate
condition|)
block|{
if|if
condition|(
name|opt_state
operator|->
name|ignore_ancestry
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--reintegrate cannot be used with "
literal|"--ignore-ancestry"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|record_only
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--reintegrate cannot be used with "
literal|"--record-only"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|depth
operator|!=
name|svn_depth_unknown
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--depth cannot be used with "
literal|"--reintegrate"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|force
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--force cannot be used with "
literal|"--reintegrate"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|two_sources_specified
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--reintegrate can only be used with "
literal|"a single merge source"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|opt_state
operator|->
name|allow_mixed_rev
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--allow-mixed-revisions cannot be used "
literal|"with --reintegrate"
argument_list|)
argument_list|)
return|;
block|}
name|merge_err
operator|=
name|run_merge
argument_list|(
name|two_sources_specified
argument_list|,
name|sourcepath1
argument_list|,
name|peg_revision1
argument_list|,
name|sourcepath2
argument_list|,
name|targetpath
argument_list|,
name|ranges_to_merge
argument_list|,
name|first_range_start
argument_list|,
name|first_range_end
argument_list|,
name|opt_state
argument_list|,
name|options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_err
operator|&&
name|merge_err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING
condition|)
block|{
return|return
name|svn_error_quick_wrap
argument_list|(
name|merge_err
argument_list|,
name|_
argument_list|(
literal|"Merge tracking not possible, use --ignore-ancestry or\n"
literal|"fix invalid mergeinfo in target with 'svn propset'"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_cl__notifier_print_conflict_stats
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|merge_err
operator|=
name|svn_error_compose_create
argument_list|(
name|merge_err
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_cl__may_need_force
argument_list|(
name|merge_err
argument_list|)
return|;
block|}
end_function

end_unit

