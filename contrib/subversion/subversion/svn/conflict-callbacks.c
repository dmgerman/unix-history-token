begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * conflict-callbacks.c: conflict resolution callbacks specific to the  * commandline client.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_xlate.h>
end_include

begin_comment
comment|/* for APR_LOCALE_CHARSET */
end_comment

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"cl-conflicts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_define
define|#
directive|define
name|ARRAY_LEN
parameter_list|(
name|ary
parameter_list|)
value|((sizeof (ary)) / (sizeof ((ary)[0])))
end_define

begin_escape
end_escape

begin_struct
struct|struct
name|svn_cl__interactive_conflict_baton_t
block|{
name|svn_cl__accept_t
name|accept_which
decl_stmt|;
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
specifier|const
name|char
modifier|*
name|editor_cmd
decl_stmt|;
name|svn_boolean_t
name|external_failed
decl_stmt|;
name|svn_cmdline_prompt_baton_t
modifier|*
name|pb
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_prefix
decl_stmt|;
name|svn_boolean_t
name|quit
decl_stmt|;
name|svn_cl__conflict_stats_t
modifier|*
name|conflict_stats
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|svn_error_t
modifier|*
name|svn_cl__get_conflict_func_interactive_baton
parameter_list|(
name|svn_cl__interactive_conflict_baton_t
modifier|*
modifier|*
name|b
parameter_list|,
name|svn_cl__accept_t
name|accept_which
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|editor_cmd
parameter_list|,
name|svn_cl__conflict_stats_t
modifier|*
name|conflict_stats
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_cmdline_prompt_baton_t
modifier|*
name|pb
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pb
argument_list|)
argument_list|)
decl_stmt|;
name|pb
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|pb
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
operator|*
name|b
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|accept_which
operator|=
name|accept_which
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|config
operator|=
name|config
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|editor_cmd
operator|=
name|editor_cmd
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|external_failed
operator|=
name|FALSE
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|pb
operator|=
name|pb
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
operator|(
operator|*
name|b
operator|)
operator|->
name|path_prefix
argument_list|,
literal|""
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|quit
operator|=
name|FALSE
expr_stmt|;
operator|(
operator|*
name|b
operator|)
operator|->
name|conflict_stats
operator|=
name|conflict_stats
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_cl__accept_t
name|svn_cl__accept_from_word
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
comment|/* Shorthand options are consistent with  svn_cl__conflict_handler(). */
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_POSTPONE
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"p"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|":-P"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__accept_postpone
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_BASE
argument_list|)
operator|==
literal|0
condition|)
comment|/* ### shorthand? */
return|return
name|svn_cl__accept_base
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_WORKING
argument_list|)
operator|==
literal|0
condition|)
comment|/* ### shorthand? */
return|return
name|svn_cl__accept_working
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_MINE_CONFLICT
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"mc"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"X-)"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__accept_mine_conflict
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_THEIRS_CONFLICT
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"tc"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"X-("
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__accept_theirs_conflict
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_MINE_FULL
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"mf"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|":-)"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__accept_mine_full
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_THEIRS_FULL
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"tf"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|":-("
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__accept_theirs_full
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_EDIT
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"e"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|":-E"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__accept_edit
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__ACCEPT_LAUNCH
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"l"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|word
argument_list|,
literal|":-l"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__accept_launch
return|;
comment|/* word is an invalid action. */
return|return
name|svn_cl__accept_invalid
return|;
block|}
end_function

begin_comment
comment|/* Print on stdout a diff that shows incoming conflicting changes  * corresponding to the conflict described in DESC. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|show_diff
parameter_list|(
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|path_prefix
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path1
decl_stmt|,
modifier|*
name|path2
decl_stmt|;
specifier|const
name|char
modifier|*
name|label1
decl_stmt|,
modifier|*
name|label2
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|options
decl_stmt|;
if|if
condition|(
name|desc
operator|->
name|merged_file
condition|)
block|{
comment|/* For conflicts recorded by the 'merge' operation, show a diff between        * 'mine' (the working version of the file as it appeared before the        * 'merge' operation was run) and 'merged' (the version of the file        * as it appears after the merge operation).        *        * For conflicts recorded by the 'update' and 'switch' operations,        * show a diff beween 'theirs' (the new pristine version of the        * file) and 'merged' (the version of the file as it appears with        * local changes merged with the new pristine version).        *        * This way, the diff is always minimal and clearly identifies changes        * brought into the working copy by the update/switch/merge operation. */
if|if
condition|(
name|desc
operator|->
name|operation
operator|==
name|svn_wc_operation_merge
condition|)
block|{
name|path1
operator|=
name|desc
operator|->
name|my_abspath
expr_stmt|;
name|label1
operator|=
name|_
argument_list|(
literal|"MINE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|path1
operator|=
name|desc
operator|->
name|their_abspath
expr_stmt|;
name|label1
operator|=
name|_
argument_list|(
literal|"THEIRS"
argument_list|)
expr_stmt|;
block|}
name|path2
operator|=
name|desc
operator|->
name|merged_file
expr_stmt|;
name|label2
operator|=
name|_
argument_list|(
literal|"MERGED"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There's no merged file, but we can show the          difference between mine and theirs. */
name|path1
operator|=
name|desc
operator|->
name|their_abspath
expr_stmt|;
name|label1
operator|=
name|_
argument_list|(
literal|"THEIRS"
argument_list|)
expr_stmt|;
name|path2
operator|=
name|desc
operator|->
name|my_abspath
expr_stmt|;
name|label2
operator|=
name|_
argument_list|(
literal|"MINE"
argument_list|)
expr_stmt|;
block|}
name|label1
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\t- %s"
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|label2
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\t- %s"
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|,
name|label2
argument_list|)
expr_stmt|;
name|options
operator|=
name|svn_diff_file_options_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|options
operator|->
name|ignore_eol_style
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|output
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff_2
argument_list|(
operator|&
name|diff
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|,
name|options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_diff_file_output_unified3
argument_list|(
name|output
argument_list|,
name|diff
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|,
name|label1
argument_list|,
name|label2
argument_list|,
name|APR_LOCALE_CHARSET
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print on stdout just the conflict hunks of a diff among the 'base', 'their'  * and 'my' files of DESC. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|show_conflicts
parameter_list|(
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|options
decl_stmt|;
name|options
operator|=
name|svn_diff_file_options_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|options
operator|->
name|ignore_eol_style
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|output
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff3_2
argument_list|(
operator|&
name|diff
argument_list|,
name|desc
operator|->
name|base_abspath
argument_list|,
name|desc
operator|->
name|my_abspath
argument_list|,
name|desc
operator|->
name|their_abspath
argument_list|,
name|options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Consider putting the markers/labels from      ### svn_wc__merge_internal in the conflict description. */
return|return
name|svn_diff_file_output_merge2
argument_list|(
name|output
argument_list|,
name|diff
argument_list|,
name|desc
operator|->
name|base_abspath
argument_list|,
name|desc
operator|->
name|my_abspath
argument_list|,
name|desc
operator|->
name|their_abspath
argument_list|,
name|_
argument_list|(
literal|"||||||| ORIGINAL"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<<<<<<< MINE (select with 'mc')"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|">>>>>>> THEIRS (select with 'tc')"
argument_list|)
argument_list|,
literal|"======="
argument_list|,
name|svn_diff_conflict_display_only_conflicts
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Perform a 3-way merge of the conflicting values of a property,  * and write the result to the OUTPUT stream.  *  * If MERGED_ABSPATH is non-NULL, use it as 'my' version instead of  * DESC->MY_ABSPATH.  *  * Assume the values are printable UTF-8 text.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_prop_conflict
parameter_list|(
name|svn_stream_t
modifier|*
name|output
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|base_abspath
init|=
name|desc
operator|->
name|base_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|my_abspath
init|=
name|desc
operator|->
name|my_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|their_abspath
init|=
name|desc
operator|->
name|their_abspath
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|options
init|=
name|svn_diff_file_options_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
comment|/* If any of the property values is missing, use an empty file instead    * for the purpose of showing a diff. */
if|if
condition|(
operator|!
name|base_abspath
operator|||
operator|!
name|my_abspath
operator|||
operator|!
name|their_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|empty_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|empty_file
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|base_abspath
condition|)
name|base_abspath
operator|=
name|empty_file
expr_stmt|;
if|if
condition|(
operator|!
name|my_abspath
condition|)
name|my_abspath
operator|=
name|empty_file
expr_stmt|;
if|if
condition|(
operator|!
name|their_abspath
condition|)
name|their_abspath
operator|=
name|empty_file
expr_stmt|;
block|}
name|options
operator|->
name|ignore_eol_style
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff3_2
argument_list|(
operator|&
name|diff
argument_list|,
name|base_abspath
argument_list|,
name|merged_abspath
condition|?
name|merged_abspath
else|:
name|my_abspath
argument_list|,
name|their_abspath
argument_list|,
name|options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_output_merge2
argument_list|(
name|output
argument_list|,
name|diff
argument_list|,
name|base_abspath
argument_list|,
name|merged_abspath
condition|?
name|merged_abspath
else|:
name|my_abspath
argument_list|,
name|their_abspath
argument_list|,
name|_
argument_list|(
literal|"||||||| ORIGINAL"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"<<<<<<< MINE"
argument_list|)
argument_list|,
name|_
argument_list|(
literal|">>>>>>> THEIRS"
argument_list|)
argument_list|,
literal|"======="
argument_list|,
name|svn_diff_conflict_display_modified_original_latest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Display the conflicting values of a property as a 3-way diff.  *  * If MERGED_ABSPATH is non-NULL, show it as 'my' version instead of  * DESC->MY_ABSPATH.  *  * Assume the values are printable UTF-8 text.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|show_prop_conflict
parameter_list|(
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|output
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|merge_prop_conflict
argument_list|(
name|output
argument_list|,
name|desc
argument_list|,
name|merged_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Run an external editor, passing it the MERGED_FILE, or, if the  * 'merged' file is null, return an error. The tool to use is determined by  * B->editor_cmd, B->config and environment variables; see  * svn_cl__edit_file_externally() for details.  *  * If the tool runs, set *PERFORMED_EDIT to true; if a tool is not  * configured or cannot run, do not touch *PERFORMED_EDIT, report the error  * on stderr, and return SVN_NO_ERROR; if any other error is encountered,  * return that error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_editor
parameter_list|(
name|svn_boolean_t
modifier|*
name|performed_edit
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_file
parameter_list|,
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|merged_file
condition|)
block|{
name|err
operator|=
name|svn_cmdline__edit_file_externally
argument_list|(
name|merged_file
argument_list|,
name|b
operator|->
name|editor_cmd
argument_list|,
name|b
operator|->
name|config
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|root_err
init|=
name|svn_error_root_cause
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|root_err
operator|->
name|message
condition|?
name|root_err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"No editor found."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_EXTERNAL_PROGRAM
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|root_err
init|=
name|svn_error_root_cause
argument_list|(
name|err
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|root_err
operator|->
name|message
condition|?
name|root_err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"Error running editor."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
else|else
operator|*
name|performed_edit
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; there's no "
literal|"merged version to edit.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Run an external editor, passing it the 'merged' property in DESC.  * The tool to use is determined by B->editor_cmd, B->config and  * environment variables; see svn_cl__edit_file_externally() for details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|edit_prop_conflict
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|merged_file_path
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_path
decl_stmt|;
name|svn_boolean_t
name|performed_edit
init|=
name|FALSE
decl_stmt|;
name|svn_stream_t
modifier|*
name|merged_prop
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|file
argument_list|,
operator|&
name|file_path
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|merged_prop
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
comment|/* disown */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|merge_prop_conflict
argument_list|(
name|merged_prop
argument_list|,
name|desc
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|merged_prop
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_editor
argument_list|(
operator|&
name|performed_edit
argument_list|,
name|file_path
argument_list|,
name|b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|merged_file_path
operator|=
operator|(
name|performed_edit
condition|?
name|file_path
else|:
name|NULL
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Run an external merge tool, passing it the 'base', 'their', 'my' and  * 'merged' files in DESC. The tool to use is determined by B->config and  * environment variables; see svn_cl__merge_file_externally() for details.  *  * If the tool runs, set *PERFORMED_EDIT to true; if a tool is not  * configured or cannot run, do not touch *PERFORMED_EDIT, report the error  * on stderr, and return SVN_NO_ERROR; if any other error is encountered,  * return that error.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|launch_resolver
parameter_list|(
name|svn_boolean_t
modifier|*
name|performed_edit
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_cl__merge_file_externally
argument_list|(
name|desc
operator|->
name|base_abspath
argument_list|,
name|desc
operator|->
name|their_abspath
argument_list|,
name|desc
operator|->
name|my_abspath
argument_list|,
name|desc
operator|->
name|merged_file
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|b
operator|->
name|config
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"No merge tool found, "
literal|"try '(m) merge' instead.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_EXTERNAL_PROGRAM
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"Error running merge tool, "
literal|"try '(m) merge' instead."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
elseif|else
if|if
condition|(
name|performed_edit
condition|)
operator|*
name|performed_edit
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Maximum line length for the prompt string. */
end_comment

begin_define
define|#
directive|define
name|MAX_PROMPT_WIDTH
value|70
end_define

begin_comment
comment|/* Description of a resolver option */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|resolver_option_t
block|{
specifier|const
name|char
modifier|*
name|code
decl_stmt|;
comment|/* one or two characters */
specifier|const
name|char
modifier|*
name|short_desc
decl_stmt|;
comment|/* label in prompt (localized) */
specifier|const
name|char
modifier|*
name|long_desc
decl_stmt|;
comment|/* longer description (localized) */
name|svn_wc_conflict_choice_t
name|choice
decl_stmt|;
comment|/* or -1 if not a simple choice */
block|}
name|resolver_option_t
typedef|;
end_typedef

begin_comment
comment|/* Resolver options for a text conflict */
end_comment

begin_comment
comment|/* (opt->code == "" causes a blank line break in help_string()) */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|text_conflict_options
index|[]
init|=
block|{
comment|/* Translators: keep long_desc below 70 characters (wrap with a left      margin of 9 spaces if needed); don't translate the words within square      brackets. */
block|{
literal|"e"
block|,
name|N_
argument_list|(
literal|"edit file"
argument_list|)
block|,
name|N_
argument_list|(
literal|"change merged file in an editor"
literal|"  [edit]"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"df"
block|,
name|N_
argument_list|(
literal|"show diff"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show all changes made to merged file"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"r"
block|,
name|N_
argument_list|(
literal|"mark resolved"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept merged version of file"
argument_list|)
block|,
name|svn_wc_conflict_choose_merged
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
name|svn_wc_conflict_choose_unspecified
block|}
block|,
block|{
literal|"dc"
block|,
name|N_
argument_list|(
literal|"display conflict"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show all conflicts "
literal|"(ignoring merged version)"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"mc"
block|,
name|N_
argument_list|(
literal|"my side of conflict"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept my version for all conflicts "
literal|"(same)  [mine-conflict]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_conflict
block|}
block|,
block|{
literal|"tc"
block|,
name|N_
argument_list|(
literal|"their side of conflict"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept their version for all "
literal|"conflicts (same)"
literal|"  [theirs-conflict]"
argument_list|)
block|,
name|svn_wc_conflict_choose_theirs_conflict
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
name|svn_wc_conflict_choose_unspecified
block|}
block|,
block|{
literal|"mf"
block|,
name|N_
argument_list|(
literal|"my version"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept my version of entire file (even "
literal|"non-conflicts)  [mine-full]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_full
block|}
block|,
block|{
literal|"tf"
block|,
name|N_
argument_list|(
literal|"their version"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept their version of entire file "
literal|"(same)  [theirs-full]"
argument_list|)
block|,
name|svn_wc_conflict_choose_theirs_full
block|}
block|,
block|{
literal|""
block|,
literal|""
block|,
literal|""
block|,
name|svn_wc_conflict_choose_unspecified
block|}
block|,
block|{
literal|"m"
block|,
name|N_
argument_list|(
literal|"merge"
argument_list|)
block|,
name|N_
argument_list|(
literal|"use internal merge tool to resolve "
literal|"conflict"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"l"
block|,
name|N_
argument_list|(
literal|"launch tool"
argument_list|)
block|,
name|N_
argument_list|(
literal|"launch external tool to resolve "
literal|"conflict  [launch]"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"mark the conflict to be resolved later"
literal|"  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"s"
block|,
name|N_
argument_list|(
literal|"show all options"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this list (also 'h', '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Resolver options for a property conflict */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|prop_conflict_options
index|[]
init|=
block|{
block|{
literal|"mf"
block|,
name|N_
argument_list|(
literal|"my version"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept my version of entire property (even "
literal|"non-conflicts)  [mine-full]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_full
block|}
block|,
block|{
literal|"tf"
block|,
name|N_
argument_list|(
literal|"their version"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept their version of entire property "
literal|"(same)  [theirs-full]"
argument_list|)
block|,
name|svn_wc_conflict_choose_theirs_full
block|}
block|,
block|{
literal|"dc"
block|,
name|N_
argument_list|(
literal|"display conflict"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show conflicts in this property"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"e"
block|,
name|N_
argument_list|(
literal|"edit property"
argument_list|)
block|,
name|N_
argument_list|(
literal|"change merged property value in an editor"
literal|"  [edit]"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
literal|"r"
block|,
name|N_
argument_list|(
literal|"mark resolved"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept edited version of property"
argument_list|)
block|,
name|svn_wc_conflict_choose_merged
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"mark the conflict to be resolved later"
literal|"  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"h"
block|,
name|N_
argument_list|(
literal|"help"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this help (also '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Resolver options for an obstructued addition */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|obstructed_add_options
index|[]
init|=
block|{
block|{
literal|"mf"
block|,
name|N_
argument_list|(
literal|"my version"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept pre-existing item (ignore "
literal|"upstream addition)  [mine-full]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_full
block|}
block|,
block|{
literal|"tf"
block|,
name|N_
argument_list|(
literal|"their version"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept incoming item (overwrite "
literal|"pre-existing item)  [theirs-full]"
argument_list|)
block|,
name|svn_wc_conflict_choose_theirs_full
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"mark the conflict to be resolved later"
literal|"  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"h"
block|,
name|N_
argument_list|(
literal|"help"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this help (also '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Resolver options for a tree conflict */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|tree_conflict_options
index|[]
init|=
block|{
block|{
literal|"r"
block|,
name|N_
argument_list|(
literal|"mark resolved"
argument_list|)
block|,
name|N_
argument_list|(
literal|"accept current working copy state"
argument_list|)
block|,
name|svn_wc_conflict_choose_merged
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"resolve the conflict later  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"h"
block|,
name|N_
argument_list|(
literal|"help"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this help (also '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|tree_conflict_options_update_moved_away
index|[]
init|=
block|{
block|{
literal|"mc"
block|,
name|N_
argument_list|(
literal|"apply update (recommended)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"apply update to the move destination"
literal|"  [mine-conflict]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_conflict
block|}
block|,
block|{
literal|"r"
block|,
name|N_
argument_list|(
literal|"discard update (breaks move)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"discard update, mark "
literal|"resolved, the move will "
literal|"will become a copy"
argument_list|)
block|,
name|svn_wc_conflict_choose_merged
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"resolve the conflict later  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"h"
block|,
name|N_
argument_list|(
literal|"help"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this help (also '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|tree_conflict_options_update_edit_moved_away
index|[]
init|=
block|{
block|{
literal|"mc"
block|,
name|N_
argument_list|(
literal|"apply update to move destination"
argument_list|)
block|,
name|N_
argument_list|(
literal|"apply incoming update to move destination"
literal|"  [mine-conflict]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_conflict
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"resolve the conflict later  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"h"
block|,
name|N_
argument_list|(
literal|"help"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this help (also '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|tree_conflict_options_update_deleted
index|[]
init|=
block|{
block|{
literal|"mc"
block|,
name|N_
argument_list|(
literal|"keep affected local moves"
argument_list|)
block|,
name|N_
argument_list|(
literal|"keep any local moves affected "
literal|"by this deletion  [mine-conflict]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_conflict
block|}
block|,
block|{
literal|"r"
block|,
name|N_
argument_list|(
literal|"mark resolved (breaks moves)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"mark resolved, any affected "
literal|"moves will become copies"
argument_list|)
block|,
name|svn_wc_conflict_choose_merged
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"resolve the conflict later  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"h"
block|,
name|N_
argument_list|(
literal|"help"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this help (also '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|resolver_option_t
name|tree_conflict_options_update_replaced
index|[]
init|=
block|{
block|{
literal|"mc"
block|,
name|N_
argument_list|(
literal|"keep affected local moves"
argument_list|)
block|,
name|N_
argument_list|(
literal|"keep any moves affected by this "
literal|"replacement  [mine-conflict]"
argument_list|)
block|,
name|svn_wc_conflict_choose_mine_conflict
block|}
block|,
block|{
literal|"r"
block|,
name|N_
argument_list|(
literal|"mark resolved (breaks moves)"
argument_list|)
block|,
name|N_
argument_list|(
literal|"mark resolved (any affected "
literal|"moves will become copies)"
argument_list|)
block|,
name|svn_wc_conflict_choose_merged
block|}
block|,
block|{
literal|"p"
block|,
name|N_
argument_list|(
literal|"postpone"
argument_list|)
block|,
name|N_
argument_list|(
literal|"resolve the conflict later  [postpone]"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"q"
block|,
name|N_
argument_list|(
literal|"quit resolution"
argument_list|)
block|,
name|N_
argument_list|(
literal|"postpone all remaining conflicts"
argument_list|)
block|,
name|svn_wc_conflict_choose_postpone
block|}
block|,
block|{
literal|"h"
block|,
name|N_
argument_list|(
literal|"help"
argument_list|)
block|,
name|N_
argument_list|(
literal|"show this help (also '?')"
argument_list|)
block|,
operator|-
literal|1
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a pointer to the option description in OPTIONS matching the  * one- or two-character OPTION_CODE.  Return NULL if not found. */
end_comment

begin_function
specifier|static
specifier|const
name|resolver_option_t
modifier|*
name|find_option
parameter_list|(
specifier|const
name|resolver_option_t
modifier|*
name|options
parameter_list|,
specifier|const
name|char
modifier|*
name|option_code
parameter_list|)
block|{
specifier|const
name|resolver_option_t
modifier|*
name|opt
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|options
init|;
name|opt
operator|->
name|code
condition|;
name|opt
operator|++
control|)
block|{
comment|/* Ignore code "" (blank lines) which is not a valid answer. */
if|if
condition|(
name|opt
operator|->
name|code
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
name|option_code
argument_list|)
operator|==
literal|0
condition|)
return|return
name|opt
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Return a prompt string listing the options OPTIONS. If OPTION_CODES is  * non-null, select only the options whose codes are mentioned in it. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|prompt_string
parameter_list|(
specifier|const
name|resolver_option_t
modifier|*
name|options
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|option_codes
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
init|=
name|_
argument_list|(
literal|"Select:"
argument_list|)
decl_stmt|;
name|int
name|left_margin
init|=
name|svn_utf_cstring_utf8_width
argument_list|(
name|result
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|line_sep
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"\n%*s"
argument_list|,
name|left_margin
argument_list|,
literal|""
argument_list|)
decl_stmt|;
name|int
name|this_line_len
init|=
name|left_margin
decl_stmt|;
name|svn_boolean_t
name|first
init|=
name|TRUE
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|resolver_option_t
modifier|*
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|slen
decl_stmt|;
if|if
condition|(
name|option_codes
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|option_codes
condition|)
break|break;
name|opt
operator|=
name|find_option
argument_list|(
name|options
argument_list|,
operator|*
name|option_codes
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|opt
operator|=
name|options
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|opt
operator|->
name|code
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|first
condition|)
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|result
argument_list|,
literal|","
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|s
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|" (%s) %s"
argument_list|)
argument_list|,
name|opt
operator|->
name|code
argument_list|,
name|_
argument_list|(
name|opt
operator|->
name|short_desc
argument_list|)
argument_list|)
expr_stmt|;
name|slen
operator|=
name|svn_utf_cstring_utf8_width
argument_list|(
name|s
argument_list|)
expr_stmt|;
comment|/* Break the line if adding the next option would make it too long */
if|if
condition|(
name|this_line_len
operator|+
name|slen
operator|>
name|MAX_PROMPT_WIDTH
condition|)
block|{
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|result
argument_list|,
name|line_sep
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|this_line_len
operator|=
name|left_margin
expr_stmt|;
block|}
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|result
argument_list|,
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|this_line_len
operator|+=
name|slen
expr_stmt|;
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|result
argument_list|,
literal|": "
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a help string listing the OPTIONS. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|help_string
parameter_list|(
specifier|const
name|resolver_option_t
modifier|*
name|options
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|result
init|=
literal|""
decl_stmt|;
specifier|const
name|resolver_option_t
modifier|*
name|opt
decl_stmt|;
for|for
control|(
name|opt
operator|=
name|options
init|;
name|opt
operator|->
name|code
condition|;
name|opt
operator|++
control|)
block|{
comment|/* Append a line describing OPT, or a blank line if its code is "". */
if|if
condition|(
name|opt
operator|->
name|code
index|[
literal|0
index|]
condition|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"  (%s)"
argument_list|,
name|opt
operator|->
name|code
argument_list|)
decl_stmt|;
name|result
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s%-6s - %s\n"
argument_list|,
name|result
argument_list|,
name|s
argument_list|,
name|_
argument_list|(
name|opt
operator|->
name|long_desc
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|result
argument_list|,
literal|"\n"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|result
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|result
argument_list|,
name|_
argument_list|(
literal|"Words in square brackets are the corresponding "
literal|"--accept option arguments.\n"
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Prompt the user with CONFLICT_OPTIONS, restricted to the options listed  * in OPTIONS_TO_SHOW if that is non-null.  Set *OPT to point to the chosen  * one of CONFLICT_OPTIONS (not necessarily one of OPTIONS_TO_SHOW), or to  * NULL if the answer was not one of them.  *  * If the answer is the (globally recognized) 'help' option, then display  * the help (on stderr) and return with *OPT == NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prompt_user
parameter_list|(
specifier|const
name|resolver_option_t
modifier|*
modifier|*
name|opt
parameter_list|,
specifier|const
name|resolver_option_t
modifier|*
name|conflict_options
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|options_to_show
parameter_list|,
name|void
modifier|*
name|prompt_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|prompt
init|=
name|prompt_string
argument_list|(
name|conflict_options
argument_list|,
name|options_to_show
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|answer
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_prompt_user2
argument_list|(
operator|&
name|answer
argument_list|,
name|prompt
argument_list|,
name|prompt_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"h"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|answer
argument_list|,
literal|"?"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"\n%s\n"
argument_list|,
name|help_string
argument_list|(
name|conflict_options
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|opt
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|opt
operator|=
name|find_option
argument_list|(
name|conflict_options
argument_list|,
name|answer
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|opt
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Unrecognized option.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do about the text conflict described by DESC.  * Return the answer in RESULT. B is the conflict baton for this  * conflict resolution session.  * SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_text_conflict
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|diff_allowed
init|=
name|FALSE
decl_stmt|;
comment|/* Have they done something that might have affected the merged      file (so that we need to save a .edited copy)? */
name|svn_boolean_t
name|performed_edit
init|=
name|FALSE
decl_stmt|;
comment|/* Have they done *something* (edit, look at diff, etc) to      give them a rational basis for choosing (r)esolved? */
name|svn_boolean_t
name|knows_something
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|desc
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_text
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Conflict discovered in file '%s'.\n"
argument_list|)
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|b
operator|->
name|path_prefix
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Diffing can happen between base and merged, to show conflict      markers to the user (this is the typical 3-way merge      scenario), or if no base is available, we can show a diff      between mine and theirs. */
if|if
condition|(
operator|(
name|desc
operator|->
name|merged_file
operator|&&
name|desc
operator|->
name|base_abspath
operator|)
operator|||
operator|(
operator|!
name|desc
operator|->
name|base_abspath
operator|&&
name|desc
operator|->
name|my_abspath
operator|&&
name|desc
operator|->
name|their_abspath
operator|)
condition|)
name|diff_allowed
operator|=
name|TRUE
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|const
name|char
modifier|*
name|options
index|[
name|ARRAY_LEN
argument_list|(
name|text_conflict_options
argument_list|)
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|next_option
init|=
name|options
decl_stmt|;
specifier|const
name|resolver_option_t
modifier|*
name|opt
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"p"
expr_stmt|;
if|if
condition|(
name|diff_allowed
condition|)
block|{
operator|*
name|next_option
operator|++
operator|=
literal|"df"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"e"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"m"
expr_stmt|;
if|if
condition|(
name|knows_something
condition|)
operator|*
name|next_option
operator|++
operator|=
literal|"r"
expr_stmt|;
if|if
condition|(
operator|!
name|desc
operator|->
name|is_binary
condition|)
block|{
operator|*
name|next_option
operator|++
operator|=
literal|"mc"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"tc"
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|knows_something
condition|)
operator|*
name|next_option
operator|++
operator|=
literal|"r"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"mf"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"tf"
expr_stmt|;
block|}
operator|*
name|next_option
operator|++
operator|=
literal|"s"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt_user
argument_list|(
operator|&
name|opt
argument_list|,
name|text_conflict_options
argument_list|,
name|options
argument_list|,
name|b
operator|->
name|pb
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"q"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
name|b
operator|->
name|accept_which
operator|=
name|svn_cl__accept_postpone
expr_stmt|;
name|b
operator|->
name|quit
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"s"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"\n%s\n"
argument_list|,
name|help_string
argument_list|(
name|text_conflict_options
argument_list|,
name|iterpool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"dc"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|is_binary
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; cannot "
literal|"display conflicts for a "
literal|"binary file.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|desc
operator|->
name|my_abspath
operator|&&
name|desc
operator|->
name|base_abspath
operator|&&
name|desc
operator|->
name|their_abspath
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; original "
literal|"files not available.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|show_conflicts
argument_list|(
name|desc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|knows_something
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"df"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|diff_allowed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; there's no "
literal|"merged version to diff.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|show_diff
argument_list|(
name|desc
argument_list|,
name|b
operator|->
name|path_prefix
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|knows_something
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"e"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|":-E"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|open_editor
argument_list|(
operator|&
name|performed_edit
argument_list|,
name|desc
operator|->
name|merged_file
argument_list|,
name|b
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|performed_edit
condition|)
name|knows_something
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"m"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|":-g"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"=>-"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|":>."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|kind
operator|!=
name|svn_wc_conflict_kind_text
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; can only "
literal|"resolve text conflicts with "
literal|"the internal merge tool."
literal|"\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|desc
operator|->
name|base_abspath
operator|&&
name|desc
operator|->
name|their_abspath
operator|&&
name|desc
operator|->
name|my_abspath
operator|&&
name|desc
operator|->
name|merged_file
condition|)
block|{
name|svn_boolean_t
name|remains_in_conflict
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__merge_file
argument_list|(
name|desc
operator|->
name|base_abspath
argument_list|,
name|desc
operator|->
name|their_abspath
argument_list|,
name|desc
operator|->
name|my_abspath
argument_list|,
name|desc
operator|->
name|merged_file
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|b
operator|->
name|path_prefix
argument_list|,
name|b
operator|->
name|editor_cmd
argument_list|,
name|b
operator|->
name|config
argument_list|,
operator|&
name|remains_in_conflict
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|knows_something
operator|=
operator|!
name|remains_in_conflict
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"l"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|":-l"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ### This check should be earlier as it's nasty to offer an option            *     and then when the user chooses it say 'Invalid option'. */
comment|/* ### 'merged_file' shouldn't be necessary *before* we launch the            *     resolver: it should be the *result* of doing so. */
if|if
condition|(
name|desc
operator|->
name|base_abspath
operator|&&
name|desc
operator|->
name|their_abspath
operator|&&
name|desc
operator|->
name|my_abspath
operator|&&
name|desc
operator|->
name|merged_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|launch_resolver
argument_list|(
operator|&
name|performed_edit
argument_list|,
name|desc
argument_list|,
name|b
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|performed_edit
condition|)
name|knows_something
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|opt
operator|->
name|choice
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|opt
operator|->
name|choice
operator|==
name|svn_wc_conflict_choose_mine_conflict
operator|||
name|opt
operator|->
name|choice
operator|==
name|svn_wc_conflict_choose_theirs_conflict
operator|)
operator|&&
name|desc
operator|->
name|is_binary
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; cannot choose "
literal|"based on conflicts in a "
literal|"binary file.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* We only allow the user accept the merged version of              the file if they've edited it, or at least looked at              the diff. */
if|if
condition|(
name|opt
operator|->
name|choice
operator|==
name|svn_wc_conflict_choose_merged
operator|&&
operator|!
name|knows_something
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; use diff/edit/merge/launch "
literal|"before choosing 'mark resolved'.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
if|if
condition|(
name|performed_edit
condition|)
name|result
operator|->
name|save_merged
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do about the property conflict described by DESC.  * Return the answer in RESULT. B is the conflict baton for this  * conflict resolution session.  * SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_prop_conflict
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
specifier|const
name|char
modifier|*
name|merged_file_path
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|resolved_allowed
init|=
name|FALSE
decl_stmt|;
comment|/* ### Work around a historical bug in the provider: the path to the    *     conflict description file was put in the 'theirs' field, and    *     'theirs' was put in the 'merged' field. */
operator|(
operator|(
name|svn_wc_conflict_description2_t
operator|*
operator|)
name|desc
operator|)
operator|->
name|their_abspath
operator|=
name|desc
operator|->
name|merged_file
expr_stmt|;
operator|(
operator|(
name|svn_wc_conflict_description2_t
operator|*
operator|)
name|desc
operator|)
operator|->
name|merged_file
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|desc
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_property
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Conflict for property '%s' discovered"
literal|" on '%s'.\n"
argument_list|)
argument_list|,
name|desc
operator|->
name|property_name
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|b
operator|->
name|path_prefix
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__get_human_readable_prop_conflict_description
argument_list|(
operator|&
name|message
argument_list|,
name|desc
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|message
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
specifier|const
name|resolver_option_t
modifier|*
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|options
index|[
name|ARRAY_LEN
argument_list|(
name|prop_conflict_options
argument_list|)
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|next_option
init|=
name|options
decl_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"p"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"mf"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"tf"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"dc"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"e"
expr_stmt|;
if|if
condition|(
name|resolved_allowed
condition|)
operator|*
name|next_option
operator|++
operator|=
literal|"r"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"q"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
literal|"h"
expr_stmt|;
operator|*
name|next_option
operator|++
operator|=
name|NULL
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt_user
argument_list|(
operator|&
name|opt
argument_list|,
name|prop_conflict_options
argument_list|,
name|options
argument_list|,
name|b
operator|->
name|pb
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"q"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
name|b
operator|->
name|accept_which
operator|=
name|svn_cl__accept_postpone
expr_stmt|;
name|b
operator|->
name|quit
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"dc"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|show_prop_conflict
argument_list|(
name|desc
argument_list|,
name|merged_file_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"e"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|edit_prop_conflict
argument_list|(
operator|&
name|merged_file_path
argument_list|,
name|desc
argument_list|,
name|b
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|resolved_allowed
operator|=
operator|(
name|merged_file_path
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"r"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|resolved_allowed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"Invalid option; please edit the property "
literal|"first.\n\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|result
operator|->
name|merged_file
operator|=
name|merged_file_path
expr_stmt|;
name|result
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_merged
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|opt
operator|->
name|choice
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do about the tree conflict described by DESC.  * Return the answer in RESULT. B is the conflict baton for this  * conflict resolution session.  * SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_tree_conflict
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|readable_desc
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__get_human_readable_tree_conflict_description
argument_list|(
operator|&
name|readable_desc
argument_list|,
name|desc
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Tree conflict on '%s'\n> %s\n"
argument_list|)
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|b
operator|->
name|path_prefix
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|readable_desc
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|resolver_option_t
modifier|*
name|opt
decl_stmt|;
specifier|const
name|resolver_option_t
modifier|*
name|tc_opts
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|->
name|operation
operator|==
name|svn_wc_operation_update
operator|||
name|desc
operator|->
name|operation
operator|==
name|svn_wc_operation_switch
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
condition|)
block|{
if|if
condition|(
name|desc
operator|->
name|action
operator|==
name|svn_wc_conflict_action_edit
condition|)
name|tc_opts
operator|=
name|tree_conflict_options_update_edit_moved_away
expr_stmt|;
else|else
name|tc_opts
operator|=
name|tree_conflict_options_update_moved_away
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|desc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
condition|)
name|tc_opts
operator|=
name|tree_conflict_options_update_deleted
expr_stmt|;
elseif|else
if|if
condition|(
name|desc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_replaced
condition|)
name|tc_opts
operator|=
name|tree_conflict_options_update_replaced
expr_stmt|;
else|else
name|tc_opts
operator|=
name|tree_conflict_options
expr_stmt|;
block|}
else|else
name|tc_opts
operator|=
name|tree_conflict_options
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt_user
argument_list|(
operator|&
name|opt
argument_list|,
name|tc_opts
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|pb
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"q"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
name|b
operator|->
name|accept_which
operator|=
name|svn_cl__accept_postpone
expr_stmt|;
name|b
operator|->
name|quit
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|opt
operator|->
name|choice
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Ask the user what to do about the obstructed add described by DESC.  * Return the answer in RESULT. B is the conflict baton for this  * conflict resolution session.  * SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_obstructed_add
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Conflict discovered when trying to add '%s'.\n"
literal|"An object of the same name already exists.\n"
argument_list|)
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|b
operator|->
name|path_prefix
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|resolver_option_t
modifier|*
name|opt
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prompt_user
argument_list|(
operator|&
name|opt
argument_list|,
name|obstructed_add_options
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|pb
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|opt
operator|->
name|code
argument_list|,
literal|"q"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
name|b
operator|->
name|accept_which
operator|=
name|svn_cl__accept_postpone
expr_stmt|;
name|b
operator|->
name|quit
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|opt
operator|->
name|choice
operator|!=
operator|-
literal|1
condition|)
block|{
name|result
operator|->
name|choice
operator|=
name|opt
operator|->
name|choice
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The body of svn_cl__conflict_func_interactive(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict_func_interactive
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Start out assuming we're going to postpone the conflict. */
operator|*
name|result
operator|=
name|svn_wc_create_conflict_result
argument_list|(
name|svn_wc_conflict_choose_postpone
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|b
operator|->
name|accept_which
condition|)
block|{
case|case
name|svn_cl__accept_invalid
case|:
case|case
name|svn_cl__accept_unspecified
case|:
comment|/* No (or no valid) --accept option, fall through to prompting. */
break|break;
case|case
name|svn_cl__accept_postpone
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_postpone
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_cl__accept_base
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_base
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_cl__accept_working
case|:
comment|/* If the caller didn't merge the property values, then I guess        * 'choose working' means 'choose mine'... */
if|if
condition|(
operator|!
name|desc
operator|->
name|merged_file
condition|)
operator|(
operator|*
name|result
operator|)
operator|->
name|merged_file
operator|=
name|desc
operator|->
name|my_abspath
expr_stmt|;
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_merged
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_cl__accept_mine_conflict
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_mine_conflict
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_cl__accept_theirs_conflict
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_theirs_conflict
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_cl__accept_mine_full
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_mine_full
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_cl__accept_theirs_full
case|:
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_theirs_full
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_cl__accept_edit
case|:
if|if
condition|(
name|desc
operator|->
name|merged_file
condition|)
block|{
if|if
condition|(
name|b
operator|->
name|external_failed
condition|)
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_postpone
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|err
operator|=
name|svn_cmdline__edit_file_externally
argument_list|(
name|desc
operator|->
name|merged_file
argument_list|,
name|b
operator|->
name|editor_cmd
argument_list|,
name|b
operator|->
name|config
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"No editor found;"
literal|" leaving all conflicts."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|b
operator|->
name|external_failed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_EXTERNAL_PROGRAM
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"Error running editor;"
literal|" leaving all conflicts."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|b
operator|->
name|external_failed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_merged
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* else, fall through to prompting. */
break|break;
case|case
name|svn_cl__accept_launch
case|:
if|if
condition|(
name|desc
operator|->
name|base_abspath
operator|&&
name|desc
operator|->
name|their_abspath
operator|&&
name|desc
operator|->
name|my_abspath
operator|&&
name|desc
operator|->
name|merged_file
condition|)
block|{
name|svn_boolean_t
name|remains_in_conflict
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|external_failed
condition|)
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_postpone
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|err
operator|=
name|svn_cl__merge_file_externally
argument_list|(
name|desc
operator|->
name|base_abspath
argument_list|,
name|desc
operator|->
name|their_abspath
argument_list|,
name|desc
operator|->
name|my_abspath
argument_list|,
name|desc
operator|->
name|merged_file
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|b
operator|->
name|config
argument_list|,
operator|&
name|remains_in_conflict
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"No merge tool found;"
literal|" leaving all conflicts."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|external_failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_EXTERNAL_PROGRAM
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|err
operator|->
name|message
condition|?
name|err
operator|->
name|message
else|:
name|_
argument_list|(
literal|"Error running merge tool;"
literal|" leaving all conflicts."
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|external_failed
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|remains_in_conflict
condition|)
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_postpone
expr_stmt|;
else|else
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_merged
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* else, fall through to prompting. */
break|break;
block|}
comment|/* We're in interactive mode and either the user gave no --accept      option or the option did not apply; let's prompt. */
comment|/* Handle the most common cases, which is either:       Conflicting edits on a file's text, or      Conflicting edits on a property.   */
if|if
condition|(
operator|(
operator|(
name|desc
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_text
operator|)
operator|&&
operator|(
name|desc
operator|->
name|action
operator|==
name|svn_wc_conflict_action_edit
operator|)
operator|&&
operator|(
name|desc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_edited
operator|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|handle_text_conflict
argument_list|(
operator|*
name|result
argument_list|,
name|desc
argument_list|,
name|b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|desc
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_property
condition|)
name|SVN_ERR
argument_list|(
name|handle_prop_conflict
argument_list|(
operator|*
name|result
argument_list|,
name|desc
argument_list|,
name|b
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*     Dealing with obstruction of additions can be tricky.  The     obstructing item could be unversioned, versioned, or even     schedule-add.  Here's a matrix of how the caller should behave,     based on results we return.                           Unversioned       Versioned       Schedule-Add        choose_mine       skip addition,    skip addition     skip addition                         add existing item        choose_theirs     destroy file,    schedule-delete,   revert add,                         add new item.    add new item.      rm file,                                                             add new item        postpone               [              bail out                 ]     */
elseif|else
if|if
condition|(
operator|(
name|desc
operator|->
name|action
operator|==
name|svn_wc_conflict_action_add
operator|)
operator|&&
operator|(
name|desc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_obstructed
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|handle_obstructed_add
argument_list|(
operator|*
name|result
argument_list|,
name|desc
argument_list|,
name|b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|desc
operator|->
name|kind
operator|==
name|svn_wc_conflict_kind_tree
condition|)
name|SVN_ERR
argument_list|(
name|handle_tree_conflict
argument_list|(
operator|*
name|result
argument_list|,
name|desc
argument_list|,
name|b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* other types of conflicts -- do nothing about them. */
block|{
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|=
name|svn_wc_conflict_choose_postpone
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__conflict_func_interactive
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|desc
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_cl__interactive_conflict_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|conflict_func_interactive
argument_list|(
name|result
argument_list|,
name|desc
argument_list|,
name|baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are resolving a conflict, adjust the summary of conflicts. */
if|if
condition|(
operator|(
operator|*
name|result
operator|)
operator|->
name|choice
operator|!=
name|svn_wc_conflict_choose_postpone
condition|)
block|{
specifier|const
name|char
modifier|*
name|local_path
init|=
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|b
operator|->
name|path_prefix
argument_list|,
name|desc
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_cl__conflict_stats_resolved
argument_list|(
name|b
operator|->
name|conflict_stats
argument_list|,
name|local_path
argument_list|,
name|desc
operator|->
name|kind
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

