begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * util.c: Subversion command line client utility functions. Any  * functions that need to be shared across subcommands should be put  * in here.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_env.h>
end_include

begin_include
include|#
directive|include
file|<apr_errno.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_info.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_token.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_opt_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_ORGANIZATION_NAME
end_ifdef

begin_include
include|#
directive|include
file|"freebsd-organization.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_function
name|svn_error_t
modifier|*
name|svn_cl__print_commit_info
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|commit_info
operator|->
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"\nCommitted revision %ld%s.\n"
argument_list|)
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|,
name|commit_info
operator|->
name|revision
operator|==
literal|42
operator|&&
name|getenv
argument_list|(
literal|"SVN_I_LOVE_PANGALACTIC_GARGLE_BLASTERS"
argument_list|)
condition|?
name|_
argument_list|(
literal|" (the answer to life, the universe, "
literal|"and everything)"
argument_list|)
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Writing to stdout, as there maybe systems that consider the    * presence of stderr as an indication of commit failure.    * OTOH, this is only of informational nature to the user as    * the commit has succeeded. */
if|if
condition|(
name|commit_info
operator|->
name|post_commit_err
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"\nWarning: %s\n"
argument_list|)
argument_list|,
name|commit_info
operator|->
name|post_commit_err
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__merge_file_externally
parameter_list|(
specifier|const
name|char
modifier|*
name|base_path
parameter_list|,
specifier|const
name|char
modifier|*
name|their_path
parameter_list|,
specifier|const
name|char
modifier|*
name|my_path
parameter_list|,
specifier|const
name|char
modifier|*
name|merged_path
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_path
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|svn_boolean_t
modifier|*
name|remains_in_conflict
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|char
modifier|*
name|merge_tool
decl_stmt|;
comment|/* Error if there is no editor specified */
if|if
condition|(
name|apr_env_get
argument_list|(
operator|&
name|merge_tool
argument_list|,
literal|"SVN_MERGE"
argument_list|,
name|pool
argument_list|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|struct
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
name|merge_tool
operator|=
name|NULL
expr_stmt|;
name|cfg
operator|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* apr_env_get wants char **, this wants const char ** */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|merge_tool
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_MERGE_TOOL_CMD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_tool
condition|)
block|{
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
name|merge_tool
init|;
operator|*
name|c
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|svn_ctype_isspace
argument_list|(
operator|*
name|c
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|!
operator|*
name|c
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The SVN_MERGE environment variable is empty or "
literal|"consists solely of whitespace. Expected a shell command.\n"
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_NO_EXTERNAL_MERGE_TOOL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The environment variable SVN_MERGE and the merge-tool-cmd run-time "
literal|"configuration option were not set.\n"
argument_list|)
argument_list|)
return|;
block|{
specifier|const
name|char
modifier|*
name|arguments
index|[
literal|7
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
name|char
modifier|*
name|cwd
decl_stmt|;
name|int
name|exitcode
decl_stmt|;
name|apr_status_t
name|status
init|=
name|apr_filepath_get
argument_list|(
operator|&
name|cwd
argument_list|,
name|APR_FILEPATH_NATIVE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|status
operator|!=
literal|0
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|)
return|;
name|arguments
index|[
literal|0
index|]
operator|=
name|merge_tool
expr_stmt|;
name|arguments
index|[
literal|1
index|]
operator|=
name|base_path
expr_stmt|;
name|arguments
index|[
literal|2
index|]
operator|=
name|their_path
expr_stmt|;
name|arguments
index|[
literal|3
index|]
operator|=
name|my_path
expr_stmt|;
name|arguments
index|[
literal|4
index|]
operator|=
name|merged_path
expr_stmt|;
name|arguments
index|[
literal|5
index|]
operator|=
name|wc_path
expr_stmt|;
name|arguments
index|[
literal|6
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_run_cmd
argument_list|(
name|svn_dirent_internal_style
argument_list|(
name|cwd
argument_list|,
name|pool
argument_list|)
argument_list|,
name|merge_tool
argument_list|,
name|arguments
argument_list|,
operator|&
name|exitcode
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Exit code 0 means the merge was successful.      * Exit code 1 means the file was left in conflict but it      * is OK to continue with the merge.      * Any other exit code means there was a real problem. */
if|if
condition|(
name|exitcode
operator|!=
literal|0
operator|&&
name|exitcode
operator|!=
literal|1
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_EXTERNAL_PROGRAM
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The external merge tool exited with exit code %d"
argument_list|)
argument_list|,
name|exitcode
argument_list|)
return|;
elseif|else
if|if
condition|(
name|remains_in_conflict
condition|)
operator|*
name|remains_in_conflict
operator|=
name|exitcode
operator|==
literal|1
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A svn_client_ctx_t's log_msg_baton3, for use with    svn_cl__make_log_msg_baton(). */
end_comment

begin_struct
struct|struct
name|log_msg_baton
block|{
specifier|const
name|char
modifier|*
name|editor_cmd
decl_stmt|;
comment|/* editor specified via --editor-cmd, else NULL */
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
comment|/* the message. */
specifier|const
name|char
modifier|*
name|message_encoding
decl_stmt|;
comment|/* the locale/encoding of the message. */
specifier|const
name|char
modifier|*
name|base_dir
decl_stmt|;
comment|/* the base directory for an external edit. UTF-8! */
specifier|const
name|char
modifier|*
name|tmpfile_left
decl_stmt|;
comment|/* the tmpfile left by an external edit. UTF-8! */
name|svn_boolean_t
name|non_interactive
decl_stmt|;
comment|/* if true, don't pop up an editor */
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
comment|/* client configuration hash */
name|svn_boolean_t
name|keep_locks
decl_stmt|;
comment|/* Keep repository locks? */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* a pool. */
block|}
struct|;
end_struct

begin_function
name|svn_error_t
modifier|*
name|svn_cl__make_log_msg_baton
parameter_list|(
name|void
modifier|*
modifier|*
name|baton
parameter_list|,
name|svn_cl__opt_state_t
modifier|*
name|opt_state
parameter_list|,
specifier|const
name|char
modifier|*
name|base_dir
comment|/* UTF-8! */
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_msg_baton
modifier|*
name|lmb
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lmb
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|filedata
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|opt_state
operator|->
name|filedata
operator|->
name|data
argument_list|)
operator|<
name|opt_state
operator|->
name|filedata
operator|->
name|len
condition|)
block|{
comment|/* The data contains a zero byte, and therefore can't be              represented as a C string.  Punt now; it's probably not              a deliberate encoding, and even if it is, we still              can't handle it. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_BAD_LOG_MESSAGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Log message contains a zero byte"
argument_list|)
argument_list|)
return|;
block|}
name|lmb
operator|->
name|message
operator|=
name|opt_state
operator|->
name|filedata
operator|->
name|data
expr_stmt|;
block|}
else|else
block|{
name|lmb
operator|->
name|message
operator|=
name|opt_state
operator|->
name|message
expr_stmt|;
block|}
name|lmb
operator|->
name|editor_cmd
operator|=
name|opt_state
operator|->
name|editor_cmd
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|encoding
condition|)
block|{
name|lmb
operator|->
name|message_encoding
operator|=
name|opt_state
operator|->
name|encoding
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|config
condition|)
block|{
name|svn_config_t
modifier|*
name|cfg
init|=
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
decl_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
operator|(
name|lmb
operator|->
name|message_encoding
operator|)
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_LOG_ENCODING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|lmb
operator|->
name|base_dir
operator|=
name|base_dir
condition|?
name|base_dir
else|:
literal|""
expr_stmt|;
name|lmb
operator|->
name|tmpfile_left
operator|=
name|NULL
expr_stmt|;
name|lmb
operator|->
name|config
operator|=
name|config
expr_stmt|;
name|lmb
operator|->
name|keep_locks
operator|=
name|opt_state
operator|->
name|no_unlock
expr_stmt|;
name|lmb
operator|->
name|non_interactive
operator|=
name|opt_state
operator|->
name|non_interactive
expr_stmt|;
name|lmb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
operator|*
name|baton
operator|=
name|lmb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__cleanup_log_msg
parameter_list|(
name|void
modifier|*
name|log_msg_baton
parameter_list|,
name|svn_error_t
modifier|*
name|commit_err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_msg_baton
modifier|*
name|lmb
init|=
name|log_msg_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* If there was no tmpfile left, or there is no log message baton,      return COMMIT_ERR. */
if|if
condition|(
operator|(
operator|!
name|lmb
operator|)
operator|||
operator|(
operator|!
name|lmb
operator|->
name|tmpfile_left
operator|)
condition|)
return|return
name|commit_err
return|;
comment|/* If there was no commit error, cleanup the tmpfile and return. */
if|if
condition|(
operator|!
name|commit_err
condition|)
return|return
name|svn_io_remove_file2
argument_list|(
name|lmb
operator|->
name|tmpfile_left
argument_list|,
name|FALSE
argument_list|,
name|lmb
operator|->
name|pool
argument_list|)
return|;
comment|/* There was a commit error; there is a tmpfile.  Leave the tmpfile      around, and add message about its presence to the commit error      chain.  Then return COMMIT_ERR.  If the conversion from UTF-8 to      native encoding fails, we have to compose that error with the      commit error chain, too. */
name|err
operator|=
name|svn_error_createf
argument_list|(
name|commit_err
operator|->
name|apr_err
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"   '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|lmb
operator|->
name|tmpfile_left
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_compose
argument_list|(
name|commit_err
argument_list|,
name|svn_error_create
argument_list|(
name|commit_err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Your commit message was left in "
literal|"a temporary file:"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|commit_err
return|;
block|}
end_function

begin_comment
comment|/* Remove line-starting PREFIX and everything after it from BUFFER.    If NEW_LEN is non-NULL, return the new length of BUFFER in    *NEW_LEN.  */
end_comment

begin_function
specifier|static
name|void
name|truncate_buffer_at_prefix
parameter_list|(
name|apr_size_t
modifier|*
name|new_len
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
specifier|const
name|char
modifier|*
name|prefix
parameter_list|)
block|{
name|char
modifier|*
name|substring
init|=
name|buffer
decl_stmt|;
name|assert
argument_list|(
name|buffer
operator|&&
name|prefix
argument_list|)
expr_stmt|;
comment|/* Initialize *NEW_LEN. */
if|if
condition|(
name|new_len
condition|)
operator|*
name|new_len
operator|=
name|strlen
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Find PREFIX in BUFFER. */
name|substring
operator|=
name|strstr
argument_list|(
name|substring
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|substring
condition|)
return|return;
comment|/* We found PREFIX.  Is it really a PREFIX?  Well, if it's the first          thing in the file, or if the character before it is a          line-terminator character, it sure is. */
if|if
condition|(
operator|(
name|substring
operator|==
name|buffer
operator|)
operator|||
operator|(
operator|*
operator|(
name|substring
operator|-
literal|1
operator|)
operator|==
literal|'\r'
operator|)
operator|||
operator|(
operator|*
operator|(
name|substring
operator|-
literal|1
operator|)
operator|==
literal|'\n'
operator|)
condition|)
block|{
operator|*
name|substring
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|new_len
condition|)
operator|*
name|new_len
operator|=
name|substring
operator|-
name|buffer
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|substring
condition|)
block|{
comment|/* Well, it wasn't really a prefix, so just advance by 1              character and continue. */
name|substring
operator|++
expr_stmt|;
block|}
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Since we're adding freebsd-specific tokens to the log message,  * clean out any leftovers to avoid accidently sending them to other  * projects that won't be expecting them.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|prefixes
index|[]
init|=
block|{
literal|"PR:"
block|,
literal|"Submitted by:"
block|,
literal|"Reviewed by:"
block|,
literal|"Approved by:"
block|,
literal|"Obtained from:"
block|,
literal|"MFC after:"
block|,
literal|"MFH:"
block|,
literal|"Relnotes:"
block|,
literal|"Security:"
block|,
literal|"Sponsored by:"
block|,
literal|"Differential Revision:"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|cleanmsg
parameter_list|(
name|apr_size_t
modifier|*
name|l
parameter_list|,
name|char
modifier|*
name|s
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|char
modifier|*
name|kw
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|empty
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|prefixes
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|prefixes
index|[
literal|0
index|]
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|pos
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|(
name|kw
operator|=
name|strstr
argument_list|(
name|pos
argument_list|,
name|prefixes
index|[
name|i
index|]
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Check to see if keyword is at start of line (or buffer) */
if|if
condition|(
operator|!
operator|(
name|kw
operator|==
name|s
operator|||
name|kw
index|[
operator|-
literal|1
index|]
operator|==
literal|'\r'
operator|||
name|kw
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|pos
operator|=
name|kw
operator|+
literal|1
expr_stmt|;
continue|continue;
block|}
name|p
operator|=
name|kw
operator|+
name|strlen
argument_list|(
name|prefixes
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|empty
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
operator|||
operator|*
name|p
operator|==
literal|'\t'
condition|)
block|{
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|'\0'
operator|||
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
condition|)
break|break;
name|empty
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|empty
operator|&&
operator|(
operator|*
name|p
operator|==
literal|'\r'
operator|||
operator|*
name|p
operator|==
literal|'\n'
operator|)
condition|)
block|{
name|memmove
argument_list|(
name|kw
argument_list|,
name|p
operator|+
literal|1
argument_list|,
name|strlen
argument_list|(
name|p
operator|+
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
condition|)
operator|*
name|l
operator|-=
operator|(
name|p
operator|+
literal|1
operator|-
name|kw
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|empty
condition|)
block|{
operator|*
name|kw
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|l
condition|)
operator|*
name|l
operator|-=
operator|(
name|p
operator|-
name|kw
operator|)
expr_stmt|;
block|}
else|else
block|{
name|pos
operator|=
name|p
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_define
define|#
directive|define
name|EDITOR_EOF_PREFIX
value|_("--This line, and those below, will be ignored--")
end_define

begin_function
name|svn_error_t
modifier|*
name|svn_cl__get_log_message
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|log_msg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_file
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|commit_items
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|default_msg
init|=
name|NULL
decl_stmt|;
name|struct
name|log_msg_baton
modifier|*
name|lmb
init|=
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
specifier|const
name|char
modifier|*
name|mfc_after
decl_stmt|,
modifier|*
name|sponsored_by
decl_stmt|;
name|cfg
operator|=
name|lmb
operator|->
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|lmb
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Set default message.  */
name|default_msg
operator|=
name|svn_stringbuf_create
argument_list|(
name|APR_EOL_STR
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"PR:\t\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Submitted by:\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Reviewed by:\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Approved by:\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Obtained from:\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"MFC after:\t"
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|mfc_after
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
literal|"freebsd-mfc-after"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|mfc_after
operator|!=
name|NULL
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|mfc_after
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"MFH:\t\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Relnotes:\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Security:\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Sponsored by:\t"
argument_list|)
expr_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|sponsored_by
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
literal|"freebsd-sponsored-by"
argument_list|,
ifdef|#
directive|ifdef
name|HAS_ORGANIZATION_NAME
name|ORGANIZATION_NAME
argument_list|)
expr_stmt|;
else|#
directive|else
name|NULL
block|)
function|;
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|if
condition|(
name|sponsored_by
operator|!=
name|NULL
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|sponsored_by
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"Differential Revision:\t"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|EDITOR_EOF_PREFIX
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Description of fields to fill in above:                     76 columns --|"
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> PR:                       If a GNATS PR is affected by the change."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Submitted by:             If someone else sent in the change."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Reviewed by:              If someone else reviewed your modification."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Approved by:              If you needed approval for this commit."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Obtained from:            If the change is from a third party."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> MFC after:                N [day[s]|week[s]|month[s]].  Request a reminder email."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> MFH:                      Ports tree branch name.  Request approval for merge."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Relnotes:                 Set to 'yes' for mention in release notes."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Security:                 Vulnerability reference (one per line) or description."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Sponsored by:             If the change was sponsored by an organization."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Differential Revision:    https://reviews.freebsd.org/D### (*full* phabric URL needed)."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
literal|"> Empty fields above will be automatically removed."
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|svn_stringbuf_appendcstr
argument_list|(
name|default_msg
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|*
name|tmp_file
operator|=
name|NULL
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|lmb
operator|->
name|message
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|log_msg_buf
init|=
name|svn_stringbuf_create
argument_list|(
name|lmb
operator|->
name|message
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|log_msg_str
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|log_msg_str
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Trim incoming messages of the EOF marker text and the junk          that follows it.  */
name|truncate_buffer_at_prefix
argument_list|(
operator|&
operator|(
name|log_msg_buf
operator|->
name|len
operator|)
argument_list|,
name|log_msg_buf
operator|->
name|data
argument_list|,
name|EDITOR_EOF_PREFIX
argument_list|)
expr_stmt|;
name|cleanmsg
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|log_msg_buf
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Make a string from a stringbuf, sharing the data allocation. */
name|log_msg_str
operator|->
name|data
operator|=
name|log_msg_buf
operator|->
name|data
expr_stmt|;
name|log_msg_str
operator|->
name|len
operator|=
name|log_msg_buf
operator|->
name|len
expr_stmt|;
name|SVN_ERR_W
argument_list|(
name|svn_subst_translate_string2
argument_list|(
operator|&
name|log_msg_str
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|log_msg_str
argument_list|,
name|lmb
operator|->
name|message_encoding
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Error normalizing log message to internal format"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|log_msg
operator|=
name|log_msg_str
operator|->
name|data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_if

begin_if
if|if
condition|(
operator|!
name|commit_items
operator|->
name|nelts
condition|)
block|{
operator|*
name|log_msg
operator|=
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_if

begin_while
while|while
condition|(
operator|!
name|message
condition|)
block|{
comment|/* We still don't have a valid commit message.  Use $EDITOR to          get one.  Note that svn_cl__edit_string_externally will still          return a UTF-8'ized log message. */
name|int
name|i
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|tmp_message
init|=
name|svn_stringbuf_dup
argument_list|(
name|default_msg
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_string_t
modifier|*
name|msg_string
init|=
name|svn_string_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|item
operator|->
name|path
decl_stmt|;
name|char
name|text_mod
init|=
literal|'_'
decl_stmt|,
name|prop_mod
init|=
literal|' '
decl_stmt|,
name|unlock
init|=
literal|' '
decl_stmt|;
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
name|item
operator|->
name|url
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|*
name|path
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
operator|&&
name|lmb
operator|->
name|base_dir
condition|)
name|path
operator|=
name|svn_dirent_is_child
argument_list|(
name|lmb
operator|->
name|base_dir
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If still no path, then just use current directory. */
if|if
condition|(
operator|!
name|path
condition|)
name|path
operator|=
literal|"."
expr_stmt|;
if|if
condition|(
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
operator|)
operator|&&
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
condition|)
name|text_mod
operator|=
literal|'R'
expr_stmt|;
elseif|else
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
condition|)
name|text_mod
operator|=
literal|'A'
expr_stmt|;
elseif|else
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
condition|)
name|text_mod
operator|=
literal|'D'
expr_stmt|;
elseif|else
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
condition|)
name|text_mod
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
condition|)
name|prop_mod
operator|=
literal|'M'
expr_stmt|;
if|if
condition|(
operator|!
name|lmb
operator|->
name|keep_locks
operator|&&
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN
condition|)
name|unlock
operator|=
literal|'U'
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|tmp_message
argument_list|,
name|text_mod
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|tmp_message
argument_list|,
name|prop_mod
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|tmp_message
argument_list|,
name|unlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_IS_COPY
condition|)
comment|/* History included via copy/move. */
name|svn_stringbuf_appendcstr
argument_list|(
name|tmp_message
argument_list|,
literal|"+ "
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_appendcstr
argument_list|(
name|tmp_message
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|tmp_message
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|tmp_message
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
block|}
name|msg_string
operator|->
name|data
operator|=
name|tmp_message
operator|->
name|data
expr_stmt|;
name|msg_string
operator|->
name|len
operator|=
name|tmp_message
operator|->
name|len
expr_stmt|;
comment|/* Use the external edit to get a log message. */
if|if
condition|(
operator|!
name|lmb
operator|->
name|non_interactive
condition|)
block|{
name|err
operator|=
name|svn_cmdline__edit_string_externally
argument_list|(
operator|&
name|msg_string
argument_list|,
operator|&
name|lmb
operator|->
name|tmpfile_left
argument_list|,
name|lmb
operator|->
name|editor_cmd
argument_list|,
name|lmb
operator|->
name|base_dir
argument_list|,
name|msg_string
argument_list|,
literal|"svn-commit"
argument_list|,
name|lmb
operator|->
name|config
argument_list|,
name|TRUE
argument_list|,
name|lmb
operator|->
name|message_encoding
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* non_interactive flag says we can't pop up an editor, so error */
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot invoke editor to get log message "
literal|"when non-interactive"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Dup the tmpfile path into its baton's pool. */
operator|*
name|tmp_file
operator|=
name|lmb
operator|->
name|tmpfile_left
operator|=
name|apr_pstrdup
argument_list|(
name|lmb
operator|->
name|pool
argument_list|,
name|lmb
operator|->
name|tmpfile_left
argument_list|)
expr_stmt|;
comment|/* If the edit returned an error, handle it. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_NO_EXTERNAL_EDITOR
condition|)
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Could not use external editor to fetch log message; "
literal|"consider setting the $SVN_EDITOR environment variable "
literal|"or using the --message (-m) or --file (-F) options"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|msg_string
condition|)
name|message
operator|=
name|svn_stringbuf_create_from_string
argument_list|(
name|msg_string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Strip the prefix from the buffer. */
if|if
condition|(
name|message
condition|)
name|truncate_buffer_at_prefix
argument_list|(
operator|&
name|message
operator|->
name|len
argument_list|,
name|message
operator|->
name|data
argument_list|,
name|EDITOR_EOF_PREFIX
argument_list|)
expr_stmt|;
comment|/*        * Since we're adding freebsd-specific tokens to the log message,        * clean out any leftovers to avoid accidently sending them to other        * projects that won't be expecting them.        */
if|if
condition|(
name|message
condition|)
name|cleanmsg
argument_list|(
operator|&
name|message
operator|->
name|len
argument_list|,
name|message
operator|->
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
block|{
comment|/* We did get message, now check if it is anything more than just              white space as we will consider white space only as empty */
name|apr_size_t
name|len
decl_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|len
operator|<
name|message
operator|->
name|len
condition|;
name|len
operator|++
control|)
block|{
comment|/* FIXME: should really use an UTF-8 whitespace test                  rather than svn_ctype_isspace, which is ASCII only */
if|if
condition|(
operator|!
name|svn_ctype_isspace
argument_list|(
name|message
operator|->
name|data
index|[
name|len
index|]
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|len
operator|==
name|message
operator|->
name|len
condition|)
name|message
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|message
condition|)
block|{
specifier|const
name|char
modifier|*
name|reply
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_prompt_user2
argument_list|(
operator|&
name|reply
argument_list|,
name|_
argument_list|(
literal|"\nLog message unchanged or not specified\n"
literal|"(a)bort, (c)ontinue, (e)dit:\n"
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reply
condition|)
block|{
name|int
name|letter
init|=
name|apr_tolower
argument_list|(
name|reply
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
comment|/* If the user chooses to abort, we cleanup the                  temporary file and exit the loop with a NULL                  message. */
if|if
condition|(
literal|'a'
operator|==
name|letter
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|lmb
operator|->
name|tmpfile_left
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tmp_file
operator|=
name|lmb
operator|->
name|tmpfile_left
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
comment|/* If the user chooses to continue, we make an empty                  message, which will cause us to exit the loop.  We                  also cleanup the temporary file. */
if|if
condition|(
literal|'c'
operator|==
name|letter
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|lmb
operator|->
name|tmpfile_left
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|tmp_file
operator|=
name|lmb
operator|->
name|tmpfile_left
operator|=
name|NULL
expr_stmt|;
name|message
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the user chooses anything else, the loop will                  continue on the NULL message. */
block|}
block|}
block|}
end_while

begin_expr_stmt
operator|*
name|log_msg
operator|=
name|message
condition|?
name|message
operator|->
name|data
else|:
name|NULL
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|SVN_NO_ERROR
return|;
end_return

begin_comment
unit|}
comment|/* ### The way our error wrapping currently works, the error returned  * from here will look as though it originates in this source file,  * instead of in the caller's source file.  This can be a bit  * misleading, until one starts debugging.  Ideally, there'd be a way  * to wrap an error while preserving its FILE/LINE info.  */
end_comment

begin_expr_stmt
unit|svn_error_t
operator|*
name|svn_cl__may_need_force
argument_list|(
argument|svn_error_t *err
argument_list|)
block|{
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_UNVERSIONED_RESOURCE
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_MODIFIED
operator|)
condition|)
block|{
comment|/* Should this svn_error_compose a new error number? Probably not,          the error hasn't changed. */
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Use --force to override this restriction (local modifications "
literal|"may be lost)"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_expr_stmt

begin_return
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
end_return

begin_expr_stmt
unit|}   svn_error_t
operator|*
name|svn_cl__error_checked_fputs
argument_list|(
argument|const char *string
argument_list|,
argument|FILE* stream
argument_list|)
block|{
comment|/* On POSIX systems, errno will be set on an error in fputs, but this might      not be the case on other platforms.  We reset errno and only      use it if it was set by the below fputs call.  Else, we just return      a generic error. */
name|errno
operator|=
literal|0
block|;
if|if
condition|(
name|fputs
argument_list|(
name|string
argument_list|,
name|stream
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|errno
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|errno
argument_list|,
name|_
argument_list|(
literal|"Write error"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_expr_stmt

begin_return
return|return
name|SVN_NO_ERROR
return|;
end_return

begin_expr_stmt
unit|}   svn_error_t
operator|*
name|svn_cl__try
argument_list|(
argument|svn_error_t *err
argument_list|,
argument|apr_array_header_t *errors_seen
argument_list|,
argument|svn_boolean_t quiet
argument_list|,
argument|...
argument_list|)
block|{
if|if
condition|(
name|err
condition|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|quiet
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|apr_err
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|apr_status_t
argument_list|)
operator|)
operator|!=
name|APR_SUCCESS
condition|)
block|{
if|if
condition|(
name|errors_seen
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|add
init|=
name|TRUE
decl_stmt|;
comment|/* Don't report duplicate error codes. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|errors_seen
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|APR_ARRAY_IDX
argument_list|(
name|errors_seen
argument_list|,
name|i
argument_list|,
name|apr_status_t
argument_list|)
operator|==
name|err
operator|->
name|apr_err
condition|)
block|{
name|add
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
end_expr_stmt

begin_expr_stmt
unit|}               if
operator|(
name|add
operator|)
name|APR_ARRAY_PUSH
argument_list|(
name|errors_seen
argument_list|,
name|apr_status_t
argument_list|)
operator|=
name|err
operator|->
name|apr_err
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}           if
operator|(
name|err
operator|->
name|apr_err
operator|==
name|apr_err
operator|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
name|SVN_NO_ERROR
return|;
end_return

begin_expr_stmt
unit|}         }
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}    return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
unit|}   void
name|svn_cl__xml_tagged_cdata
argument_list|(
argument|svn_stringbuf_t **sb
argument_list|,
argument|apr_pool_t *pool
argument_list|,
argument|const char *tagname
argument_list|,
argument|const char *string
argument_list|)
end_macro

begin_block
block|{
if|if
condition|(
name|string
condition|)
block|{
name|svn_xml_make_open_tag
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_protect_pcdata
argument_list|,
name|tagname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_xml_escape_cdata_cstring
argument_list|(
name|sb
argument_list|,
name|string
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|void
name|svn_cl__print_xml_commit
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|sb
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|author
parameter_list|,
specifier|const
name|char
modifier|*
name|date
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* "<commit ...>" */
name|svn_xml_make_open_tag
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"commit"
argument_list|,
literal|"revision"
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|revision
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* "<author>xx</author>" */
if|if
condition|(
name|author
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"author"
argument_list|,
name|author
argument_list|)
expr_stmt|;
comment|/* "<date>xx</date>" */
if|if
condition|(
name|date
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"date"
argument_list|,
name|date
argument_list|)
expr_stmt|;
comment|/* "</commit>" */
name|svn_xml_make_close_tag
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"commit"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_cl__print_xml_lock
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|sb
parameter_list|,
specifier|const
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* "<lock>" */
name|svn_xml_make_open_tag
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"lock"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* "<token>xx</token>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"token"
argument_list|,
name|lock
operator|->
name|token
argument_list|)
expr_stmt|;
comment|/* "<owner>xx</owner>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"owner"
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
expr_stmt|;
comment|/* "<comment>xx</comment>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"comment"
argument_list|,
name|lock
operator|->
name|comment
argument_list|)
expr_stmt|;
comment|/* "<created>xx</created>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"created"
argument_list|,
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|creation_date
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "<expires>xx</expires>" */
if|if
condition|(
name|lock
operator|->
name|expiration_date
operator|!=
literal|0
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"expires"
argument_list|,
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|expiration_date
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "</lock>" */
name|svn_xml_make_close_tag
argument_list|(
name|sb
argument_list|,
name|pool
argument_list|,
literal|"lock"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__xml_print_header
parameter_list|(
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/*<?xml version="1.0" encoding="UTF-8"?> */
name|svn_xml_make_header2
argument_list|(
operator|&
name|sb
argument_list|,
literal|"UTF-8"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* "<TAGNAME>" */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
name|tagname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|svn_cl__error_checked_fputs
argument_list|(
name|sb
operator|->
name|data
argument_list|,
name|stdout
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__xml_print_footer
parameter_list|(
specifier|const
name|char
modifier|*
name|tagname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* "</TAGNAME>" */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|tagname
argument_list|)
expr_stmt|;
return|return
name|svn_cl__error_checked_fputs
argument_list|(
name|sb
operator|->
name|data
argument_list|,
name|stdout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A map for svn_node_kind_t values to XML strings */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|map_node_kind_xml
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|svn_node_none
block|}
block|,
block|{
literal|"file"
block|,
name|svn_node_file
block|}
block|,
block|{
literal|"dir"
block|,
name|svn_node_dir
block|}
block|,
block|{
literal|""
block|,
name|svn_node_unknown
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A map for svn_node_kind_t values to human-readable strings */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|map_node_kind_human
index|[]
init|=
block|{
block|{
name|N_
argument_list|(
literal|"none"
argument_list|)
block|,
name|svn_node_none
block|}
block|,
block|{
name|N_
argument_list|(
literal|"file"
argument_list|)
block|,
name|svn_node_file
block|}
block|,
block|{
name|N_
argument_list|(
literal|"dir"
argument_list|)
block|,
name|svn_node_dir
block|}
block|,
block|{
literal|""
block|,
name|svn_node_unknown
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|svn_cl__node_kind_str_xml
parameter_list|(
name|svn_node_kind_t
name|kind
parameter_list|)
block|{
return|return
name|svn_token__to_word
argument_list|(
name|map_node_kind_xml
argument_list|,
name|kind
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cl__node_kind_str_human_readable
parameter_list|(
name|svn_node_kind_t
name|kind
parameter_list|)
block|{
return|return
name|_
argument_list|(
name|svn_token__to_word
argument_list|(
name|map_node_kind_human
argument_list|,
name|kind
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A map for svn_wc_operation_t values to XML strings */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|map_wc_operation_xml
index|[]
init|=
block|{
block|{
literal|"none"
block|,
name|svn_wc_operation_none
block|}
block|,
block|{
literal|"update"
block|,
name|svn_wc_operation_update
block|}
block|,
block|{
literal|"switch"
block|,
name|svn_wc_operation_switch
block|}
block|,
block|{
literal|"merge"
block|,
name|svn_wc_operation_merge
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A map for svn_wc_operation_t values to human-readable strings */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_token_map_t
name|map_wc_operation_human
index|[]
init|=
block|{
block|{
name|N_
argument_list|(
literal|"none"
argument_list|)
block|,
name|svn_wc_operation_none
block|}
block|,
block|{
name|N_
argument_list|(
literal|"update"
argument_list|)
block|,
name|svn_wc_operation_update
block|}
block|,
block|{
name|N_
argument_list|(
literal|"switch"
argument_list|)
block|,
name|svn_wc_operation_switch
block|}
block|,
block|{
name|N_
argument_list|(
literal|"merge"
argument_list|)
block|,
name|svn_wc_operation_merge
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|const
name|char
modifier|*
name|svn_cl__operation_str_xml
parameter_list|(
name|svn_wc_operation_t
name|operation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_token__to_word
argument_list|(
name|map_wc_operation_xml
argument_list|,
name|operation
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cl__operation_str_human_readable
parameter_list|(
name|svn_wc_operation_t
name|operation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|_
argument_list|(
name|svn_token__to_word
argument_list|(
name|map_wc_operation_human
argument_list|,
name|operation
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__args_to_target_array_print_reserved
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|targets
parameter_list|,
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|known_targets
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|keep_last_origpath_on_truepath_collision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_client_args_to_target_array2
argument_list|(
name|targets
argument_list|,
name|os
argument_list|,
name|known_targets
argument_list|,
name|ctx
argument_list|,
name|keep_last_origpath_on_truepath_collision
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RESERVED_FILENAME_SPECIFIED
condition|)
block|{
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svn: Skipping argument: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_cl__get_changelist(); implements    svn_changelist_receiver_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|changelist_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|changelist
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* No need to check CHANGELIST; our caller only asked about one of them. */
name|apr_array_header_t
modifier|*
name|paths
init|=
name|baton
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|paths
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__changelist_paths
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|paths
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|found
decl_stmt|;
name|apr_hash_t
modifier|*
name|paths_hash
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|changelists
operator|&&
name|changelists
operator|->
name|nelts
operator|)
condition|)
block|{
operator|*
name|paths
operator|=
operator|(
name|apr_array_header_t
operator|*
operator|)
name|targets
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|found
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_get_changelists
argument_list|(
name|target
argument_list|,
name|changelists
argument_list|,
name|depth
argument_list|,
name|changelist_receiver
argument_list|,
name|found
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|paths_hash
argument_list|,
name|found
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_hash_keys
argument_list|(
name|paths
argument_list|,
name|paths_hash
argument_list|,
name|result_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_cl__show_revs_t
name|svn_cl__show_revs_from_word
parameter_list|(
specifier|const
name|char
modifier|*
name|word
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__SHOW_REVS_MERGED
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__show_revs_merged
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
name|SVN_CL__SHOW_REVS_ELIGIBLE
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_cl__show_revs_eligible
return|;
comment|/* word is an invalid flavor. */
return|return
name|svn_cl__show_revs_invalid
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__time_cstring_to_human_cstring
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|human_cstring
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_time_t
name|when
decl_stmt|;
name|err
operator|=
name|svn_time_from_cstring
argument_list|(
operator|&
name|when
argument_list|,
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_BAD_DATE
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|human_cstring
operator|=
name|_
argument_list|(
literal|"(invalid date)"
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
operator|*
name|human_cstring
operator|=
name|svn_time_to_human_cstring
argument_list|(
name|when
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cl__node_description
parameter_list|(
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_repos_root_URL
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|root_str
init|=
literal|"^"
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_str
init|=
literal|"..."
decl_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
comment|/* Printing "(none)" the harder way to ensure conformity (mostly with      * translations). */
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"(%s)"
argument_list|,
name|svn_cl__node_kind_str_human_readable
argument_list|(
name|svn_node_none
argument_list|)
argument_list|)
return|;
comment|/* Construct a "caret notation" ^/URL if NODE matches WC_REPOS_ROOT_URL.    * Otherwise show the complete URL, and if we can't, show dots. */
if|if
condition|(
name|node
operator|->
name|repos_url
operator|&&
operator|(
name|wc_repos_root_URL
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|node
operator|->
name|repos_url
argument_list|,
name|wc_repos_root_URL
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|root_str
operator|=
name|node
operator|->
name|repos_url
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|path_in_repos
condition|)
name|path_str
operator|=
name|node
operator|->
name|path_in_repos
expr_stmt|;
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"(%s) %s@%ld"
argument_list|,
name|svn_cl__node_kind_str_human_readable
argument_list|(
name|node
operator|->
name|node_kind
argument_list|)
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|root_str
argument_list|,
name|path_str
argument_list|,
name|pool
argument_list|)
argument_list|,
name|node
operator|->
name|peg_rev
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__eat_peg_revisions
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|true_targets_p
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|true_targets
decl_stmt|;
name|true_targets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|true_target
decl_stmt|,
modifier|*
name|peg
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__split_arg_at_peg_revision
argument_list|(
operator|&
name|true_target
argument_list|,
operator|&
name|peg
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peg
index|[
literal|0
index|]
operator|&&
name|peg
index|[
literal|1
index|]
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s': a peg revision is not allowed here"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
name|APR_ARRAY_PUSH
argument_list|(
name|true_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|true_target
expr_stmt|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|true_targets_p
argument_list|)
expr_stmt|;
operator|*
name|true_targets_p
operator|=
name|true_targets
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__assert_homogeneous_target_type
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_client__assert_homogeneous_target_type
argument_list|(
name|targets
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ILLEGAL_TARGET
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__check_target_is_local_path
parameter_list|(
specifier|const
name|char
modifier|*
name|target
parameter_list|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__check_targets_are_local_paths
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__check_target_is_local_path
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_cl__local_style_skip_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|parent_path
condition|)
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|parent_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|svn_dirent_local_style
argument_list|(
name|relpath
condition|?
name|relpath
else|:
name|path
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_cl__propset_print_binary_mime_type_warning
parameter_list|(
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|detected_mimetype
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|canon_propval
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|target
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|node_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|!=
name|svn_node_file
condition|)
continue|continue;
name|SVN_ERR
argument_list|(
name|svn_wc_canonicalize_svn_prop
argument_list|(
operator|&
name|canon_propval
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_mime_type_is_binary
argument_list|(
name|canon_propval
operator|->
name|data
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_detect_mimetype2
argument_list|(
operator|&
name|detected_mimetype
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|detected_mimetype
operator|==
name|NULL
operator|||
operator|!
name|svn_mime_type_is_binary
argument_list|(
name|detected_mimetype
argument_list|)
condition|)
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|iterpool
argument_list|,
name|_
argument_list|(
literal|"svn: warning: '%s' is a binary mime-type but file '%s' "
literal|"looks like text; diff, merge, blame, and other "
literal|"operations will stop working on this file\n"
argument_list|)
argument_list|,
name|canon_propval
operator|->
name|data
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

