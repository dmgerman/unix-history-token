begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * info-cmd.c -- Display information about a resource  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"cl.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"cl-conflicts.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_cl__info_print_time
parameter_list|(
name|apr_time_t
name|atime
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|time_utf8
decl_stmt|;
name|time_utf8
operator|=
name|svn_time_to_human_cstring
argument_list|(
name|atime
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|desc
argument_list|,
name|time_utf8
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return string representation of SCHEDULE */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|schedule_str
parameter_list|(
name|svn_wc_schedule_t
name|schedule
parameter_list|)
block|{
switch|switch
condition|(
name|schedule
condition|)
block|{
case|case
name|svn_wc_schedule_normal
case|:
return|return
literal|"normal"
return|;
case|case
name|svn_wc_schedule_add
case|:
return|return
literal|"add"
return|;
case|case
name|svn_wc_schedule_delete
case|:
return|return
literal|"delete"
return|;
case|case
name|svn_wc_schedule_replace
case|:
return|return
literal|"replace"
return|;
default|default:
return|return
literal|"none"
return|;
block|}
block|}
end_function

begin_comment
comment|/* A callback of type svn_client_info_receiver2_t.    Prints svn info in xml mode to standard out */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_info_xml
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|svn_client_info2_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_prefix
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|rev
argument_list|)
condition|)
name|rev_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|info
operator|->
name|rev
argument_list|)
expr_stmt|;
else|else
name|rev_str
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Resource is not under version control."
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "<entry ...>" */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"entry"
argument_list|,
literal|"path"
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"kind"
argument_list|,
name|svn_cl__node_kind_str_xml
argument_list|(
name|info
operator|->
name|kind
argument_list|)
argument_list|,
literal|"revision"
argument_list|,
name|rev_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* "<url> xx</url>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"url"
argument_list|,
name|info
operator|->
name|URL
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|repos_root_URL
operator|&&
name|info
operator|->
name|URL
condition|)
block|{
comment|/* "<relative-url> xx</relative-url>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"relative-url"
argument_list|,
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"^/"
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|svn_uri_skip_ancestor
argument_list|(
name|info
operator|->
name|repos_root_URL
argument_list|,
name|info
operator|->
name|URL
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|repos_root_URL
operator|||
name|info
operator|->
name|repos_UUID
condition|)
block|{
comment|/* "<repository>" */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"repository"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* "<root> xx</root>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"root"
argument_list|,
name|info
operator|->
name|repos_root_URL
argument_list|)
expr_stmt|;
comment|/* "<uuid> xx</uuid>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"uuid"
argument_list|,
name|info
operator|->
name|repos_UUID
argument_list|)
expr_stmt|;
comment|/* "</repository>" */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"repository"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|wc_info
condition|)
block|{
comment|/* "<wc-info>" */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"wc-info"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* "<wcroot-abspath> xx</wcroot-abspath>" */
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"wcroot-abspath"
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
argument_list|)
expr_stmt|;
comment|/* "<schedule> xx</schedule>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"schedule"
argument_list|,
name|schedule_str
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|schedule
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "<depth> xx</depth>" */
block|{
name|svn_depth_t
name|depth
init|=
name|info
operator|->
name|wc_info
operator|->
name|depth
decl_stmt|;
comment|/* In the entries world info just passed depth infinity for files */
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
operator|&&
name|info
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"depth"
argument_list|,
name|svn_depth_to_word
argument_list|(
name|depth
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* "<copy-from-url> xx</copy-from-url>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"copy-from-url"
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|copyfrom_url
argument_list|)
expr_stmt|;
comment|/* "<copy-from-rev> xx</copy-from-rev>" */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|copyfrom_rev
argument_list|)
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"copy-from-rev"
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|copyfrom_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "<text-updated> xx</text-updated>" */
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|recorded_time
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"text-updated"
argument_list|,
name|svn_time_to_cstring
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|recorded_time
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* "<checksum> xx</checksum>" */
comment|/* ### Print the checksum kind. */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"checksum"
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|changelist
condition|)
comment|/* "<changelist> xx</changelist>" */
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"changelist"
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|changelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|moved_from_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_from_abspath
argument_list|)
expr_stmt|;
comment|/*<moved-from> xx</moved-from> */
if|if
condition|(
name|relpath
operator|&&
name|relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"moved-from"
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
else|else
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"moved-from"
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_from_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|moved_to_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_to_abspath
argument_list|)
expr_stmt|;
comment|/*<moved-to> xx</moved-to> */
if|if
condition|(
name|relpath
operator|&&
name|relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"moved-to"
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
else|else
name|svn_cl__xml_tagged_cdata
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"moved-to"
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_to_abspath
argument_list|)
expr_stmt|;
block|}
comment|/* "</wc-info>" */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"wc-info"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|last_changed_author
operator|||
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|last_changed_rev
argument_list|)
operator|||
name|info
operator|->
name|last_changed_date
condition|)
block|{
name|svn_cl__print_xml_commit
argument_list|(
operator|&
name|sb
argument_list|,
name|info
operator|->
name|last_changed_rev
argument_list|,
name|info
operator|->
name|last_changed_author
argument_list|,
name|svn_time_to_cstring
argument_list|(
name|info
operator|->
name|last_changed_date
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|wc_info
operator|&&
name|info
operator|->
name|wc_info
operator|->
name|conflicts
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|wc_info
operator|->
name|conflicts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
init|=
name|APR_ARRAY_IDX
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|conflicts
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__append_conflict_info_xml
argument_list|(
name|sb
argument_list|,
name|conflict
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|lock
condition|)
name|svn_cl__print_xml_lock
argument_list|(
operator|&
name|sb
argument_list|,
name|info
operator|->
name|lock
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* "</entry>" */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"entry"
argument_list|)
expr_stmt|;
return|return
name|svn_cl__error_checked_fputs
argument_list|(
name|sb
operator|->
name|data
argument_list|,
name|stdout
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A callback of type svn_client_info_receiver2_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_info
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|svn_client_info2_t
modifier|*
name|info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_prefix
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Path: %s\n"
argument_list|)
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### remove this someday:  it's only here for cmdline output      compatibility with svn 1.1 and older.  */
if|if
condition|(
name|info
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Name: %s\n"
argument_list|)
argument_list|,
name|svn_dirent_basename
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wc_info
operator|&&
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Working Copy Root Path: %s\n"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|URL
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"URL: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|URL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|URL
operator|&&
name|info
operator|->
name|repos_root_URL
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Relative URL: ^/%s\n"
argument_list|)
argument_list|,
name|svn_path_uri_encode
argument_list|(
name|svn_uri_skip_ancestor
argument_list|(
name|info
operator|->
name|repos_root_URL
argument_list|,
name|info
operator|->
name|URL
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|repos_root_URL
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Repository Root: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|repos_root_URL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|repos_UUID
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Repository UUID: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|repos_UUID
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Revision: %ld\n"
argument_list|)
argument_list|,
name|info
operator|->
name|rev
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|info
operator|->
name|kind
condition|)
block|{
case|case
name|svn_node_file
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Node Kind: file\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_dir
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Node Kind: directory\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_none
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Node Kind: none\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_unknown
case|:
default|default:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Node Kind: unknown\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|info
operator|->
name|wc_info
condition|)
block|{
switch|switch
condition|(
name|info
operator|->
name|wc_info
operator|->
name|schedule
condition|)
block|{
case|case
name|svn_wc_schedule_normal
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Schedule: normal\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_schedule_add
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Schedule: add\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_schedule_delete
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Schedule: delete\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_schedule_replace
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Schedule: replace\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
switch|switch
condition|(
name|info
operator|->
name|wc_info
operator|->
name|depth
condition|)
block|{
case|case
name|svn_depth_unknown
case|:
comment|/* Unknown depth is the norm for remote directories anyway              (although infinity would be equally appropriate).  Let's              not bother to print it. */
break|break;
case|case
name|svn_depth_empty
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Depth: empty\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_depth_files
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Depth: files\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_depth_immediates
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Depth: immediates\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_depth_exclude
case|:
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Depth: exclude\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_depth_infinity
case|:
comment|/* Infinity is the default depth for working copy              directories.  Let's not print it, it's not special enough              to be worth mentioning.  */
break|break;
default|default:
comment|/* Other depths should never happen here. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Depth: INVALID\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|copyfrom_url
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Copied From URL: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|copyfrom_url
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|copyfrom_rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Copied From Rev: %ld\n"
argument_list|)
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|copyfrom_rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|moved_from_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_from_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|relpath
operator|&&
name|relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Moved From: %s\n"
argument_list|)
argument_list|,
name|relpath
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Moved From: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_from_abspath
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|moved_to_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|wcroot_abspath
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_to_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|relpath
operator|&&
name|relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Moved To: %s\n"
argument_list|)
argument_list|,
name|relpath
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Moved To: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|moved_to_abspath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|last_changed_author
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Last Changed Author: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|last_changed_author
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|info
operator|->
name|last_changed_rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Last Changed Rev: %ld\n"
argument_list|)
argument_list|,
name|info
operator|->
name|last_changed_rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|last_changed_date
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__info_print_time
argument_list|(
name|info
operator|->
name|last_changed_date
argument_list|,
name|_
argument_list|(
literal|"Last Changed Date"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wc_info
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|recorded_time
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__info_print_time
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|recorded_time
argument_list|,
name|_
argument_list|(
literal|"Text Last Updated"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum: %s\n"
argument_list|)
argument_list|,
name|svn_checksum_to_cstring
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|wc_info
operator|->
name|conflicts
condition|)
block|{
name|svn_boolean_t
name|printed_prop_conflict_file
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|info
operator|->
name|wc_info
operator|->
name|conflicts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
init|=
name|APR_ARRAY_IDX
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|conflicts
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc
decl_stmt|;
switch|switch
condition|(
name|conflict
operator|->
name|kind
condition|)
block|{
case|case
name|svn_wc_conflict_kind_text
case|:
if|if
condition|(
name|conflict
operator|->
name|base_abspath
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Conflict Previous Base File: %s\n"
argument_list|)
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|conflict
operator|->
name|base_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
operator|->
name|my_abspath
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Conflict Previous Working File: %s\n"
argument_list|)
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|conflict
operator|->
name|my_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
operator|->
name|their_abspath
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Conflict Current Base File: %s\n"
argument_list|)
argument_list|,
name|svn_cl__local_style_skip_ancestor
argument_list|(
name|path_prefix
argument_list|,
name|conflict
operator|->
name|their_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_kind_property
case|:
if|if
condition|(
operator|!
name|printed_prop_conflict_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Conflict Properties File: %s\n"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|conflict
operator|->
name|their_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|printed_prop_conflict_file
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svn_wc_conflict_kind_tree
case|:
name|SVN_ERR
argument_list|(
name|svn_cl__get_human_readable_tree_conflict_description
argument_list|(
operator|&
name|desc
argument_list|,
name|conflict
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|_
argument_list|(
literal|"Tree conflict"
argument_list|)
argument_list|,
name|desc
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* We only store one left and right version for all conflicts, which is              referenced from all conflicts.              Print it after the conflicts to match the 1.6/1.7 output where it is              only available for tree conflicts */
block|{
specifier|const
name|char
modifier|*
name|src_left_version
decl_stmt|;
specifier|const
name|char
modifier|*
name|src_right_version
decl_stmt|;
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
init|=
name|APR_ARRAY_IDX
argument_list|(
name|info
operator|->
name|wc_info
operator|->
name|conflicts
argument_list|,
literal|0
argument_list|,
specifier|const
name|svn_wc_conflict_description2_t
operator|*
argument_list|)
decl_stmt|;
name|src_left_version
operator|=
name|svn_cl__node_description
argument_list|(
name|conflict
operator|->
name|src_left_version
argument_list|,
name|info
operator|->
name|repos_root_URL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|src_right_version
operator|=
name|svn_cl__node_description
argument_list|(
name|conflict
operator|->
name|src_right_version
argument_list|,
name|info
operator|->
name|repos_root_URL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|src_left_version
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"  %s: %s\n"
argument_list|,
name|_
argument_list|(
literal|"Source  left"
argument_list|)
argument_list|,
comment|/* (1) */
name|src_left_version
argument_list|)
argument_list|)
expr_stmt|;
comment|/* (1): Sneaking in a space in "Source  left" so that              * it is the same length as "Source right" while it still              * starts in the same column. That's just a tiny tweak in              * the English `svn'. */
if|if
condition|(
name|src_right_version
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"  %s: %s\n"
argument_list|,
name|_
argument_list|(
literal|"Source right"
argument_list|)
argument_list|,
name|src_right_version
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|info
operator|->
name|lock
condition|)
block|{
if|if
condition|(
name|info
operator|->
name|lock
operator|->
name|token
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Lock Token: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|lock
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lock
operator|->
name|owner
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Lock Owner: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|lock
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lock
operator|->
name|creation_date
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__info_print_time
argument_list|(
name|info
operator|->
name|lock
operator|->
name|creation_date
argument_list|,
name|_
argument_list|(
literal|"Lock Created"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lock
operator|->
name|expiration_date
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__info_print_time
argument_list|(
name|info
operator|->
name|lock
operator|->
name|expiration_date
argument_list|,
name|_
argument_list|(
literal|"Lock Expires"
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|info
operator|->
name|lock
operator|->
name|comment
condition|)
block|{
name|int
name|comment_lines
decl_stmt|;
comment|/* NOTE: The stdio will handle newline translation. */
name|comment_lines
operator|=
name|svn_cstring_count_newlines
argument_list|(
name|info
operator|->
name|lock
operator|->
name|comment
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|Q_
argument_list|(
literal|"Lock Comment (%i line):\n%s\n"
argument_list|,
literal|"Lock Comment (%i lines):\n%s\n"
argument_list|,
name|comment_lines
argument_list|)
argument_list|,
name|comment_lines
argument_list|,
name|info
operator|->
name|lock
operator|->
name|comment
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|info
operator|->
name|wc_info
operator|&&
name|info
operator|->
name|wc_info
operator|->
name|changelist
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Changelist: %s\n"
argument_list|)
argument_list|,
name|info
operator|->
name|wc_info
operator|->
name|changelist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print extra newline separator. */
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"\n"
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the `svn_opt_subcommand_t' interface. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_cl__info
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_cl__opt_state_t
modifier|*
name|opt_state
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|opt_state
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
operator|(
operator|(
name|svn_cl__cmd_baton_t
operator|*
operator|)
name|baton
operator|)
operator|->
name|ctx
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|seen_nonexistent_target
init|=
name|FALSE
decl_stmt|;
name|svn_opt_revision_t
name|peg_revision
decl_stmt|;
name|svn_client_info_receiver2_t
name|receiver
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_prefix
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__args_to_target_array_print_reserved
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|opt_state
operator|->
name|targets
argument_list|,
name|ctx
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add "." if user passed 0 arguments. */
name|svn_opt_push_implicit_dot_target
argument_list|(
name|targets
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|xml
condition|)
block|{
name|receiver
operator|=
name|print_info_xml
expr_stmt|;
comment|/* If output is not incremental, output the XML header and wrap          everything in a top-level element. This makes the output in          its entirety a well-formed XML document. */
if|if
condition|(
operator|!
name|opt_state
operator|->
name|incremental
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__xml_print_header
argument_list|(
literal|"info"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|receiver
operator|=
name|print_info
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|incremental
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'incremental' option only valid in XML "
literal|"mode"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|opt_state
operator|->
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|opt_state
operator|->
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|path_prefix
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|truepath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cl__check_cancel
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get peg revisions. */
name|SVN_ERR
argument_list|(
name|svn_opt_parse_path
argument_list|(
operator|&
name|peg_revision
argument_list|,
operator|&
name|truepath
argument_list|,
name|target
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If no peg-rev was attached to a URL target, then assume HEAD. */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|truepath
argument_list|)
condition|)
block|{
if|if
condition|(
name|peg_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|peg_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|truepath
argument_list|,
name|truepath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|svn_client_info3
argument_list|(
name|truepath
argument_list|,
operator|&
name|peg_revision
argument_list|,
operator|&
operator|(
name|opt_state
operator|->
name|start_revision
operator|)
argument_list|,
name|opt_state
operator|->
name|depth
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|opt_state
operator|->
name|changelists
argument_list|,
name|receiver
argument_list|,
operator|(
name|void
operator|*
operator|)
name|path_prefix
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* If one of the targets is a non-existent URL or wc-entry,              don't bail out.  Just warn and move on to the next target. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_ILLEGAL_URL
condition|)
block|{
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svn: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|seen_nonexistent_target
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|xml
operator|&&
operator|(
operator|!
name|opt_state
operator|->
name|incremental
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cl__xml_print_footer
argument_list|(
literal|"info"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|seen_nonexistent_target
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not display info for all targets because some "
literal|"targets don't exist"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

