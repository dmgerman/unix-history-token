begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * commit_util.c:  Driver for the WC commit process.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_iter.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* for qsort() */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_comment
comment|/*** Uncomment this to turn on commit driver debugging. ***/
end_comment

begin_comment
comment|/* #define SVN_CLIENT_COMMIT_DEBUG */
end_comment

begin_comment
comment|/* Wrap an RA error in a nicer error if one is available. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fixup_commit_error
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|base_url
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_ALREADY_EXISTS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_TXN_OUT_OF_DATE
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_PATH_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_ALREADY_EXISTS
operator|||
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_ERR_RA_OUT_OF_DATE
argument_list|)
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
if|if
condition|(
name|local_abspath
condition|)
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_failed_out_of_date
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|notify
operator|=
name|svn_wc_create_notify_url
argument_list|(
name|svn_path_url_add_component2
argument_list|(
name|base_url
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_wc_notify_failed_out_of_date
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_UP_TO_DATE
argument_list|,
name|err
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
condition|?
name|_
argument_list|(
literal|"Directory '%s' is out of date"
argument_list|)
else|:
name|_
argument_list|(
literal|"File '%s' is out of date"
argument_list|)
operator|)
argument_list|,
name|local_abspath
condition|?
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|svn_path_url_add_component2
argument_list|(
name|base_url
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_ERR_FS_NO_LOCK_TOKEN
argument_list|)
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_LOCK_OWNER_MISMATCH
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_NOT_LOCKED
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
if|if
condition|(
name|local_abspath
condition|)
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_failed_locked
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|notify
operator|=
name|svn_wc_create_notify_url
argument_list|(
name|svn_path_url_add_component2
argument_list|(
name|base_url
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_wc_notify_failed_locked
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_NO_LOCK_TOKEN
argument_list|,
name|err
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
condition|?
name|_
argument_list|(
literal|"Directory '%s' is locked in another working copy"
argument_list|)
else|:
name|_
argument_list|(
literal|"File '%s' is locked in another working copy"
argument_list|)
operator|)
argument_list|,
name|local_abspath
condition|?
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|svn_path_url_add_component2
argument_list|(
name|base_url
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|svn_error_find_cause
argument_list|(
name|err
argument_list|,
name|SVN_ERR_RA_DAV_FORBIDDEN
argument_list|)
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_AUTHZ_UNWRITABLE
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
if|if
condition|(
name|local_abspath
condition|)
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_failed_forbidden_by_server
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|notify
operator|=
name|svn_wc_create_notify_url
argument_list|(
name|svn_path_url_add_component2
argument_list|(
name|base_url
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_wc_notify_failed_forbidden_by_server
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_FORBIDDEN_BY_SERVER
argument_list|,
name|err
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
condition|?
name|_
argument_list|(
literal|"Changing directory '%s' is forbidden by the server"
argument_list|)
else|:
name|_
argument_list|(
literal|"Changing file '%s' is forbidden by the server"
argument_list|)
operator|)
argument_list|,
name|local_abspath
condition|?
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|svn_path_url_add_component2
argument_list|(
name|base_url
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Harvesting Commit Candidates ***/
end_comment

begin_comment
comment|/* Add a new commit candidate (described by all parameters except    `COMMITTABLES') to the COMMITTABLES hash.  All of the commit item's    members are allocated out of RESULT_POOL.     If the state flag specifies that a lock must be used, store the token in LOCK    in lock_tokens.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_committable
parameter_list|(
name|svn_client__committables_t
modifier|*
name|committables
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_relpath
parameter_list|,
name|svn_revnum_t
name|copyfrom_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|moved_from_abspath
parameter_list|,
name|apr_byte_t
name|state_flags
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
specifier|const
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|array
decl_stmt|;
name|svn_client_commit_item3_t
modifier|*
name|new_item
decl_stmt|;
comment|/* Sanity checks. */
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|repos_root_url
operator|&&
name|repos_relpath
argument_list|)
expr_stmt|;
comment|/* ### todo: Get the canonical repository for this item, which will      be the real key for the COMMITTABLES hash, instead of the above      bogosity. */
name|array
operator|=
name|svn_hash_gets
argument_list|(
name|committables
operator|->
name|by_repository
argument_list|,
name|repos_root_url
argument_list|)
expr_stmt|;
comment|/* E-gads!  There is no array for this repository yet!  Oh, no      problem, we'll just create (and add to the hash) one. */
if|if
condition|(
name|array
operator|==
name|NULL
condition|)
block|{
name|array
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|new_item
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|committables
operator|->
name|by_repository
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|repos_root_url
argument_list|)
argument_list|,
name|array
argument_list|)
expr_stmt|;
block|}
comment|/* Now update pointer values, ensuring that their allocations live      in POOL. */
name|new_item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|new_item
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|new_item
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|new_item
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|new_item
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|new_item
operator|->
name|copyfrom_url
operator|=
name|copyfrom_relpath
condition|?
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|copyfrom_relpath
argument_list|,
name|result_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|new_item
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_rev
expr_stmt|;
name|new_item
operator|->
name|state_flags
operator|=
name|state_flags
expr_stmt|;
name|new_item
operator|->
name|incoming_prop_changes
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_from_abspath
condition|)
name|new_item
operator|->
name|moved_from_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|moved_from_abspath
argument_list|)
expr_stmt|;
comment|/* Now, add the commit item to the array. */
name|APR_ARRAY_PUSH
argument_list|(
name|array
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|new_item
expr_stmt|;
comment|/* ... and to the hash. */
name|svn_hash_sets
argument_list|(
name|committables
operator|->
name|by_path
argument_list|,
name|new_item
operator|->
name|path
argument_list|,
name|new_item
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|&&
name|lock_tokens
operator|&&
operator|(
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN
operator|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|lock_tokens
argument_list|,
name|new_item
operator|->
name|url
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|lock
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If there is a commit item for PATH in COMMITTABLES, return it, else    return NULL.  Use POOL for temporary allocation only. */
end_comment

begin_function
specifier|static
name|svn_client_commit_item3_t
modifier|*
name|look_up_committable
parameter_list|(
name|svn_client__committables_t
modifier|*
name|committables
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|svn_client_commit_item3_t
operator|*
operator|)
name|svn_hash_gets
argument_list|(
name|committables
operator|->
name|by_path
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper function for svn_client__harvest_committables().  * Determine whether we are within a tree-conflicted subtree of the  * working copy and return an SVN_ERR_WC_FOUND_CONFLICT error if so. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bail_on_tree_conflicted_ancestor
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|svn_dirent_is_ancestor
argument_list|(
name|wcroot_abspath
argument_list|,
name|local_abspath
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
comment|/* Check if the parent has tree conflicts */
name|SVN_ERR
argument_list|(
name|svn_wc_conflicted_p3
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree_conflicted
condition|)
block|{
if|if
condition|(
name|notify_func
operator|!=
name|NULL
condition|)
block|{
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_failed_conflict
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_FOUND_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Aborting commit: '%s' remains in tree-conflict"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Step outwards */
if|if
condition|(
name|svn_dirent_is_root
argument_list|(
name|local_abspath
argument_list|,
name|strlen
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
condition|)
break|break;
else|else
name|local_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Recursively search for commit candidates in (and under) LOCAL_ABSPATH using    WC_CTX and add those candidates to COMMITTABLES.  If in ADDS_ONLY modes,    only new additions are recognized.     DEPTH indicates how to treat files and subdirectories of LOCAL_ABSPATH    when LOCAL_ABSPATH is itself a directory; see    svn_client__harvest_committables() for its behavior.     Lock tokens of candidates will be added to LOCK_TOKENS, if    non-NULL.  JUST_LOCKED indicates whether to treat non-modified items with    lock tokens as commit candidates.     If COMMIT_RELPATH is not NULL, treat not-added nodes as if it is destined to    be added as COMMIT_RELPATH, and add 'deleted' entries to COMMITTABLES as    items to delete in the copy destination.  COPY_MODE_ROOT should be set TRUE    for the first call for which COPY_MODE is TRUE, i.e. not for the    recursive calls, and FALSE otherwise.     If CHANGELISTS is non-NULL, it is a hash whose keys are const char *    changelist names used as a restrictive filter    when harvesting committables; that is, don't add a path to    COMMITTABLES unless it's a member of one of those changelists.     IS_EXPLICIT_TARGET should always be passed as TRUE, except when    harvest_committables() calls itself in recursion. This provides a way to    tell whether LOCAL_ABSPATH was an original target or whether it was reached    by recursing deeper into a dir target. (This is used to skip all file    externals that aren't explicit commit targets.)     DANGLERS is a hash table mapping const char* absolute paths of a parent    to a const char * absolute path of a child. See the comment about    danglers at the top of svn_client__harvest_committables().     If CANCEL_FUNC is non-null, call it with CANCEL_BATON to see    if the user has cancelled the operation.     Any items added to COMMITTABLES are allocated from the COMITTABLES    hash pool, not POOL.  SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_struct
struct|struct
name|harvest_baton
block|{
comment|/* Static data */
specifier|const
name|char
modifier|*
name|root_abspath
decl_stmt|;
name|svn_client__committables_t
modifier|*
name|committables
decl_stmt|;
name|apr_hash_t
modifier|*
name|lock_tokens
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_relpath
decl_stmt|;
comment|/* Valid for the harvest root */
name|svn_depth_t
name|depth
decl_stmt|;
name|svn_boolean_t
name|just_locked
decl_stmt|;
name|apr_hash_t
modifier|*
name|changelists
decl_stmt|;
name|apr_hash_t
modifier|*
name|danglers
decl_stmt|;
name|svn_client__check_url_kind_t
name|check_url_func
decl_stmt|;
name|void
modifier|*
name|check_url_baton
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
comment|/* Harvester state */
specifier|const
name|char
modifier|*
name|skip_below_abspath
decl_stmt|;
comment|/* If non-NULL, skip everything below */
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|harvest_status_callback
parameter_list|(
name|void
modifier|*
name|status_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|svn_error_t
modifier|*
name|harvest_committables
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_client__committables_t
modifier|*
name|committables
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_mode_relpath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|just_locked
parameter_list|,
name|apr_hash_t
modifier|*
name|changelists
parameter_list|,
name|apr_hash_t
modifier|*
name|danglers
parameter_list|,
name|svn_client__check_url_kind_t
name|check_url_func
parameter_list|,
name|void
modifier|*
name|check_url_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|harvest_baton
name|baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|just_locked
operator|&&
name|lock_tokens
operator|)
operator|||
operator|!
name|just_locked
argument_list|)
expr_stmt|;
name|baton
operator|.
name|root_abspath
operator|=
name|local_abspath
expr_stmt|;
name|baton
operator|.
name|committables
operator|=
name|committables
expr_stmt|;
name|baton
operator|.
name|lock_tokens
operator|=
name|lock_tokens
expr_stmt|;
name|baton
operator|.
name|commit_relpath
operator|=
name|copy_mode_relpath
expr_stmt|;
name|baton
operator|.
name|depth
operator|=
name|depth
expr_stmt|;
name|baton
operator|.
name|just_locked
operator|=
name|just_locked
expr_stmt|;
name|baton
operator|.
name|changelists
operator|=
name|changelists
expr_stmt|;
name|baton
operator|.
name|danglers
operator|=
name|danglers
expr_stmt|;
name|baton
operator|.
name|check_url_func
operator|=
name|check_url_func
expr_stmt|;
name|baton
operator|.
name|check_url_baton
operator|=
name|check_url_baton
expr_stmt|;
name|baton
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|baton
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|baton
operator|.
name|wc_ctx
operator|=
name|wc_ctx
expr_stmt|;
name|baton
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|baton
operator|.
name|skip_below_abspath
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_walk_status
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
operator|(
name|copy_mode_relpath
operator|!=
name|NULL
operator|)
comment|/* get_all */
argument_list|,
name|FALSE
comment|/* no_ignore */
argument_list|,
name|FALSE
comment|/* ignore_text_mods */
argument_list|,
name|NULL
comment|/* ignore_patterns */
argument_list|,
name|harvest_status_callback
argument_list|,
operator|&
name|baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|harvest_not_present_for_copy
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_client__committables_t
modifier|*
name|committables
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|commit_relpath
parameter_list|,
name|svn_client__check_url_kind_t
name|check_url_func
parameter_list|,
name|void
modifier|*
name|check_url_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* A function to retrieve not present children would be nice to have */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_children_of_working_node
argument_list|(
operator|&
name|children
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|this_abspath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_dirent_basename
argument_list|(
name|this_abspath
argument_list|,
name|NULL
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_commit_relpath
decl_stmt|;
name|svn_boolean_t
name|not_present
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_is_not_present
argument_list|(
operator|&
name|not_present
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|this_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|not_present
condition|)
continue|continue;
if|if
condition|(
name|commit_relpath
operator|==
name|NULL
condition|)
name|this_commit_relpath
operator|=
name|NULL
expr_stmt|;
else|else
name|this_commit_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|commit_relpath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* We should check if we should really add a delete operation */
if|if
condition|(
name|check_url_func
condition|)
block|{
name|svn_revnum_t
name|parent_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_url
decl_stmt|;
comment|/* Determine from what parent we would be the deleted child */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
name|NULL
argument_list|,
operator|&
name|parent_rev
argument_list|,
operator|&
name|parent_repos_relpath
argument_list|,
operator|&
name|parent_repos_root_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|this_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|svn_path_url_add_component2
argument_list|(
name|parent_repos_root_url
argument_list|,
name|parent_repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_dirent_basename
argument_list|(
name|this_abspath
argument_list|,
name|NULL
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_url_func
argument_list|(
name|check_url_baton
argument_list|,
operator|&
name|kind
argument_list|,
name|node_url
argument_list|,
name|parent_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
continue|continue;
comment|/* This node can't be deleted */
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|wc_ctx
argument_list|,
name|this_abspath
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_committable
argument_list|(
name|committables
argument_list|,
name|this_abspath
argument_list|,
name|kind
argument_list|,
name|repos_root_url
argument_list|,
name|this_commit_relpath
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
comment|/* copyfrom_relpath */
argument_list|,
name|SVN_INVALID_REVNUM
comment|/* copyfrom_rev */
argument_list|,
name|NULL
comment|/* moved_from_abspath */
argument_list|,
name|SVN_CLIENT_COMMIT_ITEM_DELETE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_wc_status_func4_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|harvest_status_callback
parameter_list|(
name|void
modifier|*
name|status_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_byte_t
name|state_flags
init|=
literal|0
decl_stmt|;
name|svn_revnum_t
name|node_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|cf_relpath
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|cf_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_boolean_t
name|matches_changelists
decl_stmt|;
name|svn_boolean_t
name|is_added
decl_stmt|;
name|svn_boolean_t
name|is_deleted
decl_stmt|;
name|svn_boolean_t
name|is_replaced
decl_stmt|;
name|svn_boolean_t
name|is_op_root
decl_stmt|;
name|svn_revnum_t
name|original_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_relpath
decl_stmt|;
name|svn_boolean_t
name|copy_mode
decl_stmt|;
name|struct
name|harvest_baton
modifier|*
name|baton
init|=
name|status_baton
decl_stmt|;
name|svn_boolean_t
name|is_harvest_root
init|=
operator|(
name|strcmp
argument_list|(
name|baton
operator|->
name|root_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|svn_client__committables_t
modifier|*
name|committables
init|=
name|baton
operator|->
name|committables
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
init|=
name|status
operator|->
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_relpath
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|copy_mode_root
init|=
operator|(
name|baton
operator|->
name|commit_relpath
operator|&&
name|is_harvest_root
operator|)
decl_stmt|;
name|svn_boolean_t
name|just_locked
init|=
name|baton
operator|->
name|just_locked
decl_stmt|;
name|apr_hash_t
modifier|*
name|changelists
init|=
name|baton
operator|->
name|changelists
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
init|=
name|baton
operator|->
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
init|=
name|baton
operator|->
name|notify_baton
decl_stmt|;
name|svn_wc_context_t
modifier|*
name|wc_ctx
init|=
name|baton
operator|->
name|wc_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|baton
operator|->
name|result_pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|moved_from_abspath
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|baton
operator|->
name|commit_relpath
condition|)
name|commit_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|baton
operator|->
name|commit_relpath
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|baton
operator|->
name|root_abspath
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|copy_mode
operator|=
operator|(
name|commit_relpath
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|baton
operator|->
name|skip_below_abspath
operator|&&
name|svn_dirent_is_ancestor
argument_list|(
name|baton
operator|->
name|skip_below_abspath
argument_list|,
name|local_abspath
argument_list|)
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|baton
operator|->
name|skip_below_abspath
operator|=
name|NULL
expr_stmt|;
comment|/* We have left the skip tree */
comment|/* Return early for nodes that don't have a committable status */
switch|switch
condition|(
name|status
operator|->
name|node_status
condition|)
block|{
case|case
name|svn_wc_status_unversioned
case|:
case|case
name|svn_wc_status_ignored
case|:
case|case
name|svn_wc_status_external
case|:
case|case
name|svn_wc_status_none
case|:
comment|/* Unversioned nodes aren't committable, but are reported by the status            walker.            But if the unversioned node is the root of the walk, we have a user            error */
if|if
condition|(
name|is_harvest_root
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
case|case
name|svn_wc_status_normal
case|:
comment|/* Status normal nodes aren't modified, so we don't have to commit them            when we perform a normal commit. But if a node is conflicted we want            to stop the commit and if we are collecting lock tokens we want to            look further anyway.             When in copy mode we need to compare the revision of the node against            the parent node to copy mixed-revision base nodes properly */
if|if
condition|(
operator|!
name|copy_mode
operator|&&
operator|!
name|status
operator|->
name|conflicted
operator|&&
operator|!
operator|(
name|just_locked
operator|&&
name|status
operator|->
name|lock
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
break|break;
default|default:
comment|/* Fall through */
break|break;
block|}
comment|/* Early out if the item is already marked as committable. */
if|if
condition|(
name|look_up_committable
argument_list|(
name|committables
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|copy_mode
operator|&&
name|commit_relpath
operator|)
operator|||
operator|(
operator|!
name|copy_mode
operator|&&
operator|!
name|commit_relpath
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|copy_mode_root
operator|&&
name|copy_mode
operator|)
operator|||
operator|!
name|copy_mode_root
argument_list|)
expr_stmt|;
comment|/* Save the result for reuse. */
name|matches_changelists
operator|=
operator|(
operator|(
name|changelists
operator|==
name|NULL
operator|)
operator|||
operator|(
name|status
operator|->
name|changelist
operator|!=
name|NULL
operator|&&
name|svn_hash_gets
argument_list|(
name|changelists
argument_list|,
name|status
operator|->
name|changelist
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
expr_stmt|;
comment|/* Early exit. */
if|if
condition|(
name|status
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|&&
operator|!
name|matches_changelists
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If NODE is in our changelist, then examine it for conflicts. We      need to bail out if any conflicts exist.      The status walker checked for conflict marker removal. */
if|if
condition|(
name|status
operator|->
name|conflicted
operator|&&
name|matches_changelists
condition|)
block|{
if|if
condition|(
name|notify_func
operator|!=
name|NULL
condition|)
block|{
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_failed_conflict
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_FOUND_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Aborting commit: '%s' remains in conflict"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_obstructed
condition|)
block|{
comment|/* A node's type has changed before attempting to commit.          This also catches symlink vs non symlink changes */
if|if
condition|(
name|notify_func
operator|!=
name|NULL
condition|)
block|{
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_failed_obstruction
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node '%s' has unexpectedly changed kind"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|status
operator|->
name|conflicted
operator|&&
name|status
operator|->
name|kind
operator|==
name|svn_node_unknown
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Ignore delete-delete conflict */
comment|/* Return error on unknown path kinds.  We check both the entry and      the node itself, since a path might have changed kind since its      entry was written. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_commit_status
argument_list|(
operator|&
name|is_added
argument_list|,
operator|&
name|is_deleted
argument_list|,
operator|&
name|is_replaced
argument_list|,
operator|&
name|is_op_root
argument_list|,
operator|&
name|node_rev
argument_list|,
operator|&
name|original_rev
argument_list|,
operator|&
name|original_relpath
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Hande file externals only when passed as explicit target. Note that    * svn_client_commit6() passes all committable externals in as explicit    * targets iff they count. */
if|if
condition|(
name|status
operator|->
name|file_external
operator|&&
operator|!
name|is_harvest_root
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_missing
operator|&&
name|matches_changelists
condition|)
block|{
comment|/* Added files and directories must exist. See issue #3198. */
if|if
condition|(
name|is_added
operator|&&
name|is_op_root
condition|)
block|{
if|if
condition|(
name|notify_func
operator|!=
name|NULL
condition|)
block|{
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_failed_missing
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is scheduled for addition, but is missing"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|is_deleted
operator|&&
operator|!
name|is_op_root
comment|/*&& !is_added */
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Not an operational delete and not an add. */
comment|/* Check for the deletion case.      * We delete explicitly deleted nodes (duh!)      * We delete not-present children of copies      * We delete nodes that directly replace a node in its ancestor    */
if|if
condition|(
name|is_deleted
operator|||
name|is_replaced
condition|)
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_DELETE
expr_stmt|;
comment|/* Check for adds and copies */
if|if
condition|(
name|is_added
operator|&&
name|is_op_root
condition|)
block|{
comment|/* Root of local add or copy */
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
if|if
condition|(
name|original_relpath
condition|)
block|{
comment|/* Root of copy */
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_IS_COPY
expr_stmt|;
name|cf_relpath
operator|=
name|original_relpath
expr_stmt|;
name|cf_rev
operator|=
name|original_rev
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|moved_from_abspath
operator|&&
operator|!
name|copy_mode
condition|)
block|{
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_MOVED_HERE
expr_stmt|;
name|moved_from_abspath
operator|=
name|status
operator|->
name|moved_from_abspath
expr_stmt|;
block|}
block|}
block|}
comment|/* Further copies may occur in copy mode. */
elseif|else
if|if
condition|(
name|copy_mode
operator|&&
operator|!
operator|(
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
operator|)
condition|)
block|{
name|svn_revnum_t
name|dir_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
if|if
condition|(
operator|!
name|copy_mode_root
operator|&&
operator|!
name|status
operator|->
name|switched
operator|&&
operator|!
name|is_added
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_base
argument_list|(
name|NULL
argument_list|,
operator|&
name|dir_rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
comment|/* ignore_enoent */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_mode_root
operator|||
name|status
operator|->
name|switched
operator|||
name|node_rev
operator|!=
name|dir_rev
condition|)
block|{
name|state_flags
operator||=
operator|(
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator||
name|SVN_CLIENT_COMMIT_ITEM_IS_COPY
operator|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|copied
condition|)
block|{
comment|/* Copy from original location */
name|cf_rev
operator|=
name|original_rev
expr_stmt|;
name|cf_relpath
operator|=
name|original_relpath
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy BASE location, to represent a mixed-rev or switch copy */
name|cf_rev
operator|=
name|status
operator|->
name|revision
expr_stmt|;
name|cf_relpath
operator|=
name|status
operator|->
name|repos_relpath
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
operator|)
operator|||
operator|(
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
condition|)
block|{
name|svn_boolean_t
name|text_mod
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|prop_mod
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|status
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* Check for text modifications on files */
if|if
condition|(
operator|(
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
operator|&&
operator|!
operator|(
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_IS_COPY
operator|)
condition|)
block|{
name|text_mod
operator|=
name|TRUE
expr_stmt|;
comment|/* Local added files are always modified */
block|}
else|else
name|text_mod
operator|=
operator|(
name|status
operator|->
name|text_status
operator|!=
name|svn_wc_status_normal
operator|)
expr_stmt|;
block|}
name|prop_mod
operator|=
operator|(
name|status
operator|->
name|prop_status
operator|!=
name|svn_wc_status_normal
operator|&&
name|status
operator|->
name|prop_status
operator|!=
name|svn_wc_status_none
operator|)
expr_stmt|;
comment|/* Set text/prop modification flags accordingly. */
if|if
condition|(
name|text_mod
condition|)
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
expr_stmt|;
if|if
condition|(
name|prop_mod
condition|)
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
expr_stmt|;
block|}
comment|/* If the entry has a lock token and it is already a commit candidate,      or the caller wants unmodified locked items to be treated as      such, note this fact. */
if|if
condition|(
name|status
operator|->
name|lock
operator|&&
name|baton
operator|->
name|lock_tokens
operator|&&
operator|(
name|state_flags
operator|||
name|just_locked
operator|)
condition|)
block|{
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN
expr_stmt|;
block|}
comment|/* Now, if this is something to commit, add it to our list. */
if|if
condition|(
name|matches_changelists
operator|&&
name|state_flags
condition|)
block|{
comment|/* Finally, add the committable item. */
name|SVN_ERR
argument_list|(
name|add_committable
argument_list|(
name|committables
argument_list|,
name|local_abspath
argument_list|,
name|status
operator|->
name|kind
argument_list|,
name|repos_root_url
argument_list|,
name|copy_mode
condition|?
name|commit_relpath
else|:
name|status
operator|->
name|repos_relpath
argument_list|,
name|copy_mode
condition|?
name|SVN_INVALID_REVNUM
else|:
name|node_rev
argument_list|,
name|cf_relpath
argument_list|,
name|cf_rev
argument_list|,
name|moved_from_abspath
argument_list|,
name|state_flags
argument_list|,
name|baton
operator|->
name|lock_tokens
argument_list|,
name|status
operator|->
name|lock
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Fetch lock tokens for descendants of deleted BASE nodes. */
if|if
condition|(
name|matches_changelists
operator|&&
operator|(
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
operator|)
operator|&&
operator|!
name|copy_mode
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|node_rev
argument_list|)
comment|/*&& BASE-kind = dir */
operator|&&
name|baton
operator|->
name|lock_tokens
condition|)
block|{
name|apr_hash_t
modifier|*
name|local_relpath_tokens
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_lock_tokens_recursive
argument_list|(
operator|&
name|local_relpath_tokens
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add tokens to existing hash. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|local_relpath_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|baton
operator|->
name|lock_tokens
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure we check for dangling children on additions       We perform this operation on the harvest root, and on roots caused by      changelist filtering.   */
if|if
condition|(
name|matches_changelists
operator|&&
operator|(
name|is_harvest_root
operator|||
name|baton
operator|->
name|changelists
operator|)
operator|&&
name|state_flags
operator|&&
operator|(
name|is_added
operator|||
operator|(
name|is_deleted
operator|&&
name|is_op_root
operator|&&
name|status
operator|->
name|copied
operator|)
operator|)
operator|&&
name|baton
operator|->
name|danglers
condition|)
block|{
comment|/* If a node is added, its parent must exist in the repository at the          time of committing */
name|apr_hash_t
modifier|*
name|danglers
init|=
name|baton
operator|->
name|danglers
decl_stmt|;
name|svn_boolean_t
name|parent_added
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* First check if parent is already in the list of commits          (Common case for GUI clients that provide a list of commit targets) */
if|if
condition|(
name|look_up_committable
argument_list|(
name|committables
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
condition|)
name|parent_added
operator|=
name|FALSE
expr_stmt|;
comment|/* Skip all expensive checks */
else|else
name|SVN_ERR
argument_list|(
name|svn_wc__node_is_added
argument_list|(
operator|&
name|parent_added
argument_list|,
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_added
condition|)
block|{
specifier|const
name|char
modifier|*
name|copy_root_abspath
decl_stmt|;
name|svn_boolean_t
name|parent_is_copy
decl_stmt|;
comment|/* The parent is added, so either it is a copy, or a locally added            * directory. In either case, we require the op-root of the parent            * to be part of the commit. See issue #4059. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
operator|&
name|parent_is_copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|copy_root_abspath
argument_list|,
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_is_copy
condition|)
name|parent_abspath
operator|=
name|copy_root_abspath
expr_stmt|;
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|danglers
argument_list|,
name|parent_abspath
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|danglers
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|parent_abspath
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|is_deleted
operator|&&
operator|!
name|is_added
condition|)
block|{
comment|/* Skip all descendants */
if|if
condition|(
name|status
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|baton
operator|->
name|skip_below_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|baton
operator|->
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Recursively handle each node according to depth, except when the      node is only being deleted, or is in an added tree (as added trees      use the normal commit handling). */
if|if
condition|(
name|copy_mode
operator|&&
operator|!
name|is_added
operator|&&
operator|!
name|is_deleted
operator|&&
name|status
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|harvest_not_present_for_copy
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|committables
argument_list|,
name|repos_root_url
argument_list|,
name|commit_relpath
argument_list|,
name|baton
operator|->
name|check_url_func
argument_list|,
name|baton
operator|->
name|check_url_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for handle_descendants */
end_comment

begin_struct
struct|struct
name|handle_descendants_baton
block|{
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|svn_client__check_url_kind_t
name|check_url_func
decl_stmt|;
name|void
modifier|*
name|check_url_baton
decl_stmt|;
name|svn_client__committables_t
modifier|*
name|committables
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Helper for the commit harvesters */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_descendants
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|void
modifier|*
name|key
parameter_list|,
name|apr_ssize_t
name|klen
parameter_list|,
name|void
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|handle_descendants_baton
modifier|*
name|hdb
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
init|=
name|val
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
init|=
name|key
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|absent_descendants
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Is this a copy operation? */
if|if
condition|(
operator|!
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
operator|||
operator|!
name|item
operator|->
name|copyfrom_url
condition|)
continue|continue;
if|if
condition|(
name|hdb
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|hdb
operator|->
name|cancel_func
argument_list|(
name|hdb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_not_present_descendants
argument_list|(
operator|&
name|absent_descendants
argument_list|,
name|hdb
operator|->
name|wc_ctx
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|absent_descendants
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_client_commit_item3_t
modifier|*
name|desc_item
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|absent_descendants
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|item
operator|->
name|path
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
comment|/* ### Need a sub-iterpool? */
comment|/* We found a 'not present' descendant during a copy (at op_depth>0),              this is most commonly caused by copying some mixed revision tree.               In this case not present can imply that the node does not exist              in the parent revision, or that the node does. But we want to copy              the working copy state in which it does not exist, but might be              replaced. */
name|desc_item
operator|=
name|svn_hash_gets
argument_list|(
name|hdb
operator|->
name|committables
operator|->
name|by_path
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
comment|/* If the path has a commit operation (possibly at an higher              op_depth, we might want to turn an add in a replace. */
if|if
condition|(
name|desc_item
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
name|svn_boolean_t
name|found_intermediate
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|desc_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
condition|)
continue|continue;
comment|/* We already have a delete or replace */
elseif|else
if|if
condition|(
operator|!
operator|(
name|desc_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
condition|)
continue|continue;
comment|/* Not a copy/add, just a modification */
name|dir
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
while|while
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
name|item
operator|->
name|path
argument_list|)
condition|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|i_item
decl_stmt|;
name|i_item
operator|=
name|svn_hash_gets
argument_list|(
name|hdb
operator|->
name|committables
operator|->
name|by_path
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|i_item
condition|)
block|{
if|if
condition|(
operator|(
name|i_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
operator|)
operator|||
operator|(
name|i_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
condition|)
block|{
name|found_intermediate
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
name|dir
operator|=
name|svn_dirent_dirname
argument_list|(
name|dir
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|found_intermediate
condition|)
continue|continue;
comment|/* Some intermediate ancestor is an add or delete */
comment|/* Fall through to detect if we need to turn the add in a                  replace. */
block|}
if|if
condition|(
name|hdb
operator|->
name|check_url_func
condition|)
block|{
specifier|const
name|char
modifier|*
name|from_url
init|=
name|svn_path_url_add_component2
argument_list|(
name|item
operator|->
name|copyfrom_url
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|hdb
operator|->
name|check_url_func
argument_list|(
name|hdb
operator|->
name|check_url_baton
argument_list|,
operator|&
name|kind
argument_list|,
name|from_url
argument_list|,
name|item
operator|->
name|copyfrom_rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
continue|continue;
comment|/* This node is already deleted */
block|}
else|else
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
comment|/* 'Ok' for a delete of something */
if|if
condition|(
name|desc_item
condition|)
block|{
comment|/* Extend the existing add/copy item to create a replace */
name|desc_item
operator|->
name|state_flags
operator||=
name|SVN_CLIENT_COMMIT_ITEM_DELETE
expr_stmt|;
continue|continue;
block|}
comment|/* Add a new commit item that describes the delete */
name|SVN_ERR
argument_list|(
name|add_committable
argument_list|(
name|hdb
operator|->
name|committables
argument_list|,
name|svn_dirent_join
argument_list|(
name|item
operator|->
name|path
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|kind
argument_list|,
name|repos_root_url
argument_list|,
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|item
operator|->
name|url
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
comment|/* copyfrom_relpath */
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
comment|/* moved_from_abspath */
argument_list|,
name|SVN_CLIENT_COMMIT_ITEM_DELETE
argument_list|,
name|NULL
comment|/* lock tokens */
argument_list|,
name|NULL
comment|/* lock */
argument_list|,
name|commit_items
operator|->
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate and initialize the COMMITTABLES structure from POOL.  */
end_comment

begin_function
specifier|static
name|void
name|create_committables
parameter_list|(
name|svn_client__committables_t
modifier|*
modifier|*
name|committables
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|committables
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|committables
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|committables
operator|)
operator|->
name|by_repository
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|committables
operator|)
operator|->
name|by_path
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__harvest_committables
parameter_list|(
name|svn_client__committables_t
modifier|*
modifier|*
name|committables
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|lock_tokens
parameter_list|,
specifier|const
name|char
modifier|*
name|base_dir_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|int
name|depth_empty_start
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|just_locked
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_client__check_url_kind_t
name|check_url_func
parameter_list|,
name|void
modifier|*
name|check_url_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|changelist_hash
init|=
name|NULL
decl_stmt|;
name|struct
name|handle_descendants_baton
name|hdb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* It's possible that one of the named targets has a parent that is    * itself scheduled for addition or replacement -- that is, the    * parent is not yet versioned in the repository.  This is okay, as    * long as the parent itself is part of this same commit, either    * directly, or by virtue of a grandparent, great-grandparent, etc,    * being part of the commit.    *    * Since we don't know what's included in the commit until we've    * harvested all the targets, we can't reliably check this as we    * go.  So in `danglers', we record named targets whose parents    * do not yet exist in the repository. Then after harvesting the total    * commit group, we check to make sure those parents are included.    *    * Each key of danglers is a parent which does not exist in the    * repository.  The (const char *) value is one of that parent's    * children which is named as part of the commit; the child is    * included only to make a better error message.    *    * (The reason we don't bother to check unnamed -- i.e, implicit --    * targets is that they can only join the commit if their parents    * did too, so this situation can't arise for them.)    */
name|apr_hash_t
modifier|*
name|danglers
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|base_dir_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the COMMITTABLES structure. */
name|create_committables
argument_list|(
name|committables
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* And the LOCK_TOKENS dito. */
operator|*
name|lock_tokens
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* If we have a list of changelists, convert that into a hash with      changelist keys. */
if|if
condition|(
name|changelists
operator|&&
name|changelists
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|changelist_hash
argument_list|,
name|changelists
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Add the relative portion to the base abspath.  */
name|target_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|base_dir_abspath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Handle our TARGET. */
comment|/* Make sure this isn't inside a working copy subtree that is        * marked as tree-conflicted. */
name|SVN_ERR
argument_list|(
name|bail_on_tree_conflicted_ancestor
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Are the remaining items externals with depth empty? */
if|if
condition|(
name|i
operator|==
name|depth_empty_start
condition|)
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
name|SVN_ERR
argument_list|(
name|harvest_committables
argument_list|(
name|target_abspath
argument_list|,
operator|*
name|committables
argument_list|,
operator|*
name|lock_tokens
argument_list|,
name|NULL
comment|/* COPY_MODE_RELPATH */
argument_list|,
name|depth
argument_list|,
name|just_locked
argument_list|,
name|changelist_hash
argument_list|,
name|danglers
argument_list|,
name|check_url_func
argument_list|,
name|check_url_baton
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hdb
operator|.
name|wc_ctx
operator|=
name|ctx
operator|->
name|wc_ctx
expr_stmt|;
name|hdb
operator|.
name|cancel_func
operator|=
name|ctx
operator|->
name|cancel_func
expr_stmt|;
name|hdb
operator|.
name|cancel_baton
operator|=
name|ctx
operator|->
name|cancel_baton
expr_stmt|;
name|hdb
operator|.
name|check_url_func
operator|=
name|check_url_func
expr_stmt|;
name|hdb
operator|.
name|check_url_baton
operator|=
name|check_url_baton
expr_stmt|;
name|hdb
operator|.
name|committables
operator|=
operator|*
name|committables
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
operator|(
operator|*
name|committables
operator|)
operator|->
name|by_repository
argument_list|,
name|handle_descendants
argument_list|,
operator|&
name|hdb
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure that every path in danglers is part of the commit. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|danglers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|dangling_parent
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|look_up_committable
argument_list|(
operator|*
name|committables
argument_list|,
name|dangling_parent
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|dangling_child
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|notify_func2
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|dangling_child
argument_list|,
name|svn_wc_notify_failed_no_parent
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not known to exist in the repository "
literal|"and is not part of the commit, "
literal|"yet its child '%s' is part of the commit"
argument_list|)
argument_list|,
comment|/* Probably one or both of these is an entry, but                               safest to local_stylize just in case. */
name|svn_dirent_local_style
argument_list|(
name|dangling_parent
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|dangling_child
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|copy_committables_baton
block|{
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|svn_client__committables_t
modifier|*
name|committables
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
name|svn_client__check_url_kind_t
name|check_url_func
decl_stmt|;
name|void
modifier|*
name|check_url_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|harvest_copy_committables
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|copy_committables_baton
modifier|*
name|btn
init|=
name|baton
decl_stmt|;
name|svn_client__copy_pair_t
modifier|*
name|pair
init|=
operator|*
operator|(
name|svn_client__copy_pair_t
operator|*
operator|*
operator|)
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_relpath
decl_stmt|;
name|struct
name|handle_descendants_baton
name|hdb
decl_stmt|;
comment|/* Read the entry for this SRC. */
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|btn
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|commit_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|pair
operator|->
name|dst_abspath_or_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Handle this SRC. */
name|SVN_ERR
argument_list|(
name|harvest_committables
argument_list|(
name|pair
operator|->
name|src_abspath_or_url
argument_list|,
name|btn
operator|->
name|committables
argument_list|,
name|NULL
argument_list|,
name|commit_relpath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
comment|/* JUST_LOCKED */
name|NULL
comment|/* changelists */
argument_list|,
name|NULL
argument_list|,
name|btn
operator|->
name|check_url_func
argument_list|,
name|btn
operator|->
name|check_url_baton
argument_list|,
name|btn
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|btn
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|btn
operator|->
name|ctx
operator|->
name|notify_func2
argument_list|,
name|btn
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|btn
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|btn
operator|->
name|result_pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hdb
operator|.
name|wc_ctx
operator|=
name|btn
operator|->
name|ctx
operator|->
name|wc_ctx
expr_stmt|;
name|hdb
operator|.
name|cancel_func
operator|=
name|btn
operator|->
name|ctx
operator|->
name|cancel_func
expr_stmt|;
name|hdb
operator|.
name|cancel_baton
operator|=
name|btn
operator|->
name|ctx
operator|->
name|cancel_baton
expr_stmt|;
name|hdb
operator|.
name|check_url_func
operator|=
name|btn
operator|->
name|check_url_func
expr_stmt|;
name|hdb
operator|.
name|check_url_baton
operator|=
name|btn
operator|->
name|check_url_baton
expr_stmt|;
name|hdb
operator|.
name|committables
operator|=
name|btn
operator|->
name|committables
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_iter_apr_hash
argument_list|(
name|NULL
argument_list|,
name|btn
operator|->
name|committables
operator|->
name|by_repository
argument_list|,
name|handle_descendants
argument_list|,
operator|&
name|hdb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_copy_committables
parameter_list|(
name|svn_client__committables_t
modifier|*
modifier|*
name|committables
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|copy_pairs
parameter_list|,
name|svn_client__check_url_kind_t
name|check_url_func
parameter_list|,
name|void
modifier|*
name|check_url_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|copy_committables_baton
name|btn
decl_stmt|;
comment|/* Create the COMMITTABLES structure. */
name|create_committables
argument_list|(
name|committables
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|btn
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|btn
operator|.
name|committables
operator|=
operator|*
name|committables
expr_stmt|;
name|btn
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|btn
operator|.
name|check_url_func
operator|=
name|check_url_func
expr_stmt|;
name|btn
operator|.
name|check_url_baton
operator|=
name|check_url_baton
expr_stmt|;
comment|/* For each copy pair, harvest the committables for that pair into the      committables hash. */
return|return
name|svn_iter_apr_array
argument_list|(
name|NULL
argument_list|,
name|copy_pairs
argument_list|,
name|harvest_copy_committables
argument_list|,
operator|&
name|btn
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|svn_client__sort_commit_item_urls
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_client_commit_item3_t
modifier|*
name|item1
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_client_commit_item3_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|svn_client_commit_item3_t
modifier|*
name|item2
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_client_commit_item3_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
return|return
name|svn_path_compare_paths
argument_list|(
name|item1
operator|->
name|url
argument_list|,
name|item2
operator|->
name|url
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__condense_commit_items
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|base_url
parameter_list|,
name|apr_array_header_t
modifier|*
name|commit_items
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|ci
init|=
name|commit_items
decl_stmt|;
comment|/* convenience */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|,
modifier|*
name|last_item
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ci
operator|&&
name|ci
operator|->
name|nelts
argument_list|)
expr_stmt|;
comment|/* Sort our commit items by their URLs. */
name|qsort
argument_list|(
name|ci
operator|->
name|elts
argument_list|,
name|ci
operator|->
name|nelts
argument_list|,
name|ci
operator|->
name|elt_size
argument_list|,
name|svn_client__sort_commit_item_urls
argument_list|)
expr_stmt|;
comment|/* Loop through the URLs, finding the longest usable ancestor common      to all of them, and making sure there are no duplicate URLs.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|ci
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
expr_stmt|;
name|url
operator|=
name|item
operator|->
name|url
expr_stmt|;
if|if
condition|(
operator|(
name|last_item
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|last_item
operator|->
name|url
argument_list|,
name|url
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_DUPLICATE_COMMIT_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot commit both '%s' and '%s' as they refer to the same URL"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|item
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|last_item
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* In the first iteration, our BASE_URL is just our only          encountered commit URL to date.  After that, we find the          longest ancestor between the current BASE_URL and the current          commit URL.  */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
operator|*
name|base_url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
else|else
operator|*
name|base_url
operator|=
name|svn_uri_get_longest_ancestor
argument_list|(
operator|*
name|base_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If our BASE_URL is itself a to-be-committed item, and it is          anything other than an already-versioned directory with          property mods, we'll call its parent directory URL the          BASE_URL.  Why?  Because we can't have a file URL as our base          -- period -- and all other directory operations (removal,          addition, etc.) require that we open that directory's parent          dir first.  */
comment|/* ### I don't understand the strlen()s here, hmmm.  -kff */
if|if
condition|(
operator|(
name|strlen
argument_list|(
operator|*
name|base_url
argument_list|)
operator|==
name|strlen
argument_list|(
name|url
argument_list|)
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|item
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
operator|&&
name|item
operator|->
name|state_flags
operator|==
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
operator|)
operator|)
condition|)
operator|*
name|base_url
operator|=
name|svn_uri_dirname
argument_list|(
operator|*
name|base_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Stash our item here for the next iteration. */
name|last_item
operator|=
name|item
expr_stmt|;
block|}
comment|/* Now that we've settled on a *BASE_URL, go hack that base off      of all of our URLs and store it as session_relpath. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|this_item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ci
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
name|this_item
operator|->
name|session_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
operator|*
name|base_url
argument_list|,
name|this_item
operator|->
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SVN_CLIENT_COMMIT_DEBUG
comment|/* ### TEMPORARY CODE ### */
name|SVN_DBG
argument_list|(
operator|(
literal|"COMMITTABLES: (base URL=%s)\n"
operator|,
operator|*
name|base_url
operator|)
argument_list|)
expr_stmt|;
name|SVN_DBG
argument_list|(
operator|(
literal|"   FLAGS     REV  REL-URL (COPY-URL)\n"
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ci
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|this_item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ci
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
name|char
name|flags
index|[
literal|6
index|]
decl_stmt|;
name|flags
index|[
literal|0
index|]
operator|=
operator|(
name|this_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
condition|?
literal|'a'
else|:
literal|'-'
expr_stmt|;
name|flags
index|[
literal|1
index|]
operator|=
operator|(
name|this_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
operator|)
condition|?
literal|'d'
else|:
literal|'-'
expr_stmt|;
name|flags
index|[
literal|2
index|]
operator|=
operator|(
name|this_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
operator|)
condition|?
literal|'t'
else|:
literal|'-'
expr_stmt|;
name|flags
index|[
literal|3
index|]
operator|=
operator|(
name|this_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
operator|)
condition|?
literal|'p'
else|:
literal|'-'
expr_stmt|;
name|flags
index|[
literal|4
index|]
operator|=
operator|(
name|this_item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_IS_COPY
operator|)
condition|?
literal|'c'
else|:
literal|'-'
expr_stmt|;
name|flags
index|[
literal|5
index|]
operator|=
literal|'\0'
expr_stmt|;
name|SVN_DBG
argument_list|(
operator|(
literal|"   %s  %6ld  '%s' (%s)\n"
operator|,
name|flags
operator|,
name|this_item
operator|->
name|revision
operator|,
name|this_item
operator|->
name|url
condition|?
name|this_item
operator|->
name|url
else|:
literal|""
operator|,
name|this_item
operator|->
name|copyfrom_url
condition|?
name|this_item
operator|->
name|copyfrom_url
else|:
literal|"none"
operator|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SVN_CLIENT_COMMIT_DEBUG */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|file_mod_t
block|{
specifier|const
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
name|void
modifier|*
name|file_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A baton for use while driving a path-based editor driver for commit */
end_comment

begin_struct
struct|struct
name|item_commit_baton
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
comment|/* commit editor */
name|void
modifier|*
name|edit_baton
decl_stmt|;
comment|/* commit editor's baton */
name|apr_hash_t
modifier|*
name|file_mods
decl_stmt|;
comment|/* hash: path->file_mod_t */
specifier|const
name|char
modifier|*
name|notify_path_prefix
decl_stmt|;
comment|/* notification path prefix                                           (NULL is okay, else abs path) */
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
comment|/* client context baton */
name|apr_hash_t
modifier|*
name|commit_items
decl_stmt|;
comment|/* the committables */
specifier|const
name|char
modifier|*
name|base_url
decl_stmt|;
comment|/* The session url for the commit */
block|}
struct|;
end_struct

begin_comment
comment|/* Drive CALLBACK_BATON->editor with the change described by the item in  * CALLBACK_BATON->commit_items that is keyed by PATH.  If the change  * includes a text mod, however, call the editor's file_open() function  * but do not send the text mod to the editor; instead, add a mapping of  * "item-url => (commit-item, file-baton)" into CALLBACK_BATON->file_mods.  *  * Before driving the editor, call the cancellation and notification  * callbacks in CALLBACK_BATON->ctx, if present.  *  * This implements svn_delta_path_driver_cb_func_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_item_commit
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|item_commit_baton
modifier|*
name|icb
init|=
name|callback_baton
decl_stmt|;
specifier|const
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|svn_hash_gets
argument_list|(
name|icb
operator|->
name|commit_items
argument_list|,
name|path
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
init|=
name|item
operator|->
name|kind
decl_stmt|;
name|void
modifier|*
name|file_baton
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|file_pool
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|icb
operator|->
name|editor
decl_stmt|;
name|apr_hash_t
modifier|*
name|file_mods
init|=
name|icb
operator|->
name|file_mods
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
name|icb
operator|->
name|ctx
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|NULL
decl_stmt|;
comment|/* Do some initializations. */
operator|*
name|dir_baton
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|svn_node_none
operator|&&
name|item
operator|->
name|path
condition|)
block|{
comment|/* We always get an absolute path, see svn_client_commit_item3_t. */
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|item
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|item
operator|->
name|path
expr_stmt|;
block|}
comment|/* If this is a file with textual mods, we'll be keeping its baton      around until the end of the commit.  So just lump its memory into      a single, big, all-the-file-batons-in-here pool.  Otherwise, we      can just use POOL, and trust our caller to clean that mess up. */
if|if
condition|(
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
operator|)
condition|)
name|file_pool
operator|=
name|apr_hash_pool_get
argument_list|(
name|file_mods
argument_list|)
expr_stmt|;
else|else
name|file_pool
operator|=
name|pool
expr_stmt|;
comment|/* Call the cancellation function. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Validation. */
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_IS_COPY
condition|)
block|{
if|if
condition|(
operator|!
name|item
operator|->
name|copyfrom_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Commit item '%s' has copy flag but no copyfrom URL"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|item
operator|->
name|copyfrom_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Commit item '%s' has copy flag but an invalid revision"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* If a feedback table was supplied by the application layer,      describe what we're about to do to this item. */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
operator|&&
name|item
operator|->
name|path
condition|)
block|{
specifier|const
name|char
modifier|*
name|npath
init|=
name|item
operator|->
name|path
decl_stmt|;
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
if|if
condition|(
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
operator|)
operator|&&
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
condition|)
block|{
comment|/* We don't print the "(bin)" notice for binary files when              replacing, only when adding.  So we don't bother to get              the mime-type here. */
if|if
condition|(
name|item
operator|->
name|copyfrom_url
condition|)
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|npath
argument_list|,
name|svn_wc_notify_commit_copied_replaced
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|npath
argument_list|,
name|svn_wc_notify_commit_replaced
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
condition|)
block|{
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|npath
argument_list|,
name|svn_wc_notify_commit_deleted
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
condition|)
block|{
if|if
condition|(
name|item
operator|->
name|copyfrom_url
condition|)
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|npath
argument_list|,
name|svn_wc_notify_commit_copied
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|npath
argument_list|,
name|svn_wc_notify_commit_added
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|propval
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_prop_get2
argument_list|(
operator|&
name|propval
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|propval
condition|)
name|notify
operator|->
name|mime_type
operator|=
name|propval
operator|->
name|data
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
operator|)
operator|||
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
operator|)
condition|)
block|{
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|npath
argument_list|,
name|svn_wc_notify_commit_modified
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
else|else
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
condition|)
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
else|else
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
block|}
else|else
name|notify
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|notify
condition|)
block|{
name|notify
operator|->
name|kind
operator|=
name|item
operator|->
name|kind
expr_stmt|;
name|notify
operator|->
name|path_prefix
operator|=
name|icb
operator|->
name|notify_path_prefix
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If this item is supposed to be deleted, do so. */
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|parent_baton
argument_list|)
expr_stmt|;
name|err
operator|=
name|editor
operator|->
name|delete_entry
argument_list|(
name|path
argument_list|,
name|item
operator|->
name|revision
argument_list|,
name|parent_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
block|}
comment|/* If this item is supposed to be added, do so. */
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|parent_baton
argument_list|)
expr_stmt|;
name|err
operator|=
name|editor
operator|->
name|add_file
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|item
operator|->
name|copyfrom_url
argument_list|,
name|item
operator|->
name|copyfrom_url
condition|?
name|item
operator|->
name|copyfrom_rev
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|file_pool
argument_list|,
operator|&
name|file_baton
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* May be svn_node_none when adding parent dirs for a copy. */
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|parent_baton
argument_list|)
expr_stmt|;
name|err
operator|=
name|editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|item
operator|->
name|copyfrom_url
argument_list|,
name|item
operator|->
name|copyfrom_url
condition|?
name|item
operator|->
name|copyfrom_rev
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
comment|/* Set other prop-changes, if available in the baton */
if|if
condition|(
name|item
operator|->
name|outgoing_prop_changes
condition|)
block|{
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
name|apr_array_header_t
modifier|*
name|prop_changes
init|=
name|item
operator|->
name|outgoing_prop_changes
decl_stmt|;
name|int
name|ctr
decl_stmt|;
for|for
control|(
name|ctr
operator|=
literal|0
init|;
name|ctr
operator|<
name|prop_changes
operator|->
name|nelts
condition|;
name|ctr
operator|++
control|)
block|{
name|prop
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_changes
argument_list|,
name|ctr
argument_list|,
name|svn_prop_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|err
operator|=
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|editor
operator|->
name|change_dir_prop
argument_list|(
operator|*
name|dir_baton
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
block|}
block|}
block|}
comment|/* Now handle property mods. */
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
condition|)
block|{
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
if|if
condition|(
operator|!
name|file_baton
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|parent_baton
argument_list|)
expr_stmt|;
name|err
operator|=
name|editor
operator|->
name|open_file
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|item
operator|->
name|revision
argument_list|,
name|file_pool
argument_list|,
operator|&
name|file_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
operator|*
name|dir_baton
condition|)
block|{
if|if
condition|(
operator|!
name|parent_baton
condition|)
block|{
name|err
operator|=
name|editor
operator|->
name|open_root
argument_list|(
name|icb
operator|->
name|edit_baton
argument_list|,
name|item
operator|->
name|revision
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|editor
operator|->
name|open_directory
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|item
operator|->
name|revision
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
block|}
block|}
comment|/* When committing a directory that no longer exists in the          repository, a "not found" error does not occur immediately          upon opening the directory.  It appears here during the delta          transmisssion. */
name|err
operator|=
name|svn_wc_transmit_prop_deltas2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|editor
argument_list|,
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
condition|?
operator|*
name|dir_baton
else|:
name|file_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
comment|/* Make any additional client -> repository prop changes. */
if|if
condition|(
name|item
operator|->
name|outgoing_prop_changes
condition|)
block|{
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|item
operator|->
name|outgoing_prop_changes
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|prop
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|item
operator|->
name|outgoing_prop_changes
argument_list|,
name|i
argument_list|,
name|svn_prop_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|err
operator|=
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|editor
operator|->
name|change_dir_prop
argument_list|(
operator|*
name|dir_baton
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
block|}
block|}
block|}
comment|/* Finally, handle text mods (in that we need to open a file if it      hasn't already been opened, and we need to put the file baton in      our FILES hash). */
if|if
condition|(
operator|(
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_TEXT_MODS
operator|)
condition|)
block|{
name|struct
name|file_mod_t
modifier|*
name|mod
init|=
name|apr_palloc
argument_list|(
name|file_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|mod
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|file_baton
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|parent_baton
argument_list|)
expr_stmt|;
name|err
operator|=
name|editor
operator|->
name|open_file
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|item
operator|->
name|revision
argument_list|,
name|file_pool
argument_list|,
operator|&
name|file_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
block|}
comment|/* Add this file mod to the FILE_MODS hash. */
name|mod
operator|->
name|item
operator|=
name|item
expr_stmt|;
name|mod
operator|->
name|file_baton
operator|=
name|file_baton
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|file_mods
argument_list|,
name|item
operator|->
name|session_relpath
argument_list|,
name|mod
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|file_baton
condition|)
block|{
comment|/* Close any outstanding file batons that didn't get caught by          the "has local mods" conditional above. */
name|err
operator|=
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|file_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|fixup_error
goto|;
block|}
return|return
name|SVN_NO_ERROR
return|;
name|fixup_error
label|:
return|return
name|svn_error_trace
argument_list|(
name|fixup_commit_error
argument_list|(
name|local_abspath
argument_list|,
name|icb
operator|->
name|base_url
argument_list|,
name|path
argument_list|,
name|kind
argument_list|,
name|err
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__do_commit
parameter_list|(
specifier|const
name|char
modifier|*
name|base_url
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|commit_items
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|notify_path_prefix
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|sha1_checksums
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|file_mods
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|items_hash
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|item_commit_baton
name|cb_baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|commit_items
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Ditto for the checksums. */
if|if
condition|(
name|sha1_checksums
condition|)
operator|*
name|sha1_checksums
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Build a hash from our COMMIT_ITEMS array, keyed on the      relative paths (which come from the item URLs).  And      keep an array of those decoded paths, too.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|item
operator|->
name|session_relpath
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|items_hash
argument_list|,
name|path
argument_list|,
name|item
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
block|}
comment|/* Setup the callback baton. */
name|cb_baton
operator|.
name|editor
operator|=
name|editor
expr_stmt|;
name|cb_baton
operator|.
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|cb_baton
operator|.
name|file_mods
operator|=
name|file_mods
expr_stmt|;
name|cb_baton
operator|.
name|notify_path_prefix
operator|=
name|notify_path_prefix
expr_stmt|;
name|cb_baton
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|cb_baton
operator|.
name|commit_items
operator|=
name|items_hash
expr_stmt|;
name|cb_baton
operator|.
name|base_url
operator|=
name|base_url
expr_stmt|;
comment|/* Drive the commit editor! */
name|SVN_ERR
argument_list|(
name|svn_delta_path_driver2
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|paths
argument_list|,
name|TRUE
argument_list|,
name|do_item_commit
argument_list|,
operator|&
name|cb_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Transmit outstanding text deltas. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|file_mods
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|struct
name|file_mod_t
modifier|*
name|mod
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|mod
operator|->
name|item
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|new_text_base_md5_checksum
decl_stmt|;
specifier|const
name|svn_checksum_t
modifier|*
name|new_text_base_sha1_checksum
decl_stmt|;
name|svn_boolean_t
name|fulltext
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Transmit the entry. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|item
operator|->
name|path
argument_list|,
name|svn_wc_notify_commit_postfix_txdelta
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|notify
operator|->
name|path_prefix
operator|=
name|notify_path_prefix
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* If the node has no history, transmit full text */
if|if
condition|(
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
operator|&&
operator|!
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_IS_COPY
operator|)
condition|)
name|fulltext
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|svn_wc_transmit_text_deltas3
argument_list|(
operator|&
name|new_text_base_md5_checksum
argument_list|,
operator|&
name|new_text_base_sha1_checksum
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|fulltext
argument_list|,
name|editor
argument_list|,
name|mod
operator|->
name|file_baton
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Close tempfiles */
return|return
name|svn_error_trace
argument_list|(
name|fixup_commit_error
argument_list|(
name|item
operator|->
name|path
argument_list|,
name|base_url
argument_list|,
name|item
operator|->
name|session_relpath
argument_list|,
name|svn_node_file
argument_list|,
name|err
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|sha1_checksums
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|sha1_checksums
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|new_text_base_sha1_checksum
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Close the edit. */
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_log_msg
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|log_msg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_file
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|commit_items
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|log_msg_func3
condition|)
block|{
comment|/* The client provided a callback function for the current API.          Forward the call to it directly. */
return|return
call|(
modifier|*
name|ctx
operator|->
name|log_msg_func3
call|)
argument_list|(
name|log_msg
argument_list|,
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
operator|->
name|log_msg_baton3
argument_list|,
name|pool
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|ctx
operator|->
name|log_msg_func2
operator|||
name|ctx
operator|->
name|log_msg_func
condition|)
block|{
comment|/* The client provided a pre-1.5 (or pre-1.3) API callback          function.  Convert the commit_items list to the appropriate          type, and forward call to it. */
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|old_commit_items
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|commit_items
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|ctx
operator|->
name|log_msg_func2
condition|)
block|{
name|svn_client_commit_item2_t
modifier|*
name|old_item
init|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|old_item
argument_list|)
argument_list|)
decl_stmt|;
name|old_item
operator|->
name|path
operator|=
name|item
operator|->
name|path
expr_stmt|;
name|old_item
operator|->
name|kind
operator|=
name|item
operator|->
name|kind
expr_stmt|;
name|old_item
operator|->
name|url
operator|=
name|item
operator|->
name|url
expr_stmt|;
name|old_item
operator|->
name|revision
operator|=
name|item
operator|->
name|revision
expr_stmt|;
name|old_item
operator|->
name|copyfrom_url
operator|=
name|item
operator|->
name|copyfrom_url
expr_stmt|;
name|old_item
operator|->
name|copyfrom_rev
operator|=
name|item
operator|->
name|copyfrom_rev
expr_stmt|;
name|old_item
operator|->
name|state_flags
operator|=
name|item
operator|->
name|state_flags
expr_stmt|;
name|old_item
operator|->
name|wcprop_changes
operator|=
name|item
operator|->
name|incoming_prop_changes
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|old_commit_items
argument_list|,
name|svn_client_commit_item2_t
operator|*
argument_list|)
operator|=
name|old_item
expr_stmt|;
block|}
else|else
comment|/* ctx->log_msg_func */
block|{
name|svn_client_commit_item_t
modifier|*
name|old_item
init|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|old_item
argument_list|)
argument_list|)
decl_stmt|;
name|old_item
operator|->
name|path
operator|=
name|item
operator|->
name|path
expr_stmt|;
name|old_item
operator|->
name|kind
operator|=
name|item
operator|->
name|kind
expr_stmt|;
name|old_item
operator|->
name|url
operator|=
name|item
operator|->
name|url
expr_stmt|;
comment|/* The pre-1.3 API used the revision field for copyfrom_rev                  and revision depeding of copyfrom_url. */
name|old_item
operator|->
name|revision
operator|=
name|item
operator|->
name|copyfrom_url
condition|?
name|item
operator|->
name|copyfrom_rev
else|:
name|item
operator|->
name|revision
expr_stmt|;
name|old_item
operator|->
name|copyfrom_url
operator|=
name|item
operator|->
name|copyfrom_url
expr_stmt|;
name|old_item
operator|->
name|state_flags
operator|=
name|item
operator|->
name|state_flags
expr_stmt|;
name|old_item
operator|->
name|wcprop_changes
operator|=
name|item
operator|->
name|incoming_prop_changes
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|old_commit_items
argument_list|,
name|svn_client_commit_item_t
operator|*
argument_list|)
operator|=
name|old_item
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|log_msg_func2
condition|)
name|err
operator|=
call|(
modifier|*
name|ctx
operator|->
name|log_msg_func2
call|)
argument_list|(
name|log_msg
argument_list|,
name|tmp_file
argument_list|,
name|old_commit_items
argument_list|,
name|ctx
operator|->
name|log_msg_baton2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
call|(
modifier|*
name|ctx
operator|->
name|log_msg_func
call|)
argument_list|(
name|log_msg
argument_list|,
name|tmp_file
argument_list|,
name|old_commit_items
argument_list|,
name|ctx
operator|->
name|log_msg_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
else|else
block|{
comment|/* No log message callback was provided by the client. */
operator|*
name|log_msg
operator|=
literal|""
expr_stmt|;
operator|*
name|tmp_file
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__ensure_revprop_table
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|revprop_table_out
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table_in
parameter_list|,
specifier|const
name|char
modifier|*
name|log_msg
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|new_revprop_table
decl_stmt|;
if|if
condition|(
name|revprop_table_in
condition|)
block|{
if|if
condition|(
name|svn_prop_has_svn_prop
argument_list|(
name|revprop_table_in
argument_list|,
name|pool
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Standard properties can't be set "
literal|"explicitly as revision properties"
argument_list|)
argument_list|)
return|;
name|new_revprop_table
operator|=
name|apr_hash_copy
argument_list|(
name|pool
argument_list|,
name|revprop_table_in
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_revprop_table
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|new_revprop_table
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|svn_string_create
argument_list|(
name|log_msg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|revprop_table_out
operator|=
name|new_revprop_table
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

