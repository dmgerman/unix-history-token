begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * add.c:  wrappers around wc add/mkdir functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|<apr_fnmatch.h>
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_magic.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Remove leading and trailing white space from a C string, in place. */
end_comment

begin_function
specifier|static
name|void
name|trim_string
parameter_list|(
name|char
modifier|*
modifier|*
name|pstr
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|pstr
decl_stmt|;
name|size_t
name|i
decl_stmt|;
while|while
condition|(
name|svn_ctype_isspace
argument_list|(
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
operator|*
name|pstr
operator|=
name|str
expr_stmt|;
name|i
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
name|svn_ctype_isspace
argument_list|(
name|str
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|i
operator|--
expr_stmt|;
name|str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove leading and trailing single- or double quotes from a C string,  * in place. */
end_comment

begin_function
specifier|static
name|void
name|unquote_string
parameter_list|(
name|char
modifier|*
modifier|*
name|pstr
parameter_list|)
block|{
name|char
modifier|*
name|str
init|=
operator|*
name|pstr
decl_stmt|;
name|size_t
name|i
init|=
name|strlen
argument_list|(
name|str
argument_list|)
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
operator|(
operator|(
operator|*
name|str
operator|==
literal|'"'
operator|&&
name|str
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'"'
operator|)
operator|||
operator|(
operator|*
name|str
operator|==
literal|'\''
operator|&&
name|str
index|[
name|i
operator|-
literal|1
index|]
operator|==
literal|'\''
operator|)
operator|)
condition|)
block|{
name|str
index|[
name|i
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|pstr
operator|=
name|str
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Split PROPERTY and store each individual value in PROPS.    Allocates from POOL. */
end_comment

begin_function
specifier|static
name|void
name|split_props
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|property
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|temp_props
decl_stmt|;
name|char
modifier|*
name|new_prop
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|j
init|=
literal|0
decl_stmt|;
name|temp_props
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new_prop
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|strlen
argument_list|(
name|property
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|property
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|property
index|[
name|i
index|]
operator|!=
literal|';'
condition|)
block|{
name|new_prop
index|[
name|j
index|]
operator|=
name|property
index|[
name|i
index|]
expr_stmt|;
name|j
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|property
index|[
name|i
index|]
operator|==
literal|';'
condition|)
block|{
comment|/* ";;" becomes ";" */
if|if
condition|(
name|property
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|';'
condition|)
block|{
name|new_prop
index|[
name|j
index|]
operator|=
literal|';'
expr_stmt|;
name|j
operator|++
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|new_prop
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|temp_props
argument_list|,
name|char
operator|*
argument_list|)
operator|=
name|new_prop
expr_stmt|;
name|new_prop
operator|+=
name|j
operator|+
literal|1
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|new_prop
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|temp_props
argument_list|,
name|char
operator|*
argument_list|)
operator|=
name|new_prop
expr_stmt|;
operator|*
name|props
operator|=
name|temp_props
expr_stmt|;
block|}
end_function

begin_comment
comment|/* PROPVALS is a hash mapping char * property names to const char * property    values.  PROPERTIES can be empty but not NULL.     If FILENAME doesn't match the filename pattern PATTERN case insensitively,    the do nothing.  Otherwise for each 'name':'value' pair in PROPVALS, add    a new entry mappying 'name' to a svn_string_t * wrapping the 'value' in    PROPERTIES.  The svn_string_t is allocated in the pool used to allocate    PROPERTIES, but the char *'s from PROPVALS are re-used in PROPERTIES.    If PROPVALS contains a 'svn:mime-type' mapping, then set *MIMETYPE to    the mapped value.  Likewise if PROPVALS contains a mapping for    svn:executable, then set *HAVE_EXECUTABLE to TRUE.     Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|void
name|get_auto_props_for_pattern
parameter_list|(
name|apr_hash_t
modifier|*
name|properties
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|mimetype
parameter_list|,
name|svn_boolean_t
modifier|*
name|have_executable
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
specifier|const
name|char
modifier|*
name|pattern
parameter_list|,
name|apr_hash_t
modifier|*
name|propvals
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* check if filename matches and return if it doesn't */
if|if
condition|(
name|apr_fnmatch
argument_list|(
name|pattern
argument_list|,
name|filename
argument_list|,
name|APR_FNM_CASE_BLIND
argument_list|)
operator|==
name|APR_FNM_NOMATCH
condition|)
return|return;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|propvals
argument_list|)
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|propval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|propval_str
init|=
name|svn_string_create_empty
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|properties
argument_list|)
argument_list|)
decl_stmt|;
name|propval_str
operator|->
name|data
operator|=
name|propval
expr_stmt|;
name|propval_str
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|propval
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|properties
argument_list|,
name|propname
argument_list|,
name|propval_str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|mimetype
operator|=
name|propval
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
operator|==
literal|0
condition|)
operator|*
name|have_executable
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_paths_auto_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|properties
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|mimetype
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_magic__cookie_t
modifier|*
name|magic_cookie
parameter_list|,
name|apr_hash_t
modifier|*
name|autoprops
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|have_executable
init|=
name|FALSE
decl_stmt|;
operator|*
name|properties
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|mimetype
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|autoprops
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|autoprops
argument_list|)
init|;
name|hi
operator|!=
name|NULL
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|pattern
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|propvals
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|get_auto_props_for_pattern
argument_list|(
operator|*
name|properties
argument_list|,
name|mimetype
argument_list|,
operator|&
name|have_executable
argument_list|,
name|svn_dirent_basename
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|pattern
argument_list|,
name|propvals
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if mimetype has not been set check the file */
if|if
condition|(
operator|!
operator|*
name|mimetype
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_detect_mimetype2
argument_list|(
name|mimetype
argument_list|,
name|path
argument_list|,
name|ctx
operator|->
name|mimetypes_map
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we got no mime-type, or if it is "application/octet-stream",        * try to get the mime-type from libmagic. */
if|if
condition|(
name|magic_cookie
operator|&&
operator|(
operator|!
operator|*
name|mimetype
operator|||
name|strcmp
argument_list|(
operator|*
name|mimetype
argument_list|,
literal|"application/octet-stream"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|magic_mimetype
decl_stmt|;
comment|/* Since libmagic usually treats UTF-16 files as "text/plain",           * svn_magic__detect_binary_mimetype() will return NULL for such           * files. This is fine for now since we currently don't support           * UTF-16-encoded text files (issue #2194).           * Once we do support UTF-16 this code path will fail to detect           * them as text unless the svn_io_detect_mimetype2() call above           * returns "text/plain" for them. */
name|SVN_ERR
argument_list|(
name|svn_magic__detect_binary_mimetype
argument_list|(
operator|&
name|magic_mimetype
argument_list|,
name|path
argument_list|,
name|magic_cookie
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|magic_mimetype
condition|)
operator|*
name|mimetype
operator|=
name|magic_mimetype
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|mimetype
condition|)
name|apr_hash_set
argument_list|(
operator|*
name|properties
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|,
name|strlen
argument_list|(
name|SVN_PROP_MIME_TYPE
argument_list|)
argument_list|,
name|svn_string_create
argument_list|(
operator|*
name|mimetype
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* if executable has not been set check the file */
if|if
condition|(
operator|!
name|have_executable
condition|)
block|{
name|svn_boolean_t
name|executable
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_is_file_executable
argument_list|(
operator|&
name|executable
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|executable
condition|)
name|apr_hash_set
argument_list|(
operator|*
name|properties
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|,
name|strlen
argument_list|(
name|SVN_PROP_EXECUTABLE
argument_list|)
argument_list|,
name|svn_string_create_empty
argument_list|(
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Only call this if the on-disk node kind is a file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_magic__cookie_t
modifier|*
name|magic_cookie
parameter_list|,
name|apr_hash_t
modifier|*
name|autoprops
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimetype
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_special
decl_stmt|;
comment|/* Check to see if this is a special file. */
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine the properties that the file should have */
if|if
condition|(
name|is_special
condition|)
block|{
name|mimetype
operator|=
name|NULL
expr_stmt|;
name|properties
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|properties
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|,
name|svn_string_create
argument_list|(
name|SVN_PROP_BOOLEAN_TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_hash_t
modifier|*
name|file_autoprops
init|=
name|NULL
decl_stmt|;
comment|/* Get automatic properties */
comment|/* If we are setting autoprops grab the inherited svn:auto-props and          config file auto-props for this file if we haven't already got them          when iterating over the file's unversioned parents. */
if|if
condition|(
operator|!
name|no_autoprops
condition|)
block|{
if|if
condition|(
name|autoprops
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__get_all_auto_props
argument_list|(
operator|&
name|file_autoprops
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|file_autoprops
operator|=
name|autoprops
expr_stmt|;
block|}
comment|/* This may fail on write-only files:          we open them to estimate file type. */
name|SVN_ERR
argument_list|(
name|svn_client__get_paths_auto_props
argument_list|(
operator|&
name|properties
argument_list|,
operator|&
name|mimetype
argument_list|,
name|local_abspath
argument_list|,
name|magic_cookie
argument_list|,
name|file_autoprops
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Add the file */
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|properties
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Schedule directory DIR_ABSPATH, and some of the tree under it, for  * addition.  DEPTH is the depth at this point in the descent (it may  * be changed for recursive calls).  *  * If DIR_ABSPATH (or any item below DIR_ABSPATH) is already scheduled for  * addition, add will fail and return an error unless FORCE is TRUE.  *  * Use MAGIC_COOKIE (which may be NULL) to detect the mime-type of files  * if necessary.  *  * If not NULL, CONFIG_AUTOPROPS is a hash representing the config file and  * svn:auto-props autoprops which apply to DIR_ABSPATH.  It maps  * const char * file patterns to another hash which maps const char *  * property names to const char *property values.  If CONFIG_AUTOPROPS is  * NULL and the config file and svn:auto-props autoprops are required by this  * function, then such will be obtained.  *  * If IGNORES is not NULL, then it is an array of const char * ignore patterns  * that apply to any children of DIR_ABSPATH.  If REFRESH_IGNORES is TRUE, then  * the passed in value of IGNORES (if any) is itself ignored and this function  * will gather all ignore patterns applicable to DIR_ABSPATH itself (allocated in  * RESULT_POOL).  Any recursive calls to this function get the refreshed ignore  * patterns.  If IGNORES is NULL and REFRESH_IGNORES is FALSE, then all children of DIR_ABSPATH  * are unconditionally added.  *  * If CTX->CANCEL_FUNC is non-null, call it with CTX->CANCEL_BATON to allow  * the user to cancel the operation.  *  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_dir_recursive
parameter_list|(
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_magic__cookie_t
modifier|*
name|magic_cookie
parameter_list|,
name|apr_hash_t
modifier|*
name|config_autoprops
parameter_list|,
name|svn_boolean_t
name|refresh_ignores
parameter_list|,
name|apr_array_header_t
modifier|*
name|ignores
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|entry_exists
init|=
name|FALSE
decl_stmt|;
comment|/* Check cancellation; note that this catches recursive calls too. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Add this directory to revision control. */
name|err
operator|=
name|svn_wc_add_from_disk2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_EXISTS
operator|&&
name|force
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|entry_exists
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* Fetch ignores after adding to handle ignores on the directory itself      and ancestors via the single db optimization in libsvn_wc */
if|if
condition|(
name|refresh_ignores
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_get_ignores2
argument_list|(
operator|&
name|ignores
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|ctx
operator|->
name|config
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If DIR_ABSPATH is the root of an unversioned subtree then get the      following "autoprops":         1) Explicit and inherited svn:auto-props properties on           DIR_ABSPATH        2) auto-props from the CTX->CONFIG hash       Since this set of autoprops applies to all unversioned children of      DIR_ABSPATH, we will pass these along to any recursive calls to      add_dir_recursive() and calls to add_file() below.  Thus sparing      these callees from looking up the same information. */
if|if
condition|(
operator|!
name|entry_exists
operator|&&
name|config_autoprops
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__get_all_auto_props
argument_list|(
operator|&
name|config_autoprops
argument_list|,
name|dir_abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|dir_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the directory entries one by one and add those things to      version control. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_io_dirent2_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Check cancellation so you can cancel during an        * add of a directory with lots of files. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip over SVN admin directories. */
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|name
argument_list|,
name|iterpool
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|ignores
operator|&&
name|svn_wc_match_ignore_list
argument_list|(
name|name
argument_list|,
name|ignores
argument_list|,
name|iterpool
argument_list|)
condition|)
continue|continue;
comment|/* Construct the full path of the entry. */
name|abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Recurse on directories; add files; ignore the rest. */
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
name|depth
operator|>=
name|svn_depth_immediates
condition|)
block|{
name|svn_depth_t
name|depth_below_here
init|=
name|depth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|depth_below_here
operator|=
name|svn_depth_empty
expr_stmt|;
comment|/* When DIR_ABSPATH is the root of an unversioned subtree then              it and all of its children have the same set of ignores.  So              save any recursive calls the extra work of finding the same              set of ignores. */
if|if
condition|(
name|refresh_ignores
operator|&&
operator|!
name|entry_exists
condition|)
name|refresh_ignores
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_dir_recursive
argument_list|(
name|abspath
argument_list|,
name|depth_below_here
argument_list|,
name|force
argument_list|,
name|no_autoprops
argument_list|,
name|magic_cookie
argument_list|,
name|config_autoprops
argument_list|,
name|refresh_ignores
argument_list|,
name|ignores
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|dirent
operator|->
name|special
operator|)
operator|&&
name|depth
operator|>=
name|svn_depth_files
condition|)
block|{
name|err
operator|=
name|add_file
argument_list|(
name|abspath
argument_list|,
name|magic_cookie
argument_list|,
name|config_autoprops
argument_list|,
name|no_autoprops
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_EXISTS
operator|&&
name|force
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Destroy the per-iteration pool. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This structure is used as baton for collecting the config entries    in the auto-props section and any inherited svn:auto-props    properties. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|collect_auto_props_baton_t
block|{
comment|/* the hash table for storing the property name/value pairs */
name|apr_hash_t
modifier|*
name|autoprops
decl_stmt|;
comment|/* a pool used for allocating memory */
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
name|collect_auto_props_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implements svn_config_enumerator2_t callback.     For one auto-props config entry (NAME, VALUE), stash a copy of    NAME and VALUE, allocated in BATON->POOL, in BATON->AUTOPROP.    BATON must point to an collect_auto_props_baton_t. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|all_auto_props_collector
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|collect_auto_props_baton_t
modifier|*
name|autoprops_baton
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|autoprops
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* nothing to do here without a value */
if|if
condition|(
operator|*
name|value
operator|==
literal|0
condition|)
return|return
name|TRUE
return|;
name|split_props
argument_list|(
operator|&
name|autoprops
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|autoprops
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|this_value
decl_stmt|;
name|char
modifier|*
name|property
init|=
name|APR_ARRAY_IDX
argument_list|(
name|autoprops
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
decl_stmt|;
name|char
modifier|*
name|equal_sign
init|=
name|strchr
argument_list|(
name|property
argument_list|,
literal|'='
argument_list|)
decl_stmt|;
if|if
condition|(
name|equal_sign
condition|)
block|{
operator|*
name|equal_sign
operator|=
literal|'\0'
expr_stmt|;
name|equal_sign
operator|++
expr_stmt|;
name|trim_string
argument_list|(
operator|&
name|equal_sign
argument_list|)
expr_stmt|;
name|unquote_string
argument_list|(
operator|&
name|equal_sign
argument_list|)
expr_stmt|;
name|this_value
operator|=
name|equal_sign
expr_stmt|;
block|}
else|else
block|{
name|this_value
operator|=
literal|""
expr_stmt|;
block|}
name|trim_string
argument_list|(
operator|&
name|property
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|property
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|apr_hash_t
modifier|*
name|pattern_hash
init|=
name|svn_hash_gets
argument_list|(
name|autoprops_baton
operator|->
name|autoprops
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
decl_stmt|;
comment|/* Force reserved boolean property values to '*'. */
if|if
condition|(
name|svn_prop_is_boolean
argument_list|(
name|property
argument_list|)
condition|)
block|{
comment|/* SVN_PROP_EXECUTABLE, SVN_PROP_NEEDS_LOCK, SVN_PROP_SPECIAL */
name|propval
operator|=
name|svn_string_create
argument_list|(
literal|"*"
argument_list|,
name|autoprops_baton
operator|->
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|propval
operator|=
name|svn_string_create
argument_list|(
name|this_value
argument_list|,
name|autoprops_baton
operator|->
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|pattern_hash
condition|)
block|{
name|pattern_hash
operator|=
name|apr_hash_make
argument_list|(
name|autoprops_baton
operator|->
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|autoprops_baton
operator|->
name|autoprops
argument_list|,
name|apr_pstrdup
argument_list|(
name|autoprops_baton
operator|->
name|result_pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|pattern_hash
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|pattern_hash
argument_list|,
name|apr_pstrdup
argument_list|(
name|autoprops_baton
operator|->
name|result_pool
argument_list|,
name|property
argument_list|)
argument_list|,
name|propval
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Go up the directory tree from LOCAL_ABSPATH, looking for a versioned  * directory.  If found, return its path in *EXISTING_PARENT_ABSPATH.  * Otherwise, return SVN_ERR_CLIENT_NO_VERSIONED_PARENT. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_existing_parent
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|existing_parent_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
name|svn_wc_context_t
modifier|*
name|wc_ctx
init|=
name|ctx
operator|->
name|wc_ctx
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
operator|*
name|existing_parent_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|svn_dirent_is_root
argument_list|(
name|local_abspath
argument_list|,
name|strlen
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_NO_VERSIONED_PARENT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RESERVED_FILENAME_SPECIFIED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' ends in a reserved name"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_existing_parent
argument_list|(
name|existing_parent_abspath
argument_list|,
name|ctx
argument_list|,
name|parent_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_all_auto_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|autoprops
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_config_auto_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_opt_revision_t
name|rev
decl_stmt|;
name|svn_string_t
modifier|*
name|config_auto_prop
decl_stmt|;
name|svn_boolean_t
name|use_autoprops
decl_stmt|;
name|collect_auto_props_baton_t
name|autoprops_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|target_is_url
init|=
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg
init|=
name|ctx
operator|->
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
decl_stmt|;
operator|*
name|autoprops
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|autoprops_baton
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|autoprops_baton
operator|.
name|autoprops
operator|=
operator|*
name|autoprops
expr_stmt|;
comment|/* Are "traditional" auto-props enabled?  If so grab them from the     config.  This is our starting set auto-props, which may be overriden     by svn:auto-props. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|use_autoprops
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_ENABLE_AUTO_PROPS
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_autoprops
condition|)
name|svn_config_enumerate2
argument_list|(
name|cfg
argument_list|,
name|SVN_CONFIG_SECTION_AUTO_PROPS
argument_list|,
name|all_auto_props_collector
argument_list|,
operator|&
name|autoprops_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Convert the config file setting (if any) into a hash mapping file      patterns to as hash of prop-->val mappings. */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
name|rev
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
else|else
name|rev
operator|.
name|kind
operator|=
name|svn_opt_revision_working
expr_stmt|;
comment|/* If PATH_OR_URL is a WC path, then it might be unversioned, in which case      we find it's nearest versioned parent. */
do|do
block|{
name|err
operator|=
name|svn_client_propget5
argument_list|(
operator|&
name|props
argument_list|,
operator|&
name|inherited_config_auto_props
argument_list|,
name|SVN_PROP_INHERITABLE_AUTO_PROPS
argument_list|,
name|path_or_url
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|,
name|svn_depth_empty
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|target_is_url
operator|||
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_UNVERSIONED_RESOURCE
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_existing_parent
argument_list|(
operator|&
name|path_or_url
argument_list|,
name|ctx
argument_list|,
name|path_or_url
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
do|while
condition|(
name|err
operator|==
name|NULL
condition|)
do|;
comment|/* Stash any explicit PROPS for PARENT_PATH into the inherited props array,      since these are actually inherited props for LOCAL_ABSPATH. */
name|config_auto_prop
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|path_or_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|config_auto_prop
condition|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|new_iprop
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_iprop
argument_list|)
argument_list|)
decl_stmt|;
name|new_iprop
operator|->
name|path_or_url
operator|=
name|path_or_url
expr_stmt|;
name|new_iprop
operator|->
name|prop_hash
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|new_iprop
operator|->
name|prop_hash
argument_list|,
name|SVN_PROP_INHERITABLE_AUTO_PROPS
argument_list|,
name|config_auto_prop
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|inherited_config_auto_props
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
operator|=
name|new_iprop
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_config_auto_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_prop_inherited_item_t
modifier|*
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_config_auto_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|elt
operator|->
name|prop_hash
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|propval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|ch
init|=
name|propval
operator|->
name|data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|config_auto_prop_pattern
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|config_auto_prop_val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|config_auto_prop_pattern
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|config_auto_prop_val
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Parse svn:auto-props value. */
while|while
condition|(
operator|*
name|ch
operator|!=
literal|'\0'
condition|)
block|{
name|svn_stringbuf_setempty
argument_list|(
name|config_auto_prop_pattern
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|config_auto_prop_val
argument_list|)
expr_stmt|;
comment|/* Parse the file pattern. */
while|while
condition|(
operator|*
name|ch
operator|!=
literal|'\0'
operator|&&
operator|*
name|ch
operator|!=
literal|'='
operator|&&
operator|*
name|ch
operator|!=
literal|'\n'
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|config_auto_prop_pattern
argument_list|,
operator|*
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
name|svn_stringbuf_strip_whitespace
argument_list|(
name|config_auto_prop_pattern
argument_list|)
expr_stmt|;
comment|/* Parse the auto-prop group. */
while|while
condition|(
operator|*
name|ch
operator|!=
literal|'\0'
operator|&&
operator|*
name|ch
operator|!=
literal|'\n'
condition|)
block|{
name|svn_stringbuf_appendbyte
argument_list|(
name|config_auto_prop_val
argument_list|,
operator|*
name|ch
argument_list|)
expr_stmt|;
name|ch
operator|++
expr_stmt|;
block|}
comment|/* Strip leading '=' and whitespace from auto-prop group. */
if|if
condition|(
name|config_auto_prop_val
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'='
condition|)
name|svn_stringbuf_remove
argument_list|(
name|config_auto_prop_val
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|svn_stringbuf_strip_whitespace
argument_list|(
name|config_auto_prop_val
argument_list|)
expr_stmt|;
name|all_auto_props_collector
argument_list|(
name|config_auto_prop_pattern
operator|->
name|data
argument_list|,
name|config_auto_prop_val
operator|->
name|data
argument_list|,
operator|&
name|autoprops_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Skip to next line if any. */
while|while
condition|(
operator|*
name|ch
operator|!=
literal|'\0'
operator|&&
operator|*
name|ch
operator|!=
literal|'\n'
condition|)
name|ch
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|ch
operator|==
literal|'\n'
condition|)
name|ch
operator|++
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_inherited_ignores
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|ignores
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_opt_revision_t
name|rev
decl_stmt|;
name|apr_hash_t
modifier|*
name|explicit_ignores
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_ignores
decl_stmt|;
name|svn_boolean_t
name|target_is_url
init|=
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|explicit_prop
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|target_is_url
condition|)
name|rev
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
else|else
name|rev
operator|.
name|kind
operator|=
name|svn_opt_revision_working
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_propget5
argument_list|(
operator|&
name|explicit_ignores
argument_list|,
operator|&
name|inherited_ignores
argument_list|,
name|SVN_PROP_INHERITABLE_IGNORES
argument_list|,
name|path_or_url
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|,
name|svn_depth_empty
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|explicit_prop
operator|=
name|svn_hash_gets
argument_list|(
name|explicit_ignores
argument_list|,
name|path_or_url
argument_list|)
expr_stmt|;
if|if
condition|(
name|explicit_prop
condition|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|new_iprop
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_iprop
argument_list|)
argument_list|)
decl_stmt|;
name|new_iprop
operator|->
name|path_or_url
operator|=
name|path_or_url
expr_stmt|;
name|new_iprop
operator|->
name|prop_hash
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|new_iprop
operator|->
name|prop_hash
argument_list|,
name|SVN_PROP_INHERITABLE_IGNORES
argument_list|,
name|explicit_prop
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|inherited_ignores
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
operator|=
name|new_iprop
expr_stmt|;
block|}
operator|*
name|ignores
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_ignores
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_ignores
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|ignore_val
init|=
name|svn_hash_gets
argument_list|(
name|elt
operator|->
name|prop_hash
argument_list|,
name|SVN_PROP_INHERITABLE_IGNORES
argument_list|)
decl_stmt|;
if|if
condition|(
name|ignore_val
condition|)
name|svn_cstring_split_append
argument_list|(
operator|*
name|ignores
argument_list|,
name|ignore_val
operator|->
name|data
argument_list|,
literal|"\n\r\t\v "
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The main logic of the public svn_client_add5.  *  * EXISTING_PARENT_ABSPATH is the absolute path to the first existing  * parent directory of local_abspath. If not NULL, all missing parents  * of LOCAL_ABSPATH must be created before LOCAL_ABSPATH can be added. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
specifier|const
name|char
modifier|*
name|existing_parent_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_magic__cookie_t
modifier|*
name|magic_cookie
decl_stmt|;
name|apr_array_header_t
modifier|*
name|ignores
init|=
name|NULL
decl_stmt|;
name|svn_magic__init
argument_list|(
operator|&
name|magic_cookie
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|existing_parent_abspath
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_relpath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|components
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|parent_abspath
operator|=
name|existing_parent_abspath
expr_stmt|;
name|child_relpath
operator|=
name|svn_dirent_is_child
argument_list|(
name|existing_parent_abspath
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|components
operator|=
name|svn_path_decompose
argument_list|(
name|child_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|components
operator|->
name|nelts
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|parent_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|parent_abspath
argument_list|,
name|component
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|parent_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|!=
name|svn_node_none
operator|&&
name|disk_kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_NO_VERSIONED_PARENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' prevents creating parent of '%s'"
argument_list|)
argument_list|,
name|parent_abspath
argument_list|,
name|local_abspath
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* We use add_dir_recursive for all directory targets          and pass depth along no matter what it is, so that the          target's depth will be set correctly. */
name|err
operator|=
name|add_dir_recursive
argument_list|(
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|force
argument_list|,
name|no_autoprops
argument_list|,
name|magic_cookie
argument_list|,
name|NULL
argument_list|,
operator|!
name|no_ignore
argument_list|,
name|ignores
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|err
operator|=
name|add_file
argument_list|(
name|local_abspath
argument_list|,
name|magic_cookie
argument_list|,
name|NULL
argument_list|,
name|no_autoprops
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
name|svn_boolean_t
name|tree_conflicted
decl_stmt|;
comment|/* Provide a meaningful error message if the node does not exist        * on disk but is a tree conflict victim. */
name|err
operator|=
name|svn_wc_conflicted_p3
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tree_conflicted
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tree_conflicted
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_FOUND_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is an existing item in conflict; "
literal|"please mark the conflict as resolved "
literal|"before adding a new item here"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' not found"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported node kind for path '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* Ignore SVN_ERR_ENTRY_EXISTS when FORCE is set.  */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_EXISTS
operator|&&
name|force
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_add5
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_boolean_t
name|add_parents
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|existing_parent_abspath
decl_stmt|;
name|svn_boolean_t
name|is_wc_root
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if we're being asked to add a wc-root.  That's typically not      okay, unless we're in "force" mode.  svn_wc__is_wcroot()      will return TRUE even if LOCAL_ABSPATH is a *symlink* to a working      copy root, which is a scenario we want to treat differently.  */
name|err
operator|=
name|svn_wc__is_wcroot
argument_list|(
operator|&
name|is_wc_root
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
comment|/* SVN_NO_ERROR */
name|is_wc_root
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|is_wc_root
condition|)
block|{
ifdef|#
directive|ifdef
name|HAVE_SYMLINK
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|svn_boolean_t
name|is_special
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
operator|&
name|is_special
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A symlink can be an unversioned target and a wcroot. Lets try to add          the symlink, which can't be a wcroot. */
if|if
condition|(
name|is_special
condition|)
name|is_wc_root
operator|=
name|FALSE
expr_stmt|;
else|else
endif|#
directive|endif
block|{
if|if
condition|(
operator|!
name|force
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is already under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|is_wc_root
condition|)
name|parent_abspath
operator|=
name|local_abspath
expr_stmt|;
comment|/* We will only add children */
else|else
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|existing_parent_abspath
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|add_parents
operator|&&
operator|!
name|is_wc_root
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|existing_parent_abspath2
decl_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_existing_parent
argument_list|(
operator|&
name|existing_parent_abspath2
argument_list|,
name|ctx
argument_list|,
name|parent_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|existing_parent_abspath2
argument_list|,
name|parent_abspath
argument_list|)
operator|!=
literal|0
condition|)
name|existing_parent_abspath
operator|=
name|existing_parent_abspath2
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|add
argument_list|(
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|force
argument_list|,
name|no_ignore
argument_list|,
name|no_autoprops
argument_list|,
name|existing_parent_abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
operator|(
name|existing_parent_abspath
condition|?
name|existing_parent_abspath
else|:
name|parent_abspath
operator|)
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|path_driver_cb_func
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|callback_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_path_check_valid
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|parent_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
name|dir_baton
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Append URL, and all it's non-existent parent directories, to TARGETS.    Use TEMPPOOL for temporary allocations and POOL for any additions to    TARGETS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_url_parents
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|apr_pool_t
modifier|*
name|temppool
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_url
init|=
name|svn_uri_dirname
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|parent_url
argument_list|,
name|temppool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|temppool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|add_url_parents
argument_list|(
name|ra_session
argument_list|,
name|parent_url
argument_list|,
name|targets
argument_list|,
name|temppool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|url
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mkdir_urls
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|urls
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_msg
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|apr_hash_t
modifier|*
name|targets_hash
decl_stmt|;
name|apr_hash_t
modifier|*
name|commit_revprops
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|common
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Find any non-existent parent directories */
if|if
condition|(
name|make_parents
condition|)
block|{
name|apr_array_header_t
modifier|*
name|all_urls
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|urls
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|first_url
init|=
name|APR_ARRAY_IDX
argument_list|(
name|urls
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|first_url
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|urls
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|APR_ARRAY_IDX
argument_list|(
name|urls
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_url_parents
argument_list|(
name|ra_session
argument_list|,
name|url
argument_list|,
name|all_urls
argument_list|,
name|iterpool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|urls
operator|=
name|all_urls
expr_stmt|;
block|}
comment|/* Condense our list of mkdir targets. */
name|SVN_ERR
argument_list|(
name|svn_uri_condense_targets
argument_list|(
operator|&
name|common
argument_list|,
operator|&
name|targets
argument_list|,
name|urls
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*Remove duplicate targets introduced by make_parents with more targets. */
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|targets_hash
argument_list|,
name|targets
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_keys
argument_list|(
operator|&
name|targets
argument_list|,
name|targets_hash
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|targets
operator|->
name|nelts
condition|)
block|{
specifier|const
name|char
modifier|*
name|bname
decl_stmt|;
name|svn_uri_split
argument_list|(
operator|&
name|common
argument_list|,
operator|&
name|bname
argument_list|,
name|common
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|bname
expr_stmt|;
if|if
condition|(
operator|*
name|bname
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"There is no valid URI above '%s'"
argument_list|)
argument_list|,
name|common
argument_list|)
return|;
block|}
else|else
block|{
name|svn_boolean_t
name|resplit
init|=
name|FALSE
decl_stmt|;
comment|/* We can't "mkdir" the root of an editor drive, so if one of          our targets is the empty string, we need to back everything          up by a path component. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
operator|*
name|path
condition|)
block|{
name|resplit
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|resplit
condition|)
block|{
specifier|const
name|char
modifier|*
name|bname
decl_stmt|;
name|svn_uri_split
argument_list|(
operator|&
name|common
argument_list|,
operator|&
name|bname
argument_list|,
name|common
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bname
operator|==
literal|'\0'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"There is no valid URI above '%s'"
argument_list|)
argument_list|,
name|common
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|path
operator|=
name|svn_relpath_join
argument_list|(
name|bname
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
block|}
block|}
block|}
name|qsort
argument_list|(
name|targets
operator|->
name|elts
argument_list|,
name|targets
operator|->
name|nelts
argument_list|,
name|targets
operator|->
name|elt_size
argument_list|,
name|svn_sort_compare_paths
argument_list|)
expr_stmt|;
comment|/* ### This reparent may be problematic in limited-authz-to-common-parent      ### scenarios (compare issue #3242).  See also issue #3649. */
if|if
condition|(
name|ra_session
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|common
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create new commit items and add them to the array. */
if|if
condition|(
name|SVN_CLIENT__HAS_LOG_MSG_FUNC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|item
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|common
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__get_log_msg
argument_list|(
operator|&
name|log_msg
argument_list|,
operator|&
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_msg
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|log_msg
operator|=
literal|""
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_revprop_table
argument_list|(
operator|&
name|commit_revprops
argument_list|,
name|revprop_table
argument_list|,
name|log_msg
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open an RA session for the URL. Note that we don't have a local      directory, nor a place to put temp files. */
if|if
condition|(
operator|!
name|ra_session
condition|)
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|common
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|common
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch RA commit editor */
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|ra_session
argument_list|,
name|svn_client__get_shim_callbacks
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|commit_revprops
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
comment|/* No lock tokens */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the path-based editor driver. */
name|err
operator|=
name|svn_delta_path_driver2
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|targets
argument_list|,
name|TRUE
argument_list|,
name|path_driver_cb_func
argument_list|,
operator|(
name|void
operator|*
operator|)
name|editor
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* At least try to abort the edit (and fs txn) before throwing err. */
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Close the edit. */
return|return
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__make_local_parents
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_node_kind_t
name|orig_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|path
argument_list|,
operator|&
name|orig_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_parents
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Should no longer use svn_depth_empty to indicate that only the directory      itself is added, since it not only constraints the operation depth, but      also defines the depth of the target directory now. Moreover, the new      directory will have no children at all.*/
name|err
operator|=
name|svn_client_add5
argument_list|(
name|path
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|make_parents
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we created a new directory, but couldn't add it to version      control, then delete it. */
if|if
condition|(
name|err
operator|&&
operator|(
name|orig_kind
operator|==
name|svn_node_none
operator|)
condition|)
block|{
comment|/* ### If this returns an error, should we link it onto          err instead, so that the user is warned that we just          created an unversioned directory? */
name|svn_error_clear
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_mkdir4
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|paths
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_client__assert_homogeneous_target_type
argument_list|(
name|paths
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|mkdir_urls
argument_list|(
name|paths
argument_list|,
name|make_parents
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a regular "mkdir" + "svn add" */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* See if the user wants us to stop. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__make_local_parents
argument_list|(
name|path
argument_list|,
name|make_parents
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

