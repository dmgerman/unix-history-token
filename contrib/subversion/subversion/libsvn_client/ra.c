begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * ra.c :  routines for interacting with the RA layer  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This is the baton that we pass svn_ra_open3(), and is associated with    the callback table we provide to RA. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|callback_baton_t
block|{
comment|/* Holds the directory that corresponds to the REPOS_URL at svn_ra_open3()      time. When callbacks specify a relative path, they are joined with      this base directory. */
specifier|const
name|char
modifier|*
name|base_dir_abspath
decl_stmt|;
comment|/* TEMPORARY: Is 'base_dir_abspath' a versioned path?  cmpilato      suspects that the commit-to-multiple-disjoint-working-copies      code is getting this all wrong, sometimes passing an unversioned      (or versioned in a foreign wc) path here which sorta kinda      happens to work most of the time but is ultimately incorrect.  */
name|svn_boolean_t
name|base_dir_isversioned
decl_stmt|;
comment|/* Used as wri_abspath for obtaining access to the pristine store */
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
comment|/* An array of svn_client_commit_item3_t * structures, present only      during working copy commits. */
specifier|const
name|apr_array_header_t
modifier|*
name|commit_items
decl_stmt|;
comment|/* A client context. */
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
block|}
name|callback_baton_t
typedef|;
end_typedef

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_tmp_file
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the 'svn_ra_get_wc_prop_func_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_wc_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|callback_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
operator|*
name|value
operator|=
name|NULL
expr_stmt|;
comment|/* If we have a list of commit_items, search through that for a      match for this relative URL. */
if|if
condition|(
name|cb
operator|->
name|commit_items
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|cb
operator|->
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|relpath
argument_list|,
name|item
operator|->
name|session_relpath
argument_list|)
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|item
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|item
operator|->
name|path
expr_stmt|;
break|break;
block|}
block|}
comment|/* Commits can only query relpaths in the commit_items list          since the commit driver traverses paths as they are, or will          be, in the repository.  Non-commits query relpaths in the          working copy. */
if|if
condition|(
operator|!
name|local_abspath
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we don't have a base directory, then there are no properties. */
elseif|else
if|if
condition|(
name|cb
operator|->
name|base_dir_abspath
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
else|else
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|cb
operator|->
name|base_dir_abspath
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc_prop_get2
argument_list|(
name|value
argument_list|,
name|cb
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|name
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the 'svn_ra_push_wc_prop_func_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|push_wc_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|callback_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If we're committing, search through the commit_items list for a      match for this relative URL. */
if|if
condition|(
operator|!
name|cb
operator|->
name|commit_items
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempt to set wcprop '%s' on '%s' in a non-commit operation"
argument_list|)
argument_list|,
name|name
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|relpath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|cb
operator|->
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|relpath
argument_list|,
name|item
operator|->
name|session_relpath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|apr_pool_t
modifier|*
name|changes_pool
init|=
name|item
operator|->
name|incoming_prop_changes
operator|->
name|pool
decl_stmt|;
name|svn_prop_t
modifier|*
name|prop
init|=
name|apr_palloc
argument_list|(
name|changes_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop
argument_list|)
argument_list|)
decl_stmt|;
name|prop
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|changes_pool
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
condition|)
name|prop
operator|->
name|value
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|changes_pool
argument_list|)
expr_stmt|;
else|else
name|prop
operator|->
name|value
operator|=
name|NULL
expr_stmt|;
comment|/* Buffer the propchange to take effect during the              post-commit process. */
name|APR_ARRAY_PUSH
argument_list|(
name|item
operator|->
name|incoming_prop_changes
argument_list|,
name|svn_prop_t
operator|*
argument_list|)
operator|=
name|prop
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the 'svn_ra_set_wc_prop_func_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_wc_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|callback_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|cb
operator|->
name|base_dir_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We pass 1 for the 'force' parameter here.  Since the property is      coming from the repository, we definitely want to accept it.      Ideally, we'd raise a conflict if, say, the received property is      svn:eol-style yet the file has a locally added svn:mime-type      claiming that it's binary.  Probably the repository is still      right, but the conflict would remind the user to make sure.      Unfortunately, we don't have a clean mechanism for doing that      here, so we just set the property and hope for the best. */
return|return
name|svn_error_trace
argument_list|(
name|svn_wc_prop_set4
argument_list|(
name|cb
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|svn_depth_empty
argument_list|,
name|TRUE
comment|/* skip_checks */
argument_list|,
name|NULL
comment|/* changelist_filter */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* cancellation */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* notification */
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the `svn_ra_invalidate_wc_props_func_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|invalidate_wc_props
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|callback_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|cb
operator|->
name|base_dir_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* It's easier just to clear the whole dav_cache than to remove      individual items from it recursively like this.  And since we      know that the RA providers that ship with Subversion only      invalidate the one property they use the most from this cache,      and that we're intentionally trying to get away from the use of      the cache altogether anyway, there's little to lose in wiping the      whole cache.  Is it the most well-behaved approach to take?  Not      so much.  We choose not to care.  */
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__node_clear_dav_cache_recursive
argument_list|(
name|cb
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the `svn_ra_get_wc_contents_func_t' interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_wc_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|callback_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|cb
operator|->
name|wcroot_abspath
condition|)
block|{
operator|*
name|contents
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__get_pristine_contents_by_checksum
argument_list|(
name|contents
argument_list|,
name|cb
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|cb
operator|->
name|wcroot_abspath
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cancel_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|callback_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
call|(
name|b
operator|->
name|ctx
operator|->
name|cancel_func
call|)
argument_list|(
name|b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_client_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|callback_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
operator|*
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|b
operator|->
name|ctx
operator|->
name|client_name
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_define
define|#
directive|define
name|SVN_CLIENT__MAX_REDIRECT_ATTEMPTS
value|3
end_define

begin_comment
comment|/* ### TODO:  Make configurable. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client__open_ra_session_internal
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|corrected_url
parameter_list|,
specifier|const
name|char
modifier|*
name|base_url
parameter_list|,
specifier|const
name|char
modifier|*
name|base_dir_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|commit_items
parameter_list|,
name|svn_boolean_t
name|write_dav_props
parameter_list|,
name|svn_boolean_t
name|read_dav_props
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_callbacks2_t
modifier|*
name|cbtable
decl_stmt|;
name|callback_baton_t
modifier|*
name|cb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
init|=
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|write_dav_props
operator|||
name|read_dav_props
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|read_dav_props
operator|||
name|base_dir_abspath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|base_dir_abspath
operator|==
name|NULL
operator|||
name|svn_dirent_is_absolute
argument_list|(
name|base_dir_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_create_callbacks
argument_list|(
operator|&
name|cbtable
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cbtable
operator|->
name|open_tmp_file
operator|=
name|open_tmp_file
expr_stmt|;
name|cbtable
operator|->
name|get_wc_prop
operator|=
name|read_dav_props
condition|?
name|get_wc_prop
else|:
name|NULL
expr_stmt|;
name|cbtable
operator|->
name|set_wc_prop
operator|=
operator|(
name|write_dav_props
operator|&&
name|read_dav_props
operator|)
condition|?
name|set_wc_prop
else|:
name|NULL
expr_stmt|;
name|cbtable
operator|->
name|push_wc_prop
operator|=
name|commit_items
condition|?
name|push_wc_prop
else|:
name|NULL
expr_stmt|;
name|cbtable
operator|->
name|invalidate_wc_props
operator|=
operator|(
name|write_dav_props
operator|&&
name|read_dav_props
operator|)
condition|?
name|invalidate_wc_props
else|:
name|NULL
expr_stmt|;
name|cbtable
operator|->
name|auth_baton
operator|=
name|ctx
operator|->
name|auth_baton
expr_stmt|;
comment|/* new-style */
name|cbtable
operator|->
name|progress_func
operator|=
name|ctx
operator|->
name|progress_func
expr_stmt|;
name|cbtable
operator|->
name|progress_baton
operator|=
name|ctx
operator|->
name|progress_baton
expr_stmt|;
name|cbtable
operator|->
name|cancel_func
operator|=
name|ctx
operator|->
name|cancel_func
condition|?
name|cancel_callback
else|:
name|NULL
expr_stmt|;
name|cbtable
operator|->
name|get_client_string
operator|=
name|get_client_string
expr_stmt|;
if|if
condition|(
name|base_dir_abspath
condition|)
name|cbtable
operator|->
name|get_wc_contents
operator|=
name|get_wc_contents
expr_stmt|;
name|cb
operator|->
name|commit_items
operator|=
name|commit_items
expr_stmt|;
name|cb
operator|->
name|ctx
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
name|base_dir_abspath
operator|&&
operator|(
name|read_dav_props
operator|||
name|write_dav_props
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|uuid
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|base_dir_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_WORKING_COPY
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_UPGRADE_REQUIRED
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|uuid
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|cb
operator|->
name|base_dir_isversioned
operator|=
name|TRUE
expr_stmt|;
block|}
name|cb
operator|->
name|base_dir_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|base_dir_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|base_dir_abspath
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|cb
operator|->
name|wcroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|base_dir_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_UPGRADE_REQUIRED
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|cb
operator|->
name|wcroot_abspath
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* If the caller allows for auto-following redirections, and the      RA->open() call above reveals a CORRECTED_URL, try the new URL.      We'll do this in a loop up to some maximum number follow-and-retry      attempts.  */
if|if
condition|(
name|corrected_url
condition|)
block|{
name|apr_hash_t
modifier|*
name|attempted
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|attempts_left
init|=
name|SVN_CLIENT__MAX_REDIRECT_ATTEMPTS
decl_stmt|;
operator|*
name|corrected_url
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|attempts_left
operator|--
condition|)
block|{
specifier|const
name|char
modifier|*
name|corrected
init|=
name|NULL
decl_stmt|;
comment|/* Try to open the RA session.  If this is our last attempt,              don't accept corrected URLs from the RA provider. */
name|SVN_ERR
argument_list|(
name|svn_ra_open4
argument_list|(
name|ra_session
argument_list|,
name|attempts_left
operator|==
literal|0
condition|?
name|NULL
else|:
operator|&
name|corrected
argument_list|,
name|base_url
argument_list|,
name|uuid
argument_list|,
name|cbtable
argument_list|,
name|cb
argument_list|,
name|ctx
operator|->
name|config
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No error and no corrected URL?  We're done here. */
if|if
condition|(
operator|!
name|corrected
condition|)
break|break;
comment|/* Notify the user that a redirect is being followed. */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
operator|!=
name|NULL
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify_url
argument_list|(
name|corrected
argument_list|,
name|svn_wc_notify_url_redirect
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Our caller will want to know what our final corrected URL was. */
operator|*
name|corrected_url
operator|=
name|corrected
expr_stmt|;
comment|/* Make sure we've not attempted this URL before. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|attempted
argument_list|,
name|corrected
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_CYCLE_DETECTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Redirect cycle detected for URL '%s'"
argument_list|)
argument_list|,
name|corrected
argument_list|)
return|;
comment|/* Remember this CORRECTED_URL so we don't wind up in a loop. */
name|svn_hash_sets
argument_list|(
name|attempted
argument_list|,
name|corrected
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
name|base_url
operator|=
name|corrected
expr_stmt|;
block|}
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_open4
argument_list|(
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|base_url
argument_list|,
name|uuid
argument_list|,
name|cbtable
argument_list|,
name|cb
argument_list|,
name|ctx
operator|->
name|config
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_undef
undef|#
directive|undef
name|SVN_CLIENT__MAX_REDIRECT_ATTEMPTS
end_undef

begin_function
name|svn_error_t
modifier|*
name|svn_client_open_ra_session2
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
name|session
argument_list|,
name|NULL
argument_list|,
name|url
argument_list|,
name|wri_abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__resolve_rev_and_url
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|resolved_loc_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_opt_revision_t
name|peg_rev
init|=
operator|*
name|peg_revision
decl_stmt|;
name|svn_opt_revision_t
name|start_rev
init|=
operator|*
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* Default revisions: peg -> working or head; operative -> peg. */
name|SVN_ERR
argument_list|(
name|svn_opt_resolve_revisions
argument_list|(
operator|&
name|peg_rev
argument_list|,
operator|&
name|start_rev
argument_list|,
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
argument_list|,
name|TRUE
comment|/* notice_local_mods */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the history function to get the object's (possibly      different) url in REVISION. */
name|SVN_ERR
argument_list|(
name|svn_client__repos_locations
argument_list|(
operator|&
name|url
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ra_session
argument_list|,
name|path_or_url
argument_list|,
operator|&
name|peg_rev
argument_list|,
operator|&
name|start_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__pathrev_create_with_session
argument_list|(
name|resolved_loc_p
argument_list|,
name|ra_session
argument_list|,
name|rev
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__ra_session_from_path2
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|ra_session_p
parameter_list|,
name|svn_client__pathrev_t
modifier|*
modifier|*
name|resolved_loc_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|char
modifier|*
name|base_dir_abspath
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
specifier|const
name|char
modifier|*
name|initial_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|corrected_url
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|resolved_loc
decl_stmt|;
specifier|const
name|char
modifier|*
name|wri_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_url_from_path2
argument_list|(
operator|&
name|initial_url
argument_list|,
name|path_or_url
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|initial_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_MISSING_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' has no URL"
argument_list|)
argument_list|,
name|path_or_url
argument_list|)
return|;
if|if
condition|(
name|base_dir_abspath
condition|)
name|wri_abspath
operator|=
name|base_dir_abspath
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|wri_abspath
argument_list|,
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|wri_abspath
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|corrected_url
argument_list|,
name|initial_url
argument_list|,
name|wri_abspath
argument_list|,
name|NULL
comment|/* commit_items */
argument_list|,
name|base_dir_abspath
operator|!=
name|NULL
argument_list|,
name|base_dir_abspath
operator|!=
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we got a CORRECTED_URL, we'll want to refer to that as the      URL-ized form of PATH_OR_URL from now on. */
if|if
condition|(
name|corrected_url
operator|&&
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
name|path_or_url
operator|=
name|corrected_url
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_rev_and_url
argument_list|(
operator|&
name|resolved_loc
argument_list|,
name|ra_session
argument_list|,
name|path_or_url
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the session point to the real URL. */
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|resolved_loc
operator|->
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ra_session_p
operator|=
name|ra_session
expr_stmt|;
if|if
condition|(
name|resolved_loc_p
condition|)
operator|*
name|resolved_loc_p
operator|=
name|resolved_loc
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__ensure_ra_session_url
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|old_session_url
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|session_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|ra_session
argument_list|,
name|old_session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|session_url
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|old_session_url
argument_list|,
name|session_url
argument_list|)
operator|!=
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Repository Locations ***/
end_comment

begin_struct
struct|struct
name|gls_receiver_baton_t
block|{
name|apr_array_header_t
modifier|*
name|segments
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|gls_receiver
parameter_list|(
name|svn_location_segment_t
modifier|*
name|segment
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|gls_receiver_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|b
operator|->
name|segments
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
operator|=
name|svn_location_segment_dup
argument_list|(
name|segment
argument_list|,
name|b
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
name|b
operator|->
name|ctx
operator|->
name|cancel_func
call|)
argument_list|(
name|b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A qsort-compatible function which sorts svn_location_segment_t's    based on their revision range covering, resulting in ascending    (oldest-to-youngest) ordering. */
end_comment

begin_function
specifier|static
name|int
name|compare_segments
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_location_segment_t
modifier|*
name|a_seg
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_location_segment_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|svn_location_segment_t
modifier|*
name|b_seg
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_location_segment_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
if|if
condition|(
name|a_seg
operator|->
name|range_start
operator|==
name|b_seg
operator|->
name|range_start
condition|)
return|return
literal|0
return|;
return|return
operator|(
name|a_seg
operator|->
name|range_start
operator|<
name|b_seg
operator|->
name|range_start
operator|)
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__repos_location_segments
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|segments
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|gls_receiver_baton_t
name|gls_receiver_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_session_url
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
operator|*
name|segments
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|8
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_location_segment_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|gls_receiver_baton
operator|.
name|segments
operator|=
operator|*
name|segments
expr_stmt|;
name|gls_receiver_baton
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|gls_receiver_baton
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_session_url
argument_list|,
name|ra_session
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_location_segments
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|peg_revision
argument_list|,
name|start_revision
argument_list|,
name|end_revision
argument_list|,
name|gls_receiver
argument_list|,
operator|&
name|gls_receiver_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|old_session_url
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
operator|(
operator|*
name|segments
operator|)
operator|->
name|elts
argument_list|,
operator|(
operator|*
name|segments
operator|)
operator|->
name|nelts
argument_list|,
operator|(
operator|*
name|segments
operator|)
operator|->
name|elt_size
argument_list|,
name|compare_segments
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *START_URL and *END_URL to the URLs that the object URL@PEG_REVNUM  * had in revisions START_REVNUM and END_REVNUM.  Return an error if the  * node cannot be traced back to one of the requested revisions.  *  * START_URL and/or END_URL may be NULL if not wanted.  START_REVNUM and  * END_REVNUM must be valid revision numbers except that END_REVNUM may  * be SVN_INVALID_REVNUM if END_URL is NULL.  *  * RA_SESSION is an open RA session parented at URL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repos_locations
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|start_url
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|end_url
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|peg_revnum
parameter_list|,
name|svn_revnum_t
name|start_revnum
parameter_list|,
name|svn_revnum_t
name|end_revnum
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_url
decl_stmt|,
modifier|*
name|start_path
decl_stmt|,
modifier|*
name|end_path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|revs
decl_stmt|;
name|apr_hash_t
modifier|*
name|rev_locs
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|peg_revnum
operator|!=
name|SVN_INVALID_REVNUM
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|start_revnum
operator|!=
name|SVN_INVALID_REVNUM
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|end_revnum
operator|!=
name|SVN_INVALID_REVNUM
operator|||
name|end_url
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Avoid a network request in the common easy case. */
if|if
condition|(
name|start_revnum
operator|==
name|peg_revnum
operator|&&
operator|(
name|end_revnum
operator|==
name|peg_revnum
operator|||
name|end_revnum
operator|==
name|SVN_INVALID_REVNUM
operator|)
condition|)
block|{
if|if
condition|(
name|start_url
condition|)
operator|*
name|start_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_url
condition|)
operator|*
name|end_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|revs
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revs
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|start_revnum
expr_stmt|;
if|if
condition|(
name|end_revnum
operator|!=
name|start_revnum
operator|&&
name|end_revnum
operator|!=
name|SVN_INVALID_REVNUM
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|revs
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|end_revnum
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_locations
argument_list|(
name|ra_session
argument_list|,
operator|&
name|rev_locs
argument_list|,
literal|""
argument_list|,
name|peg_revnum
argument_list|,
name|revs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We'd better have all the paths we were looking for! */
if|if
condition|(
name|start_url
condition|)
block|{
name|start_path
operator|=
name|apr_hash_get
argument_list|(
name|rev_locs
argument_list|,
operator|&
name|start_revnum
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|start_path
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unable to find repository location for '%s' in revision %ld"
argument_list|)
argument_list|,
name|url
argument_list|,
name|start_revnum
argument_list|)
return|;
operator|*
name|start_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_url
argument_list|,
name|start_path
operator|+
literal|1
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|end_url
condition|)
block|{
name|end_path
operator|=
name|apr_hash_get
argument_list|(
name|rev_locs
argument_list|,
operator|&
name|end_revnum
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|end_path
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The location for '%s' for revision %ld does not exist in the "
literal|"repository or refers to an unrelated object"
argument_list|)
argument_list|,
name|url
argument_list|,
name|end_revnum
argument_list|)
return|;
operator|*
name|end_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_url
argument_list|,
name|end_path
operator|+
literal|1
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__repos_location
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|op_loc_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|peg_loc
parameter_list|,
name|svn_revnum_t
name|op_revnum
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|old_session_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|op_url
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_session_url
argument_list|,
name|ra_session
argument_list|,
name|peg_loc
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|repos_locations
argument_list|(
operator|&
name|op_url
argument_list|,
name|NULL
argument_list|,
name|ra_session
argument_list|,
name|peg_loc
operator|->
name|url
argument_list|,
name|peg_loc
operator|->
name|rev
argument_list|,
name|op_revnum
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|old_session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|op_loc_p
operator|=
name|svn_client__pathrev_create
argument_list|(
name|peg_loc
operator|->
name|repos_root_url
argument_list|,
name|peg_loc
operator|->
name|repos_uuid
argument_list|,
name|op_revnum
argument_list|,
name|op_url
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__repos_locations
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|start_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|start_revision
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|end_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|end_revision
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|start
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|end
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath_or_url
decl_stmt|;
name|svn_revnum_t
name|peg_revnum
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_revnum_t
name|start_revnum
decl_stmt|,
name|end_revnum
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Ensure that we are given some real revision data to work with.      (It's okay if the END is unspecified -- in that case, we'll just      set it to the same thing as START.)  */
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|||
name|start
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|end
operator|==
name|NULL
condition|)
block|{
specifier|static
specifier|const
name|svn_opt_revision_t
name|unspecified_rev
init|=
block|{
name|svn_opt_revision_unspecified
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|end
operator|=
operator|&
name|unspecified_rev
expr_stmt|;
block|}
comment|/* Determine LOCAL_ABSPATH_OR_URL, URL, and possibly PEG_REVNUM.      If we are looking at the working version of a WC path that is scheduled      as a copy, then we need to use the copy-from URL and peg revision. */
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath_or_url
argument_list|,
name|path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_boolean_t
name|is_copy
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
operator|&
name|is_copy
argument_list|,
operator|&
name|peg_revnum
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath_or_url
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|url
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|url
operator|&&
name|is_copy
operator|&&
name|ra_session
condition|)
block|{
specifier|const
name|char
modifier|*
name|session_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|ra_session
argument_list|,
operator|&
name|session_url
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|session_url
argument_list|,
name|url
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* We can't use the caller provided RA session now :( */
name|ra_session
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
else|else
name|url
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|url
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_url
argument_list|(
operator|&
name|url
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath_or_url
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|url
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_MISSING_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' has no URL"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|local_abspath_or_url
operator|=
name|path
expr_stmt|;
name|url
operator|=
name|path
expr_stmt|;
block|}
comment|/* ### We should be smarter here.  If the callers just asks for BASE and      WORKING revisions, we should already have the correct URLs, so we      don't need to do anything more here in that case. */
comment|/* Open a RA session to this URL if we don't have one already. */
if|if
condition|(
operator|!
name|ra_session
condition|)
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|url
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resolve the opt_revision_ts. */
if|if
condition|(
name|peg_revnum
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|peg_revnum
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath_or_url
argument_list|,
name|ra_session
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|start_revnum
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath_or_url
argument_list|,
name|ra_session
argument_list|,
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|end_revnum
operator|=
name|start_revnum
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|end_revnum
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath_or_url
argument_list|,
name|ra_session
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the output revision variables. */
if|if
condition|(
name|start_revision
condition|)
block|{
operator|*
name|start_revision
operator|=
name|start_revnum
expr_stmt|;
block|}
if|if
condition|(
name|end_revision
operator|&&
name|end
operator|->
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
operator|*
name|end_revision
operator|=
name|end_revnum
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|repos_locations
argument_list|(
name|start_url
argument_list|,
name|end_url
argument_list|,
name|ra_session
argument_list|,
name|url
argument_list|,
name|peg_revnum
argument_list|,
name|start_revnum
argument_list|,
name|end_revnum
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__calc_youngest_common_ancestor
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|ancestor_p
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc1
parameter_list|,
name|apr_hash_t
modifier|*
name|history1
parameter_list|,
name|svn_boolean_t
name|has_rev_zero_history1
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc2
parameter_list|,
name|apr_hash_t
modifier|*
name|history2
parameter_list|,
name|svn_boolean_t
name|has_rev_zero_history2
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_revnum_t
name|yc_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|char
modifier|*
name|yc_relpath
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|loc1
operator|->
name|repos_root_url
argument_list|,
name|loc2
operator|->
name|repos_root_url
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|ancestor_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Loop through the first location's history, check for overlapping      paths and ranges in the second location's history, and      remembering the youngest matching location. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|history1
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|path_len
init|=
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|ranges1
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|ranges2
decl_stmt|,
modifier|*
name|common
decl_stmt|;
name|ranges2
operator|=
name|apr_hash_get
argument_list|(
name|history2
argument_list|,
name|path
argument_list|,
name|path_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|ranges2
condition|)
block|{
comment|/* We have a path match.  Now, did our two histories share              any revisions at that path? */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|common
argument_list|,
name|ranges1
argument_list|,
name|ranges2
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|common
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|yc_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|common
argument_list|,
name|common
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|yc_revision
argument_list|)
operator|)
operator|||
operator|(
name|yc_range
operator|->
name|end
operator|>
name|yc_revision
operator|)
condition|)
block|{
name|yc_revision
operator|=
name|yc_range
operator|->
name|end
expr_stmt|;
name|yc_relpath
operator|=
name|path
operator|+
literal|1
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* It's possible that PATH_OR_URL1 and PATH_OR_URL2's only common      history is revision 0. */
if|if
condition|(
operator|!
name|yc_relpath
operator|&&
name|has_rev_zero_history1
operator|&&
name|has_rev_zero_history2
condition|)
block|{
name|yc_relpath
operator|=
literal|""
expr_stmt|;
name|yc_revision
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|yc_relpath
condition|)
block|{
operator|*
name|ancestor_p
operator|=
name|svn_client__pathrev_create_with_relpath
argument_list|(
name|loc1
operator|->
name|repos_root_url
argument_list|,
name|loc1
operator|->
name|repos_uuid
argument_list|,
name|yc_revision
argument_list|,
name|yc_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ancestor_p
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_youngest_common_ancestor
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|ancestor_p
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc1
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc2
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|sesspool
init|=
name|NULL
decl_stmt|;
name|apr_hash_t
modifier|*
name|history1
decl_stmt|,
modifier|*
name|history2
decl_stmt|;
name|svn_boolean_t
name|has_rev_zero_history1
decl_stmt|;
name|svn_boolean_t
name|has_rev_zero_history2
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|loc1
operator|->
name|repos_root_url
argument_list|,
name|loc2
operator|->
name|repos_root_url
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|ancestor_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Open an RA session for the two locations. */
if|if
condition|(
name|session
operator|==
name|NULL
condition|)
block|{
name|sesspool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|session
argument_list|,
name|loc1
operator|->
name|url
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|sesspool
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We're going to cheat and use history-as-mergeinfo because it      saves us a bunch of annoying custom data comparisons and such. */
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|history1
argument_list|,
operator|&
name|has_rev_zero_history1
argument_list|,
name|loc1
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|history2
argument_list|,
operator|&
name|has_rev_zero_history2
argument_list|,
name|loc2
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the ra session if we opened one. */
if|if
condition|(
name|sesspool
condition|)
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__calc_youngest_common_ancestor
argument_list|(
name|ancestor_p
argument_list|,
name|loc1
argument_list|,
name|history1
argument_list|,
name|has_rev_zero_history1
argument_list|,
name|loc2
argument_list|,
name|history2
argument_list|,
name|has_rev_zero_history2
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__youngest_common_ancestor
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|ancestor_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|ancestor_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url1
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision1
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url2
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision2
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|sesspool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|loc1
decl_stmt|,
modifier|*
name|loc2
decl_stmt|,
modifier|*
name|ancestor
decl_stmt|;
comment|/* Resolve the two locations */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|session
argument_list|,
operator|&
name|loc1
argument_list|,
name|path_or_url1
argument_list|,
name|NULL
argument_list|,
name|revision1
argument_list|,
name|revision1
argument_list|,
name|ctx
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_rev_and_url
argument_list|(
operator|&
name|loc2
argument_list|,
name|session
argument_list|,
name|path_or_url2
argument_list|,
name|revision2
argument_list|,
name|revision2
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_youngest_common_ancestor
argument_list|(
operator|&
name|ancestor
argument_list|,
name|loc1
argument_list|,
name|loc2
argument_list|,
name|session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ancestor
condition|)
block|{
operator|*
name|ancestor_url
operator|=
name|ancestor
operator|->
name|url
expr_stmt|;
operator|*
name|ancestor_rev
operator|=
name|ancestor
operator|->
name|rev
expr_stmt|;
block|}
else|else
block|{
operator|*
name|ancestor_url
operator|=
name|NULL
expr_stmt|;
operator|*
name|ancestor_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|ra_ev2_baton
block|{
comment|/* The working copy context, from the client context.  */
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
comment|/* For a given REPOS_RELPATH, provide a LOCAL_ABSPATH that represents      that repository node.  */
name|apr_hash_t
modifier|*
name|relpath_map
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|svn_error_t
modifier|*
name|svn_client__ra_provide_base
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ra_ev2_baton
modifier|*
name|reb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|local_abspath
operator|=
name|svn_hash_gets
argument_list|(
name|reb
operator|->
name|relpath_map
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_abspath
condition|)
block|{
operator|*
name|contents
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|err
operator|=
name|svn_wc_get_pristine_contents2
argument_list|(
name|contents
argument_list|,
name|reb
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|*
name|contents
operator|!=
name|NULL
condition|)
block|{
comment|/* The pristine contents refer to the BASE, or to the pristine of          a copy/move to this location. Fetch the correct revision.  */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
name|NULL
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|reb
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__ra_provide_props
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ra_ev2_baton
modifier|*
name|reb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|local_abspath
operator|=
name|svn_hash_gets
argument_list|(
name|reb
operator|->
name|relpath_map
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_abspath
condition|)
block|{
operator|*
name|props
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|err
operator|=
name|svn_wc_get_pristine_props
argument_list|(
name|props
argument_list|,
name|reb
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|*
name|props
operator|!=
name|NULL
condition|)
block|{
comment|/* The pristine props refer to the BASE, or to the pristine props of          a copy/move to this location. Fetch the correct revision.  */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
name|NULL
argument_list|,
name|revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|reb
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__ra_get_copysrc_kind
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|svn_revnum_t
name|src_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ra_ev2_baton
modifier|*
name|reb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|local_abspath
operator|=
name|svn_hash_gets
argument_list|(
name|reb
operator|->
name|relpath_map
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_abspath
condition|)
block|{
operator|*
name|kind
operator|=
name|svn_node_unknown
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* ### what to do with SRC_REVISION?  */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
name|kind
argument_list|,
name|reb
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|svn_client__ra_make_cb_baton
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|apr_hash_t
modifier|*
name|relpath_map
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|struct
name|ra_ev2_baton
modifier|*
name|reb
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reb
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|wc_ctx
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|relpath_map
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|reb
operator|->
name|wc_ctx
operator|=
name|wc_ctx
expr_stmt|;
name|reb
operator|->
name|relpath_map
operator|=
name|relpath_map
expr_stmt|;
return|return
name|reb
return|;
block|}
end_function

end_unit

