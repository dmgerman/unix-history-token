begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * switch.c:  implement 'switch' feature via WC& RA interfaces.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* This feature is essentially identical to 'svn update' (see    ./update.c), but with two differences:       - the reporter->finish_report() routine needs to make the server        run delta_dirs() on two *different* paths, rather than on two        identical paths.       - after the update runs, we need to more than just        ensure_uniform_revision;  we need to rewrite all the entries'        URL attributes. */
end_comment

begin_comment
comment|/* A conflict callback that simply records the conflicted path in BATON.     Implements svn_wc_conflict_resolver_func2_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_conflict
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|description
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|conflicted_paths
init|=
name|baton
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|conflicted_paths
argument_list|,
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|conflicted_paths
argument_list|)
argument_list|,
name|description
operator|->
name|local_abspath
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|svn_wc_create_conflict_result
argument_list|(
name|svn_wc_conflict_choose_postpone
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ...     Add the paths of any conflict victims to CONFLICTED_PATHS, if that    is not null. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|switch_internal
parameter_list|(
name|svn_revnum_t
modifier|*
name|result_rev
parameter_list|,
name|apr_hash_t
modifier|*
name|conflicted_paths
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
decl_stmt|;
name|void
modifier|*
name|report_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|anchor_url
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|switch_loc
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_revnum_t
name|revnum
decl_stmt|;
specifier|const
name|char
modifier|*
name|diff3_cmd
decl_stmt|;
name|apr_hash_t
modifier|*
name|wcroot_iprops
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
name|svn_boolean_t
name|use_commit_times
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|switch_editor
decl_stmt|;
name|void
modifier|*
name|switch_edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|preserved_exts_str
decl_stmt|;
name|apr_array_header_t
modifier|*
name|preserved_exts
decl_stmt|;
name|svn_boolean_t
name|server_supports_depth
decl_stmt|;
name|struct
name|svn_client__dirent_fetcher_baton_t
name|dfb
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg
init|=
name|ctx
operator|->
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
decl_stmt|;
comment|/* An unknown depth can't be sticky. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth_is_sticky
operator|=
name|FALSE
expr_stmt|;
comment|/* Do not support the situation of both exclude and switch a target. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_exclude
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot both exclude and switch a path"
argument_list|)
argument_list|)
return|;
comment|/* Get the external diff3, if any. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|diff3_cmd
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_DIFF3_CMD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff3_cmd
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
operator|&
name|diff3_cmd
argument_list|,
name|diff3_cmd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if the user wants last-commit timestamps instead of current ones. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|use_commit_times
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_USE_COMMIT_TIMES
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|svn_boolean_t
name|has_working
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_has_working
argument_list|(
operator|&
name|has_working
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_working
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot switch '%s' because it is not in the "
literal|"repository yet"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* See which files the user wants to preserve the extension of when      conflict files are made. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|preserved_exts_str
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_PRESERVED_CF_EXTS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|preserved_exts
operator|=
operator|*
name|preserved_exts_str
condition|?
name|svn_cstring_split
argument_list|(
name|preserved_exts_str
argument_list|,
literal|"\n\r\t\v "
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Sanity check.  Without these, the switch is meaningless. */
name|SVN_ERR_ASSERT
argument_list|(
name|switch_url
operator|&&
operator|(
name|switch_url
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|local_abspath
argument_list|,
name|anchor_abspath
argument_list|)
condition|)
name|target
operator|=
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
literal|""
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_url
argument_list|(
operator|&
name|anchor_url
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|anchor_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_MISSING_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory '%s' has no URL"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|anchor_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
comment|/* We may need to crop the tree if the depth is sticky */
if|if
condition|(
name|depth_is_sticky
operator|&&
name|depth
operator|<
name|svn_depth_infinity
condition|)
block|{
name|svn_node_kind_t
name|target_kind
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_exclude
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_exclude
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Target excluded, we are done now */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|target_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_crop_tree2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Open an RA session to 'source' URL */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|switch_loc
argument_list|,
name|switch_url
argument_list|,
name|anchor_abspath
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Disallow a switch operation to change the repository root of the      target. */
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|switch_loc
operator|->
name|repos_root_url
argument_list|,
name|anchor_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_INVALID_SWITCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s'\nis not the same repository as\n'%s'"
argument_list|)
argument_list|,
name|anchor_url
argument_list|,
name|switch_loc
operator|->
name|repos_root_url
argument_list|)
return|;
comment|/* If we're not ignoring ancestry, then error out if the switch      source and target don't have a common ancestory.       ### We're acting on the anchor here, not the target.  Is that      ### okay? */
if|if
condition|(
operator|!
name|ignore_ancestry
condition|)
block|{
name|svn_client__pathrev_t
modifier|*
name|target_base_loc
decl_stmt|,
modifier|*
name|yca
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__wc_node_get_base
argument_list|(
operator|&
name|target_base_loc
argument_list|,
name|local_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target_base_loc
condition|)
name|yca
operator|=
name|NULL
expr_stmt|;
comment|/* Not versioned */
else|else
block|{
comment|/* ### It would be nice if this function could reuse the existing              ra session instead of opening two for its own use. */
name|SVN_ERR
argument_list|(
name|svn_client__get_youngest_common_ancestor
argument_list|(
operator|&
name|yca
argument_list|,
name|switch_loc
argument_list|,
name|target_base_loc
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|yca
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' shares no common ancestry with '%s'"
argument_list|)
argument_list|,
name|switch_url
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
name|wcroot_iprops
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Will the base of LOCAL_ABSPATH require an iprop cache post-switch?      If we are switching LOCAL_ABSPATH to the root of the repository then      we don't need to cache inherited properties.  In all other cases we      *might* need to cache iprops. */
if|if
condition|(
name|strcmp
argument_list|(
name|switch_loc
operator|->
name|repos_root_url
argument_list|,
name|switch_loc
operator|->
name|url
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|svn_boolean_t
name|wc_root
decl_stmt|;
name|svn_boolean_t
name|needs_iprop_cache
init|=
name|TRUE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__is_wcroot
argument_list|(
operator|&
name|wc_root
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Switching the WC root to anything but the repos root means          we need an iprop cache. */
if|if
condition|(
operator|!
name|wc_root
condition|)
block|{
comment|/* We know we are switching a subtree to something other than the              repos root, but if we are unswitching that subtree we don't              need an iprops cache. */
specifier|const
name|char
modifier|*
name|target_parent_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|unswitched_url
decl_stmt|;
comment|/* Calculate the URL LOCAL_ABSPATH would have if it was unswitched              relative to its parent. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_url
argument_list|(
operator|&
name|target_parent_url
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|unswitched_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|target_parent_url
argument_list|,
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If LOCAL_ABSPATH will be unswitched relative to its parent, then              it doesn't need an iprop cache.  Note: It doesn't matter if              LOCAL_ABSPATH is withing a switched subtree, only if it's the              *root* of a switched subtree.*/
if|if
condition|(
name|strcmp
argument_list|(
name|unswitched_url
argument_list|,
name|switch_loc
operator|->
name|url
argument_list|)
operator|==
literal|0
condition|)
name|needs_iprop_cache
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|needs_iprop_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_inherited_props
argument_list|(
name|ra_session
argument_list|,
operator|&
name|inherited_props
argument_list|,
literal|""
argument_list|,
name|switch_loc
operator|->
name|rev
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|wcroot_iprops
argument_list|,
name|local_abspath
argument_list|,
name|inherited_props
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|anchor_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the switch (update) editor.  If REVISION is invalid, that's      okay; the RA driver will call editor->set_target_revision() later on. */
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|server_supports_depth
argument_list|,
name|SVN_RA_CAPABILITY_DEPTH
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|dfb
operator|.
name|ra_session
operator|=
name|ra_session
expr_stmt|;
name|dfb
operator|.
name|anchor_url
operator|=
name|anchor_url
expr_stmt|;
name|dfb
operator|.
name|target_revision
operator|=
name|switch_loc
operator|->
name|rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_switch_editor
argument_list|(
operator|&
name|switch_editor
argument_list|,
operator|&
name|switch_edit_baton
argument_list|,
operator|&
name|revnum
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|anchor_abspath
argument_list|,
name|target
argument_list|,
name|switch_loc
operator|->
name|url
argument_list|,
name|wcroot_iprops
argument_list|,
name|use_commit_times
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|server_supports_depth
argument_list|,
name|diff3_cmd
argument_list|,
name|preserved_exts
argument_list|,
name|svn_client__dirent_fetcher
argument_list|,
operator|&
name|dfb
argument_list|,
name|conflicted_paths
condition|?
name|record_conflict
else|:
name|NULL
argument_list|,
name|conflicted_paths
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell RA to do an update of URL+TARGET to REVISION; if we pass an      invalid revnum, that means RA will use the latest revision. */
name|SVN_ERR
argument_list|(
name|svn_ra_do_switch3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|reporter
argument_list|,
operator|&
name|report_baton
argument_list|,
name|switch_loc
operator|->
name|rev
argument_list|,
name|target
argument_list|,
name|depth_is_sticky
condition|?
name|depth
else|:
name|svn_depth_unknown
argument_list|,
name|switch_loc
operator|->
name|url
argument_list|,
name|FALSE
comment|/* send_copyfrom_args */
argument_list|,
name|ignore_ancestry
argument_list|,
name|switch_editor
argument_list|,
name|switch_edit_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Past this point, we assume the WC is going to be modified so we will    * need to sleep for timestamps. */
operator|*
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
comment|/* Drive the reporter structure, describing the revisions within      PATH.  When we call reporter->finish_report, the update_editor      will be driven by svn_repos_dir_delta2. */
name|SVN_ERR
argument_list|(
name|svn_wc_crawl_revisions5
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|TRUE
argument_list|,
name|depth
argument_list|,
operator|(
operator|!
name|depth_is_sticky
operator|)
argument_list|,
operator|(
operator|!
name|server_supports_depth
operator|)
argument_list|,
name|use_commit_times
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We handle externals after the switch is complete, so that      handling external items (and any errors therefrom) doesn't delay      the primary operation. */
if|if
condition|(
name|SVN_DEPTH_IS_RECURSIVE
argument_list|(
name|depth
argument_list|)
operator|&&
operator|(
operator|!
name|ignore_externals
operator|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|new_externals
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_depths
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__externals_gather_definitions
argument_list|(
operator|&
name|new_externals
argument_list|,
operator|&
name|new_depths
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__handle_externals
argument_list|(
name|new_externals
argument_list|,
name|new_depths
argument_list|,
name|switch_loc
operator|->
name|repos_root_url
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|timestamp_sleep
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Let everyone know we're finished here. */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|anchor_abspath
argument_list|,
name|svn_wc_notify_update_completed
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
name|revnum
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the caller wants the result revision, give it to them. */
if|if
condition|(
name|result_rev
condition|)
operator|*
name|result_rev
operator|=
name|revnum
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__switch_internal
parameter_list|(
name|svn_revnum_t
modifier|*
name|result_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|,
modifier|*
name|anchor_abspath
decl_stmt|;
name|svn_boolean_t
name|acquired_lock
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|err1
decl_stmt|,
modifier|*
name|err2
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_paths
init|=
name|ctx
operator|->
name|conflict_func2
condition|?
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
else|:
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rely on svn_wc__acquire_write_lock setting ANCHOR_ABSPATH even      when it returns SVN_ERR_WC_LOCKED */
name|err
operator|=
name|svn_wc__acquire_write_lock
argument_list|(
operator|&
name|anchor_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_LOCKED
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|acquired_lock
operator|=
operator|(
name|err
operator|==
name|SVN_NO_ERROR
operator|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err1
operator|=
name|switch_internal
argument_list|(
name|result_rev
argument_list|,
name|conflicted_paths
argument_list|,
name|local_abspath
argument_list|,
name|anchor_abspath
argument_list|,
name|switch_url
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|ignore_externals
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|ignore_ancestry
argument_list|,
name|timestamp_sleep
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Give the conflict resolver callback the opportunity to    * resolve any conflicts that were raised. */
if|if
condition|(
operator|!
name|err1
operator|&&
name|ctx
operator|->
name|conflict_func2
condition|)
block|{
name|err1
operator|=
name|svn_client__resolve_conflicts
argument_list|(
name|NULL
argument_list|,
name|conflicted_paths
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|acquired_lock
condition|)
name|err2
operator|=
name|svn_wc__release_write_lock
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|anchor_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|err2
operator|=
name|SVN_NO_ERROR
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err1
argument_list|,
name|err2
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_switch3
parameter_list|(
name|svn_revnum_t
modifier|*
name|result_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|sleep_here
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|err
operator|=
name|svn_client__switch_internal
argument_list|(
name|result_rev
argument_list|,
name|path
argument_list|,
name|switch_url
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|ignore_externals
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|ignore_ancestry
argument_list|,
operator|&
name|sleep_here
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Sleep to ensure timestamp integrity (we do this regardless of      errors in the actual switch operation(s)). */
if|if
condition|(
name|sleep_here
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

