begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * externals.c:  handle the svn:externals property  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_comment
comment|/* Remove the directory at LOCAL_ABSPATH from revision control, and do the  * same to any revision controlled directories underneath LOCAL_ABSPATH  * (including directories not referred to by parent svn administrative areas);  * then if LOCAL_ABSPATH is empty afterwards, remove it, else rename it to a  * unique name in the same parent directory.  *  * Pass CANCEL_FUNC, CANCEL_BATON to svn_wc_remove_from_revision_control.  *  * Use SCRATCH_POOL for all temporary allocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|relegate_dir_external
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__acquire_write_lock
argument_list|(
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__external_remove
argument_list|(
name|wc_ctx
argument_list|,
name|wri_abspath
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_LEFT_LOCAL_MOD
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|dirname
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_path
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|parent_dir
argument_list|,
operator|&
name|dirname
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Reserve the new dir name. */
name|SVN_ERR
argument_list|(
name|svn_io_open_uniquely_named
argument_list|(
name|NULL
argument_list|,
operator|&
name|new_path
argument_list|,
name|parent_dir
argument_list|,
name|dirname
argument_list|,
literal|".OLD"
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Sigh...  We must fall ever so slightly from grace.           Ideally, there would be no window, however brief, when we          don't have a reservation on the new name.  Unfortunately,          at least in the Unix (Linux?) version of apr_file_rename(),          you can't rename a directory over a file, because it's just          calling stdio rename(), which says:              ENOTDIR               A  component used as a directory in oldpath or newpath               path is not, in fact, a directory.  Or, oldpath  is               a directory, and newpath exists but is not a directory           So instead, we get the name, then remove the file (ugh), then          rename the directory, hoping that nobody has gotten that name          in the meantime -- which would never happen in real life, so          no big deal.       */
comment|/* Do our best, but no biggy if it fails. The rename will fail. */
name|svn_error_clear
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|new_path
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Rename. If this is still a working copy we should use the working          copy rename function (to release open handles) */
name|err
operator|=
name|svn_wc__rename_wc
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|new_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* And if it is no longer a working copy, we should just rename              it */
name|err
operator|=
name|svn_io_file_rename
argument_list|(
name|local_abspath
argument_list|,
name|new_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* ### TODO: We should notify the user about the rename */
if|if
condition|(
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|err
condition|?
name|local_abspath
else|:
name|new_path
argument_list|,
name|svn_wc_notify_left_local_modifications
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Try to update a directory external at PATH to URL at REVISION.    Use POOL for temporary allocations, and use the client context CTX. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|switch_dir_external
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|defining_abspath
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_revnum_t
name|external_peg_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_revnum_t
name|external_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|peg_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_number
condition|)
name|external_peg_rev
operator|=
name|peg_revision
operator|->
name|value
operator|.
name|number
expr_stmt|;
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_number
condition|)
name|external_rev
operator|=
name|revision
operator|->
name|value
operator|.
name|number
expr_stmt|;
comment|/* If path is a directory, try to update/switch to the correct URL      and revision. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
specifier|const
name|char
modifier|*
name|node_url
decl_stmt|;
comment|/* Doubles as an "is versioned" check. */
name|err
operator|=
name|svn_wc__node_get_url
argument_list|(
operator|&
name|node_url
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
goto|goto
name|relegate
goto|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|node_url
condition|)
block|{
comment|/* If we have what appears to be a version controlled              subdir, and its top-level URL matches that of our              externals definition, perform an update. */
if|if
condition|(
name|strcmp
argument_list|(
name|node_url
argument_list|,
name|url
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__update_internal
argument_list|(
name|NULL
argument_list|,
name|local_abspath
argument_list|,
name|revision
argument_list|,
name|svn_depth_unknown
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|timestamp_sleep
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
comment|/* We'd really prefer not to have to do a brute-force              relegation -- blowing away the current external working              copy and checking it out anew -- so we'll first see if we              can get away with a generally cheaper relocation (if              required) and switch-style update.               To do so, we need to know the repository root URL of the              external working copy as it currently sits. */
name|err
operator|=
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|repos_root_url
operator|=
name|NULL
expr_stmt|;
name|repos_uuid
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|repos_root_url
condition|)
block|{
comment|/* If the new external target URL is not obviously a                  child of the external working copy's current                  repository root URL... */
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|url
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
comment|/* ... then figure out precisely which repository                       root URL that target URL *is* a child of ... */
name|SVN_ERR
argument_list|(
name|svn_client_get_repos_root
argument_list|(
operator|&
name|repos_root
argument_list|,
name|NULL
argument_list|,
name|url
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... and use that to try to relocate the external                      working copy to the target location.  */
name|err
operator|=
name|svn_client_relocate2
argument_list|(
name|local_abspath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_root
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* If the relocation failed because the new URL                      points to a totally different repository, we've                      no choice but to relegate and check out a new WC. */
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_INVALID_RELOCATION
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_INVALID_RELOCATION
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
goto|goto
name|relegate
goto|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* If the relocation went without a hitch, we should                      have a new repository root URL. */
name|repos_root_url
operator|=
name|repos_root
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__switch_internal
argument_list|(
name|NULL
argument_list|,
name|local_abspath
argument_list|,
name|url
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|svn_depth_infinity
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|TRUE
comment|/* ignore_ancestry */
argument_list|,
name|timestamp_sleep
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__external_register
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|defining_abspath
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|url
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|external_peg_rev
argument_list|,
name|external_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
name|relegate
label|:
comment|/* Fall back on removing the WC and checking out a new one. */
comment|/* Ensure that we don't have any RA sessions or WC locks from failed      operations above. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* Buh-bye, old and busted ... */
name|SVN_ERR
argument_list|(
name|relegate_dir_external
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|defining_abspath
argument_list|,
name|local_abspath
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The target dir might have multiple components.  Guarantee          the path leading down to the last component. */
specifier|const
name|char
modifier|*
name|parent
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|parent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ... Hello, new hotness. */
name|SVN_ERR
argument_list|(
name|svn_client__checkout_internal
argument_list|(
name|NULL
argument_list|,
name|url
argument_list|,
name|local_abspath
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|timestamp_sleep
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__external_register
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|defining_abspath
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|external_peg_rev
argument_list|,
name|external_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|cleanup
label|:
comment|/* Issues #4123 and #4130: We don't need to keep the newly checked      out external's DB open. */
name|SVN_ERR
argument_list|(
name|svn_wc__close_db
argument_list|(
name|local_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Try to update a file external at LOCAL_ABSPATH to URL at REVISION using a    access baton that has a write lock.  Use SCRATCH_POOL for temporary    allocations, and use the client context CTX. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|switch_file_external
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
specifier|const
name|char
modifier|*
name|def_dir_abspath
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
init|=
name|ctx
operator|->
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
decl_stmt|;
name|svn_boolean_t
name|use_commit_times
decl_stmt|;
specifier|const
name|char
modifier|*
name|diff3_cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|preserved_exts_str
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|preserved_exts
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|,
name|external_kind
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if the user wants last-commit timestamps instead of current ones. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|use_commit_times
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_USE_COMMIT_TIMES
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the external diff3, if any. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|diff3_cmd
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_DIFF3_CMD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff3_cmd
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
operator|&
name|diff3_cmd
argument_list|,
name|diff3_cmd
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See which files the user wants to preserve the extension of when      conflict files are made. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|preserved_exts_str
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_PRESERVED_CF_EXTS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|preserved_exts
operator|=
operator|*
name|preserved_exts_str
condition|?
name|svn_cstring_split
argument_list|(
name|preserved_exts_str
argument_list|,
literal|"\n\r\t\v "
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* File externals can only be installed inside the current working copy.        So verify if the working copy that contains/will contain the target        is the defining abspath, or one of its ancestors */
if|if
condition|(
operator|!
name|svn_dirent_is_ancestor
argument_list|(
name|wcroot_abspath
argument_list|,
name|def_dir_abspath
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_BAD_PATH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot insert a file external defined on '%s' "
literal|"into the working copy '%s'."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|def_dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wcroot_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_external_info
argument_list|(
operator|&
name|external_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is a versioned item with this name, ensure it's a file      external before working with it.  If there is no entry in the      working copy, then create an empty file and add it to the working      copy. */
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
operator|&&
name|kind
operator|!=
name|svn_node_unknown
condition|)
block|{
if|if
condition|(
name|external_kind
operator|!=
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_FILE_EXTERNAL_OVERWRITE_VERSIONED
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"The file external from '%s' cannot overwrite the existing "
literal|"versioned item at '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
operator|||
name|kind
operator|==
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The file external '%s' can not be "
literal|"created because the node exists."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|{
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
decl_stmt|;
name|void
modifier|*
name|report_baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|switch_editor
decl_stmt|;
name|void
modifier|*
name|switch_baton
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|switch_loc
decl_stmt|;
name|svn_revnum_t
name|revnum
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|svn_dirent_split
argument_list|(
operator|&
name|dir_abspath
argument_list|,
operator|&
name|target
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Open an RA session to 'source' URL */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|switch_loc
argument_list|,
name|url
argument_list|,
name|dir_abspath
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the external file's iprops. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_inherited_props
argument_list|(
name|ra_session
argument_list|,
operator|&
name|inherited_props
argument_list|,
literal|""
argument_list|,
name|switch_loc
operator|->
name|rev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|svn_uri_dirname
argument_list|(
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_file_external_editor
argument_list|(
operator|&
name|switch_editor
argument_list|,
operator|&
name|switch_baton
argument_list|,
operator|&
name|revnum
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|def_dir_abspath
argument_list|,
name|switch_loc
operator|->
name|url
argument_list|,
name|switch_loc
operator|->
name|repos_root_url
argument_list|,
name|switch_loc
operator|->
name|repos_uuid
argument_list|,
name|inherited_props
argument_list|,
name|use_commit_times
argument_list|,
name|diff3_cmd
argument_list|,
name|preserved_exts
argument_list|,
name|def_dir_abspath
argument_list|,
name|url
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|ctx
operator|->
name|conflict_func2
argument_list|,
name|ctx
operator|->
name|conflict_baton2
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell RA to do an update of URL+TARGET to REVISION; if we pass an      invalid revnum, that means RA will use the latest revision. */
name|SVN_ERR
argument_list|(
name|svn_ra_do_switch3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|reporter
argument_list|,
operator|&
name|report_baton
argument_list|,
name|switch_loc
operator|->
name|rev
argument_list|,
name|target
argument_list|,
name|svn_depth_unknown
argument_list|,
name|url
argument_list|,
name|FALSE
comment|/* send_copyfrom */
argument_list|,
name|TRUE
comment|/* ignore_ancestry */
argument_list|,
name|switch_editor
argument_list|,
name|switch_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__crawl_file_external
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|TRUE
argument_list|,
name|use_commit_times
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_completed
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
name|revnum
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrappers around svn_wc__external_remove, obtaining and releasing a lock for    directory externals */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_external2
parameter_list|(
name|svn_boolean_t
modifier|*
name|removed
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|external_kind
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__external_remove
argument_list|(
name|wc_ctx
argument_list|,
name|wri_abspath
argument_list|,
name|local_abspath
argument_list|,
operator|(
name|external_kind
operator|==
name|svn_node_none
operator|)
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|removed
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_external
parameter_list|(
name|svn_boolean_t
modifier|*
name|removed
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|external_kind
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|removed
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|external_kind
condition|)
block|{
case|case
name|svn_node_dir
case|:
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|remove_external2
argument_list|(
name|removed
argument_list|,
name|wc_ctx
argument_list|,
name|wri_abspath
argument_list|,
name|local_abspath
argument_list|,
name|external_kind
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_file
case|:
default|default:
name|SVN_ERR
argument_list|(
name|remove_external2
argument_list|(
name|removed
argument_list|,
name|wc_ctx
argument_list|,
name|wri_abspath
argument_list|,
name|local_abspath
argument_list|,
name|external_kind
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Called when an external that is in the EXTERNALS table is no longer    referenced from an svn:externals property */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_external_item_removal
parameter_list|(
specifier|const
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|defining_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_node_kind_t
name|external_kind
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|removed
init|=
name|FALSE
decl_stmt|;
comment|/* local_abspath should be a wcroot or a file external */
name|SVN_ERR
argument_list|(
name|svn_wc__read_external_info
argument_list|(
operator|&
name|external_kind
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|defining_abspath
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_kind
operator|!=
name|kind
condition|)
name|external_kind
operator|=
name|svn_node_none
expr_stmt|;
comment|/* Only remove the registration */
name|err
operator|=
name|remove_external
argument_list|(
operator|&
name|removed
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|defining_abspath
argument_list|,
name|local_abspath
argument_list|,
name|external_kind
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_LOCKED
operator|&&
name|removed
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
comment|/* We removed the working copy, so we can't release the                      lock that was stored inside */
block|}
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_external_removed
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
call|(
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_LEFT_LOCAL_MOD
condition|)
block|{
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_left_local_modifications
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
call|(
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_LEFT_LOCAL_MOD
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_external_item_change
parameter_list|(
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_dir_url
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|old_defining_abspath
parameter_list|,
specifier|const
name|svn_wc_external_item2_t
modifier|*
name|new_item
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|new_loc
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_url
decl_stmt|;
name|svn_node_kind_t
name|ext_kind
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|repos_root_url
operator|&&
name|parent_dir_url
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|new_item
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Don't bother to check status, since we'll get that for free by      attempting to retrieve the hash values anyway.  */
comment|/* When creating the absolute URL, use the pool and not the      iterpool, since the hash table values outlive the iterpool and      any pointers they have should also outlive the iterpool.  */
name|SVN_ERR
argument_list|(
name|svn_wc__resolve_relative_external_url
argument_list|(
operator|&
name|new_url
argument_list|,
name|new_item
argument_list|,
name|repos_root_url
argument_list|,
name|parent_dir_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine if the external is a file or directory. */
comment|/* Get the RA connection. */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|new_loc
argument_list|,
name|new_url
argument_list|,
name|NULL
argument_list|,
operator|&
operator|(
name|new_item
operator|->
name|peg_revision
operator|)
argument_list|,
operator|&
operator|(
name|new_item
operator|->
name|revision
operator|)
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|new_loc
operator|->
name|rev
argument_list|,
operator|&
name|ext_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_node_none
operator|==
name|ext_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' at revision %ld doesn't exist"
argument_list|)
argument_list|,
name|new_loc
operator|->
name|url
argument_list|,
name|new_loc
operator|->
name|rev
argument_list|)
return|;
if|if
condition|(
name|svn_node_dir
operator|!=
name|ext_kind
operator|&&
name|svn_node_file
operator|!=
name|ext_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' at revision %ld is not a file "
literal|"or a directory"
argument_list|)
argument_list|,
name|new_loc
operator|->
name|url
argument_list|,
name|new_loc
operator|->
name|rev
argument_list|)
return|;
comment|/* Not protecting against recursive externals.  Detecting them in      the global case is hard, and it should be pretty obvious to a      user when it happens.  Worst case: your disk fills up :-). */
comment|/* First notify that we're about to handle an external. */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_external
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|old_defining_abspath
condition|)
block|{
comment|/* The target dir might have multiple components.  Guarantee the path          leading down to the last component. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|ext_kind
condition|)
block|{
case|case
name|svn_node_dir
case|:
name|SVN_ERR
argument_list|(
name|switch_dir_external
argument_list|(
name|local_abspath
argument_list|,
name|new_loc
operator|->
name|url
argument_list|,
operator|&
operator|(
name|new_item
operator|->
name|peg_revision
operator|)
argument_list|,
operator|&
operator|(
name|new_item
operator|->
name|revision
operator|)
argument_list|,
name|parent_dir_abspath
argument_list|,
name|timestamp_sleep
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_file
case|:
if|if
condition|(
name|strcmp
argument_list|(
name|repos_root_url
argument_list|,
name|new_loc
operator|->
name|repos_root_url
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|local_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|ext_repos_relpath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/*              * The working copy library currently requires that all files              * in the working copy have the same repository root URL.              * The URL from the file external's definition differs from the              * one used by the working copy. As a workaround, replace the              * root URL portion of the file external's URL, after making              * sure both URLs point to the same repository. See issue #4087.              */
name|err
operator|=
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|local_repos_root_url
argument_list|,
operator|&
name|local_repos_uuid
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|parent_dir_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|local_repos_root_url
operator|=
name|NULL
expr_stmt|;
name|local_repos_uuid
operator|=
name|NULL
expr_stmt|;
block|}
name|ext_repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|new_loc
operator|->
name|repos_root_url
argument_list|,
name|new_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_repos_uuid
operator|==
name|NULL
operator|||
name|local_repos_root_url
operator|==
name|NULL
operator|||
name|ext_repos_relpath
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|local_repos_uuid
argument_list|,
name|new_loc
operator|->
name|repos_uuid
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported external: URL of file external '%s' "
literal|"is not in repository '%s'"
argument_list|)
argument_list|,
name|new_url
argument_list|,
name|repos_root_url
argument_list|)
return|;
name|new_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|local_repos_root_url
argument_list|,
name|ext_repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|new_loc
argument_list|,
name|new_url
argument_list|,
name|NULL
argument_list|,
operator|&
operator|(
name|new_item
operator|->
name|peg_revision
operator|)
argument_list|,
operator|&
operator|(
name|new_item
operator|->
name|revision
operator|)
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|switch_file_external
argument_list|(
name|local_abspath
argument_list|,
name|new_url
argument_list|,
operator|&
name|new_item
operator|->
name|peg_revision
argument_list|,
operator|&
name|new_item
operator|->
name|revision
argument_list|,
name|parent_dir_abspath
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|wrap_external_error
parameter_list|(
specifier|const
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_CANCELLED
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notifier
init|=
name|svn_wc_create_notify
argument_list|(
name|target_abspath
argument_list|,
name|svn_wc_notify_failed_external
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notifier
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notifier
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_externals_change
parameter_list|(
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|new_desc_text
parameter_list|,
name|apr_hash_t
modifier|*
name|old_externals
parameter_list|,
name|svn_depth_t
name|ambient_depth
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|new_desc
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Bag out if the depth here is too shallow for externals action. */
if|if
condition|(
operator|(
name|requested_depth
operator|<
name|svn_depth_infinity
operator|&&
name|requested_depth
operator|!=
name|svn_depth_unknown
operator|)
operator|||
operator|(
name|ambient_depth
operator|<
name|svn_depth_infinity
operator|&&
name|requested_depth
operator|<
name|svn_depth_infinity
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|new_desc_text
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_parse_externals_description3
argument_list|(
operator|&
name|new_desc
argument_list|,
name|local_abspath
argument_list|,
name|new_desc_text
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|new_desc
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_url
argument_list|(
operator|&
name|url
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|url
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|new_desc
operator|&&
operator|(
name|i
operator|<
name|new_desc
operator|->
name|nelts
operator|)
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|old_defining_abspath
decl_stmt|;
name|svn_wc_external_item2_t
modifier|*
name|new_item
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
name|svn_boolean_t
name|under_root
decl_stmt|;
name|new_item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|new_desc
argument_list|,
name|i
argument_list|,
name|svn_wc_external_item2_t
operator|*
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_is_under_root
argument_list|(
operator|&
name|under_root
argument_list|,
operator|&
name|target_abspath
argument_list|,
name|local_abspath
argument_list|,
name|new_item
operator|->
name|target_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|under_root
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not in the working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|new_item
operator|->
name|target_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
name|old_defining_abspath
operator|=
name|svn_hash_gets
argument_list|(
name|old_externals
argument_list|,
name|target_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|wrap_external_error
argument_list|(
name|ctx
argument_list|,
name|target_abspath
argument_list|,
name|handle_external_item_change
argument_list|(
name|ctx
argument_list|,
name|repos_root_url
argument_list|,
name|local_abspath
argument_list|,
name|url
argument_list|,
name|target_abspath
argument_list|,
name|old_defining_abspath
argument_list|,
name|new_item
argument_list|,
name|timestamp_sleep
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And remove already processed items from the to-remove hash */
if|if
condition|(
name|old_defining_abspath
condition|)
name|svn_hash_sets
argument_list|(
name|old_externals
argument_list|,
name|target_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__handle_externals
parameter_list|(
name|apr_hash_t
modifier|*
name|externals_new
parameter_list|,
name|apr_hash_t
modifier|*
name|ambient_depths
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|old_external_defs
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|repos_root_url
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__externals_defined_below
argument_list|(
operator|&
name|old_external_defs
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|externals_new
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc_text
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_depth_t
name|ambient_depth
init|=
name|svn_depth_infinity
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ambient_depths
condition|)
block|{
specifier|const
name|char
modifier|*
name|ambient_depth_w
decl_stmt|;
name|ambient_depth_w
operator|=
name|apr_hash_get
argument_list|(
name|ambient_depths
argument_list|,
name|local_abspath
argument_list|,
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ambient_depth_w
operator|==
name|NULL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Traversal of '%s' found no ambient depth"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|ambient_depth
operator|=
name|svn_depth_from_word
argument_list|(
name|ambient_depth_w
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|handle_externals_change
argument_list|(
name|ctx
argument_list|,
name|repos_root_url
argument_list|,
name|timestamp_sleep
argument_list|,
name|local_abspath
argument_list|,
name|desc_text
argument_list|,
name|old_external_defs
argument_list|,
name|ambient_depth
argument_list|,
name|requested_depth
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Remove the remaining externals */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|old_external_defs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|item_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|defining_abspath
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|wrap_external_error
argument_list|(
name|ctx
argument_list|,
name|item_abspath
argument_list|,
name|handle_external_item_removal
argument_list|(
name|ctx
argument_list|,
name|defining_abspath
argument_list|,
name|item_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Are there any unversioned directories between the removed        * external and the DEFINING_ABSPATH which we can remove? */
name|parent_abspath
operator|=
name|item_abspath
expr_stmt|;
do|do
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|parent_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
name|FALSE
comment|/* show_deleted*/
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_io_dir_remove_nonrecursive
argument_list|(
name|parent_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOTEMPTY
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
break|break;
comment|/* No parents to delete */
block|}
elseif|else
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Fall through; parent dir might be unversioned */
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
block|}
do|while
condition|(
name|strcmp
argument_list|(
name|parent_abspath
argument_list|,
name|defining_abspath
argument_list|)
operator|!=
literal|0
condition|)
do|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__export_externals
parameter_list|(
name|apr_hash_t
modifier|*
name|externals
parameter_list|,
specifier|const
name|char
modifier|*
name|from_url
parameter_list|,
specifier|const
name|char
modifier|*
name|to_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
name|svn_depth_t
name|requested_depth
parameter_list|,
specifier|const
name|char
modifier|*
name|native_eol
parameter_list|,
name|svn_boolean_t
name|ignore_keywords
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|sub_iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|to_abspath
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|externals
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|desc_text
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_url
decl_stmt|;
name|apr_array_header_t
modifier|*
name|items
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_parse_externals_description3
argument_list|(
operator|&
name|items
argument_list|,
name|local_abspath
argument_list|,
name|desc_text
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|items
operator|->
name|nelts
condition|)
continue|continue;
name|local_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|to_abspath
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|dir_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|from_url
argument_list|,
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|item_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_url
decl_stmt|;
name|svn_boolean_t
name|under_root
decl_stmt|;
name|svn_wc_external_item2_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|items
argument_list|,
name|i
argument_list|,
name|svn_wc_external_item2_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|sub_iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_is_under_root
argument_list|(
operator|&
name|under_root
argument_list|,
operator|&
name|item_abspath
argument_list|,
name|local_abspath
argument_list|,
name|item
operator|->
name|target_dir
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|under_root
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not in the working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|item
operator|->
name|target_dir
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__resolve_relative_external_url
argument_list|(
operator|&
name|new_url
argument_list|,
name|item
argument_list|,
name|repos_root_url
argument_list|,
name|dir_url
argument_list|,
name|sub_iterpool
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The target dir might have multiple components.  Guarantee              the path leading down to the last component. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|item_abspath
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|wrap_external_error
argument_list|(
name|ctx
argument_list|,
name|item_abspath
argument_list|,
name|svn_client_export5
argument_list|(
name|NULL
argument_list|,
name|new_url
argument_list|,
name|item_abspath
argument_list|,
operator|&
name|item
operator|->
name|peg_revision
argument_list|,
operator|&
name|item
operator|->
name|revision
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|ignore_keywords
argument_list|,
name|svn_depth_infinity
argument_list|,
name|native_eol
argument_list|,
name|ctx
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|,
name|sub_iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|sub_iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

