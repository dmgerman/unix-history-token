begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * patch.c: patch application support  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_fnmatch.h>
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_eol_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|hunk_info_t
block|{
comment|/* The hunk. */
name|svn_diff_hunk_t
modifier|*
name|hunk
decl_stmt|;
comment|/* The line where the hunk matched in the target file. */
name|svn_linenum_t
name|matched_line
decl_stmt|;
comment|/* Whether this hunk has been rejected. */
name|svn_boolean_t
name|rejected
decl_stmt|;
comment|/* Whether this hunk has already been applied (either manually    * or by an earlier run of patch). */
name|svn_boolean_t
name|already_applied
decl_stmt|;
comment|/* The fuzz factor used when matching this hunk, i.e. how many    * lines of leading and trailing context to ignore during matching. */
name|svn_linenum_t
name|fuzz
decl_stmt|;
block|}
name|hunk_info_t
typedef|;
end_typedef

begin_comment
comment|/* A struct carrying information related to the patched and unpatched  * content of a target, be it a property or the text of a file. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|target_content_t
block|{
comment|/* Indicates whether unpatched content existed prior to patching. */
name|svn_boolean_t
name|existed
decl_stmt|;
comment|/* The line last read from the unpatched content. */
name|svn_linenum_t
name|current_line
decl_stmt|;
comment|/* The EOL-style of the unpatched content. Either 'none', 'fixed',    * or 'native'. See the documentation of svn_subst_eol_style_t. */
name|svn_subst_eol_style_t
name|eol_style
decl_stmt|;
comment|/* If the EOL_STYLE above is not 'none', this is the EOL string    * corresponding to the EOL-style. Else, it is the EOL string the    * last line read from the target file was using. */
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
comment|/* An array containing apr_off_t offsets marking the beginning of    * each line in the unpatched content. */
name|apr_array_header_t
modifier|*
name|lines
decl_stmt|;
comment|/* An array containing hunk_info_t structures for hunks already matched. */
name|apr_array_header_t
modifier|*
name|hunks
decl_stmt|;
comment|/* True if end-of-file was reached while reading from the unpatched    * content. */
name|svn_boolean_t
name|eof
decl_stmt|;
comment|/* The keywords of the target. They will be contracted when reading    * unpatched content and expanded when writing patched content.    * When patching properties this hash is always empty. */
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
comment|/* A callback, with an associated baton, to read a line of unpatched    * content. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|readline
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
name|void
modifier|*
name|read_baton
decl_stmt|;
comment|/* A callback to get the current byte offset within the unpatched    * content. Uses the read baton. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|tell
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* A callback to seek to an offset within the unpatched content.    * Uses the read baton. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|seek
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
comment|/* A callback to write data to the patched content, with an    * associated baton. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|write
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
name|void
modifier|*
name|write_baton
decl_stmt|;
block|}
name|target_content_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|prop_patch_target_t
block|{
comment|/* The name of the property */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
comment|/* The property value. This is NULL in case the property did not exist    * prior to patch application (see also CONTENT->existed).    * Note that the patch implementation does not support binary properties,    * so this string is not expected to contain embedded NUL characters. */
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
comment|/* The patched property value.    * This is equivalent to the target, except that in appropriate    * places it contains the modified text as it appears in the patch file. */
name|svn_stringbuf_t
modifier|*
name|patched_value
decl_stmt|;
comment|/* All information that is specific to the content of the property. */
name|target_content_t
modifier|*
name|content
decl_stmt|;
comment|/* Represents the operation performed on the property. It can be added,    * deleted or modified.    * ### Should we use flags instead since we're not using all enum values? */
name|svn_diff_operation_kind_t
name|operation
decl_stmt|;
comment|/* ### Here we'll add flags telling if the prop was added, deleted,    * ### had_rejects, had_local_mods prior to patching and so on. */
block|}
name|prop_patch_target_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|patch_target_t
block|{
comment|/* The target path as it appeared in the patch file,    * but in canonicalised form. */
specifier|const
name|char
modifier|*
name|canon_path_from_patchfile
decl_stmt|;
comment|/* The target path, relative to the working copy directory the    * patch is being applied to. A patch strip count applies to this    * and only this path. This is never NULL. */
specifier|const
name|char
modifier|*
name|local_relpath
decl_stmt|;
comment|/* The absolute path of the target on the filesystem.    * Any symlinks the path from the patch file may contain are resolved.    * Is not always known, so it may be NULL. */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* The target file, read-only. This is NULL in case the target    * file did not exist prior to patch application (see also    * CONTENT->existed). */
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* The target file is a symlink */
name|svn_boolean_t
name|is_symlink
decl_stmt|;
comment|/* The patched file.    * This is equivalent to the target, except that in appropriate    * places it contains the modified text as it appears in the patch file.    * The data in this file is written in repository-normal form.    * EOL transformation and keyword contraction is performed when the    * patched result is installed in the working copy. */
name|apr_file_t
modifier|*
name|patched_file
decl_stmt|;
comment|/* Path to the patched file. */
specifier|const
name|char
modifier|*
name|patched_path
decl_stmt|;
comment|/* Hunks that are rejected will be written to this file. */
name|apr_file_t
modifier|*
name|reject_file
decl_stmt|;
comment|/* Path to the reject file. */
specifier|const
name|char
modifier|*
name|reject_path
decl_stmt|;
comment|/* The node kind of the target as found in WC-DB prior    * to patch application. */
name|svn_node_kind_t
name|db_kind
decl_stmt|;
comment|/* The target's kind on disk prior to patch application. */
name|svn_node_kind_t
name|kind_on_disk
decl_stmt|;
comment|/* True if the target was locally deleted prior to patching. */
name|svn_boolean_t
name|locally_deleted
decl_stmt|;
comment|/* True if the target had to be skipped for some reason. */
name|svn_boolean_t
name|skipped
decl_stmt|;
comment|/* True if at least one hunk was rejected. */
name|svn_boolean_t
name|had_rejects
decl_stmt|;
comment|/* True if at least one property hunk was rejected. */
name|svn_boolean_t
name|had_prop_rejects
decl_stmt|;
comment|/* True if the target file had local modifications before the    * patch was applied to it. */
name|svn_boolean_t
name|local_mods
decl_stmt|;
comment|/* True if the target was added by the patch, which means that it did    * not exist on disk before patching and has content after patching. */
name|svn_boolean_t
name|added
decl_stmt|;
comment|/* True if the target ended up being deleted by the patch. */
name|svn_boolean_t
name|deleted
decl_stmt|;
comment|/* True if the target ended up being replaced by the patch    * (i.e. a new file was added on top locally deleted node). */
name|svn_boolean_t
name|replaced
decl_stmt|;
comment|/* Set if the target is supposed to be moved by the patch.    * This applies to --git diffs which carry "rename from/to" headers. */
specifier|const
name|char
modifier|*
name|move_target_abspath
decl_stmt|;
comment|/* True if the target has the executable bit set. */
name|svn_boolean_t
name|executable
decl_stmt|;
comment|/* True if the patch changed the text of the target. */
name|svn_boolean_t
name|has_text_changes
decl_stmt|;
comment|/* True if the patch changed any of the properties of the target. */
name|svn_boolean_t
name|has_prop_changes
decl_stmt|;
comment|/* True if the patch contained a svn:special property. */
name|svn_boolean_t
name|is_special
decl_stmt|;
comment|/* All the information that is specific to the content of the target. */
name|target_content_t
modifier|*
name|content
decl_stmt|;
comment|/* A hash table of prop_patch_target_t objects keyed by property names. */
name|apr_hash_t
modifier|*
name|prop_targets
decl_stmt|;
block|}
name|patch_target_t
typedef|;
end_typedef

begin_comment
comment|/* A smaller struct containing a subset of patch_target_t.  * Carries the minimal amount of information we still need for a  * target after we're done patching it so we can free other resources. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|patch_target_info_t
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_boolean_t
name|deleted
decl_stmt|;
block|}
name|patch_target_info_t
typedef|;
end_typedef

begin_comment
comment|/* Strip STRIP_COUNT components from the front of PATH, returning  * the result in *RESULT, allocated in RESULT_POOL.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|strip_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|components
decl_stmt|;
name|apr_array_header_t
modifier|*
name|stripped
decl_stmt|;
name|components
operator|=
name|svn_path_decompose
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_count
operator|>
name|components
operator|->
name|nelts
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PATCH_BAD_STRIP_COUNT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot strip %u components from '%s'"
argument_list|)
argument_list|,
name|strip_count
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|stripped
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|components
operator|->
name|nelts
operator|-
name|strip_count
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strip_count
init|;
name|i
operator|<
name|components
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|stripped
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|component
expr_stmt|;
block|}
operator|*
name|result
operator|=
name|svn_path_compose
argument_list|(
name|stripped
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Obtain KEYWORDS, EOL_STYLE and EOL_STR for LOCAL_ABSPATH.  * WC_CTX is a context for the working copy the patch is applied to.  * Use RESULT_POOL for allocations of fields in TARGET.  * Use SCRATCH_POOL for all other allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|obtain_eol_and_keywords_for_file
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|keywords
parameter_list|,
name|svn_subst_eol_style_t
modifier|*
name|eol_style
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_string_t
modifier|*
name|keywords_val
decl_stmt|,
modifier|*
name|eol_style_val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_prop_list2
argument_list|(
operator|&
name|props
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|keywords_val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
expr_stmt|;
if|if
condition|(
name|keywords_val
condition|)
block|{
name|svn_revnum_t
name|changed_rev
decl_stmt|;
name|apr_time_t
name|changed_date
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_str
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_changed_info
argument_list|(
operator|&
name|changed_rev
argument_list|,
operator|&
name|changed_date
argument_list|,
operator|&
name|author
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rev_str
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld"
argument_list|,
name|changed_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_build_keywords3
argument_list|(
name|keywords
argument_list|,
name|keywords_val
operator|->
name|data
argument_list|,
name|rev_str
argument_list|,
name|url
argument_list|,
name|repos_root_url
argument_list|,
name|changed_date
argument_list|,
name|author
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|eol_style_val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_style_val
condition|)
block|{
name|svn_subst_eol_style_from_value
argument_list|(
name|eol_style
argument_list|,
name|eol_str
argument_list|,
name|eol_style_val
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Resolve the exact path for a patch TARGET at path PATH_FROM_PATCHFILE,  * which is the path of the target as it appeared in the patch file.  * Put a canonicalized version of PATH_FROM_PATCHFILE into  * TARGET->CANON_PATH_FROM_PATCHFILE.  * WC_CTX is a context for the working copy the patch is applied to.  * If possible, determine TARGET->WC_PATH, TARGET->ABS_PATH, TARGET->KIND,  * TARGET->ADDED, and TARGET->PARENT_DIR_EXISTS.  * Indicate in TARGET->SKIPPED whether the target should be skipped.  * STRIP_COUNT specifies the number of leading path components  * which should be stripped from target paths in the patch.  * PROP_CHANGES_ONLY specifies whether the target path is allowed to have  * only property changes, and no content changes (in which case the target  * must be a directory).  * Use RESULT_POOL for allocations of fields in TARGET.  * Use SCRATCH_POOL for all other allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|resolve_target_path
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|path_from_patchfile
parameter_list|,
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|prop_changes_only
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|stripped_path
decl_stmt|;
name|svn_wc_status3_t
modifier|*
name|status
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|under_root
decl_stmt|;
name|target
operator|->
name|canon_path_from_patchfile
operator|=
name|svn_dirent_internal_style
argument_list|(
name|path_from_patchfile
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* We allow properties to be set on the wc root dir. */
if|if
condition|(
operator|!
name|prop_changes_only
operator|&&
name|target
operator|->
name|canon_path_from_patchfile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* An empty patch target path? What gives? Skip this. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
name|target
operator|->
name|local_relpath
operator|=
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|strip_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|strip_path
argument_list|(
operator|&
name|stripped_path
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|strip_count
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|stripped_path
operator|=
name|target
operator|->
name|canon_path_from_patchfile
expr_stmt|;
if|if
condition|(
name|svn_dirent_is_absolute
argument_list|(
name|stripped_path
argument_list|)
condition|)
block|{
name|target
operator|->
name|local_relpath
operator|=
name|svn_dirent_is_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|stripped_path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|local_relpath
condition|)
block|{
comment|/* The target path is either outside of the working copy            * or it is the working copy itself. Skip it. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
name|target
operator|->
name|local_relpath
operator|=
name|stripped_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
name|target
operator|->
name|local_relpath
operator|=
name|stripped_path
expr_stmt|;
block|}
comment|/* Make sure the path is secure to use. We want the target to be inside    * of the working copy and not be fooled by symlinks it might contain. */
name|SVN_ERR
argument_list|(
name|svn_dirent_is_under_root
argument_list|(
operator|&
name|under_root
argument_list|,
operator|&
name|target
operator|->
name|local_abspath
argument_list|,
name|wcroot_abspath
argument_list|,
name|target
operator|->
name|local_relpath
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|under_root
condition|)
block|{
comment|/* The target path is outside of the working copy. Skip it. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Skip things we should not be messing with. */
name|err
operator|=
name|svn_wc_status3
argument_list|(
operator|&
name|status
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|target
operator|->
name|locally_deleted
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|db_kind
operator|=
name|svn_node_none
expr_stmt|;
name|status
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_ignored
operator|||
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_unversioned
operator|||
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_missing
operator|||
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_obstructed
operator|||
name|status
operator|->
name|conflicted
condition|)
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_deleted
condition|)
block|{
name|target
operator|->
name|locally_deleted
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|&&
operator|(
name|status
operator|->
name|kind
operator|!=
name|svn_node_unknown
operator|)
condition|)
name|target
operator|->
name|db_kind
operator|=
name|status
operator|->
name|kind
expr_stmt|;
else|else
name|target
operator|->
name|db_kind
operator|=
name|svn_node_none
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
operator|&
name|target
operator|->
name|kind_on_disk
argument_list|,
operator|&
name|target
operator|->
name|is_symlink
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|locally_deleted
condition|)
block|{
specifier|const
name|char
modifier|*
name|moved_to_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_was_moved_away
argument_list|(
operator|&
name|moved_to_abspath
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### BUG: moved_to_abspath contains the target where the op-root was          ### moved to... not the target itself! */
if|if
condition|(
name|moved_to_abspath
condition|)
block|{
name|target
operator|->
name|local_abspath
operator|=
name|moved_to_abspath
expr_stmt|;
name|target
operator|->
name|local_relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|wcroot_abspath
argument_list|,
name|moved_to_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|target
operator|->
name|local_relpath
operator|&&
name|target
operator|->
name|local_relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
comment|/* As far as we are concerned this target is not locally deleted. */
name|target
operator|->
name|locally_deleted
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_special_path
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
operator|&
name|target
operator|->
name|kind_on_disk
argument_list|,
operator|&
name|target
operator|->
name|is_symlink
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|!=
name|svn_node_none
condition|)
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for reading from properties. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|prop_read_baton_t
block|{
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
block|}
name|prop_read_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Allocate *STRINGBUF in RESULT_POOL, and read into it one line from  * the unpatched property value accessed via BATON.  * Reading stops either after a line-terminator was found, or if  * the property value runs out in which case *EOF is set to TRUE.  * The line-terminator is not stored in *STRINGBUF.  *  * If the line is empty or could not be read, *line is set to NULL.  *  * The line-terminator is detected automatically and stored in *EOL  * if EOL is not NULL. If the end of the property value is reached  * and does not end with a newline character, and EOL is not NULL,  * *EOL is set to NULL.  *  * SCRATCH_POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_read_baton_t
modifier|*
name|b
init|=
operator|(
name|prop_read_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|c
decl_stmt|;
name|svn_boolean_t
name|found_eof
decl_stmt|;
if|if
condition|(
operator|(
name|apr_uint64_t
operator|)
name|b
operator|->
name|offset
operator|>=
operator|(
name|apr_uint64_t
operator|)
name|b
operator|->
name|value
operator|->
name|len
condition|)
block|{
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Read bytes into STR up to and including, but not storing,    * the next EOL sequence. */
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
do|do
block|{
name|c
operator|=
name|b
operator|->
name|value
operator|->
name|data
operator|+
name|b
operator|->
name|offset
expr_stmt|;
name|b
operator|->
name|offset
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
block|{
name|found_eof
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|c
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r"
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|c
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r\n"
expr_stmt|;
name|b
operator|->
name|offset
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|80
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
operator|*
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|eol_str
condition|)
break|break;
block|}
do|while
condition|(
name|c
operator|<
name|b
operator|->
name|value
operator|->
name|data
operator|+
name|b
operator|->
name|value
operator|->
name|len
condition|)
do|;
if|if
condition|(
name|eof
condition|)
operator|*
name|eof
operator|=
name|found_eof
expr_stmt|;
operator|*
name|line
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return in *OFFSET the current byte offset for reading from the  * unpatched property value accessed via BATON.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tell_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_read_baton_t
modifier|*
name|b
init|=
operator|(
name|prop_read_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
operator|*
name|offset
operator|=
name|b
operator|->
name|offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Seek to the specified by OFFSET in the unpatched property value accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_read_baton_t
modifier|*
name|b
init|=
operator|(
name|prop_read_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|b
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes from BUF into the patched property value accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|patched_value
init|=
operator|(
name|svn_stringbuf_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|patched_value
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Initialize a PROP_TARGET structure for PROP_NAME on the patch target  * at LOCAL_ABSPATH. OPERATION indicates the operation performed on the  * property. Use working copy context WC_CTX.  * Allocate results in RESULT_POOL.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_prop_target
parameter_list|(
name|prop_patch_target_t
modifier|*
modifier|*
name|prop_target
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|svn_diff_operation_kind_t
name|operation
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|prop_patch_target_t
modifier|*
name|new_prop_target
decl_stmt|;
name|target_content_t
modifier|*
name|content
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|prop_read_baton_t
modifier|*
name|prop_read_baton
decl_stmt|;
name|content
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|content
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All other fields are FALSE or NULL due to apr_pcalloc(). */
name|content
operator|->
name|current_line
operator|=
literal|1
expr_stmt|;
name|content
operator|->
name|eol_style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
name|content
operator|->
name|lines
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|hunks
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hunk_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|keywords
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|new_prop_target
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_prop_target
argument_list|)
argument_list|)
expr_stmt|;
name|new_prop_target
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
name|new_prop_target
operator|->
name|operation
operator|=
name|operation
expr_stmt|;
name|new_prop_target
operator|->
name|content
operator|=
name|content
expr_stmt|;
name|err
operator|=
name|svn_wc_prop_get2
argument_list|(
operator|&
name|value
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|prop_name
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|content
operator|->
name|existed
operator|=
operator|(
name|value
operator|!=
name|NULL
operator|)
expr_stmt|;
name|new_prop_target
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|new_prop_target
operator|->
name|patched_value
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Wire up the read and write callbacks. */
name|prop_read_baton
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|prop_read_baton
argument_list|)
argument_list|)
expr_stmt|;
name|prop_read_baton
operator|->
name|value
operator|=
name|value
expr_stmt|;
name|prop_read_baton
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|content
operator|->
name|readline
operator|=
name|readline_prop
expr_stmt|;
name|content
operator|->
name|tell
operator|=
name|tell_prop
expr_stmt|;
name|content
operator|->
name|seek
operator|=
name|seek_prop
expr_stmt|;
name|content
operator|->
name|read_baton
operator|=
name|prop_read_baton
expr_stmt|;
name|content
operator|->
name|write
operator|=
name|write_prop
expr_stmt|;
name|content
operator|->
name|write_baton
operator|=
name|new_prop_target
operator|->
name|patched_value
expr_stmt|;
operator|*
name|prop_target
operator|=
name|new_prop_target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate *STRINGBUF in RESULT_POOL, and read into it one line from  * the unpatched file content accessed via BATON.  * Reading stops either after a line-terminator was found,  * or if EOF is reached in which case *EOF is set to TRUE.  * The line-terminator is not stored in *STRINGBUF.  *  * If the line is empty or could not be read, *line is set to NULL.  *  * The line-terminator is detected automatically and stored in *EOL  * if EOL is not NULL. If EOF is reached and FILE does not end  * with a newline character, and EOL is not NULL, *EOL is set to NULL.  *  * SCRATCH_POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
name|apr_size_t
name|numbytes
decl_stmt|;
name|char
name|c
decl_stmt|;
name|svn_boolean_t
name|found_eof
decl_stmt|;
comment|/* Read bytes into STR up to and including, but not storing,    * the next EOL sequence. */
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
name|numbytes
operator|=
literal|1
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|found_eof
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|numbytes
argument_list|,
operator|&
name|found_eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbytes
operator|!=
literal|1
condition|)
block|{
name|found_eof
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\n"
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r"
expr_stmt|;
if|if
condition|(
operator|!
name|found_eof
condition|)
block|{
name|apr_off_t
name|pos
decl_stmt|;
comment|/* Check for "\r\n" by peeking at the next byte. */
name|pos
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|file
argument_list|,
operator|&
name|c
argument_list|,
sizeof|sizeof
argument_list|(
name|c
argument_list|)
argument_list|,
operator|&
name|numbytes
argument_list|,
operator|&
name|found_eof
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|numbytes
operator|==
literal|1
operator|&&
name|c
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|eol_str
operator|=
literal|"\r\n"
expr_stmt|;
block|}
else|else
block|{
comment|/* Pretend we never peeked. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|found_eof
operator|=
name|FALSE
expr_stmt|;
name|numbytes
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
name|str
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
literal|80
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|str
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|eol_str
condition|)
break|break;
block|}
if|if
condition|(
name|eof
condition|)
operator|*
name|eof
operator|=
name|found_eof
expr_stmt|;
operator|*
name|line
operator|=
name|str
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return in *OFFSET the current byte offset for reading from the  * unpatched file content accessed via BATON.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tell_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
operator|*
name|offset
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Seek to the specified by OFFSET in the unpatched file content accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write LEN bytes from BUF into the patched file content accessed  * via BATON. Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
operator|(
name|apr_file_t
operator|*
operator|)
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Handling symbolic links:  *  * In Subversion, symlinks can be represented on disk in two distinct ways.  * On systems which support symlinks, a symlink is created on disk.  * On systems which do not support symlink, a file is created on disk  * which contains the "normal form" of the symlink, which looks like:  *   link TARGET  * where TARGET is the file the symlink points to.  *  * When reading symlinks (i.e. the link itself, not the file the symlink  * is pointing to) through the svn_subst_create_specialfile() function  * into a buffer, the buffer always contains the "normal form" of the symlink.  * Due to this representation symlinks always contain a single line of text.  *  * The functions below are needed to deal with the case where a patch  * wants to change the TARGET that a symlink points to.  */
end_comment

begin_comment
comment|/* Baton for the (readline|tell|seek|write)_symlink functions. */
end_comment

begin_struct
struct|struct
name|symlink_baton_t
block|{
comment|/* The path to the symlink on disk (not the path to the target of the link) */
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
comment|/* Indicates whether the "normal form" of the symlink has been read. */
name|svn_boolean_t
name|at_eof
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Allocate *STRINGBUF in RESULT_POOL, and store into it the "normal form"  * of the symlink accessed via BATON.  *  * Otherwise behaves like readline_file(), which see.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|line
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol_str
parameter_list|,
name|svn_boolean_t
modifier|*
name|eof
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|eof
condition|)
operator|*
name|eof
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|eol_str
condition|)
operator|*
name|eol_str
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|sb
operator|->
name|at_eof
condition|)
block|{
operator|*
name|line
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|svn_string_t
modifier|*
name|dest
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_link
argument_list|(
operator|&
name|dest
argument_list|,
name|sb
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|line
operator|=
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"link %s"
argument_list|,
name|dest
operator|->
name|data
argument_list|)
expr_stmt|;
name|sb
operator|->
name|at_eof
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *OFFSET to 1 or 0 depending on whether the "normal form" of  * the symlink has already been read. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tell_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
operator|*
name|offset
operator|=
name|sb
operator|->
name|at_eof
condition|?
literal|1
else|:
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If offset is non-zero, mark the symlink as having been read in its  * "normal form". Else, mark the symlink as not having been read yet. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|baton
decl_stmt|;
name|sb
operator|->
name|at_eof
operator|=
operator|(
name|offset
operator|!=
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the target of the symlink accessed via BATON.  * The contents of BUF must be a valid "normal form" of a symlink. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_symlink
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|link
init|=
name|apr_pstrndup
argument_list|(
name|scratch_pool
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|link
argument_list|,
literal|"link "
argument_list|,
literal|5
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid link representation"
argument_list|)
argument_list|)
return|;
name|link
operator|+=
literal|5
expr_stmt|;
comment|/* Skip "link " */
comment|/* We assume the entire symlink is written at once, as the patch      format is line based */
name|SVN_ERR
argument_list|(
name|svn_io_create_unique_link
argument_list|(
operator|&
name|new_name
argument_list|,
name|target_abspath
argument_list|,
name|link
argument_list|,
literal|".tmp"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|new_name
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a suitable filename for the target of PATCH.  * Examine the ``old'' and ``new'' file names, and choose the file name  * with the fewest path components, the shortest basename, and the shortest  * total file name length (in that order). In case of a tie, return the new  * filename. This heuristic is also used by Larry Wall's UNIX patch (except  * that it prompts for a filename in case of a tie).  * Additionally, for compatibility with git, if one of the filenames  * is "/dev/null", use the other filename. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|choose_target_filename
parameter_list|(
specifier|const
name|svn_patch_t
modifier|*
name|patch
parameter_list|)
block|{
name|apr_size_t
name|old
decl_stmt|;
name|apr_size_t
name|new
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|,
literal|"/dev/null"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|patch
operator|->
name|new_filename
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|,
literal|"/dev/null"
argument_list|)
operator|==
literal|0
condition|)
return|return
name|patch
operator|->
name|old_filename
return|;
comment|/* If the patch renames the target, use the old name while    * applying hunks. The target will be renamed to the new name    * after hunks have been applied. */
if|if
condition|(
name|patch
operator|->
name|operation
operator|==
name|svn_diff_op_moved
condition|)
return|return
name|patch
operator|->
name|old_filename
return|;
name|old
operator|=
name|svn_path_component_count
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|)
expr_stmt|;
name|new
operator|=
name|svn_path_component_count
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
block|{
name|old
operator|=
name|strlen
argument_list|(
name|svn_dirent_basename
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|=
name|strlen
argument_list|(
name|svn_dirent_basename
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
operator|==
name|new
condition|)
block|{
name|old
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|old_filename
argument_list|)
expr_stmt|;
name|new
operator|=
name|strlen
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|old
operator|<
name|new
operator|)
condition|?
name|patch
operator|->
name|old_filename
else|:
name|patch
operator|->
name|new_filename
return|;
block|}
end_function

begin_comment
comment|/* Attempt to initialize a *PATCH_TARGET structure for a target file  * described by PATCH. Use working copy context WC_CTX.  * STRIP_COUNT specifies the number of leading path components  * which should be stripped from target paths in the patch.  * The patch target structure is allocated in RESULT_POOL, but if the target  * should be skipped, PATCH_TARGET->SKIPPED is set and the target should be  * treated as not fully initialized, e.g. the caller should not not do any  * further operations on the target if it is marked to be skipped.  * If REMOVE_TEMPFILES is TRUE, set up temporary files to be removed as  * soon as they are no longer needed.  * Use SCRATCH_POOL for all other allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_patch_target
parameter_list|(
name|patch_target_t
modifier|*
modifier|*
name|patch_target
parameter_list|,
specifier|const
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|wcroot_abspath
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|patch_target_t
modifier|*
name|target
decl_stmt|;
name|target_content_t
modifier|*
name|content
decl_stmt|;
name|svn_boolean_t
name|has_prop_changes
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|prop_changes_only
init|=
name|FALSE
decl_stmt|;
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|patch
operator|->
name|prop_patches
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_prop_patch_t
modifier|*
name|prop_patch
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|has_prop_changes
condition|)
name|has_prop_changes
operator|=
name|prop_patch
operator|->
name|hunks
operator|->
name|nelts
operator|>
literal|0
expr_stmt|;
else|else
break|break;
block|}
block|}
name|prop_changes_only
operator|=
name|has_prop_changes
operator|&&
name|patch
operator|->
name|hunks
operator|->
name|nelts
operator|==
literal|0
expr_stmt|;
name|content
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|content
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All other fields in content are FALSE or NULL due to apr_pcalloc().*/
name|content
operator|->
name|current_line
operator|=
literal|1
expr_stmt|;
name|content
operator|->
name|eol_style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
name|content
operator|->
name|lines
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|hunks
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|hunk_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|keywords
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|target
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All other fields in target are FALSE or NULL due to apr_pcalloc(). */
name|target
operator|->
name|db_kind
operator|=
name|svn_node_none
expr_stmt|;
name|target
operator|->
name|kind_on_disk
operator|=
name|svn_node_none
expr_stmt|;
name|target
operator|->
name|content
operator|=
name|content
expr_stmt|;
name|target
operator|->
name|prop_targets
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|resolve_target_path
argument_list|(
name|target
argument_list|,
name|choose_target_filename
argument_list|(
name|patch
argument_list|)
argument_list|,
name|wcroot_abspath
argument_list|,
name|strip_count
argument_list|,
name|prop_changes_only
argument_list|,
name|wc_ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|patch_target
operator|=
name|target
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
specifier|const
name|char
modifier|*
name|diff_header
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* Create a temporary file to write the patched result to.        * Also grab various bits of information about the file. */
if|if
condition|(
name|target
operator|->
name|is_symlink
condition|)
block|{
name|struct
name|symlink_baton_t
modifier|*
name|sb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sb
argument_list|)
argument_list|)
decl_stmt|;
name|content
operator|->
name|existed
operator|=
name|TRUE
expr_stmt|;
name|sb
operator|->
name|local_abspath
operator|=
name|target
operator|->
name|local_abspath
expr_stmt|;
comment|/* Wire up the read callbacks. */
name|content
operator|->
name|read_baton
operator|=
name|sb
expr_stmt|;
name|content
operator|->
name|readline
operator|=
name|readline_symlink
expr_stmt|;
name|content
operator|->
name|seek
operator|=
name|seek_symlink
expr_stmt|;
name|content
operator|->
name|tell
operator|=
name|tell_symlink
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|target
operator|->
name|file
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_text_modified_p2
argument_list|(
operator|&
name|target
operator|->
name|local_mods
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_is_file_executable
argument_list|(
operator|&
name|target
operator|->
name|executable
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|obtain_eol_and_keywords_for_file
argument_list|(
operator|&
name|content
operator|->
name|keywords
argument_list|,
operator|&
name|content
operator|->
name|eol_style
argument_list|,
operator|&
name|content
operator|->
name|eol_str
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|existed
operator|=
name|TRUE
expr_stmt|;
comment|/* Wire up the read callbacks. */
name|content
operator|->
name|readline
operator|=
name|readline_file
expr_stmt|;
name|content
operator|->
name|seek
operator|=
name|seek_file
expr_stmt|;
name|content
operator|->
name|tell
operator|=
name|tell_file
expr_stmt|;
name|content
operator|->
name|read_baton
operator|=
name|target
operator|->
name|file
expr_stmt|;
block|}
comment|/* ### Is it ok to set the operation of the target already here? Isn't        * ### the target supposed to be marked with an operation after we have        * ### determined that the changes will apply cleanly to the WC? Maybe        * ### we should have kept the patch field in patch_target_t to be        * ### able to distinguish between 'what the patch says we should do'        * ### and 'what we can do with the given state of our WC'. */
if|if
condition|(
name|patch
operator|->
name|operation
operator|==
name|svn_diff_op_added
condition|)
name|target
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|patch
operator|->
name|operation
operator|==
name|svn_diff_op_deleted
condition|)
name|target
operator|->
name|deleted
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|patch
operator|->
name|operation
operator|==
name|svn_diff_op_moved
condition|)
block|{
specifier|const
name|char
modifier|*
name|move_target_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|move_target_relpath
decl_stmt|;
name|svn_boolean_t
name|under_root
decl_stmt|;
name|svn_node_kind_t
name|kind_on_disk
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|move_target_path
operator|=
name|svn_dirent_internal_style
argument_list|(
name|patch
operator|->
name|new_filename
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strip_count
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|strip_path
argument_list|(
operator|&
name|move_target_path
argument_list|,
name|move_target_path
argument_list|,
name|strip_count
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_dirent_is_absolute
argument_list|(
name|move_target_path
argument_list|)
condition|)
block|{
name|move_target_relpath
operator|=
name|svn_dirent_is_child
argument_list|(
name|wcroot_abspath
argument_list|,
name|move_target_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|move_target_relpath
condition|)
block|{
comment|/* The move target path is either outside of the working                    * copy or it is the working copy itself. Skip it. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
name|move_target_relpath
operator|=
name|move_target_path
expr_stmt|;
comment|/* Make sure the move target path is secure to use. */
name|SVN_ERR
argument_list|(
name|svn_dirent_is_under_root
argument_list|(
operator|&
name|under_root
argument_list|,
operator|&
name|target
operator|->
name|move_target_abspath
argument_list|,
name|wcroot_abspath
argument_list|,
name|move_target_relpath
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|under_root
condition|)
block|{
comment|/* The target path is outside of the working copy. Skip it. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|local_abspath
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|target
operator|->
name|move_target_abspath
argument_list|,
operator|&
name|kind_on_disk
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|wc_kind
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|move_target_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind_on_disk
operator|!=
name|svn_node_none
operator|||
name|wc_kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* The move target path already exists on disk. Skip target. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
name|target
operator|->
name|move_target_abspath
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
operator|!
name|target
operator|->
name|is_symlink
condition|)
block|{
comment|/* Open a temporary file to write the patched result to. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|target
operator|->
name|patched_file
argument_list|,
operator|&
name|target
operator|->
name|patched_path
argument_list|,
name|NULL
argument_list|,
name|remove_tempfiles
condition|?
name|svn_io_file_del_on_pool_cleanup
else|:
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Put the write callback in place. */
name|content
operator|->
name|write
operator|=
name|write_file
expr_stmt|;
name|content
operator|->
name|write_baton
operator|=
name|target
operator|->
name|patched_file
expr_stmt|;
block|}
else|else
block|{
comment|/* Put the write callback in place. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
name|NULL
argument_list|,
operator|&
name|target
operator|->
name|patched_path
argument_list|,
name|NULL
argument_list|,
name|remove_tempfiles
condition|?
name|svn_io_file_del_on_pool_cleanup
else|:
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|write_baton
operator|=
operator|(
name|void
operator|*
operator|)
name|target
operator|->
name|patched_path
expr_stmt|;
name|content
operator|->
name|write
operator|=
name|write_symlink
expr_stmt|;
block|}
comment|/* Open a temporary file to write rejected hunks to. */
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|target
operator|->
name|reject_file
argument_list|,
operator|&
name|target
operator|->
name|reject_path
argument_list|,
name|NULL
argument_list|,
name|remove_tempfiles
condition|?
name|svn_io_file_del_on_pool_cleanup
else|:
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The reject file needs a diff header. */
name|diff_header
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"--- %s%s+++ %s%s"
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|APR_EOL_STR
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|diff_header
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|diff_header
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle properties. */
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|result_pool
argument_list|,
name|patch
operator|->
name|prop_patches
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|prop_name
init|=
name|apr_hash_this_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_prop_patch_t
modifier|*
name|prop_patch
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|SVN_ERR
argument_list|(
name|init_prop_target
argument_list|(
operator|&
name|prop_target
argument_list|,
name|prop_name
argument_list|,
name|prop_patch
operator|->
name|operation
argument_list|,
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|target
operator|->
name|prop_targets
argument_list|,
name|prop_name
argument_list|,
name|prop_target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a *LINE from CONTENT. If the line has not been read before  * mark the line in CONTENT->LINES.  * If a line could be read successfully, increase CONTENT->CURRENT_LINE,  * and allocate *LINE in RESULT_POOL.  * Do temporary allocations in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|readline
parameter_list|(
name|target_content_t
modifier|*
name|content
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|line_raw
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_linenum_t
name|max_line
init|=
operator|(
name|svn_linenum_t
operator|)
name|content
operator|->
name|lines
operator|->
name|nelts
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|content
operator|->
name|eof
operator|||
name|content
operator|->
name|readline
operator|==
name|NULL
condition|)
block|{
operator|*
name|line
operator|=
literal|""
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|content
operator|->
name|current_line
operator|<=
name|max_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|current_line
operator|==
name|max_line
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|tell
argument_list|(
name|content
operator|->
name|read_baton
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|content
operator|->
name|lines
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|offset
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|content
operator|->
name|readline
argument_list|(
name|content
operator|->
name|read_baton
argument_list|,
operator|&
name|line_raw
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|content
operator|->
name|eof
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|eol_style
operator|==
name|svn_subst_eol_style_none
condition|)
name|content
operator|->
name|eol_str
operator|=
name|eol_str
expr_stmt|;
if|if
condition|(
name|line_raw
condition|)
block|{
comment|/* Contract keywords. */
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|line_raw
operator|->
name|data
argument_list|,
name|line
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
operator|*
name|line
operator|=
literal|""
expr_stmt|;
if|if
condition|(
operator|(
name|line_raw
operator|&&
name|line_raw
operator|->
name|len
operator|>
literal|0
operator|)
operator|||
name|eol_str
condition|)
name|content
operator|->
name|current_line
operator|++
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|content
operator|->
name|current_line
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Seek to the specified LINE in CONTENT.  * Mark any lines not read before in CONTENT->LINES.  * Do temporary allocations in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|seek_to_line
parameter_list|(
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_linenum_t
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_linenum_t
name|saved_line
decl_stmt|;
name|svn_boolean_t
name|saved_eof
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|line
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|==
name|content
operator|->
name|current_line
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|saved_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
name|saved_eof
operator|=
name|content
operator|->
name|eof
expr_stmt|;
if|if
condition|(
name|line
operator|<=
operator|(
name|svn_linenum_t
operator|)
name|content
operator|->
name|lines
operator|->
name|nelts
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|offset
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|content
operator|->
name|lines
argument_list|,
name|line
operator|-
literal|1
argument_list|,
name|apr_off_t
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|seek
argument_list|(
name|content
operator|->
name|read_baton
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|content
operator|->
name|current_line
operator|=
name|line
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|dummy
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|content
operator|->
name|eof
operator|&&
name|content
operator|->
name|current_line
operator|<
name|line
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|dummy
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* After seeking backwards from EOF position clear EOF indicator. */
if|if
condition|(
name|saved_eof
operator|&&
name|saved_line
operator|>
name|content
operator|->
name|current_line
condition|)
name|content
operator|->
name|eof
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Indicate in *MATCHED whether the original text of HUNK matches the patch  * CONTENT at its current line. Lines within FUZZ lines of the start or  * end of HUNK will always match. If IGNORE_WHITESPACE is set, we ignore  * whitespace when doing the matching. When this function returns, neither  * CONTENT->CURRENT_LINE nor the file offset in the target file will  * have changed. If MATCH_MODIFIED is TRUE, match the modified hunk text,  * rather than the original hunk text.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|match_hunk
parameter_list|(
name|svn_boolean_t
modifier|*
name|matched
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_linenum_t
name|fuzz
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|match_modified
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_line
decl_stmt|;
name|svn_linenum_t
name|lines_read
decl_stmt|;
name|svn_linenum_t
name|saved_line
decl_stmt|;
name|svn_boolean_t
name|hunk_eof
decl_stmt|;
name|svn_boolean_t
name|lines_matched
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_linenum_t
name|hunk_length
decl_stmt|;
name|svn_linenum_t
name|leading_context
decl_stmt|;
name|svn_linenum_t
name|trailing_context
decl_stmt|;
operator|*
name|matched
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|eof
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|saved_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
name|lines_read
operator|=
literal|0
expr_stmt|;
name|lines_matched
operator|=
name|FALSE
expr_stmt|;
name|leading_context
operator|=
name|svn_diff_hunk_get_leading_context
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|trailing_context
operator|=
name|svn_diff_hunk_get_trailing_context
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_modified
condition|)
block|{
name|svn_diff_hunk_reset_modified_text
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|hunk_length
operator|=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_diff_hunk_reset_original_text
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|hunk_length
operator|=
name|svn_diff_hunk_get_original_length
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
do|do
block|{
specifier|const
name|char
modifier|*
name|hunk_line_translated
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_modified
condition|)
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_modified_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
name|NULL
argument_list|,
operator|&
name|hunk_eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_original_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
name|NULL
argument_list|,
operator|&
name|hunk_eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Contract keywords, if any, before matching. */
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|hunk_line
operator|->
name|data
argument_list|,
operator|&
name|hunk_line_translated
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|target_line
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|lines_read
operator|++
expr_stmt|;
comment|/* If the last line doesn't have a newline, we get EOF but still        * have a non-empty line to compare. */
if|if
condition|(
operator|(
name|hunk_eof
operator|&&
name|hunk_line
operator|->
name|len
operator|==
literal|0
operator|)
operator|||
operator|(
name|content
operator|->
name|eof
operator|&&
operator|*
name|target_line
operator|==
literal|0
operator|)
condition|)
break|break;
comment|/* Leading/trailing fuzzy lines always match. */
if|if
condition|(
operator|(
name|lines_read
operator|<=
name|fuzz
operator|&&
name|leading_context
operator|>
name|fuzz
operator|)
operator|||
operator|(
name|lines_read
operator|>
name|hunk_length
operator|-
name|fuzz
operator|&&
name|trailing_context
operator|>
name|fuzz
operator|)
condition|)
name|lines_matched
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
if|if
condition|(
name|ignore_whitespace
condition|)
block|{
name|char
modifier|*
name|hunk_line_trimmed
decl_stmt|;
name|char
modifier|*
name|target_line_trimmed
decl_stmt|;
name|hunk_line_trimmed
operator|=
name|apr_pstrdup
argument_list|(
name|iterpool
argument_list|,
name|hunk_line_translated
argument_list|)
expr_stmt|;
name|target_line_trimmed
operator|=
name|apr_pstrdup
argument_list|(
name|iterpool
argument_list|,
name|target_line
argument_list|)
expr_stmt|;
name|apr_collapse_spaces
argument_list|(
name|hunk_line_trimmed
argument_list|,
name|hunk_line_trimmed
argument_list|)
expr_stmt|;
name|apr_collapse_spaces
argument_list|(
name|target_line_trimmed
argument_list|,
name|target_line_trimmed
argument_list|)
expr_stmt|;
name|lines_matched
operator|=
operator|!
name|strcmp
argument_list|(
name|hunk_line_trimmed
argument_list|,
name|target_line_trimmed
argument_list|)
expr_stmt|;
block|}
else|else
name|lines_matched
operator|=
operator|!
name|strcmp
argument_list|(
name|hunk_line_translated
argument_list|,
name|target_line
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|lines_matched
condition|)
do|;
operator|*
name|matched
operator|=
name|lines_matched
operator|&&
name|hunk_eof
operator|&&
name|hunk_line
operator|->
name|len
operator|==
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|saved_line
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Scan lines of CONTENT for a match of the original text of HUNK,  * up to but not including the specified UPPER_LINE. Use fuzz factor FUZZ.  * If UPPER_LINE is zero scan until EOF occurs when reading from TARGET.  * Return the line at which HUNK was matched in *MATCHED_LINE.  * If the hunk did not match at all, set *MATCHED_LINE to zero.  * If the hunk matched multiple times, and MATCH_FIRST is TRUE,  * return the line number at which the first match occurred in *MATCHED_LINE.  * If the hunk matched multiple times, and MATCH_FIRST is FALSE,  * return the line number at which the last match occurred in *MATCHED_LINE.  * If IGNORE_WHITESPACE is set, ignore whitespace during the matching.  * If MATCH_MODIFIED is TRUE, match the modified hunk text,  * rather than the original hunk text.  * Call cancel CANCEL_FUNC with baton CANCEL_BATON to trigger cancellation.  * Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|scan_for_match
parameter_list|(
name|svn_linenum_t
modifier|*
name|matched_line
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_boolean_t
name|match_first
parameter_list|,
name|svn_linenum_t
name|upper_line
parameter_list|,
name|svn_linenum_t
name|fuzz
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|match_modified
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
operator|*
name|matched_line
operator|=
literal|0
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|content
operator|->
name|current_line
operator|<
name|upper_line
operator|||
name|upper_line
operator|==
literal|0
operator|)
operator|&&
operator|!
name|content
operator|->
name|eof
condition|)
block|{
name|svn_boolean_t
name|matched
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|match_hunk
argument_list|(
operator|&
name|matched
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|match_modified
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched
condition|)
block|{
name|svn_boolean_t
name|taken
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Don't allow hunks to match at overlapping locations. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_linenum_t
name|length
decl_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
specifier|const
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|match_modified
condition|)
name|length
operator|=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
else|else
name|length
operator|=
name|svn_diff_hunk_get_original_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|taken
operator|=
operator|(
operator|!
name|hi
operator|->
name|rejected
operator|&&
name|content
operator|->
name|current_line
operator|>=
name|hi
operator|->
name|matched_line
operator|&&
name|content
operator|->
name|current_line
operator|<
operator|(
name|hi
operator|->
name|matched_line
operator|+
name|length
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|taken
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|taken
condition|)
block|{
operator|*
name|matched_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
if|if
condition|(
name|match_first
condition|)
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|content
operator|->
name|eof
condition|)
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|content
operator|->
name|current_line
operator|+
literal|1
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Indicate in *MATCH whether the content described by CONTENT  * matches the modified text of HUNK.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|match_existing_target
parameter_list|(
name|svn_boolean_t
modifier|*
name|match
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|lines_matched
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|hunk_eof
decl_stmt|;
name|svn_linenum_t
name|saved_line
decl_stmt|;
name|svn_diff_hunk_reset_modified_text
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|saved_line
operator|=
name|content
operator|->
name|current_line
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
specifier|const
name|char
modifier|*
name|line
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|line_translated
decl_stmt|;
specifier|const
name|char
modifier|*
name|hunk_line_translated
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|line
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_modified_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
name|NULL
argument_list|,
operator|&
name|hunk_eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Contract keywords. */
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|line
argument_list|,
operator|&
name|line_translated
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|hunk_line
operator|->
name|data
argument_list|,
operator|&
name|hunk_line_translated
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|content
operator|->
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|lines_matched
operator|=
operator|!
name|strcmp
argument_list|(
name|line_translated
argument_list|,
name|hunk_line_translated
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|eof
operator|!=
name|hunk_eof
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|match
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
do|while
condition|(
name|lines_matched
operator|&&
operator|!
name|content
operator|->
name|eof
operator|&&
operator|!
name|hunk_eof
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|match
operator|=
operator|(
name|lines_matched
operator|&&
name|content
operator|->
name|eof
operator|==
name|hunk_eof
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|saved_line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine the line at which a HUNK applies to CONTENT of the TARGET  * file, and return an appropriate hunk_info object in *HI, allocated from  * RESULT_POOL. Use fuzz factor FUZZ. Set HI->FUZZ to FUZZ. If no correct  * line can be determined, set HI->REJECTED to TRUE.  PREVIOUS_OFFSET  * is the offset at which the previous matching hunk was applied, or zero.  * IGNORE_WHITESPACE tells whether whitespace should be considered when  * matching. IS_PROP_HUNK indicates whether the hunk patches file content  * or a property.  * When this function returns, neither CONTENT->CURRENT_LINE nor  * the file offset in the target file will have changed.  * Call cancel CANCEL_FUNC with baton CANCEL_BATON to trigger cancellation.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_hunk_info
parameter_list|(
name|hunk_info_t
modifier|*
modifier|*
name|hi
parameter_list|,
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
name|svn_linenum_t
name|fuzz
parameter_list|,
name|svn_linenum_t
name|previous_offset
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|is_prop_hunk
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_linenum_t
name|matched_line
decl_stmt|;
name|svn_linenum_t
name|original_start
decl_stmt|;
name|svn_boolean_t
name|already_applied
decl_stmt|;
name|original_start
operator|=
name|svn_diff_hunk_get_original_start
argument_list|(
name|hunk
argument_list|)
operator|+
name|previous_offset
expr_stmt|;
name|already_applied
operator|=
name|FALSE
expr_stmt|;
comment|/* An original offset of zero means that this hunk wants to create    * a new file. Don't bother matching hunks in that case, since    * the hunk applies at line 1. If the file already exists, the hunk    * is rejected, unless the file is versioned and its content matches    * the file the patch wants to create.  */
if|if
condition|(
name|original_start
operator|==
literal|0
operator|&&
name|fuzz
operator|>
literal|0
condition|)
block|{
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject any fuzz for new files */
block|}
elseif|else
if|if
condition|(
name|original_start
operator|==
literal|0
operator|&&
operator|!
name|is_prop_hunk
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
block|{
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dirent
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
operator|!
name|dirent
operator|->
name|special
operator|&&
name|dirent
operator|->
name|filesize
operator|==
literal|0
condition|)
block|{
name|matched_line
operator|=
literal|1
expr_stmt|;
comment|/* Matched an on-disk empty file */
block|}
else|else
block|{
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_boolean_t
name|file_matches
decl_stmt|;
comment|/* ### I can't reproduce anything but a no-match here.                          The content is already at eof, so any hunk fails */
name|SVN_ERR
argument_list|(
name|match_existing_target
argument_list|(
operator|&
name|file_matches
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|file_matches
condition|)
block|{
name|matched_line
operator|=
literal|1
expr_stmt|;
name|already_applied
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject */
block|}
else|else
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject */
block|}
block|}
else|else
name|matched_line
operator|=
literal|1
expr_stmt|;
block|}
comment|/* Same conditions apply as for the file case above.    *    * ### Since the hunk says the prop should be added we just assume so for    * ### now and don't bother with storing the previous lines and such. When    * ### we have the diff operation available we can just check for adds. */
elseif|else
if|if
condition|(
name|original_start
operator|==
literal|0
operator|&&
name|is_prop_hunk
condition|)
block|{
if|if
condition|(
name|content
operator|->
name|existed
condition|)
block|{
name|svn_boolean_t
name|prop_matches
decl_stmt|;
name|SVN_ERR
argument_list|(
name|match_existing_target
argument_list|(
operator|&
name|prop_matches
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_matches
condition|)
block|{
name|matched_line
operator|=
literal|1
expr_stmt|;
name|already_applied
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|matched_line
operator|=
literal|0
expr_stmt|;
comment|/* reject */
block|}
else|else
name|matched_line
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|original_start
operator|>
literal|0
operator|&&
name|content
operator|->
name|existed
condition|)
block|{
name|svn_linenum_t
name|saved_line
init|=
name|content
operator|->
name|current_line
decl_stmt|;
comment|/* Scan for a match at the line where the hunk thinks it        * should be going. */
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|original_start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|current_line
operator|!=
name|original_start
condition|)
block|{
comment|/* Seek failed. */
name|matched_line
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|TRUE
argument_list|,
name|original_start
operator|+
literal|1
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched_line
operator|!=
name|original_start
condition|)
block|{
comment|/* Check if the hunk is already applied.            * We only check for an exact match here, and don't bother checking            * for already applied patches with offset/fuzz, because such a            * check would be ambiguous. */
if|if
condition|(
name|fuzz
operator|==
literal|0
condition|)
block|{
name|svn_linenum_t
name|modified_start
decl_stmt|;
name|modified_start
operator|=
name|svn_diff_hunk_get_modified_start
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified_start
operator|==
literal|0
condition|)
block|{
comment|/* Patch wants to delete the file.                       ### locally_deleted is always false here? */
name|already_applied
operator|=
name|target
operator|->
name|locally_deleted
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|modified_start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|TRUE
argument_list|,
name|modified_start
operator|+
literal|1
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|already_applied
operator|=
operator|(
name|matched_line
operator|==
name|modified_start
operator|)
expr_stmt|;
block|}
block|}
else|else
name|already_applied
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|already_applied
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_linenum_t
name|search_start
init|=
literal|1
decl_stmt|,
name|search_end
init|=
literal|0
decl_stmt|;
name|svn_linenum_t
name|matched_line2
decl_stmt|;
comment|/* Search for closest match before or after original                  start.  We have no backward search so search forwards                  from the previous match (or start of file) to the                  original start looking for the last match.  Then                  search forwards from the original start looking for a                  better match.  Finally search forwards from the start                  of file to the previous hunk if that could result in                  a better match. */
for|for
control|(
name|i
operator|=
name|content
operator|->
name|hunks
operator|->
name|nelts
init|;
name|i
operator|>
literal|0
condition|;
operator|--
name|i
control|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|prev
init|=
name|APR_ARRAY_IDX
argument_list|(
name|content
operator|->
name|hunks
argument_list|,
name|i
operator|-
literal|1
argument_list|,
specifier|const
name|hunk_info_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|prev
operator|->
name|rejected
condition|)
block|{
name|svn_linenum_t
name|length
decl_stmt|;
name|length
operator|=
name|svn_diff_hunk_get_original_length
argument_list|(
name|prev
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|search_start
operator|=
name|prev
operator|->
name|matched_line
operator|+
name|length
expr_stmt|;
break|break;
block|}
block|}
comment|/* Search from the previous match, or start of file,                  towards the original location. */
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|search_start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|FALSE
argument_list|,
name|original_start
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a match we only need to search forwards for a                  better match, otherwise to the end of the file. */
if|if
condition|(
name|matched_line
condition|)
name|search_end
operator|=
name|original_start
operator|+
operator|(
name|original_start
operator|-
name|matched_line
operator|)
expr_stmt|;
comment|/* Search from original location, towards the end. */
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|original_start
operator|+
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line2
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|TRUE
argument_list|,
name|search_end
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Chose the forward match if it is closer than the                  backward match or if there is no backward match. */
if|if
condition|(
name|matched_line2
operator|&&
operator|(
operator|!
name|matched_line
operator|||
operator|(
name|matched_line2
operator|-
name|original_start
operator|<
name|original_start
operator|-
name|matched_line
operator|)
operator|)
condition|)
name|matched_line
operator|=
name|matched_line2
expr_stmt|;
comment|/* Search from before previous hunk if there could be a                  better match. */
if|if
condition|(
name|search_start
operator|>
literal|1
operator|&&
operator|(
operator|!
name|matched_line
operator|||
operator|(
name|matched_line
operator|>
name|original_start
operator|&&
operator|(
name|matched_line
operator|-
name|original_start
operator|>
name|original_start
operator|-
name|search_start
operator|)
operator|)
operator|)
condition|)
block|{
name|svn_linenum_t
name|search_start2
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|matched_line
operator|&&
name|matched_line
operator|-
name|original_start
operator|<
name|original_start
condition|)
name|search_start2
operator|=
name|original_start
operator|-
operator|(
name|matched_line
operator|-
name|original_start
operator|)
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|search_start2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|scan_for_match
argument_list|(
operator|&
name|matched_line2
argument_list|,
name|content
argument_list|,
name|hunk
argument_list|,
name|FALSE
argument_list|,
name|search_start
operator|-
literal|1
argument_list|,
name|fuzz
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched_line2
condition|)
name|matched_line
operator|=
name|matched_line2
expr_stmt|;
block|}
block|}
block|}
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|saved_line
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The hunk wants to modify a file which doesn't exist. */
name|matched_line
operator|=
literal|0
expr_stmt|;
block|}
operator|(
operator|*
name|hi
operator|)
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|hunk_info_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|hunk
operator|=
name|hunk
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|matched_line
operator|=
name|matched_line
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|rejected
operator|=
operator|(
name|matched_line
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|already_applied
operator|=
name|already_applied
expr_stmt|;
operator|(
operator|*
name|hi
operator|)
operator|->
name|fuzz
operator|=
name|fuzz
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy lines to the patched content until the specified LINE has been  * reached. Indicate in *EOF whether end-of-file was encountered while  * reading from the target.  * If LINE is zero, copy lines until end-of-file has been reached.  * Do all allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_lines_to_target
parameter_list|(
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_linenum_t
name|line
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|content
operator|->
name|current_line
operator|<
name|line
operator|||
name|line
operator|==
literal|0
operator|)
operator|&&
operator|!
name|content
operator|->
name|eof
condition|)
block|{
specifier|const
name|char
modifier|*
name|target_line
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|readline
argument_list|(
name|content
argument_list|,
operator|&
name|target_line
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|content
operator|->
name|eof
condition|)
name|target_line
operator|=
name|apr_pstrcat
argument_list|(
name|iterpool
argument_list|,
name|target_line
argument_list|,
name|content
operator|->
name|eol_str
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|target_line
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|write
argument_list|(
name|content
operator|->
name|write_baton
argument_list|,
name|target_line
argument_list|,
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the diff text of HUNK to TARGET's reject file,  * and mark TARGET as having had rejects.  * We don't expand keywords, nor normalise line-endings, in reject files.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reject_hunk
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|svn_diff_hunk_t
modifier|*
name|hunk
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|hunk_header
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|text_atat
init|=
literal|"@@"
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|prop_atat
init|=
literal|"##"
decl_stmt|;
specifier|const
name|char
modifier|*
name|atat
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
if|if
condition|(
name|prop_name
condition|)
block|{
specifier|const
name|char
modifier|*
name|prop_header
decl_stmt|;
comment|/* ### Print 'Added', 'Deleted' or 'Modified' instead of 'Property'.        */
name|prop_header
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"Property: %s\n"
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|prop_header
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|prop_header
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|atat
operator|=
name|prop_atat
expr_stmt|;
block|}
else|else
block|{
name|atat
operator|=
name|text_atat
expr_stmt|;
block|}
name|hunk_header
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s -%lu,%lu +%lu,%lu %s%s"
argument_list|,
name|atat
argument_list|,
name|svn_diff_hunk_get_original_start
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|svn_diff_hunk_get_original_length
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|svn_diff_hunk_get_modified_start
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hunk
argument_list|)
argument_list|,
name|atat
argument_list|,
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|hunk_header
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|hunk_header
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_diff_text
argument_list|(
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
block|{
if|if
condition|(
name|hunk_line
operator|->
name|len
operator|>=
literal|1
condition|)
block|{
name|len
operator|=
name|hunk_line
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|hunk_line
operator|->
name|data
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eol_str
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|eol_str
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|eol_str
argument_list|,
name|len
argument_list|,
operator|&
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
condition|)
name|target
operator|->
name|had_prop_rejects
operator|=
name|TRUE
expr_stmt|;
else|else
name|target
operator|->
name|had_rejects
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the modified text of the hunk described by HI to the patched  * CONTENT. TARGET is the patch target.  * If PROP_NAME is not NULL, the hunk is assumed to be targeted for  * a property with the given name.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_hunk
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|target_content_t
modifier|*
name|content
parameter_list|,
name|hunk_info_t
modifier|*
name|hi
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_linenum_t
name|lines_read
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* ### Is there a cleaner way to describe if we have an existing target?    */
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
operator|||
name|prop_name
condition|)
block|{
name|svn_linenum_t
name|line
decl_stmt|;
comment|/* Move forward to the hunk's line, copying data as we go.        * Also copy leading lines of context which matched with fuzz.        * The target has changed on the fuzzy-matched lines,        * so we should retain the target's version of those lines. */
name|SVN_ERR
argument_list|(
name|copy_lines_to_target
argument_list|(
name|content
argument_list|,
name|hi
operator|->
name|matched_line
operator|+
name|hi
operator|->
name|fuzz
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip the target's version of the hunk.        * Don't skip trailing lines which matched with fuzz. */
name|line
operator|=
name|content
operator|->
name|current_line
operator|+
name|svn_diff_hunk_get_original_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
operator|-
operator|(
literal|2
operator|*
name|hi
operator|->
name|fuzz
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|seek_to_line
argument_list|(
name|content
argument_list|,
name|line
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content
operator|->
name|current_line
operator|!=
name|line
operator|&&
operator|!
name|content
operator|->
name|eof
condition|)
block|{
comment|/* Seek failed, reject this hunk. */
name|hi
operator|->
name|rejected
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|content
argument_list|,
name|hi
operator|->
name|hunk
argument_list|,
name|prop_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Write the hunk's version to the patched result.    * Don't write the lines which matched with fuzz. */
name|lines_read
operator|=
literal|0
expr_stmt|;
name|svn_diff_hunk_reset_modified_text
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_stringbuf_t
modifier|*
name|hunk_line
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol_str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_hunk_readline_modified_text
argument_list|(
name|hi
operator|->
name|hunk
argument_list|,
operator|&
name|hunk_line
argument_list|,
operator|&
name|eol_str
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|lines_read
operator|++
expr_stmt|;
if|if
condition|(
name|lines_read
operator|>
name|hi
operator|->
name|fuzz
operator|&&
name|lines_read
operator|<=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
operator|-
name|hi
operator|->
name|fuzz
condition|)
block|{
name|apr_size_t
name|len
decl_stmt|;
if|if
condition|(
name|hunk_line
operator|->
name|len
operator|>=
literal|1
condition|)
block|{
name|len
operator|=
name|hunk_line
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|write
argument_list|(
name|content
operator|->
name|write_baton
argument_list|,
name|hunk_line
operator|->
name|data
argument_list|,
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eol_str
condition|)
block|{
comment|/* Use the EOL as it was read from the patch file,                * unless the target's EOL style is set by svn:eol-style */
if|if
condition|(
name|content
operator|->
name|eol_style
operator|!=
name|svn_subst_eol_style_none
condition|)
name|eol_str
operator|=
name|content
operator|->
name|eol_str
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|eol_str
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|content
operator|->
name|write
argument_list|(
name|content
operator|->
name|write_baton
argument_list|,
name|eol_str
argument_list|,
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_name
condition|)
name|target
operator|->
name|has_prop_changes
operator|=
name|TRUE
expr_stmt|;
else|else
name|target
operator|->
name|has_text_changes
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Use client context CTX to send a suitable notification for hunk HI,  * using TARGET to determine the path. If the hunk is a property hunk,  * PROP_NAME must be the name of the property, else NULL.  * Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_hunk_notification
parameter_list|(
specifier|const
name|hunk_info_t
modifier|*
name|hi
parameter_list|,
specifier|const
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
specifier|const
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_wc_notify_action_t
name|action
decl_stmt|;
if|if
condition|(
name|hi
operator|->
name|already_applied
condition|)
name|action
operator|=
name|svn_wc_notify_patch_hunk_already_applied
expr_stmt|;
elseif|else
if|if
condition|(
name|hi
operator|->
name|rejected
condition|)
name|action
operator|=
name|svn_wc_notify_patch_rejected_hunk
expr_stmt|;
else|else
name|action
operator|=
name|svn_wc_notify_patch_applied_hunk
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|target
operator|->
name|local_abspath
condition|?
name|target
operator|->
name|local_abspath
else|:
name|target
operator|->
name|local_relpath
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_original_start
operator|=
name|svn_diff_hunk_get_original_start
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_original_length
operator|=
name|svn_diff_hunk_get_original_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_modified_start
operator|=
name|svn_diff_hunk_get_modified_start
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_modified_length
operator|=
name|svn_diff_hunk_get_modified_length
argument_list|(
name|hi
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|notify
operator|->
name|hunk_matched_line
operator|=
name|hi
operator|->
name|matched_line
expr_stmt|;
name|notify
operator|->
name|hunk_fuzz
operator|=
name|hi
operator|->
name|fuzz
expr_stmt|;
name|notify
operator|->
name|prop_name
operator|=
name|prop_name
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Use client context CTX to send a suitable notification for a patch TARGET.  * Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_patch_notification
parameter_list|(
specifier|const
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_wc_notify_action_t
name|action
decl_stmt|;
specifier|const
name|char
modifier|*
name|notify_path
decl_stmt|;
if|if
condition|(
operator|!
name|ctx
operator|->
name|notify_func2
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|target
operator|->
name|skipped
condition|)
name|action
operator|=
name|svn_wc_notify_skip
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|deleted
condition|)
name|action
operator|=
name|svn_wc_notify_delete
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|replaced
operator|||
name|target
operator|->
name|move_target_abspath
condition|)
name|action
operator|=
name|svn_wc_notify_add
expr_stmt|;
else|else
name|action
operator|=
name|svn_wc_notify_patch
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|move_target_abspath
condition|)
name|notify_path
operator|=
name|target
operator|->
name|move_target_abspath
expr_stmt|;
else|else
name|notify_path
operator|=
name|target
operator|->
name|local_abspath
condition|?
name|target
operator|->
name|local_abspath
else|:
name|target
operator|->
name|local_relpath
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|notify_path
argument_list|,
name|action
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|svn_wc_notify_skip
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_none
operator|||
name|target
operator|->
name|db_kind
operator|==
name|svn_node_unknown
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_missing
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_dir
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_obstructed
expr_stmt|;
else|else
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_unknown
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|target
operator|->
name|had_rejects
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|local_mods
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|has_text_changes
condition|)
name|notify
operator|->
name|content_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|had_prop_rejects
condition|)
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|has_prop_changes
condition|)
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
block|}
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|==
name|svn_wc_notify_patch
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hash_index
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|send_hunk_notification
argument_list|(
name|hi
argument_list|,
name|target
argument_list|,
name|NULL
comment|/* prop_name */
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|hash_index
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|target
operator|->
name|prop_targets
argument_list|)
init|;
name|hash_index
condition|;
name|hash_index
operator|=
name|apr_hash_next
argument_list|(
name|hash_index
argument_list|)
control|)
block|{
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|prop_target
operator|=
name|apr_hash_this_val
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Don't notify on the hunk level for added or deleted props. */
if|if
condition|(
name|prop_target
operator|->
name|operation
operator|!=
name|svn_diff_op_added
operator|&&
name|prop_target
operator|->
name|operation
operator|!=
name|svn_diff_op_deleted
condition|)
name|SVN_ERR
argument_list|(
name|send_hunk_notification
argument_list|(
name|hi
argument_list|,
name|target
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|->
name|move_target_abspath
condition|)
block|{
comment|/* Notify about deletion of move source. */
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
name|svn_wc_notify_delete
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements the callback for svn_sort__array.  Puts hunks that match    before hunks that do not match, puts hunks that match in order    based on postion matched, puts hunks that do not match in order    based on original position. */
end_comment

begin_function
specifier|static
name|int
name|sort_matched_hunks
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|hunk_info_t
modifier|*
name|item1
init|=
operator|*
operator|(
operator|(
specifier|const
name|hunk_info_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|hunk_info_t
modifier|*
name|item2
init|=
operator|*
operator|(
operator|(
specifier|const
name|hunk_info_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
name|svn_boolean_t
name|matched1
init|=
operator|!
name|item1
operator|->
name|rejected
operator|&&
operator|!
name|item1
operator|->
name|already_applied
decl_stmt|;
name|svn_boolean_t
name|matched2
init|=
operator|!
name|item2
operator|->
name|rejected
operator|&&
operator|!
name|item2
operator|->
name|already_applied
decl_stmt|;
name|svn_linenum_t
name|original1
decl_stmt|,
name|original2
decl_stmt|;
if|if
condition|(
name|matched1
operator|&&
name|matched2
condition|)
block|{
comment|/* Both match so use order matched in file. */
if|if
condition|(
name|item1
operator|->
name|matched_line
operator|>
name|item2
operator|->
name|matched_line
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|item1
operator|->
name|matched_line
operator|==
name|item2
operator|->
name|matched_line
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|matched2
condition|)
comment|/* Only second matches, put it before first. */
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|matched1
condition|)
comment|/* Only first matches, put it before second. */
return|return
operator|-
literal|1
return|;
comment|/* Neither matches, sort by original_start. */
name|original1
operator|=
name|svn_diff_hunk_get_original_start
argument_list|(
name|item1
operator|->
name|hunk
argument_list|)
expr_stmt|;
name|original2
operator|=
name|svn_diff_hunk_get_original_start
argument_list|(
name|item2
operator|->
name|hunk
argument_list|)
expr_stmt|;
if|if
condition|(
name|original1
operator|>
name|original2
condition|)
return|return
literal|1
return|;
elseif|else
if|if
condition|(
name|original1
operator|==
name|original2
condition|)
return|return
literal|0
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Apply a PATCH to a working copy at ABS_WC_PATH and put the result  * into temporary files, to be installed in the working copy later.  * Return information about the patch target in *PATCH_TARGET, allocated  * in RESULT_POOL. Use WC_CTX as the working copy context.  * STRIP_COUNT specifies the number of leading path components  * which should be stripped from target paths in the patch.  * REMOVE_TEMPFILES, PATCH_FUNC, and PATCH_BATON as in svn_client_patch().  * IGNORE_WHITESPACE tells whether whitespace should be considered when  * doing the matching.  * Call cancel CANCEL_FUNC with baton CANCEL_BATON to trigger cancellation.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_one_patch
parameter_list|(
name|patch_target_t
modifier|*
modifier|*
name|patch_target
parameter_list|,
name|svn_patch_t
modifier|*
name|patch
parameter_list|,
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|patch_target_t
modifier|*
name|target
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|svn_linenum_t
name|MAX_FUZZ
init|=
literal|2
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hash_index
decl_stmt|;
name|svn_linenum_t
name|previous_offset
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|init_patch_target
argument_list|(
operator|&
name|target
argument_list|,
name|patch
argument_list|,
name|abs_wc_path
argument_list|,
name|wc_ctx
argument_list|,
name|strip_count
argument_list|,
name|remove_tempfiles
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|skipped
condition|)
block|{
operator|*
name|patch_target
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Match hunks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patch
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_diff_hunk_t
modifier|*
name|hunk
decl_stmt|;
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_linenum_t
name|fuzz
init|=
literal|0
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|hunk
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|patch
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|svn_diff_hunk_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Determine the line the hunk should be applied at.        * If no match is found initially, try with fuzz. */
do|do
block|{
name|SVN_ERR
argument_list|(
name|get_hunk_info
argument_list|(
operator|&
name|hi
argument_list|,
name|target
argument_list|,
name|target
operator|->
name|content
argument_list|,
name|hunk
argument_list|,
name|fuzz
argument_list|,
name|previous_offset
argument_list|,
name|ignore_whitespace
argument_list|,
name|FALSE
comment|/* is_prop_hunk */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|fuzz
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|hi
operator|->
name|rejected
operator|&&
name|fuzz
operator|<=
name|MAX_FUZZ
operator|&&
operator|!
name|hi
operator|->
name|already_applied
condition|)
do|;
if|if
condition|(
name|hi
operator|->
name|matched_line
condition|)
name|previous_offset
operator|=
name|hi
operator|->
name|matched_line
operator|-
name|svn_diff_hunk_get_original_start
argument_list|(
name|hunk
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
operator|=
name|hi
expr_stmt|;
block|}
comment|/* Hunks are applied in the order determined by the matched line and      this may be different from the order of the original lines. */
name|svn_sort__array
argument_list|(
name|target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|sort_matched_hunks
argument_list|)
expr_stmt|;
comment|/* Apply or reject hunks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|already_applied
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|hi
operator|->
name|rejected
condition|)
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|content
argument_list|,
name|hi
operator|->
name|hunk
argument_list|,
name|NULL
comment|/* prop_name */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|apply_hunk
argument_list|(
name|target
argument_list|,
name|target
operator|->
name|content
argument_list|,
name|hi
argument_list|,
name|NULL
comment|/* prop_name */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
block|{
comment|/* Copy any remaining lines to target. */
name|SVN_ERR
argument_list|(
name|copy_lines_to_target
argument_list|(
name|target
operator|->
name|content
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|content
operator|->
name|eof
condition|)
block|{
comment|/* We could not copy the entire target file to the temporary file,            * and would truncate the target if we copied the temporary file            * on top of it. Skip this target. */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* Match property hunks. */
for|for
control|(
name|hash_index
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|patch
operator|->
name|prop_patches
argument_list|)
init|;
name|hash_index
condition|;
name|hash_index
operator|=
name|apr_hash_next
argument_list|(
name|hash_index
argument_list|)
control|)
block|{
name|svn_prop_patch_t
modifier|*
name|prop_patch
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|prop_name
operator|=
name|apr_hash_this_key
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
name|prop_patch
operator|=
name|apr_hash_this_val
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prop_name
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
condition|)
name|target
operator|->
name|is_special
operator|=
name|TRUE
expr_stmt|;
comment|/* We'll store matched hunks in prop_content. */
name|prop_target
operator|=
name|svn_hash_gets
argument_list|(
name|target
operator|->
name|prop_targets
argument_list|,
name|prop_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_patch
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_diff_hunk_t
modifier|*
name|hunk
decl_stmt|;
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_linenum_t
name|fuzz
init|=
literal|0
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|hunk
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_patch
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|svn_diff_hunk_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Determine the line the hunk should be applied at.            * If no match is found initially, try with fuzz. */
do|do
block|{
name|SVN_ERR
argument_list|(
name|get_hunk_info
argument_list|(
operator|&
name|hi
argument_list|,
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hunk
argument_list|,
name|fuzz
argument_list|,
literal|0
argument_list|,
name|ignore_whitespace
argument_list|,
name|TRUE
comment|/* is_prop_hunk */
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|fuzz
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|hi
operator|->
name|rejected
operator|&&
name|fuzz
operator|<=
name|MAX_FUZZ
operator|&&
operator|!
name|hi
operator|->
name|already_applied
condition|)
do|;
name|APR_ARRAY_PUSH
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
operator|=
name|hi
expr_stmt|;
block|}
block|}
comment|/* Apply or reject property hunks. */
for|for
control|(
name|hash_index
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|target
operator|->
name|prop_targets
argument_list|)
init|;
name|hash_index
condition|;
name|hash_index
operator|=
name|apr_hash_next
argument_list|(
name|hash_index
argument_list|)
control|)
block|{
name|prop_patch_target_t
modifier|*
name|prop_target
decl_stmt|;
name|prop_target
operator|=
name|apr_hash_this_val
argument_list|(
name|hash_index
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|hunk_info_t
modifier|*
name|hi
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|hi
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|hi
operator|->
name|already_applied
condition|)
continue|continue;
elseif|else
if|if
condition|(
name|hi
operator|->
name|rejected
condition|)
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hi
operator|->
name|hunk
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|apply_hunk
argument_list|(
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hi
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_target
operator|->
name|content
operator|->
name|existed
condition|)
block|{
comment|/* Copy any remaining lines to target. */
name|SVN_ERR
argument_list|(
name|copy_lines_to_target
argument_list|(
name|prop_target
operator|->
name|content
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prop_target
operator|->
name|content
operator|->
name|eof
condition|)
block|{
comment|/* We could not copy the entire target property to the                  * temporary file, and would truncate the target if we                  * copied the temporary file on top of it. Skip this target.  */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|is_symlink
condition|)
block|{
comment|/* Now close files we don't need any longer to get their contents        * flushed to disk.        * But we're not closing the reject file -- it still needed and        * will be closed later in write_out_rejected_hunks(). */
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|target
operator|->
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|target
operator|->
name|patched_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|apr_finfo_t
name|working_file
decl_stmt|;
name|apr_finfo_t
name|patched_file
decl_stmt|;
comment|/* Get sizes of the patched temporary file and the working file.        * We'll need those to figure out whether we should delete the        * patched file. */
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|patched_file
argument_list|,
name|target
operator|->
name|patched_path
argument_list|,
name|APR_FINFO_SIZE
operator||
name|APR_FINFO_LINK
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|working_file
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|APR_FINFO_SIZE
operator||
name|APR_FINFO_LINK
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|working_file
operator|.
name|size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|patched_file
operator|.
name|size
operator|==
literal|0
operator|&&
name|working_file
operator|.
name|size
operator|>
literal|0
condition|)
block|{
comment|/* If a unidiff removes all lines from a file, that usually            * means deletion, so we can confidently schedule the target            * for deletion. In the rare case where the unidiff was really            * meant to replace a file with an empty one, this may not            * be desirable. But the deletion can easily be reverted and            * creating an empty file manually is not exactly hard either. */
name|target
operator|->
name|deleted
operator|=
operator|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_file
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patched_file
operator|.
name|size
operator|==
literal|0
operator|&&
name|working_file
operator|.
name|size
operator|==
literal|0
condition|)
block|{
comment|/* The target was empty or non-existent to begin with            * and no content was changed by patching.            * Report this as skipped if it didn't exist, unless in the special            * case of adding an empty file which has properties set on it or            * adding an empty file with a 'git diff' */
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_none
operator|&&
operator|!
name|target
operator|->
name|has_prop_changes
operator|&&
operator|!
name|target
operator|->
name|added
condition|)
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|patched_file
operator|.
name|size
operator|>
literal|0
operator|&&
name|working_file
operator|.
name|size
operator|==
literal|0
condition|)
block|{
comment|/* The patch has created a file. */
if|if
condition|(
name|target
operator|->
name|locally_deleted
condition|)
name|target
operator|->
name|replaced
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|target
operator|->
name|db_kind
operator|==
name|svn_node_none
condition|)
name|target
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
operator|*
name|patch_target
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Try to create missing parent directories for TARGET in the working copy  * rooted at ABS_WC_PATH, and add the parents to version control.  * If the parents cannot be created, mark the target as skipped.  * Use client context CTX. If DRY_RUN is true, do not create missing  * parents but issue notifications only.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_missing_parents
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|components
decl_stmt|;
name|int
name|present_components
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Check if we can safely create the target's parent. */
name|local_abspath
operator|=
name|abs_wc_path
expr_stmt|;
name|components
operator|=
name|svn_path_decompose
argument_list|(
name|target
operator|->
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|present_components
operator|=
literal|0
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|components
operator|->
name|nelts
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|,
name|disk_kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|component
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|wc_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|==
name|svn_node_file
operator|||
name|wc_kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* on-disk files and missing files are obstructions */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|disk_kind
operator|==
name|svn_node_dir
condition|)
block|{
if|if
condition|(
name|wc_kind
operator|==
name|svn_node_dir
condition|)
name|present_components
operator|++
expr_stmt|;
else|else
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|wc_kind
operator|!=
name|svn_node_none
condition|)
block|{
comment|/* Node is missing */
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* It's not a file, it's not a dir...              Let's add a dir */
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|local_abspath
operator|=
name|abs_wc_path
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|present_components
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|component
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dry_run
operator|&&
name|present_components
operator|<
name|components
operator|->
name|nelts
operator|-
literal|1
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_join
argument_list|(
name|abs_wc_path
argument_list|,
name|svn_relpath_dirname
argument_list|(
name|target
operator|->
name|local_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|present_components
init|;
name|i
operator|<
name|components
operator|->
name|nelts
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|component
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|components
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|component
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
comment|/* Just do notification. */
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_add
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Create the missing component and add it                * to version control. Allow cancellation since we                * have not modified the working copy yet for this                * target. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk3
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
name|FALSE
comment|/* skip checks */
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Install a patched TARGET into the working copy at ABS_WC_PATH.  * Use client context CTX to retrieve WC_CTX, and possibly doing  * notifications. If DRY_RUN is TRUE, don't modify the working copy.  * Do temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|install_patched_target
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|target
operator|->
name|deleted
condition|)
block|{
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
comment|/* Schedule the target for deletion.  Suppress            * notification, we'll do it manually in a minute            * because we also need to notify during dry-run.            * Also suppress cancellation, because we'd rather            * notify about what we did before aborting. */
name|SVN_ERR
argument_list|(
name|svn_wc_delete4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_local */
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|svn_node_kind_t
name|parent_db_kind
decl_stmt|;
if|if
condition|(
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|replaced
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If the target's parent directory does not yet exist            * we need to create it before we can copy the patched            * result in place. */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|parent_db_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't add targets under nodes scheduled for delete, so add              a new directory if needed. */
if|if
condition|(
name|parent_db_kind
operator|==
name|svn_node_dir
operator|||
name|parent_db_kind
operator|==
name|svn_node_file
condition|)
block|{
if|if
condition|(
name|parent_db_kind
operator|!=
name|svn_node_dir
condition|)
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|parent_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|!=
name|svn_node_dir
condition|)
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
name|SVN_ERR
argument_list|(
name|create_missing_parents
argument_list|(
name|target
argument_list|,
name|abs_wc_path
argument_list|,
name|ctx
argument_list|,
name|dry_run
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
comment|/* The target should exist */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|wc_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_none
operator|||
name|wc_kind
operator|!=
name|target
operator|->
name|kind_on_disk
condition|)
block|{
name|target
operator|->
name|skipped
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|dry_run
operator|&&
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
if|if
condition|(
name|target
operator|->
name|is_special
condition|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|patched_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|patched_stream
argument_list|,
name|target
operator|->
name|patched_path
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_create_specialfile
argument_list|(
operator|&
name|stream
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|patched_stream
argument_list|,
name|stream
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_boolean_t
name|repair_eol
decl_stmt|;
comment|/* Copy the patched file on top of the target file.                * Always expand keywords in the patched file, but repair EOL                * only if svn:eol-style dictates a particular style. */
name|repair_eol
operator|=
operator|(
name|target
operator|->
name|content
operator|->
name|eol_style
operator|==
name|svn_subst_eol_style_fixed
operator|||
name|target
operator|->
name|content
operator|->
name|eol_style
operator|==
name|svn_subst_eol_style_native
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_copy_and_translate4
argument_list|(
name|target
operator|->
name|patched_path
argument_list|,
name|target
operator|->
name|move_target_abspath
condition|?
name|target
operator|->
name|move_target_abspath
else|:
name|target
operator|->
name|local_abspath
argument_list|,
name|target
operator|->
name|content
operator|->
name|eol_str
argument_list|,
name|repair_eol
argument_list|,
name|target
operator|->
name|content
operator|->
name|keywords
argument_list|,
name|TRUE
comment|/* expand */
argument_list|,
name|FALSE
comment|/* special */
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|replaced
condition|)
block|{
comment|/* The target file didn't exist previously,                * so add it to version control.                * Suppress notification, we'll do that later (and also                * during dry-run). Don't allow cancellation because                * we'd rather notify about what we did before aborting. */
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk3
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
name|FALSE
comment|/* skip checks */
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Restore the target's executable bit if necessary. */
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|target
operator|->
name|move_target_abspath
condition|?
name|target
operator|->
name|move_target_abspath
else|:
name|target
operator|->
name|local_abspath
argument_list|,
name|target
operator|->
name|executable
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|move_target_abspath
condition|)
block|{
comment|/* ### Copying the patched content to the move target location,                * performing the move in meta-data, and removing the file at                * the move source should be one atomic operation. */
comment|/* ### Create missing parents. */
comment|/* Perform the move in meta-data. */
name|SVN_ERR
argument_list|(
name|svn_wc__move2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|target
operator|->
name|move_target_abspath
argument_list|,
name|TRUE
argument_list|,
comment|/* metadata_only */
name|FALSE
argument_list|,
comment|/* allow_mixed_revisions */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Delete the patch target's old location from disk. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write out rejected hunks, if any, to TARGET->REJECT_PATH. If DRY_RUN is  * TRUE, don't modify the working copy.  * Do temporary allocations in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_out_rejected_hunks
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|target
operator|->
name|reject_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
operator|&&
operator|(
name|target
operator|->
name|had_rejects
operator|||
name|target
operator|->
name|had_prop_rejects
operator|)
condition|)
block|{
comment|/* Write out rejected hunks, if any. */
name|SVN_ERR
argument_list|(
name|svn_io_copy_file
argument_list|(
name|target
operator|->
name|reject_path
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s.svnpatch.rej"
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### TODO mark file as conflicted. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Install the patched properties for TARGET. Use client context CTX to  * retrieve WC_CTX. If DRY_RUN is TRUE, don't modify the working copy.  * Do temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|install_patched_prop_targets
parameter_list|(
name|patch_target_t
modifier|*
name|target
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|target
operator|->
name|prop_targets
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|prop_patch_target_t
modifier|*
name|prop_target
init|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|prop_val
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For a deleted prop we only set the value to NULL. */
if|if
condition|(
name|prop_target
operator|->
name|operation
operator|==
name|svn_diff_op_deleted
condition|)
block|{
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_prop_set4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|NULL
argument_list|,
name|svn_depth_empty
argument_list|,
name|TRUE
comment|/* skip_checks */
argument_list|,
name|NULL
comment|/* changelist_filter */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* cancellation */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* notification */
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If the patch target doesn't exist yet, the patch wants to add an        * empty file with properties set on it. So create an empty file and        * add it to version control. But if the patch was in the 'git format'        * then the file has already been added.        *        * ### How can we tell whether the patch really wanted to create        * ### an empty directory? */
if|if
condition|(
operator|!
name|target
operator|->
name|has_text_changes
operator|&&
name|target
operator|->
name|kind_on_disk
operator|==
name|svn_node_none
operator|&&
operator|!
name|target
operator|->
name|added
condition|)
block|{
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|target
operator|->
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk3
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|NULL
comment|/*props*/
argument_list|,
name|FALSE
comment|/* skip checks */
argument_list|,
comment|/* suppress notification */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Attempt to set the property, and reject all hunks if this          fails.  If the property had a non-empty value, but now has          an empty one, we'll just delete the property altogether.  */
if|if
condition|(
name|prop_target
operator|->
name|value
operator|&&
name|prop_target
operator|->
name|value
operator|->
name|len
operator|&&
name|prop_target
operator|->
name|patched_value
operator|&&
operator|!
name|prop_target
operator|->
name|patched_value
operator|->
name|len
condition|)
name|prop_val
operator|=
name|NULL
expr_stmt|;
else|else
name|prop_val
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|prop_target
operator|->
name|patched_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|dry_run
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|canon_propval
decl_stmt|;
name|err
operator|=
name|svn_wc_canonicalize_svn_prop
argument_list|(
operator|&
name|canon_propval
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|prop_val
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|target
operator|->
name|db_kind
argument_list|,
name|TRUE
argument_list|,
comment|/* ### Skipping checks */
name|NULL
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|svn_wc_prop_set4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|prop_val
argument_list|,
name|svn_depth_empty
argument_list|,
name|TRUE
comment|/* skip_checks */
argument_list|,
name|NULL
comment|/* changelist_filter */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* cancellation */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* notification */
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
comment|/* ### The errors which svn_wc_canonicalize_svn_prop() will            * ### return aren't documented. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ILLEGAL_TARGET
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_NODE_UNEXPECTED_KIND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_IO_UNKNOWN_EOL
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_BAD_MIME_TYPE
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION
condition|)
block|{
name|int
name|i
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_target
operator|->
name|content
operator|->
name|hunks
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|hunk_info_t
modifier|*
name|hunk_info
decl_stmt|;
name|hunk_info
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_target
operator|->
name|content
operator|->
name|hunks
argument_list|,
name|i
argument_list|,
name|hunk_info_t
operator|*
argument_list|)
expr_stmt|;
name|hunk_info
operator|->
name|rejected
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reject_hunk
argument_list|(
name|target
argument_list|,
name|prop_target
operator|->
name|content
argument_list|,
name|hunk_info
operator|->
name|hunk
argument_list|,
name|prop_target
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for can_delete_callback */
end_comment

begin_struct
struct|struct
name|can_delete_baton_t
block|{
name|svn_boolean_t
name|must_keep
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|targets_info
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_wc_status_func4_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|can_delete_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|can_delete_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|int
name|i
decl_stmt|;
switch|switch
condition|(
name|status
operator|->
name|node_status
condition|)
block|{
case|case
name|svn_wc_status_none
case|:
case|case
name|svn_wc_status_deleted
case|:
return|return
name|SVN_NO_ERROR
return|;
default|default:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|cb
operator|->
name|local_abspath
argument_list|,
name|abspath
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Only interested in descendants */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|targets_info
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|patch_target_info_t
modifier|*
name|target_info
init|=
name|APR_ARRAY_IDX
argument_list|(
name|cb
operator|->
name|targets_info
argument_list|,
name|i
argument_list|,
specifier|const
name|patch_target_info_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|target_info
operator|->
name|local_abspath
argument_list|,
name|abspath
argument_list|)
condition|)
block|{
if|if
condition|(
name|target_info
operator|->
name|deleted
condition|)
return|return
name|SVN_NO_ERROR
return|;
break|break;
comment|/* Cease invocation; must keep */
block|}
block|}
name|cb
operator|->
name|must_keep
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CEASE_INVOCATION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_ancestor_delete
parameter_list|(
specifier|const
name|char
modifier|*
name|deleted_target
parameter_list|,
name|apr_array_header_t
modifier|*
name|targets_info
parameter_list|,
specifier|const
name|char
modifier|*
name|apply_root
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|can_delete_baton_t
name|cb
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_array_header_t
modifier|*
name|ignores
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|deleted_target
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|ignores
argument_list|,
name|ctx
operator|->
name|config
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|svn_dirent_is_child
argument_list|(
name|apply_root
argument_list|,
name|dir_abspath
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|cb
operator|.
name|local_abspath
operator|=
name|dir_abspath
expr_stmt|;
name|cb
operator|.
name|must_keep
operator|=
name|FALSE
expr_stmt|;
name|cb
operator|.
name|targets_info
operator|=
name|targets_info
expr_stmt|;
name|err
operator|=
name|svn_wc_walk_status
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ignores
argument_list|,
name|can_delete_callback
argument_list|,
operator|&
name|cb
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_CEASE_INVOCATION
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cb
operator|.
name|must_keep
condition|)
block|{
break|break;
block|}
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_delete4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|dir_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|{
name|patch_target_info_t
modifier|*
name|pti
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pti
argument_list|)
argument_list|)
decl_stmt|;
name|pti
operator|->
name|local_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|dir_abspath
argument_list|)
expr_stmt|;
name|pti
operator|->
name|deleted
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|targets_info
argument_list|,
name|patch_target_info_t
operator|*
argument_list|)
operator|=
name|pti
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|dir_abspath
argument_list|,
name|svn_wc_notify_delete
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* And check if we must also delete the parent */
name|dir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This function is the main entry point into the patch code. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_patches
parameter_list|(
comment|/* The path to the patch file. */
specifier|const
name|char
modifier|*
name|patch_abspath
parameter_list|,
comment|/* The abspath to the working copy the patch should be applied to. */
specifier|const
name|char
modifier|*
name|abs_wc_path
parameter_list|,
comment|/* Indicates whether we're doing a dry run. */
name|svn_boolean_t
name|dry_run
parameter_list|,
comment|/* Number of leading components to strip from patch target paths. */
name|int
name|strip_count
parameter_list|,
comment|/* Whether to apply the patch in reverse. */
name|svn_boolean_t
name|reverse
parameter_list|,
comment|/* Whether to ignore whitespace when matching context lines. */
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
comment|/* As in svn_client_patch(). */
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
comment|/* As in svn_client_patch(). */
name|svn_client_patch_func_t
name|patch_func
parameter_list|,
name|void
modifier|*
name|patch_baton
parameter_list|,
comment|/* The client context. */
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_patch_t
modifier|*
name|patch
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_patch_file_t
modifier|*
name|patch_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets_info
decl_stmt|;
comment|/* Try to open the patch file. */
name|SVN_ERR
argument_list|(
name|svn_diff_open_patch_file
argument_list|(
operator|&
name|patch_file
argument_list|,
name|patch_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Apply patches. */
name|targets_info
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|patch_target_info_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_parse_next_patch
argument_list|(
operator|&
name|patch
argument_list|,
name|patch_file
argument_list|,
name|reverse
argument_list|,
name|ignore_whitespace
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|patch
condition|)
block|{
name|patch_target_t
modifier|*
name|target
decl_stmt|;
name|svn_boolean_t
name|filtered
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|apply_one_patch
argument_list|(
operator|&
name|target
argument_list|,
name|patch
argument_list|,
name|abs_wc_path
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|strip_count
argument_list|,
name|ignore_whitespace
argument_list|,
name|remove_tempfiles
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
operator|&&
name|patch_func
condition|)
block|{
name|SVN_ERR
argument_list|(
name|patch_func
argument_list|(
name|patch_baton
argument_list|,
operator|&
name|filtered
argument_list|,
name|target
operator|->
name|canon_path_from_patchfile
argument_list|,
name|target
operator|->
name|patched_path
argument_list|,
name|target
operator|->
name|reject_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|filtered
condition|)
block|{
comment|/* Save info we'll still need when we're done patching. */
name|patch_target_info_t
modifier|*
name|target_info
init|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|patch_target_info_t
argument_list|)
argument_list|)
decl_stmt|;
name|target_info
operator|->
name|local_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|target
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
name|target_info
operator|->
name|deleted
operator|=
name|target
operator|->
name|deleted
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|targets_info
argument_list|,
name|patch_target_info_t
operator|*
argument_list|)
operator|=
name|target_info
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|has_text_changes
operator|||
name|target
operator|->
name|added
operator|||
name|target
operator|->
name|move_target_abspath
operator|||
name|target
operator|->
name|deleted
condition|)
name|SVN_ERR
argument_list|(
name|install_patched_target
argument_list|(
name|target
argument_list|,
name|abs_wc_path
argument_list|,
name|ctx
argument_list|,
name|dry_run
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|has_prop_changes
operator|&&
operator|(
operator|!
name|target
operator|->
name|deleted
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|install_patched_prop_targets
argument_list|(
name|target
argument_list|,
name|ctx
argument_list|,
name|dry_run
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_out_rejected_hunks
argument_list|(
name|target
argument_list|,
name|dry_run
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|send_patch_notification
argument_list|(
name|target
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|->
name|deleted
operator|&&
operator|!
name|target
operator|->
name|skipped
condition|)
block|{
name|SVN_ERR
argument_list|(
name|check_ancestor_delete
argument_list|(
name|target_info
operator|->
name|local_abspath
argument_list|,
name|targets_info
argument_list|,
name|abs_wc_path
argument_list|,
name|dry_run
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
do|while
condition|(
name|patch
condition|)
do|;
name|SVN_ERR
argument_list|(
name|svn_diff_close_patch_file
argument_list|(
name|patch_file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_patch
parameter_list|(
specifier|const
name|char
modifier|*
name|patch_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_dir_abspath
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|int
name|strip_count
parameter_list|,
name|svn_boolean_t
name|reverse
parameter_list|,
name|svn_boolean_t
name|ignore_whitespace
parameter_list|,
name|svn_boolean_t
name|remove_tempfiles
parameter_list|,
name|svn_client_patch_func_t
name|patch_func
parameter_list|,
name|void
modifier|*
name|patch_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
name|strip_count
operator|<
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"strip count must be positive"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|wc_dir_abspath
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|patch_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|patch_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|patch_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|wc_dir_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|apply_patches
argument_list|(
name|patch_abspath
argument_list|,
name|wc_dir_abspath
argument_list|,
name|dry_run
argument_list|,
name|strip_count
argument_list|,
name|reverse
argument_list|,
name|ignore_whitespace
argument_list|,
name|remove_tempfiles
argument_list|,
name|patch_func
argument_list|,
name|patch_baton
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|wc_dir_abspath
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

