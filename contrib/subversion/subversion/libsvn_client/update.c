begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * update.c:  wrappers around wc update functionality  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_comment
comment|/* Implements svn_wc_dirents_func_t for update and switch handling. Assumes    a struct svn_client__dirent_fetcher_baton_t * baton */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client__dirent_fetcher
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|svn_client__dirent_fetcher_baton_t
modifier|*
name|dfb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_url
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_relpath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|dfb
operator|->
name|anchor_url
argument_list|,
name|url
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_url
argument_list|,
name|dfb
operator|->
name|ra_session
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|session_relpath
operator|=
literal|""
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_session
argument_list|(
name|dfb
operator|->
name|ra_session
argument_list|,
operator|&
name|session_relpath
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Is session_relpath still a directory? */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|dfb
operator|->
name|ra_session
argument_list|,
name|session_relpath
argument_list|,
name|dfb
operator|->
name|target_revision
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|dfb
operator|->
name|ra_session
argument_list|,
name|dirents
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|session_relpath
argument_list|,
name|dfb
operator|->
name|target_revision
argument_list|,
name|SVN_DIRENT_KIND
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|dirents
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|old_url
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|dfb
operator|->
name|ra_session
argument_list|,
name|old_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Set *CLEAN_CHECKOUT to FALSE only if LOCAL_ABSPATH is a non-empty    folder. ANCHOR_ABSPATH is the w/c root and LOCAL_ABSPATH will still    be considered empty, if it is equal to ANCHOR_ABSPATH and only    contains the admin sub-folder.    If the w/c folder already exists but cannot be openend, we return    "unclean" - just in case. Most likely, the caller will have to bail    out later due to the same error we got here.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|is_empty_wc
parameter_list|(
name|svn_boolean_t
modifier|*
name|clean_checkout
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_dir_t
modifier|*
name|dir
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* "clean" until found dirty */
operator|*
name|clean_checkout
operator|=
name|TRUE
expr_stmt|;
comment|/* open directory. If it does not exist, yet, a clean one will      be created by the caller. */
name|err
operator|=
name|svn_io_dir_open
argument_list|(
operator|&
name|dir
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
operator|*
name|clean_checkout
operator|=
name|FALSE
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
for|for
control|(
name|err
operator|=
name|svn_io_dir_read
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_NAME
argument_list|,
name|dir
argument_list|,
name|pool
argument_list|)
init|;
name|err
operator|==
name|SVN_NO_ERROR
condition|;
name|err
operator|=
name|svn_io_dir_read
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_NAME
argument_list|,
name|dir
argument_list|,
name|pool
argument_list|)
control|)
block|{
comment|/* Ignore entries for this dir and its parent, robustly.          (APR promises that they'll come first, so technically          this guard could be moved outside the loop.  But Ryan Bloom          says he doesn't believe it, and I believe him. */
if|if
condition|(
operator|!
operator|(
name|finfo
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|finfo
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
operator|(
name|finfo
operator|.
name|name
index|[
literal|1
index|]
operator|==
literal|'.'
operator|&&
name|finfo
operator|.
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|svn_wc_is_adm_dir
argument_list|(
name|finfo
operator|.
name|name
argument_list|,
name|pool
argument_list|)
operator|||
name|strcmp
argument_list|(
name|local_abspath
argument_list|,
name|anchor_abspath
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|clean_checkout
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* There was some issue reading the folder content.            * We better disable optimizations in that case. */
operator|*
name|clean_checkout
operator|=
name|FALSE
expr_stmt|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_io_dir_close
argument_list|(
name|dir
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* A conflict callback that simply records the conflicted path in BATON.     Implements svn_wc_conflict_resolver_func2_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_conflict
parameter_list|(
name|svn_wc_conflict_result_t
modifier|*
modifier|*
name|result
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|description
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|conflicted_paths
init|=
name|baton
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|conflicted_paths
argument_list|,
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|conflicted_paths
argument_list|)
argument_list|,
name|description
operator|->
name|local_abspath
argument_list|)
argument_list|,
literal|""
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|svn_wc_create_conflict_result
argument_list|(
name|svn_wc_conflict_choose_postpone
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is a helper for svn_client__update_internal(), which see for    an explanation of most of these parameters.  Some stuff that's    unique is as follows:     ANCHOR_ABSPATH is the local absolute path of the update anchor.    This is typically either the same as LOCAL_ABSPATH, or the    immediate parent of LOCAL_ABSPATH.     If NOTIFY_SUMMARY is set (and there's a notification handler in    CTX), transmit the final update summary upon successful    completion of the update.     Add the paths of any conflict victims to CONFLICTED_PATHS, if that    is not null.     Use RA_SESSION_P to run the update if it is not NULL.  If it is then    open a new ra session and place it in RA_SESSION_P.  This allows    repeated calls to update_internal to reuse the same session. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_internal
parameter_list|(
name|svn_revnum_t
modifier|*
name|result_rev
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
name|apr_hash_t
modifier|*
name|conflicted_paths
parameter_list|,
name|svn_ra_session_t
modifier|*
modifier|*
name|ra_session_p
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor_abspath
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|adds_as_modification
parameter_list|,
name|svn_boolean_t
name|notify_summary
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
decl_stmt|;
name|void
modifier|*
name|update_edit_baton
decl_stmt|;
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
decl_stmt|;
name|void
modifier|*
name|report_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|corrected_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|anchor_url
decl_stmt|;
name|svn_revnum_t
name|revnum
decl_stmt|;
name|svn_boolean_t
name|use_commit_times
decl_stmt|;
name|svn_boolean_t
name|clean_checkout
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|diff3_cmd
decl_stmt|;
name|apr_hash_t
modifier|*
name|wcroot_iprops
decl_stmt|;
name|svn_opt_revision_t
name|opt_rev
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
init|=
operator|*
name|ra_session_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|preserved_exts_str
decl_stmt|;
name|apr_array_header_t
modifier|*
name|preserved_exts
decl_stmt|;
name|struct
name|svn_client__dirent_fetcher_baton_t
name|dfb
decl_stmt|;
name|svn_boolean_t
name|server_supports_depth
decl_stmt|;
name|svn_boolean_t
name|cropping_target
decl_stmt|;
name|svn_boolean_t
name|target_conflicted
init|=
name|FALSE
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg
init|=
name|ctx
operator|->
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
decl_stmt|;
if|if
condition|(
name|result_rev
condition|)
operator|*
name|result_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* An unknown depth can't be sticky. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth_is_sticky
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|local_abspath
argument_list|,
name|anchor_abspath
argument_list|)
condition|)
name|target
operator|=
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|target
operator|=
literal|""
expr_stmt|;
comment|/* Check if our anchor exists in BASE. If it doesn't we can't update. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_base
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|anchor_abspath
argument_list|,
name|TRUE
comment|/* ignore_enoent */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It does not make sense to update conflict victims. */
if|if
condition|(
name|repos_relpath
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|text_conflicted
decl_stmt|,
name|prop_conflicted
decl_stmt|;
name|anchor_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc_conflicted_p3
argument_list|(
operator|&
name|text_conflicted
argument_list|,
operator|&
name|prop_conflicted
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* tree-conflicts are handled by the update editor */
if|if
condition|(
operator|!
name|err
operator|&&
operator|(
name|text_conflicted
operator|||
name|prop_conflicted
operator|)
condition|)
name|target_conflicted
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|anchor_url
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|anchor_url
operator|||
name|target_conflicted
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|nt
decl_stmt|;
name|nt
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|target_conflicted
condition|?
name|svn_wc_notify_skip_conflicted
else|:
name|svn_wc_notify_update_skip_working_only
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|nt
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We may need to crop the tree if the depth is sticky */
name|cropping_target
operator|=
operator|(
name|depth_is_sticky
operator|&&
name|depth
operator|<
name|svn_depth_infinity
operator|)
expr_stmt|;
if|if
condition|(
name|cropping_target
condition|)
block|{
name|svn_node_kind_t
name|target_kind
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_exclude
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_exclude
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Target excluded, we are done now */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|target_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_crop_tree2
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* check whether the "clean c/o" optimization is applicable */
name|SVN_ERR
argument_list|(
name|is_empty_wc
argument_list|(
operator|&
name|clean_checkout
argument_list|,
name|local_abspath
argument_list|,
name|anchor_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the external diff3, if any. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|diff3_cmd
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_DIFF3_CMD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff3_cmd
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
operator|&
name|diff3_cmd
argument_list|,
name|diff3_cmd
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if the user wants last-commit timestamps instead of current ones. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|cfg
argument_list|,
operator|&
name|use_commit_times
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_USE_COMMIT_TIMES
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See which files the user wants to preserve the extension of when      conflict files are made. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|preserved_exts_str
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_PRESERVED_CF_EXTS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|preserved_exts
operator|=
operator|*
name|preserved_exts_str
condition|?
name|svn_cstring_split
argument_list|(
name|preserved_exts_str
argument_list|,
literal|"\n\r\t\v "
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
comment|/* Let everyone know we're starting a real update (unless we're      asked not to). */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
operator|&&
name|notify_summary
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_started
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Try to reuse the RA session by reparenting it to the anchor_url.    * This code is probably overly cautious since we only use this    * currently when parents are missing and so all the anchor_urls    * have to be in the same repo. */
if|if
condition|(
name|ra_session
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|anchor_url
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_ILLEGAL_URL
condition|)
block|{
comment|/* session changed repos, can't reuse it */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|ra_session
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|corrected_url
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Open an RA session for the URL if one isn't already available */
if|if
condition|(
operator|!
name|ra_session
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|corrected_url
argument_list|,
name|anchor_url
argument_list|,
name|anchor_abspath
argument_list|,
name|NULL
argument_list|,
name|TRUE
comment|/* write_dav_props */
argument_list|,
name|TRUE
comment|/* read_dav_props */
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ra_session_p
operator|=
name|ra_session
expr_stmt|;
block|}
comment|/* If we got a corrected URL from the RA subsystem, we'll need to      relocate our working copy first. */
if|if
condition|(
name|corrected_url
condition|)
block|{
specifier|const
name|char
modifier|*
name|new_repos_root_url
decl_stmt|;
comment|/* To relocate everything inside our repository we need the old and new          repos root. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|new_repos_root_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* svn_client_relocate2() will check the uuid */
name|SVN_ERR
argument_list|(
name|svn_client_relocate2
argument_list|(
name|anchor_abspath
argument_list|,
name|repos_root_url
argument_list|,
name|new_repos_root_url
argument_list|,
name|ignore_externals
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store updated repository root for externals */
name|repos_root_url
operator|=
name|new_repos_root_url
expr_stmt|;
comment|/* ### We should update anchor_loc->repos_uuid too, although currently        * we don't use it. */
name|anchor_url
operator|=
name|corrected_url
expr_stmt|;
block|}
comment|/* Resolve unspecified REVISION now, because we need to retrieve the      correct inherited props prior to the editor drive and we need to      use the same value of HEAD for both. */
name|opt_rev
operator|.
name|kind
operator|=
name|revision
operator|->
name|kind
expr_stmt|;
name|opt_rev
operator|.
name|value
operator|=
name|revision
operator|->
name|value
expr_stmt|;
if|if
condition|(
name|opt_rev
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
name|opt_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
comment|/* ### todo: shouldn't svn_client__get_revision_number be able      to take a URL as easily as a local path?  */
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|revnum
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|ra_session
argument_list|,
operator|&
name|opt_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|server_supports_depth
argument_list|,
name|SVN_RA_CAPABILITY_DEPTH
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|dfb
operator|.
name|ra_session
operator|=
name|ra_session
expr_stmt|;
name|dfb
operator|.
name|target_revision
operator|=
name|revnum
expr_stmt|;
name|dfb
operator|.
name|anchor_url
operator|=
name|anchor_url
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_inheritable_props
argument_list|(
operator|&
name|wcroot_iprops
argument_list|,
name|local_abspath
argument_list|,
name|revnum
argument_list|,
name|depth
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the update editor.  If REVISION is invalid, that's okay;      the RA driver will call editor->set_target_revision later on. */
name|SVN_ERR
argument_list|(
name|svn_wc__get_update_editor
argument_list|(
operator|&
name|update_editor
argument_list|,
operator|&
name|update_edit_baton
argument_list|,
operator|&
name|revnum
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|anchor_abspath
argument_list|,
name|target
argument_list|,
name|wcroot_iprops
argument_list|,
name|use_commit_times
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|adds_as_modification
argument_list|,
name|server_supports_depth
argument_list|,
name|clean_checkout
argument_list|,
name|diff3_cmd
argument_list|,
name|preserved_exts
argument_list|,
name|svn_client__dirent_fetcher
argument_list|,
operator|&
name|dfb
argument_list|,
name|conflicted_paths
condition|?
name|record_conflict
else|:
name|NULL
argument_list|,
name|conflicted_paths
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell RA to do an update of URL+TARGET to REVISION; if we pass an      invalid revnum, that means RA will use the latest revision.  */
name|SVN_ERR
argument_list|(
name|svn_ra_do_update3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|reporter
argument_list|,
operator|&
name|report_baton
argument_list|,
name|revnum
argument_list|,
name|target
argument_list|,
operator|(
operator|!
name|server_supports_depth
operator|||
name|depth_is_sticky
condition|?
name|depth
else|:
name|svn_depth_unknown
operator|)
argument_list|,
name|FALSE
comment|/* send_copyfrom_args */
argument_list|,
name|FALSE
comment|/* ignore_ancestry */
argument_list|,
name|update_editor
argument_list|,
name|update_edit_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Past this point, we assume the WC is going to be modified so we will    * need to sleep for timestamps. */
operator|*
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
comment|/* Drive the reporter structure, describing the revisions within      LOCAL_ABSPATH.  When this calls reporter->finish_report, the      reporter will drive the update_editor. */
name|SVN_ERR
argument_list|(
name|svn_wc_crawl_revisions5
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|,
name|TRUE
argument_list|,
name|depth
argument_list|,
operator|(
operator|!
name|depth_is_sticky
operator|)
argument_list|,
operator|(
operator|!
name|server_supports_depth
operator|)
argument_list|,
name|use_commit_times
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We handle externals after the update is complete, so that      handling external items (and any errors therefrom) doesn't delay      the primary operation.  */
if|if
condition|(
operator|(
name|SVN_DEPTH_IS_RECURSIVE
argument_list|(
name|depth
argument_list|)
operator|||
name|cropping_target
operator|)
operator|&&
operator|(
operator|!
name|ignore_externals
operator|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|new_externals
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_depths
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__externals_gather_definitions
argument_list|(
operator|&
name|new_externals
argument_list|,
operator|&
name|new_depths
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__handle_externals
argument_list|(
name|new_externals
argument_list|,
name|new_depths
argument_list|,
name|repos_root_url
argument_list|,
name|local_abspath
argument_list|,
name|depth
argument_list|,
name|timestamp_sleep
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Let everyone know we're finished here (unless we're asked not to). */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
operator|&&
name|notify_summary
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_completed
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
name|revnum
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* If the caller wants the result revision, give it to them. */
if|if
condition|(
name|result_rev
condition|)
operator|*
name|result_rev
operator|=
name|revnum
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__update_internal
parameter_list|(
name|svn_revnum_t
modifier|*
name|result_rev
parameter_list|,
name|svn_boolean_t
modifier|*
name|timestamp_sleep
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|adds_as_modification
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_boolean_t
name|innerupdate
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|anchor_abspath
decl_stmt|,
modifier|*
name|lockroot_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_opt_revision_t
name|peg_revision
init|=
operator|*
name|revision
decl_stmt|;
name|apr_hash_t
modifier|*
name|conflicted_paths
init|=
name|ctx
operator|->
name|conflict_func2
condition|?
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
else|:
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
operator|(
name|innerupdate
operator|&&
name|make_parents
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|make_parents
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
init|=
name|local_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|missing_parents
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Try to lock.  If we can't lock because our target (or its              parent) isn't a working copy, we'll try to walk up the              tree to find a working copy, remembering this path's              parent as one we need to flesh out.  */
name|err
operator|=
name|svn_wc__acquire_write_lock
argument_list|(
operator|&
name|lockroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
operator|!
name|innerupdate
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
break|break;
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
operator|)
operator|||
name|svn_dirent_is_root
argument_list|(
name|parent_abspath
argument_list|,
name|strlen
argument_list|(
name|parent_abspath
argument_list|)
argument_list|)
condition|)
return|return
name|err
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Remember the parent of our update target as a missing              parent. */
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|parent_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|missing_parents
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|parent_abspath
expr_stmt|;
block|}
comment|/* Run 'svn up --depth=empty' (effectively) on the missing          parents, if any. */
name|anchor_abspath
operator|=
name|lockroot_abspath
expr_stmt|;
for|for
control|(
name|i
operator|=
name|missing_parents
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
specifier|const
name|char
modifier|*
name|missing_parent
init|=
name|APR_ARRAY_IDX
argument_list|(
name|missing_parents
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|update_internal
argument_list|(
name|result_rev
argument_list|,
name|timestamp_sleep
argument_list|,
name|conflicted_paths
argument_list|,
operator|&
name|ra_session
argument_list|,
name|missing_parent
argument_list|,
name|anchor_abspath
argument_list|,
operator|&
name|peg_revision
argument_list|,
name|svn_depth_empty
argument_list|,
name|FALSE
argument_list|,
name|ignore_externals
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|adds_as_modification
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
name|anchor_abspath
operator|=
name|missing_parent
expr_stmt|;
comment|/* If we successfully updated a missing parent, let's re-use              the returned revision number for future updates for the              sake of consistency. */
name|peg_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|peg_revision
operator|.
name|value
operator|.
name|number
operator|=
operator|*
name|result_rev
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__acquire_write_lock
argument_list|(
operator|&
name|lockroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
operator|!
name|innerupdate
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|anchor_abspath
operator|=
name|lockroot_abspath
expr_stmt|;
block|}
name|err
operator|=
name|update_internal
argument_list|(
name|result_rev
argument_list|,
name|timestamp_sleep
argument_list|,
name|conflicted_paths
argument_list|,
operator|&
name|ra_session
argument_list|,
name|local_abspath
argument_list|,
name|anchor_abspath
argument_list|,
operator|&
name|peg_revision
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|ignore_externals
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|adds_as_modification
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Give the conflict resolver callback the opportunity to    * resolve any conflicts that were raised. */
if|if
condition|(
operator|!
name|err
operator|&&
name|ctx
operator|->
name|conflict_func2
operator|&&
name|apr_hash_count
argument_list|(
name|conflicted_paths
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_client__resolve_conflicts
argument_list|(
name|NULL
argument_list|,
name|conflicted_paths
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_wc__release_write_lock
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|lockroot_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_update4
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|result_revs
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|depth_is_sticky
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|allow_unver_obstructions
parameter_list|,
name|svn_boolean_t
name|adds_as_modification
parameter_list|,
name|svn_boolean_t
name|make_parents
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|sleep
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_boolean_t
name|found_valid_target
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|result_revs
condition|)
operator|*
name|result_revs
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|paths
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_revnum_t
name|result_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
block|{
name|err
operator|=
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|err
operator|=
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
name|err
operator|=
name|svn_client__update_internal
argument_list|(
operator|&
name|result_rev
argument_list|,
operator|&
name|sleep
argument_list|,
name|local_abspath
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|depth_is_sticky
argument_list|,
name|ignore_externals
argument_list|,
name|allow_unver_obstructions
argument_list|,
name|adds_as_modification
argument_list|,
name|make_parents
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
condition|)
goto|goto
name|cleanup
goto|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
comment|/* SVN_ERR_WC_NOT_WORKING_COPY: it's not versioned */
name|result_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|path
argument_list|,
name|svn_wc_notify_skip
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|found_valid_target
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|result_revs
condition|)
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|result_revs
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|result_rev
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
operator|!
name|err
operator|&&
operator|!
name|found_valid_target
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"None of the targets are working copies"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|sleep
condition|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
if|if
condition|(
name|paths
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
comment|/* PATH iteslf may have been removed by the update. */
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|wcroot_abspath
operator|=
name|NULL
expr_stmt|;
name|svn_io_sleep_for_timestamps
argument_list|(
name|wcroot_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

