begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * blame.c:  return blame messages  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_comment
comment|/* The metadata associated with a particular revision. */
end_comment

begin_struct
struct|struct
name|rev
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* the revision number */
name|apr_hash_t
modifier|*
name|rev_props
decl_stmt|;
comment|/* the revision properties */
comment|/* Used for merge reporting. */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* the absolute repository path */
block|}
struct|;
end_struct

begin_comment
comment|/* One chunk of blame */
end_comment

begin_struct
struct|struct
name|blame
block|{
specifier|const
name|struct
name|rev
modifier|*
name|rev
decl_stmt|;
comment|/* the responsible revision */
name|apr_off_t
name|start
decl_stmt|;
comment|/* the starting diff-token (line) */
name|struct
name|blame
modifier|*
name|next
decl_stmt|;
comment|/* the next chunk */
block|}
struct|;
end_struct

begin_comment
comment|/* A chain of blame chunks */
end_comment

begin_struct
struct|struct
name|blame_chain
block|{
name|struct
name|blame
modifier|*
name|blame
decl_stmt|;
comment|/* linked list of blame chunks */
name|struct
name|blame
modifier|*
name|avail
decl_stmt|;
comment|/* linked list of free blame chunks */
name|struct
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Allocate members from this pool. */
block|}
struct|;
end_struct

begin_comment
comment|/* The baton use for the diff output routine. */
end_comment

begin_struct
struct|struct
name|diff_baton
block|{
name|struct
name|blame_chain
modifier|*
name|chain
decl_stmt|;
specifier|const
name|struct
name|rev
modifier|*
name|rev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The baton used for a file revision. Lives the entire operation */
end_comment

begin_struct
struct|struct
name|file_rev_baton
block|{
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|;
name|svn_boolean_t
name|backwards
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|svn_diff_file_options_t
modifier|*
name|diff_options
decl_stmt|;
comment|/* name of file containing the previous revision of the file */
specifier|const
name|char
modifier|*
name|last_filename
decl_stmt|;
name|struct
name|rev
modifier|*
name|last_rev
decl_stmt|;
comment|/* the rev of the last modification */
name|struct
name|blame_chain
modifier|*
name|chain
decl_stmt|;
comment|/* the original blame chain. */
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
comment|/* To construct a url */
name|apr_pool_t
modifier|*
name|mainpool
decl_stmt|;
comment|/* lives during the whole sequence of calls */
name|apr_pool_t
modifier|*
name|lastpool
decl_stmt|;
comment|/* pool used during previous call */
name|apr_pool_t
modifier|*
name|currpool
decl_stmt|;
comment|/* pool used during this call */
comment|/* These are used for tracking merged revisions. */
name|svn_boolean_t
name|include_merged_revisions
decl_stmt|;
name|struct
name|blame_chain
modifier|*
name|merged_chain
decl_stmt|;
comment|/* the merged blame chain. */
comment|/* name of file containing the previous merged revision of the file */
specifier|const
name|char
modifier|*
name|last_original_filename
decl_stmt|;
comment|/* pools for files which may need to persist for more than one rev. */
name|apr_pool_t
modifier|*
name|filepool
decl_stmt|;
name|apr_pool_t
modifier|*
name|prevfilepool
decl_stmt|;
name|svn_boolean_t
name|check_mime_type
decl_stmt|;
comment|/* When blaming backwards we have to use the changes      on the *next* revision, as the interesting change      happens when we move to the previous revision */
name|svn_revnum_t
name|last_revnum
decl_stmt|;
name|apr_hash_t
modifier|*
name|last_props
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The baton used by the txdelta window handler. Allocated per revision */
end_comment

begin_struct
struct|struct
name|delta_baton
block|{
comment|/* Our underlying handler/baton that we wrap */
name|svn_txdelta_window_handler_t
name|wrapped_handler
decl_stmt|;
name|void
modifier|*
name|wrapped_baton
decl_stmt|;
name|struct
name|file_rev_baton
modifier|*
name|file_rev_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|;
comment|/* the delta source */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|svn_boolean_t
name|is_merged_revision
decl_stmt|;
name|struct
name|rev
modifier|*
name|rev
decl_stmt|;
comment|/* the rev struct for the current revision */
block|}
struct|;
end_struct

begin_comment
comment|/* Return a blame chunk associated with REV for a change starting    at token START, and allocated in CHAIN->mainpool. */
end_comment

begin_function
specifier|static
name|struct
name|blame
modifier|*
name|blame_create
parameter_list|(
name|struct
name|blame_chain
modifier|*
name|chain
parameter_list|,
specifier|const
name|struct
name|rev
modifier|*
name|rev
parameter_list|,
name|apr_off_t
name|start
parameter_list|)
block|{
name|struct
name|blame
modifier|*
name|blame
decl_stmt|;
if|if
condition|(
name|chain
operator|->
name|avail
condition|)
block|{
name|blame
operator|=
name|chain
operator|->
name|avail
expr_stmt|;
name|chain
operator|->
name|avail
operator|=
name|blame
operator|->
name|next
expr_stmt|;
block|}
else|else
name|blame
operator|=
name|apr_palloc
argument_list|(
name|chain
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|blame
argument_list|)
argument_list|)
expr_stmt|;
name|blame
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
name|blame
operator|->
name|start
operator|=
name|start
expr_stmt|;
name|blame
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|blame
return|;
block|}
end_function

begin_comment
comment|/* Destroy a blame chunk. */
end_comment

begin_function
specifier|static
name|void
name|blame_destroy
parameter_list|(
name|struct
name|blame_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|blame
modifier|*
name|blame
parameter_list|)
block|{
name|blame
operator|->
name|next
operator|=
name|chain
operator|->
name|avail
expr_stmt|;
name|chain
operator|->
name|avail
operator|=
name|blame
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the blame chunk that contains token OFF, starting the search at    BLAME. */
end_comment

begin_function
specifier|static
name|struct
name|blame
modifier|*
name|blame_find
parameter_list|(
name|struct
name|blame
modifier|*
name|blame
parameter_list|,
name|apr_off_t
name|off
parameter_list|)
block|{
name|struct
name|blame
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
while|while
condition|(
name|blame
condition|)
block|{
if|if
condition|(
name|blame
operator|->
name|start
operator|>
name|off
condition|)
break|break;
name|prev
operator|=
name|blame
expr_stmt|;
name|blame
operator|=
name|blame
operator|->
name|next
expr_stmt|;
block|}
return|return
name|prev
return|;
block|}
end_function

begin_comment
comment|/* Shift the start-point of BLAME and all subsequence blame-chunks    by ADJUST tokens */
end_comment

begin_function
specifier|static
name|void
name|blame_adjust
parameter_list|(
name|struct
name|blame
modifier|*
name|blame
parameter_list|,
name|apr_off_t
name|adjust
parameter_list|)
block|{
while|while
condition|(
name|blame
condition|)
block|{
name|blame
operator|->
name|start
operator|+=
name|adjust
expr_stmt|;
name|blame
operator|=
name|blame
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Delete the blame associated with the region from token START to    START + LENGTH */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|blame_delete_range
parameter_list|(
name|struct
name|blame_chain
modifier|*
name|chain
parameter_list|,
name|apr_off_t
name|start
parameter_list|,
name|apr_off_t
name|length
parameter_list|)
block|{
name|struct
name|blame
modifier|*
name|first
init|=
name|blame_find
argument_list|(
name|chain
operator|->
name|blame
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|struct
name|blame
modifier|*
name|last
init|=
name|blame_find
argument_list|(
name|chain
operator|->
name|blame
argument_list|,
name|start
operator|+
name|length
argument_list|)
decl_stmt|;
name|struct
name|blame
modifier|*
name|tail
init|=
name|last
operator|->
name|next
decl_stmt|;
if|if
condition|(
name|first
operator|!=
name|last
condition|)
block|{
name|struct
name|blame
modifier|*
name|walk
init|=
name|first
operator|->
name|next
decl_stmt|;
while|while
condition|(
name|walk
operator|!=
name|last
condition|)
block|{
name|struct
name|blame
modifier|*
name|next
init|=
name|walk
operator|->
name|next
decl_stmt|;
name|blame_destroy
argument_list|(
name|chain
argument_list|,
name|walk
argument_list|)
expr_stmt|;
name|walk
operator|=
name|next
expr_stmt|;
block|}
name|first
operator|->
name|next
operator|=
name|last
expr_stmt|;
name|last
operator|->
name|start
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|first
operator|->
name|start
operator|==
name|start
condition|)
block|{
operator|*
name|first
operator|=
operator|*
name|last
expr_stmt|;
name|blame_destroy
argument_list|(
name|chain
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|last
operator|=
name|first
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tail
operator|&&
name|tail
operator|->
name|start
operator|==
name|last
operator|->
name|start
operator|+
name|length
condition|)
block|{
operator|*
name|last
operator|=
operator|*
name|tail
expr_stmt|;
name|blame_destroy
argument_list|(
name|chain
argument_list|,
name|tail
argument_list|)
expr_stmt|;
name|tail
operator|=
name|last
operator|->
name|next
expr_stmt|;
block|}
name|blame_adjust
argument_list|(
name|tail
argument_list|,
operator|-
name|length
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Insert a chunk of blame associated with REV starting    at token START and continuing for LENGTH tokens */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|blame_insert_range
parameter_list|(
name|struct
name|blame_chain
modifier|*
name|chain
parameter_list|,
specifier|const
name|struct
name|rev
modifier|*
name|rev
parameter_list|,
name|apr_off_t
name|start
parameter_list|,
name|apr_off_t
name|length
parameter_list|)
block|{
name|struct
name|blame
modifier|*
name|head
init|=
name|chain
operator|->
name|blame
decl_stmt|;
name|struct
name|blame
modifier|*
name|point
init|=
name|blame_find
argument_list|(
name|head
argument_list|,
name|start
argument_list|)
decl_stmt|;
name|struct
name|blame
modifier|*
name|insert
decl_stmt|;
if|if
condition|(
name|point
operator|->
name|start
operator|==
name|start
condition|)
block|{
name|insert
operator|=
name|blame_create
argument_list|(
name|chain
argument_list|,
name|point
operator|->
name|rev
argument_list|,
name|point
operator|->
name|start
operator|+
name|length
argument_list|)
expr_stmt|;
name|point
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
name|insert
operator|->
name|next
operator|=
name|point
operator|->
name|next
expr_stmt|;
name|point
operator|->
name|next
operator|=
name|insert
expr_stmt|;
block|}
else|else
block|{
name|struct
name|blame
modifier|*
name|middle
decl_stmt|;
name|middle
operator|=
name|blame_create
argument_list|(
name|chain
argument_list|,
name|rev
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|insert
operator|=
name|blame_create
argument_list|(
name|chain
argument_list|,
name|point
operator|->
name|rev
argument_list|,
name|start
operator|+
name|length
argument_list|)
expr_stmt|;
name|middle
operator|->
name|next
operator|=
name|insert
expr_stmt|;
name|insert
operator|->
name|next
operator|=
name|point
operator|->
name|next
expr_stmt|;
name|point
operator|->
name|next
operator|=
name|middle
expr_stmt|;
block|}
name|blame_adjust
argument_list|(
name|insert
operator|->
name|next
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback for diff between subsequent revisions */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_diff_modified
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_off_t
name|original_start
parameter_list|,
name|apr_off_t
name|original_length
parameter_list|,
name|apr_off_t
name|modified_start
parameter_list|,
name|apr_off_t
name|modified_length
parameter_list|,
name|apr_off_t
name|latest_start
parameter_list|,
name|apr_off_t
name|latest_length
parameter_list|)
block|{
name|struct
name|diff_baton
modifier|*
name|db
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|original_length
condition|)
name|SVN_ERR
argument_list|(
name|blame_delete_range
argument_list|(
name|db
operator|->
name|chain
argument_list|,
name|modified_start
argument_list|,
name|original_length
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|modified_length
condition|)
name|SVN_ERR
argument_list|(
name|blame_insert_range
argument_list|(
name|db
operator|->
name|chain
argument_list|,
name|db
operator|->
name|rev
argument_list|,
name|modified_start
argument_list|,
name|modified_length
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_diff_output_fns_t
name|output_fns
init|=
block|{
name|NULL
block|,
name|output_diff_modified
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Add the blame for the diffs between LAST_FILE and CUR_FILE to CHAIN,    for revision REV.  LAST_FILE may be NULL in which    case blame is added for every line of CUR_FILE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_blame
parameter_list|(
specifier|const
name|char
modifier|*
name|last_file
parameter_list|,
specifier|const
name|char
modifier|*
name|cur_file
parameter_list|,
name|struct
name|blame_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|rev
modifier|*
name|rev
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|diff_options
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|last_file
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|chain
operator|->
name|blame
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|chain
operator|->
name|blame
operator|=
name|blame_create
argument_list|(
name|chain
argument_list|,
name|rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|struct
name|diff_baton
name|diff_baton
decl_stmt|;
name|diff_baton
operator|.
name|chain
operator|=
name|chain
expr_stmt|;
name|diff_baton
operator|.
name|rev
operator|=
name|rev
expr_stmt|;
comment|/* We have a previous file.  Get the diff and adjust blame info. */
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff_2
argument_list|(
operator|&
name|diff
argument_list|,
name|last_file
argument_list|,
name|cur_file
argument_list|,
name|diff_options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_output2
argument_list|(
name|diff
argument_list|,
operator|&
name|diff_baton
argument_list|,
operator|&
name|output_fns
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Record the blame information for the revision in BATON->file_rev_baton.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_blame
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|delta_baton
modifier|*
name|dbaton
init|=
name|baton
decl_stmt|;
name|struct
name|file_rev_baton
modifier|*
name|frb
init|=
name|dbaton
operator|->
name|file_rev_baton
decl_stmt|;
name|struct
name|blame_chain
modifier|*
name|chain
decl_stmt|;
comment|/* Close the source file used for the delta.      It is important to do this early, since otherwise, they will be deleted      before all handles are closed, which leads to failures on some platforms      when new tempfiles are to be created. */
if|if
condition|(
name|dbaton
operator|->
name|source_stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|dbaton
operator|->
name|source_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are including merged revisions, we need to add each rev to the      merged chain. */
if|if
condition|(
name|frb
operator|->
name|include_merged_revisions
condition|)
name|chain
operator|=
name|frb
operator|->
name|merged_chain
expr_stmt|;
else|else
name|chain
operator|=
name|frb
operator|->
name|chain
expr_stmt|;
comment|/* Process this file. */
name|SVN_ERR
argument_list|(
name|add_file_blame
argument_list|(
name|frb
operator|->
name|last_filename
argument_list|,
name|dbaton
operator|->
name|filename
argument_list|,
name|chain
argument_list|,
name|dbaton
operator|->
name|rev
argument_list|,
name|frb
operator|->
name|diff_options
argument_list|,
name|frb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|frb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|frb
operator|->
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are including merged revisions, and the current revision is not a      merged one, we need to add its blame info to the chain for the original      line of history. */
if|if
condition|(
name|frb
operator|->
name|include_merged_revisions
operator|&&
operator|!
name|dbaton
operator|->
name|is_merged_revision
condition|)
block|{
name|apr_pool_t
modifier|*
name|tmppool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|add_file_blame
argument_list|(
name|frb
operator|->
name|last_original_filename
argument_list|,
name|dbaton
operator|->
name|filename
argument_list|,
name|frb
operator|->
name|chain
argument_list|,
name|dbaton
operator|->
name|rev
argument_list|,
name|frb
operator|->
name|diff_options
argument_list|,
name|frb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|frb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|frb
operator|->
name|currpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This filename could be around for a while, potentially, so          use the longer lifetime pool, and switch it with the previous one*/
name|svn_pool_clear
argument_list|(
name|frb
operator|->
name|prevfilepool
argument_list|)
expr_stmt|;
name|tmppool
operator|=
name|frb
operator|->
name|filepool
expr_stmt|;
name|frb
operator|->
name|filepool
operator|=
name|frb
operator|->
name|prevfilepool
expr_stmt|;
name|frb
operator|->
name|prevfilepool
operator|=
name|tmppool
expr_stmt|;
name|frb
operator|->
name|last_original_filename
operator|=
name|apr_pstrdup
argument_list|(
name|frb
operator|->
name|filepool
argument_list|,
name|dbaton
operator|->
name|filename
argument_list|)
expr_stmt|;
block|}
comment|/* Prepare for next revision. */
comment|/* Remember the file name so we can diff it with the next revision. */
name|frb
operator|->
name|last_filename
operator|=
name|dbaton
operator|->
name|filename
expr_stmt|;
comment|/* Switch pools. */
block|{
name|apr_pool_t
modifier|*
name|tmp_pool
init|=
name|frb
operator|->
name|lastpool
decl_stmt|;
name|frb
operator|->
name|lastpool
operator|=
name|frb
operator|->
name|currpool
expr_stmt|;
name|frb
operator|->
name|currpool
operator|=
name|tmp_pool
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The delta window handler for the text delta between the previously seen  * revision and the revision currently being handled.  *  * Record the blame information for this revision in BATON->file_rev_baton.  *  * Implements svn_txdelta_window_handler_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|delta_baton
modifier|*
name|dbaton
init|=
name|baton
decl_stmt|;
comment|/* Call the wrapped handler first. */
if|if
condition|(
name|dbaton
operator|->
name|wrapped_handler
condition|)
name|SVN_ERR
argument_list|(
name|dbaton
operator|->
name|wrapped_handler
argument_list|(
name|window
argument_list|,
name|dbaton
operator|->
name|wrapped_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We patiently wait for the NULL window marking the end. */
if|if
condition|(
name|window
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Diff and update blame info. */
name|SVN_ERR
argument_list|(
name|update_blame
argument_list|(
name|baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Calculate and record blame information for one revision of the file,  * by comparing the file content against the previously seen revision.  *  * This handler is called once for each interesting revision of the file.  *  * Record the blame information for this revision in (file_rev_baton) BATON.  *  * Implements svn_file_rev_handler_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_rev_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revnum
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|svn_boolean_t
name|merged_revision
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|content_delta_handler
parameter_list|,
name|void
modifier|*
modifier|*
name|content_delta_baton
parameter_list|,
name|apr_array_header_t
modifier|*
name|prop_diffs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_rev_baton
modifier|*
name|frb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|last_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|cur_stream
decl_stmt|;
name|struct
name|delta_baton
modifier|*
name|delta_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|filepool
decl_stmt|;
comment|/* Clear the current pool. */
name|svn_pool_clear
argument_list|(
name|frb
operator|->
name|currpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|frb
operator|->
name|check_mime_type
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
init|=
name|svn_prop_array_to_hash
argument_list|(
name|prop_diffs
argument_list|,
name|frb
operator|->
name|currpool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
name|frb
operator|->
name|check_mime_type
operator|=
name|FALSE
expr_stmt|;
comment|/* Only check first */
name|value
operator|=
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|&&
name|svn_mime_type_is_binary
argument_list|(
name|value
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_IS_BINARY_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot calculate blame information for binary file '%s'"
argument_list|)
argument_list|,
operator|(
name|svn_path_is_url
argument_list|(
name|frb
operator|->
name|target
argument_list|)
condition|?
name|frb
operator|->
name|target
else|:
name|svn_dirent_local_style
argument_list|(
name|frb
operator|->
name|target
argument_list|,
name|pool
argument_list|)
operator|)
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|frb
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify_url
argument_list|(
name|svn_path_url_add_component2
argument_list|(
name|frb
operator|->
name|repos_root_url
argument_list|,
name|path
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_wc_notify_blame_revision
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_none
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
name|revnum
expr_stmt|;
name|notify
operator|->
name|rev_props
operator|=
name|rev_props
expr_stmt|;
name|frb
operator|->
name|ctx
operator|->
name|notify_func2
argument_list|(
name|frb
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|frb
operator|->
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|frb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|(
name|frb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there were no content changes and no (potential) merges, we couldn't      care less about this revision now.  Note that we checked the mime type      above, so things work if the user just changes the mime type in a commit.      Also note that we don't switch the pools in this case.  This is important,      since the tempfile will be removed by the pool and we need the tempfile      from the last revision with content changes. */
if|if
condition|(
operator|!
name|content_delta_handler
operator|&&
operator|(
operator|!
name|frb
operator|->
name|include_merged_revisions
operator|||
name|merged_revision
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Create delta baton. */
name|delta_baton
operator|=
name|apr_pcalloc
argument_list|(
name|frb
operator|->
name|currpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|delta_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare the text delta window handler. */
if|if
condition|(
name|frb
operator|->
name|last_filename
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|delta_baton
operator|->
name|source_stream
argument_list|,
name|frb
operator|->
name|last_filename
argument_list|,
name|frb
operator|->
name|currpool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Means empty stream below. */
name|delta_baton
operator|->
name|source_stream
operator|=
name|NULL
expr_stmt|;
name|last_stream
operator|=
name|svn_stream_disown
argument_list|(
name|delta_baton
operator|->
name|source_stream
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|frb
operator|->
name|include_merged_revisions
operator|&&
operator|!
name|merged_revision
condition|)
name|filepool
operator|=
name|frb
operator|->
name|filepool
expr_stmt|;
else|else
name|filepool
operator|=
name|frb
operator|->
name|currpool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|cur_stream
argument_list|,
operator|&
name|delta_baton
operator|->
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|filepool
argument_list|,
name|filepool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Wrap the window handler with our own. */
name|delta_baton
operator|->
name|file_rev_baton
operator|=
name|frb
expr_stmt|;
name|delta_baton
operator|->
name|is_merged_revision
operator|=
name|merged_revision
expr_stmt|;
comment|/* Create the rev structure. */
name|delta_baton
operator|->
name|rev
operator|=
name|apr_pcalloc
argument_list|(
name|frb
operator|->
name|mainpool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|frb
operator|->
name|backwards
condition|)
block|{
comment|/* Use from last round...          SVN_INVALID_REVNUM on first, which is exactly          what we want */
name|delta_baton
operator|->
name|rev
operator|->
name|revision
operator|=
name|frb
operator|->
name|last_revnum
expr_stmt|;
name|delta_baton
operator|->
name|rev
operator|->
name|rev_props
operator|=
name|frb
operator|->
name|last_props
expr_stmt|;
comment|/* Store for next delta */
if|if
condition|(
name|revnum
operator|>=
name|MIN
argument_list|(
name|frb
operator|->
name|start_rev
argument_list|,
name|frb
operator|->
name|end_rev
argument_list|)
condition|)
block|{
name|frb
operator|->
name|last_revnum
operator|=
name|revnum
expr_stmt|;
name|frb
operator|->
name|last_props
operator|=
name|svn_prop_hash_dup
argument_list|(
name|rev_props
argument_list|,
name|frb
operator|->
name|mainpool
argument_list|)
expr_stmt|;
block|}
comment|/* Else: Not needed on last rev */
block|}
elseif|else
if|if
condition|(
name|merged_revision
operator|||
operator|(
name|revnum
operator|>=
name|MIN
argument_list|(
name|frb
operator|->
name|start_rev
argument_list|,
name|frb
operator|->
name|end_rev
argument_list|)
operator|)
condition|)
block|{
comment|/* 1+ for the "youngest to oldest" blame */
name|SVN_ERR_ASSERT
argument_list|(
name|revnum
operator|<=
literal|1
operator|+
name|MAX
argument_list|(
name|frb
operator|->
name|end_rev
argument_list|,
name|frb
operator|->
name|start_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set values from revision props. */
name|delta_baton
operator|->
name|rev
operator|->
name|revision
operator|=
name|revnum
expr_stmt|;
name|delta_baton
operator|->
name|rev
operator|->
name|rev_props
operator|=
name|svn_prop_hash_dup
argument_list|(
name|rev_props
argument_list|,
name|frb
operator|->
name|mainpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We shouldn't get more than one revision outside the          specified range (unless we alsoe receive merged revisions) */
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|frb
operator|->
name|last_filename
operator|==
name|NULL
operator|)
operator|||
name|frb
operator|->
name|include_merged_revisions
argument_list|)
expr_stmt|;
comment|/* The file existed before start_rev; generate no blame info for          lines from this revision (or before).            This revision specifies the state as it was at the start revision */
name|delta_baton
operator|->
name|rev
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
if|if
condition|(
name|frb
operator|->
name|include_merged_revisions
condition|)
name|delta_baton
operator|->
name|rev
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|frb
operator|->
name|mainpool
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Keep last revision for postprocessing after all changes */
name|frb
operator|->
name|last_rev
operator|=
name|delta_baton
operator|->
name|rev
expr_stmt|;
comment|/* Handle all delta - even if it is empty.      We must do the latter to "merge" blame info from other branches. */
if|if
condition|(
name|content_delta_handler
condition|)
block|{
comment|/* Proper delta - get window handler for applying delta.          svn_ra_get_file_revs2 will drive the delta editor. */
name|svn_txdelta_apply
argument_list|(
name|last_stream
argument_list|,
name|cur_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|frb
operator|->
name|currpool
argument_list|,
operator|&
name|delta_baton
operator|->
name|wrapped_handler
argument_list|,
operator|&
name|delta_baton
operator|->
name|wrapped_baton
argument_list|)
expr_stmt|;
operator|*
name|content_delta_handler
operator|=
name|window_handler
expr_stmt|;
operator|*
name|content_delta_baton
operator|=
name|delta_baton
expr_stmt|;
block|}
else|else
block|{
comment|/* Apply an empty delta, i.e. simply copy the old contents.          We can't simply use the existing file due to the pool rotation logic.          Trigger the blame update magic. */
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|last_stream
argument_list|,
name|cur_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_blame
argument_list|(
name|delta_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Ensure that CHAIN_ORIG and CHAIN_MERGED have the same number of chunks,    and that for every chunk C, CHAIN_ORIG[C] and CHAIN_MERGED[C] have the    same starting value.  Both CHAIN_ORIG and CHAIN_MERGED should not be    NULL.  */
end_comment

begin_function
specifier|static
name|void
name|normalize_blames
parameter_list|(
name|struct
name|blame_chain
modifier|*
name|chain
parameter_list|,
name|struct
name|blame_chain
modifier|*
name|chain_merged
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|blame
modifier|*
name|walk
decl_stmt|,
modifier|*
name|walk_merged
decl_stmt|;
comment|/* Walk over the CHAIN's blame chunks and CHAIN_MERGED's blame chunks,      creating new chunks as needed. */
for|for
control|(
name|walk
operator|=
name|chain
operator|->
name|blame
operator|,
name|walk_merged
operator|=
name|chain_merged
operator|->
name|blame
init|;
name|walk
operator|->
name|next
operator|&&
name|walk_merged
operator|->
name|next
condition|;
name|walk
operator|=
name|walk
operator|->
name|next
operator|,
name|walk_merged
operator|=
name|walk_merged
operator|->
name|next
control|)
block|{
comment|/* The current chunks should always be starting at the same offset. */
name|assert
argument_list|(
name|walk
operator|->
name|start
operator|==
name|walk_merged
operator|->
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|walk
operator|->
name|next
operator|->
name|start
operator|<
name|walk_merged
operator|->
name|next
operator|->
name|start
condition|)
block|{
comment|/* insert a new chunk in CHAIN_MERGED. */
name|struct
name|blame
modifier|*
name|tmp
init|=
name|blame_create
argument_list|(
name|chain_merged
argument_list|,
name|walk_merged
operator|->
name|rev
argument_list|,
name|walk
operator|->
name|next
operator|->
name|start
argument_list|)
decl_stmt|;
name|tmp
operator|->
name|next
operator|=
name|walk_merged
operator|->
name|next
expr_stmt|;
name|walk_merged
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|walk
operator|->
name|next
operator|->
name|start
operator|>
name|walk_merged
operator|->
name|next
operator|->
name|start
condition|)
block|{
comment|/* insert a new chunk in CHAIN. */
name|struct
name|blame
modifier|*
name|tmp
init|=
name|blame_create
argument_list|(
name|chain
argument_list|,
name|walk
operator|->
name|rev
argument_list|,
name|walk_merged
operator|->
name|next
operator|->
name|start
argument_list|)
decl_stmt|;
name|tmp
operator|->
name|next
operator|=
name|walk
operator|->
name|next
expr_stmt|;
name|walk
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
block|}
block|}
comment|/* If both NEXT pointers are null, the lists are equally long, otherwise      we need to extend one of them.  If CHAIN is longer, append new chunks      to CHAIN_MERGED until its length matches that of CHAIN. */
while|while
condition|(
name|walk
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|struct
name|blame
modifier|*
name|tmp
init|=
name|blame_create
argument_list|(
name|chain_merged
argument_list|,
name|walk_merged
operator|->
name|rev
argument_list|,
name|walk
operator|->
name|next
operator|->
name|start
argument_list|)
decl_stmt|;
name|walk_merged
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|walk_merged
operator|=
name|walk_merged
operator|->
name|next
expr_stmt|;
name|walk
operator|=
name|walk
operator|->
name|next
expr_stmt|;
block|}
comment|/* Same as above, only extend CHAIN to match CHAIN_MERGED. */
while|while
condition|(
name|walk_merged
operator|->
name|next
operator|!=
name|NULL
condition|)
block|{
name|struct
name|blame
modifier|*
name|tmp
init|=
name|blame_create
argument_list|(
name|chain
argument_list|,
name|walk
operator|->
name|rev
argument_list|,
name|walk_merged
operator|->
name|next
operator|->
name|start
argument_list|)
decl_stmt|;
name|walk
operator|->
name|next
operator|=
name|tmp
expr_stmt|;
name|walk
operator|=
name|walk
operator|->
name|next
expr_stmt|;
name|walk_merged
operator|=
name|walk_merged
operator|->
name|next
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_blame5
parameter_list|(
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|start
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|end
parameter_list|,
specifier|const
name|svn_diff_file_options_t
modifier|*
name|diff_options
parameter_list|,
name|svn_boolean_t
name|ignore_mime_type
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_client_blame_receiver3_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_rev_baton
name|frb
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_revnum_t
name|start_revnum
decl_stmt|,
name|end_revnum
decl_stmt|;
name|struct
name|blame
modifier|*
name|walk
decl_stmt|,
modifier|*
name|walk_merged
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_stream_t
modifier|*
name|last_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath_or_url
decl_stmt|;
if|if
condition|(
name|start
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|||
name|end
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|)
name|target_abspath_or_url
operator|=
name|target
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|target_abspath_or_url
argument_list|,
name|target
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get an RA plugin for this filesystem object. */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|peg_revision
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|start_revnum
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath_or_url
argument_list|,
name|ra_session
argument_list|,
name|start
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|end_revnum
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath_or_url
argument_list|,
name|ra_session
argument_list|,
name|end
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|svn_client__pathrev_t
modifier|*
name|loc
decl_stmt|;
name|svn_opt_revision_t
name|younger_end
decl_stmt|;
name|younger_end
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|younger_end
operator|.
name|value
operator|.
name|number
operator|=
name|MAX
argument_list|(
name|start_revnum
argument_list|,
name|end_revnum
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_rev_and_url
argument_list|(
operator|&
name|loc
argument_list|,
name|ra_session
argument_list|,
name|target
argument_list|,
name|peg_revision
argument_list|,
operator|&
name|younger_end
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the session point to the real URL. */
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|loc
operator|->
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We check the mime-type of the yougest revision before getting all      the older revisions. */
if|if
condition|(
operator|!
name|ignore_mime_type
operator|&&
name|start_revnum
operator|<
name|end_revnum
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|mime_type
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
operator|||
name|start_revnum
operator|>
name|end_revnum
operator|||
operator|(
name|end
operator|->
name|kind
operator|!=
name|svn_opt_revision_working
operator|&&
name|end
operator|->
name|kind
operator|!=
name|svn_opt_revision_base
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|end_revnum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|mime_type
operator|=
name|svn_prop_get_value
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
if|if
condition|(
name|end
operator|->
name|kind
operator|==
name|svn_opt_revision_working
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_prop_get2
argument_list|(
operator|&
name|value
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath_or_url
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_get_pristine_props
argument_list|(
operator|&
name|props
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath_or_url
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|props
condition|?
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
else|:
name|NULL
expr_stmt|;
block|}
name|mime_type
operator|=
name|value
condition|?
name|value
operator|->
name|data
else|:
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mime_type
condition|)
block|{
if|if
condition|(
name|svn_mime_type_is_binary
argument_list|(
name|mime_type
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_IS_BINARY_FILE
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Cannot calculate blame information for binary file '%s'"
argument_list|)
argument_list|,
operator|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|?
name|target
else|:
name|svn_dirent_local_style
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
operator|)
argument_list|)
return|;
block|}
block|}
name|frb
operator|.
name|start_rev
operator|=
name|start_revnum
expr_stmt|;
name|frb
operator|.
name|end_rev
operator|=
name|end_revnum
expr_stmt|;
name|frb
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|frb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|frb
operator|.
name|diff_options
operator|=
name|diff_options
expr_stmt|;
name|frb
operator|.
name|include_merged_revisions
operator|=
name|include_merged_revisions
expr_stmt|;
name|frb
operator|.
name|last_filename
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|last_rev
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|last_original_filename
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|chain
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frb
operator|.
name|chain
argument_list|)
argument_list|)
expr_stmt|;
name|frb
operator|.
name|chain
operator|->
name|blame
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|chain
operator|->
name|avail
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|chain
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|include_merged_revisions
condition|)
block|{
name|frb
operator|.
name|merged_chain
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|frb
operator|.
name|merged_chain
argument_list|)
argument_list|)
expr_stmt|;
name|frb
operator|.
name|merged_chain
operator|->
name|blame
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|merged_chain
operator|->
name|avail
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|merged_chain
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
block|}
name|frb
operator|.
name|backwards
operator|=
operator|(
name|frb
operator|.
name|start_rev
operator|>
name|frb
operator|.
name|end_rev
operator|)
expr_stmt|;
name|frb
operator|.
name|last_revnum
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|frb
operator|.
name|last_props
operator|=
name|NULL
expr_stmt|;
name|frb
operator|.
name|check_mime_type
operator|=
operator|(
name|frb
operator|.
name|backwards
operator|&&
operator|!
name|ignore_mime_type
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|frb
operator|.
name|repos_root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|frb
operator|.
name|mainpool
operator|=
name|pool
expr_stmt|;
comment|/* The callback will flip the following two pools, because it needs      information from the previous call.  Obviously, it can't rely on      the lifetime of the pool provided by get_file_revs. */
name|frb
operator|.
name|lastpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|frb
operator|.
name|currpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_merged_revisions
condition|)
block|{
name|frb
operator|.
name|filepool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|frb
operator|.
name|prevfilepool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Collect all blame information.      We need to ensure that we get one revision before the start_rev,      if available so that we can know what was actually changed in the start      revision. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_file_revs2
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|frb
operator|.
name|backwards
condition|?
name|start_revnum
else|:
name|MAX
argument_list|(
literal|0
argument_list|,
name|start_revnum
operator|-
literal|1
argument_list|)
argument_list|,
name|end_revnum
argument_list|,
name|include_merged_revisions
argument_list|,
name|file_rev_handler
argument_list|,
operator|&
name|frb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|->
name|kind
operator|==
name|svn_opt_revision_working
condition|)
block|{
comment|/* If the local file is modified we have to call the handler on the          working copy file with keywords unexpanded */
name|svn_wc_status3_t
modifier|*
name|status
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_status3
argument_list|(
operator|&
name|status
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath_or_url
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|text_status
operator|!=
name|svn_wc_status_normal
operator|||
operator|(
name|status
operator|->
name|prop_status
operator|!=
name|svn_wc_status_normal
operator|&&
name|status
operator|->
name|prop_status
operator|!=
name|svn_wc_status_none
operator|)
condition|)
block|{
name|svn_stream_t
modifier|*
name|wcfile
decl_stmt|;
name|svn_stream_t
modifier|*
name|tempfile
decl_stmt|;
name|svn_opt_revision_t
name|rev
decl_stmt|;
name|svn_boolean_t
name|normalize_eols
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|temppath
decl_stmt|;
if|if
condition|(
name|status
operator|->
name|prop_status
operator|!=
name|svn_wc_status_none
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|eol_style
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_prop_get2
argument_list|(
operator|&
name|eol_style
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath_or_url
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_style
condition|)
block|{
name|svn_subst_eol_style_t
name|style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
name|svn_subst_eol_style_from_value
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
name|eol_style
operator|->
name|data
argument_list|)
expr_stmt|;
name|normalize_eols
operator|=
operator|(
name|style
operator|==
name|svn_subst_eol_style_native
operator|)
expr_stmt|;
block|}
block|}
name|rev
operator|.
name|kind
operator|=
name|svn_opt_revision_working
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_normalized_stream
argument_list|(
operator|&
name|wcfile
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath_or_url
argument_list|,
operator|&
name|rev
argument_list|,
name|FALSE
argument_list|,
name|normalize_eols
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tempfile
argument_list|,
operator|&
name|temppath
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|wcfile
argument_list|,
name|tempfile
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_file_blame
argument_list|(
name|frb
operator|.
name|last_filename
argument_list|,
name|temppath
argument_list|,
name|frb
operator|.
name|chain
argument_list|,
name|NULL
argument_list|,
name|frb
operator|.
name|diff_options
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|frb
operator|.
name|last_filename
operator|=
name|temppath
expr_stmt|;
block|}
block|}
comment|/* Report the blame to the caller. */
comment|/* The callback has to have been called at least once. */
name|SVN_ERR_ASSERT
argument_list|(
name|frb
operator|.
name|last_filename
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Create a pool for the iteration below. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Open the last file and get a stream. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|last_stream
argument_list|,
name|frb
operator|.
name|last_filename
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|last_stream
argument_list|,
literal|"\n"
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Perform optional merged chain normalization. */
if|if
condition|(
name|include_merged_revisions
condition|)
block|{
comment|/* If we never created any blame for the original chain, create it now,          with the most recent changed revision.  This could occur if a file          was created on a branch and them merged to another branch.  This is          semanticly a copy, and we want to use the revision on the branch as          the most recently changed revision.  ### Is this really what we want          to do here?  Do the sematics of copy change? */
if|if
condition|(
operator|!
name|frb
operator|.
name|chain
operator|->
name|blame
condition|)
name|frb
operator|.
name|chain
operator|->
name|blame
operator|=
name|blame_create
argument_list|(
name|frb
operator|.
name|chain
argument_list|,
name|frb
operator|.
name|last_rev
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|normalize_blames
argument_list|(
name|frb
operator|.
name|chain
argument_list|,
name|frb
operator|.
name|merged_chain
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|walk_merged
operator|=
name|frb
operator|.
name|merged_chain
operator|->
name|blame
expr_stmt|;
block|}
comment|/* Process each blame item. */
for|for
control|(
name|walk
operator|=
name|frb
operator|.
name|chain
operator|->
name|blame
init|;
name|walk
condition|;
name|walk
operator|=
name|walk
operator|->
name|next
control|)
block|{
name|apr_off_t
name|line_no
decl_stmt|;
name|svn_revnum_t
name|merged_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|merged_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|merged_rev_props
decl_stmt|;
if|if
condition|(
name|walk_merged
condition|)
block|{
name|merged_rev
operator|=
name|walk_merged
operator|->
name|rev
operator|->
name|revision
expr_stmt|;
name|merged_rev_props
operator|=
name|walk_merged
operator|->
name|rev
operator|->
name|rev_props
expr_stmt|;
name|merged_path
operator|=
name|walk_merged
operator|->
name|rev
operator|->
name|path
expr_stmt|;
block|}
else|else
block|{
name|merged_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|merged_rev_props
operator|=
name|NULL
expr_stmt|;
name|merged_path
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|line_no
operator|=
name|walk
operator|->
name|start
init|;
operator|!
name|walk
operator|->
name|next
operator|||
name|line_no
operator|<
name|walk
operator|->
name|next
operator|->
name|start
condition|;
operator|++
name|line_no
control|)
block|{
name|svn_boolean_t
name|eof
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|sb
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|sb
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
operator|||
name|sb
operator|->
name|len
condition|)
block|{
if|if
condition|(
name|walk
operator|->
name|rev
condition|)
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|receiver_baton
argument_list|,
name|start_revnum
argument_list|,
name|end_revnum
argument_list|,
name|line_no
argument_list|,
name|walk
operator|->
name|rev
operator|->
name|revision
argument_list|,
name|walk
operator|->
name|rev
operator|->
name|rev_props
argument_list|,
name|merged_rev
argument_list|,
name|merged_rev_props
argument_list|,
name|merged_path
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|receiver_baton
argument_list|,
name|start_revnum
argument_list|,
name|end_revnum
argument_list|,
name|line_no
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eof
condition|)
break|break;
block|}
if|if
condition|(
name|walk_merged
condition|)
name|walk_merged
operator|=
name|walk_merged
operator|->
name|next
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|frb
operator|.
name|lastpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|frb
operator|.
name|currpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|include_merged_revisions
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|frb
operator|.
name|filepool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|frb
operator|.
name|prevfilepool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

