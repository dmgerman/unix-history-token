begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * import.c:  wrappers around import functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_magic.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Import context baton.     ### TODO:  Add the following items to this baton:       /` import editor/baton. `/       const svn_delta_editor_t *editor;       void *edit_baton;        /` Client context baton `/       svn_client_ctx_t `ctx;        /` Paths (keys) excluded from the import (values ignored) `/       apr_hash_t *excludes; */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|import_ctx_t
block|{
comment|/* Whether any changes were made to the repository */
name|svn_boolean_t
name|repos_changed
decl_stmt|;
comment|/* A magic cookie for mime-type detection. */
name|svn_magic__cookie_t
modifier|*
name|magic_cookie
decl_stmt|;
comment|/* Collection of all possible configuration file dictated auto-props and      svn:auto-props.  A hash mapping const char * file patterns to a      second hash which maps const char * property names to const char *      property values.  Properties which don't have a value, e.g.      svn:executable, simply map the property name to an empty string.      May be NULL if autoprops are disabled. */
name|apr_hash_t
modifier|*
name|autoprops
decl_stmt|;
block|}
name|import_ctx_t
typedef|;
end_typedef

begin_comment
comment|/* Apply LOCAL_ABSPATH's contents (as a delta against the empty string) to    FILE_BATON in EDITOR.  Use POOL for any temporary allocation.    PROPERTIES is the set of node properties set on this file.     Fill DIGEST with the md5 checksum of the sent file; DIGEST must be    at least APR_MD5_DIGESTSIZE bytes long. */
end_comment

begin_comment
comment|/* ### how does this compare against svn_wc_transmit_text_deltas2() ??? */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_file_contents
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|apr_hash_t
modifier|*
name|properties
parameter_list|,
name|unsigned
name|char
modifier|*
name|digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|svn_txdelta_window_handler_t
name|handler
decl_stmt|;
name|void
modifier|*
name|handler_baton
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|eol_style_val
init|=
name|NULL
decl_stmt|,
modifier|*
name|keywords_val
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|special
init|=
name|FALSE
decl_stmt|;
name|svn_subst_eol_style_t
name|eol_style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
decl_stmt|;
name|apr_hash_t
modifier|*
name|keywords
decl_stmt|;
comment|/* If there are properties, look for EOL-style and keywords ones. */
if|if
condition|(
name|properties
condition|)
block|{
name|eol_style_val
operator|=
name|apr_hash_get
argument_list|(
name|properties
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|keywords_val
operator|=
name|apr_hash_get
argument_list|(
name|properties
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|,
sizeof|sizeof
argument_list|(
name|SVN_PROP_KEYWORDS
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|properties
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
condition|)
name|special
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Get an editor func that wants to consume the delta stream. */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
operator|&
name|handler
argument_list|,
operator|&
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_style_val
condition|)
name|svn_subst_eol_style_from_value
argument_list|(
operator|&
name|eol_style
argument_list|,
operator|&
name|eol
argument_list|,
name|eol_style_val
operator|->
name|data
argument_list|)
expr_stmt|;
else|else
block|{
name|eol
operator|=
name|NULL
expr_stmt|;
name|eol_style
operator|=
name|svn_subst_eol_style_none
expr_stmt|;
block|}
if|if
condition|(
name|keywords_val
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_build_keywords3
argument_list|(
operator|&
name|keywords
argument_list|,
name|keywords_val
operator|->
name|data
argument_list|,
name|APR_STRINGIFY
argument_list|(
name|SVN_INVALID_REVNUM
argument_list|)
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|keywords
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|special
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_subst_read_specialfile
argument_list|(
operator|&
name|contents
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Open the working copy file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|contents
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have EOL styles or keywords, then detranslate the file. */
if|if
condition|(
name|svn_subst_translation_required
argument_list|(
name|eol_style
argument_list|,
name|eol
argument_list|,
name|keywords
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|eol_style
operator|==
name|svn_subst_eol_style_unknown
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNKNOWN_EOL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s property on '%s' contains "
literal|"unrecognized EOL-style '%s'"
argument_list|)
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|,
name|eol_style_val
operator|->
name|data
argument_list|)
return|;
comment|/* We're importing, so translate files with 'native' eol-style to            * repository-normal form, not to this platform's native EOL. */
if|if
condition|(
name|eol_style
operator|==
name|svn_subst_eol_style_native
condition|)
name|eol
operator|=
name|SVN_SUBST_NATIVE_EOL_STR
expr_stmt|;
comment|/* Wrap the working copy stream with a filter to detranslate it. */
name|contents
operator|=
name|svn_subst_stream_translated
argument_list|(
name|contents
argument_list|,
name|eol
argument_list|,
name|TRUE
comment|/* repair */
argument_list|,
name|keywords
argument_list|,
name|FALSE
comment|/* expand */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Send the file's contents to the delta-window handler. */
return|return
name|svn_error_trace
argument_list|(
name|svn_txdelta_send_stream
argument_list|(
name|contents
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|digest
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Import file PATH as EDIT_PATH in the repository directory indicated  * by DIR_BATON in EDITOR.  *  * Accumulate file paths and their batons in FILES, which must be  * non-null.  (These are used to send postfix textdeltas later).  *  * If CTX->NOTIFY_FUNC is non-null, invoke it with CTX->NOTIFY_BATON  * for each file.  *  * Use POOL for any temporary allocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|import_file
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
parameter_list|,
name|import_ctx_t
modifier|*
name|import_ctx
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|void
modifier|*
name|file_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|mimetype
init|=
name|NULL
decl_stmt|;
name|unsigned
name|char
name|digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|text_checksum
decl_stmt|;
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_path_check_valid
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add the file, using the pool from the FILES hash. */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_file
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember that the repository was modified */
name|import_ctx
operator|->
name|repos_changed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|dirent
operator|->
name|special
condition|)
block|{
comment|/* add automatic properties */
name|SVN_ERR
argument_list|(
name|svn_client__get_paths_auto_props
argument_list|(
operator|&
name|properties
argument_list|,
operator|&
name|mimetype
argument_list|,
name|local_abspath
argument_list|,
name|import_ctx
operator|->
name|magic_cookie
argument_list|,
name|import_ctx
operator|->
name|autoprops
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|properties
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|properties
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|properties
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|pname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|pval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|pname
argument_list|,
name|pval
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_commit_added
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|notify
operator|->
name|mime_type
operator|=
name|mimetype
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If this is a special file, we need to set the svn:special      property and create a temporary detranslated version in order to      send to the server. */
if|if
condition|(
name|dirent
operator|->
name|special
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|properties
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|,
name|svn_string_create
argument_list|(
name|SVN_PROP_BOOLEAN_TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|,
name|svn_hash_gets
argument_list|(
name|properties
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now, transmit the file contents. */
name|SVN_ERR
argument_list|(
name|send_file_contents
argument_list|(
name|local_abspath
argument_list|,
name|file_baton
argument_list|,
name|editor
argument_list|,
name|properties
argument_list|,
name|digest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, close the file. */
name|text_checksum
operator|=
name|svn_checksum_to_cstring
argument_list|(
name|svn_checksum__from_digest_md5
argument_list|(
name|digest
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|text_checksum
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return in CHILDREN a mapping of basenames to dirents for the importable  * children of DIR_ABSPATH.  EXCLUDES is a hash of absolute paths to filter  * out.  IGNORES and GLOBAL_IGNORES, if non-NULL, are lists of basename  * patterns to filter out.  * FILTER_CALLBACK and FILTER_BATON will be called for each absolute path,  * allowing users to further filter the list of returned entries.  *  * Results are returned in RESULT_POOL; use SCRATCH_POOL for temporary data.*/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_filtered_children
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|children
parameter_list|,
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|excludes
parameter_list|,
name|apr_array_header_t
modifier|*
name|ignores
parameter_list|,
name|apr_array_header_t
modifier|*
name|global_ignores
parameter_list|,
name|svn_client_import_filter_func_t
name|filter_callback
parameter_list|,
name|void
modifier|*
name|filter_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_get_dirents3
argument_list|(
operator|&
name|dirents
argument_list|,
name|dir_abspath
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|base_name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|base_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|base_name
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
comment|/* If someone's trying to import a directory named the same              as our administrative directories, that's probably not              what they wanted to do.  If they are importing a file              with that name, something is bound to blow up when they              checkout what they've imported.  So, just skip items with              that name.  */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|svn_dirent_join
argument_list|(
name|local_abspath
argument_list|,
name|base_name
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|svn_wc_notify_skip
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|dirents
argument_list|,
name|base_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* If this is an excluded path, exclude it. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|excludes
argument_list|,
name|local_abspath
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|dirents
argument_list|,
name|base_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ignores
operator|&&
name|svn_wc_match_ignore_list
argument_list|(
name|base_name
argument_list|,
name|ignores
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|dirents
argument_list|,
name|base_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|global_ignores
operator|&&
name|svn_wc_match_ignore_list
argument_list|(
name|base_name
argument_list|,
name|global_ignores
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|dirents
argument_list|,
name|base_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|filter_callback
condition|)
block|{
name|svn_boolean_t
name|filter
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|filter_callback
argument_list|(
name|filter_baton
argument_list|,
operator|&
name|filter
argument_list|,
name|local_abspath
argument_list|,
name|dirent
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filter
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|dirents
argument_list|,
name|base_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|children
operator|=
name|dirents
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|import_dir
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_hash_t
modifier|*
name|excludes
parameter_list|,
name|apr_array_header_t
modifier|*
name|global_ignores
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_boolean_t
name|ignore_unknown_node_types
parameter_list|,
name|svn_client_import_filter_func_t
name|filter_callback
parameter_list|,
name|void
modifier|*
name|filter_baton
parameter_list|,
name|import_ctx_t
modifier|*
name|import_ctx
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Import the children of DIR_ABSPATH, with other arguments similar to  * import_dir(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|import_children
parameter_list|(
specifier|const
name|char
modifier|*
name|dir_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|apr_hash_t
modifier|*
name|dirents
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_hash_t
modifier|*
name|excludes
parameter_list|,
name|apr_array_header_t
modifier|*
name|global_ignores
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_boolean_t
name|ignore_unknown_node_types
parameter_list|,
name|svn_client_import_filter_func_t
name|filter_callback
parameter_list|,
name|void
modifier|*
name|filter_baton
parameter_list|,
name|import_ctx_t
modifier|*
name|import_ctx
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_dirents
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|sorted_dirents
operator|=
name|svn_sort__hash
argument_list|(
name|dirents
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_dirents
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|this_abspath
decl_stmt|,
modifier|*
name|this_edit_path
decl_stmt|;
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_dirents
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
init|=
name|item
operator|.
name|key
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
init|=
name|item
operator|.
name|value
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Typically, we started importing from ".", in which case          edit_path is "".  So below, this_path might become "./blah",          and this_edit_path might become "blah", for example. */
name|this_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|dir_abspath
argument_list|,
name|filename
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|this_edit_path
operator|=
name|svn_relpath_join
argument_list|(
name|edit_path
argument_list|,
name|filename
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
name|depth
operator|>=
name|svn_depth_immediates
condition|)
block|{
comment|/* Recurse. */
name|svn_depth_t
name|depth_below_here
init|=
name|depth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|depth_below_here
operator|=
name|svn_depth_empty
expr_stmt|;
name|SVN_ERR
argument_list|(
name|import_dir
argument_list|(
name|editor
argument_list|,
name|dir_baton
argument_list|,
name|this_abspath
argument_list|,
name|this_edit_path
argument_list|,
name|depth_below_here
argument_list|,
name|excludes
argument_list|,
name|global_ignores
argument_list|,
name|no_ignore
argument_list|,
name|no_autoprops
argument_list|,
name|ignore_unknown_node_types
argument_list|,
name|filter_callback
argument_list|,
name|filter_baton
argument_list|,
name|import_ctx
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
name|depth
operator|>=
name|svn_depth_files
condition|)
block|{
name|SVN_ERR
argument_list|(
name|import_file
argument_list|(
name|editor
argument_list|,
name|dir_baton
argument_list|,
name|this_abspath
argument_list|,
name|this_edit_path
argument_list|,
name|dirent
argument_list|,
name|import_ctx
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirent
operator|->
name|kind
operator|!=
name|svn_node_dir
operator|&&
name|dirent
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
block|{
if|if
condition|(
name|ignore_unknown_node_types
condition|)
block|{
comment|/*## warn about it*/
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|this_abspath
argument_list|,
name|svn_wc_notify_skip
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown or unversionable type for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|this_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Import directory LOCAL_ABSPATH into the repository directory indicated by  * DIR_BATON in EDITOR.  EDIT_PATH is the path imported as the root  * directory, so all edits are relative to that.  *  * DEPTH is the depth at this point in the descent (it may be changed  * for recursive calls).  *  * Accumulate file paths and their batons in FILES, which must be  * non-null.  (These are used to send postfix textdeltas later).  *  * EXCLUDES is a hash whose keys are absolute paths to exclude from  * the import (values are unused).  *  * GLOBAL_IGNORES is an array of const char * ignore patterns.  Any child  * of LOCAL_ABSPATH which matches one or more of the patterns is not imported.  *  * If NO_IGNORE is FALSE, don't import files or directories that match  * ignore patterns.  *  * If FILTER_CALLBACK is not NULL, call it with FILTER_BATON on each to be  * imported node below LOCAL_ABSPATH to allow filtering nodes.  *  * If CTX->NOTIFY_FUNC is non-null, invoke it with CTX->NOTIFY_BATON for each  * directory.  *  * Use POOL for any temporary allocation.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|import_dir
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|edit_path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_hash_t
modifier|*
name|excludes
parameter_list|,
name|apr_array_header_t
modifier|*
name|global_ignores
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_boolean_t
name|ignore_unknown_node_types
parameter_list|,
name|svn_client_import_filter_func_t
name|filter_callback
parameter_list|,
name|void
modifier|*
name|filter_baton
parameter_list|,
name|import_ctx_t
modifier|*
name|import_ctx
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|void
modifier|*
name|this_dir_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_path_check_valid
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_filtered_children
argument_list|(
operator|&
name|dirents
argument_list|,
name|local_abspath
argument_list|,
name|excludes
argument_list|,
name|NULL
argument_list|,
name|global_ignores
argument_list|,
name|filter_callback
argument_list|,
name|filter_baton
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Import this directory, but not yet its children. */
block|{
comment|/* Add the new subdirectory, getting a descent baton from the editor. */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_directory
argument_list|(
name|edit_path
argument_list|,
name|dir_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|this_dir_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember that the repository was modified */
name|import_ctx
operator|->
name|repos_changed
operator|=
name|TRUE
expr_stmt|;
comment|/* By notifying before the recursive call below, we display        a directory add before displaying adds underneath the        directory.  To do it the other way around, just move this        after the recursive call. */
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_commit_added
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|notify
operator|->
name|lock_state
operator|=
name|svn_wc_notify_lock_state_inapplicable
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Now import the children recursively. */
name|SVN_ERR
argument_list|(
name|import_children
argument_list|(
name|local_abspath
argument_list|,
name|edit_path
argument_list|,
name|dirents
argument_list|,
name|editor
argument_list|,
name|this_dir_baton
argument_list|,
name|depth
argument_list|,
name|excludes
argument_list|,
name|global_ignores
argument_list|,
name|no_ignore
argument_list|,
name|no_autoprops
argument_list|,
name|ignore_unknown_node_types
argument_list|,
name|filter_callback
argument_list|,
name|filter_baton
argument_list|,
name|import_ctx
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, close the sub-directory. */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_directory
argument_list|(
name|this_dir_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Recursively import PATH to a repository using EDITOR and  * EDIT_BATON.  PATH can be a file or directory.  *  * DEPTH is the depth at which to import PATH; it behaves as for  * svn_client_import4().  *  * NEW_ENTRIES is an ordered array of path components that must be  * created in the repository (where the ordering direction is  * parent-to-child).  If PATH is a directory, NEW_ENTRIES may be empty  * -- the result is an import which creates as many new entries in the  * top repository target directory as there are importable entries in  * the top of PATH; but if NEW_ENTRIES is not empty, its last item is  * the name of a new subdirectory in the repository to hold the  * import.  If PATH is a file, NEW_ENTRIES may not be empty, and its  * last item is the name used for the file in the repository.  If  * NEW_ENTRIES contains more than one item, all but the last item are  * the names of intermediate directories that are created before the  * real import begins.  NEW_ENTRIES may NOT be NULL.  *  * EXCLUDES is a hash whose keys are absolute paths to exclude from  * the import (values are unused).  *  * AUTOPROPS is hash of all config file autoprops and  * svn:auto-props inherited by the import target, see the  * IMPORT_CTX member of the same name.  *  * LOCAL_IGNORES is an array of const char * ignore patterns which  * correspond to the svn:ignore property (if any) set on the root of the  * repository target and thus dictates which immediate children of that  * target should be ignored and not imported.  *  * GLOBAL_IGNORES is an array of const char * ignore patterns which  * correspond to the svn:global-ignores properties (if any) set on  * the root of the repository target or inherited by it.  *  * If NO_IGNORE is FALSE, don't import files or directories that match  * ignore patterns.  *  * If CTX->NOTIFY_FUNC is non-null, invoke it with CTX->NOTIFY_BATON for  * each imported path, passing actions svn_wc_notify_commit_added.  *  * Use POOL for any temporary allocation.  *  * Note: the repository directory receiving the import was specified  * when the editor was fetched.  (I.e, when EDITOR->open_root() is  * called, it returns a directory baton for that directory, which is  * not necessarily the root.)  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|import
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|new_entries
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_hash_t
modifier|*
name|excludes
parameter_list|,
name|apr_hash_t
modifier|*
name|autoprops
parameter_list|,
name|apr_array_header_t
modifier|*
name|local_ignores
parameter_list|,
name|apr_array_header_t
modifier|*
name|global_ignores
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_boolean_t
name|ignore_unknown_node_types
parameter_list|,
name|svn_client_import_filter_func_t
name|filter_callback
parameter_list|,
name|void
modifier|*
name|filter_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|void
modifier|*
name|root_baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|batons
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|edit_path
init|=
literal|""
decl_stmt|;
name|import_ctx_t
modifier|*
name|import_ctx
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|import_ctx
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|svn_io_dirent2_t
modifier|*
name|dirent
decl_stmt|;
name|import_ctx
operator|->
name|autoprops
operator|=
name|autoprops
expr_stmt|;
name|svn_magic__init
argument_list|(
operator|&
name|import_ctx
operator|->
name|magic_cookie
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Get a root dir baton.  We pass an invalid revnum to open_root      to mean "base this on the youngest revision".  Should we have an      SVN_YOUNGEST_REVNUM defined for these purposes? */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Import a file or a directory tree. */
name|SVN_ERR
argument_list|(
name|svn_io_stat_dirent2
argument_list|(
operator|&
name|dirent
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the intermediate directory components necessary for properly      rooting our import source tree.  */
if|if
condition|(
name|new_entries
operator|->
name|nelts
condition|)
block|{
name|int
name|i
decl_stmt|;
name|batons
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|new_entries
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|new_entries
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|component
init|=
name|APR_ARRAY_IDX
argument_list|(
name|new_entries
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|edit_path
operator|=
name|svn_relpath_join
argument_list|(
name|edit_path
argument_list|,
name|component
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If this is the last path component, and we're importing a              file, then this component is the name of the file, not an              intermediate directory. */
if|if
condition|(
operator|(
name|i
operator|==
name|new_entries
operator|->
name|nelts
operator|-
literal|1
operator|)
operator|&&
operator|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
condition|)
break|break;
name|APR_ARRAY_PUSH
argument_list|(
name|batons
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|root_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_directory
argument_list|(
name|edit_path
argument_list|,
name|root_baton
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember that the repository was modified */
name|import_ctx
operator|->
name|repos_changed
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"New entry name required when importing a file"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Note that there is no need to check whether PATH's basename is      the same name that we reserve for our administrative      subdirectories.  It would be strange -- though not illegal -- to      import the contents of a directory of that name, because the      directory's own name is not part of those contents.  Of course,      if something underneath it also has our reserved name, then we'll      error. */
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* This code path ignores EXCLUDES and FILTER, but they don't make          much sense for a single file import anyway. */
name|svn_boolean_t
name|ignores_match
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
operator|!
name|no_ignore
condition|)
name|ignores_match
operator|=
operator|(
name|svn_wc_match_ignore_list
argument_list|(
name|local_abspath
argument_list|,
name|global_ignores
argument_list|,
name|pool
argument_list|)
operator|||
name|svn_wc_match_ignore_list
argument_list|(
name|local_abspath
argument_list|,
name|local_ignores
argument_list|,
name|pool
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignores_match
condition|)
name|SVN_ERR
argument_list|(
name|import_file
argument_list|(
name|editor
argument_list|,
name|root_baton
argument_list|,
name|local_abspath
argument_list|,
name|edit_path
argument_list|,
name|dirent
argument_list|,
name|import_ctx
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
comment|/* If we are creating a new repository directory path to import to,          then we disregard any svn:ignore property. */
if|if
condition|(
operator|!
name|no_ignore
operator|&&
name|new_entries
operator|->
name|nelts
condition|)
name|local_ignores
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_filtered_children
argument_list|(
operator|&
name|dirents
argument_list|,
name|local_abspath
argument_list|,
name|excludes
argument_list|,
name|local_ignores
argument_list|,
name|global_ignores
argument_list|,
name|filter_callback
argument_list|,
name|filter_baton
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|import_children
argument_list|(
name|local_abspath
argument_list|,
name|edit_path
argument_list|,
name|dirents
argument_list|,
name|editor
argument_list|,
name|root_baton
argument_list|,
name|depth
argument_list|,
name|excludes
argument_list|,
name|global_ignores
argument_list|,
name|no_ignore
argument_list|,
name|no_autoprops
argument_list|,
name|ignore_unknown_node_types
argument_list|,
name|filter_callback
argument_list|,
name|filter_baton
argument_list|,
name|import_ctx
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dirent
operator|->
name|kind
operator|==
name|svn_node_none
operator|||
name|dirent
operator|->
name|kind
operator|==
name|svn_node_unknown
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Close up shop; it's time to go home. */
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_directory
argument_list|(
name|root_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|batons
operator|&&
name|batons
operator|->
name|nelts
condition|)
block|{
name|void
modifier|*
modifier|*
name|baton
decl_stmt|;
while|while
condition|(
operator|(
name|baton
operator|=
operator|(
name|void
operator|*
operator|*
operator|)
name|apr_array_pop
argument_list|(
name|batons
argument_list|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_directory
argument_list|(
operator|*
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|import_ctx
operator|->
name|repos_changed
condition|)
return|return
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
return|;
else|else
return|return
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public Interfaces. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client_import5
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|no_ignore
parameter_list|,
name|svn_boolean_t
name|no_autoprops
parameter_list|,
name|svn_boolean_t
name|ignore_unknown_node_types
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_client_import_filter_func_t
name|filter_callback
parameter_list|,
name|void
modifier|*
name|filter_baton
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_msg
init|=
literal|""
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|apr_hash_t
modifier|*
name|excludes
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_entries
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|commit_revprops
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|autoprops
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|global_ignores
decl_stmt|;
name|apr_array_header_t
modifier|*
name|local_ignores_arr
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new commit item and add it to the array. */
if|if
condition|(
name|SVN_CLIENT__HAS_LOG_MSG_FUNC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
comment|/* If there's a log message gatherer, create a temporary commit          item array solely to help generate the log message.  The          array is not used for the import itself. */
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|item
argument_list|)
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_ADD
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_log_msg
argument_list|(
operator|&
name|log_msg
argument_list|,
operator|&
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_msg
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|tmp_file
condition|)
block|{
specifier|const
name|char
modifier|*
name|abs_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|abs_path
argument_list|,
name|tmp_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|excludes
argument_list|,
name|abs_path
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|url
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Figure out all the path components we need to create just to have      a place to stick our imported tree. */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can import into directories, but if a file already exists, that's      an error. */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_EXISTS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' already exists"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
while|while
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_uri_split
argument_list|(
operator|&
name|url
argument_list|,
operator|&
name|dir
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|new_entries
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|dir
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Reverse the order of the components we added to our NEW_ENTRIES array. */
name|svn_sort__array_reverse
argument_list|(
name|new_entries
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* The repository doesn't know about the reserved administrative      directory. */
if|if
condition|(
name|new_entries
operator|->
name|nelts
condition|)
block|{
specifier|const
name|char
modifier|*
name|last_component
init|=
name|APR_ARRAY_IDX
argument_list|(
name|new_entries
argument_list|,
name|new_entries
operator|->
name|nelts
operator|-
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_wc_is_adm_dir
argument_list|(
name|last_component
argument_list|,
name|scratch_pool
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ADM_DIR_RESERVED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is a reserved name and cannot be imported"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|last_component
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__ensure_revprop_table
argument_list|(
operator|&
name|commit_revprops
argument_list|,
name|revprop_table
argument_list|,
name|log_msg
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch RA commit editor. */
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|ra_session
argument_list|,
name|svn_client__get_shim_callbacks
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|commit_revprops
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get inherited svn:auto-props, svn:global-ignores, and      svn:ignores for the location we are importing to. */
if|if
condition|(
operator|!
name|no_autoprops
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__get_all_auto_props
argument_list|(
operator|&
name|autoprops
argument_list|,
name|url
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|no_ignore
condition|)
block|{
name|global_ignores
operator|=
name|NULL
expr_stmt|;
name|local_ignores_arr
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|svn_opt_revision_t
name|rev
decl_stmt|;
name|apr_array_header_t
modifier|*
name|config_ignores
decl_stmt|;
name|apr_hash_t
modifier|*
name|local_ignores_hash
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_inherited_ignores
argument_list|(
operator|&
name|global_ignores
argument_list|,
name|url
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|config_ignores
argument_list|,
name|ctx
operator|->
name|config
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|global_ignores
operator|=
name|apr_array_append
argument_list|(
name|scratch_pool
argument_list|,
name|global_ignores
argument_list|,
name|config_ignores
argument_list|)
expr_stmt|;
name|rev
operator|.
name|kind
operator|=
name|svn_opt_revision_head
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_propget5
argument_list|(
operator|&
name|local_ignores_hash
argument_list|,
name|NULL
argument_list|,
name|SVN_PROP_IGNORE
argument_list|,
name|url
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|,
name|svn_depth_empty
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|local_ignores_arr
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|local_ignores_hash
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|propval
init|=
name|svn_hash_gets
argument_list|(
name|local_ignores_hash
argument_list|,
name|url
argument_list|)
decl_stmt|;
if|if
condition|(
name|propval
condition|)
block|{
name|svn_cstring_split_append
argument_list|(
name|local_ignores_arr
argument_list|,
name|propval
operator|->
name|data
argument_list|,
literal|"\n\r\t\v "
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* If an error occurred during the commit, abort the edit and return      the error.  We don't even care if the abort itself fails.  */
if|if
condition|(
operator|(
name|err
operator|=
name|import
argument_list|(
name|local_abspath
argument_list|,
name|new_entries
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|depth
argument_list|,
name|excludes
argument_list|,
name|autoprops
argument_list|,
name|local_ignores_arr
argument_list|,
name|global_ignores
argument_list|,
name|no_ignore
argument_list|,
name|no_autoprops
argument_list|,
name|ignore_unknown_node_types
argument_list|,
name|filter_callback
argument_list|,
name|filter_baton
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
operator|)
condition|)
block|{
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

