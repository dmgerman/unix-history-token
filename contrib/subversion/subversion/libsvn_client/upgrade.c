begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * upgrade.c:  wrapper around wc upgrade functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* callback baton for fetch_repos_info */
end_comment

begin_struct
struct|struct
name|repos_info_baton
block|{
name|apr_pool_t
modifier|*
name|state_pool
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_repos
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_uuid
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* svn_wc_upgrade_get_repos_info_t implementation for calling    svn_wc_upgrade() from svn_client_upgrade() */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_repos_info
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|repos_root
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|repos_uuid
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|repos_info_baton
modifier|*
name|ri
init|=
name|baton
decl_stmt|;
comment|/* The same info is likely to retrieved multiple times (e.g. externals) */
if|if
condition|(
name|ri
operator|->
name|last_repos
operator|&&
name|svn_uri__is_ancestor
argument_list|(
name|ri
operator|->
name|last_repos
argument_list|,
name|url
argument_list|)
condition|)
block|{
operator|*
name|repos_root
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|ri
operator|->
name|last_repos
argument_list|)
expr_stmt|;
operator|*
name|repos_uuid
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|ri
operator|->
name|last_uuid
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client_get_repos_root
argument_list|(
name|repos_root
argument_list|,
name|repos_uuid
argument_list|,
name|url
argument_list|,
name|ri
operator|->
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store data for further calls */
name|ri
operator|->
name|last_repos
operator|=
name|apr_pstrdup
argument_list|(
name|ri
operator|->
name|state_pool
argument_list|,
operator|*
name|repos_root
argument_list|)
expr_stmt|;
name|ri
operator|->
name|last_uuid
operator|=
name|apr_pstrdup
argument_list|(
name|ri
operator|->
name|state_pool
argument_list|,
operator|*
name|repos_uuid
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_upgrade
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_hash_t
modifier|*
name|externals
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool2
decl_stmt|;
name|svn_opt_revision_t
name|rev
init|=
block|{
name|svn_opt_revision_unspecified
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|struct
name|repos_info_baton
name|info_baton
decl_stmt|;
name|info_baton
operator|.
name|state_pool
operator|=
name|scratch_pool
expr_stmt|;
name|info_baton
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|info_baton
operator|.
name|last_repos
operator|=
name|NULL
expr_stmt|;
name|info_baton
operator|.
name|last_uuid
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_upgrade
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|fetch_repos_info
argument_list|,
operator|&
name|info_baton
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now it's time to upgrade the externals too. We do it after the wc      upgrade to avoid that errors in the externals causes the wc upgrade to      fail. Thanks to caching the performance penalty of walking the wc a      second time shouldn't be too severe */
name|SVN_ERR
argument_list|(
name|svn_client_propget5
argument_list|(
operator|&
name|externals
argument_list|,
name|NULL
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|,
name|local_abspath
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|rev
argument_list|,
name|NULL
argument_list|,
name|svn_depth_infinity
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool2
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|externals
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|externals_parent_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|externals_parent_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|externals_parent_repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|externals_parent_repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|externals_parent
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|external_desc
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|externals_p
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|externals_p
operator|=
name|apr_array_make
argument_list|(
name|iterpool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_wc_external_item2_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In this loop, an error causes the respective externals definition, or        * the external (inner loop), to be skipped, so that upgrade carries on        * with the other externals. */
name|err
operator|=
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|externals_parent_abspath
argument_list|,
name|externals_parent
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|externals_parent_repos_relpath
argument_list|,
operator|&
name|externals_parent_repos_root_url
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|externals_parent_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|externals_parent_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|externals_parent_repos_root_url
argument_list|,
name|externals_parent_repos_relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_wc_parse_externals_description3
argument_list|(
operator|&
name|externals_p
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|external_desc
operator|->
name|data
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|externals_parent
argument_list|,
name|svn_wc_notify_failed_external
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Next externals definition, please... */
continue|continue;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|externals_p
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_wc_external_item2_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|resolved_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|external_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
name|svn_node_kind_t
name|external_kind
decl_stmt|;
name|svn_revnum_t
name|peg_revision
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|externals_p
argument_list|,
name|i
argument_list|,
name|svn_wc_external_item2_t
operator|*
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
name|external_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|externals_parent_abspath
argument_list|,
name|item
operator|->
name|target_dir
argument_list|,
name|iterpool2
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__resolve_relative_external_url
argument_list|(
operator|&
name|resolved_url
argument_list|,
name|item
argument_list|,
name|externals_parent_repos_root_url
argument_list|,
name|externals_parent_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|handle_error
goto|;
comment|/* This is a hack. We only need to call svn_wc_upgrade() on external            * dirs, as file externals are upgraded along with their defining            * WC.  Reading the kind will throw an exception on an external dir,            * saying that the wc must be upgraded.  If it's a file, the lookup            * is done in an adm_dir belonging to the defining wc (which has            * already been upgraded) and no error is returned.  If it doesn't            * exist (external that isn't checked out yet), we'll just get            * svn_node_none. */
name|err
operator|=
name|svn_wc_read_kind2
argument_list|(
operator|&
name|external_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|external_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|iterpool2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_UPGRADE_REQUIRED
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client_upgrade
argument_list|(
name|external_abspath
argument_list|,
name|ctx
argument_list|,
name|iterpool2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|handle_error
goto|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
goto|goto
name|handle_error
goto|;
comment|/* The upgrade of any dir should be done now, get the now reliable            * kind. */
name|err
operator|=
name|svn_wc_read_kind2
argument_list|(
operator|&
name|external_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|external_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|iterpool2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|handle_error
goto|;
comment|/* Update the EXTERNALS table according to the root URL,            * relpath and uuid known in the upgraded external WC. */
comment|/* We should probably have a function that provides all three            * of root URL, repos relpath and uuid at once, but here goes... */
comment|/* First get the relpath, as that returns SVN_ERR_WC_PATH_NOT_FOUND            * when the node is not present in the file system.            * svn_wc__node_get_repos_info() would try to derive the URL. */
name|err
operator|=
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|external_abspath
argument_list|,
name|iterpool2
argument_list|,
name|iterpool2
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|handle_error
goto|;
comment|/* If we haven't got any information from the checked out external,            * or if the URL information mismatches the external's definition,            * ask fetch_repos_info() to find out the repos root. */
if|if
condition|(
literal|0
operator|!=
name|strcmp
argument_list|(
name|resolved_url
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
condition|)
block|{
name|err
operator|=
name|fetch_repos_info
argument_list|(
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
operator|&
name|info_baton
argument_list|,
name|resolved_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|handle_error
goto|;
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root_url
argument_list|,
name|resolved_url
argument_list|,
name|iterpool2
argument_list|)
expr_stmt|;
comment|/* There's just the URL, no idea what kind the external is.                * That's fine, as the external isn't even checked out yet.                * The kind will be set during the next 'update'. */
name|external_kind
operator|=
name|svn_node_unknown
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
goto|goto
name|handle_error
goto|;
name|peg_revision
operator|=
operator|(
name|item
operator|->
name|peg_revision
operator|.
name|kind
operator|==
name|svn_opt_revision_number
condition|?
name|item
operator|->
name|peg_revision
operator|.
name|value
operator|.
name|number
else|:
name|SVN_INVALID_REVNUM
operator|)
expr_stmt|;
name|revision
operator|=
operator|(
name|item
operator|->
name|revision
operator|.
name|kind
operator|==
name|svn_opt_revision_number
condition|?
name|item
operator|->
name|revision
operator|.
name|value
operator|.
name|number
else|:
name|SVN_INVALID_REVNUM
operator|)
expr_stmt|;
name|err
operator|=
name|svn_wc__upgrade_add_external_info
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|external_abspath
argument_list|,
name|external_kind
argument_list|,
name|externals_parent
argument_list|,
name|repos_relpath
argument_list|,
name|repos_root_url
argument_list|,
name|repos_uuid
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|iterpool2
argument_list|)
expr_stmt|;
name|handle_error
label|:
if|if
condition|(
name|err
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|external_abspath
argument_list|,
name|svn_wc_notify_failed_external
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|err
operator|=
name|err
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Next external node, please... */
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool2
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

