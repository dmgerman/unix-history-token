begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * commit.c:  wrappers around wc commit functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_struct
struct|struct
name|capture_baton_t
block|{
name|svn_commit_callback2_t
name|original_callback
decl_stmt|;
name|void
modifier|*
name|original_baton
decl_stmt|;
name|svn_commit_info_t
modifier|*
modifier|*
name|info
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|capture_commit_info
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|capture_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
operator|*
operator|(
name|cb
operator|->
name|info
operator|)
operator|=
name|svn_commit_info_dup
argument_list|(
name|commit_info
argument_list|,
name|cb
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|original_callback
condition|)
name|SVN_ERR
argument_list|(
call|(
name|cb
operator|->
name|original_callback
call|)
argument_list|(
name|commit_info
argument_list|,
name|cb
operator|->
name|original_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_ra_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|log_msg
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|commit_items
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|commit_revprops
decl_stmt|;
name|apr_hash_t
modifier|*
name|relpath_map
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_revprop_table
argument_list|(
operator|&
name|commit_revprops
argument_list|,
name|revprop_table
argument_list|,
name|log_msg
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ENABLE_EV2_SHIMS
if|if
condition|(
name|commit_items
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|relpath_map
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
if|if
condition|(
operator|!
name|item
operator|->
name|path
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|relpath
condition|)
name|svn_hash_sets
argument_list|(
name|relpath_map
argument_list|,
name|relpath
argument_list|,
name|item
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Fetch RA commit editor. */
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|ra_session
argument_list|,
name|svn_client__get_shim_callbacks
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|relpath_map
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|ra_session
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|commit_revprops
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|lock_tokens
argument_list|,
name|keep_locks
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public Interfaces. ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reconcile_errors
parameter_list|(
name|svn_error_t
modifier|*
name|commit_err
parameter_list|,
name|svn_error_t
modifier|*
name|unlock_err
parameter_list|,
name|svn_error_t
modifier|*
name|bump_err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Early release (for good behavior). */
if|if
condition|(
operator|!
operator|(
name|commit_err
operator|||
name|unlock_err
operator|||
name|bump_err
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If there was a commit error, start off our error chain with      that. */
if|if
condition|(
name|commit_err
condition|)
block|{
name|commit_err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|commit_err
argument_list|,
name|_
argument_list|(
literal|"Commit failed (details follow):"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|commit_err
expr_stmt|;
block|}
comment|/* Else, create a new "general" error that will lead off the errors      that follow. */
else|else
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_BASE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Commit succeeded, but other errors follow:"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there was an unlock error... */
if|if
condition|(
name|unlock_err
condition|)
block|{
comment|/* Wrap the error with some headers. */
name|unlock_err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|unlock_err
argument_list|,
name|_
argument_list|(
literal|"Error unlocking locked dirs (details follow):"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append this error to the chain. */
name|svn_error_compose
argument_list|(
name|err
argument_list|,
name|unlock_err
argument_list|)
expr_stmt|;
block|}
comment|/* If there was a bumping error... */
if|if
condition|(
name|bump_err
condition|)
block|{
comment|/* Wrap the error with some headers. */
name|bump_err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|bump_err
argument_list|,
name|_
argument_list|(
literal|"Error bumping revisions post-commit (details follow):"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append this error to the chain. */
name|svn_error_compose
argument_list|(
name|err
argument_list|,
name|bump_err
argument_list|)
expr_stmt|;
block|}
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* For all lock tokens in ALL_TOKENS for URLs under BASE_URL, add them    to a new hashtable allocated in POOL.  *RESULT is set to point to this    new hash table.  *RESULT will be keyed on const char * URI-decoded paths    relative to BASE_URL.  The lock tokens will not be duplicated. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|collect_lock_tokens
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|result
parameter_list|,
name|apr_hash_t
modifier|*
name|all_tokens
parameter_list|,
specifier|const
name|char
modifier|*
name|base_url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
operator|*
name|result
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|all_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_uri_skip_ancestor
argument_list|(
name|base_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|relpath
condition|)
block|{
name|svn_hash_sets
argument_list|(
operator|*
name|result
argument_list|,
name|relpath
argument_list|,
name|token
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Put ITEM onto QUEUE, allocating it in QUEUE's pool...  * If a checksum is provided, it can be the MD5 and/or the SHA1. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|post_process_commit_item
parameter_list|(
name|svn_wc_committed_queue_t
modifier|*
name|queue
parameter_list|,
specifier|const
name|svn_client_commit_item3_t
modifier|*
name|item
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|svn_boolean_t
name|keep_changelists
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|svn_boolean_t
name|commit_as_operations
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|sha1_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|loop_recurse
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|remove_lock
decl_stmt|;
if|if
condition|(
operator|!
name|commit_as_operations
operator|&&
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_ADD
operator|)
operator|&&
operator|(
name|item
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
operator|&&
operator|(
name|item
operator|->
name|copyfrom_url
operator|)
condition|)
name|loop_recurse
operator|=
name|TRUE
expr_stmt|;
name|remove_lock
operator|=
operator|(
operator|!
name|keep_locks
operator|&&
operator|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN
operator|)
operator|)
expr_stmt|;
comment|/* When the node was deleted (or replaced), we need to always remove the       locks, as they're invalidated on the server. We cannot honor the       SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN flag here because it does not tell      us whether we have locked children. */
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
condition|)
name|remove_lock
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_wc_queue_committed3
argument_list|(
name|queue
argument_list|,
name|wc_ctx
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|loop_recurse
argument_list|,
name|item
operator|->
name|incoming_prop_changes
argument_list|,
name|remove_lock
argument_list|,
operator|!
name|keep_changelists
argument_list|,
name|sha1_checksum
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_nonrecursive_dir_delete
parameter_list|(
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|depth
operator|!=
name|svn_depth_infinity
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### TODO(sd): This check is slightly too strict.  It should be      ### possible to:      ###      ###   * delete a directory containing only files when      ###     depth==svn_depth_files;      ###      ###   * delete a directory containing only files and empty      ###     subdirs when depth==svn_depth_immediates.      ###      ### But for now, we insist on svn_depth_infinity if you're      ### going to delete a directory, because we're lazy and      ### trying to get depthy commits working in the first place.      ###      ### This would be fairly easy to fix, though: just, well,      ### check the above conditions!      ###      ### GJS: I think there may be some confusion here. there is      ###      the depth of the commit, and the depth of a checked-out      ###      directory in the working copy. Delete, by its nature, will      ###      always delete all of its children, so it seems a bit      ###      strange to worry about what is in the working copy.   */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|svn_wc_schedule_t
name|schedule
decl_stmt|;
comment|/* ### Looking at schedule is probably enough, no need for          pristine compare etc. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_schedule
argument_list|(
operator|&
name|schedule
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|schedule
operator|==
name|svn_wc_schedule_delete
operator|||
name|schedule
operator|==
name|svn_wc_schedule_replace
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_children
argument_list|(
operator|&
name|children
argument_list|,
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|children
operator|->
name|nelts
operator|>
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot delete the directory '%s' "
literal|"in a non-recursive commit "
literal|"because it has children"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a list of committables described by their common base abspath    BASE_ABSPATH and a list of relative dirents TARGET_RELPATHS determine    which absolute paths must be locked to commit all these targets and    return this as a const char * array in LOCK_TARGETS     Allocate the result in RESULT_POOL and use SCRATCH_POOL for temporary    storage */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|determine_lock_targets
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|lock_targets
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|base_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|target_relpaths
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|wc_items
decl_stmt|;
comment|/* const char *wcroot -> apr_array_header_t */
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|wc_items
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Create an array of targets for each working copy used */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|target_relpaths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|wc_targets
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|target_relpaths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|target_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|base_abspath
argument_list|,
name|target_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
continue|continue;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|wc_targets
operator|=
name|svn_hash_gets
argument_list|(
name|wc_items
argument_list|,
name|wcroot_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|wc_targets
condition|)
block|{
name|wc_targets
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|wc_items
argument_list|,
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|wcroot_abspath
argument_list|)
argument_list|,
name|wc_targets
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|wc_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target_abspath
expr_stmt|;
block|}
operator|*
name|lock_targets
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|apr_hash_count
argument_list|(
name|wc_items
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* For each working copy determine where to lock */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|wc_items
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|common
decl_stmt|;
specifier|const
name|char
modifier|*
name|wcroot_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|wc_targets
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_targets
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
name|target_abspath
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|wc_targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|wcroot_abspath
argument_list|,
name|target_abspath
argument_list|)
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|lock_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|target_abspath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Lock the parent to allow deleting the target */
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|lock_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_dirent_dirname
argument_list|(
name|target_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|wc_targets
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_dirent_condense_targets
argument_list|(
operator|&
name|common
argument_list|,
operator|&
name|wc_targets
argument_list|,
name|wc_targets
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|wc_targets
operator|->
name|elts
argument_list|,
name|wc_targets
operator|->
name|nelts
argument_list|,
name|wc_targets
operator|->
name|elt_size
argument_list|,
name|svn_sort_compare_paths
argument_list|)
expr_stmt|;
if|if
condition|(
name|wc_targets
operator|->
name|nelts
operator|==
literal|0
operator|||
operator|!
name|svn_path_is_empty
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|wc_targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|common
argument_list|,
name|wcroot_abspath
argument_list|)
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|lock_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|common
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Lock the parent to allow deleting the target */
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|lock_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_dirent_dirname
argument_list|(
name|common
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for check_url_kind */
end_comment

begin_struct
struct|struct
name|check_url_kind_baton
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_client__check_url_kind_t for svn_client_commit5 */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_url_kind
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|check_url_kind_baton
modifier|*
name|cukb
init|=
name|baton
decl_stmt|;
comment|/* If we don't have a session or can't use the session, get one */
if|if
condition|(
operator|!
name|cukb
operator|->
name|session
operator|||
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|cukb
operator|->
name|repos_root_url
argument_list|,
name|url
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|cukb
operator|->
name|session
argument_list|,
name|url
argument_list|,
name|NULL
argument_list|,
name|cukb
operator|->
name|ctx
argument_list|,
name|cukb
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|cukb
operator|->
name|session
argument_list|,
operator|&
name|cukb
operator|->
name|repos_root_url
argument_list|,
name|cukb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|cukb
operator|->
name|session
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_check_path
argument_list|(
name|cukb
operator|->
name|session
argument_list|,
literal|""
argument_list|,
name|revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Recurse into every target in REL_TARGETS, finding committable externals  * nested within. Append these to REL_TARGETS itself. The paths in REL_TARGETS  * are assumed to be / will be created relative to BASE_ABSPATH. The remaining  * arguments correspond to those of svn_client_commit6(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|append_externals_as_explicit_targets
parameter_list|(
name|apr_array_header_t
modifier|*
name|rel_targets
parameter_list|,
specifier|const
name|char
modifier|*
name|base_abspath
parameter_list|,
name|svn_boolean_t
name|include_file_externals
parameter_list|,
name|svn_boolean_t
name|include_dir_externals
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|rel_targets_nelts_fixed
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|include_file_externals
operator|||
name|include_dir_externals
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Easy part of applying DEPTH to externals. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_empty
condition|)
block|{
comment|/* Don't recurse. */
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Iterate *and* grow REL_TARGETS at the same time. */
name|rel_targets_nelts_fixed
operator|=
name|rel_targets
operator|->
name|nelts
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rel_targets_nelts_fixed
condition|;
name|i
operator|++
control|)
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
decl_stmt|;
name|apr_array_header_t
modifier|*
name|externals
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|target
operator|=
name|svn_dirent_join
argument_list|(
name|base_abspath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|rel_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* ### TODO: Possible optimization: No need to do this for file targets.        * ### But what's cheaper, stat'ing the file system or querying the db?        * ### --> future. */
name|SVN_ERR
argument_list|(
name|svn_wc__committable_externals_below
argument_list|(
operator|&
name|externals
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
argument_list|,
name|depth
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|externals
operator|!=
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|rel_target
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|externals
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_wc__committable_external_info_t
modifier|*
name|xinfo
init|=
name|APR_ARRAY_IDX
argument_list|(
name|externals
argument_list|,
name|j
argument_list|,
name|svn_wc__committable_external_info_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|xinfo
operator|->
name|kind
operator|==
name|svn_node_file
operator|&&
operator|!
name|include_file_externals
operator|)
operator|||
operator|(
name|xinfo
operator|->
name|kind
operator|==
name|svn_node_dir
operator|&&
operator|!
name|include_dir_externals
operator|)
condition|)
continue|continue;
name|rel_target
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|base_abspath
argument_list|,
name|xinfo
operator|->
name|local_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rel_target
operator|!=
name|NULL
operator|&&
operator|*
name|rel_target
operator|!=
literal|'\0'
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|rel_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|rel_target
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_commit6
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|svn_boolean_t
name|keep_changelists
parameter_list|,
name|svn_boolean_t
name|commit_as_operations
parameter_list|,
name|svn_boolean_t
name|include_file_externals
parameter_list|,
name|svn_boolean_t
name|include_dir_externals
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|struct
name|capture_baton_t
name|cb
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_msg
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_url
decl_stmt|;
name|apr_array_header_t
modifier|*
name|rel_targets
decl_stmt|;
name|apr_array_header_t
modifier|*
name|lock_targets
decl_stmt|;
name|apr_array_header_t
modifier|*
name|locks_obtained
decl_stmt|;
name|svn_client__committables_t
modifier|*
name|committables
decl_stmt|;
name|apr_hash_t
modifier|*
name|lock_tokens
decl_stmt|;
name|apr_hash_t
modifier|*
name|sha1_checksums
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
decl_stmt|;
name|svn_error_t
modifier|*
name|cmt_err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_error_t
modifier|*
name|bump_err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_error_t
modifier|*
name|unlock_err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|svn_boolean_t
name|commit_in_progress
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|timestamp_sleep
init|=
name|FALSE
decl_stmt|;
name|svn_commit_info_t
modifier|*
name|commit_info
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|current_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|notify_prefix
decl_stmt|;
name|int
name|depth_empty_after
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|depth
operator|!=
name|svn_depth_unknown
operator|&&
name|depth
operator|!=
name|svn_depth_exclude
argument_list|)
expr_stmt|;
comment|/* Committing URLs doesn't make sense, so error if it's tried. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is a URL, but URLs cannot be commit targets"
argument_list|)
argument_list|,
name|target
argument_list|)
return|;
block|}
comment|/* Condense the target list. This makes all targets absolute. */
name|SVN_ERR
argument_list|(
name|svn_dirent_condense_targets
argument_list|(
operator|&
name|base_abspath
argument_list|,
operator|&
name|rel_targets
argument_list|,
name|targets
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No targets means nothing to commit, so just return. */
if|if
condition|(
name|base_abspath
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR_ASSERT
argument_list|(
name|rel_targets
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we calculated only a base and no relative targets, this      must mean that we are being asked to commit (effectively) a      single path. */
if|if
condition|(
name|rel_targets
operator|->
name|nelts
operator|==
literal|0
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|rel_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|""
expr_stmt|;
if|if
condition|(
name|include_file_externals
operator|||
name|include_dir_externals
condition|)
block|{
if|if
condition|(
name|depth
operator|!=
name|svn_depth_unknown
operator|&&
name|depth
operator|!=
name|svn_depth_infinity
condition|)
block|{
comment|/* All targets after this will be handled as depth empty */
name|depth_empty_after
operator|=
name|rel_targets
operator|->
name|nelts
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|append_externals_as_explicit_targets
argument_list|(
name|rel_targets
argument_list|,
name|base_abspath
argument_list|,
name|include_file_externals
argument_list|,
name|include_dir_externals
argument_list|,
name|depth
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|determine_lock_targets
argument_list|(
operator|&
name|lock_targets
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|base_abspath
argument_list|,
name|rel_targets
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|locks_obtained
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|lock_targets
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lock_targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|lock_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|lock_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_wc__acquire_write_lock
argument_list|(
operator|&
name|lock_root
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
name|APR_ARRAY_PUSH
argument_list|(
name|locks_obtained
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|lock_root
expr_stmt|;
block|}
comment|/* Determine prefix to strip from the commit notify messages */
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|current_abspath
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify_prefix
operator|=
name|svn_dirent_get_longest_ancestor
argument_list|(
name|current_abspath
argument_list|,
name|base_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If a non-recursive commit is desired, do not allow a deleted directory      as one of the targets. */
if|if
condition|(
name|depth
operator|!=
name|svn_depth_infinity
operator|&&
operator|!
name|commit_as_operations
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rel_targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rel_targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|target_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|base_abspath
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|check_nonrecursive_dir_delete
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* Crawl the working copy for commit items. */
block|{
name|struct
name|check_url_kind_baton
name|cukb
decl_stmt|;
comment|/* Prepare for when we have a copy containing not-present nodes. */
name|cukb
operator|.
name|pool
operator|=
name|iterpool
expr_stmt|;
name|cukb
operator|.
name|session
operator|=
name|NULL
expr_stmt|;
comment|/* ### Can we somehow reuse session? */
name|cukb
operator|.
name|repos_root_url
operator|=
name|NULL
expr_stmt|;
name|cukb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_client__harvest_committables
argument_list|(
operator|&
name|committables
argument_list|,
operator|&
name|lock_tokens
argument_list|,
name|base_abspath
argument_list|,
name|rel_targets
argument_list|,
name|depth_empty_after
argument_list|,
name|depth
argument_list|,
operator|!
name|keep_locks
argument_list|,
name|changelists
argument_list|,
name|check_url_kind
argument_list|,
operator|&
name|cukb
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|committables
operator|->
name|by_repository
argument_list|)
operator|==
literal|0
condition|)
block|{
goto|goto
name|cleanup
goto|;
comment|/* Nothing to do */
block|}
elseif|else
if|if
condition|(
name|apr_hash_count
argument_list|(
name|committables
operator|->
name|by_repository
argument_list|)
operator|>
literal|1
condition|)
block|{
name|cmt_err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Commit can only commit to a single repository at a time.\n"
literal|"Are all targets part of the same working copy?"
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|{
name|apr_hash_index_t
modifier|*
name|hi
init|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|committables
operator|->
name|by_repository
argument_list|)
decl_stmt|;
name|commit_items
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
comment|/* If our array of targets contains only locks (and no actual file      or prop modifications), then we return here to avoid committing a      revision with no changes. */
block|{
name|svn_boolean_t
name|found_changed_path
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|item
operator|->
name|state_flags
operator|!=
name|SVN_CLIENT_COMMIT_ITEM_LOCK_TOKEN
condition|)
block|{
name|found_changed_path
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|found_changed_path
condition|)
goto|goto
name|cleanup
goto|;
block|}
comment|/* For every target that was moved verify that both halves of the    * move are part of the commit. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_MOVED_HERE
condition|)
block|{
comment|/* ### item->moved_from_abspath contains the move origin */
specifier|const
name|char
modifier|*
name|moved_from_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|delete_op_root_abspath
decl_stmt|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_wc__node_was_moved_here
argument_list|(
operator|&
name|moved_from_abspath
argument_list|,
operator|&
name|delete_op_root_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|moved_from_abspath
operator|&&
name|delete_op_root_abspath
operator|&&
name|strcmp
argument_list|(
name|moved_from_abspath
argument_list|,
name|delete_op_root_abspath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_boolean_t
name|found_delete_half
init|=
operator|(
name|svn_hash_gets
argument_list|(
name|committables
operator|->
name|by_path
argument_list|,
name|delete_op_root_abspath
argument_list|)
operator|!=
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|found_delete_half
condition|)
block|{
specifier|const
name|char
modifier|*
name|delete_half_parent_abspath
decl_stmt|;
comment|/* The delete-half isn't in the commit target list.                    * However, it might itself be the child of a deleted node,                    * either because of another move or a deletion.                    *                    * For example, consider: mv A/B B; mv B/C C; commit;                    * C's moved-from A/B/C is a child of the deleted A/B.                    * A/B/C does not appear in the commit target list, but                    * A/B does appear.                    * (Note that moved-from information is always stored                    * relative to the BASE tree, so we have 'C moved-from                    * A/B/C', not 'C moved-from B/C'.)                    *                    * An example involving a move and a delete would be:                    * mv A/B C; rm A; commit;                    * Now C is moved-from A/B which does not appear in the                    * commit target list, but A does appear.                    */
comment|/* Scan upwards for a deletion op-root from the                    * delete-half's parent directory. */
name|delete_half_parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|delete_op_root_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|delete_op_root_abspath
argument_list|,
name|delete_half_parent_abspath
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|parent_delete_op_root_abspath
decl_stmt|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_wc__node_get_deleted_ancestor
argument_list|(
operator|&
name|parent_delete_op_root_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|delete_half_parent_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|parent_delete_op_root_abspath
condition|)
name|found_delete_half
operator|=
operator|(
name|svn_hash_gets
argument_list|(
name|committables
operator|->
name|by_path
argument_list|,
name|parent_delete_op_root_abspath
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|found_delete_half
condition|)
block|{
name|cmt_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot commit '%s' because it was moved from "
literal|"'%s' which is not part of the commit; both "
literal|"sides of the move must be committed together"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|item
operator|->
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|delete_op_root_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
if|if
condition|(
name|item
operator|->
name|state_flags
operator|&
name|SVN_CLIENT_COMMIT_ITEM_DELETE
condition|)
block|{
specifier|const
name|char
modifier|*
name|moved_to_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_op_root_abspath
decl_stmt|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_wc__node_was_moved_away
argument_list|(
operator|&
name|moved_to_abspath
argument_list|,
operator|&
name|copy_op_root_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|item
operator|->
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|moved_to_abspath
operator|&&
name|copy_op_root_abspath
operator|&&
name|strcmp
argument_list|(
name|moved_to_abspath
argument_list|,
name|copy_op_root_abspath
argument_list|)
operator|==
literal|0
operator|&&
name|svn_hash_gets
argument_list|(
name|committables
operator|->
name|by_path
argument_list|,
name|copy_op_root_abspath
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|cmt_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot commit '%s' because it was moved to '%s' "
literal|"which is not part of the commit; both sides of "
literal|"the move must be committed together"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|item
operator|->
name|path
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|copy_op_root_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
block|}
comment|/* Go get a log message.  If an error occurs, or no log message is      specified, abort the operation. */
if|if
condition|(
name|SVN_CLIENT__HAS_LOG_MSG_FUNC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_client__get_log_msg
argument_list|(
operator|&
name|log_msg
argument_list|,
operator|&
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
operator|||
operator|(
operator|!
name|log_msg
operator|)
condition|)
goto|goto
name|cleanup
goto|;
block|}
else|else
name|log_msg
operator|=
literal|""
expr_stmt|;
comment|/* Sort and condense our COMMIT_ITEMS. */
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_client__condense_commit_items
argument_list|(
operator|&
name|base_url
argument_list|,
name|commit_items
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Collect our lock tokens with paths relative to base_url. */
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|collect_lock_tokens
argument_list|(
operator|&
name|lock_tokens
argument_list|,
name|lock_tokens
argument_list|,
name|base_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
name|cb
operator|.
name|original_callback
operator|=
name|commit_callback
expr_stmt|;
name|cb
operator|.
name|original_baton
operator|=
name|commit_baton
expr_stmt|;
name|cb
operator|.
name|info
operator|=
operator|&
name|commit_info
expr_stmt|;
name|cb
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Get the RA editor from the first lock target, rather than BASE_ABSPATH.    * When committing from multiple WCs, BASE_ABSPATH might be an unrelated    * parent of nested working copies. We don't support commits to multiple    * repositories so using the first WC to get the RA session is safe. */
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
operator|&
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|base_url
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|lock_targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|commit_items
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|get_ra_editor
argument_list|(
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|log_msg
argument_list|,
name|commit_items
argument_list|,
name|revprop_table
argument_list|,
name|lock_tokens
argument_list|,
name|keep_locks
argument_list|,
name|capture_commit_info
argument_list|,
operator|&
name|cb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmt_err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Make a note that we have a commit-in-progress. */
name|commit_in_progress
operator|=
name|TRUE
expr_stmt|;
comment|/* We'll assume that, once we pass this point, we are going to need to    * sleep for timestamps.  Really, we may not need to do unless and until    * we reach the point where we post-commit 'bump' the WC metadata. */
name|timestamp_sleep
operator|=
name|TRUE
expr_stmt|;
comment|/* Perform the commit. */
name|cmt_err
operator|=
name|svn_error_trace
argument_list|(
name|svn_client__do_commit
argument_list|(
name|base_url
argument_list|,
name|commit_items
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|notify_prefix
argument_list|,
operator|&
name|sha1_checksums
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Handle a successful commit. */
if|if
condition|(
operator|(
operator|!
name|cmt_err
operator|)
operator|||
operator|(
name|cmt_err
operator|->
name|apr_err
operator|==
name|SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED
operator|)
condition|)
block|{
name|svn_wc_committed_queue_t
modifier|*
name|queue
init|=
name|svn_wc_committed_queue_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Make a note that our commit is finished. */
name|commit_in_progress
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|commit_items
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|commit_items
argument_list|,
name|i
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|bump_err
operator|=
name|post_process_commit_item
argument_list|(
name|queue
argument_list|,
name|item
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|keep_changelists
argument_list|,
name|keep_locks
argument_list|,
name|commit_as_operations
argument_list|,
name|svn_hash_gets
argument_list|(
name|sha1_checksums
argument_list|,
name|item
operator|->
name|path
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|bump_err
condition|)
goto|goto
name|cleanup
goto|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|commit_info
argument_list|)
expr_stmt|;
name|bump_err
operator|=
name|svn_wc_process_committed_queue2
argument_list|(
name|queue
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|,
name|commit_info
operator|->
name|date
argument_list|,
name|commit_info
operator|->
name|author
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|cleanup
label|:
comment|/* Sleep to ensure timestamp integrity.  BASE_ABSPATH may have been      removed by the commit or it may the common ancestor of multiple      working copies. */
if|if
condition|(
name|timestamp_sleep
condition|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|base_abspath
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|wcroot_abspath
operator|=
name|NULL
expr_stmt|;
block|}
name|svn_io_sleep_for_timestamps
argument_list|(
name|wcroot_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Abort the commit if it is still in progress. */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Close open handles before aborting */
if|if
condition|(
name|commit_in_progress
condition|)
name|cmt_err
operator|=
name|svn_error_compose_create
argument_list|(
name|cmt_err
argument_list|,
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A bump error is likely to occur while running a working copy log file,      explicitly unlocking and removing temporary files would be wrong in      that case.  A commit error (cmt_err) should only occur before any      attempt to modify the working copy, so it doesn't prevent explicit      clean-up. */
if|if
condition|(
operator|!
name|bump_err
condition|)
block|{
comment|/* Release all locks we obtained */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|locks_obtained
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|lock_root
init|=
name|APR_ARRAY_IDX
argument_list|(
name|locks_obtained
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|unlock_err
operator|=
name|svn_error_compose_create
argument_list|(
name|svn_wc__release_write_lock
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|lock_root
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|unlock_err
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|reconcile_errors
argument_list|(
name|cmt_err
argument_list|,
name|unlock_err
argument_list|,
name|bump_err
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

