begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * prop_commands.c:  Implementation of propset, propget, and proplist.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Return an SVN_ERR_CLIENT_PROPERTY_NAME error if NAME is a wcprop,    else return SVN_NO_ERROR. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|error_if_wcprop_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
operator|==
name|svn_prop_wc_kind
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is a wcprop, thus not accessible to clients"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|getter_baton
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_revnum_t
name|base_revision_for_url
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_for_validation
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|mime_type
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|getter_baton
modifier|*
name|gb
init|=
name|baton
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
init|=
name|gb
operator|->
name|ra_session
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|gb
operator|->
name|base_revision_for_url
argument_list|,
name|stream
argument_list|,
name|NULL
argument_list|,
operator|(
name|mime_type
condition|?
operator|&
name|props
else|:
name|NULL
operator|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mime_type
condition|)
operator|*
name|mime_type
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_url_propset
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
specifier|const
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|svn_revnum_t
name|base_revision_for_url
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|void
modifier|*
name|root_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|base_revision_for_url
argument_list|,
name|pool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|void
modifier|*
name|file_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|uri_basename
init|=
name|svn_uri_basename
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_file
argument_list|(
name|uri_basename
argument_list|,
name|root_baton
argument_list|,
name|base_revision_for_url
argument_list|,
name|pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|file_baton
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|root_baton
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|editor
operator|->
name|close_directory
argument_list|(
name|root_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|propset_on_url
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|svn_boolean_t
name|skip_checks
parameter_list|,
name|svn_revnum_t
name|base_revision_for_url
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|enum
name|svn_prop_kind
name|prop_kind
init|=
name|svn_property_kind2
argument_list|(
name|propname
argument_list|)
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|commit_revprops
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|prop_kind
operator|!=
name|svn_prop_regular_kind
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROP_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Property '%s' is not a regular property"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
comment|/* Open an RA session for the URL. Note that we don't have a local      directory, nor a place to put temp files. */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|base_revision_for_url
argument_list|,
operator|&
name|node_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' does not exist in revision %ld"
argument_list|)
argument_list|,
name|target
argument_list|,
name|base_revision_for_url
argument_list|)
return|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* We need to reparent our session one directory up, since editor          semantics require the root is a directory.           ### How does this interact with authz? */
specifier|const
name|char
modifier|*
name|parent_url
decl_stmt|;
name|parent_url
operator|=
name|svn_uri_dirname
argument_list|(
name|target
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|parent_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Setting an inappropriate property is not allowed (unless      overridden by 'skip_checks', in some circumstances).  Deleting an      inappropriate property is allowed, however, since older clients      allowed (and other clients possibly still allow) setting it in      the first place. */
if|if
condition|(
name|propval
operator|&&
name|svn_prop_is_svn_prop
argument_list|(
name|propname
argument_list|)
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|new_value
decl_stmt|;
name|struct
name|getter_baton
name|gb
decl_stmt|;
name|gb
operator|.
name|ra_session
operator|=
name|ra_session
expr_stmt|;
name|gb
operator|.
name|base_revision_for_url
operator|=
name|base_revision_for_url
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_canonicalize_svn_prop
argument_list|(
operator|&
name|new_value
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|target
argument_list|,
name|node_kind
argument_list|,
name|skip_checks
argument_list|,
name|get_file_for_validation
argument_list|,
operator|&
name|gb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|propval
operator|=
name|new_value
expr_stmt|;
block|}
comment|/* Create a new commit item and add it to the array. */
if|if
condition|(
name|SVN_CLIENT__HAS_LOG_MSG_FUNC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|item
argument_list|)
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|target
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_PROP_MODS
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_log_msg
argument_list|(
operator|&
name|message
argument_list|,
operator|&
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|message
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|message
operator|=
literal|""
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_revprop_table
argument_list|(
operator|&
name|commit_revprops
argument_list|,
name|revprop_table
argument_list|,
name|message
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch RA commit editor. */
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|ra_session
argument_list|,
name|svn_client__get_shim_callbacks
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|commit_revprops
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
comment|/* No lock tokens */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|do_url_propset
argument_list|(
name|target
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|node_kind
argument_list|,
name|base_revision_for_url
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* At least try to abort the edit (and fs txn) before throwing err. */
name|svn_error_clear
argument_list|(
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* Close the edit. */
return|return
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check that PROPNAME is a valid name for a versioned property.  Return an  * error if it is not valid, specifically if it is:  *   - the name of a standard Subversion rev-prop; or  *   - in the namespace of WC-props; or  *   - not a well-formed property name (except if PROPVAL is NULL: in other  *     words we do allow deleting a prop with an ill-formed name).  *  * Since Subversion controls the "svn:" property namespace, we don't honor  * a 'skip_checks' flag here.  Checks for unusual property combinations such  * as svn:eol-style with a non-text svn:mime-type might understandably be  * skipped, but things such as using a property name reserved for revprops  * on a local target are never allowed.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_prop_name
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|)
block|{
if|if
condition|(
name|svn_prop_is_known_svn_rev_prop
argument_list|(
name|propname
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision property '%s' not allowed "
literal|"in this context"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|error_if_wcprop_name
argument_list|(
name|propname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|propval
operator|&&
operator|!
name|svn_prop_name_is_valid
argument_list|(
name|propname
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad property name: '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_propset_local
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|skip_checks
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|targets_are_urls
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Check for homogeneity among our targets. */
name|targets_are_urls
operator|=
name|svn_path_is_url
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__assert_homogeneous_target_type
argument_list|(
name|targets
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets_are_urls
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Targets must be working copy paths"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|check_prop_name
argument_list|(
name|propname
argument_list|,
name|propval
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Check for cancellation */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|target_abspath
argument_list|,
name|target
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call prop_set for deleted nodes to have special errors */
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
operator|||
name|kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|target_abspath
argument_list|,
name|svn_wc_notify_path_nonexistent
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|svn_wc_prop_set4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|depth
argument_list|,
name|skip_checks
argument_list|,
name|changelists
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_propset_remote
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_boolean_t
name|skip_checks
parameter_list|,
name|svn_revnum_t
name|base_revision_for_url
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|url
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Targets must be URLs"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|check_prop_name
argument_list|(
name|propname
argument_list|,
name|propval
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The rationale for requiring the base_revision_for_url      argument is that without it, it's too easy to possibly      overwrite someone else's change without noticing.  (See also      tools/examples/svnput.c). */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision_for_url
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Setting property on non-local targets "
literal|"needs a base revision"
argument_list|)
argument_list|)
return|;
comment|/* ### When you set svn:eol-style or svn:keywords on a wc file,      ### Subversion sends a textdelta at commit time to properly      ### normalize the file in the repository.  If we want to      ### support editing these properties on URLs, then we should      ### generate the same textdelta; for now, we won't support      ### editing these properties on URLs.  (Admittedly, this      ### means that all the machinery with get_file_for_validation      ### is unused.)    */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Setting property '%s' on non-local "
literal|"targets is not supported"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|propset_on_url
argument_list|(
name|propname
argument_list|,
name|propval
argument_list|,
name|url
argument_list|,
name|skip_checks
argument_list|,
name|base_revision_for_url
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_and_set_revprop
parameter_list|(
name|svn_revnum_t
modifier|*
name|set_rev
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original_propval
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|original_propval
condition|)
block|{
comment|/* Ensure old value hasn't changed behind our back. */
name|svn_string_t
modifier|*
name|current
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_rev_prop
argument_list|(
name|ra_session
argument_list|,
operator|*
name|set_rev
argument_list|,
name|propname
argument_list|,
operator|&
name|current
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|original_propval
operator|->
name|data
operator|&&
operator|(
operator|!
name|current
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"revprop '%s' in r%ld is unexpectedly absent "
literal|"in repository (maybe someone else deleted it?)"
argument_list|)
argument_list|,
name|propname
argument_list|,
operator|*
name|set_rev
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|original_propval
operator|->
name|data
operator|&&
operator|(
operator|!
name|svn_string_compare
argument_list|(
name|original_propval
argument_list|,
name|current
argument_list|)
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"revprop '%s' in r%ld has unexpected value "
literal|"in repository (maybe someone else changed it?)"
argument_list|)
argument_list|,
name|propname
argument_list|,
operator|*
name|set_rev
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|(
operator|!
name|original_propval
operator|->
name|data
operator|)
operator|&&
name|current
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"revprop '%s' in r%ld is unexpectedly present "
literal|"in repository (maybe someone else set it?)"
argument_list|)
argument_list|,
name|propname
argument_list|,
operator|*
name|set_rev
argument_list|)
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|ra_session
argument_list|,
operator|*
name|set_rev
argument_list|,
name|propname
argument_list|,
name|NULL
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_revprop_set2
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|propval
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|original_propval
parameter_list|,
specifier|const
name|char
modifier|*
name|URL
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|set_rev
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_boolean_t
name|be_atomic
decl_stmt|;
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|propname
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|propval
operator|&&
name|strchr
argument_list|(
name|propval
operator|->
name|data
argument_list|,
literal|'\n'
argument_list|)
operator|!=
name|NULL
operator|&&
operator|(
operator|!
name|force
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_REVISION_AUTHOR_CONTAINS_NEWLINE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Author name should not contain a newline;"
literal|" value will not be set unless forced"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|propval
operator|&&
operator|!
name|svn_prop_name_is_valid
argument_list|(
name|propname
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_PROPERTY_NAME
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad property name: '%s'"
argument_list|)
argument_list|,
name|propname
argument_list|)
return|;
comment|/* Open an RA session for the URL. */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|URL
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resolve the revision into something real, and return that to the      caller as well. */
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
name|set_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|ra_session
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session
argument_list|,
operator|&
name|be_atomic
argument_list|,
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|be_atomic
condition|)
block|{
comment|/* Convert ORIGINAL_PROPVAL to an OLD_VALUE_P. */
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|unset
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|original_propval
operator|==
name|NULL
condition|)
name|old_value_p
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|original_propval
operator|->
name|data
operator|==
name|NULL
condition|)
name|old_value_p
operator|=
operator|&
name|unset
expr_stmt|;
else|else
name|old_value_p
operator|=
operator|&
name|original_propval
expr_stmt|;
comment|/* The actual RA call. */
name|SVN_ERR
argument_list|(
name|svn_ra_change_rev_prop2
argument_list|(
name|ra_session
argument_list|,
operator|*
name|set_rev
argument_list|,
name|propname
argument_list|,
name|old_value_p
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The actual RA call. */
name|SVN_ERR
argument_list|(
name|check_and_set_revprop
argument_list|(
name|set_rev
argument_list|,
name|ra_session
argument_list|,
name|propname
argument_list|,
name|original_propval
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify_url
argument_list|(
name|URL
argument_list|,
name|propval
operator|==
name|NULL
condition|?
name|svn_wc_notify_revprop_deleted
else|:
name|svn_wc_notify_revprop_set
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|prop_name
operator|=
name|propname
expr_stmt|;
name|notify
operator|->
name|revision
operator|=
operator|*
name|set_rev
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for the remote case of svn_client_propget.  *  * If PROPS is not null, then get the value of property PROPNAME in REVNUM,    using RA_LIB and SESSION.  Store the value ('svn_string_t *') in PROPS,    under the path key "TARGET_PREFIX/TARGET_RELATIVE" ('const char *').  *  * If INHERITED_PROPS is not null, then set *INHERITED_PROPS to a  * depth-first ordered array of svn_prop_inherited_item_t * structures  * representing the PROPNAME properties inherited by the target.  If  * INHERITABLE_PROPS in not null and no inheritable properties are found,  * then set *INHERITED_PROPS to an empty array.  *  * Recurse according to DEPTH, similarly to svn_client_propget3().  *  * KIND is the kind of the node at "TARGET_PREFIX/TARGET_RELATIVE".  * Yes, caller passes this; it makes the recursion more efficient :-).  *  * Allocate PROPS and *INHERITED_PROPS in RESULT_POOL, but do all temporary  * work in SCRATCH_POOL.  The two pools can be the same; recursive  * calls may use a different SCRATCH_POOL, however.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remote_propget
parameter_list|(
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|inherited_props
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|target_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|target_relative
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_revnum_t
name|revnum
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_t
modifier|*
name|prop_hash
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_full_url
init|=
name|svn_path_url_add_component2
argument_list|(
name|target_prefix
argument_list|,
name|target_relative
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|ra_session
argument_list|,
operator|(
name|depth
operator|>=
name|svn_depth_files
condition|?
operator|&
name|dirents
else|:
name|NULL
operator|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_hash
argument_list|,
name|target_relative
argument_list|,
name|revnum
argument_list|,
name|SVN_DIRENT_KIND
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
name|target_relative
argument_list|,
name|revnum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_hash
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ENTRY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' does not exist in revision %ld"
argument_list|)
argument_list|,
name|target_full_url
argument_list|,
name|revnum
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown node kind for '%s'"
argument_list|)
argument_list|,
name|target_full_url
argument_list|)
return|;
block|}
if|if
condition|(
name|inherited_props
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
comment|/* We will filter out all but PROPNAME later, making a final copy          in RESULT_POOL, so pass SCRATCH_POOL for all pools. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_inherited_props
argument_list|(
name|ra_session
argument_list|,
name|inherited_props
argument_list|,
name|target_relative
argument_list|,
name|revnum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__iprop_relpaths_to_urls
argument_list|(
operator|*
name|inherited_props
argument_list|,
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make a copy of any inherited PROPNAME properties in RESULT_POOL. */
if|if
condition|(
name|inherited_props
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|final_iprops
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|*
name|inherited_props
operator|)
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|iprop
init|=
name|APR_ARRAY_IDX
argument_list|(
operator|(
operator|*
name|inherited_props
operator|)
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|iprop_val
init|=
name|svn_hash_gets
argument_list|(
name|iprop
operator|->
name|prop_hash
argument_list|,
name|propname
argument_list|)
decl_stmt|;
if|if
condition|(
name|iprop_val
condition|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|new_iprop
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_iprop
argument_list|)
argument_list|)
decl_stmt|;
name|new_iprop
operator|->
name|path_or_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|iprop
operator|->
name|path_or_url
argument_list|)
expr_stmt|;
name|new_iprop
operator|->
name|prop_hash
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|new_iprop
operator|->
name|prop_hash
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|propname
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|iprop_val
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|final_iprops
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
operator|=
name|new_iprop
expr_stmt|;
block|}
block|}
operator|*
name|inherited_props
operator|=
name|final_iprops
expr_stmt|;
block|}
if|if
condition|(
name|prop_hash
operator|&&
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|prop_hash
argument_list|,
name|propname
argument_list|)
operator|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|props
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|target_full_url
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|val
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|depth
operator|>=
name|svn_depth_files
operator|&&
name|kind
operator|==
name|svn_node_dir
operator|&&
name|apr_hash_count
argument_list|(
name|dirents
argument_list|)
operator|>
literal|0
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|this_name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_dirent_t
modifier|*
name|this_ent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_target_relative
decl_stmt|;
name|svn_depth_t
name|depth_below_here
init|=
name|depth
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|&&
name|this_ent
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
continue|continue;
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
operator|||
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|depth_below_here
operator|=
name|svn_depth_empty
expr_stmt|;
name|new_target_relative
operator|=
name|svn_relpath_join
argument_list|(
name|target_relative
argument_list|,
name|this_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remote_propget
argument_list|(
name|props
argument_list|,
name|NULL
argument_list|,
name|propname
argument_list|,
name|target_prefix
argument_list|,
name|new_target_relative
argument_list|,
name|this_ent
operator|->
name|kind
argument_list|,
name|revnum
argument_list|,
name|ra_session
argument_list|,
name|depth_below_here
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for recursive_propget_receiver(). */
end_comment

begin_struct
struct|struct
name|recursive_propget_receiver_baton
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* Hash to collect props. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Pool to allocate additions to PROPS. */
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
comment|/* Working copy context. */
block|}
struct|;
end_struct

begin_comment
comment|/* An implementation of svn_wc__proplist_receiver_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recursive_propget_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|recursive_propget_receiver_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|props
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
init|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|props
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|b
operator|->
name|props
argument_list|,
name|apr_pstrdup
argument_list|(
name|b
operator|->
name|pool
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the property value for any PROPNAME set on TARGET in *PROPS,    with WC paths of char * for keys and property values of    svn_string_t * for values.  Assumes that PROPS is non-NULL.  Additions    to *PROPS are allocated in RESULT_POOL, temporary allocations happen in    SCRATCH_POOL.     CHANGELISTS is an array of const char * changelist names, used as a    restrictive filter on items whose properties are set; that is,    don't set properties on any item unless it's a member of one of    those changelists.  If CHANGELISTS is empty (or altogether NULL),    no changelist filtering occurs.     Treat DEPTH as in svn_client_propget3(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_prop_from_wc
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_boolean_t
name|pristine
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|recursive_propget_receiver_baton
name|rb
decl_stmt|;
comment|/* Technically, svn_depth_unknown just means use whatever depth(s)      we find in the working copy.  But this is a walk over extant      working copy paths: if they're there at all, then by definition      the local depth reaches them, so let's just use svn_depth_infinity      to get there. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
if|if
condition|(
operator|!
name|pristine
operator|&&
name|depth
operator|==
name|svn_depth_infinity
operator|&&
operator|(
operator|!
name|changelists
operator|||
name|changelists
operator|->
name|nelts
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* Handle this common svn:mergeinfo case more efficient than the target          list handling in the recursive retrieval. */
name|SVN_ERR
argument_list|(
name|svn_wc__prop_retrieve_recursive
argument_list|(
name|props
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|propname
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|rb
operator|.
name|props
operator|=
operator|*
name|props
expr_stmt|;
name|rb
operator|.
name|pool
operator|=
name|result_pool
expr_stmt|;
name|rb
operator|.
name|wc_ctx
operator|=
name|ctx
operator|->
name|wc_ctx
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__prop_list_recursive
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|propname
argument_list|,
name|depth
argument_list|,
name|pristine
argument_list|,
name|changelists
argument_list|,
name|recursive_propget_receiver
argument_list|,
operator|&
name|rb
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Note: this implementation is very similar to svn_client_proplist. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client_propget5
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|inherited_props
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|actual_revnum
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|revnum
decl_stmt|;
name|svn_boolean_t
name|local_explicit_props
decl_stmt|;
name|svn_boolean_t
name|local_iprops
decl_stmt|;
name|SVN_ERR
argument_list|(
name|error_if_wcprop_name
argument_list|(
name|propname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|)
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|peg_revision
operator|=
name|svn_cl__rev_default_to_head_or_working
argument_list|(
name|peg_revision
argument_list|,
name|target
argument_list|)
expr_stmt|;
name|revision
operator|=
name|svn_cl__rev_default_to_peg
argument_list|(
name|revision
argument_list|,
name|peg_revision
argument_list|)
expr_stmt|;
name|local_explicit_props
operator|=
operator|(
operator|!
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
operator|&&
name|SVN_CLIENT__REVKIND_IS_LOCAL_TO_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
operator|&&
name|SVN_CLIENT__REVKIND_IS_LOCAL_TO_WC
argument_list|(
name|revision
operator|->
name|kind
argument_list|)
operator|)
expr_stmt|;
name|local_iprops
operator|=
operator|(
name|local_explicit_props
operator|&&
operator|(
name|peg_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
operator|||
name|peg_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|&&
operator|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
operator|||
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|local_explicit_props
condition|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|pristine
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* If FALSE, we want the working revision. */
name|pristine
operator|=
operator|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_committed
operator|||
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_base
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
argument_list|,
name|pristine
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
operator|||
name|kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* svn uses SVN_ERR_UNVERSIONED_RESOURCE as warning only              for this function. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNVERSIONED_RESOURCE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|err
operator|=
name|svn_client__get_revision_number
argument_list|(
operator|&
name|revnum
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_BAD_REVISION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|revnum
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
name|inherited_props
operator|&&
name|local_iprops
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_iprops
argument_list|(
name|inherited_props
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
argument_list|,
name|propname
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_get_repos_root
argument_list|(
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|target
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__iprop_relpaths_to_urls
argument_list|(
operator|*
name|inherited_props
argument_list|,
name|repos_root_url
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|get_prop_from_wc
argument_list|(
name|props
argument_list|,
name|propname
argument_list|,
name|target
argument_list|,
name|pristine
argument_list|,
name|kind
argument_list|,
name|depth
argument_list|,
name|changelists
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|inherited_props
operator|&&
operator|!
name|local_iprops
operator|)
operator|||
operator|!
name|local_explicit_props
condition|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_opt_revision_t
name|new_operative_rev
decl_stmt|;
name|svn_opt_revision_t
name|new_peg_rev
decl_stmt|;
comment|/* Peg or operative revisions may be WC specific for          TARGET's explicit props, but still require us to          contact the repository for the inherited properties. */
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
operator|||
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|origin_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_root_abspath
decl_stmt|;
name|svn_boolean_t
name|is_copy
decl_stmt|;
comment|/* Avoid assertion on the next line when somebody accidentally asks for              a working copy revision on a URL */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
operator|&
name|is_copy
argument_list|,
operator|&
name|origin_rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
operator|&
name|copy_root_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
comment|/* scan_deleted */
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
block|{
name|target
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|resolved_peg_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|resolved_peg_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_peg_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|new_peg_rev
operator|.
name|value
operator|.
name|number
operator|=
name|resolved_peg_rev
expr_stmt|;
name|peg_revision
operator|=
operator|&
name|new_peg_rev
expr_stmt|;
block|}
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|resolved_operative_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|resolved_operative_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_operative_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|new_operative_rev
operator|.
name|value
operator|.
name|number
operator|=
name|resolved_operative_rev
expr_stmt|;
name|revision
operator|=
operator|&
name|new_operative_rev
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* TARGET doesn't exist in the repository, so there are                      obviously not inherited props to be found there. */
name|local_iprops
operator|=
name|TRUE
expr_stmt|;
operator|*
name|inherited_props
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Do we still have anything to ask the repository about? */
if|if
condition|(
operator|!
name|local_explicit_props
operator|||
operator|!
name|local_iprops
condition|)
block|{
name|svn_client__pathrev_t
modifier|*
name|loc
decl_stmt|;
comment|/* Get an RA plugin for this filesystem object. */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|loc
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local_explicit_props
condition|)
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remote_propget
argument_list|(
operator|!
name|local_explicit_props
condition|?
operator|*
name|props
else|:
name|NULL
argument_list|,
operator|!
name|local_iprops
condition|?
name|inherited_props
else|:
name|NULL
argument_list|,
name|propname
argument_list|,
name|loc
operator|->
name|url
argument_list|,
literal|""
argument_list|,
name|kind
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
name|ra_session
argument_list|,
name|depth
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|revnum
operator|=
name|loc
operator|->
name|rev
expr_stmt|;
block|}
block|}
if|if
condition|(
name|actual_revnum
condition|)
operator|*
name|actual_revnum
operator|=
name|revnum
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_revprop_get
parameter_list|(
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|propval
parameter_list|,
specifier|const
name|char
modifier|*
name|URL
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|set_rev
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Open an RA session for the URL. Note that we don't have a local      directory, nor a place to put temp files. */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|URL
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resolve the revision into something real, and return that to the      caller as well. */
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
name|set_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|ra_session
argument_list|,
name|revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The actual RA call. */
name|err
operator|=
name|svn_ra_rev_prop
argument_list|(
name|ra_session
argument_list|,
operator|*
name|set_rev
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Close RA session */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Call RECEIVER for the given PATH and its PROP_HASH and/or  * INHERITED_PROPERTIES.  *  * If PROP_HASH is null or has zero count or INHERITED_PROPERTIES is null,  * then do nothing.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|call_receiver
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_hash_t
modifier|*
name|prop_hash
parameter_list|,
name|apr_array_header_t
modifier|*
name|inherited_properties
parameter_list|,
name|svn_proplist_receiver2_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|(
name|prop_hash
operator|&&
name|apr_hash_count
argument_list|(
name|prop_hash
argument_list|)
operator|)
operator|||
name|inherited_properties
condition|)
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|receiver_baton
argument_list|,
name|path
argument_list|,
name|prop_hash
argument_list|,
name|inherited_properties
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for the remote case of svn_client_proplist.  *  * If GET_EXPLICIT_PROPS is true, then call RECEIVER for paths at or under  * "TARGET_PREFIX/TARGET_RELATIVE@REVNUM" (obtained using RA_SESSION) which  * have regular properties.  If GET_TARGET_INHERITED_PROPS is true, then send  * the target's inherited properties to the callback.  *  * The 'path' and keys for 'prop_hash' and 'inherited_prop' arguments to  * RECEIVER are all URLs.  *  * RESULT_POOL is used to allocated the 'path', 'prop_hash', and  * 'inherited_prop' arguments to RECEIVER.  SCRATCH_POOL is used for all  * other (temporary) allocations.  *  * KIND is the kind of the node at "TARGET_PREFIX/TARGET_RELATIVE".  *  * If the target is a directory, only fetch properties for the files  * and directories at depth DEPTH.  DEPTH has not effect on inherited  * properties.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remote_proplist
parameter_list|(
specifier|const
name|char
modifier|*
name|target_prefix
parameter_list|,
specifier|const
name|char
modifier|*
name|target_relative
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_revnum_t
name|revnum
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_boolean_t
name|get_explicit_props
parameter_list|,
name|svn_boolean_t
name|get_target_inherited_props
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_proplist_receiver2_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|dirents
decl_stmt|;
name|apr_hash_t
modifier|*
name|prop_hash
init|=
name|NULL
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_full_url
init|=
name|svn_path_url_add_component2
argument_list|(
name|target_prefix
argument_list|,
name|target_relative
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
decl_stmt|;
comment|/* Note that we pass only the SCRATCH_POOL to svn_ra_get[dir*|file*] because      we'll be filtering out non-regular properties from PROP_HASH before we      return. */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|ra_session
argument_list|,
operator|(
name|depth
operator|>
name|svn_depth_empty
operator|)
condition|?
operator|&
name|dirents
else|:
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_hash
argument_list|,
name|target_relative
argument_list|,
name|revnum
argument_list|,
name|SVN_DIRENT_KIND
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
name|target_relative
argument_list|,
name|revnum
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|prop_hash
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNKNOWN_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown node kind for '%s'"
argument_list|)
argument_list|,
name|target_full_url
argument_list|)
return|;
block|}
if|if
condition|(
name|get_target_inherited_props
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_inherited_props
argument_list|(
name|ra_session
argument_list|,
operator|&
name|inherited_props
argument_list|,
name|target_relative
argument_list|,
name|revnum
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__iprop_relpaths_to_urls
argument_list|(
name|inherited_props
argument_list|,
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inherited_props
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|get_explicit_props
condition|)
name|prop_hash
operator|=
name|NULL
expr_stmt|;
else|else
block|{
comment|/* Filter out non-regular properties, since the RA layer returns all          kinds.  Copy regular properties keys/vals from the prop_hash          allocated in SCRATCH_POOL to the "final" hash allocated in          RESULT_POOL. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|prop_hash
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|klen
init|=
name|svn__apr_hash_index_klen
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_prop_kind_t
name|prop_kind
decl_stmt|;
name|prop_kind
operator|=
name|svn_property_kind2
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_kind
operator|!=
name|svn_prop_regular_kind
condition|)
block|{
name|apr_hash_set
argument_list|(
name|prop_hash
argument_list|,
name|name
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|SVN_ERR
argument_list|(
name|call_receiver
argument_list|(
name|target_full_url
argument_list|,
name|prop_hash
argument_list|,
name|inherited_props
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|>
name|svn_depth_empty
operator|&&
name|get_explicit_props
operator|&&
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
operator|&&
operator|(
name|apr_hash_count
argument_list|(
name|dirents
argument_list|)
operator|>
literal|0
operator|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|dirents
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|this_name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_dirent_t
modifier|*
name|this_ent
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_target_relative
decl_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|new_target_relative
operator|=
name|svn_relpath_join
argument_list|(
name|target_relative
argument_list|,
name|this_name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_ent
operator|->
name|kind
operator|==
name|svn_node_file
operator|||
name|depth
operator|>
name|svn_depth_files
condition|)
block|{
name|svn_depth_t
name|depth_below_here
init|=
name|depth
decl_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|depth_below_here
operator|=
name|svn_depth_empty
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remote_proplist
argument_list|(
name|target_prefix
argument_list|,
name|new_target_relative
argument_list|,
name|this_ent
operator|->
name|kind
argument_list|,
name|revnum
argument_list|,
name|ra_session
argument_list|,
name|TRUE
comment|/* get_explicit_props */
argument_list|,
name|FALSE
comment|/* get_target_inherited_props */
argument_list|,
name|depth_below_here
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for recursive_proplist_receiver(). */
end_comment

begin_struct
struct|struct
name|recursive_proplist_receiver_baton
block|{
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
comment|/* Working copy context. */
name|svn_proplist_receiver2_t
name|wrapped_receiver
decl_stmt|;
comment|/* Proplist receiver to call. */
name|void
modifier|*
name|wrapped_receiver_baton
decl_stmt|;
comment|/* Baton for the proplist receiver. */
name|apr_array_header_t
modifier|*
name|iprops
decl_stmt|;
comment|/* Anchor, anchor_abspath pair for converting to relative paths */
specifier|const
name|char
modifier|*
name|anchor
decl_stmt|;
specifier|const
name|char
modifier|*
name|anchor_abspath
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An implementation of svn_wc__proplist_receiver_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recursive_proplist_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|recursive_proplist_receiver_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|iprops
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|b
operator|->
name|iprops
operator|&&
operator|!
name|strcmp
argument_list|(
name|local_abspath
argument_list|,
name|b
operator|->
name|anchor_abspath
argument_list|)
condition|)
block|{
comment|/* Report iprops with the properties for the anchor */
name|iprops
operator|=
name|b
operator|->
name|iprops
expr_stmt|;
name|b
operator|->
name|iprops
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|iprops
condition|)
block|{
comment|/* No report for the root?          Report iprops anyway */
name|SVN_ERR
argument_list|(
name|b
operator|->
name|wrapped_receiver
argument_list|(
name|b
operator|->
name|wrapped_receiver_baton
argument_list|,
name|b
operator|->
name|anchor
condition|?
name|b
operator|->
name|anchor
else|:
name|b
operator|->
name|anchor_abspath
argument_list|,
name|NULL
comment|/* prop_hash */
argument_list|,
name|b
operator|->
name|iprops
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|iprops
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Attempt to convert absolute paths to relative paths for    * presentation purposes, if needed. */
if|if
condition|(
name|b
operator|->
name|anchor
operator|&&
name|b
operator|->
name|anchor_abspath
condition|)
block|{
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|b
operator|->
name|anchor
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|b
operator|->
name|anchor_abspath
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
name|path
operator|=
name|local_abspath
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|b
operator|->
name|wrapped_receiver
argument_list|(
name|b
operator|->
name|wrapped_receiver_baton
argument_list|,
name|path
argument_list|,
name|props
argument_list|,
name|iprops
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_client_proplist4 when retrieving properties and/or    inherited properties from the repository.  Except as noted below,    all arguments are as per svn_client_proplist4.     GET_EXPLICIT_PROPS controls if explicit props are retrieved. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_remote_props
parameter_list|(
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|get_explicit_props
parameter_list|,
name|svn_boolean_t
name|get_target_inherited_props
parameter_list|,
name|svn_proplist_receiver2_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_opt_revision_t
name|new_operative_rev
decl_stmt|;
name|svn_opt_revision_t
name|new_peg_rev
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|loc
decl_stmt|;
comment|/* Peg or operative revisions may be WC specific for      PATH_OR_URL's explicit props, but still require us to      contact the repository for the inherited properties. */
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
operator|||
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|origin_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_uuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_root_abspath
decl_stmt|;
name|svn_boolean_t
name|is_copy
decl_stmt|;
comment|/* Avoid assertion on the next line when somebody accidentally asks for          a working copy revision on a URL */
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_VERSIONED_PATH_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
operator|&
name|is_copy
argument_list|,
operator|&
name|origin_rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root_url
argument_list|,
operator|&
name|repos_uuid
argument_list|,
operator|&
name|copy_root_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
comment|/* scan_deleted */
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
block|{
name|path_or_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|resolved_peg_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|resolved_peg_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_peg_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|new_peg_rev
operator|.
name|value
operator|.
name|number
operator|=
name|resolved_peg_rev
expr_stmt|;
name|peg_revision
operator|=
operator|&
name|new_peg_rev
expr_stmt|;
block|}
if|if
condition|(
name|SVN_CLIENT__REVKIND_NEEDS_WC
argument_list|(
name|revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|resolved_operative_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|resolved_operative_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_operative_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|new_operative_rev
operator|.
name|value
operator|.
name|number
operator|=
name|resolved_operative_rev
expr_stmt|;
name|revision
operator|=
operator|&
name|new_operative_rev
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* PATH_OR_URL doesn't exist in the repository, so there are                      obviously not inherited props to be found there. If we                      aren't looking for explicit props then we're done. */
if|if
condition|(
operator|!
name|get_explicit_props
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
block|}
comment|/* Get an RA session for this URL. */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|loc
argument_list|,
name|path_or_url
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|remote_proplist
argument_list|(
name|loc
operator|->
name|url
argument_list|,
literal|""
argument_list|,
name|kind
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
name|ra_session
argument_list|,
name|get_explicit_props
argument_list|,
name|get_target_inherited_props
argument_list|,
name|depth
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_client_proplist4 when retrieving properties and    possibly inherited properties from the WC.  All arguments are as    per svn_client_proplist4. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_local_props
parameter_list|(
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_boolean_t
name|get_target_inherited_props
parameter_list|,
name|svn_proplist_receiver2_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|pristine
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_hash_t
modifier|*
name|changelist_hash
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|iprops
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|pristine
operator|=
operator|(
operator|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_committed
operator|)
operator|||
operator|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_base
operator|)
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pristine
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
operator|||
name|kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* svn uses SVN_ERR_UNVERSIONED_RESOURCE as warning only          for this function. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNVERSIONED_RESOURCE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|get_target_inherited_props
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_iprops
argument_list|(
operator|&
name|iprops
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_get_repos_root
argument_list|(
operator|&
name|repos_root_url
argument_list|,
name|NULL
argument_list|,
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__iprop_relpaths_to_urls
argument_list|(
name|iprops
argument_list|,
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changelists
operator|&&
name|changelists
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|svn_hash_from_cstring_keys
argument_list|(
operator|&
name|changelist_hash
argument_list|,
name|changelists
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch, recursively or not. */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|struct
name|recursive_proplist_receiver_baton
name|rb
decl_stmt|;
name|rb
operator|.
name|wc_ctx
operator|=
name|ctx
operator|->
name|wc_ctx
expr_stmt|;
name|rb
operator|.
name|wrapped_receiver
operator|=
name|receiver
expr_stmt|;
name|rb
operator|.
name|wrapped_receiver_baton
operator|=
name|receiver_baton
expr_stmt|;
name|rb
operator|.
name|iprops
operator|=
name|iprops
expr_stmt|;
name|rb
operator|.
name|anchor_abspath
operator|=
name|local_abspath
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|path_or_url
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|rb
operator|.
name|anchor
operator|=
name|path_or_url
expr_stmt|;
block|}
else|else
block|{
name|rb
operator|.
name|anchor
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc__prop_list_recursive
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|depth
argument_list|,
name|pristine
argument_list|,
name|changelists
argument_list|,
name|recursive_proplist_receiver
argument_list|,
operator|&
name|rb
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|.
name|iprops
condition|)
block|{
comment|/* We didn't report for the root. Report iprops anyway */
name|SVN_ERR
argument_list|(
name|call_receiver
argument_list|(
name|path_or_url
argument_list|,
name|NULL
comment|/* props */
argument_list|,
name|rb
operator|.
name|iprops
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|svn_wc__changelist_match
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|changelist_hash
argument_list|,
name|scratch_pool
argument_list|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
if|if
condition|(
name|pristine
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_get_pristine_props
argument_list|(
operator|&
name|props
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc_prop_list2
argument_list|(
operator|&
name|props
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_UNEXPECTED_STATUS
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* As svn_wc_prop_list2() doesn't return NULL for locally-deleted                    let's do that here.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|call_receiver
argument_list|(
name|path_or_url
argument_list|,
name|props
argument_list|,
name|iprops
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_proplist4
parameter_list|(
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|changelists
parameter_list|,
name|svn_boolean_t
name|get_target_inherited_props
parameter_list|,
name|svn_proplist_receiver2_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|local_explicit_props
decl_stmt|;
name|svn_boolean_t
name|local_iprops
decl_stmt|;
name|peg_revision
operator|=
name|svn_cl__rev_default_to_head_or_working
argument_list|(
name|peg_revision
argument_list|,
name|path_or_url
argument_list|)
expr_stmt|;
name|revision
operator|=
name|svn_cl__rev_default_to_peg
argument_list|(
name|revision
argument_list|,
name|peg_revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth
operator|=
name|svn_depth_empty
expr_stmt|;
comment|/* Are explicit props available locally? */
name|local_explicit_props
operator|=
operator|(
operator|!
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
operator|&&
name|SVN_CLIENT__REVKIND_IS_LOCAL_TO_WC
argument_list|(
name|peg_revision
operator|->
name|kind
argument_list|)
operator|&&
name|SVN_CLIENT__REVKIND_IS_LOCAL_TO_WC
argument_list|(
name|revision
operator|->
name|kind
argument_list|)
operator|)
expr_stmt|;
comment|/* If we want iprops are they available locally? */
name|local_iprops
operator|=
operator|(
name|get_target_inherited_props
comment|/* We want iprops */
operator|&&
name|local_explicit_props
comment|/* No local explicit props means no local iprops. */
operator|&&
operator|(
name|peg_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
operator|||
name|peg_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|&&
operator|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
operator|||
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|get_target_inherited_props
operator|&&
operator|!
name|local_iprops
operator|)
operator|||
operator|!
name|local_explicit_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_remote_props
argument_list|(
name|path_or_url
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
operator|!
name|local_explicit_props
argument_list|,
operator|(
name|get_target_inherited_props
operator|&&
operator|!
name|local_iprops
operator|)
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|local_explicit_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_local_props
argument_list|(
name|path_or_url
argument_list|,
name|revision
argument_list|,
name|depth
argument_list|,
name|changelists
argument_list|,
name|local_iprops
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_revprop_list
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|URL
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|set_rev
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Open an RA session for the URL. Note that we don't have a local      directory, nor a place to put temp files. */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|URL
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Resolve the revision into something real, and return that to the      caller as well. */
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
name|set_rev
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|ra_session
argument_list|,
name|revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The actual RA call. */
name|err
operator|=
name|svn_ra_rev_proplist
argument_list|(
name|ra_session
argument_list|,
operator|*
name|set_rev
argument_list|,
operator|&
name|proplist
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|proplist
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Close RA session */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

end_unit

