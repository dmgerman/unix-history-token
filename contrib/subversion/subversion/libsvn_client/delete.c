begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * delete.c:  wrappers around wc delete functionality.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Baton for find_undeletables */
end_comment

begin_struct
struct|struct
name|can_delete_baton_t
block|{
specifier|const
name|char
modifier|*
name|root_abspath
decl_stmt|;
name|svn_boolean_t
name|target_missing
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* An svn_wc_status_func4_t callback function for finding    status structures which are not safely deletable. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_undeletables
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_missing
condition|)
block|{
name|struct
name|can_delete_baton_t
modifier|*
name|cdt
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cdt
operator|->
name|root_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|==
literal|0
condition|)
name|cdt
operator|->
name|target_missing
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Check for error-ful states. */
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_obstructed
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is in the way of the resource "
literal|"actually under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
name|status
operator|->
name|versioned
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNVERSIONED_RESOURCE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not under version control"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_added
operator|||
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_replaced
operator|)
operator|&&
name|status
operator|->
name|text_status
operator|==
name|svn_wc_status_normal
operator|&&
operator|(
name|status
operator|->
name|prop_status
operator|==
name|svn_wc_status_normal
operator|||
name|status
operator|->
name|prop_status
operator|==
name|svn_wc_status_none
operator|)
condition|)
block|{
comment|/* Unmodified copy. Go ahead, remove it */
block|}
elseif|else
if|if
condition|(
name|status
operator|->
name|node_status
operator|!=
name|svn_wc_status_normal
operator|&&
name|status
operator|->
name|node_status
operator|!=
name|svn_wc_status_deleted
operator|&&
name|status
operator|->
name|node_status
operator|!=
name|svn_wc_status_missing
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_MODIFIED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' has local modifications -- commit or "
literal|"revert them first"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check whether LOCAL_ABSPATH is an external and raise an error if it is.     A file external should not be deleted since the file external is    implemented as a switched file and it would delete the file the    file external is switched to, which is not the behavior the user    would probably want.     A directory external should not be deleted since it is the root    of a different working copy. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_external
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|external_kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|defining_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__read_external_info
argument_list|(
operator|&
name|external_kind
argument_list|,
operator|&
name|defining_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|external_kind
operator|!=
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_CANNOT_DELETE_FILE_EXTERNAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot remove the external at '%s'; "
literal|"please edit or delete the svn:externals "
literal|"property on '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|defining_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that the path can be deleted without losing stuff,    i.e. ensure that there are no modified or unversioned resources    under PATH.  This is similar to checking the output of the status    command.  CTX is used for the client's config options.  POOL is    used for all temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|can_delete_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|target_missing
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|ignores
decl_stmt|;
name|struct
name|can_delete_baton_t
name|cdt
decl_stmt|;
comment|/* Use an infinite-depth status check to see if there's anything in      or under PATH which would make it unsafe for deletion.  The      status callback function find_undeletables() makes the      determination, returning an error if it finds anything that shouldn't      be deleted. */
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|ignores
argument_list|,
name|ctx
operator|->
name|config
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|cdt
operator|.
name|root_abspath
operator|=
name|local_abspath
expr_stmt|;
name|cdt
operator|.
name|target_missing
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_walk_status
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|FALSE
comment|/* get_all */
argument_list|,
name|FALSE
comment|/* no_ignore */
argument_list|,
name|FALSE
comment|/* ignore_text_mod */
argument_list|,
name|ignores
argument_list|,
name|find_undeletables
argument_list|,
operator|&
name|cdt
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_missing
condition|)
operator|*
name|target_missing
operator|=
name|cdt
operator|.
name|target_missing
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|path_driver_cb_func
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|callback_baton
decl_stmt|;
operator|*
name|dir_baton
operator|=
name|NULL
expr_stmt|;
return|return
name|editor
operator|->
name|delete_entry
argument_list|(
name|path
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|parent_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|single_repos_delete
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|base_uri
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|relpaths
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|apr_hash_t
modifier|*
name|commit_revprops
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_msg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Create new commit items and add them to the array. */
if|if
condition|(
name|SVN_CLIENT__HAS_LOG_MSG_FUNC
argument_list|(
name|ctx
argument_list|)
condition|)
block|{
name|svn_client_commit_item3_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|commit_items
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|relpaths
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|item
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|relpaths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|relpaths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|item
operator|=
name|svn_client_commit_item3_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|base_uri
argument_list|,
name|relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|item
operator|->
name|state_flags
operator|=
name|SVN_CLIENT_COMMIT_ITEM_DELETE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|commit_items
argument_list|,
name|svn_client_commit_item3_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__get_log_msg
argument_list|(
operator|&
name|log_msg
argument_list|,
operator|&
name|tmp_file
argument_list|,
name|commit_items
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|log_msg
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|log_msg
operator|=
literal|""
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_revprop_table
argument_list|(
operator|&
name|commit_revprops
argument_list|,
name|revprop_table
argument_list|,
name|log_msg
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch RA commit editor */
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|ra_session
argument_list|,
name|svn_client__get_shim_callbacks
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|commit_revprops
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
comment|/* No lock tokens */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the path-based editor driver. */
name|err
operator|=
name|svn_delta_path_driver2
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|relpaths
argument_list|,
name|TRUE
argument_list|,
name|path_driver_cb_func
argument_list|,
operator|(
name|void
operator|*
operator|)
name|editor
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
comment|/* Close the edit. */
return|return
name|svn_error_trace
argument_list|(
name|editor
operator|->
name|close_edit
argument_list|(
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Structure for tracking remote delete targets associated with a    specific repository. */
end_comment

begin_struct
struct|struct
name|repos_deletables_t
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|apr_array_header_t
modifier|*
name|target_uris
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_urls_multi_repos
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|uris
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|deletables
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Create a hash mapping repository root URLs -> repos_deletables_t *      structures.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|uris
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|uri
init|=
name|APR_ARRAY_IDX
argument_list|(
name|uris
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|struct
name|repos_deletables_t
modifier|*
name|repos_deletables
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|deletables
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|repos_root
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
block|{
comment|/* Great!  We've found another URI underneath this                  session.  We'll pick out the related RA session for                  use later, store the new target, and move on.  */
name|repos_deletables
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|repos_deletables
operator|->
name|target_uris
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|uri
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we haven't created a repos_deletable structure for this          delete target, we need to do.  That means opening up an RA          session and initializing its targets list.  */
if|if
condition|(
operator|!
name|repos_deletables
condition|)
block|{
name|svn_ra_session_t
modifier|*
name|ra_session
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
name|apr_array_header_t
modifier|*
name|target_uris
decl_stmt|;
comment|/* Open an RA session to (ultimately) the root of the              repository in which URI is found.  */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|uri
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|uri
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Make a new relpaths list for this repository, and add              this URI's relpath to it. */
name|target_uris
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|target_uris
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|uri
argument_list|)
expr_stmt|;
comment|/* Build our repos_deletables_t item and stash it in the              hash. */
name|repos_deletables
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|repos_deletables
argument_list|)
argument_list|)
expr_stmt|;
name|repos_deletables
operator|->
name|ra_session
operator|=
name|ra_session
expr_stmt|;
name|repos_deletables
operator|->
name|target_uris
operator|=
name|target_uris
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|deletables
argument_list|,
name|repos_root
argument_list|,
name|repos_deletables
argument_list|)
expr_stmt|;
block|}
comment|/* If we get here, we should have been able to calculate a          repos_relpath for this URI.  Let's make sure.  (We return an          RA error code otherwise for 1.6 compatibility.)  */
if|if
condition|(
operator|!
name|repos_relpath
operator|||
operator|!
operator|*
name|repos_relpath
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
literal|"URL '%s' not within a repository"
argument_list|,
name|uri
argument_list|)
return|;
comment|/* Now, test to see if the thing actually exists in HEAD. */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|repos_deletables
operator|->
name|ra_session
argument_list|,
name|repos_relpath
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
literal|"URL '%s' does not exist"
argument_list|,
name|uri
argument_list|)
return|;
block|}
comment|/* Now we iterate over the DELETABLES hash, issuing a commit for      each repository with its associated collected targets. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|deletables
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|struct
name|repos_deletables_t
modifier|*
name|repos_deletables
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_uri
decl_stmt|;
name|apr_array_header_t
modifier|*
name|target_relpaths
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* We want to anchor the commit on the longest common path          across the targets for this one repository.  If, however, one          of our targets is that longest common path, we need instead          anchor the commit on that path's immediate parent.  Because          we're asking svn_uri_condense_targets() to remove          redundancies, this situation should be detectable by their          being returned either a) only a single, empty-path, target          relpath, or b) no target relpaths at all.  */
name|SVN_ERR
argument_list|(
name|svn_uri_condense_targets
argument_list|(
operator|&
name|base_uri
argument_list|,
operator|&
name|target_relpaths
argument_list|,
name|repos_deletables
operator|->
name|target_uris
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|svn_path_is_empty
argument_list|(
name|base_uri
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_relpaths
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|target_relpath
decl_stmt|;
name|svn_uri_split
argument_list|(
operator|&
name|base_uri
argument_list|,
operator|&
name|target_relpath
argument_list|,
name|base_uri
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|target_relpaths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target_relpath
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|target_relpaths
operator|->
name|nelts
operator|==
literal|1
operator|)
operator|&&
operator|(
name|svn_path_is_empty
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|target_relpaths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|target_relpath
decl_stmt|;
name|svn_uri_split
argument_list|(
operator|&
name|base_uri
argument_list|,
operator|&
name|target_relpath
argument_list|,
name|base_uri
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|target_relpaths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target_relpath
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|repos_deletables
operator|->
name|ra_session
argument_list|,
name|base_uri
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|single_repos_delete
argument_list|(
name|repos_deletables
operator|->
name|ra_session
argument_list|,
name|base_uri
argument_list|,
name|target_relpaths
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__wc_delete
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|keep_local
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|target_missing
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_external
argument_list|(
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|keep_local
condition|)
comment|/* Verify that there are no "awkward" files */
name|SVN_ERR
argument_list|(
name|can_delete_node
argument_list|(
operator|&
name|target_missing
argument_list|,
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
comment|/* Mark the entry for commit deletion and perform wc deletion */
return|return
name|svn_error_trace
argument_list|(
name|svn_wc_delete4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|keep_local
operator|||
name|target_missing
comment|/*keep_local */
argument_list|,
name|TRUE
comment|/* delete_unversioned */
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__wc_delete_many
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|targets
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|keep_local
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|has_non_missing
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_external
argument_list|(
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|force
operator|&&
operator|!
name|keep_local
condition|)
block|{
name|svn_boolean_t
name|missing
decl_stmt|;
comment|/* Verify that there are no "awkward" files */
name|SVN_ERR
argument_list|(
name|can_delete_node
argument_list|(
operator|&
name|missing
argument_list|,
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|missing
condition|)
name|has_non_missing
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
name|has_non_missing
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dry_run
condition|)
block|{
comment|/* Mark the entry for commit deletion and perform wc deletion */
comment|/* If none of the targets exists, pass keep local TRUE, to avoid          deleting case-different files. Detecting this in the generic case          from the delete code is expensive */
return|return
name|svn_error_trace
argument_list|(
name|svn_wc__delete_many
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|targets
argument_list|,
name|keep_local
operator|||
operator|!
name|has_non_missing
argument_list|,
name|TRUE
comment|/* delete_unversioned_target */
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_delete4
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_boolean_t
name|keep_local
parameter_list|,
specifier|const
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|commit_callback
parameter_list|,
name|void
modifier|*
name|commit_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_url
decl_stmt|;
if|if
condition|(
operator|!
name|paths
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_client__assert_homogeneous_target_type
argument_list|(
name|paths
argument_list|)
argument_list|)
expr_stmt|;
name|is_url
operator|=
name|svn_path_is_url
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|delete_urls_multi_repos
argument_list|(
name|paths
argument_list|,
name|revprop_table
argument_list|,
name|commit_callback
argument_list|,
name|commit_baton
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|apr_hash_t
modifier|*
name|wcroots
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|is_new_target
decl_stmt|;
comment|/* Build a map of wcroots and targets within them. */
name|wcroots
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|wcroot_abspath
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* See if the user wants us to stop. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__get_wcroot
argument_list|(
operator|&
name|wcroot_abspath
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|targets
operator|=
name|svn_hash_gets
argument_list|(
name|wcroots
argument_list|,
name|wcroot_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|==
name|NULL
condition|)
block|{
name|targets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|wcroots
argument_list|,
name|wcroot_abspath
argument_list|,
name|targets
argument_list|)
expr_stmt|;
block|}
comment|/* Make sure targets are unique. */
name|is_new_target
operator|=
name|TRUE
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|targets
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|local_abspath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|is_new_target
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|is_new_target
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|local_abspath
expr_stmt|;
block|}
comment|/* Delete the targets from each working copy in turn. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|wcroots
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|root_abspath
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|targets
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_condense_targets
argument_list|(
operator|&
name|root_abspath
argument_list|,
name|NULL
argument_list|,
name|targets
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|svn_client__wc_delete_many
argument_list|(
name|targets
argument_list|,
name|force
argument_list|,
name|FALSE
argument_list|,
name|keep_local
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|root_abspath
argument_list|,
name|TRUE
comment|/* lock_anchor */
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

