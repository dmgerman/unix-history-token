begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * export.c:  export a tree.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes. ***/
end_comment

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_delta_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|ENABLE_EV2_IMPL
end_ifndef

begin_define
define|#
directive|define
name|ENABLE_EV2_IMPL
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Add EXTERNALS_PROP_VAL for the export destination path PATH to    TRAVERSAL_INFO.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_externals
parameter_list|(
name|apr_hash_t
modifier|*
name|externals
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|externals_prop_val
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|apr_hash_pool_get
argument_list|(
name|externals
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
if|if
condition|(
operator|!
name|externals_prop_val
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|externals
argument_list|,
name|local_abspath
argument_list|,
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|externals_prop_val
operator|->
name|data
argument_list|,
name|externals_prop_val
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function that gets the eol style and optionally overrides the    EOL marker for files marked as native with the EOL marker matching    the string specified in requested_value which is of the same format    as the svn:eol-style property values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_eol_style
parameter_list|(
name|svn_subst_eol_style_t
modifier|*
name|style
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|eol
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
specifier|const
name|char
modifier|*
name|requested_value
parameter_list|)
block|{
name|svn_subst_eol_style_from_value
argument_list|(
name|style
argument_list|,
name|eol
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|requested_value
operator|&&
operator|*
name|style
operator|==
name|svn_subst_eol_style_native
condition|)
block|{
name|svn_subst_eol_style_t
name|requested_style
decl_stmt|;
specifier|const
name|char
modifier|*
name|requested_eol
decl_stmt|;
name|svn_subst_eol_style_from_value
argument_list|(
operator|&
name|requested_style
argument_list|,
operator|&
name|requested_eol
argument_list|,
name|requested_value
argument_list|)
expr_stmt|;
if|if
condition|(
name|requested_style
operator|==
name|svn_subst_eol_style_fixed
condition|)
operator|*
name|eol
operator|=
name|requested_eol
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_IO_UNKNOWN_EOL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a valid EOL value"
argument_list|)
argument_list|,
name|requested_value
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If *APPENDABLE_DIRENT_P represents an existing directory, then append  * to it the basename of BASENAME_OF and return the result in  * *APPENDABLE_DIRENT_P.  The kind of BASENAME_OF is either dirent or uri,  * as given by IS_URI.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|append_basename_if_dir
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|appendable_dirent_p
parameter_list|,
specifier|const
name|char
modifier|*
name|basename_of
parameter_list|,
name|svn_boolean_t
name|is_uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|local_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_resolved_path
argument_list|(
operator|*
name|appendable_dirent_p
argument_list|,
operator|&
name|local_kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_kind
operator|==
name|svn_node_dir
condition|)
block|{
specifier|const
name|char
modifier|*
name|base_name
decl_stmt|;
if|if
condition|(
name|is_uri
condition|)
name|base_name
operator|=
name|svn_uri_basename
argument_list|(
name|basename_of
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|base_name
operator|=
name|svn_dirent_basename
argument_list|(
name|basename_of
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|appendable_dirent_p
operator|=
name|svn_dirent_join
argument_list|(
operator|*
name|appendable_dirent_p
argument_list|,
name|base_name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make an unversioned copy of the versioned file at FROM_ABSPATH.  Copy it  * to the destination path TO_ABSPATH.  *  * If REVISION is svn_opt_revision_working, copy the working version,  * otherwise copy the base version.  *  * Expand the file's keywords according to the source file's 'svn:keywords'  * property, if present.  If copying a locally modified working version,  * append 'M' to the revision number and use '(local)' for the author.  *  * Translate the file's line endings according to the source file's  * 'svn:eol-style' property, if present.  If NATIVE_EOL is not NULL, use it  * in place of the native EOL style.  Throw an error if the source file has  * inconsistent line endings and EOL translation is attempted.  *  * Set the destination file's modification time to the source file's  * modification time if copying the working version and the working version  * is locally modified; otherwise set it to the versioned file's last  * changed time.  *  * Set the destination file's 'executable' flag according to the source  * file's 'svn:executable' property.  */
end_comment

begin_comment
comment|/* baton for export_node */
end_comment

begin_struct
struct|struct
name|export_info_baton
block|{
specifier|const
name|char
modifier|*
name|to_path
decl_stmt|;
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
decl_stmt|;
name|svn_boolean_t
name|ignore_keywords
decl_stmt|;
name|svn_boolean_t
name|overwrite
decl_stmt|;
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|native_eol
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|origin_abspath
decl_stmt|;
name|svn_boolean_t
name|exported
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Export a file or directory. Implements svn_wc_status_func4_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|export_node
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|export_info_baton
modifier|*
name|eib
init|=
name|baton
decl_stmt|;
name|svn_wc_context_t
modifier|*
name|wc_ctx
init|=
name|eib
operator|->
name|wc_ctx
decl_stmt|;
name|apr_hash_t
modifier|*
name|kw
init|=
name|NULL
decl_stmt|;
name|svn_subst_eol_style_t
name|style
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_string_t
modifier|*
name|eol_style
decl_stmt|,
modifier|*
name|keywords
decl_stmt|,
modifier|*
name|executable
decl_stmt|,
modifier|*
name|special
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|local_mod
init|=
name|FALSE
decl_stmt|;
name|apr_time_t
name|tm
decl_stmt|;
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|svn_stream_t
modifier|*
name|dst_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|dst_tmp
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_abspath
init|=
name|svn_dirent_join
argument_list|(
name|eib
operator|->
name|to_path
argument_list|,
name|svn_dirent_skip_ancestor
argument_list|(
name|eib
operator|->
name|origin_abspath
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|eib
operator|->
name|exported
operator|=
name|TRUE
expr_stmt|;
comment|/* Don't export 'deleted' files and directories unless it's a      revision other than WORKING.  These files and directories      don't really exist in WORKING. */
if|if
condition|(
name|eib
operator|->
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
operator|&&
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_deleted
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|status
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_fileperms_t
name|perm
init|=
name|APR_OS_DEFAULT
decl_stmt|;
comment|/* Try to make the new directory.  If this fails because the          directory already exists, check our FORCE flag to see if we          care. */
comment|/* Keep the source directory's permissions if applicable.          Skip retrieving the umask on windows. Apr does not implement setting          filesystem privileges on Windows.          Retrieving the file permissions with APR_FINFO_PROT | APR_FINFO_OWNER          is documented to be 'incredibly expensive' */
ifndef|#
directive|ifndef
name|WIN32
if|if
condition|(
name|eib
operator|->
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
condition|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|local_abspath
argument_list|,
name|APR_FINFO_PROT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|perm
operator|=
name|finfo
operator|.
name|protection
expr_stmt|;
block|}
endif|#
directive|endif
name|err
operator|=
name|svn_io_dir_make
argument_list|(
name|to_abspath
argument_list|,
name|perm
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
if|if
condition|(
operator|!
name|eib
operator|->
name|overwrite
condition|)
name|SVN_ERR_W
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Destination directory exists, and will not be "
literal|"overwritten unless forced"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eib
operator|->
name|notify_func
operator|&&
operator|(
name|strcmp
argument_list|(
name|eib
operator|->
name|origin_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|to_abspath
argument_list|,
name|svn_wc_notify_update_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
call|(
name|eib
operator|->
name|notify_func
call|)
argument_list|(
name|eib
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|eib
operator|->
name|origin_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Skip file externals if they are a descendant of the export,      BUT NOT if we are explictly exporting the file external. */
if|if
condition|(
name|status
operator|->
name|file_external
operator|&&
name|strcmp
argument_list|(
name|eib
operator|->
name|origin_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Produce overwrite errors for the export root */
if|if
condition|(
name|strcmp
argument_list|(
name|local_abspath
argument_list|,
name|eib
operator|->
name|origin_abspath
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_node_kind_t
name|to_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|to_abspath
argument_list|,
operator|&
name|to_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|to_kind
operator|==
name|svn_node_file
operator|||
name|to_kind
operator|==
name|svn_node_unknown
operator|)
operator|&&
operator|!
name|eib
operator|->
name|overwrite
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination file '%s' exists, and "
literal|"will not be overwritten unless forced"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|to_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|to_kind
operator|==
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination '%s' exists. Cannot "
literal|"overwrite directory with non-directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|to_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|eib
operator|->
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_working
condition|)
block|{
comment|/* Only export 'added' files when the revision is WORKING. This is not          WORKING, so skip the 'added' files, since they didn't exist          in the BASE revision and don't have an associated text-base.           'replaced' files are technically the same as 'added' files.          ### TODO: Handle replaced nodes properly.          ###       svn_opt_revision_base refers to the "new"          ###       base of the node. That means, if a node is locally          ###       replaced, export skips this node, as if it was locally          ###       added, because svn_opt_revision_base refers to the base          ###       of the added node, not to the node that was deleted.          ###       In contrast, when the node is copied-here or moved-here,          ###       the copy/move source's content will be exported.          ###       It is currently not possible to export the revert-base          ###       when a node is locally replaced. We need a new          ###       svn_opt_revision_ enum value for proper distinction          ###       between revert-base and commit-base.           Copied-/moved-here nodes have a base, so export both added and          replaced files when they involve a copy-/move-here.           We get all this for free from evaluating SOURCE == NULL:        */
name|SVN_ERR
argument_list|(
name|svn_wc_get_pristine_contents2
argument_list|(
operator|&
name|source
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_pristine_props
argument_list|(
operator|&
name|props
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ### hmm. this isn't always a specialfile. this will simply open          ### the file readonly if it is a regular file. */
name|SVN_ERR
argument_list|(
name|svn_subst_read_specialfile
argument_list|(
operator|&
name|source
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_prop_list2
argument_list|(
operator|&
name|props
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|->
name|node_status
operator|!=
name|svn_wc_status_normal
condition|)
name|local_mod
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* We can early-exit if we're creating a special file. */
name|special
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|special
operator|!=
name|NULL
condition|)
block|{
comment|/* Create the destination as a special file, and copy the source          details into the destination stream. */
comment|/* ### And forget the notification */
name|SVN_ERR
argument_list|(
name|svn_subst_create_specialfile
argument_list|(
operator|&
name|dst_stream
argument_list|,
name|to_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_copy3
argument_list|(
name|source
argument_list|,
name|dst_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|eol_style
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
expr_stmt|;
name|keywords
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
expr_stmt|;
name|executable
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|eol_style
condition|)
name|SVN_ERR
argument_list|(
name|get_eol_style
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
name|eol_style
operator|->
name|data
argument_list|,
name|eib
operator|->
name|native_eol
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|local_mod
condition|)
block|{
comment|/* Use the modified time from the working copy of          the file */
name|SVN_ERR
argument_list|(
name|svn_io_file_affected_time
argument_list|(
operator|&
name|tm
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tm
operator|=
name|status
operator|->
name|changed_date
expr_stmt|;
block|}
if|if
condition|(
name|keywords
condition|)
block|{
name|svn_revnum_t
name|changed_rev
init|=
name|status
operator|->
name|changed_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
init|=
name|svn_path_url_add_component2
argument_list|(
name|status
operator|->
name|repos_root_url
argument_list|,
name|status
operator|->
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
init|=
name|status
operator|->
name|changed_author
decl_stmt|;
if|if
condition|(
name|local_mod
condition|)
block|{
comment|/* For locally modified files, we'll append an 'M'              to the revision number, and set the author to              "(local)" since we can't always determine the              current user's username */
name|suffix
operator|=
literal|"M"
expr_stmt|;
name|author
operator|=
name|_
argument_list|(
literal|"(local)"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|suffix
operator|=
literal|""
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_subst_build_keywords3
argument_list|(
operator|&
name|kw
argument_list|,
name|keywords
operator|->
name|data
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld%s"
argument_list|,
name|changed_rev
argument_list|,
name|suffix
argument_list|)
argument_list|,
name|url
argument_list|,
name|status
operator|->
name|repos_root_url
argument_list|,
name|tm
argument_list|,
name|author
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* For atomicity, we translate to a tmp file and then rename the tmp file      over the real destination. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|dst_stream
argument_list|,
operator|&
name|dst_tmp
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|to_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If some translation is needed, then wrap the output stream (this is      more efficient than wrapping the input). */
if|if
condition|(
name|eol
operator|||
operator|(
name|kw
operator|&&
operator|(
name|apr_hash_count
argument_list|(
name|kw
argument_list|)
operator|>
literal|0
operator|)
operator|)
condition|)
name|dst_stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|dst_stream
argument_list|,
name|eol
argument_list|,
name|FALSE
comment|/* repair */
argument_list|,
name|kw
argument_list|,
operator|!
name|eib
operator|->
name|ignore_keywords
comment|/* expand */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* ###: use cancel func/baton in place of NULL/NULL below. */
name|err
operator|=
name|svn_stream_copy3
argument_list|(
name|source
argument_list|,
name|dst_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
operator|&&
name|executable
condition|)
name|err
operator|=
name|svn_io_set_file_executable
argument_list|(
name|dst_tmp
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_io_set_file_affected_time
argument_list|(
name|tm
argument_list|,
name|dst_tmp
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_remove_file2
argument_list|(
name|dst_tmp
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* Now that dst_tmp contains the translated data, do the atomic rename. */
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|dst_tmp
argument_list|,
name|to_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eib
operator|->
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|to_abspath
argument_list|,
name|svn_wc_notify_update_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
call|(
name|eib
operator|->
name|notify_func
call|)
argument_list|(
name|eib
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Abstraction of open_root.  *  * Create PATH if it does not exist and is not obstructed, and invoke  * NOTIFY_FUNC with NOTIFY_BATON on PATH.  *  * If PATH exists but is a file, then error with SVN_ERR_WC_NOT_WORKING_COPY.  *  * If PATH is a already a directory, then error with  * SVN_ERR_WC_OBSTRUCTED_UPDATE, unless FORCE, in which case just  * export into PATH with no error.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root_internal
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|force
parameter_list|,
name|svn_wc_notify_func2_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' exists and is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|kind
operator|!=
name|svn_node_dir
operator|)
operator|||
operator|(
operator|!
name|force
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' already exists"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|path
argument_list|,
name|svn_wc_notify_update_add
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
call|(
modifier|*
name|notify_func
call|)
argument_list|(
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ---------------------------------------------------------------------- */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** A dedicated 'export' editor, which does no .svn/ accounting.  ***/
end_comment

begin_struct
struct|struct
name|edit_baton
block|{
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_url
decl_stmt|;
name|svn_boolean_t
name|force
decl_stmt|;
name|svn_revnum_t
modifier|*
name|target_revision
decl_stmt|;
name|apr_hash_t
modifier|*
name|externals
decl_stmt|;
specifier|const
name|char
modifier|*
name|native_eol
decl_stmt|;
name|svn_boolean_t
name|ignore_keywords
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
name|svn_wc_notify_func2_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|dir_baton
block|{
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|file_baton
block|{
name|struct
name|edit_baton
modifier|*
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmppath
decl_stmt|;
comment|/* We need to keep this around so we can explicitly close it in close_file,      thus flushing its output to disk so we can copy and translate it. */
name|svn_stream_t
modifier|*
name|tmp_stream
decl_stmt|;
comment|/* The MD5 digest of the file's fulltext.  This is all zeros until      the last textdelta window handler call returns. */
name|unsigned
name|char
name|text_digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
comment|/* The three svn: properties we might actually care about. */
specifier|const
name|svn_string_t
modifier|*
name|eol_style_val
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|keywords_val
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|executable_val
decl_stmt|;
name|svn_boolean_t
name|special
decl_stmt|;
comment|/* Any keyword vals to be substituted */
specifier|const
name|char
modifier|*
name|revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
decl_stmt|;
name|apr_time_t
name|date
decl_stmt|;
comment|/* Pool associated with this baton. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|handler_baton
block|{
name|svn_txdelta_window_handler_t
name|apply_handler
decl_stmt|;
name|void
modifier|*
name|apply_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmppath
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
comment|/* Stashing a target_revision in the baton */
operator|*
operator|(
name|eb
operator|->
name|target_revision
operator|)
operator|=
name|target_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Just ensure that the main export directory exists. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_root_internal
argument_list|(
name|eb
operator|->
name|root_path
argument_list|,
name|eb
operator|->
name|force
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build our dir baton. */
name|db
operator|->
name|path
operator|=
name|eb
operator|->
name|root_path
expr_stmt|;
name|db
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|root_baton
operator|=
name|db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Ensure the directory exists, and send feedback. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
init|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|root_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|full_path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|full_path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' exists and is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|kind
operator|==
name|svn_node_dir
operator|&&
name|eb
operator|->
name|force
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' already exists"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|full_path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|full_path
argument_list|,
name|svn_wc_notify_update_add
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
call|(
modifier|*
name|eb
operator|->
name|notify_func
call|)
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Build our dir baton. */
name|db
operator|->
name|path
operator|=
name|full_path
expr_stmt|;
name|db
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|baton
operator|=
name|db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Build a file baton. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|pb
operator|->
name|edit_baton
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
init|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|root_path
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* PATH is not canonicalized, i.e. it may still contain spaces etc.    * but EB->root_url is. */
specifier|const
name|char
modifier|*
name|full_url
init|=
name|svn_path_url_add_component2
argument_list|(
name|eb
operator|->
name|root_url
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|fb
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|fb
operator|->
name|path
operator|=
name|full_path
expr_stmt|;
name|fb
operator|->
name|url
operator|=
name|full_url
expr_stmt|;
name|fb
operator|->
name|repos_root_url
operator|=
name|eb
operator|->
name|repos_root_url
expr_stmt|;
name|fb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
operator|*
name|baton
operator|=
name|fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|handler_baton
modifier|*
name|hb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|hb
operator|->
name|apply_handler
argument_list|(
name|window
argument_list|,
name|hb
operator|->
name|apply_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* We failed to apply the patch; clean up the temporary file.  */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_io_remove_file2
argument_list|(
name|hb
operator|->
name|tmppath
argument_list|,
name|TRUE
argument_list|,
name|hb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write incoming data into the tmpfile stream */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|handler_baton
modifier|*
name|hb
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hb
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Create a temporary file in the same directory as the file. We're going      to rename the thing into place when we're done. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fb
operator|->
name|tmp_stream
argument_list|,
operator|&
name|fb
operator|->
name|tmppath
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|hb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|hb
operator|->
name|tmppath
operator|=
name|fb
operator|->
name|tmppath
expr_stmt|;
comment|/* svn_txdelta_apply() closes the stream, but we want to close it in the      close_file() function, so disown it here. */
comment|/* ### contrast to when we call svn_ra_get_file() which does NOT close the      ### tmp_stream. we *should* be much more consistent! */
name|svn_txdelta_apply
argument_list|(
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
argument_list|,
name|svn_stream_disown
argument_list|(
name|fb
operator|->
name|tmp_stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|fb
operator|->
name|text_digest
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
operator|&
name|hb
operator|->
name|apply_handler
argument_list|,
operator|&
name|hb
operator|->
name|apply_baton
argument_list|)
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|hb
expr_stmt|;
operator|*
name|handler
operator|=
name|window_handler
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
if|if
condition|(
operator|!
name|value
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Store only the magic three properties. */
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|eol_style_val
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|fb
operator|->
name|edit_baton
operator|->
name|ignore_keywords
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|keywords_val
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|executable_val
operator|=
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Try to fill out the baton's keywords-structure too. */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|revision
operator|=
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|pool
argument_list|,
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|)
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|fb
operator|->
name|date
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|author
operator|=
name|apr_pstrdup
argument_list|(
name|fb
operator|->
name|pool
argument_list|,
name|value
operator|->
name|data
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
operator|==
literal|0
condition|)
name|fb
operator|->
name|special
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|db
operator|->
name|edit_baton
decl_stmt|;
if|if
condition|(
name|value
operator|&&
operator|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|add_externals
argument_list|(
name|eb
operator|->
name|externals
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Move the tmpfile to file, and send feedback. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|fb
operator|->
name|edit_baton
decl_stmt|;
name|svn_checksum_t
modifier|*
name|text_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|actual_checksum
decl_stmt|;
comment|/* Was a txdelta even sent? */
if|if
condition|(
operator|!
name|fb
operator|->
name|tmppath
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fb
operator|->
name|tmp_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|text_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|text_digest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|actual_checksum
operator|=
name|svn_checksum__from_digest_md5
argument_list|(
name|fb
operator|->
name|text_digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Note that text_digest can be NULL when talking to certain repositories.      In that case text_checksum will be NULL and the following match code      will note that the checksums match */
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|text_checksum
argument_list|,
name|actual_checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|text_checksum
argument_list|,
name|actual_checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
operator|!
name|fb
operator|->
name|eol_style_val
operator|)
operator|&&
operator|(
operator|!
name|fb
operator|->
name|keywords_val
operator|)
operator|&&
operator|(
operator|!
name|fb
operator|->
name|special
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|fb
operator|->
name|tmppath
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_subst_eol_style_t
name|style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|repair
init|=
name|FALSE
decl_stmt|;
name|apr_hash_t
modifier|*
name|final_kw
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|fb
operator|->
name|eol_style_val
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_eol_style
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
name|fb
operator|->
name|eol_style_val
operator|->
name|data
argument_list|,
name|eb
operator|->
name|native_eol
argument_list|)
argument_list|)
expr_stmt|;
name|repair
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|fb
operator|->
name|keywords_val
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_build_keywords3
argument_list|(
operator|&
name|final_kw
argument_list|,
name|fb
operator|->
name|keywords_val
operator|->
name|data
argument_list|,
name|fb
operator|->
name|revision
argument_list|,
name|fb
operator|->
name|url
argument_list|,
name|fb
operator|->
name|repos_root_url
argument_list|,
name|fb
operator|->
name|date
argument_list|,
name|fb
operator|->
name|author
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_copy_and_translate4
argument_list|(
name|fb
operator|->
name|tmppath
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|eol
argument_list|,
name|repair
argument_list|,
name|final_kw
argument_list|,
name|TRUE
argument_list|,
comment|/* expand */
name|fb
operator|->
name|special
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|fb
operator|->
name|tmppath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fb
operator|->
name|executable_val
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|date
operator|&&
operator|(
operator|!
name|fb
operator|->
name|special
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_affected_time
argument_list|(
name|fb
operator|->
name|date
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|edit_baton
operator|->
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|svn_wc_notify_update_add
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
call|(
modifier|*
name|fb
operator|->
name|edit_baton
operator|->
name|notify_func
call|)
argument_list|(
name|fb
operator|->
name|edit_baton
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Always use empty props, since the node won't have pre-existing props      (This is an export, remember?) */
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* An export always gets text against the empty stream (i.e, full texts). */
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_editor_ev1
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|export_editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_delta_editor_t
modifier|*
name|editor
init|=
name|svn_delta_default_editor
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|editor
operator|->
name|set_target_revision
operator|=
name|set_target_revision
expr_stmt|;
name|editor
operator|->
name|open_root
operator|=
name|open_root
expr_stmt|;
name|editor
operator|->
name|add_directory
operator|=
name|add_directory
expr_stmt|;
name|editor
operator|->
name|add_file
operator|=
name|add_file
expr_stmt|;
name|editor
operator|->
name|apply_textdelta
operator|=
name|apply_textdelta
expr_stmt|;
name|editor
operator|->
name|close_file
operator|=
name|close_file
expr_stmt|;
name|editor
operator|->
name|change_file_prop
operator|=
name|change_file_prop
expr_stmt|;
name|editor
operator|->
name|change_dir_prop
operator|=
name|change_dir_prop
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta_get_cancellation_editor
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|editor
argument_list|,
name|eb
argument_list|,
name|export_editor
argument_list|,
name|edit_baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** The Ev2 Implementation ***/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_ev2
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
init|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|root_path
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* RELPATH is not canonicalized, i.e. it may still contain spaces etc.    * but EB->root_url is. */
specifier|const
name|char
modifier|*
name|full_url
init|=
name|svn_path_url_add_component2
argument_list|(
name|eb
operator|->
name|root_url
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|val
decl_stmt|;
comment|/* The four svn: properties we might actually care about. */
specifier|const
name|svn_string_t
modifier|*
name|eol_style_val
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|keywords_val
init|=
name|NULL
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|executable_val
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|special
init|=
name|FALSE
decl_stmt|;
comment|/* Any keyword vals to be substituted */
specifier|const
name|char
modifier|*
name|revision
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|author
init|=
name|NULL
decl_stmt|;
name|apr_time_t
name|date
init|=
literal|0
decl_stmt|;
comment|/* Look at any properties for additional information. */
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EOL_STYLE
argument_list|)
operator|)
condition|)
name|eol_style_val
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|!
name|eb
operator|->
name|ignore_keywords
operator|&&
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_KEYWORDS
argument_list|)
operator|)
condition|)
name|keywords_val
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EXECUTABLE
argument_list|)
operator|)
condition|)
name|executable_val
operator|=
name|val
expr_stmt|;
comment|/* Try to fill out the baton's keywords-structure too. */
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_REV
argument_list|)
operator|)
condition|)
name|revision
operator|=
name|val
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_ENTRY_COMMITTED_DATE
argument_list|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|date
argument_list|,
name|val
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_ENTRY_LAST_AUTHOR
argument_list|)
operator|)
condition|)
name|author
operator|=
name|val
operator|->
name|data
expr_stmt|;
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
operator|)
condition|)
name|special
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|special
condition|)
block|{
name|svn_stream_t
modifier|*
name|tmp_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_create_specialfile
argument_list|(
operator|&
name|tmp_stream
argument_list|,
name|full_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|tmp_stream
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_stream_t
modifier|*
name|tmp_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmppath
decl_stmt|;
comment|/* Create a temporary file in the same directory as the file. We're going          to rename the thing into place when we're done. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tmp_stream
argument_list|,
operator|&
name|tmppath
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|full_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Possibly wrap the stream to be translated, as dictated by          the props. */
if|if
condition|(
name|eol_style_val
operator|||
name|keywords_val
condition|)
block|{
name|svn_subst_eol_style_t
name|style
decl_stmt|;
specifier|const
name|char
modifier|*
name|eol
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|repair
init|=
name|FALSE
decl_stmt|;
name|apr_hash_t
modifier|*
name|final_kw
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|eol_style_val
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_eol_style
argument_list|(
operator|&
name|style
argument_list|,
operator|&
name|eol
argument_list|,
name|eol_style_val
operator|->
name|data
argument_list|,
name|eb
operator|->
name|native_eol
argument_list|)
argument_list|)
expr_stmt|;
name|repair
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|keywords_val
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_build_keywords3
argument_list|(
operator|&
name|final_kw
argument_list|,
name|keywords_val
operator|->
name|data
argument_list|,
name|revision
argument_list|,
name|full_url
argument_list|,
name|eb
operator|->
name|repos_root_url
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Writing through a translated stream is more efficient than              reading through one, so we wrap TMP_STREAM and not CONTENTS. */
name|tmp_stream
operator|=
name|svn_subst_stream_translated
argument_list|(
name|tmp_stream
argument_list|,
name|eol
argument_list|,
name|repair
argument_list|,
name|final_kw
argument_list|,
name|TRUE
argument_list|,
comment|/* expand */
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|tmp_stream
argument_list|,
name|eb
operator|->
name|cancel_func
argument_list|,
name|eb
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Move the file into place. */
name|SVN_ERR
argument_list|(
name|svn_io_file_rename
argument_list|(
name|tmppath
argument_list|,
name|full_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|executable_val
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_executable
argument_list|(
name|full_path
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|&&
operator|(
operator|!
name|special
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_set_file_affected_time
argument_list|(
name|date
argument_list|,
name|full_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|full_path
argument_list|,
name|svn_wc_notify_update_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
call|(
modifier|*
name|eb
operator|->
name|notify_func
call|)
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory_ev2
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
init|=
name|svn_dirent_join
argument_list|(
name|eb
operator|->
name|root_path
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|full_path
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|full_path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_NOT_WORKING_COPY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' exists and is not a directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|full_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|kind
operator|==
name|svn_node_dir
operator|&&
name|eb
operator|->
name|force
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_OBSTRUCTED_UPDATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' already exists"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|full_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|val
operator|=
name|svn_hash_gets
argument_list|(
name|props
argument_list|,
name|SVN_PROP_EXTERNALS
argument_list|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|add_externals
argument_list|(
name|eb
operator|->
name|externals
argument_list|,
name|full_path
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|notify_func
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|full_path
argument_list|,
name|svn_wc_notify_update_add
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
call|(
modifier|*
name|eb
operator|->
name|notify_func
call|)
argument_list|(
name|eb
operator|->
name|notify_baton
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|target_revision_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
operator|*
name|eb
operator|->
name|target_revision
operator|=
name|target_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_editor_ev2
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|export_editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_editor_t
modifier|*
name|editor
decl_stmt|;
name|struct
name|svn_delta__extra_baton
modifier|*
name|exb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|exb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_boolean_t
modifier|*
name|found_abs_paths
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|found_abs_paths
argument_list|)
argument_list|)
decl_stmt|;
name|exb
operator|->
name|baton
operator|=
name|eb
expr_stmt|;
name|exb
operator|->
name|target_revision
operator|=
name|target_revision_func
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_create
argument_list|(
operator|&
name|editor
argument_list|,
name|eb
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_setcb_add_directory
argument_list|(
name|editor
argument_list|,
name|add_directory_ev2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_setcb_add_file
argument_list|(
name|editor
argument_list|,
name|add_file_ev2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|found_abs_paths
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta__delta_from_editor
argument_list|(
name|export_editor
argument_list|,
name|edit_baton
argument_list|,
name|editor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|found_abs_paths
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|fetch_props_func
argument_list|,
name|eb
argument_list|,
name|fetch_base_func
argument_list|,
name|eb
argument_list|,
name|exb
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the root of the export. */
name|SVN_ERR
argument_list|(
name|open_root_internal
argument_list|(
name|eb
operator|->
name|root_path
argument_list|,
name|eb
operator|->
name|force
argument_list|,
name|eb
operator|->
name|notify_func
argument_list|,
name|eb
operator|->
name|notify_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|export_file_ev2
parameter_list|(
specifier|const
name|char
modifier|*
name|from_path_or_url
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|svn_client__pathrev_t
modifier|*
name|loc
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_boolean_t
name|overwrite
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|from_is_url
init|=
name|svn_path_is_url
argument_list|(
name|from_path_or_url
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|svn_stream_t
modifier|*
name|tmp_stream
decl_stmt|;
name|svn_node_kind_t
name|to_kind
decl_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|to_path
argument_list|)
condition|)
block|{
if|if
condition|(
name|from_is_url
condition|)
name|to_path
operator|=
name|svn_uri_basename
argument_list|(
name|from_path_or_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|to_path
operator|=
name|svn_dirent_basename
argument_list|(
name|from_path_or_url
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root_path
operator|=
name|to_path
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|append_basename_if_dir
argument_list|(
operator|&
name|to_path
argument_list|,
name|from_path_or_url
argument_list|,
name|from_is_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root_path
operator|=
name|to_path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|to_path
argument_list|,
operator|&
name|to_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|to_kind
operator|==
name|svn_node_file
operator|||
name|to_kind
operator|==
name|svn_node_unknown
operator|)
operator|&&
operator|!
name|overwrite
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination file '%s' exists, and "
literal|"will not be overwritten unless forced"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|to_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|to_kind
operator|==
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination '%s' exists. Cannot "
literal|"overwrite directory with non-directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|to_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|tmp_stream
operator|=
name|svn_stream_buffered
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
name|tmp_stream
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since you cannot actually root an editor at a file, we manually drive    * a function of our editor. */
name|SVN_ERR
argument_list|(
name|add_file_ev2
argument_list|(
name|eb
argument_list|,
literal|""
argument_list|,
name|NULL
argument_list|,
name|tmp_stream
argument_list|,
name|props
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|export_file
parameter_list|(
specifier|const
name|char
modifier|*
name|from_path_or_url
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|svn_client__pathrev_t
modifier|*
name|loc
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_boolean_t
name|overwrite
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|struct
name|file_baton
modifier|*
name|fb
init|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|to_kind
decl_stmt|;
name|svn_boolean_t
name|from_is_url
init|=
name|svn_path_is_url
argument_list|(
name|from_path_or_url
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|to_path
argument_list|)
condition|)
block|{
if|if
condition|(
name|from_is_url
condition|)
name|to_path
operator|=
name|svn_uri_basename
argument_list|(
name|from_path_or_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|to_path
operator|=
name|svn_dirent_basename
argument_list|(
name|from_path_or_url
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root_path
operator|=
name|to_path
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|append_basename_if_dir
argument_list|(
operator|&
name|to_path
argument_list|,
name|from_path_or_url
argument_list|,
name|from_is_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root_path
operator|=
name|to_path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|to_path
argument_list|,
operator|&
name|to_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|to_kind
operator|==
name|svn_node_file
operator|||
name|to_kind
operator|==
name|svn_node_unknown
operator|)
operator|&&
operator|!
name|overwrite
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination file '%s' exists, and "
literal|"will not be overwritten unless forced"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|to_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|to_kind
operator|==
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Destination '%s' exists. Cannot "
literal|"overwrite directory with non-directory"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|to_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
comment|/* Since you cannot actually root an editor at a file, we    * manually drive a few functions of our editor. */
comment|/* This is the equivalent of a parentless add_file(). */
name|fb
operator|->
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|fb
operator|->
name|path
operator|=
name|eb
operator|->
name|root_path
expr_stmt|;
name|fb
operator|->
name|url
operator|=
name|eb
operator|->
name|root_url
expr_stmt|;
name|fb
operator|->
name|pool
operator|=
name|scratch_pool
expr_stmt|;
name|fb
operator|->
name|repos_root_url
operator|=
name|eb
operator|->
name|repos_root_url
expr_stmt|;
comment|/* Copied from apply_textdelta(). */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fb
operator|->
name|tmp_stream
argument_list|,
operator|&
name|fb
operator|->
name|tmppath
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|fb
operator|->
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|fb
operator|->
name|pool
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Step outside the editor-likeness for a moment, to actually talk    * to the repository. */
comment|/* ### note: the stream will not be closed */
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
name|fb
operator|->
name|tmp_stream
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Push the props into change_file_prop(), to update the file_baton    * with information. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|propval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|change_file_prop
argument_list|(
name|fb
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* And now just use close_file() to do all the keyword and EOL    * work, and put the file into place. */
name|SVN_ERR
argument_list|(
name|close_file
argument_list|(
name|fb
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|export_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|from_path_or_url
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|struct
name|edit_baton
modifier|*
name|eb
parameter_list|,
name|svn_client__pathrev_t
modifier|*
name|loc
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_boolean_t
name|overwrite
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|ignore_keywords
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|native_eol
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|void
modifier|*
name|edit_baton
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|export_editor
decl_stmt|;
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
decl_stmt|;
name|void
modifier|*
name|report_baton
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
if|if
condition|(
operator|!
name|ENABLE_EV2_IMPL
condition|)
name|SVN_ERR
argument_list|(
name|get_editor_ev1
argument_list|(
operator|&
name|export_editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|eb
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|get_editor_ev2
argument_list|(
operator|&
name|export_editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|eb
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Manufacture a basic 'report' to the update reporter. */
name|SVN_ERR
argument_list|(
name|svn_ra_do_update3
argument_list|(
name|ra_session
argument_list|,
operator|&
name|reporter
argument_list|,
operator|&
name|report_baton
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
literal|""
argument_list|,
comment|/* no sub-target */
name|depth
argument_list|,
name|FALSE
argument_list|,
comment|/* don't want copyfrom-args */
name|FALSE
argument_list|,
comment|/* don't want ignore_ancestry */
name|export_editor
argument_list|,
name|edit_baton
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
comment|/* Depth is irrelevant, as we're                                 passing start_empty=TRUE anyway. */
name|svn_depth_infinity
argument_list|,
name|TRUE
argument_list|,
comment|/* "help, my dir is empty!" */
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|finish_report
argument_list|(
name|report_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Special case: Due to our sly export/checkout method of updating an    * empty directory, no target will have been created if the exported    * item is itself an empty directory (export_editor->open_root never    * gets called, because there are no "changes" to make to the empty    * dir we reported to the repository).    *    * So we just create the empty dir manually; but we do it via    * open_root_internal(), in order to get proper notification.    */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|to_path
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|open_root_internal
argument_list|(
name|to_path
argument_list|,
name|overwrite
argument_list|,
name|ctx
operator|->
name|notify_func2
argument_list|,
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ignore_externals
operator|&&
name|depth
operator|==
name|svn_depth_infinity
condition|)
block|{
specifier|const
name|char
modifier|*
name|to_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|to_abspath
argument_list|,
name|to_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__export_externals
argument_list|(
name|eb
operator|->
name|externals
argument_list|,
name|from_path_or_url
argument_list|,
name|to_abspath
argument_list|,
name|eb
operator|->
name|repos_root_url
argument_list|,
name|depth
argument_list|,
name|native_eol
argument_list|,
name|ignore_keywords
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public Interfaces ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client_export5
parameter_list|(
name|svn_revnum_t
modifier|*
name|result_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path_or_url
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_boolean_t
name|overwrite
parameter_list|,
name|svn_boolean_t
name|ignore_externals
parameter_list|,
name|svn_boolean_t
name|ignore_keywords
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|native_eol
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|edit_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_boolean_t
name|from_is_url
init|=
name|svn_path_is_url
argument_list|(
name|from_path_or_url
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|peg_revision
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|revision
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|to_path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a local path"
argument_list|)
argument_list|,
name|to_path
argument_list|)
return|;
name|peg_revision
operator|=
name|svn_cl__rev_default_to_head_or_working
argument_list|(
name|peg_revision
argument_list|,
name|from_path_or_url
argument_list|)
expr_stmt|;
name|revision
operator|=
name|svn_cl__rev_default_to_peg
argument_list|(
name|revision
argument_list|,
name|peg_revision
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_is_url
operator|||
operator|!
name|SVN_CLIENT__REVKIND_IS_LOCAL_TO_WC
argument_list|(
name|revision
operator|->
name|kind
argument_list|)
condition|)
block|{
name|svn_client__pathrev_t
modifier|*
name|loc
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|struct
name|edit_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Get the RA connection. */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|loc
argument_list|,
name|from_path_or_url
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|eb
operator|->
name|repos_root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|root_path
operator|=
name|to_path
expr_stmt|;
name|eb
operator|->
name|root_url
operator|=
name|loc
operator|->
name|url
expr_stmt|;
name|eb
operator|->
name|force
operator|=
name|overwrite
expr_stmt|;
name|eb
operator|->
name|target_revision
operator|=
operator|&
name|edit_revision
expr_stmt|;
name|eb
operator|->
name|externals
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|native_eol
operator|=
name|native_eol
expr_stmt|;
name|eb
operator|->
name|ignore_keywords
operator|=
name|ignore_keywords
expr_stmt|;
name|eb
operator|->
name|cancel_func
operator|=
name|ctx
operator|->
name|cancel_func
expr_stmt|;
name|eb
operator|->
name|cancel_baton
operator|=
name|ctx
operator|->
name|cancel_baton
expr_stmt|;
name|eb
operator|->
name|notify_func
operator|=
name|ctx
operator|->
name|notify_func2
expr_stmt|;
name|eb
operator|->
name|notify_baton
operator|=
name|ctx
operator|->
name|notify_baton2
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|loc
operator|->
name|rev
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
block|{
if|if
condition|(
operator|!
name|ENABLE_EV2_IMPL
condition|)
name|SVN_ERR
argument_list|(
name|export_file
argument_list|(
name|from_path_or_url
argument_list|,
name|to_path
argument_list|,
name|eb
argument_list|,
name|loc
argument_list|,
name|ra_session
argument_list|,
name|overwrite
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|export_file_ev2
argument_list|(
name|from_path_or_url
argument_list|,
name|to_path
argument_list|,
name|eb
argument_list|,
name|loc
argument_list|,
name|ra_session
argument_list|,
name|overwrite
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|export_directory
argument_list|(
name|from_path_or_url
argument_list|,
name|to_path
argument_list|,
name|eb
argument_list|,
name|loc
argument_list|,
name|ra_session
argument_list|,
name|overwrite
argument_list|,
name|ignore_externals
argument_list|,
name|ignore_keywords
argument_list|,
name|depth
argument_list|,
name|native_eol
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' doesn't exist"
argument_list|)
argument_list|,
name|from_path_or_url
argument_list|)
return|;
block|}
comment|/* kind == svn_node_unknown not handled */
block|}
else|else
block|{
name|struct
name|export_info_baton
name|eib
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|apr_hash_t
modifier|*
name|externals
init|=
name|NULL
decl_stmt|;
comment|/* This is a working copy export. */
comment|/* just copy the contents of the working copy into the target path. */
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|from_path_or_url
argument_list|,
name|from_path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|to_path
argument_list|,
name|to_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|from_path_or_url
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### [JAF] If something already exists on disk at the destination path,        * the behaviour depends on the node kinds of the source and destination        * and on the FORCE flag.  The intention (I guess) is to follow the        * semantics of svn_client_export5(), semantics that are not fully        * documented but would be something like:        *        * -----------+---------------------------------------------------------        *        Src | DIR                 FILE                SPECIAL        * Dst (disk) +---------------------------------------------------------        * NONE       | simple copy         simple copy         (as src=file?)        * DIR        | merge if forced [2] inside if root [1]  (as src=file?)        * FILE       | err                 overwr if forced[3] (as src=file?)        * SPECIAL    | ???                 ???                 ???        * -----------+---------------------------------------------------------        *        * [1] FILE onto DIR case: If this file is the root of the copy and thus        *     the only node to be copied, then copy it as a child of the        *     directory TO, applying these same rules again except that if this        *     case occurs again (the child path is already a directory) then        *     error out.  If this file is not the root of the copy (it is        *     reached by recursion), then error out.        *        * [2] DIR onto DIR case.  If the 'FORCE' flag is true then copy the        *     source's children inside the target dir, else error out.  When        *     copying the children, apply the same set of rules, except in the        *     FILE onto DIR case error out like in note [1].        *        * [3] If the 'FORCE' flag is true then overwrite the destination file        *     else error out.        *        * The reality (apparently, looking at the code) is somewhat different.        * For a start, to detect the source kind, it looks at what is on disk        * rather than the versioned working or base node.        */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|append_basename_if_dir
argument_list|(
operator|&
name|to_path
argument_list|,
name|from_path_or_url
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|eib
operator|.
name|to_path
operator|=
name|to_path
expr_stmt|;
name|eib
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|eib
operator|.
name|overwrite
operator|=
name|overwrite
expr_stmt|;
name|eib
operator|.
name|ignore_keywords
operator|=
name|ignore_keywords
expr_stmt|;
name|eib
operator|.
name|wc_ctx
operator|=
name|ctx
operator|->
name|wc_ctx
expr_stmt|;
name|eib
operator|.
name|native_eol
operator|=
name|native_eol
expr_stmt|;
name|eib
operator|.
name|notify_func
operator|=
name|ctx
operator|->
name|notify_func2
expr_stmt|;
empty_stmt|;
name|eib
operator|.
name|notify_baton
operator|=
name|ctx
operator|->
name|notify_baton2
expr_stmt|;
name|eib
operator|.
name|origin_abspath
operator|=
name|from_path_or_url
expr_stmt|;
name|eib
operator|.
name|exported
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_walk_status
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|from_path_or_url
argument_list|,
name|depth
argument_list|,
name|TRUE
comment|/* get_all */
argument_list|,
name|TRUE
comment|/* no_ignore */
argument_list|,
name|FALSE
comment|/* ignore_text_mods */
argument_list|,
name|NULL
argument_list|,
name|export_node
argument_list|,
operator|&
name|eib
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eib
operator|.
name|exported
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The node '%s' was not found."
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|from_path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|ignore_externals
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__externals_defined_below
argument_list|(
operator|&
name|externals
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|from_path_or_url
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|externals
operator|&&
name|apr_hash_count
argument_list|(
name|externals
argument_list|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|externals
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|external_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|relpath
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|from_path_or_url
argument_list|,
name|external_abspath
argument_list|)
expr_stmt|;
name|target_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|to_path
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Ensure that the parent directory exists */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_dirent_dirname
argument_list|(
name|target_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_export5
argument_list|(
name|NULL
argument_list|,
name|svn_dirent_join
argument_list|(
name|from_path_or_url
argument_list|,
name|relpath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|target_abspath
argument_list|,
name|peg_revision
argument_list|,
name|revision
argument_list|,
name|TRUE
argument_list|,
name|ignore_externals
argument_list|,
name|ignore_keywords
argument_list|,
name|depth
argument_list|,
name|native_eol
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|to_path
argument_list|,
name|svn_wc_notify_update_completed
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|notify
operator|->
name|revision
operator|=
name|edit_revision
expr_stmt|;
call|(
modifier|*
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|result_rev
condition|)
operator|*
name|result_rev
operator|=
name|edit_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

