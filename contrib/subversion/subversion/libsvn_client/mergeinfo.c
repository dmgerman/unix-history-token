begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * mergeinfo.c :  merge history functions for the libsvn_client library  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_opt_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_function
name|svn_client__merge_path_t
modifier|*
name|svn_client__merge_path_dup
parameter_list|(
specifier|const
name|svn_client__merge_path_t
modifier|*
name|old
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_client__merge_path_t
modifier|*
name|new
init|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|old
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|old
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|old
operator|->
name|abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|remaining_ranges
condition|)
name|new
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|old
operator|->
name|remaining_ranges
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|pre_merge_mergeinfo
condition|)
name|new
operator|->
name|pre_merge_mergeinfo
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|old
operator|->
name|pre_merge_mergeinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|implicit_mergeinfo
condition|)
name|new
operator|->
name|implicit_mergeinfo
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|old
operator|->
name|implicit_mergeinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|svn_client__merge_path_t
modifier|*
name|svn_client__merge_path_create
parameter_list|(
specifier|const
name|char
modifier|*
name|abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_client__merge_path_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|abspath
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__parse_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|propval
decl_stmt|;
operator|*
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
comment|/* ### Use svn_wc_prop_get() would actually be sufficient for now.      ### DannyB thinks that later we'll need behavior more like      ### svn_client__get_prop_from_wc(). */
name|SVN_ERR
argument_list|(
name|svn_wc_prop_get2
argument_list|(
operator|&
name|propval
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|propval
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
name|mergeinfo
argument_list|,
name|propval
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__record_wc_mergeinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|svn_boolean_t
name|do_notification
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|mergeinfo_str
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|mergeinfo_changes
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert MERGEINFO (if any) into text for storage as a property value. */
if|if
condition|(
name|mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|mergeinfo_str
argument_list|,
name|mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_notification
operator|&&
name|ctx
operator|->
name|notify_func2
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__mergeinfo_status
argument_list|(
operator|&
name|mergeinfo_changes
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record the new mergeinfo in the WC. */
comment|/* ### Later, we'll want behavior more analogous to      ### svn_client__get_prop_from_wc(). */
name|SVN_ERR
argument_list|(
name|svn_wc_prop_set4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|mergeinfo_str
argument_list|,
name|svn_depth_empty
argument_list|,
name|TRUE
comment|/* skip checks */
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* cancellation */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* notification */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_notification
operator|&&
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
init|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_merge_record_info
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|mergeinfo_changes
condition|)
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
else|else
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__record_wc_mergeinfo_catalog
parameter_list|(
name|apr_hash_t
modifier|*
name|result_catalog
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|result_catalog
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sorted_cat
init|=
name|svn_sort__hash
argument_list|(
name|result_catalog
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Write the mergeinfo out in sorted order of the paths (presumably just        * so that the notifications are in a predictable, convenient order). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_cat
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_cat
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client__record_wc_mergeinfo
argument_list|(
name|elt
operator|.
name|key
argument_list|,
name|elt
operator|.
name|value
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_NOT_FOUND
condition|)
block|{
comment|/* PATH isn't just missing, it's not even versioned as far                  as this working copy knows.  But it was included in                  MERGES, which means that the server knows about it.                  Likely we don't have access to the source due to authz                  restrictions.  For now just clear the error and                  continue... */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Retrieving mergeinfo. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_wc_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_boolean_t
modifier|*
name|inherited_p
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|limit_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|walked_path
parameter_list|,
name|svn_boolean_t
name|ignore_invalid_mergeinfo
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|walk_relpath
init|=
literal|""
decl_stmt|;
name|svn_mergeinfo_t
name|wc_mergeinfo
decl_stmt|;
name|svn_revnum_t
name|base_revision
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|inherited
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|limit_abspath
condition|)
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|limit_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_base
argument_list|(
name|NULL
argument_list|,
operator|&
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
comment|/* ignore_enoent */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Don't look for explicit mergeinfo on LOCAL_ABSPATH if we are only          interested in inherited mergeinfo. */
if|if
condition|(
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
condition|)
block|{
name|wc_mergeinfo
operator|=
name|NULL
expr_stmt|;
name|inherit
operator|=
name|svn_mergeinfo_inherited
expr_stmt|;
block|}
else|else
block|{
comment|/* Look for mergeinfo on LOCAL_ABSPATH.  If there isn't any and we              want inherited mergeinfo, walk towards the root of the WC until              we encounter either (a) an unversioned directory, or              (b) mergeinfo.  If we encounter (b), use that inherited              mergeinfo as our baseline. */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_client__parse_mergeinfo
argument_list|(
operator|&
name|wc_mergeinfo
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|ignore_invalid_mergeinfo
operator|||
name|walk_relpath
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|)
operator|&&
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|wc_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|wc_mergeinfo
operator|==
name|NULL
operator|&&
name|inherit
operator|!=
name|svn_mergeinfo_explicit
operator|&&
operator|!
name|svn_dirent_is_root
argument_list|(
name|local_abspath
argument_list|,
name|strlen
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|is_wc_root
decl_stmt|;
name|svn_boolean_t
name|is_switched
decl_stmt|;
name|svn_revnum_t
name|parent_base_rev
decl_stmt|;
name|svn_revnum_t
name|parent_changed_rev
decl_stmt|;
comment|/* Don't look any higher than the limit path. */
if|if
condition|(
name|limit_abspath
operator|&&
name|strcmp
argument_list|(
name|limit_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* If we've reached the root of the working copy don't look any              higher. */
name|SVN_ERR
argument_list|(
name|svn_wc_check_root
argument_list|(
operator|&
name|is_wc_root
argument_list|,
operator|&
name|is_switched
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_wc_root
operator|||
name|is_switched
condition|)
break|break;
comment|/* No explicit mergeinfo on this path.  Look higher up the              directory tree while keeping track of what we've walked. */
name|walk_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|svn_dirent_basename
argument_list|(
name|local_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|walk_relpath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|local_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_base
argument_list|(
name|NULL
argument_list|,
operator|&
name|parent_base_rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### This checks the WORKING changed_rev, so invalid on replacement              ### not even reliable in case an ancestor was copied from a              ### different location */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_changed_info
argument_list|(
operator|&
name|parent_changed_rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look in LOCAL_ABSPATH's parent for inherited mergeinfo if              LOCAL_ABSPATH has no base revision because it is an uncommitted              addition, or if its base revision falls within the inclusive              range of its parent's last changed revision to the parent's base              revision; otherwise stop looking for inherited mergeinfo. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
operator|&&
operator|(
name|base_revision
operator|<
name|parent_changed_rev
operator|||
name|parent_base_rev
operator|<
name|base_revision
operator|)
condition|)
break|break;
comment|/* We haven't yet risen above the root of the WC. */
continue|continue;
block|}
break|break;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|walk_relpath
argument_list|)
condition|)
block|{
comment|/* Mergeinfo is explicit. */
name|inherited
operator|=
name|FALSE
expr_stmt|;
operator|*
name|mergeinfo
operator|=
name|wc_mergeinfo
expr_stmt|;
block|}
else|else
block|{
comment|/* Mergeinfo may be inherited. */
if|if
condition|(
name|wc_mergeinfo
condition|)
block|{
name|inherited
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_suffix_to_mergeinfo
argument_list|(
name|mergeinfo
argument_list|,
name|wc_mergeinfo
argument_list|,
name|walk_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inherited
operator|=
name|FALSE
expr_stmt|;
operator|*
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|walked_path
condition|)
operator|*
name|walked_path
operator|=
name|walk_relpath
expr_stmt|;
comment|/* Remove non-inheritable mergeinfo and paths mapped to empty ranges      which may occur if WCPATH's mergeinfo is not explicit. */
if|if
condition|(
name|inherited
operator|&&
name|apr_hash_count
argument_list|(
operator|*
name|mergeinfo
argument_list|)
condition|)
comment|/* Nothing to do for empty mergeinfo. */
block|{
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_inheritable2
argument_list|(
name|mergeinfo
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_mergeinfo__remove_empty_rangelists
argument_list|(
operator|*
name|mergeinfo
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inherited_p
condition|)
operator|*
name|inherited_p
operator|=
name|inherited
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_wc_mergeinfo_catalog
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|mergeinfo_cat
parameter_list|,
name|svn_boolean_t
modifier|*
name|inherited
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|limit_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|walked_path
parameter_list|,
name|svn_boolean_t
name|ignore_invalid_mergeinfo
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target_repos_relpath
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|mergeinfo_cat
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|target_repos_relpath
argument_list|,
operator|&
name|repos_root
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the mergeinfo for the LOCAL_ABSPATH target and set *INHERITED and      *WALKED_PATH. */
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|inherited
argument_list|,
name|inherit
argument_list|,
name|local_abspath
argument_list|,
name|limit_path
argument_list|,
name|walked_path
argument_list|,
name|ignore_invalid_mergeinfo
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add any explicit/inherited mergeinfo for LOCAL_ABSPATH to      *MERGEINFO_CAT. */
if|if
condition|(
name|mergeinfo
condition|)
block|{
operator|*
name|mergeinfo_cat
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|mergeinfo_cat
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|target_repos_relpath
argument_list|)
argument_list|,
name|mergeinfo
argument_list|)
expr_stmt|;
block|}
comment|/* If LOCAL_ABSPATH is a directory and we want the subtree mergeinfo too,      then get it.       With WC-NG it is cheaper to do a single db transaction, than first      looking if we really have a directory. */
if|if
condition|(
name|include_descendants
condition|)
block|{
name|apr_hash_t
modifier|*
name|mergeinfo_props
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__prop_retrieve_recursive
argument_list|(
operator|&
name|mergeinfo_props
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert *mergeinfo_props into a proper svn_mergeinfo_catalog_t */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo_props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|node_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|subtree_mergeinfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|node_abspath
argument_list|,
name|local_abspath
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* Already parsed in svn_client__get_wc_mergeinfo */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|node_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|subtree_mergeinfo
argument_list|,
name|propval
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the target had no explicit/inherited mergeinfo and this is the              first subtree with mergeinfo found, then the catalog will still              be NULL. */
if|if
condition|(
operator|*
name|mergeinfo_cat
operator|==
name|NULL
condition|)
operator|*
name|mergeinfo_cat
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|mergeinfo_cat
argument_list|,
name|repos_relpath
argument_list|,
name|subtree_mergeinfo
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_repos_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|target_mergeinfo
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|squelch_incapable
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_catalog_t
name|tgt_mergeinfo_cat
decl_stmt|;
operator|*
name|target_mergeinfo
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo_catalog
argument_list|(
operator|&
name|tgt_mergeinfo_cat
argument_list|,
name|ra_session
argument_list|,
name|url
argument_list|,
name|rev
argument_list|,
name|inherit
argument_list|,
name|squelch_incapable
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt_mergeinfo_cat
operator|&&
name|apr_hash_count
argument_list|(
name|tgt_mergeinfo_cat
argument_list|)
condition|)
block|{
comment|/* We asked only for the REL_PATH's mergeinfo, not any of its          descendants.  So if there is anything in the catalog it is the          mergeinfo for REL_PATH. */
operator|*
name|target_mergeinfo
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|tgt_mergeinfo_cat
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_repos_mergeinfo_catalog
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|mergeinfo_cat
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|squelch_incapable
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|repos_mergeinfo_cat
decl_stmt|;
name|apr_array_header_t
modifier|*
name|rel_paths
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_session_url
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|rel_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|""
expr_stmt|;
comment|/* Fetch the mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_session_url
argument_list|,
name|ra_session
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_mergeinfo
argument_list|(
name|ra_session
argument_list|,
operator|&
name|repos_mergeinfo_cat
argument_list|,
name|rel_paths
argument_list|,
name|rev
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|old_session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|squelch_incapable
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_UNSUPPORTED_FEATURE
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|mergeinfo_cat
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|repos_mergeinfo_cat
operator|==
name|NULL
condition|)
block|{
operator|*
name|mergeinfo_cat
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|session_relpath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_root
argument_list|(
name|ra_session
argument_list|,
operator|&
name|session_relpath
argument_list|,
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|session_relpath
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|*
name|mergeinfo_cat
operator|=
name|repos_mergeinfo_cat
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_prefix_to_catalog
argument_list|(
name|mergeinfo_cat
argument_list|,
name|repos_mergeinfo_cat
argument_list|,
name|session_relpath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_wc_or_repos_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|target_mergeinfo
parameter_list|,
name|svn_boolean_t
modifier|*
name|inherited
parameter_list|,
name|svn_boolean_t
modifier|*
name|from_repos
parameter_list|,
name|svn_boolean_t
name|repos_only
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|target_wcpath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_mergeinfo_catalog_t
name|tgt_mergeinfo_cat
decl_stmt|;
operator|*
name|target_mergeinfo
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_or_repos_mergeinfo_catalog
argument_list|(
operator|&
name|tgt_mergeinfo_cat
argument_list|,
name|inherited
argument_list|,
name|from_repos
argument_list|,
name|FALSE
argument_list|,
name|repos_only
argument_list|,
name|FALSE
argument_list|,
name|inherit
argument_list|,
name|ra_session
argument_list|,
name|target_wcpath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgt_mergeinfo_cat
operator|&&
name|apr_hash_count
argument_list|(
name|tgt_mergeinfo_cat
argument_list|)
condition|)
block|{
comment|/* We asked only for the TARGET_WCPATH's mergeinfo, not any of its          descendants.  It this mergeinfo is in the catalog, it's keyed          on TARGET_WCPATH's root-relative path.  We could dig that up          so we can peek into our catalog, but it ought to be the only          thing in the catalog, so we'll just fetch the first hash item. */
operator|*
name|target_mergeinfo
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|tgt_mergeinfo_cat
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_wc_or_repos_mergeinfo_catalog
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|target_mergeinfo_catalog
parameter_list|,
name|svn_boolean_t
modifier|*
name|inherited_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|from_repos
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|repos_only
parameter_list|,
name|svn_boolean_t
name|ignore_invalid_mergeinfo
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|target_wcpath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|svn_revnum_t
name|target_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|target_mergeinfo_cat_wc
init|=
name|NULL
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|target_mergeinfo_cat_repos
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|target_wcpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|from_repos
condition|)
operator|*
name|from_repos
operator|=
name|FALSE
expr_stmt|;
comment|/* We may get an entry with abbreviated information from TARGET_WCPATH's      parent if TARGET_WCPATH is missing.  These limited entries do not have      a URL and without that we cannot get accurate mergeinfo for      TARGET_WCPATH. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
name|NULL
argument_list|,
operator|&
name|target_rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|repos_root
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_relpath
condition|)
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|url
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|repos_only
condition|)
block|{
name|svn_boolean_t
name|inherited
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_mergeinfo_catalog
argument_list|(
operator|&
name|target_mergeinfo_cat_wc
argument_list|,
operator|&
name|inherited
argument_list|,
name|include_descendants
argument_list|,
name|inherit
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ignore_invalid_mergeinfo
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|inherited_p
condition|)
operator|*
name|inherited_p
operator|=
name|inherited
expr_stmt|;
comment|/* If we want LOCAL_ABSPATH's inherited mergeinfo, were we able to          get it from the working copy?  If not, then we must ask the          repository. */
if|if
condition|(
operator|!
operator|(
name|inherited
operator|||
operator|(
name|inherit
operator|==
name|svn_mergeinfo_explicit
operator|)
operator|||
operator|(
name|repos_relpath
operator|&&
name|target_mergeinfo_cat_wc
operator|&&
name|svn_hash_gets
argument_list|(
name|target_mergeinfo_cat_wc
argument_list|,
name|repos_relpath
argument_list|)
operator|)
operator|)
condition|)
block|{
name|repos_only
operator|=
name|TRUE
expr_stmt|;
comment|/* We already have any subtree mergeinfo from the working copy, no              need to ask the server for it again. */
name|include_descendants
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|repos_only
condition|)
block|{
comment|/* No need to check the repos if this is a local addition. */
if|if
condition|(
name|url
operator|!=
name|NULL
condition|)
block|{
name|apr_hash_t
modifier|*
name|original_props
decl_stmt|;
comment|/* Check to see if we have local modifications which removed all of              TARGET_WCPATH's pristine mergeinfo.  If that is the case then              TARGET_WCPATH effectively has no mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_wc_get_pristine_props
argument_list|(
operator|&
name|original_props
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|original_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|sesspool
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|!
name|ra_session
condition|)
block|{
name|sesspool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|ra_session
argument_list|,
name|url
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|sesspool
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo_catalog
argument_list|(
operator|&
name|target_mergeinfo_cat_repos
argument_list|,
name|ra_session
argument_list|,
name|url
argument_list|,
name|target_rev
argument_list|,
name|inherit
argument_list|,
name|TRUE
argument_list|,
name|include_descendants
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_mergeinfo_cat_repos
operator|&&
name|svn_hash_gets
argument_list|(
name|target_mergeinfo_cat_repos
argument_list|,
name|repos_relpath
argument_list|)
condition|)
block|{
if|if
condition|(
name|inherited_p
condition|)
operator|*
name|inherited_p
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|from_repos
condition|)
operator|*
name|from_repos
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we created an RA_SESSION above, destroy it.                  Otherwise, if reparented an existing session, point                  it back where it was when we were called. */
if|if
condition|(
name|sesspool
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Combine the mergeinfo from the working copy and repository as needed. */
if|if
condition|(
name|target_mergeinfo_cat_wc
condition|)
block|{
operator|*
name|target_mergeinfo_catalog
operator|=
name|target_mergeinfo_cat_wc
expr_stmt|;
if|if
condition|(
name|target_mergeinfo_cat_repos
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_catalog_merge
argument_list|(
operator|*
name|target_mergeinfo_catalog
argument_list|,
name|target_mergeinfo_cat_repos
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target_mergeinfo_cat_repos
condition|)
block|{
operator|*
name|target_mergeinfo_catalog
operator|=
name|target_mergeinfo_cat_repos
expr_stmt|;
block|}
else|else
block|{
operator|*
name|target_mergeinfo_catalog
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__get_history_as_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|mergeinfo_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|has_rev_zero_history
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|pathrev
parameter_list|,
name|svn_revnum_t
name|range_youngest
parameter_list|,
name|svn_revnum_t
name|range_oldest
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|segments
decl_stmt|;
comment|/* Fetch the location segments for our URL@PEG_REVNUM. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|range_youngest
argument_list|)
condition|)
name|range_youngest
operator|=
name|pathrev
operator|->
name|rev
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|range_oldest
argument_list|)
condition|)
name|range_oldest
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__repos_location_segments
argument_list|(
operator|&
name|segments
argument_list|,
name|ra_session
argument_list|,
name|pathrev
operator|->
name|url
argument_list|,
name|pathrev
operator|->
name|rev
argument_list|,
name|range_youngest
argument_list|,
name|range_oldest
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_rev_zero_history
condition|)
block|{
operator|*
name|has_rev_zero_history
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|segments
operator|->
name|nelts
condition|)
block|{
name|svn_location_segment_t
modifier|*
name|oldest_segment
init|=
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
literal|0
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|oldest_segment
operator|->
name|range_start
operator|==
literal|0
condition|)
operator|*
name|has_rev_zero_history
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__mergeinfo_from_segments
argument_list|(
name|mergeinfo_p
argument_list|,
name|segments
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Eliding mergeinfo. ***/
end_comment

begin_comment
comment|/* Given the mergeinfo (CHILD_MERGEINFO) for a path, and the    mergeinfo of its nearest ancestor with mergeinfo (PARENT_MERGEINFO), compare    CHILD_MERGEINFO to PARENT_MERGEINFO to see if the former elides to    the latter, following the elision rules described in    svn_client__elide_mergeinfo()'s docstring.  Set *ELIDES to whether    or not CHILD_MERGEINFO is redundant.     Note: This function assumes that PARENT_MERGEINFO is definitive;    i.e. if it is NULL then the caller not only walked the entire WC    looking for inherited mergeinfo, but queried the repository if none    was found in the WC.  This is rather important since this function    says empty mergeinfo should be elided if PARENT_MERGEINFO is NULL,    and we don't want to do that unless we are *certain* that the empty    mergeinfo on PATH isn't overriding anything.     If PATH_SUFFIX and PARENT_MERGEINFO are not NULL append PATH_SUFFIX    to each path in PARENT_MERGEINFO before performing the comparison. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|should_elide_mergeinfo
parameter_list|(
name|svn_boolean_t
modifier|*
name|elides
parameter_list|,
name|svn_mergeinfo_t
name|parent_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|child_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|path_suffix
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Easy out: No child mergeinfo to elide. */
if|if
condition|(
name|child_mergeinfo
operator|==
name|NULL
condition|)
block|{
operator|*
name|elides
operator|=
name|FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_hash_count
argument_list|(
name|child_mergeinfo
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Empty mergeinfo elides to empty mergeinfo or to "nothing",          i.e. it isn't overriding any parent. Otherwise it doesn't          elide. */
operator|*
name|elides
operator|=
operator|(
operator|!
name|parent_mergeinfo
operator|||
name|apr_hash_count
argument_list|(
name|parent_mergeinfo
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|parent_mergeinfo
operator|||
name|apr_hash_count
argument_list|(
name|parent_mergeinfo
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Non-empty mergeinfo never elides to empty mergeinfo          or no mergeinfo. */
operator|*
name|elides
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* Both CHILD_MERGEINFO and PARENT_MERGEINFO are non-NULL and          non-empty. */
name|svn_mergeinfo_t
name|path_tweaked_parent_mergeinfo
decl_stmt|;
comment|/* If we need to adjust the paths in PARENT_MERGEINFO do it now. */
if|if
condition|(
name|path_suffix
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_suffix_to_mergeinfo
argument_list|(
operator|&
name|path_tweaked_parent_mergeinfo
argument_list|,
name|parent_mergeinfo
argument_list|,
name|path_suffix
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|path_tweaked_parent_mergeinfo
operator|=
name|parent_mergeinfo
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__equals
argument_list|(
name|elides
argument_list|,
name|path_tweaked_parent_mergeinfo
argument_list|,
name|child_mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_client__elide_mergeinfo().     Given a working copy LOCAL_ABSPATH, its mergeinfo hash CHILD_MERGEINFO, and    the mergeinfo of LOCAL_ABSPATH's nearest ancestor PARENT_MERGEINFO, use    should_elide_mergeinfo() to decide whether or not CHILD_MERGEINFO elides to    PARENT_MERGEINFO; PATH_SUFFIX means the same as in that function.     If elision does occur, then remove the mergeinfo for LOCAL_ABSPATH.     If CHILD_MERGEINFO is NULL, do nothing.     Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|elide_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
name|parent_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|child_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|elides
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|should_elide_mergeinfo
argument_list|(
operator|&
name|elides
argument_list|,
name|parent_mergeinfo
argument_list|,
name|child_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elides
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_prop_set4
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|NULL
argument_list|,
name|svn_depth_empty
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* cancellation */
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* notification */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_merge_elide_info
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_update
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|prop_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__elide_mergeinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_elision_limit_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|limit_abspath
init|=
name|wc_elision_limit_abspath
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|wc_elision_limit_abspath
operator|||
name|svn_dirent_is_absolute
argument_list|(
name|wc_elision_limit_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for first easy out: We are already at the limit path. */
if|if
condition|(
operator|!
name|limit_abspath
operator|||
name|strcmp
argument_list|(
name|target_abspath
argument_list|,
name|limit_abspath
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|svn_mergeinfo_t
name|target_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|inherited
decl_stmt|;
specifier|const
name|char
modifier|*
name|walk_path
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Get the TARGET_WCPATH's explicit mergeinfo. */
name|err
operator|=
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|target_mergeinfo
argument_list|,
operator|&
name|inherited
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|target_abspath
argument_list|,
name|limit_abspath
argument_list|,
operator|&
name|walk_path
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
comment|/* Issue #3896: If we attempt elision because invalid                  mergeinfo is present on TARGET_WCPATH, then don't let                  the merge fail, just skip the elision attempt. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* If TARGET_WCPATH has no explicit mergeinfo, there's nothing to          elide, we're done. */
if|if
condition|(
name|inherited
operator|||
name|target_mergeinfo
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Get TARGET_WCPATH's inherited mergeinfo from the WC. */
name|err
operator|=
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_nearest_ancestor
argument_list|,
name|target_abspath
argument_list|,
name|limit_abspath
argument_list|,
operator|&
name|walk_path
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
comment|/* Issue #3896 again, but invalid mergeinfo is inherited. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* If TARGET_WCPATH inherited no mergeinfo from the WC and we are          not limiting our search to the working copy then check if it          inherits any from the repos. */
if|if
condition|(
operator|!
name|mergeinfo
operator|&&
operator|!
name|wc_elision_limit_abspath
condition|)
block|{
name|err
operator|=
name|svn_client__get_wc_or_repos_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|svn_mergeinfo_nearest_ancestor
argument_list|,
name|NULL
argument_list|,
name|target_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
comment|/* Issue #3896 again, but invalid mergeinfo is inherited                      from the repository. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
block|}
comment|/* If there is nowhere to elide TARGET_WCPATH's mergeinfo to and          the elision is limited, then we are done.*/
if|if
condition|(
operator|!
name|mergeinfo
operator|&&
name|wc_elision_limit_abspath
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|elide_mergeinfo
argument_list|(
name|mergeinfo
argument_list|,
name|target_mergeinfo
argument_list|,
name|target_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *MERGEINFO_CATALOG to the explicit or inherited mergeinfo for    PATH_OR_URL@PEG_REVISION.  If INCLUDE_DESCENDANTS is true, also    store in *MERGEINFO_CATALOG the explicit mergeinfo on any subtrees    under PATH_OR_URL.  Key all mergeinfo in *MERGEINFO_CATALOG on    repository relpaths.     If no mergeinfo is found then set *MERGEINFO_CATALOG to NULL.     Set *REPOS_ROOT to the root URL of the repository associated with    PATH_OR_URL.     If RA_SESSION is NOT NULL and PATH_OR_URL refers to a URL, RA_SESSION    (which must be of the repository containing PATH_OR_URL) will be used    instead of a temporary RA session. Caller is responsible for reparenting    the session if it wants to use it after the call.     Allocate *MERGEINFO_CATALOG and all its contents in RESULT_POOL.  Use    SCRATCH_POOL for all temporary allocations.     Return SVN_ERR_UNSUPPORTED_FEATURE if the server does not support    Merge Tracking.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|mergeinfo_catalog
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|repos_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|ignore_invalid_mergeinfo
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
decl_stmt|;
name|svn_boolean_t
name|use_url
init|=
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|peg_loc
decl_stmt|;
if|if
condition|(
name|ra_session
operator|&&
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_rev_and_url
argument_list|(
operator|&
name|peg_loc
argument_list|,
name|ra_session
argument_list|,
name|path_or_url
argument_list|,
name|peg_revision
argument_list|,
name|peg_revision
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|peg_loc
argument_list|,
name|path_or_url
argument_list|,
name|NULL
argument_list|,
name|peg_revision
argument_list|,
name|peg_revision
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If PATH_OR_URL is as working copy path determine if we will need to      contact the repository for the requested PEG_REVISION. */
if|if
condition|(
operator|!
name|use_url
condition|)
block|{
name|svn_client__pathrev_t
modifier|*
name|origin
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|local_abspath
argument_list|,
name|path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__wc_node_get_origin
argument_list|(
operator|&
name|origin
argument_list|,
name|local_abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|origin
operator|||
name|strcmp
argument_list|(
name|origin
operator|->
name|url
argument_list|,
name|peg_loc
operator|->
name|url
argument_list|)
operator|!=
literal|0
operator|||
name|peg_loc
operator|->
name|rev
operator|!=
name|origin
operator|->
name|rev
condition|)
block|{
name|use_url
operator|=
name|TRUE
expr_stmt|;
comment|/* Don't rely on local mergeinfo */
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
name|repos_root
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_url
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo_catalog
argument_list|(
name|mergeinfo_catalog
argument_list|,
name|ra_session
argument_list|,
name|peg_loc
operator|->
name|url
argument_list|,
name|peg_loc
operator|->
name|rev
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|FALSE
argument_list|,
name|include_descendants
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ! svn_path_is_url() */
block|{
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_or_repos_mergeinfo_catalog
argument_list|(
name|mergeinfo_catalog
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|include_descendants
argument_list|,
name|FALSE
argument_list|,
name|ignore_invalid_mergeinfo
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|ra_session
argument_list|,
name|path_or_url
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*** In-memory mergeinfo elision ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client__elide_mergeinfo_catalog
parameter_list|(
name|svn_mergeinfo_catalog_t
name|mergeinfo_catalog
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_hash
decl_stmt|;
name|apr_array_header_t
modifier|*
name|elidable_paths
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|dir_stack
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Here's the general algorithm:      Walk through the paths sorted in tree order.  For each path, pop      the dir_stack until it is either empty or the top item contains a parent      of the current path. Check to see if that mergeinfo is then elidable,      and build the list of elidable mergeinfo based upon that determination.      Finally, push the path of interest onto the stack, and continue. */
name|sorted_hash
operator|=
name|svn_sort__hash
argument_list|(
name|mergeinfo_catalog
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_hash
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
modifier|*
name|item
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|sorted_hash
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|item
operator|->
name|key
decl_stmt|;
if|if
condition|(
name|dir_stack
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|top
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_suffix
decl_stmt|;
name|svn_boolean_t
name|elides
init|=
name|FALSE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Pop off any paths which are not ancestors of PATH. */
do|do
block|{
name|top
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|dir_stack
argument_list|,
name|dir_stack
operator|->
name|nelts
operator|-
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|path_suffix
operator|=
name|svn_dirent_is_child
argument_list|(
name|top
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|path_suffix
condition|)
name|apr_array_pop
argument_list|(
name|dir_stack
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dir_stack
operator|->
name|nelts
operator|>
literal|0
operator|&&
operator|!
name|path_suffix
condition|)
do|;
comment|/* If we have a path suffix, it means we haven't popped the stack              clean. */
if|if
condition|(
name|path_suffix
condition|)
block|{
name|SVN_ERR
argument_list|(
name|should_elide_mergeinfo
argument_list|(
operator|&
name|elides
argument_list|,
name|svn_hash_gets
argument_list|(
name|mergeinfo_catalog
argument_list|,
name|top
argument_list|)
argument_list|,
name|svn_hash_gets
argument_list|(
name|mergeinfo_catalog
argument_list|,
name|path
argument_list|)
argument_list|,
name|path_suffix
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elides
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|elidable_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
block|}
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|dir_stack
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Now remove the elidable paths from the catalog. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|elidable_paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|elidable_paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|mergeinfo_catalog
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for filter_log_entry_with_rangelist().     DEPTH_FIRST_CATALOG_INDEX is an array of svn_sort__item_t's.  The keys are    repository-absolute const char *paths, the values are svn_mergeinfo_t for    each path.     Return a pointer to the mergeinfo value of the nearest path-wise ancestor    of FSPATH in DEPTH_FIRST_CATALOG_INDEX.  A path is considered its    own ancestor, so if a key exactly matches FSPATH, return that    key's mergeinfo and set *ANCESTOR_IS_SELF to true (set it to false in all    other cases).     If DEPTH_FIRST_CATALOG_INDEX is NULL, empty, or no ancestor is found, then    return NULL. */
end_comment

begin_function
specifier|static
name|svn_mergeinfo_t
name|find_nearest_ancestor
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|depth_first_catalog_index
parameter_list|,
name|svn_boolean_t
modifier|*
name|ancestor_is_self
parameter_list|,
specifier|const
name|char
modifier|*
name|fspath
parameter_list|)
block|{
name|int
name|ancestor_index
init|=
operator|-
literal|1
decl_stmt|;
operator|*
name|ancestor_is_self
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|depth_first_catalog_index
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth_first_catalog_index
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|depth_first_catalog_index
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_fspath__skip_ancestor
argument_list|(
name|item
operator|.
name|key
argument_list|,
name|fspath
argument_list|)
condition|)
block|{
name|ancestor_index
operator|=
name|i
expr_stmt|;
comment|/* There's no nearer ancestor than FSPATH itself. */
if|if
condition|(
name|strcmp
argument_list|(
name|item
operator|.
name|key
argument_list|,
name|fspath
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|ancestor_is_self
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
if|if
condition|(
name|ancestor_index
operator|==
operator|-
literal|1
condition|)
return|return
name|NULL
return|;
else|else
return|return
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|depth_first_catalog_index
argument_list|,
name|ancestor_index
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|)
operator|.
name|value
return|;
block|}
end_function

begin_comment
comment|/* Baton for use with the filter_log_entry_with_rangelist()    svn_log_entry_receiver_t callback. */
end_comment

begin_struct
struct|struct
name|filter_log_entry_baton_t
block|{
comment|/* Is TRUE if RANGELIST describes potentially merged revisions, is FALSE      if RANGELIST describes potentially eligible revisions. */
name|svn_boolean_t
name|filtering_merged
decl_stmt|;
comment|/* Unsorted array of repository relative paths representing the merge      sources.  There will be more than one source  */
specifier|const
name|apr_array_header_t
modifier|*
name|merge_source_fspaths
decl_stmt|;
comment|/* The repository-absolute path we are calling svn_client_log5() on. */
specifier|const
name|char
modifier|*
name|target_fspath
decl_stmt|;
comment|/* Mergeinfo catalog for the tree rooted at TARGET_FSPATH.      The path keys must be repository-absolute. */
name|svn_mergeinfo_catalog_t
name|target_mergeinfo_catalog
decl_stmt|;
comment|/* Depth first sorted array of svn_sort__item_t's for      TARGET_MERGEINFO_CATALOG. */
name|apr_array_header_t
modifier|*
name|depth_first_catalog_index
decl_stmt|;
comment|/* A rangelist describing all the revisions potentially merged or      potentially eligible for merging (see FILTERING_MERGED) based on      the target's explicit or inherited mergeinfo. */
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
comment|/* The wrapped svn_log_entry_receiver_t callback and baton which      filter_log_entry_with_rangelist() is acting as a filter for. */
name|svn_log_entry_receiver_t
name|log_receiver
decl_stmt|;
name|void
modifier|*
name|log_receiver_baton
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements the svn_log_entry_receiver_t interface.  BATON is a    `struct filter_log_entry_baton_t *'.     Call the wrapped log receiver BATON->log_receiver (with    BATON->log_receiver_baton) if:     BATON->FILTERING_MERGED is FALSE and the changes represented by LOG_ENTRY    have been fully merged from BATON->merge_source_fspaths to the WC target    based on the mergeinfo for the WC contained in BATON->TARGET_MERGEINFO_CATALOG.     Or     BATON->FILTERING_MERGED is TRUE and the changes represented by LOG_ENTRY    have not been merged, or only partially merged, from    BATON->merge_source_fspaths to the WC target based on the mergeinfo for the    WC contained in BATON->TARGET_MERGEINFO_CATALOG. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|filter_log_entry_with_rangelist
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|filter_log_entry_baton_t
modifier|*
name|fleb
init|=
name|baton
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|intersection
decl_stmt|,
modifier|*
name|this_rangelist
decl_stmt|;
if|if
condition|(
name|fleb
operator|->
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|fleb
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|(
name|fleb
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Ignore r0 because there can be no "change 0" in a merge range. */
if|if
condition|(
name|log_entry
operator|->
name|revision
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|this_rangelist
operator|=
name|svn_rangelist__initialize
argument_list|(
name|log_entry
operator|->
name|revision
operator|-
literal|1
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Don't consider inheritance yet, see if LOG_ENTRY->REVISION is      fully or partially represented in BATON->RANGELIST. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|intersection
argument_list|,
name|fleb
operator|->
name|rangelist
argument_list|,
name|this_rangelist
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|intersection
operator|&&
name|intersection
operator|->
name|nelts
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR_ASSERT
argument_list|(
name|intersection
operator|->
name|nelts
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* Ok, we know LOG_ENTRY->REVISION is represented in BATON->RANGELIST,      but is it only partially represented, i.e. is the corresponding range in      BATON->RANGELIST non-inheritable?  Ask for the same intersection as      above but consider inheritance this time, if the intersection is empty      we know the range in BATON->RANGELIST is non-inheritable. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|intersection
argument_list|,
name|fleb
operator|->
name|rangelist
argument_list|,
name|this_rangelist
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|log_entry
operator|->
name|non_inheritable
operator|=
operator|!
name|intersection
operator|->
name|nelts
expr_stmt|;
comment|/* If the paths changed by LOG_ENTRY->REVISION are provided we can determine      if LOG_ENTRY->REVISION, while only partially represented in      BATON->RANGELIST, is in fact completely applied to all affected paths.      ### And ... what if it is, or if it isn't? What do we do with the answer?          And how do we cope if the changed paths are not provided? */
if|if
condition|(
operator|(
name|log_entry
operator|->
name|non_inheritable
operator|||
operator|!
name|fleb
operator|->
name|filtering_merged
operator|)
operator|&&
name|log_entry
operator|->
name|changed_paths2
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|all_subtrees_have_this_rev
init|=
name|TRUE
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|this_rev_rangelist
init|=
name|svn_rangelist__initialize
argument_list|(
name|log_entry
operator|->
name|revision
operator|-
literal|1
argument_list|,
name|log_entry
operator|->
name|revision
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_log_changed_path2_t
modifier|*
name|change
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_fspath_affected
decl_stmt|;
name|svn_mergeinfo_t
name|nearest_ancestor_mergeinfo
decl_stmt|;
name|svn_boolean_t
name|found_this_revision
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_source_rel_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_source_fspath
decl_stmt|;
name|svn_boolean_t
name|ancestor_is_self
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Check that PATH is a subtree of at least one of the              merge sources.  If not then ignore this path.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fleb
operator|->
name|merge_source_fspaths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|merge_source_fspath
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|fleb
operator|->
name|merge_source_fspaths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|merge_source_rel_target
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|merge_source_fspath
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_source_rel_target
condition|)
block|{
comment|/* If MERGE_SOURCE was itself deleted, replaced, or added                      in LOG_ENTRY->REVISION then ignore this PATH since you                      can't merge a addition or deletion of yourself. */
if|if
condition|(
name|merge_source_rel_target
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
name|change
operator|->
name|action
operator|!=
literal|'M'
operator|)
condition|)
name|i
operator|=
name|fleb
operator|->
name|merge_source_fspaths
operator|->
name|nelts
expr_stmt|;
break|break;
block|}
block|}
comment|/* If we examined every merge source path and PATH is a child of              none of them then we can ignore this PATH. */
if|if
condition|(
name|i
operator|==
name|fleb
operator|->
name|merge_source_fspaths
operator|->
name|nelts
condition|)
continue|continue;
comment|/* Calculate the target path which PATH would affect if merged. */
name|target_fspath_affected
operator|=
name|svn_fspath__join
argument_list|(
name|fleb
operator|->
name|target_fspath
argument_list|,
name|merge_source_rel_target
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|nearest_ancestor_mergeinfo
operator|=
name|find_nearest_ancestor
argument_list|(
name|fleb
operator|->
name|depth_first_catalog_index
argument_list|,
operator|&
name|ancestor_is_self
argument_list|,
name|target_fspath_affected
argument_list|)
expr_stmt|;
comment|/* Issue #3791: A path should never have explicit mergeinfo              describing its own addition (that's self-referential).  Nor will              it have explicit mergeinfo describing its own deletion (we              obviously can't add new mergeinfo to a path we are deleting).               This lack of explicit mergeinfo should not cause such revisions              to show up as eligible however.  If PATH was deleted, replaced,              or added in LOG_ENTRY->REVISION, but the corresponding              TARGET_PATH_AFFECTED already exists and has explicit mergeinfo              describing merges from PATH *after* LOG_ENTRY->REVISION, then              ignore this PATH.  If it was deleted in LOG_ENTRY->REVISION it's              obviously back.  If it was added or replaced it's still around              possibly it was replaced one or more times, but it's back now.              Regardless, LOG_ENTRY->REVISION is *not* an eligible revision! */
if|if
condition|(
name|nearest_ancestor_mergeinfo
operator|&&
name|ancestor_is_self
comment|/* Explicit mergeinfo on TARGET_PATH_AFFECTED */
operator|&&
operator|(
name|change
operator|->
name|action
operator|!=
literal|'M'
operator|)
condition|)
block|{
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|svn_hash_gets
argument_list|(
name|nearest_ancestor_mergeinfo
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|rangelist
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|youngest_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|rangelist
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|youngest_range
operator|&&
operator|(
name|youngest_range
operator|->
name|end
operator|>
name|log_entry
operator|->
name|revision
operator|)
condition|)
continue|continue;
block|}
block|}
if|if
condition|(
name|nearest_ancestor_mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi2
decl_stmt|;
for|for
control|(
name|hi2
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|nearest_ancestor_mergeinfo
argument_list|)
init|;
name|hi2
condition|;
name|hi2
operator|=
name|apr_hash_next
argument_list|(
name|hi2
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|mergeinfo_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi2
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi2
argument_list|)
decl_stmt|;
comment|/* Does the mergeinfo for PATH reflect if                      LOG_ENTRY->REVISION was previously merged                      from MERGE_SOURCE_FSPATH? */
if|if
condition|(
name|svn_fspath__skip_ancestor
argument_list|(
name|merge_source_fspath
argument_list|,
name|mergeinfo_path
argument_list|)
condition|)
block|{
comment|/* Something was merged from MERGE_SOURCE_FSPATH, does                          it include LOG_ENTRY->REVISION? */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|intersection
argument_list|,
name|rangelist
argument_list|,
name|this_rev_rangelist
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersection
operator|->
name|nelts
condition|)
block|{
if|if
condition|(
name|ancestor_is_self
condition|)
block|{
comment|/* TARGET_PATH_AFFECTED has explicit mergeinfo,                                  so we don't need to worry if that mergeinfo                                  is inheritable or not. */
name|found_this_revision
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* TARGET_PATH_AFFECTED inherited its mergeinfo,                                  so we have to ignore non-inheritable                                  ranges. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|intersection
argument_list|,
name|rangelist
argument_list|,
name|this_rev_rangelist
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersection
operator|->
name|nelts
condition|)
block|{
name|found_this_revision
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
block|}
block|}
if|if
condition|(
operator|!
name|found_this_revision
condition|)
block|{
comment|/* As soon as any PATH is found that is not fully merged for                  LOG_ENTRY->REVISION then we can stop. */
name|all_subtrees_have_this_rev
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|all_subtrees_have_this_rev
condition|)
block|{
if|if
condition|(
name|fleb
operator|->
name|filtering_merged
condition|)
name|log_entry
operator|->
name|non_inheritable
operator|=
name|FALSE
expr_stmt|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Call the wrapped log receiver which this function is filtering for. */
return|return
name|fleb
operator|->
name|log_receiver
argument_list|(
name|fleb
operator|->
name|log_receiver_baton
argument_list|,
name|log_entry
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|logs_for_mergeinfo_rangelist
parameter_list|(
specifier|const
name|char
modifier|*
name|source_url
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_source_fspaths
parameter_list|,
name|svn_boolean_t
name|filtering_merged
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|svn_boolean_t
name|oldest_revs_first
parameter_list|,
name|svn_mergeinfo_catalog_t
name|target_mergeinfo_catalog
parameter_list|,
specifier|const
name|char
modifier|*
name|target_fspath
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|log_receiver
parameter_list|,
name|void
modifier|*
name|log_receiver_baton
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_merge_range_t
modifier|*
name|oldest_range
decl_stmt|,
modifier|*
name|youngest_range
decl_stmt|;
name|svn_revnum_t
name|oldest_rev
decl_stmt|,
name|youngest_rev
decl_stmt|;
name|struct
name|filter_log_entry_baton_t
name|fleb
decl_stmt|;
if|if
condition|(
operator|!
name|rangelist
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Calculate and construct the bounds of our log request. */
name|youngest_range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|rangelist
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
name|youngest_rev
operator|=
name|youngest_range
operator|->
name|end
expr_stmt|;
name|oldest_range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
name|oldest_rev
operator|=
name|oldest_range
operator|->
name|start
expr_stmt|;
if|if
condition|(
operator|!
name|target_mergeinfo_catalog
condition|)
name|target_mergeinfo_catalog
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* FILTER_LOG_ENTRY_BATON_T->TARGET_MERGEINFO_CATALOG's keys are required      to be repository-absolute. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_prefix_to_catalog
argument_list|(
operator|&
name|target_mergeinfo_catalog
argument_list|,
name|target_mergeinfo_catalog
argument_list|,
literal|"/"
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build the log filtering callback baton. */
name|fleb
operator|.
name|filtering_merged
operator|=
name|filtering_merged
expr_stmt|;
name|fleb
operator|.
name|merge_source_fspaths
operator|=
name|merge_source_fspaths
expr_stmt|;
name|fleb
operator|.
name|target_mergeinfo_catalog
operator|=
name|target_mergeinfo_catalog
expr_stmt|;
name|fleb
operator|.
name|depth_first_catalog_index
operator|=
name|svn_sort__hash
argument_list|(
name|target_mergeinfo_catalog
argument_list|,
name|svn_sort_compare_items_as_paths
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|fleb
operator|.
name|target_fspath
operator|=
name|target_fspath
expr_stmt|;
name|fleb
operator|.
name|rangelist
operator|=
name|rangelist
expr_stmt|;
name|fleb
operator|.
name|log_receiver
operator|=
name|log_receiver
expr_stmt|;
name|fleb
operator|.
name|log_receiver_baton
operator|=
name|log_receiver_baton
expr_stmt|;
name|fleb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
if|if
condition|(
operator|!
name|ra_session
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__open_ra_session_internal
argument_list|(
operator|&
name|ra_session
argument_list|,
name|NULL
argument_list|,
name|source_url
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|source_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|apr_array_header_t
modifier|*
name|target
decl_stmt|;
name|target
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|target
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
literal|""
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_log2
argument_list|(
name|ra_session
argument_list|,
name|target
argument_list|,
name|oldest_revs_first
condition|?
name|oldest_rev
else|:
name|youngest_rev
argument_list|,
name|oldest_revs_first
condition|?
name|youngest_rev
else|:
name|oldest_rev
argument_list|,
literal|0
comment|/* limit */
argument_list|,
name|discover_changed_paths
argument_list|,
name|FALSE
comment|/* strict_node_history */
argument_list|,
name|FALSE
comment|/* include_merged_revisions */
argument_list|,
name|revprops
argument_list|,
name|filter_log_entry_with_rangelist
argument_list|,
operator|&
name|fleb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Check for cancellation. */
if|if
condition|(
name|ctx
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|ctx
operator|->
name|cancel_func
argument_list|(
name|ctx
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *OUT_MERGEINFO to a shallow copy of MERGEINFO with each source path    converted to a (URI-encoded) URL based on REPOS_ROOT_URL. *OUT_MERGEINFO    is declared as 'apr_hash_t *' because its key do not obey the rules of    'svn_mergeinfo_t'.     Allocate *OUT_MERGEINFO and the new keys in RESULT_POOL.  Use    SCRATCH_POOL for any temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mergeinfo_relpaths_to_urls
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|out_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|out_mergeinfo
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|full_path_mergeinfo
init|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|void
modifier|*
name|val
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|full_path_mergeinfo
argument_list|,
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|key
operator|+
literal|1
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
operator|*
name|out_mergeinfo
operator|=
name|full_path_mergeinfo
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public APIs ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_client_mergeinfo_get_merged
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|mergeinfo_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|mergeinfo_cat
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_mergeinfo
argument_list|(
operator|&
name|mergeinfo_cat
argument_list|,
operator|&
name|repos_root
argument_list|,
name|path_or_url
argument_list|,
name|peg_revision
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo_cat
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|path_or_url
argument_list|,
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|path_or_url
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|path_or_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|repos_relpath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Or get_mergeinfo failed */
block|}
name|mergeinfo
operator|=
name|svn_hash_gets
argument_list|(
name|mergeinfo_cat
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|mergeinfo_relpaths_to_urls
argument_list|(
name|mergeinfo_p
argument_list|,
name|mergeinfo
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__mergeinfo_log
parameter_list|(
name|svn_boolean_t
name|finding_merged
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|target_peg_revision
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|target_mergeinfo_catalog
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_start_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_end_revision
parameter_list|,
name|svn_log_entry_receiver_t
name|log_receiver
parameter_list|,
name|void
modifier|*
name|log_receiver_baton
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|log_target
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_repos_relpath
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|target_mergeinfo_cat
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|target_session
init|=
name|NULL
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|pathrev
decl_stmt|;
comment|/* A hash of paths, at or under TARGET_PATH_OR_URL, mapped to      rangelists.  Not technically mergeinfo, so not using the      svn_mergeinfo_t type. */
name|apr_hash_t
modifier|*
name|inheritable_subtree_merges
decl_stmt|;
name|svn_mergeinfo_t
name|source_history
decl_stmt|;
name|svn_mergeinfo_t
name|target_history
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|master_noninheritable_rangelist
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|master_inheritable_rangelist
decl_stmt|;
name|apr_array_header_t
modifier|*
name|merge_source_fspaths
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi_catalog
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|oldest_revs_first
init|=
name|TRUE
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
comment|/* We currently only support depth = empty | infinity. */
if|if
condition|(
name|depth
operator|!=
name|svn_depth_infinity
operator|&&
name|depth
operator|!=
name|svn_depth_empty
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Only depths 'infinity' and 'empty' are currently supported"
argument_list|)
argument_list|)
return|;
comment|/* Validate and sanitize the incoming source operative revision range. */
if|if
condition|(
operator|!
operator|(
operator|(
name|source_start_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|||
operator|(
name|source_start_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_number
operator|)
operator|||
operator|(
name|source_start_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_date
operator|)
operator|||
operator|(
name|source_start_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_head
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|!
operator|(
operator|(
name|source_end_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|||
operator|(
name|source_end_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_number
operator|)
operator|||
operator|(
name|source_end_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_date
operator|)
operator|||
operator|(
name|source_end_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_head
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|(
name|source_end_revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|)
operator|&&
operator|(
name|source_start_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
if|if
condition|(
operator|(
name|source_end_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|&&
operator|(
name|source_start_revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra_session
condition|)
name|target_session
operator|=
name|ra_session
expr_stmt|;
comment|/* We need the union of TARGET_PATH_OR_URL@TARGET_PEG_REVISION's mergeinfo      and MERGE_SOURCE_URL's history.  It's not enough to do path      matching, because renames in the history of MERGE_SOURCE_URL      throw that all in a tizzy.  Of course, if there's no mergeinfo on      the target, that vastly simplifies matters (we'll have nothing to      do). */
comment|/* This get_mergeinfo() call doubles as a mergeinfo capabilities check. */
if|if
condition|(
name|target_mergeinfo_catalog
condition|)
block|{
if|if
condition|(
operator|*
name|target_mergeinfo_catalog
condition|)
block|{
comment|/* The caller provided the mergeinfo catalog for              TARGET_PATH_OR_URL, so we don't need to accquire              it ourselves.  We do need to get the repos_root              though, because get_mergeinfo() won't do it for us. */
name|target_mergeinfo_cat
operator|=
operator|*
name|target_mergeinfo_catalog
expr_stmt|;
if|if
condition|(
name|ra_session
operator|&&
name|svn_path_is_url
argument_list|(
name|target_path_or_url
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|target_path_or_url
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_rev_and_url
argument_list|(
operator|&
name|pathrev
argument_list|,
name|ra_session
argument_list|,
name|target_path_or_url
argument_list|,
name|target_peg_revision
argument_list|,
name|target_peg_revision
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|target_session
operator|=
name|ra_session
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|target_session
argument_list|,
operator|&
name|pathrev
argument_list|,
name|target_path_or_url
argument_list|,
name|NULL
argument_list|,
name|target_peg_revision
argument_list|,
name|target_peg_revision
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|target_session
argument_list|,
operator|&
name|repos_root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The caller didn't provide the mergeinfo catalog for              TARGET_PATH_OR_URL, but wants us to pass a copy back              when we get it, so use RESULT_POOL. */
name|SVN_ERR
argument_list|(
name|get_mergeinfo
argument_list|(
name|target_mergeinfo_catalog
argument_list|,
operator|&
name|repos_root
argument_list|,
name|target_path_or_url
argument_list|,
name|target_peg_revision
argument_list|,
name|depth
operator|==
name|svn_depth_infinity
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|ra_session
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|target_mergeinfo_cat
operator|=
operator|*
name|target_mergeinfo_catalog
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* The caller didn't provide the mergeinfo catalog for          TARGET_PATH_OR_URL, nor does it want a copy, so we can use          nothing but SCRATCH_POOL. */
name|SVN_ERR
argument_list|(
name|get_mergeinfo
argument_list|(
operator|&
name|target_mergeinfo_cat
argument_list|,
operator|&
name|repos_root
argument_list|,
name|target_path_or_url
argument_list|,
name|target_peg_revision
argument_list|,
name|depth
operator|==
name|svn_depth_infinity
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|ra_session
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|target_path_or_url
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|target_path_or_url
argument_list|,
name|target_path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|target_repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_path_or_url
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|target_repos_relpath
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|target_path_or_url
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* TARGET_REPOS_REL should be non-NULL, else get_mergeinfo          should have failed.  */
name|SVN_ERR_ASSERT
argument_list|(
name|target_repos_relpath
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|target_mergeinfo_cat
condition|)
block|{
comment|/* If we are looking for what has been merged and there is no          mergeinfo then we already know the answer.  If we are looking          for eligible revisions then create a catalog with empty mergeinfo          on the target.  This is semantically equivalent to no mergeinfo          and gives us something to combine with MERGE_SOURCE_URL's          history. */
if|if
condition|(
name|finding_merged
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
name|target_mergeinfo_cat
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|target_mergeinfo_cat
argument_list|,
name|target_repos_relpath
argument_list|,
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Fetch the location history as mergeinfo, for the source branch    * (between the given start and end revisions), and, if we're finding    * merged revisions, then also for the entire target branch.    *    * ### TODO: As the source and target must be in the same repository, we    * should share a single session, tracking the two URLs separately. */
block|{
name|svn_ra_session_t
modifier|*
name|source_session
decl_stmt|;
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|,
name|youngest_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
if|if
condition|(
operator|!
name|finding_merged
condition|)
block|{
if|if
condition|(
operator|!
name|target_session
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|target_session
argument_list|,
operator|&
name|pathrev
argument_list|,
name|target_path_or_url
argument_list|,
name|NULL
argument_list|,
name|target_peg_revision
argument_list|,
name|target_peg_revision
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|target_history
argument_list|,
name|NULL
argument_list|,
name|pathrev
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|target_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|target_session
operator|&&
name|svn_path_is_url
argument_list|(
name|source_path_or_url
argument_list|)
operator|&&
name|repos_root
operator|&&
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|source_path_or_url
argument_list|,
name|subpool
argument_list|)
condition|)
block|{
comment|/* We can re-use the existing session */
name|source_session
operator|=
name|target_session
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|source_session
argument_list|,
name|source_path_or_url
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_rev_and_url
argument_list|(
operator|&
name|pathrev
argument_list|,
name|source_session
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|source_peg_revision
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|source_session
argument_list|,
operator|&
name|pathrev
argument_list|,
name|source_path_or_url
argument_list|,
name|NULL
argument_list|,
name|source_peg_revision
argument_list|,
name|source_peg_revision
argument_list|,
name|ctx
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|start_rev
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|source_path_or_url
argument_list|,
name|source_session
argument_list|,
name|source_start_revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|end_rev
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|source_path_or_url
argument_list|,
name|source_session
argument_list|,
name|source_end_revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|source_history
argument_list|,
name|NULL
argument_list|,
name|pathrev
argument_list|,
name|MAX
argument_list|(
name|end_rev
argument_list|,
name|start_rev
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|end_rev
argument_list|,
name|start_rev
argument_list|)
argument_list|,
name|source_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_rev
operator|>
name|end_rev
condition|)
name|oldest_revs_first
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* Separate the explicit or inherited mergeinfo on TARGET_PATH_OR_URL,      and possibly its explicit subtree mergeinfo, into their      inheritable and non-inheritable parts. */
name|master_noninheritable_rangelist
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|64
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|master_inheritable_rangelist
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|64
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|inheritable_subtree_merges
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi_catalog
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|target_mergeinfo_cat
argument_list|)
init|;
name|hi_catalog
condition|;
name|hi_catalog
operator|=
name|apr_hash_next
argument_list|(
name|hi_catalog
argument_list|)
control|)
block|{
name|svn_mergeinfo_t
name|subtree_mergeinfo
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi_catalog
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|subtree_history
decl_stmt|;
name|svn_mergeinfo_t
name|subtree_source_history
decl_stmt|;
name|svn_mergeinfo_t
name|subtree_inheritable_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|subtree_noninheritable_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|merged_noninheritable
decl_stmt|;
name|svn_mergeinfo_t
name|merged
decl_stmt|;
specifier|const
name|char
modifier|*
name|subtree_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi_catalog
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|is_subtree
init|=
name|strcmp
argument_list|(
name|subtree_path
argument_list|,
name|target_repos_relpath
argument_list|)
operator|!=
literal|0
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_subtree
condition|)
block|{
comment|/* If SUBTREE_PATH is a proper subtree of TARGET_PATH_OR_URL              then make a copy of SOURCE_HISTORY that is path adjusted              for the subtree.  */
specifier|const
name|char
modifier|*
name|subtree_rel_path
init|=
name|subtree_path
operator|+
name|strlen
argument_list|(
name|target_repos_relpath
argument_list|)
operator|+
literal|1
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_suffix_to_mergeinfo
argument_list|(
operator|&
name|subtree_source_history
argument_list|,
name|source_history
argument_list|,
name|subtree_rel_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|finding_merged
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_suffix_to_mergeinfo
argument_list|(
operator|&
name|subtree_history
argument_list|,
name|target_history
argument_list|,
name|subtree_rel_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|subtree_source_history
operator|=
name|source_history
expr_stmt|;
if|if
condition|(
operator|!
name|finding_merged
condition|)
name|subtree_history
operator|=
name|target_history
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|finding_merged
condition|)
block|{
name|svn_mergeinfo_t
name|merged_via_history
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_intersect2
argument_list|(
operator|&
name|merged_via_history
argument_list|,
name|subtree_history
argument_list|,
name|subtree_source_history
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|subtree_mergeinfo
argument_list|,
name|merged_via_history
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_inheritable2
argument_list|(
operator|&
name|subtree_inheritable_mergeinfo
argument_list|,
name|subtree_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_inheritable2
argument_list|(
operator|&
name|subtree_noninheritable_mergeinfo
argument_list|,
name|subtree_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the intersection of the non-inheritable part of          SUBTREE_MERGEINFO and SOURCE_HISTORY.  svn_mergeinfo_intersect2()          won't consider non-inheritable and inheritable ranges          intersecting unless we ignore inheritance, but in doing so the          resulting intersections have all inheritable ranges.  To get          around this we set the inheritance on the result to all          non-inheritable. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_intersect2
argument_list|(
operator|&
name|merged_noninheritable
argument_list|,
name|subtree_noninheritable_mergeinfo
argument_list|,
name|subtree_source_history
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_mergeinfo__set_inheritance
argument_list|(
name|merged_noninheritable
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Keep track of all ranges partially merged to any and all          subtrees. */
name|SVN_ERR
argument_list|(
name|svn_rangelist__merge_many
argument_list|(
name|master_noninheritable_rangelist
argument_list|,
name|merged_noninheritable
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the intersection of the inheritable part of TGT_MERGEINFO          and SOURCE_HISTORY. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_intersect2
argument_list|(
operator|&
name|merged
argument_list|,
name|subtree_inheritable_mergeinfo
argument_list|,
name|subtree_source_history
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Keep track of all ranges fully merged to any and all          subtrees. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|merged
argument_list|)
condition|)
block|{
comment|/* The inheritable rangelist merged from SUBTREE_SOURCE_HISTORY              to SUBTREE_PATH. */
name|svn_rangelist_t
modifier|*
name|subtree_merged_rangelist
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist__merge_many
argument_list|(
name|master_inheritable_rangelist
argument_list|,
name|merged
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist__merge_many
argument_list|(
name|subtree_merged_rangelist
argument_list|,
name|merged
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|inheritable_subtree_merges
argument_list|,
name|subtree_path
argument_list|,
name|subtree_merged_rangelist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Map SUBTREE_PATH to an empty rangelist if there was nothing              fully merged. e.g. Only empty or non-inheritable mergeinfo              on the subtree or mergeinfo unrelated to the source. */
name|svn_hash_sets
argument_list|(
name|inheritable_subtree_merges
argument_list|,
name|subtree_path
argument_list|,
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make sure every range in MASTER_INHERITABLE_RANGELIST is fully merged to      each subtree (including the target itself).  Any revisions which don't      exist in *every* subtree are *potentially* only partially merged to the      tree rooted at TARGET_PATH_OR_URL, so move those revisions to      MASTER_NONINHERITABLE_RANGELIST.  It may turn out that that a revision      was merged to the only subtree it affects, but we need to examine the      logs to make this determination (which will be done by      logs_for_mergeinfo_rangelist). */
if|if
condition|(
name|master_inheritable_rangelist
operator|->
name|nelts
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|inheritable_subtree_merges
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_rangelist_t
modifier|*
name|deleted_rangelist
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|added_rangelist
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|subtree_merged_rangelist
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_diff
argument_list|(
operator|&
name|deleted_rangelist
argument_list|,
operator|&
name|added_rangelist
argument_list|,
name|master_inheritable_rangelist
argument_list|,
name|subtree_merged_rangelist
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleted_rangelist
operator|->
name|nelts
condition|)
block|{
name|svn_rangelist__set_inheritance
argument_list|(
name|deleted_rangelist
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|master_noninheritable_rangelist
argument_list|,
name|deleted_rangelist
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|master_inheritable_rangelist
argument_list|,
name|deleted_rangelist
argument_list|,
name|master_inheritable_rangelist
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|finding_merged
condition|)
block|{
comment|/* Roll all the merged revisions into one rangelist. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|master_inheritable_rangelist
argument_list|,
name|master_noninheritable_rangelist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Create the starting rangelist for what might be eligible. */
name|svn_rangelist_t
modifier|*
name|source_master_rangelist
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist__merge_many
argument_list|(
name|source_master_rangelist
argument_list|,
name|source_history
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* From what might be eligible subtract what we know is          partially merged and then merge that back. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|source_master_rangelist
argument_list|,
name|master_noninheritable_rangelist
argument_list|,
name|source_master_rangelist
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|source_master_rangelist
argument_list|,
name|master_noninheritable_rangelist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|master_inheritable_rangelist
argument_list|,
name|master_inheritable_rangelist
argument_list|,
name|source_master_rangelist
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Nothing merged?  Not even when considering shared history if      looking for eligible revisions (i.e. !FINDING_MERGED)?  Then there      is nothing more to do. */
if|if
condition|(
operator|!
name|master_inheritable_rangelist
operator|->
name|nelts
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* Determine the correct (youngest) target for 'svn log'. */
name|svn_merge_range_t
modifier|*
name|youngest_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|master_inheritable_rangelist
argument_list|,
name|master_inheritable_rangelist
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|youngest_rangelist
init|=
name|svn_rangelist__initialize
argument_list|(
name|youngest_range
operator|->
name|end
operator|-
literal|1
argument_list|,
name|youngest_range
operator|->
name|end
argument_list|,
name|youngest_range
operator|->
name|inheritable
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
empty_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|source_history
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|subtree_merged_rangelist
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|intersecting_rangelist
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|intersecting_rangelist
argument_list|,
name|youngest_rangelist
argument_list|,
name|subtree_merged_rangelist
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|merge_source_fspaths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|intersecting_rangelist
operator|->
name|nelts
condition|)
name|log_target
operator|=
name|key
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Step 4: Finally, we run 'svn log' to drive our log receiver, but      using a receiver filter to only allow revisions to pass through      that are in our rangelist. */
name|log_target
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root
argument_list|,
name|log_target
operator|+
literal|1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|logs_for_mergeinfo_rangelist
argument_list|(
name|log_target
argument_list|,
name|merge_source_fspaths
argument_list|,
name|finding_merged
argument_list|,
name|master_inheritable_rangelist
argument_list|,
name|oldest_revs_first
argument_list|,
name|target_mergeinfo_cat
argument_list|,
name|svn_fspath__join
argument_list|(
literal|"/"
argument_list|,
name|target_repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|discover_changed_paths
argument_list|,
name|revprops
argument_list|,
name|log_receiver
argument_list|,
name|log_receiver_baton
argument_list|,
name|ctx
argument_list|,
name|target_session
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Close the source and target sessions. */
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* For SVN_ERR_CEASE_INVOCATION */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_mergeinfo_log2
parameter_list|(
name|svn_boolean_t
name|finding_merged
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|target_peg_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_start_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_end_revision
parameter_list|,
name|svn_log_entry_receiver_t
name|log_receiver
parameter_list|,
name|void
modifier|*
name|log_receiver_baton
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_client__mergeinfo_log
argument_list|(
name|finding_merged
argument_list|,
name|target_path_or_url
argument_list|,
name|target_peg_revision
argument_list|,
name|NULL
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|source_start_revision
argument_list|,
name|source_end_revision
argument_list|,
name|log_receiver
argument_list|,
name|log_receiver_baton
argument_list|,
name|discover_changed_paths
argument_list|,
name|depth
argument_list|,
name|revprops
argument_list|,
name|ctx
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_suggest_merge_sources
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|suggestions
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|peg_revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|mergeinfo_cat
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|list
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In our ideal algorithm, the list of recommendations should be      ordered by:          1. The most recent existing merge source.         2. The copyfrom source (which will also be listed as a merge            source if the copy was made with a 1.5+ client and server).         3. All other merge sources, most recent to least recent.       However, determining the order of application of merge sources      requires a new RA API.  Until such an API is available, our      algorithm will be:          1. The copyfrom source.         2. All remaining merge sources (unordered).   */
comment|/* ### TODO: Share ra_session batons to improve efficiency? */
name|SVN_ERR
argument_list|(
name|get_mergeinfo
argument_list|(
operator|&
name|mergeinfo_cat
argument_list|,
operator|&
name|repos_root
argument_list|,
name|path_or_url
argument_list|,
name|peg_revision
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo_cat
operator|&&
name|apr_hash_count
argument_list|(
name|mergeinfo_cat
argument_list|)
condition|)
block|{
comment|/* We asked only for the PATH_OR_URL's mergeinfo, not any of its          descendants.  So if there is anything in the catalog it is the          mergeinfo for PATH_OR_URL. */
name|mergeinfo
operator|=
name|svn__apr_hash_index_val
argument_list|(
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo_cat
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client__get_copy_source
argument_list|(
operator|&
name|copyfrom_path
argument_list|,
operator|&
name|copyfrom_rev
argument_list|,
name|path_or_url
argument_list|,
name|peg_revision
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyfrom_path
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|list
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root
argument_list|,
name|copyfrom_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mergeinfo
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|rel_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|copyfrom_path
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|rel_path
argument_list|,
name|copyfrom_path
argument_list|)
operator|!=
literal|0
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|list
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
expr|\
name|svn_path_url_add_component2
argument_list|(
name|repos_root
argument_list|,
name|rel_path
operator|+
literal|1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|suggestions
operator|=
name|list
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client__mergeinfo_status
parameter_list|(
name|svn_boolean_t
modifier|*
name|mergeinfo_changes
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|mergeinfo_changes
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_prop_diffs2
argument_list|(
operator|&
name|propchanges
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propchanges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_t
name|prop
init|=
name|APR_ARRAY_IDX
argument_list|(
name|propchanges
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prop
operator|.
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|mergeinfo_changes
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

