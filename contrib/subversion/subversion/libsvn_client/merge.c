begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * merge.c: merging  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* ==================================================================== */
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Includes ***/
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_wc.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"client.h"
end_include

begin_include
include|#
directive|include
file|"mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_opt_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_wc_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/* MERGEINFO MERGE SOURCE NORMALIZATION  *  * Nearly any helper function herein that accepts two URL/revision  * pairs (or equivalent struct merge_source_t) expects one of two things  * to be true:  *  *    1.  that mergeinfo is not being recorded at all for this  *        operation, or  *  *    2.  that the pairs represent two locations along a single line  *        of version history such that there are no copies in the  *        history of the object between the locations when treating  *        the oldest of the two locations as non-inclusive.  In other  *        words, if there is a copy at all between them, there is only  *        one copy and its source was the oldest of the two locations.  *  * We use svn_ra_get_location_segments() to split a given range of  * revisions across an object's history into several which obey these  * rules.  For example, an extract from the log of Subversion's own  * /subversion/tags/1.4.5 directory shows the following copies between  * r859500 and r866500 (omitting the '/subversion' prefix for clarity):  *  *    r859598:  *      A /branches/1.4.x  (from /trunk:859597)  *  *    r865417:  *      A /tags/1.4.4      (from /branches/1.4.x:865262)  *    # Notice that this copy leaves a gap between 865262 and 865417.  *  *    r866420:  *      A /branches/1.4.5  (from /tags/1.4.4:866419)  *  *    r866425:  *      D /branches/1.4.5  *      A /tags/1.4.5      (from /branches/1.4.5:866424)  *  * In graphical form:  *  *                859500 859597 865262        866419 866424 866500  *                  .      .      .             .      .      .  *    trunk       ------------------------------------------------  *                         \      .             .      .  *    branches/1.4.x        A-------------------------------------  *                          .     \______       .      .  *                          .            \      .      .  *    tags/1.4.4            .             A-----------------------  *                          .             .     \      .  *    branches/1.4.5        .             .      A------D  *                          .             .      .     \.  *    tags/1.4.5            .             .      .      A---------  *                          .             .      .      .  *                       859598        865417 866420 866425  *  * A merge of the difference between r859500 and r866500 of this directory  * gets split into sequential merges of the following location pairs.  *  *                859500 859597 865262 865416 866419 866424 866500  *                  .      .      .      .      .      .      .  *    trunk         (======]      .      .      .      .      .  *                                .      .      .      .      .  *    trunk                (      .      .      .      .      .  *    branches/1.4.x        ======]      .      .      .      .  *                                       .      .      .      .  *    branches/1.4.x              (      .      .      .      .  *    tags/1.4.4                   =============]      .      .  *    implicit_src_gap            (======]      .      .      .  *                                              .      .      .  *    tags/1.4.4                                (      .      .  *    branches/1.4.5                             ======]      .  *                                                     .      .  *    branches/1.4.5                                   (      .  *    tags/1.4.5                                        ======]  *  * which are represented in merge_source_t as:  *  *    [/trunk:859500, /trunk:859597]  *    (recorded in svn:mergeinfo as /trunk:859501-859597)  *  *    [/trunk:859597, /branches/1.4.x:865262]  *    (recorded in svn:mergeinfo as /branches/1.4.x:859598-865262)  *  *    [/branches/1.4.x:865262, /tags/1.4.4@866419]  *    (recorded in svn:mergeinfo as /tags/1.4.4:865263-866419)  *    (and there is a gap, the revision range [865262, 865416])  *  *    [/tags/1.4.4@866419, /branches/1.4.5@866424]  *    (recorded in svn:mergeinfo as /branches/1.4.5:866420-866424)  *  *    [/branches/1.4.5@866424, /tags/1.4.5@866500]  *    (recorded in svn:mergeinfo as /tags/1.4.5:866425-866500)  *  * Our helper functions would then operate on one of these location  * pairs at a time.  */
end_comment

begin_comment
comment|/* WHICH SVN_CLIENT_MERGE* API DO I WANT?  *  * libsvn_client has three public merge APIs; they are all wrappers  * around the do_merge engine.  Which one to use depends on the number  * of URLs passed as arguments and whether or not specific merge  * ranges (-c/-r) are specified.  *  *                 1 URL                        2 URLs  * +----+--------------------------------+---------------------+  * | -c |       mergeinfo-driven         |                     |  * | or |        cherrypicking           |                     |  * | -r |    (svn_client_merge_peg)      |                     |  * |----+--------------------------------+                     |  * |    |       mergeinfo-driven         |     unsupported     |  * |    |  'cherry harvest', i.e. merge  |                     |  * |    |  all revisions from URL that   |                     |  * | no |  have not already been merged  |                     |  * | -c |    (svn_client_merge_peg)      |                     |  * | or +--------------------------------+---------------------+  * | -r |      mergeinfo-driven          |   mergeinfo-writing |  * |    |        whole-branch            |    diff-and-apply   |  * |    |       heuristic merge          |  (svn_client_merge) |  * |    | (svn_client_merge_reintegrate) |                     |  * +----+--------------------------------+---------------------+  *  *  */
end_comment

begin_comment
comment|/* THE CHILDREN_WITH_MERGEINFO ARRAY  *  * Many of the helper functions in this file pass around an  * apr_array_header_t *CHILDREN_WITH_MERGEINFO.  This is a depth first  * sorted array filled with svn_client__merge_path_t * describing the  * merge target and any of its subtrees which have explicit mergeinfo  * or otherwise need special attention during a merge.  *  * During mergeinfo unaware merges, CHILDREN_WITH_MERGEINFO contains  * contains only one element (added by do_mergeinfo_unaware_dir_merge)  * describing a contiguous range to be merged to the WC merge target.  *  * During mergeinfo aware merges CHILDREN_WITH_MERGEINFO is created  * by get_mergeinfo_paths() and outside of that function and its helpers  * should always meet the criteria dictated in get_mergeinfo_paths()'s doc  * string.  The elements of CHILDREN_WITH_MERGEINFO should never be NULL.  *  * For clarification on mergeinfo aware vs. mergeinfo unaware merges, see  * the doc string for HONOR_MERGEINFO().  */
end_comment

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Repos-Diff Editor Callbacks ***/
end_comment

begin_comment
comment|/* */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|merge_source_t
block|{
comment|/* "left" side URL and revision (inclusive iff youngest) */
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc1
decl_stmt|;
comment|/* "right" side URL and revision (inclusive iff youngest) */
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc2
decl_stmt|;
comment|/* True iff LOC1 is an ancestor of LOC2 or vice-versa (history-wise). */
name|svn_boolean_t
name|ancestral
decl_stmt|;
block|}
name|merge_source_t
typedef|;
end_typedef

begin_comment
comment|/* Description of the merge target root node (a WC working node) */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|merge_target_t
block|{
comment|/* Absolute path to the WC node */
specifier|const
name|char
modifier|*
name|abspath
decl_stmt|;
comment|/* The repository location of the base node of the target WC.  If the node    * is locally added, then URL& REV are NULL& SVN_INVALID_REVNUM.    * REPOS_ROOT_URL and REPOS_UUID are always valid. */
name|svn_client__pathrev_t
name|loc
decl_stmt|;
block|}
name|merge_target_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|merge_cmd_baton_t
block|{
name|svn_boolean_t
name|force_delete
decl_stmt|;
comment|/* Delete a file/dir even if modified */
name|svn_boolean_t
name|dry_run
decl_stmt|;
name|svn_boolean_t
name|record_only
decl_stmt|;
comment|/* Whether to merge only mergeinfo                                          differences. */
name|svn_boolean_t
name|same_repos
decl_stmt|;
comment|/* Whether the merge source repository                                          is the same repository as the                                          target.  Defaults to FALSE if DRY_RUN                                          is TRUE.*/
name|svn_boolean_t
name|mergeinfo_capable
decl_stmt|;
comment|/* Whether the merge source server                                          is capable of Merge Tracking. */
name|svn_boolean_t
name|ignore_mergeinfo
decl_stmt|;
comment|/* Don't honor mergeinfo; see                                          doc string of do_merge().  FALSE if                                          MERGE_SOURCE->ancestral is FALSE. */
name|svn_boolean_t
name|diff_ignore_ancestry
decl_stmt|;
comment|/* Diff unrelated nodes as if related; see                                          doc string of do_merge().  FALSE if                                          MERGE_SOURCE->ancestral is FALSE. */
name|svn_boolean_t
name|reintegrate_merge
decl_stmt|;
comment|/* Whether this is a --reintegrate                                          merge or not. */
specifier|const
name|merge_target_t
modifier|*
name|target
decl_stmt|;
comment|/* Description of merge target node */
comment|/* The left and right URLs and revs.  The value of this field changes to      reflect the merge_source_t *currently* being merged by do_merge(). */
name|merge_source_t
name|merge_source
decl_stmt|;
comment|/* Rangelist containing single range which describes the gap, if any,      in the natural history of the merge source currently being processed.      See http://subversion.tigris.org/issues/show_bug.cgi?id=3432.      Updated during each call to do_directory_merge().  May be NULL if there      is no gap. */
name|svn_rangelist_t
modifier|*
name|implicit_src_gap
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
comment|/* Client context for callbacks, etc. */
comment|/* The list of any paths which remained in conflict after a      resolution attempt was made.  We track this in-memory, rather      than just using WC entry state, since the latter doesn't help us      when in dry_run mode.      ### And because we only want to resolve conflicts that were          generated by this merge, not pre-existing ones? */
name|apr_hash_t
modifier|*
name|conflicted_paths
decl_stmt|;
comment|/* A list of absolute paths which had no explicit mergeinfo prior to the      merge but got explicit mergeinfo added by the merge.  This is populated      by merge_change_props() and is allocated in POOL so it is subject to the      lifetime limitations of POOL.  Is NULL if no paths are found which      meet the criteria or DRY_RUN is true. */
name|apr_hash_t
modifier|*
name|paths_with_new_mergeinfo
decl_stmt|;
comment|/* A list of absolute paths whose mergeinfo doesn't need updating after      the merge. This can be caused by the removal of mergeinfo by the merge      or by deleting the node itself.  This is populated by merge_change_props()      and the delete callbacks and is allocated in POOL so it is subject to the      lifetime limitations of POOL.  Is NULL if no paths are found which      meet the criteria or DRY_RUN is true. */
name|apr_hash_t
modifier|*
name|paths_with_deleted_mergeinfo
decl_stmt|;
comment|/* The list of absolute skipped paths, which should be examined and      cleared after each invocation of the callback.  The paths      are absolute.  Is NULL if MERGE_B->MERGE_SOURCE->ancestral and      MERGE_B->REINTEGRATE_MERGE are both false. */
name|apr_hash_t
modifier|*
name|skipped_abspaths
decl_stmt|;
comment|/* The list of absolute merged paths.  Unused if MERGE_B->MERGE_SOURCE->ancestral      and MERGE_B->REINTEGRATE_MERGE are both false. */
name|apr_hash_t
modifier|*
name|merged_abspaths
decl_stmt|;
comment|/* A hash of (const char *) absolute WC paths mapped to the same which      represent the roots of subtrees added by the merge. */
name|apr_hash_t
modifier|*
name|added_abspaths
decl_stmt|;
comment|/* A list of tree conflict victim absolute paths which may be NULL. */
name|apr_hash_t
modifier|*
name|tree_conflicted_abspaths
decl_stmt|;
comment|/* The diff3_cmd in ctx->config, if any, else null.  We could just      extract this as needed, but since more than one caller uses it,      we just set it up when this baton is created. */
specifier|const
name|char
modifier|*
name|diff3_cmd
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
decl_stmt|;
comment|/* Array of file extension patterns to preserve as extensions in      generated conflict files. */
specifier|const
name|apr_array_header_t
modifier|*
name|ext_patterns
decl_stmt|;
comment|/* RA sessions used throughout a merge operation.  Opened/re-parented      as needed.       NOTE: During the actual merge editor drive, RA_SESSION1 is used      for the primary editing and RA_SESSION2 for fetching additional      information -- as necessary -- from the repository.  So during      this phase of the merge, you *must not* reparent RA_SESSION1; use      (temporarily reparenting if you must) RA_SESSION2 instead.  */
name|svn_ra_session_t
modifier|*
name|ra_session1
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session2
decl_stmt|;
comment|/* During the merge, *USE_SLEEP is set to TRUE if a sleep will be required      afterwards to ensure timestamp integrity, or unchanged if not. */
name|svn_boolean_t
modifier|*
name|use_sleep
decl_stmt|;
comment|/* Pool which has a lifetime limited to one iteration over a given      merge source, i.e. it is cleared on every call to do_directory_merge()      or do_file_merge() in do_merge(). */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* State for notify_merge_begin() */
struct|struct
name|notify_begin_state_t
block|{
comment|/* Cache of which abspath was last notified. */
specifier|const
name|char
modifier|*
name|last_abspath
decl_stmt|;
comment|/* Reference to the one-and-only CHILDREN_WITH_MERGEINFO (see global        comment) or a similar list for single-file-merges */
specifier|const
name|apr_array_header_t
modifier|*
name|nodes_with_mergeinfo
decl_stmt|;
block|}
name|notify_begin
struct|;
block|}
name|merge_cmd_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Return TRUE iff we should be taking account of mergeinfo in deciding what    changes to merge, for the merge described by MERGE_B.  Specifically, that    is if the merge source server is capable of merge tracking, the left-side    merge source is an ancestor of the right-side (or vice-versa), the merge    source is in the same repository as the merge target, and we are not    ignoring mergeinfo. */
end_comment

begin_define
define|#
directive|define
name|HONOR_MERGEINFO
parameter_list|(
name|merge_b
parameter_list|)
value|((merge_b)->mergeinfo_capable      \&& (merge_b)->merge_source.ancestral  \&& (merge_b)->same_repos          \&& (! (merge_b)->ignore_mergeinfo))
end_define

begin_comment
comment|/* Return TRUE iff we should be recording mergeinfo for the merge described    by MERGE_B.  Specifically, that is if we are honoring mergeinfo and the    merge is not a dry run.  */
end_comment

begin_define
define|#
directive|define
name|RECORD_MERGEINFO
parameter_list|(
name|merge_b
parameter_list|)
value|(HONOR_MERGEINFO(merge_b) \&& !(merge_b)->dry_run)
end_define

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Utilities ***/
end_comment

begin_comment
comment|/* Return TRUE iff the session URL of RA_SESSION is equal to URL.  Useful in  * asserting preconditions. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|session_url_is
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|session_url
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_ra_get_session_url
argument_list|(
name|ra_session
argument_list|,
operator|&
name|session_url
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
operator|!
name|err
argument_list|)
expr_stmt|;
return|return
name|strcmp
argument_list|(
name|url
argument_list|,
name|session_url
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return a new merge_source_t structure, allocated in RESULT_POOL,  * initialized with deep copies of LOC1 and LOC2 and ANCESTRAL. */
end_comment

begin_function
specifier|static
name|merge_source_t
modifier|*
name|merge_source_create
parameter_list|(
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc1
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|loc2
parameter_list|,
name|svn_boolean_t
name|ancestral
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|merge_source_t
modifier|*
name|s
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|->
name|loc1
operator|=
name|svn_client__pathrev_dup
argument_list|(
name|loc1
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|s
operator|->
name|loc2
operator|=
name|svn_client__pathrev_dup
argument_list|(
name|loc2
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|s
operator|->
name|ancestral
operator|=
name|ancestral
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return a deep copy of SOURCE, allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|merge_source_t
modifier|*
name|merge_source_dup
parameter_list|(
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|merge_source_t
modifier|*
name|s
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s
argument_list|)
argument_list|)
decl_stmt|;
name|s
operator|->
name|loc1
operator|=
name|svn_client__pathrev_dup
argument_list|(
name|source
operator|->
name|loc1
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|s
operator|->
name|loc2
operator|=
name|svn_client__pathrev_dup
argument_list|(
name|source
operator|->
name|loc2
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|s
operator|->
name|ancestral
operator|=
name|source
operator|->
name|ancestral
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* Return SVN_ERR_UNSUPPORTED_FEATURE if URL is not inside the repository    of LOCAL_ABSPATH.  Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_repos_match
parameter_list|(
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|svn_uri__is_ancestor
argument_list|(
name|target
operator|->
name|loc
operator|.
name|repos_root_url
argument_list|,
name|url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"URL '%s' of '%s' is not in repository '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|target
operator|->
name|loc
operator|.
name|repos_root_url
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE iff the repository of LOCATION1 is the same as  * that of LOCATION2.  If STRICT_URLS is true, the URLs must  * match (and the UUIDs, just to be sure), otherwise just the UUIDs must  * match and the URLs can differ (a common case is http versus https). */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_same_repos
parameter_list|(
specifier|const
name|svn_client__pathrev_t
modifier|*
name|location1
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|location2
parameter_list|,
name|svn_boolean_t
name|strict_urls
parameter_list|)
block|{
if|if
condition|(
name|strict_urls
condition|)
return|return
operator|(
name|strcmp
argument_list|(
name|location1
operator|->
name|repos_root_url
argument_list|,
name|location2
operator|->
name|repos_root_url
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|location1
operator|->
name|repos_uuid
argument_list|,
name|location2
operator|->
name|repos_uuid
argument_list|)
operator|==
literal|0
operator|)
return|;
else|else
return|return
operator|(
name|strcmp
argument_list|(
name|location1
operator|->
name|repos_uuid
argument_list|,
name|location2
operator|->
name|repos_uuid
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* If the repository identified of LOCATION1 is not the same as that  * of LOCATION2, throw a SVN_ERR_CLIENT_UNRELATED_RESOURCES  * error mentioning PATH1 and PATH2. For STRICT_URLS, see is_same_repos().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_same_repos
parameter_list|(
specifier|const
name|svn_client__pathrev_t
modifier|*
name|location1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|location2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|svn_boolean_t
name|strict_urls
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|is_same_repos
argument_list|(
name|location1
argument_list|,
name|location2
argument_list|,
name|strict_urls
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' must be from the same repository as "
literal|"'%s'"
argument_list|)
argument_list|,
name|path1
argument_list|,
name|path2
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store LOCAL_ABSPATH in PATH_HASH after duplicating it into the pool    containing PATH_HASH. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|store_path
parameter_list|(
name|apr_hash_t
modifier|*
name|path_hash
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dup_path
init|=
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|path_hash
argument_list|)
argument_list|,
name|local_abspath
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|path_hash
argument_list|,
name|dup_path
argument_list|,
name|dup_path
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Store LOCAL_ABSPATH in *PATH_HASH_P after duplicating it into the pool    containing *PATH_HASH_P.  If *PATH_HASH_P is NULL, then first set    *PATH_HASH_P to a new hash allocated from POOL.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|alloc_and_store_path
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|path_hash_p
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|path_hash_p
condition|)
operator|*
name|path_hash_p
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|store_path
argument_list|(
operator|*
name|path_hash_p
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return whether any WC path was put in conflict by the merge    operation corresponding to MERGE_B. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_boolean_t
name|is_path_conflicted_by_merge
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|)
block|{
return|return
operator|(
name|merge_b
operator|->
name|conflicted_paths
operator|&&
name|apr_hash_count
argument_list|(
name|merge_b
operator|->
name|conflicted_paths
argument_list|)
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Return a state indicating whether the WC metadata matches the  * node kind on disk of the local path LOCAL_ABSPATH.  * Use MERGE_B to determine the dry-run details; particularly, if a dry run  * noted that it deleted this path, assume matching node kinds (as if both  * kinds were svn_node_none).  *  *   - Return svn_wc_notify_state_inapplicable if the node kind matches.  *   - Return 'obstructed' if there is a node on disk where none or a  *     different kind is expected, or if the disk node cannot be read.  *   - Return 'missing' if there is no node on disk but one is expected.  *     Also return 'missing' for server-excluded nodes (not here due to  *     authz or other reasons determined by the server).  *  * Optionally return a bit more info for interested users.  **/
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|perform_obstruction_check
parameter_list|(
name|svn_wc_notify_state_t
modifier|*
name|obstruction_state
parameter_list|,
name|svn_boolean_t
modifier|*
name|deleted
parameter_list|,
name|svn_boolean_t
modifier|*
name|excluded
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_depth_t
modifier|*
name|parent_depth
parameter_list|,
specifier|const
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_context_t
modifier|*
name|wc_ctx
init|=
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
decl_stmt|;
name|svn_node_kind_t
name|wc_kind
decl_stmt|;
name|svn_boolean_t
name|check_root
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|obstruction_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
if|if
condition|(
name|deleted
condition|)
operator|*
name|deleted
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|NULL
condition|)
name|kind
operator|=
operator|&
name|wc_kind
expr_stmt|;
name|check_root
operator|=
operator|!
name|strcmp
argument_list|(
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__check_for_obstructions
argument_list|(
name|obstruction_state
argument_list|,
name|kind
argument_list|,
name|deleted
argument_list|,
name|excluded
argument_list|,
name|parent_depth
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|check_root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create *LEFT and *RIGHT conflict versions for conflict victim  * at VICTIM_ABSPATH, with kind NODE_KIND, using information obtained  * from MERGE_SOURCE and TARGET.  * Allocate returned conflict versions in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_conflict_versions
parameter_list|(
specifier|const
name|svn_wc_conflict_version_t
modifier|*
modifier|*
name|left
parameter_list|,
specifier|const
name|svn_wc_conflict_version_t
modifier|*
modifier|*
name|right
parameter_list|,
specifier|const
name|char
modifier|*
name|victim_abspath
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|merge_source
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|child
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|victim_abspath
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|left_relpath
decl_stmt|,
modifier|*
name|right_relpath
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|left_relpath
operator|=
name|svn_client__pathrev_relpath
argument_list|(
name|merge_source
operator|->
name|loc1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|right_relpath
operator|=
name|svn_client__pathrev_relpath
argument_list|(
name|merge_source
operator|->
name|loc2
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|left
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|merge_source
operator|->
name|loc1
operator|->
name|repos_root_url
argument_list|,
name|merge_source
operator|->
name|loc1
operator|->
name|repos_uuid
argument_list|,
name|svn_relpath_join
argument_list|(
name|left_relpath
argument_list|,
name|child
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|merge_source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|node_kind
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|right
operator|=
name|svn_wc_conflict_version_create2
argument_list|(
name|merge_source
operator|->
name|loc2
operator|->
name|repos_root_url
argument_list|,
name|merge_source
operator|->
name|loc2
operator|->
name|repos_uuid
argument_list|,
name|svn_relpath_join
argument_list|(
name|right_relpath
argument_list|,
name|child
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|merge_source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|node_kind
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for filter_self_referential_mergeinfo()     *MERGEINFO is a non-empty, non-null collection of mergeinfo.     Remove all mergeinfo from *MERGEINFO that describes revision ranges    greater than REVISION.  Put a copy of any removed mergeinfo, allocated    in POOL, into *YOUNGER_MERGEINFO.     If no mergeinfo is removed from *MERGEINFO then *YOUNGER_MERGEINFO is set    to NULL.  If all mergeinfo is removed from *MERGEINFO then *MERGEINFO is    set to NULL.    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|split_mergeinfo_on_revision
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|younger_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
operator|*
name|younger_mergeinfo
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
operator|*
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_source_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|end
operator|<=
name|revision
condition|)
block|{
comment|/* This entirely of this range is as old or older than                  REVISION, so leave it in *MERGEINFO. */
continue|continue;
block|}
else|else
block|{
comment|/* Since the rangelists in svn_mergeinfo_t's are sorted in                  increasing order we know that part or all of *this* range                  and *all* of the remaining ranges in *RANGELIST are younger                  than REVISION.  Remove the younger rangelists from                  *MERGEINFO and put them in *YOUNGER_MERGEINFO. */
name|int
name|j
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|younger_rangelist
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|younger_range
init|=
name|svn_merge_range_dup
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|j
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* REVISION might intersect with the first range where                      range->end> REVISION.  If that is the case then split                      the current range into two, putting the younger half                      into *YOUNGER_MERGEINFO and leaving the older half in                      *MERGEINFO. */
if|if
condition|(
name|j
operator|==
name|i
operator|&&
name|range
operator|->
name|start
operator|+
literal|1
operator|<=
name|revision
condition|)
name|younger_range
operator|->
name|start
operator|=
name|range
operator|->
name|end
operator|=
name|revision
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|younger_rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|younger_range
expr_stmt|;
block|}
comment|/* So far we've only been manipulating rangelists, now we                  actually create *YOUNGER_MERGEINFO and then remove the older                  ranges from *MERGEINFO */
if|if
condition|(
operator|!
operator|(
operator|*
name|younger_mergeinfo
operator|)
condition|)
operator|*
name|younger_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|younger_mergeinfo
argument_list|,
name|merge_source_path
argument_list|,
name|younger_rangelist
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_remove2
argument_list|(
name|mergeinfo
argument_list|,
operator|*
name|younger_mergeinfo
argument_list|,
operator|*
name|mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* ...out of for (i = 0; i< rangelist->nelts; i++) */
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make a copy of PROPCHANGES (array of svn_prop_t) into *TRIMMED_PROPCHANGES,    omitting any svn:mergeinfo changes.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|omit_mergeinfo_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|trimmed_propchanges
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|trimmed_propchanges
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|propchanges
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propchanges
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_prop_t
modifier|*
name|change
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propchanges
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
comment|/* If this property is not svn:mergeinfo, then copy it.  */
if|if
condition|(
name|strcmp
argument_list|(
name|change
operator|->
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|!=
literal|0
condition|)
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|trimmed_propchanges
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
operator|*
name|change
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for merge_props_changed().     *PROPS is an array of svn_prop_t structures representing regular properties    to be added to the working copy TARGET_ABSPATH.     The merge source and target are assumed to be in the same repository.     Filter out mergeinfo property additions to TARGET_ABSPATH when    those additions refer to the same line of history as TARGET_ABSPATH as    described below.     Examine the added mergeinfo, looking at each range (or single rev)    of each source path.  If a source_path/range refers to the same line of    history as TARGET_ABSPATH (pegged at its base revision), then filter out    that range.  If the entire rangelist for a given path is filtered then    filter out the path as well.     RA_SESSION is an open RA session to the repository    in which both the source and target live, else RA_SESSION is not used. It    may be temporarily reparented as needed by this function.     Use CTX for any further client operations.     If any filtering occurs, set outgoing *PROPS to a shallow copy (allocated    in POOL) of incoming *PROPS minus the filtered mergeinfo. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|filter_self_referential_mergeinfo
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|adjusted_props
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_boolean_t
name|is_copy
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_client__pathrev_t
name|target_base
decl_stmt|;
comment|/* If PATH itself has been added there is no need to filter. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_origin
argument_list|(
operator|&
name|is_copy
argument_list|,
operator|&
name|target_base
operator|.
name|rev
argument_list|,
operator|&
name|repos_relpath
argument_list|,
operator|&
name|target_base
operator|.
name|repos_root_url
argument_list|,
operator|&
name|target_base
operator|.
name|repos_uuid
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_copy
operator|||
operator|!
name|repos_relpath
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* A copy or a local addition */
name|target_base
operator|.
name|url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|target_base
operator|.
name|repos_root_url
argument_list|,
name|repos_relpath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|adjusted_props
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
operator|(
operator|*
name|props
operator|)
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|*
name|props
operator|)
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
operator|(
operator|*
name|props
operator|)
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|,
name|younger_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|filtered_mergeinfo
init|=
name|NULL
decl_stmt|;
name|svn_mergeinfo_t
name|filtered_younger_mergeinfo
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* If this property isn't mergeinfo or is NULL valued (i.e. prop removal)          or empty mergeinfo it does not require any special handling.  There          is nothing to filter out of empty mergeinfo and the concept of          filtering doesn't apply if we are trying to remove mergeinfo          entirely.  */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
operator|!
name|prop
operator|->
name|value
operator|)
comment|/* Removal of mergeinfo */
operator|||
operator|(
operator|!
name|prop
operator|->
name|value
operator|->
name|len
operator|)
condition|)
comment|/* Empty mergeinfo */
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|adjusted_props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
operator|*
name|prop
expr_stmt|;
continue|continue;
block|}
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Non-empty mergeinfo; filter self-referential mergeinfo out. */
comment|/* Parse the incoming mergeinfo to allow easier manipulation. */
name|err
operator|=
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|prop
operator|->
name|value
operator|->
name|data
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Issue #3896: If we can't parse it, we certainly can't              filter it. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|adjusted_props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
operator|*
name|prop
expr_stmt|;
continue|continue;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* The working copy target PATH is at BASE_REVISION.  Divide the          incoming mergeinfo into two groups.  One where all revision ranges          are as old or older than BASE_REVISION and one where all revision          ranges are younger.           Note: You may be wondering why we do this.           For the incoming mergeinfo "older" than target's base revision we          can filter out self-referential mergeinfo efficiently using          svn_client__get_history_as_mergeinfo().  We simply look at PATH's          natural history as mergeinfo and remove that from any incoming          mergeinfo.           For mergeinfo "younger" than the base revision we can't use          svn_ra_get_location_segments() to look into PATH's future          history.  Instead we must use svn_client__repos_locations() and          look at each incoming source/range individually and see if PATH          at its base revision and PATH at the start of the incoming range          exist on the same line of history.  If they do then we can filter          out the incoming range.  But since we have to do this for each          range there is a substantial performance penalty to pay if the          incoming ranges are not contiguous, i.e. we call          svn_client__repos_locations for each discrete range and incur          the cost of a roundtrip communication with the repository. */
name|SVN_ERR
argument_list|(
name|split_mergeinfo_on_revision
argument_list|(
operator|&
name|younger_mergeinfo
argument_list|,
operator|&
name|mergeinfo
argument_list|,
name|target_base
operator|.
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Filter self-referential mergeinfo from younger_mergeinfo. */
if|if
condition|(
name|younger_mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_source_root_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|ra_session
argument_list|,
operator|&
name|merge_source_root_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|younger_mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_source_url
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|adjusted_rangelist
init|=
name|apr_array_make
argument_list|(
name|iterpool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|merge_source_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|merge_source_root_url
argument_list|,
name|source_path
operator|+
literal|1
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|start_loc
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|j
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Because the merge source normalization code                      ensures mergeinfo refers to real locations on                      the same line of history, there's no need to                      look at the whole range, just the start. */
comment|/* Check if PATH@BASE_REVISION exists at                      RANGE->START on the same line of history.                      (start+1 because RANGE->start is not inclusive.) */
name|err2
operator|=
name|svn_client__repos_location
argument_list|(
operator|&
name|start_loc
argument_list|,
name|ra_session
argument_list|,
operator|&
name|target_base
argument_list|,
name|range
operator|->
name|start
operator|+
literal|1
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
block|{
if|if
condition|(
name|err2
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
operator|||
name|err2
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err2
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
condition|)
block|{
comment|/* PATH@BASE_REVISION didn't exist at                              RANGE->START + 1 or is unrelated to the                              resource PATH@RANGE->START.  Some of the                              requested revisions may not even exist in                              the repository; a real possibility since                              mergeinfo is hand editable.  In all of these                              cases clear and ignore the error and don't                              do any filtering.                               Note: In this last case it is possible that                              we will allow self-referential mergeinfo to                              be applied, but fixing it here is potentially                              very costly in terms of finding what part of                              a range is actually valid.  Simply allowing                              the merge to proceed without filtering the                              offending range seems the least worst                              option. */
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
name|err2
operator|=
name|NULL
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|adjusted_rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err2
argument_list|)
return|;
block|}
block|}
else|else
block|{
comment|/* PATH@BASE_REVISION exists on the same                          line of history at RANGE->START and RANGE->END.                          Now check that PATH@BASE_REVISION's path                          names at RANGE->START and RANGE->END are the same.                          If the names are not the same then the mergeinfo                          describing PATH@RANGE->START through                          PATH@RANGE->END actually belong to some other                          line of history and we want to record this                          mergeinfo, not filter it. */
if|if
condition|(
name|strcmp
argument_list|(
name|start_loc
operator|->
name|url
argument_list|,
name|merge_source_url
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|adjusted_rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
block|}
block|}
comment|/* else no need to add, this mergeinfo is                        all on the same line of history. */
block|}
comment|/* for (j = 0; j< rangelist->nelts; j++) */
comment|/* Add any rangelists for source_path that are not                  self-referential. */
if|if
condition|(
name|adjusted_rangelist
operator|->
name|nelts
condition|)
block|{
if|if
condition|(
operator|!
name|filtered_younger_mergeinfo
condition|)
name|filtered_younger_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|filtered_younger_mergeinfo
argument_list|,
name|source_path
argument_list|,
name|adjusted_rangelist
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Iteration over each merge source in younger_mergeinfo. */
block|}
comment|/* if (younger_mergeinfo) */
comment|/* Filter self-referential mergeinfo from "older" mergeinfo. */
if|if
condition|(
name|mergeinfo
condition|)
block|{
name|svn_mergeinfo_t
name|implicit_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|implicit_mergeinfo
argument_list|,
name|NULL
argument_list|,
operator|&
name|target_base
argument_list|,
name|target_base
operator|.
name|rev
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove PATH's implicit mergeinfo from the incoming mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_remove2
argument_list|(
operator|&
name|filtered_mergeinfo
argument_list|,
name|implicit_mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Combine whatever older and younger filtered mergeinfo exists          into filtered_mergeinfo. */
if|if
condition|(
name|filtered_mergeinfo
operator|&&
name|filtered_younger_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|filtered_mergeinfo
argument_list|,
name|filtered_younger_mergeinfo
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|filtered_younger_mergeinfo
condition|)
name|filtered_mergeinfo
operator|=
name|filtered_younger_mergeinfo
expr_stmt|;
comment|/* If there is any incoming mergeinfo remaining after filtering          then put it in adjusted_props. */
if|if
condition|(
name|filtered_mergeinfo
operator|&&
name|apr_hash_count
argument_list|(
name|filtered_mergeinfo
argument_list|)
condition|)
block|{
comment|/* Convert filtered_mergeinfo to a svn_prop_t and put it              back in the array. */
name|svn_string_t
modifier|*
name|filtered_mergeinfo_str
decl_stmt|;
name|svn_prop_t
modifier|*
name|adjusted_prop
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|adjusted_prop
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
operator|&
name|filtered_mergeinfo_str
argument_list|,
name|filtered_mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|adjusted_prop
operator|->
name|name
operator|=
name|SVN_PROP_MERGEINFO
expr_stmt|;
name|adjusted_prop
operator|->
name|value
operator|=
name|filtered_mergeinfo_str
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|adjusted_props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
operator|*
name|adjusted_prop
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|adjusted_props
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Prepare a set of property changes PROPCHANGES to be used for a merge    operation on LOCAL_ABSPATH.     Remove all non-regular prop-changes (entry-props and WC-props).    Remove all non-mergeinfo prop-changes if it's a record-only merge.    Remove self-referential mergeinfo (### in some cases...)    Remove foreign-repository mergeinfo (### in some cases...)     Store the resulting property changes in *PROP_UPDATES.    Store information on where mergeinfo is updated in MERGE_B.     Used for both file and directory property merges. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prepare_merge_props_changed
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
modifier|*
name|prop_updates
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|props
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We only want to merge "regular" version properties:  by      definition, 'svn merge' shouldn't touch any data within .svn/  */
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|propchanges
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are only applying mergeinfo changes then we need to do      additional filtering of PROPS so it contains only mergeinfo changes. */
if|if
condition|(
name|merge_b
operator|->
name|record_only
operator|&&
name|props
operator|->
name|nelts
condition|)
block|{
name|apr_array_header_t
modifier|*
name|mergeinfo_props
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|props
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|mergeinfo_props
argument_list|,
name|svn_prop_t
argument_list|)
operator|=
operator|*
name|prop
expr_stmt|;
break|break;
block|}
block|}
name|props
operator|=
name|mergeinfo_props
expr_stmt|;
block|}
if|if
condition|(
name|props
operator|->
name|nelts
condition|)
block|{
comment|/* Issue #3383: We don't want mergeinfo from a foreign repos.           If this is a merge from a foreign repository we must strip all          incoming mergeinfo (including mergeinfo deletions). */
if|if
condition|(
operator|!
name|merge_b
operator|->
name|same_repos
condition|)
name|SVN_ERR
argument_list|(
name|omit_mergeinfo_changes
argument_list|(
operator|&
name|props
argument_list|,
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a forward merge then don't add new mergeinfo to          PATH that is already part of PATH's own history, see          http://svn.haxx.se/dev/archive-2008-09/0006.shtml.  If the          merge sources are not ancestral then there is no concept of a          'forward' or 'reverse' merge and we filter unconditionally. */
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|loc1
operator|->
name|rev
operator|<
name|merge_b
operator|->
name|merge_source
operator|.
name|loc2
operator|->
name|rev
operator|||
operator|!
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
condition|)
block|{
if|if
condition|(
name|HONOR_MERGEINFO
argument_list|(
name|merge_b
argument_list|)
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
name|SVN_ERR
argument_list|(
name|filter_self_referential_mergeinfo
argument_list|(
operator|&
name|props
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|prop_updates
operator|=
name|props
expr_stmt|;
comment|/* Make a record in BATON if we find a PATH where mergeinfo is added      where none existed previously or PATH is having its existing      mergeinfo deleted. */
if|if
condition|(
name|props
operator|->
name|nelts
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|props
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|props
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prop
operator|->
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Does LOCAL_ABSPATH have any pristine mergeinfo? */
name|svn_boolean_t
name|has_pristine_mergeinfo
init|=
name|FALSE
decl_stmt|;
name|apr_hash_t
modifier|*
name|pristine_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_pristine_props
argument_list|(
operator|&
name|pristine_props
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pristine_props
operator|&&
name|svn_hash_gets
argument_list|(
name|pristine_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
condition|)
name|has_pristine_mergeinfo
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|has_pristine_mergeinfo
operator|&&
name|prop
operator|->
name|value
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|paths_with_new_mergeinfo
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|has_pristine_mergeinfo
operator|&&
operator|!
name|prop
operator|->
name|value
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|paths_with_deleted_mergeinfo
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_define
define|#
directive|define
name|CONFLICT_REASON_NONE
value|((svn_wc_conflict_reason_t)-1)
end_define

begin_define
define|#
directive|define
name|CONFLICT_REASON_SKIP
value|((svn_wc_conflict_reason_t)-2)
end_define

begin_define
define|#
directive|define
name|CONFLICT_REASON_SKIP_WC
value|((svn_wc_conflict_reason_t)-3)
end_define

begin_comment
comment|/* Baton used for testing trees for being editted while performing tree    conflict detection for incoming deletes */
end_comment

begin_struct
struct|struct
name|dir_delete_baton_t
block|{
comment|/* Reference to dir baton of directory that is the root of the deletion */
name|struct
name|merge_dir_baton_t
modifier|*
name|del_root
decl_stmt|;
comment|/* Boolean indicating that some edit is found. Allows avoiding more work */
name|svn_boolean_t
name|found_edit
decl_stmt|;
comment|/* A list of paths that are compared. Kept up to date until FOUND_EDIT is      set to TRUE */
name|apr_hash_t
modifier|*
name|compared_abspaths
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Baton for the merge_dir_*() functions. Initialized in merge_dir_opened() */
end_comment

begin_struct
struct|struct
name|merge_dir_baton_t
block|{
comment|/* Reference to the parent baton, unless the parent is the anchor, in which      case PARENT_BATON is NULL */
name|struct
name|merge_dir_baton_t
modifier|*
name|parent_baton
decl_stmt|;
comment|/* The pool containing this baton. Use for RESULT_POOL for storing in this      baton */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* This directory doesn't have a representation in the working copy, so any      operation on it will be skipped and possibly cause a tree conflict on the      shadow root */
name|svn_boolean_t
name|shadowed
decl_stmt|;
comment|/* This node or one of its descendants received operational changes from the      merge. If this node is the shadow root its tree conflict status has been      applied */
name|svn_boolean_t
name|edited
decl_stmt|;
comment|/* If a tree conflict will be installed once edited, it's reason. If a skip      should be produced its reason. Otherwise CONFLICT_REASON_NONE for no tree      conflict.       Special values:        CONFLICT_REASON_SKIP:             The node will be skipped with content and property state as stored in             SKIP_REASON.         CONFLICT_REASON_SKIP_WC:             The node will be skipped as an obstructing working copy.    */
name|svn_wc_conflict_reason_t
name|tree_conflict_reason
decl_stmt|;
name|svn_wc_conflict_action_t
name|tree_conflict_action
decl_stmt|;
comment|/* When TREE_CONFLICT_REASON is CONFLICT_REASON_SKIP, the skip state to      add to the notification */
name|svn_wc_notify_state_t
name|skip_reason
decl_stmt|;
comment|/* TRUE if the node was added by this merge. Otherwise FALSE */
name|svn_boolean_t
name|added
decl_stmt|;
name|svn_boolean_t
name|add_is_replace
decl_stmt|;
comment|/* Add is second part of replace */
comment|/* TRUE if we are taking over an existing directory as addition, otherwise      FALSE. */
name|svn_boolean_t
name|add_existing
decl_stmt|;
comment|/* NULL, or an hashtable mapping const char * local_abspaths to      const char *kind mapping, containing deleted nodes that still need a delete      notification (which may be a replaced notification if the node is not just      deleted) */
name|apr_hash_t
modifier|*
name|pending_deletes
decl_stmt|;
comment|/* NULL, or an hashtable mapping const char * LOCAL_ABSPATHs to      a const svn_wc_conflict_description2_t * instance, describing the just      installed conflict */
name|apr_hash_t
modifier|*
name|new_tree_conflicts
decl_stmt|;
comment|/* If not NULL, a reference to the information of the delete test that is      currently in progress. Allocated in the root-directory baton, referenced      from all descendants */
name|struct
name|dir_delete_baton_t
modifier|*
name|delete_state
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Baton for the merge_dir_*() functions. Initialized in merge_file_opened() */
end_comment

begin_struct
struct|struct
name|merge_file_baton_t
block|{
comment|/* Reference to the parent baton, unless the parent is the anchor, in which      case PARENT_BATON is NULL */
name|struct
name|merge_dir_baton_t
modifier|*
name|parent_baton
decl_stmt|;
comment|/* This file doesn't have a representation in the working copy, so any      operation on it will be skipped and possibly cause a tree conflict      on the shadow root */
name|svn_boolean_t
name|shadowed
decl_stmt|;
comment|/* This node received operational changes from the merge. If this node      is the shadow root its tree conflict status has been applied */
name|svn_boolean_t
name|edited
decl_stmt|;
comment|/* If a tree conflict will be installed once edited, it's reason. If a skip      should be produced its reason. Some special values are defined. See the      merge_tree_baton_t for an explanation. */
name|svn_wc_conflict_reason_t
name|tree_conflict_reason
decl_stmt|;
name|svn_wc_conflict_action_t
name|tree_conflict_action
decl_stmt|;
comment|/* When TREE_CONFLICT_REASON is CONFLICT_REASON_SKIP, the skip state to      add to the notification */
name|svn_wc_notify_state_t
name|skip_reason
decl_stmt|;
comment|/* TRUE if the node was added by this merge. Otherwise FALSE */
name|svn_boolean_t
name|added
decl_stmt|;
name|svn_boolean_t
name|add_is_replace
decl_stmt|;
comment|/* Add is second part of replace */
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declaration */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|notify_merge_begin
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|delete_action
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Record the skip for future processing and (later) produce the    skip notification */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_skip
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_wc_notify_action_t
name|action
parameter_list|,
name|svn_wc_notify_state_t
name|state
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|merge_b
operator|->
name|record_only
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* ### Why? - Legacy compatibility */
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
name|store_path
argument_list|(
name|merge_b
operator|->
name|skipped_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|SVN_ERR
argument_list|(
name|notify_merge_begin
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|action
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|state
expr_stmt|;
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Record a tree conflict in the WC, unless this is a dry run or a record-  * only merge, or if a tree conflict is already flagged for the VICTIM_PATH.  * (The latter can happen if a merge-tracking-aware merge is doing multiple  * editor drives because of a gap in the range of eligible revisions.)  *  * The tree conflict, with its victim specified by VICTIM_PATH, is  * assumed to have happened during a merge using merge baton MERGE_B.  *  * NODE_KIND must be the node kind of "old" and "theirs" and "mine";  * this function cannot cope with node kind clashes.  * ACTION and REASON correspond to the fields  * of the same names in svn_wc_tree_conflict_description_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_tree_conflict
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|struct
name|merge_dir_baton_t
modifier|*
name|parent_baton
parameter_list|,
name|svn_node_kind_t
name|node_kind
parameter_list|,
name|svn_wc_conflict_action_t
name|action
parameter_list|,
name|svn_wc_conflict_reason_t
name|reason
parameter_list|,
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|existing_conflict
parameter_list|,
name|svn_boolean_t
name|notify_tc
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_context_t
modifier|*
name|wc_ctx
init|=
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
decl_stmt|;
if|if
condition|(
name|merge_b
operator|->
name|record_only
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
name|store_path
argument_list|(
name|merge_b
operator|->
name|tree_conflicted_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|conflicted_paths
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_b
operator|->
name|dry_run
condition|)
block|{
name|svn_wc_conflict_description2_t
modifier|*
name|conflict
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|parent_baton
condition|?
name|parent_baton
operator|->
name|pool
else|:
name|scratch_pool
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
condition|)
block|{
specifier|const
name|char
modifier|*
name|moved_to_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_was_moved_away
argument_list|(
operator|&
name|moved_to_abspath
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_to_abspath
condition|)
block|{
comment|/* Local abspath itself has been moved away. If only a                  descendant is moved away, we call the node itself deleted */
name|reason
operator|=
name|svn_wc_conflict_reason_moved_away
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|svn_wc_conflict_reason_added
condition|)
block|{
specifier|const
name|char
modifier|*
name|moved_from_abspath
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_was_moved_here
argument_list|(
operator|&
name|moved_from_abspath
argument_list|,
name|NULL
argument_list|,
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|moved_from_abspath
condition|)
name|reason
operator|=
name|svn_wc_conflict_reason_moved_here
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|make_conflict_versions
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|,
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
operator|&
name|merge_b
operator|->
name|merge_source
argument_list|,
name|merge_b
operator|->
name|target
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fix up delete of file, add of dir replacement (or other way around) */
if|if
condition|(
name|existing_conflict
operator|!=
name|NULL
operator|&&
name|existing_conflict
operator|->
name|src_left_version
condition|)
name|left
operator|=
name|existing_conflict
operator|->
name|src_left_version
expr_stmt|;
name|conflict
operator|=
name|svn_wc_conflict_description_create_tree2
argument_list|(
name|local_abspath
argument_list|,
name|node_kind
argument_list|,
name|svn_wc_operation_merge
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|conflict
operator|->
name|action
operator|=
name|action
expr_stmt|;
name|conflict
operator|->
name|reason
operator|=
name|reason
expr_stmt|;
comment|/* May return SVN_ERR_WC_PATH_UNEXPECTED_STATUS */
if|if
condition|(
name|existing_conflict
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc__del_tree_conflict
argument_list|(
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__add_tree_conflict
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|conflict
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_baton
condition|)
block|{
if|if
condition|(
operator|!
name|parent_baton
operator|->
name|new_tree_conflicts
condition|)
name|parent_baton
operator|->
name|new_tree_conflicts
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|parent_baton
operator|->
name|new_tree_conflicts
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|conflict
argument_list|)
expr_stmt|;
block|}
comment|/* ### TODO: Store in parent baton */
block|}
comment|/* On a replacement we currently get two tree conflicts */
if|if
condition|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
operator|&&
name|notify_tc
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|SVN_ERR
argument_list|(
name|notify_merge_begin
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_tree_conflict
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|node_kind
expr_stmt|;
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Record the add for future processing and produce the    update_add notification  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_update_add
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_boolean_t
name|notify_replaced
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
name|store_path
argument_list|(
name|merge_b
operator|->
name|merged_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_wc_notify_action_t
name|action
init|=
name|svn_wc_notify_update_add
decl_stmt|;
name|SVN_ERR
argument_list|(
name|notify_merge_begin
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_replaced
condition|)
name|action
operator|=
name|svn_wc_notify_update_replace
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|action
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Record the update for future processing and produce the    update_update notification */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_update_update
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_wc_notify_state_t
name|content_state
parameter_list|,
name|svn_wc_notify_state_t
name|prop_state
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
name|store_path
argument_list|(
name|merge_b
operator|->
name|merged_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|SVN_ERR
argument_list|(
name|notify_merge_begin
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_update_update
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|content_state
expr_stmt|;
name|notify
operator|->
name|prop_state
operator|=
name|prop_state
expr_stmt|;
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Record the delete for future processing and for (later) producing the    update_delete notification */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_update_delete
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|struct
name|merge_dir_baton_t
modifier|*
name|parent_db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Update the lists of merged, skipped, tree-conflicted and added paths. */
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
comment|/* Issue #4166: If a previous merge added NOTIFY_ABSPATH, but we          are now deleting it, then remove it from the list of added          paths. */
name|svn_hash_sets
argument_list|(
name|merge_b
operator|->
name|added_abspaths
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|store_path
argument_list|(
name|merge_b
operator|->
name|merged_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|notify_merge_begin
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent_db
condition|)
block|{
specifier|const
name|char
modifier|*
name|dup_abspath
init|=
name|apr_pstrdup
argument_list|(
name|parent_db
operator|->
name|pool
argument_list|,
name|local_abspath
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|parent_db
operator|->
name|pending_deletes
condition|)
name|parent_db
operator|->
name|pending_deletes
operator|=
name|apr_hash_make
argument_list|(
name|parent_db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|parent_db
operator|->
name|pending_deletes
argument_list|,
name|dup_abspath
argument_list|,
name|svn_node_kind_to_word
argument_list|(
name|kind
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Notify the pending 'D'eletes, that were waiting to see if a matching 'A'dd    might make them a 'R'eplace. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_pending_notifications
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|struct
name|merge_dir_baton_t
modifier|*
name|db
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
operator|&&
name|db
operator|->
name|pending_deletes
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|db
operator|->
name|pending_deletes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|del_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|del_abspath
argument_list|,
name|svn_wc_notify_update_delete
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_kind_from_word
argument_list|(
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
argument_list|)
expr_stmt|;
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|db
operator|->
name|pending_deletes
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for the merge_dir_*() and merge_file_*() functions.     Installs and notifies pre-recorded tree conflicts and skips for    ancestors of operational merges  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_dir_edited
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|struct
name|merge_dir_baton_t
modifier|*
name|db
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* ### Too much common code with mark_file_edited */
if|if
condition|(
name|db
operator|->
name|edited
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|db
operator|->
name|parent_baton
operator|&&
operator|!
name|db
operator|->
name|parent_baton
operator|->
name|edited
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
operator|->
name|parent_baton
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|db
operator|->
name|edited
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|db
operator|->
name|shadowed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Easy out */
if|if
condition|(
name|db
operator|->
name|parent_baton
operator|&&
name|db
operator|->
name|parent_baton
operator|->
name|delete_state
operator|&&
name|db
operator|->
name|tree_conflict_reason
operator|!=
name|CONFLICT_REASON_NONE
condition|)
block|{
name|db
operator|->
name|parent_baton
operator|->
name|delete_state
operator|->
name|found_edit
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|db
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_SKIP
operator|||
name|db
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_SKIP_WC
condition|)
block|{
comment|/* open_directory() decided not to flag a tree conflict, but          for clarity we produce a skip for this node that          most likely isn't touched by the merge itself */
if|if
condition|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|SVN_ERR
argument_list|(
name|notify_merge_begin
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
operator|(
name|db
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_SKIP
operator|)
condition|?
name|svn_wc_notify_skip
else|:
name|svn_wc_notify_update_skip_obstruction
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|db
operator|->
name|skip_reason
expr_stmt|;
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
name|store_path
argument_list|(
name|merge_b
operator|->
name|skipped_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|db
operator|->
name|tree_conflict_reason
operator|!=
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* open_directory() decided that a tree conflict should be raised */
name|SVN_ERR
argument_list|(
name|record_tree_conflict
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|db
operator|->
name|parent_baton
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|tree_conflict_action
argument_list|,
name|db
operator|->
name|tree_conflict_reason
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function for the merge_file_*() functions.     Installs and notifies pre-recorded tree conflicts and skips for    ancestors of operational merges  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mark_file_edited
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|struct
name|merge_file_baton_t
modifier|*
name|fb
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* ### Too much common code with mark_dir_edited */
if|if
condition|(
name|fb
operator|->
name|edited
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|fb
operator|->
name|parent_baton
operator|&&
operator|!
name|fb
operator|->
name|parent_baton
operator|->
name|edited
condition|)
block|{
specifier|const
name|char
modifier|*
name|dir_abspath
init|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
operator|->
name|parent_baton
argument_list|,
name|dir_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fb
operator|->
name|edited
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|fb
operator|->
name|shadowed
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Easy out */
if|if
condition|(
name|fb
operator|->
name|parent_baton
operator|&&
name|fb
operator|->
name|parent_baton
operator|->
name|delete_state
operator|&&
name|fb
operator|->
name|tree_conflict_reason
operator|!=
name|CONFLICT_REASON_NONE
condition|)
block|{
name|fb
operator|->
name|parent_baton
operator|->
name|delete_state
operator|->
name|found_edit
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fb
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_SKIP
operator|||
name|fb
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_SKIP_WC
condition|)
block|{
comment|/* open_directory() decided not to flag a tree conflict, but          for clarity we produce a skip for this node that          most likely isn't touched by the merge itself */
if|if
condition|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|SVN_ERR
argument_list|(
name|notify_merge_begin
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|local_abspath
argument_list|,
name|svn_wc_notify_skip
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|notify
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|notify
operator|->
name|content_state
operator|=
name|notify
operator|->
name|prop_state
operator|=
name|fb
operator|->
name|skip_reason
expr_stmt|;
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
name|store_path
argument_list|(
name|merge_b
operator|->
name|skipped_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|fb
operator|->
name|tree_conflict_reason
operator|!=
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* open_file() decided that a tree conflict should be raised */
name|SVN_ERR
argument_list|(
name|record_tree_conflict
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|fb
operator|->
name|parent_baton
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|tree_conflict_action
argument_list|,
name|fb
operator|->
name|tree_conflict_reason
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.     Called before either merge_file_changed(), merge_file_added(),    merge_file_deleted() or merge_file_closed(), unless it sets *SKIP to TRUE.     When *SKIP is TRUE, the diff driver avoids work on getting the details    for the closing callbacks.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_file_opened
parameter_list|(
name|void
modifier|*
modifier|*
name|new_file_baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|skip
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|copyfrom_source
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_dir_baton_t
modifier|*
name|pdb
init|=
name|dir_baton
decl_stmt|;
name|struct
name|merge_file_baton_t
modifier|*
name|fb
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|fb
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
expr_stmt|;
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_NONE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
name|fb
operator|->
name|skip_reason
operator|=
name|svn_wc_notify_state_unknown
expr_stmt|;
operator|*
name|new_file_baton
operator|=
name|fb
expr_stmt|;
if|if
condition|(
name|pdb
condition|)
block|{
name|fb
operator|->
name|parent_baton
operator|=
name|pdb
expr_stmt|;
name|fb
operator|->
name|shadowed
operator|=
name|pdb
operator|->
name|shadowed
expr_stmt|;
name|fb
operator|->
name|skip_reason
operator|=
name|pdb
operator|->
name|skip_reason
expr_stmt|;
block|}
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
block|{
comment|/* An ancestor is tree conflicted. Nothing to do here. */
block|}
elseif|else
if|if
condition|(
name|left_source
operator|!=
name|NULL
condition|)
block|{
comment|/* Node is expected to be a file, which will be changed or deleted. */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_deleted
decl_stmt|;
name|svn_boolean_t
name|excluded
decl_stmt|;
name|svn_depth_t
name|parent_depth
decl_stmt|;
if|if
condition|(
operator|!
name|right_source
condition|)
name|fb
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
block|{
name|svn_wc_notify_state_t
name|obstr_state
decl_stmt|;
name|SVN_ERR
argument_list|(
name|perform_obstruction_check
argument_list|(
operator|&
name|obstr_state
argument_list|,
operator|&
name|is_deleted
argument_list|,
operator|&
name|excluded
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|parent_depth
argument_list|,
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstr_state
operator|!=
name|svn_wc_notify_state_inapplicable
condition|)
block|{
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_SKIP
expr_stmt|;
name|fb
operator|->
name|skip_reason
operator|=
name|obstr_state
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|is_deleted
condition|)
name|kind
operator|=
name|svn_node_none
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* If this is not the merge target and the parent is too shallow to              contain this directory, and the directory is not present              via exclusion or depth filtering, skip it instead of recording              a tree conflict.               Non-inheritable mergeinfo will be recorded, allowing              future merges into non-shallow working copies to merge              changes we missed this time around. */
if|if
condition|(
name|pdb
operator|&&
operator|(
name|excluded
operator|||
operator|(
name|parent_depth
operator|!=
name|svn_depth_unknown
operator|&&
name|parent_depth
operator|<
name|svn_depth_files
operator|)
operator|)
condition|)
block|{
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_SKIP
expr_stmt|;
name|fb
operator|->
name|skip_reason
operator|=
name|svn_wc_notify_state_missing
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|is_deleted
condition|)
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
else|else
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_missing
expr_stmt|;
comment|/* ### Similar to directory */
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* ### /Similar */
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
block|{
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_obstructed
expr_stmt|;
comment|/* ### Similar to directory */
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* ### /Similar */
block|}
if|if
condition|(
operator|!
name|right_source
condition|)
block|{
comment|/* We want to delete the directory */
name|fb
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
comment|/* Already set a tree conflict */
block|}
comment|/* Comparison mode to verify for delete tree conflicts? */
if|if
condition|(
name|pdb
operator|&&
name|pdb
operator|->
name|delete_state
operator|&&
name|pdb
operator|->
name|delete_state
operator|->
name|found_edit
condition|)
block|{
comment|/* Earlier nodes found a conflict. Done. */
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|old_tc
init|=
name|NULL
decl_stmt|;
comment|/* The node doesn't exist pre-merge: We have an addition */
name|fb
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_add
expr_stmt|;
if|if
condition|(
name|pdb
operator|&&
name|pdb
operator|->
name|pending_deletes
operator|&&
name|svn_hash_gets
argument_list|(
name|pdb
operator|->
name|pending_deletes
argument_list|,
name|local_abspath
argument_list|)
condition|)
block|{
name|fb
operator|->
name|add_is_replace
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_replace
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|pdb
operator|->
name|pending_deletes
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdb
operator|&&
name|pdb
operator|->
name|new_tree_conflicts
operator|&&
operator|(
name|old_tc
operator|=
name|svn_hash_gets
argument_list|(
name|pdb
operator|->
name|new_tree_conflicts
argument_list|,
name|local_abspath
argument_list|)
operator|)
condition|)
block|{
name|fb
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_replace
expr_stmt|;
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|old_tc
operator|->
name|reason
expr_stmt|;
comment|/* Update the tree conflict to store that this is a replace */
name|SVN_ERR
argument_list|(
name|record_tree_conflict
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|pdb
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|tree_conflict_action
argument_list|,
name|fb
operator|->
name|tree_conflict_reason
argument_list|,
name|old_tc
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_tc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|old_tc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
condition|)
block|{
comment|/* Issue #3806: Incoming replacements on local deletes produce                  inconsistent result.                   In this specific case we can continue applying the add part                  of the replacement. */
block|}
else|else
block|{
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
operator|(
name|merge_b
operator|->
name|dry_run
operator|&&
operator|(
operator|(
name|pdb
operator|&&
name|pdb
operator|->
name|added
operator|)
operator|||
name|fb
operator|->
name|add_is_replace
operator|)
operator|)
condition|)
block|{
name|svn_wc_notify_state_t
name|obstr_state
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_deleted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|perform_obstruction_check
argument_list|(
operator|&
name|obstr_state
argument_list|,
operator|&
name|is_deleted
argument_list|,
name|NULL
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstr_state
operator|!=
name|svn_wc_notify_state_inapplicable
condition|)
block|{
comment|/* Skip the obstruction */
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_SKIP
expr_stmt|;
name|fb
operator|->
name|skip_reason
operator|=
name|obstr_state
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
operator|&&
operator|!
name|is_deleted
condition|)
block|{
comment|/* Set a tree conflict */
name|fb
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|fb
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_obstructed
expr_stmt|;
block|}
block|}
comment|/* Handle pending conflicts */
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.  *  * Called after merge_file_opened() when a node receives only text and/or  * property changes between LEFT_SOURCE and RIGHT_SOURCE.  *  * left_file and right_file can be NULL when the file is not modified.  * left_props and right_props are always available.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_file_changed
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
parameter_list|,
specifier|const
name|char
modifier|*
name|left_file
parameter_list|,
specifier|const
name|char
modifier|*
name|right_file
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|left_props
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|right_props
parameter_list|,
name|svn_boolean_t
name|file_modified
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|prop_changes
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_file_baton_t
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
name|merge_b
operator|->
name|ctx
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right
decl_stmt|;
name|svn_wc_notify_state_t
name|text_state
decl_stmt|;
name|svn_wc_notify_state_t
name|property_state
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|local_abspath
operator|&&
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|left_file
operator|||
name|svn_dirent_is_absolute
argument_list|(
name|left_file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|right_file
operator|||
name|svn_dirent_is_absolute
argument_list|(
name|right_file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
block|{
if|if
condition|(
name|fb
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* We haven't notified for this node yet: report a skip */
name|SVN_ERR
argument_list|(
name|record_skip
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_update_shadowed_update
argument_list|,
name|fb
operator|->
name|skip_reason
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* This callback is essentially no more than a wrapper around      svn_wc_merge5().  Thank goodness that all the      diff-editor-mechanisms are doing the hard work of getting the      fulltexts! */
name|property_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
name|text_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prepare_merge_props_changed
argument_list|(
operator|&
name|prop_changes
argument_list|,
name|local_abspath
argument_list|,
name|prop_changes
argument_list|,
name|merge_b
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_conflict_versions
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
operator|&
name|merge_b
operator|->
name|merge_source
argument_list|,
name|merge_b
operator|->
name|target
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do property merge now, if we are not going to perform a text merge */
if|if
condition|(
operator|(
name|merge_b
operator|->
name|record_only
operator|||
operator|!
name|left_file
operator|)
operator|&&
name|prop_changes
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_merge_props3
argument_list|(
operator|&
name|property_state
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|left_props
argument_list|,
name|prop_changes
argument_list|,
name|merge_b
operator|->
name|dry_run
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|property_state
operator|==
name|svn_wc_notify_state_conflicted
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|conflicted_paths
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Easy out: We are only applying mergeinfo differences. */
if|if
condition|(
name|merge_b
operator|->
name|record_only
condition|)
block|{
comment|/* NO-OP */
block|}
elseif|else
if|if
condition|(
name|left_file
condition|)
block|{
name|svn_boolean_t
name|has_local_mods
decl_stmt|;
name|enum
name|svn_wc_merge_outcome_t
name|content_outcome
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_label
decl_stmt|;
specifier|const
name|char
modifier|*
name|left_label
decl_stmt|;
specifier|const
name|char
modifier|*
name|right_label
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_ext
init|=
literal|""
decl_stmt|;
if|if
condition|(
name|merge_b
operator|->
name|ext_patterns
operator|&&
name|merge_b
operator|->
name|ext_patterns
operator|->
name|nelts
condition|)
block|{
name|svn_path_splitext
argument_list|(
name|NULL
argument_list|,
operator|&
name|path_ext
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|path_ext
operator|&&
name|svn_cstring_match_glob_list
argument_list|(
name|path_ext
argument_list|,
name|merge_b
operator|->
name|ext_patterns
argument_list|)
operator|)
condition|)
block|{
name|path_ext
operator|=
literal|""
expr_stmt|;
block|}
block|}
comment|/* xgettext: the '.working', '.merge-left.r%ld' and          '.merge-right.r%ld' strings are used to tag onto a file          name in case of a merge conflict */
name|target_label
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|".working%s%s"
argument_list|)
argument_list|,
operator|*
name|path_ext
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|path_ext
argument_list|)
expr_stmt|;
name|left_label
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|".merge-left.r%ld%s%s"
argument_list|)
argument_list|,
name|left_source
operator|->
name|revision
argument_list|,
operator|*
name|path_ext
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|path_ext
argument_list|)
expr_stmt|;
name|right_label
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|".merge-right.r%ld%s%s"
argument_list|)
argument_list|,
name|right_source
operator|->
name|revision
argument_list|,
operator|*
name|path_ext
condition|?
literal|"."
else|:
literal|""
argument_list|,
name|path_ext
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_text_modified_p2
argument_list|(
operator|&
name|has_local_mods
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do property merge and text merge in one step so that keyword expansion          takes into account the new property values. */
name|SVN_ERR
argument_list|(
name|svn_wc_merge5
argument_list|(
operator|&
name|content_outcome
argument_list|,
operator|&
name|property_state
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|left_file
argument_list|,
name|right_file
argument_list|,
name|local_abspath
argument_list|,
name|left_label
argument_list|,
name|right_label
argument_list|,
name|target_label
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|merge_b
operator|->
name|dry_run
argument_list|,
name|merge_b
operator|->
name|diff3_cmd
argument_list|,
name|merge_b
operator|->
name|merge_options
argument_list|,
name|left_props
argument_list|,
name|prop_changes
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|content_outcome
operator|==
name|svn_wc_merge_conflict
operator|||
name|property_state
operator|==
name|svn_wc_notify_state_conflicted
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|conflicted_paths
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|content_outcome
operator|==
name|svn_wc_merge_conflict
condition|)
name|text_state
operator|=
name|svn_wc_notify_state_conflicted
expr_stmt|;
elseif|else
if|if
condition|(
name|has_local_mods
operator|&&
name|content_outcome
operator|!=
name|svn_wc_merge_unchanged
condition|)
name|text_state
operator|=
name|svn_wc_notify_state_merged
expr_stmt|;
elseif|else
if|if
condition|(
name|content_outcome
operator|==
name|svn_wc_merge_merged
condition|)
name|text_state
operator|=
name|svn_wc_notify_state_changed
expr_stmt|;
elseif|else
if|if
condition|(
name|content_outcome
operator|==
name|svn_wc_merge_no_merge
condition|)
name|text_state
operator|=
name|svn_wc_notify_state_missing
expr_stmt|;
else|else
comment|/* merge_outcome == svn_wc_merge_unchanged */
name|text_state
operator|=
name|svn_wc_notify_state_unchanged
expr_stmt|;
block|}
if|if
condition|(
name|text_state
operator|==
name|svn_wc_notify_state_conflicted
operator|||
name|text_state
operator|==
name|svn_wc_notify_state_merged
operator|||
name|text_state
operator|==
name|svn_wc_notify_state_changed
operator|||
name|property_state
operator|==
name|svn_wc_notify_state_conflicted
operator|||
name|property_state
operator|==
name|svn_wc_notify_state_merged
operator|||
name|property_state
operator|==
name|svn_wc_notify_state_changed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|record_update_update
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|text_state
argument_list|,
name|property_state
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.  *  * Called after merge_file_opened() when a node doesn't exist in LEFT_SOURCE,  * but does in RIGHT_SOURCE.  *  * When a node is replaced instead of just added a separate opened+deleted will  * be invoked before the current open+added.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_file_added
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|copyfrom_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_file
parameter_list|,
specifier|const
name|char
modifier|*
name|right_file
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|copyfrom_props
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|right_props
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_file_baton_t
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|pristine_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_props
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|local_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
block|{
if|if
condition|(
name|fb
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* We haven't notified for this node yet: report a skip */
name|SVN_ERR
argument_list|(
name|record_skip
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_update_shadowed_add
argument_list|,
name|fb
operator|->
name|skip_reason
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Easy out: We are only applying mergeinfo differences. */
if|if
condition|(
name|merge_b
operator|->
name|record_only
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
operator|)
operator|&&
operator|(
operator|!
name|fb
operator|->
name|parent_baton
operator|||
operator|!
name|fb
operator|->
name|parent_baton
operator|->
name|added
operator|)
condition|)
block|{
comment|/* Store the roots of added subtrees */
name|store_path
argument_list|(
name|merge_b
operator|->
name|added_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|merge_b
operator|->
name|dry_run
condition|)
block|{
specifier|const
name|char
modifier|*
name|copyfrom_url
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
name|svn_stream_t
modifier|*
name|new_contents
decl_stmt|,
modifier|*
name|pristine_contents
decl_stmt|;
comment|/* If this is a merge from the same repository as our          working copy, we handle adds as add-with-history.          Otherwise, we'll use a pure add. */
if|if
condition|(
name|merge_b
operator|->
name|same_repos
condition|)
block|{
specifier|const
name|char
modifier|*
name|child
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|copyfrom_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|merge_b
operator|->
name|merge_source
operator|.
name|loc2
operator|->
name|url
argument_list|,
name|child
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|copyfrom_rev
operator|=
name|right_source
operator|->
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_repos_match
argument_list|(
name|merge_b
operator|->
name|target
argument_list|,
name|local_abspath
argument_list|,
name|copyfrom_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|pristine_contents
argument_list|,
name|right_file
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_contents
operator|=
name|NULL
expr_stmt|;
comment|/* inherit from new_base_contents */
name|pristine_props
operator|=
name|right_props
expr_stmt|;
comment|/* Includes last_* information */
name|new_props
operator|=
name|NULL
expr_stmt|;
comment|/* No local changes */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|pristine_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|paths_with_new_mergeinfo
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|apr_array_header_t
modifier|*
name|regular_props
decl_stmt|;
name|copyfrom_url
operator|=
name|NULL
expr_stmt|;
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|pristine_contents
operator|=
name|svn_stream_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|new_contents
argument_list|,
name|right_file
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|pristine_props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Local addition */
comment|/* We don't want any foreign properties */
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|svn_prop_hash_to_array
argument_list|(
name|right_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|regular_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|regular_props
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Issue #3383: We don't want mergeinfo from a foreign repository. */
name|svn_hash_sets
argument_list|(
name|new_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Do everything like if we had called 'svn cp PATH1 PATH2'. */
name|SVN_ERR
argument_list|(
name|svn_wc_add_repos_file4
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|pristine_contents
argument_list|,
name|new_contents
argument_list|,
name|pristine_props
argument_list|,
name|new_props
argument_list|,
name|copyfrom_url
argument_list|,
name|copyfrom_rev
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Caller must call svn_sleep_for_timestamps() */
operator|*
name|merge_b
operator|->
name|use_sleep
operator|=
name|TRUE
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|record_update_add
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|add_is_replace
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compare the two sets of properties PROPS1 and PROPS2, ignoring the  * "svn:mergeinfo" property, and noticing only "normal" props. Set *SAME to  * true if the rest of the properties are identical or false if they differ.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|properties_same_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|same
parameter_list|,
name|apr_hash_t
modifier|*
name|props1
parameter_list|,
name|apr_hash_t
modifier|*
name|props2
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|prop_changes
decl_stmt|;
name|int
name|i
decl_stmt|,
name|diffs
decl_stmt|;
comment|/* Examine the properties that differ */
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|prop_changes
argument_list|,
name|props1
argument_list|,
name|props2
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|diffs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prop_changes
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|pname
init|=
name|APR_ARRAY_IDX
argument_list|(
name|prop_changes
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
operator|.
name|name
decl_stmt|;
comment|/* Count the properties we're interested in; ignore the rest */
if|if
condition|(
name|svn_wc_is_normal_prop
argument_list|(
name|pname
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|pname
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|!=
literal|0
condition|)
name|diffs
operator|++
expr_stmt|;
block|}
operator|*
name|same
operator|=
operator|(
name|diffs
operator|==
literal|0
operator|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compare the file OLDER_ABSPATH (together with its normal properties in  * ORIGINAL_PROPS which may also contain WC props and entry props) with the  * versioned file MINE_ABSPATH (together with its versioned properties).  * Set *SAME to true if they are the same or false if they differ, ignoring  * the "svn:mergeinfo" property, and ignoring differences in keyword  * expansion and end-of-line style. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|files_same_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|same
parameter_list|,
specifier|const
name|char
modifier|*
name|older_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|original_props
parameter_list|,
specifier|const
name|char
modifier|*
name|mine_abspath
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|working_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_prop_list2
argument_list|(
operator|&
name|working_props
argument_list|,
name|wc_ctx
argument_list|,
name|mine_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compare the properties */
name|SVN_ERR
argument_list|(
name|properties_same_p
argument_list|(
name|same
argument_list|,
name|original_props
argument_list|,
name|working_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|same
condition|)
block|{
name|svn_stream_t
modifier|*
name|mine_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|older_stream
decl_stmt|;
name|svn_opt_revision_t
name|working_rev
init|=
block|{
name|svn_opt_revision_working
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
comment|/* Compare the file content, translating 'mine' to 'normal' form. */
if|if
condition|(
name|svn_prop_get_value
argument_list|(
name|working_props
argument_list|,
name|SVN_PROP_SPECIAL
argument_list|)
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_read_specialfile
argument_list|(
operator|&
name|mine_stream
argument_list|,
name|mine_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_client__get_normalized_stream
argument_list|(
operator|&
name|mine_stream
argument_list|,
name|wc_ctx
argument_list|,
name|mine_abspath
argument_list|,
operator|&
name|working_rev
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|older_stream
argument_list|,
name|older_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_contents_same2
argument_list|(
name|same
argument_list|,
name|mine_stream
argument_list|,
name|older_stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.  *  * Called after merge_file_opened() when a node does exist in LEFT_SOURCE, but  * no longer exists (or is replaced) in RIGHT_SOURCE.  *  * When a node is replaced instead of just added a separate opened+added will  * be invoked after the current open+deleted.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_file_deleted
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
parameter_list|,
specifier|const
name|char
modifier|*
name|left_file
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|left_props
parameter_list|,
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_file_baton_t
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|same
decl_stmt|;
name|SVN_ERR
argument_list|(
name|mark_file_edited
argument_list|(
name|merge_b
argument_list|,
name|fb
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|shadowed
condition|)
block|{
if|if
condition|(
name|fb
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* We haven't notified for this node yet: report a skip */
name|SVN_ERR
argument_list|(
name|record_skip
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_update_shadowed_delete
argument_list|,
name|fb
operator|->
name|skip_reason
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Easy out: We are only applying mergeinfo differences. */
if|if
condition|(
name|merge_b
operator|->
name|record_only
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If the files are identical, attempt deletion */
if|if
condition|(
name|merge_b
operator|->
name|force_delete
condition|)
name|same
operator|=
name|TRUE
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|files_same_p
argument_list|(
operator|&
name|same
argument_list|,
name|left_file
argument_list|,
name|left_props
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fb
operator|->
name|parent_baton
operator|&&
name|fb
operator|->
name|parent_baton
operator|->
name|delete_state
condition|)
block|{
if|if
condition|(
name|same
condition|)
block|{
comment|/* Note that we checked this file */
name|store_path
argument_list|(
name|fb
operator|->
name|parent_baton
operator|->
name|delete_state
operator|->
name|compared_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We found some modification. Parent should raise a tree conflict */
name|fb
operator|->
name|parent_baton
operator|->
name|delete_state
operator|->
name|found_edit
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|same
condition|)
block|{
if|if
condition|(
operator|!
name|merge_b
operator|->
name|dry_run
condition|)
name|SVN_ERR
argument_list|(
name|svn_wc_delete4
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_local */
argument_list|,
name|FALSE
comment|/* unversioned */
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* no notify */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record that we might have deleted mergeinfo */
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|paths_with_deleted_mergeinfo
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* And notify the deletion */
name|SVN_ERR
argument_list|(
name|record_update_delete
argument_list|(
name|merge_b
argument_list|,
name|fb
operator|->
name|parent_baton
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The files differ, so raise a conflict instead of deleting */
comment|/* This is use case 5 described in the paper attached to issue        * #2282.  See also notes/tree-conflicts/detection.txt        */
name|SVN_ERR
argument_list|(
name|record_tree_conflict
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|fb
operator|->
name|parent_baton
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_conflict_action_delete
argument_list|,
name|svn_wc_conflict_reason_edited
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.     Called before either merge_dir_changed(), merge_dir_added(),    merge_dir_deleted() or merge_dir_closed(), unless it sets *SKIP to TRUE.     After this call and before the close call, all descendants will receive    their changes, unless *SKIP_CHILDREN is set to TRUE.     When *SKIP is TRUE, the diff driver avoids work on getting the details    for the closing callbacks.     The SKIP and SKIP_DESCENDANTS work independantly.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_dir_opened
parameter_list|(
name|void
modifier|*
modifier|*
name|new_dir_baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|skip
parameter_list|,
name|svn_boolean_t
modifier|*
name|skip_children
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|copyfrom_source
parameter_list|,
name|void
modifier|*
name|parent_dir_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_dir_baton_t
modifier|*
name|db
decl_stmt|;
name|struct
name|merge_dir_baton_t
modifier|*
name|pdb
init|=
name|parent_dir_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|db
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|db
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_NONE
expr_stmt|;
name|db
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
name|db
operator|->
name|skip_reason
operator|=
name|svn_wc_notify_state_unknown
expr_stmt|;
operator|*
name|new_dir_baton
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|pdb
condition|)
block|{
name|db
operator|->
name|parent_baton
operator|=
name|pdb
expr_stmt|;
name|db
operator|->
name|shadowed
operator|=
name|pdb
operator|->
name|shadowed
expr_stmt|;
name|db
operator|->
name|skip_reason
operator|=
name|pdb
operator|->
name|skip_reason
expr_stmt|;
block|}
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
comment|/* An ancestor is tree conflicted. Nothing to do here. */
if|if
condition|(
operator|!
name|left_source
condition|)
name|db
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left_source
operator|!=
name|NULL
condition|)
block|{
comment|/* Node is expected to be a directory. */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_deleted
decl_stmt|;
name|svn_boolean_t
name|excluded
decl_stmt|;
name|svn_depth_t
name|parent_depth
decl_stmt|;
if|if
condition|(
operator|!
name|right_source
condition|)
name|db
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
comment|/* Check for an obstructed or missing node on disk. */
block|{
name|svn_wc_notify_state_t
name|obstr_state
decl_stmt|;
name|SVN_ERR
argument_list|(
name|perform_obstruction_check
argument_list|(
operator|&
name|obstr_state
argument_list|,
operator|&
name|is_deleted
argument_list|,
operator|&
name|excluded
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|parent_depth
argument_list|,
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstr_state
operator|!=
name|svn_wc_notify_state_inapplicable
condition|)
block|{
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|obstr_state
operator|==
name|svn_wc_notify_state_obstructed
condition|)
block|{
name|svn_boolean_t
name|is_wcroot
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_check_root
argument_list|(
operator|&
name|is_wcroot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_wcroot
condition|)
block|{
name|db
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_SKIP_WC
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|db
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_SKIP
expr_stmt|;
name|db
operator|->
name|skip_reason
operator|=
name|obstr_state
expr_stmt|;
if|if
condition|(
operator|!
name|right_source
condition|)
block|{
operator|*
name|skip
operator|=
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|is_deleted
condition|)
name|kind
operator|=
name|svn_node_none
expr_stmt|;
block|}
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
comment|/* If this is not the merge target and the parent is too shallow to              contain this directory, and the directory is not presen              via exclusion or depth filtering, skip it instead of recording              a tree conflict.               Non-inheritable mergeinfo will be recorded, allowing              future merges into non-shallow working copies to merge              changes we missed this time around. */
if|if
condition|(
name|pdb
operator|&&
operator|(
name|excluded
operator|||
operator|(
name|parent_depth
operator|!=
name|svn_depth_unknown
operator|&&
name|parent_depth
operator|<
name|svn_depth_immediates
operator|)
operator|)
condition|)
block|{
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_SKIP
expr_stmt|;
name|db
operator|->
name|skip_reason
operator|=
name|svn_wc_notify_state_missing
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|is_deleted
condition|)
name|db
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_deleted
expr_stmt|;
else|else
name|db
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_missing
expr_stmt|;
comment|/* ### To avoid breaking tests */
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* ### /avoid breaking tests */
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_obstructed
expr_stmt|;
comment|/* ### To avoid breaking tests */
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* ### /avoid breaking tests */
block|}
if|if
condition|(
operator|!
name|right_source
condition|)
block|{
comment|/* We want to delete the directory */
comment|/* Mark PB edited now? */
name|db
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_delete
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
comment|/* Already set a tree conflict */
block|}
name|db
operator|->
name|delete_state
operator|=
operator|(
name|pdb
operator|!=
name|NULL
operator|)
condition|?
name|pdb
operator|->
name|delete_state
else|:
name|NULL
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|delete_state
operator|&&
name|db
operator|->
name|delete_state
operator|->
name|found_edit
condition|)
block|{
comment|/* A sibling found a conflict. Done. */
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|merge_b
operator|->
name|force_delete
condition|)
block|{
comment|/* No comparison necessary */
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|db
operator|->
name|delete_state
condition|)
block|{
comment|/* Start descendant comparison */
name|db
operator|->
name|delete_state
operator|=
name|apr_pcalloc
argument_list|(
name|db
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
operator|->
name|delete_state
argument_list|)
argument_list|)
expr_stmt|;
name|db
operator|->
name|delete_state
operator|->
name|del_root
operator|=
name|db
expr_stmt|;
name|db
operator|->
name|delete_state
operator|->
name|compared_abspaths
operator|=
name|apr_hash_make
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
specifier|const
name|svn_wc_conflict_description2_t
modifier|*
name|old_tc
init|=
name|NULL
decl_stmt|;
comment|/* The node doesn't exist pre-merge: We have an addition */
name|db
operator|->
name|added
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_add
expr_stmt|;
if|if
condition|(
name|pdb
operator|&&
name|pdb
operator|->
name|pending_deletes
operator|&&
name|svn_hash_gets
argument_list|(
name|pdb
operator|->
name|pending_deletes
argument_list|,
name|local_abspath
argument_list|)
condition|)
block|{
name|db
operator|->
name|add_is_replace
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_replace
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|pdb
operator|->
name|pending_deletes
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pdb
operator|&&
name|pdb
operator|->
name|new_tree_conflicts
operator|&&
operator|(
name|old_tc
operator|=
name|svn_hash_gets
argument_list|(
name|pdb
operator|->
name|new_tree_conflicts
argument_list|,
name|local_abspath
argument_list|)
operator|)
condition|)
block|{
name|db
operator|->
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_replace
expr_stmt|;
name|db
operator|->
name|tree_conflict_reason
operator|=
name|old_tc
operator|->
name|reason
expr_stmt|;
if|if
condition|(
name|old_tc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_deleted
operator|||
name|old_tc
operator|->
name|reason
operator|==
name|svn_wc_conflict_reason_moved_away
condition|)
block|{
comment|/* Issue #3806: Incoming replacements on local deletes produce                  inconsistent result.                   In this specific case we can continue applying the add part                  of the replacement. */
block|}
else|else
block|{
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
comment|/* Update the tree conflict to store that this is a replace */
name|SVN_ERR
argument_list|(
name|record_tree_conflict
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|pdb
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|tree_conflict_action
argument_list|,
name|db
operator|->
name|tree_conflict_reason
argument_list|,
name|old_tc
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|merge_b
operator|->
name|dry_run
operator|&&
operator|(
operator|(
name|pdb
operator|&&
name|pdb
operator|->
name|added
operator|)
operator|||
name|db
operator|->
name|add_is_replace
operator|)
operator|)
condition|)
block|{
name|svn_wc_notify_state_t
name|obstr_state
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_boolean_t
name|is_deleted
decl_stmt|;
name|SVN_ERR
argument_list|(
name|perform_obstruction_check
argument_list|(
operator|&
name|obstr_state
argument_list|,
operator|&
name|is_deleted
argument_list|,
name|NULL
argument_list|,
operator|&
name|kind
argument_list|,
name|NULL
argument_list|,
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In this case of adding a directory, we have an exception to the            * usual "skip if it's inconsistent" rule. If the directory exists            * on disk unexpectedly, we simply make it versioned, because we can            * do so without risk of destroying data. Only skip if it is            * versioned but unexpectedly missing from disk, or is unversioned            * but obstructed by a node of the wrong kind. */
if|if
condition|(
name|obstr_state
operator|==
name|svn_wc_notify_state_obstructed
operator|&&
operator|(
name|is_deleted
operator|||
name|kind
operator|==
name|svn_node_none
operator|)
condition|)
block|{
name|svn_node_kind_t
name|disk_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|local_abspath
argument_list|,
operator|&
name|disk_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|disk_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|obstr_state
operator|=
name|svn_wc_notify_state_inapplicable
expr_stmt|;
name|db
operator|->
name|add_existing
operator|=
name|TRUE
expr_stmt|;
comment|/* Take over existing directory */
block|}
block|}
if|if
condition|(
name|obstr_state
operator|!=
name|svn_wc_notify_state_inapplicable
condition|)
block|{
comment|/* Skip the obstruction */
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_SKIP
expr_stmt|;
name|db
operator|->
name|skip_reason
operator|=
name|obstr_state
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|kind
operator|!=
name|svn_node_none
operator|&&
operator|!
name|is_deleted
condition|)
block|{
comment|/* Set a tree conflict */
name|db
operator|->
name|shadowed
operator|=
name|TRUE
expr_stmt|;
name|db
operator|->
name|tree_conflict_reason
operator|=
name|svn_wc_conflict_reason_obstructed
expr_stmt|;
block|}
block|}
comment|/* Handle pending conflicts */
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
comment|/* Notified and done. Skip children? */
block|}
elseif|else
if|if
condition|(
name|merge_b
operator|->
name|record_only
condition|)
block|{
comment|/* Ok, we are done for this node and its descendants */
operator|*
name|skip
operator|=
name|TRUE
expr_stmt|;
operator|*
name|skip_children
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|merge_b
operator|->
name|dry_run
condition|)
block|{
comment|/* Create the directory on disk, to allow descendants to be added */
if|if
condition|(
operator|!
name|db
operator|->
name|add_existing
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|local_abspath
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_tc
condition|)
block|{
comment|/* svn_wc_add4 and svn_wc_add_from_disk2 can't add a node                  over an existing tree conflict */
comment|/* ### These functions should take some tree conflict argument                      and allow overwriting the tc when one is passed */
name|SVN_ERR
argument_list|(
name|svn_wc__del_tree_conflict
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_b
operator|->
name|same_repos
condition|)
block|{
specifier|const
name|char
modifier|*
name|original_url
decl_stmt|;
name|original_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|merge_b
operator|->
name|merge_source
operator|.
name|loc2
operator|->
name|url
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Limitation (aka HACK):                  We create a newly added directory with an original URL and                  revision as that in the repository, but without its properties                  and children.                   When the merge is cancelled before the final dir_added(), the                  copy won't really represent the in-repository state of the node.                */
name|SVN_ERR
argument_list|(
name|svn_wc_add4
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|original_url
argument_list|,
name|right_source
operator|->
name|revision
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* no notify! */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_wc_add_from_disk2
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* no notify! */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|old_tc
operator|!=
name|NULL
condition|)
block|{
comment|/* ### Should be atomic with svn_wc_add(4|_from_disk2)() */
name|SVN_ERR
argument_list|(
name|record_tree_conflict
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|pdb
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|tree_conflict_action
argument_list|,
name|db
operator|->
name|tree_conflict_reason
argument_list|,
name|old_tc
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|db
operator|->
name|shadowed
operator|&&
operator|!
name|merge_b
operator|->
name|record_only
condition|)
name|SVN_ERR
argument_list|(
name|record_update_add
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|add_is_replace
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.  *  * Called after merge_dir_opened() when a node exists in both the left and  * right source, but has its properties changed inbetween.  *  * After the merge_dir_opened() but before the call to this merge_dir_changed()  * function all descendants will have been updated.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_dir_changed
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|left_props
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|right_props
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|prop_changes
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_dir_baton_t
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|props
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|handle_pending_notifications
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* We haven't notified for this node yet: report a skip */
name|SVN_ERR
argument_list|(
name|record_skip
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_update_shadowed_update
argument_list|,
name|db
operator|->
name|skip_reason
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|prepare_merge_props_changed
argument_list|(
operator|&
name|props
argument_list|,
name|local_abspath
argument_list|,
name|prop_changes
argument_list|,
name|merge_b
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|->
name|nelts
condition|)
block|{
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|left
decl_stmt|;
specifier|const
name|svn_wc_conflict_version_t
modifier|*
name|right
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
name|merge_b
operator|->
name|ctx
decl_stmt|;
name|svn_wc_notify_state_t
name|prop_state
decl_stmt|;
name|SVN_ERR
argument_list|(
name|make_conflict_versions
argument_list|(
operator|&
name|left
argument_list|,
operator|&
name|right
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
operator|&
name|merge_b
operator|->
name|merge_source
argument_list|,
name|merge_b
operator|->
name|target
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_merge_props3
argument_list|(
operator|&
name|prop_state
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|left
argument_list|,
name|right
argument_list|,
name|left_props
argument_list|,
name|props
argument_list|,
name|merge_b
operator|->
name|dry_run
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_state
operator|==
name|svn_wc_notify_state_conflicted
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|conflicted_paths
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prop_state
operator|==
name|svn_wc_notify_state_conflicted
operator|||
name|prop_state
operator|==
name|svn_wc_notify_state_merged
operator|||
name|prop_state
operator|==
name|svn_wc_notify_state_changed
condition|)
block|{
name|SVN_ERR
argument_list|(
name|record_update_update
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_file
argument_list|,
name|svn_wc_notify_state_inapplicable
argument_list|,
name|prop_state
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.  *  * Called after merge_dir_opened() when a node doesn't exist in LEFT_SOURCE,  * but does in RIGHT_SOURCE. After the merge_dir_opened() but before the call  * to this merge_dir_added() function all descendants will have been added.  *  * When a node is replaced instead of just added a separate opened+deleted will  * be invoked before the current open+added.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_dir_added
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|copyfrom_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|copyfrom_props
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|right_props
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_dir_baton_t
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* For consistency; usually a no-op from _dir_added() */
name|SVN_ERR
argument_list|(
name|handle_pending_notifications
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* We haven't notified for this node yet: report a skip */
name|SVN_ERR
argument_list|(
name|record_skip
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_update_shadowed_add
argument_list|,
name|db
operator|->
name|skip_reason
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|db
operator|->
name|edited
comment|/* Marked edited from merge_open_dir() */
operator|&&
operator|!
name|merge_b
operator|->
name|record_only
comment|/* Skip details from merge_open_dir() */
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
operator|||
name|merge_b
operator|->
name|reintegrate_merge
operator|)
operator|&&
operator|(
operator|!
name|db
operator|->
name|parent_baton
operator|||
operator|!
name|db
operator|->
name|parent_baton
operator|->
name|added
operator|)
condition|)
block|{
comment|/* Store the roots of added subtrees */
name|store_path
argument_list|(
name|merge_b
operator|->
name|added_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|merge_b
operator|->
name|same_repos
condition|)
block|{
comment|/* When the directory was added in merge_dir_added() we didn't update its          pristine properties. Instead we receive the property changes later and          apply them in this function.           If we would apply them as changes (such as before fixing issue #3405),          we would see the unmodified properties as local changes, and the          pristine properties would be out of sync with what the repository          expects for this directory.           Instead of doing that we now simply set the properties as the pristine          properties via a private libsvn_wc api.       */
specifier|const
name|char
modifier|*
name|copyfrom_url
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|child
decl_stmt|;
comment|/* Creating a hash containing regular and entry props */
name|apr_hash_t
modifier|*
name|new_pristine_props
init|=
name|right_props
decl_stmt|;
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|child
operator|=
name|svn_dirent_is_child
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|copyfrom_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|merge_b
operator|->
name|merge_source
operator|.
name|loc2
operator|->
name|url
argument_list|,
name|child
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|copyfrom_rev
operator|=
name|right_source
operator|->
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_repos_match
argument_list|(
name|merge_b
operator|->
name|target
argument_list|,
name|parent_abspath
argument_list|,
name|copyfrom_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_b
operator|->
name|dry_run
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_wc__complete_directory_add
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|new_pristine_props
argument_list|,
name|copyfrom_url
argument_list|,
name|copyfrom_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|new_pristine_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|paths_with_new_mergeinfo
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|apr_array_header_t
modifier|*
name|regular_props
decl_stmt|;
name|apr_hash_t
modifier|*
name|new_props
decl_stmt|;
name|svn_wc_notify_state_t
name|prop_state
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|svn_prop_hash_to_array
argument_list|(
name|right_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|regular_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|regular_props
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|new_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* ### What is the easiest way to set new_props on LOCAL_ABSPATH?           ### This doesn't need a merge as we just added the node          ### (or installed a tree conflict and skipped this node)*/
name|SVN_ERR
argument_list|(
name|svn_wc_merge_props3
argument_list|(
operator|&
name|prop_state
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
argument_list|,
name|svn_prop_hash_to_array
argument_list|(
name|new_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|merge_b
operator|->
name|dry_run
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_state
operator|==
name|svn_wc_notify_state_conflicted
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|conflicted_paths
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for merge_dir_deleted. Implement svn_wc_status_func4_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_touched_by_del_check
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|dir_delete_baton_t
modifier|*
name|delb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|delb
operator|->
name|compared_abspaths
argument_list|,
name|local_abspath
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
switch|switch
condition|(
name|status
operator|->
name|node_status
condition|)
block|{
case|case
name|svn_wc_status_deleted
case|:
case|case
name|svn_wc_status_ignored
case|:
case|case
name|svn_wc_status_none
case|:
return|return
name|SVN_NO_ERROR
return|;
default|default:
name|delb
operator|->
name|found_edit
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CEASE_INVOCATION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.  *  * Called after merge_dir_opened() when a node existed only in the left source.  *  * After the merge_dir_opened() but before the call to this merge_dir_deleted()  * function all descendants that existed in left_source will have been deleted.  *  * If this node is replaced, an _opened() followed by a matching _add() will  * be invoked after this function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_dir_deleted
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
parameter_list|,
comment|/*const*/
name|apr_hash_t
modifier|*
name|left_props
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_dir_baton_t
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|same
decl_stmt|;
name|apr_hash_t
modifier|*
name|working_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|handle_pending_notifications
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mark_dir_edited
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|->
name|shadowed
condition|)
block|{
if|if
condition|(
name|db
operator|->
name|tree_conflict_reason
operator|==
name|CONFLICT_REASON_NONE
condition|)
block|{
comment|/* We haven't notified for this node yet: report a skip */
name|SVN_ERR
argument_list|(
name|record_skip
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_notify_update_shadowed_delete
argument_list|,
name|db
operator|->
name|skip_reason
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Easy out: We are only applying mergeinfo differences. */
if|if
condition|(
name|merge_b
operator|->
name|record_only
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_wc_prop_list2
argument_list|(
operator|&
name|working_props
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_b
operator|->
name|force_delete
condition|)
block|{
comment|/* In this legacy mode we just assume that a directory delete          matches any directory. db->delete_state is NULL */
name|same
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dir_delete_baton_t
modifier|*
name|delb
decl_stmt|;
comment|/* Compare the properties */
name|SVN_ERR
argument_list|(
name|properties_same_p
argument_list|(
operator|&
name|same
argument_list|,
name|left_props
argument_list|,
name|working_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|delb
operator|=
name|db
operator|->
name|delete_state
expr_stmt|;
name|assert
argument_list|(
name|delb
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same
condition|)
block|{
name|delb
operator|->
name|found_edit
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|store_path
argument_list|(
name|delb
operator|->
name|compared_abspaths
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delb
operator|->
name|del_root
operator|!=
name|db
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|delb
operator|->
name|found_edit
condition|)
name|same
operator|=
name|FALSE
expr_stmt|;
else|else
block|{
name|apr_array_header_t
modifier|*
name|ignores
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|same
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_get_default_ignores
argument_list|(
operator|&
name|ignores
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|config
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* None of the descendants was modified, but maybe there are              descendants we haven't walked?               Note that we aren't interested in changes, as we already verified              changes in the paths touched by the merge. And the existence of              other paths is enough to mark the directory edited */
name|err
operator|=
name|svn_wc_walk_status
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|TRUE
comment|/* get-all */
argument_list|,
name|FALSE
comment|/* no-ignore */
argument_list|,
name|TRUE
comment|/* ignore-text-mods */
argument_list|,
name|ignores
argument_list|,
name|verify_touched_by_del_check
argument_list|,
name|delb
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_CEASE_INVOCATION
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|same
operator|=
operator|!
name|delb
operator|->
name|found_edit
expr_stmt|;
block|}
block|}
if|if
condition|(
name|same
operator|&&
operator|!
name|merge_b
operator|->
name|dry_run
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_wc_delete4
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|FALSE
comment|/* keep_local */
argument_list|,
name|FALSE
comment|/* unversioned */
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
comment|/* no notify */
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_LEFT_LOCAL_MOD
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|same
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|same
condition|)
block|{
comment|/* If the attempt to delete an existing directory failed,        * the directory has local modifications (e.g. locally added        * files, or property changes). Flag a tree conflict. */
comment|/* This handles use case 5 described in the paper attached to issue        * #2282.  See also notes/tree-conflicts/detection.txt        */
name|SVN_ERR
argument_list|(
name|record_tree_conflict
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|db
operator|->
name|parent_baton
argument_list|,
name|svn_node_dir
argument_list|,
name|svn_wc_conflict_action_delete
argument_list|,
name|svn_wc_conflict_reason_edited
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Record that we might have deleted mergeinfo */
if|if
condition|(
name|working_props
operator|&&
name|svn_hash_gets
argument_list|(
name|working_props
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
condition|)
block|{
name|alloc_and_store_path
argument_list|(
operator|&
name|merge_b
operator|->
name|paths_with_deleted_mergeinfo
argument_list|,
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|record_update_delete
argument_list|(
name|merge_b
argument_list|,
name|db
operator|->
name|parent_baton
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.  *  * Called after merge_dir_opened() when a node itself didn't change between  * the left and right source.  *  * After the merge_dir_opened() but before the call to this merge_dir_closed()  * function all descendants will have been processed.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_dir_closed
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
parameter_list|,
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|struct
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
name|struct
name|merge_dir_baton_t
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|handle_pending_notifications
argument_list|(
name|merge_b
argument_list|,
name|db
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* An svn_diff_tree_processor_t function.     Called when the diff driver wants to report an absent path.     In case of merges this happens when the diff encounters a server-excluded    path.     We register a skipped path, which will make parent mergeinfo non-    inheritable. This ensures that a future merge might see these skipped    changes as eligable for merging.     For legacy reasons we also notify the path as skipped.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_node_absent
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
modifier|*
name|merge_b
init|=
name|processor
operator|->
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn_dirent_join
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|record_skip
argument_list|(
name|merge_b
argument_list|,
name|local_abspath
argument_list|,
name|svn_node_unknown
argument_list|,
name|svn_wc_notify_skip
argument_list|,
name|svn_wc_notify_state_missing
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Merge Notification ***/
end_comment

begin_comment
comment|/* Finds a nearest ancestor in CHILDREN_WITH_MERGEINFO for LOCAL_ABSPATH. If    PATH_IS_OWN_ANCESTOR is TRUE then a child in CHILDREN_WITH_MERGEINFO    where child->abspath == PATH is considered PATH's ancestor.  If FALSE,    then child->abspath must be a proper ancestor of PATH.     CHILDREN_WITH_MERGEINFO is expected to be sorted in Depth first    order of path. */
end_comment

begin_function
specifier|static
name|svn_client__merge_path_t
modifier|*
name|find_nearest_ancestor
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|svn_boolean_t
name|path_is_own_ancestor
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|children_with_mergeinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|children_with_mergeinfo
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_dirent_is_ancestor
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|)
operator|&&
operator|(
name|path_is_own_ancestor
operator|||
name|strcmp
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
operator|)
condition|)
return|return
name|child
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Find the highest level path in a merge target (possibly the merge target    itself) to use in a merge notification header.     Return the svn_client__merge_path_t * representing the most distant    ancestor in CHILDREN_WITH_MERGEINFO of LOCAL_ABSPATH where said    ancestor's first remaining ranges element (per the REMAINING_RANGES    member of the ancestor) intersect with the first remaining ranges element    for every intermediate ancestor svn_client__merge_path_t * of    LOCAL_ABSPATH.  If no such ancestor is found return NULL.     If the remaining ranges of the elements in CHILDREN_WITH_MERGEINFO    represent a forward merge, then set *START to the oldest revision found    in any of the intersecting ancestors and *END to the youngest revision    found.  If the remaining ranges of the elements in CHILDREN_WITH_MERGEINFO    represent a reverse merge, then set *START to the youngest revision    found and *END to the oldest revision found.  If no ancestors are found    then set *START and *END to SVN_INVALID_REVNUM.     If PATH_IS_OWN_ANCESTOR is TRUE then a child in CHILDREN_WITH_MERGEINFO    where child->abspath == PATH is considered PATH's ancestor.  If FALSE,    then child->abspath must be a proper ancestor of PATH.     See the CHILDREN_WITH_MERGEINFO ARRAY global comment for more    information. */
end_comment

begin_function
specifier|static
name|svn_client__merge_path_t
modifier|*
name|find_nearest_ancestor_with_intersecting_ranges
parameter_list|(
name|svn_revnum_t
modifier|*
name|start
parameter_list|,
name|svn_revnum_t
modifier|*
name|end
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|svn_boolean_t
name|path_is_own_ancestor
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|nearest_ancestor
init|=
name|NULL
decl_stmt|;
operator|*
name|start
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|end
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|children_with_mergeinfo
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|children_with_mergeinfo
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_dirent_is_ancestor
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|)
operator|&&
operator|(
name|path_is_own_ancestor
operator|||
name|strcmp
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|local_abspath
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|nearest_ancestor
operator|==
name|NULL
condition|)
block|{
comment|/* Found an ancestor. */
name|nearest_ancestor
operator|=
name|child
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|remaining_ranges
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|r1
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
operator|*
name|start
operator|=
name|r1
operator|->
name|start
expr_stmt|;
operator|*
name|end
operator|=
name|r1
operator|->
name|end
expr_stmt|;
block|}
else|else
block|{
comment|/* If CHILD->REMAINING_RANGES is null then LOCAL_ABSPATH                      is inside an absent subtree in the merge target. */
operator|*
name|start
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|end
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* We'e found another ancestor for LOCAL_ABSPATH.  Do its                  first remaining range intersect with the previously                  found ancestor? */
name|svn_merge_range_t
modifier|*
name|r1
init|=
name|APR_ARRAY_IDX
argument_list|(
name|nearest_ancestor
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|r2
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|r1
operator|&&
name|r2
condition|)
block|{
name|svn_merge_range_t
name|range1
decl_stmt|;
name|svn_merge_range_t
name|range2
decl_stmt|;
name|svn_boolean_t
name|reverse_merge
init|=
name|r1
operator|->
name|start
operator|>
name|r2
operator|->
name|end
decl_stmt|;
comment|/* Flip endpoints if this is a reverse merge. */
if|if
condition|(
name|reverse_merge
condition|)
block|{
name|range1
operator|.
name|start
operator|=
name|r1
operator|->
name|end
expr_stmt|;
name|range1
operator|.
name|end
operator|=
name|r1
operator|->
name|start
expr_stmt|;
name|range2
operator|.
name|start
operator|=
name|r2
operator|->
name|end
expr_stmt|;
name|range2
operator|.
name|end
operator|=
name|r2
operator|->
name|start
expr_stmt|;
block|}
else|else
block|{
name|range1
operator|.
name|start
operator|=
name|r1
operator|->
name|start
expr_stmt|;
name|range1
operator|.
name|end
operator|=
name|r1
operator|->
name|end
expr_stmt|;
name|range2
operator|.
name|start
operator|=
name|r2
operator|->
name|start
expr_stmt|;
name|range2
operator|.
name|end
operator|=
name|r2
operator|->
name|end
expr_stmt|;
block|}
if|if
condition|(
name|range1
operator|.
name|start
operator|<
name|range2
operator|.
name|end
operator|&&
name|range2
operator|.
name|start
operator|<
name|range1
operator|.
name|end
condition|)
block|{
operator|*
name|start
operator|=
name|reverse_merge
condition|?
name|MAX
argument_list|(
name|r1
operator|->
name|start
argument_list|,
name|r2
operator|->
name|start
argument_list|)
else|:
name|MIN
argument_list|(
name|r1
operator|->
name|start
argument_list|,
name|r2
operator|->
name|start
argument_list|)
expr_stmt|;
operator|*
name|end
operator|=
name|reverse_merge
condition|?
name|MIN
argument_list|(
name|r1
operator|->
name|end
argument_list|,
name|r2
operator|->
name|end
argument_list|)
else|:
name|MAX
argument_list|(
name|r1
operator|->
name|end
argument_list|,
name|r2
operator|->
name|end
argument_list|)
expr_stmt|;
name|nearest_ancestor
operator|=
name|child
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
return|return
name|nearest_ancestor
return|;
block|}
end_function

begin_comment
comment|/* Notify that we're starting to record mergeinfo for the merge of the  * revision range RANGE into TARGET_ABSPATH.  RANGE should be null if the  * merge sources are not from the same URL.  *  * This calls the client's notification receiver (as found in the client  * context), with a WC abspath.  */
end_comment

begin_function
specifier|static
name|void
name|notify_mergeinfo_recording
parameter_list|(
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|range
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|n
init|=
name|svn_wc_create_notify
argument_list|(
name|target_abspath
argument_list|,
name|svn_wc_notify_merge_record_info_begin
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|n
operator|->
name|merge_range
operator|=
name|range
condition|?
name|svn_merge_range_dup
argument_list|(
name|range
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|n
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Notify that we're completing the merge into TARGET_ABSPATH.  *  * This calls the client's notification receiver (as found in the client  * context), with a WC abspath.  */
end_comment

begin_function
specifier|static
name|void
name|notify_merge_completed
parameter_list|(
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|ctx
operator|->
name|notify_func2
condition|)
block|{
name|svn_wc_notify_t
modifier|*
name|n
init|=
name|svn_wc_create_notify
argument_list|(
name|target_abspath
argument_list|,
name|svn_wc_notify_merge_completed
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|ctx
operator|->
name|notify_func2
argument_list|(
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|n
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Is the notification the result of a real operative merge? */
end_comment

begin_define
define|#
directive|define
name|IS_OPERATIVE_NOTIFICATION
parameter_list|(
name|notify
parameter_list|)
define|\
value|(notify->content_state == svn_wc_notify_state_conflicted \                      || notify->content_state == svn_wc_notify_state_merged  \                      || notify->content_state == svn_wc_notify_state_changed \                      || notify->prop_state == svn_wc_notify_state_conflicted \                      || notify->prop_state == svn_wc_notify_state_merged     \                      || notify->prop_state == svn_wc_notify_state_changed    \                      || notify->action == svn_wc_notify_update_add \                      || notify->action == svn_wc_notify_tree_conflict)
end_define

begin_comment
comment|/* Remove merge source gaps from range used for merge notifications.    See http://subversion.tigris.org/issues/show_bug.cgi?id=4138     If IMPLICIT_SRC_GAP is not NULL then it is a rangelist containing a    single range (see the implicit_src_gap member of merge_cmd_baton_t).    RANGE describes a (possibly reverse) merge.     If IMPLICIT_SRC_GAP is not NULL and it's sole range intersects with    the older revision in *RANGE, then remove IMPLICIT_SRC_GAP's range    from *RANGE. */
end_comment

begin_function
specifier|static
name|void
name|remove_source_gap
parameter_list|(
name|svn_merge_range_t
modifier|*
name|range
parameter_list|,
name|apr_array_header_t
modifier|*
name|implicit_src_gap
parameter_list|)
block|{
if|if
condition|(
name|implicit_src_gap
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|gap_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|implicit_src_gap
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|start
operator|<
name|range
operator|->
name|end
condition|)
block|{
if|if
condition|(
name|gap_range
operator|->
name|start
operator|==
name|range
operator|->
name|start
condition|)
name|range
operator|->
name|start
operator|=
name|gap_range
operator|->
name|end
expr_stmt|;
block|}
else|else
comment|/* Reverse merge */
block|{
if|if
condition|(
name|gap_range
operator|->
name|start
operator|==
name|range
operator|->
name|end
condition|)
name|range
operator|->
name|end
operator|=
name|gap_range
operator|->
name|end
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Notify that we're starting a merge  *  * This calls the client's notification receiver (as found in the client  * context), with a WC abspath.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|notify_merge_begin
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|svn_boolean_t
name|delete_action
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_wc_notify_t
modifier|*
name|notify
decl_stmt|;
name|svn_merge_range_t
name|n_range
init|=
block|{
name|SVN_INVALID_REVNUM
block|,
name|SVN_INVALID_REVNUM
block|,
name|TRUE
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|notify_abspath
decl_stmt|;
if|if
condition|(
operator|!
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If our merge sources are ancestors of one another... */
if|if
condition|(
name|merge_b
operator|->
name|merge_source
operator|.
name|ancestral
condition|)
block|{
specifier|const
name|svn_client__merge_path_t
modifier|*
name|child
decl_stmt|;
comment|/* Find NOTIFY->PATH's nearest ancestor in          NOTIFY->CHILDREN_WITH_MERGEINFO.  Normally we consider a child in          NOTIFY->CHILDREN_WITH_MERGEINFO representing PATH to be an          ancestor of PATH, but if this is a deletion of PATH then the          notification must be for a proper ancestor of PATH.  This ensures          we don't get notifications like:             --- Merging rX into 'PARENT/CHILD'            D    PARENT/CHILD           But rather:             --- Merging rX into 'PARENT'            D    PARENT/CHILD       */
name|child
operator|=
name|find_nearest_ancestor_with_intersecting_ranges
argument_list|(
operator|&
operator|(
name|n_range
operator|.
name|start
operator|)
argument_list|,
operator|&
operator|(
name|n_range
operator|.
name|end
operator|)
argument_list|,
name|merge_b
operator|->
name|notify_begin
operator|.
name|nodes_with_mergeinfo
argument_list|,
operator|!
name|delete_action
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|&&
name|delete_action
condition|)
block|{
comment|/* Triggered by file replace in single-file-merge */
name|child
operator|=
name|find_nearest_ancestor
argument_list|(
name|merge_b
operator|->
name|notify_begin
operator|.
name|nodes_with_mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|child
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Should always find the merge anchor */
if|if
condition|(
operator|!
name|child
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Don't notify the same merge again */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
operator|=
name|child
operator|->
name|abspath
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|absent
operator|||
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|==
literal|0
operator|||
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|n_range
operator|.
name|start
argument_list|)
condition|)
block|{
comment|/* No valid information for an header */
return|return
name|SVN_NO_ERROR
return|;
block|}
name|notify_abspath
operator|=
name|child
operator|->
name|abspath
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* already notified */
name|notify_abspath
operator|=
name|merge_b
operator|->
name|target
operator|->
name|abspath
expr_stmt|;
comment|/* Store something in last_abspath. Any value would do */
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
operator|=
name|merge_b
operator|->
name|target
operator|->
name|abspath
expr_stmt|;
block|}
name|notify
operator|=
name|svn_wc_create_notify
argument_list|(
name|notify_abspath
argument_list|,
name|merge_b
operator|->
name|same_repos
condition|?
name|svn_wc_notify_merge_begin
else|:
name|svn_wc_notify_foreign_merge_begin
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|n_range
operator|.
name|start
argument_list|)
condition|)
block|{
comment|/* If the merge source has a gap, then don't mention          those gap revisions in the notification. */
name|remove_source_gap
argument_list|(
operator|&
name|n_range
argument_list|,
name|merge_b
operator|->
name|implicit_src_gap
argument_list|)
expr_stmt|;
name|notify
operator|->
name|merge_range
operator|=
operator|&
name|n_range
expr_stmt|;
block|}
else|else
block|{
name|notify
operator|->
name|merge_range
operator|=
name|NULL
expr_stmt|;
block|}
call|(
modifier|*
name|merge_b
operator|->
name|ctx
operator|->
name|notify_func2
call|)
argument_list|(
name|merge_b
operator|->
name|ctx
operator|->
name|notify_baton2
argument_list|,
name|notify
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *OUT_RANGELIST to the intersection of IN_RANGELIST with the simple  * (inheritable) revision range REV1:REV2, according to CONSIDER_INHERITANCE.  * If REV1 is equal to REV2, the result is an empty rangelist, otherwise  * REV1 must be less than REV2.  *  * Note: If CONSIDER_INHERITANCE is FALSE, the effect is to treat any non-  * inheritable input ranges as if they were inheritable.  If it is TRUE, the  * effect is to discard any non-inheritable input ranges.  Therefore the  * ranges in *OUT_RANGELIST will always be inheritable. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rangelist_intersect_range
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|out_rangelist
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|in_rangelist
parameter_list|,
name|svn_revnum_t
name|rev1
parameter_list|,
name|svn_revnum_t
name|rev2
parameter_list|,
name|svn_boolean_t
name|consider_inheritance
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|rev1
operator|<=
name|rev2
argument_list|)
expr_stmt|;
if|if
condition|(
name|rev1
operator|<
name|rev2
condition|)
block|{
name|svn_rangelist_t
modifier|*
name|simple_rangelist
init|=
name|svn_rangelist__initialize
argument_list|(
name|rev1
argument_list|,
name|rev2
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
name|out_rangelist
argument_list|,
name|simple_rangelist
argument_list|,
name|in_rangelist
argument_list|,
name|consider_inheritance
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|out_rangelist
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for fix_deleted_subtree_ranges().  Like fix_deleted_subtree_ranges()    this function should only be called when honoring mergeinfo.     CHILD, PARENT, REVISION1, REVISION2, and RA_SESSION are all cascaded from    fix_deleted_subtree_ranges() -- see that function for more information on    each.     If PARENT is not the merge target then PARENT must have already have been    processed by this function as a child.  Specifically, this means that    PARENT->REMAINING_RANGES must already be populated -- it can be an empty    rangelist but cannot be NULL.     PRIMARY_URL is the merge source url of CHILD at the younger of REVISION1    and REVISION2.     Since this function is only invoked for subtrees of the merge target, the    guarantees afforded by normalize_merge_sources() don't apply - see the    'MERGEINFO MERGE SOURCE NORMALIZATION' comment at the top of this file.    Therefore it is possible that PRIMARY_URL@REVISION1 and    PRIMARY_URL@REVISION2 don't describe the endpoints of an unbroken line of    history.  The purpose of this helper is to identify these cases of broken    history and adjust CHILD->REMAINING_RANGES in such a way we don't later try    to describe nonexistent path/revisions to the merge report editor -- see    drive_merge_report_editor().     If PRIMARY_URL@REVISION1 and PRIMARY_URL@REVISION2 describe an unbroken    line of history then do nothing and leave CHILD->REMAINING_RANGES as-is.     If neither PRIMARY_URL@REVISION1 nor PRIMARY_URL@REVISION2 exist then    there is nothing to merge to CHILD->ABSPATH so set CHILD->REMAINING_RANGES    equal to PARENT->REMAINING_RANGES.  This will cause the subtree to    effectively ignore CHILD -- see 'Note: If the first svn_merge_range_t...'    in drive_merge_report_editor()'s doc string.     If PRIMARY_URL@REVISION1 *xor* PRIMARY_URL@REVISION2 exist then we take the    subset of REVISION1:REVISION2 in CHILD->REMAINING_RANGES at which    PRIMARY_URL doesn't exist and set that subset equal to    PARENT->REMAINING_RANGES' intersection with that non-existent range.  Why?    Because this causes CHILD->REMAINING_RANGES to be identical to    PARENT->REMAINING_RANGES for revisions between REVISION1 and REVISION2 at    which PRIMARY_URL doesn't exist.  As mentioned above this means that    drive_merge_report_editor() won't attempt to describe these non-existent    subtree path/ranges to the reporter (which would break the merge).     If the preceding paragraph wasn't terribly clear then what follows spells    out this function's behavior a bit more explicitly:     For forward merges (REVISION1< REVISION2)       If PRIMARY_URL@REVISION1 exists but PRIMARY_URL@REVISION2 doesn't, then      find the revision 'N' in which PRIMARY_URL@REVISION1 was deleted.  Leave      the subset of CHILD->REMAINING_RANGES that intersects with      REVISION1:(N - 1) as-is and set the subset of CHILD->REMAINING_RANGES      that intersects with (N - 1):REVISION2 equal to PARENT->REMAINING_RANGES'      intersection with (N - 1):REVISION2.       If PRIMARY_URL@REVISION1 doesn't exist but PRIMARY_URL@REVISION2 does,      then find the revision 'M' in which PRIMARY_URL@REVISION2 came into      existence.  Leave the subset of CHILD->REMAINING_RANGES that intersects with      (M - 1):REVISION2 as-is and set the subset of CHILD->REMAINING_RANGES      that intersects with REVISION1:(M - 1) equal to PARENT->REMAINING_RANGES'      intersection with REVISION1:(M - 1).     For reverse merges (REVISION1> REVISION2)       If PRIMARY_URL@REVISION1 exists but PRIMARY_URL@REVISION2 doesn't, then      find the revision 'N' in which PRIMARY_URL@REVISION1 came into existence.      Leave the subset of CHILD->REMAINING_RANGES that intersects with      REVISION2:(N - 1) as-is and set the subset of CHILD->REMAINING_RANGES      that intersects with (N - 1):REVISION1 equal to PARENT->REMAINING_RANGES'      intersection with (N - 1):REVISION1.       If PRIMARY_URL@REVISION1 doesn't exist but PRIMARY_URL@REVISION2 does,      then find the revision 'M' in which PRIMARY_URL@REVISION2 came into      existence.  Leave the subset of CHILD->REMAINING_RANGES that intersects with      REVISION2:(M - 1) as-is and set the subset of CHILD->REMAINING_RANGES      that intersects with (M - 1):REVISION1 equal to PARENT->REMAINING_RANGES'      intersection with REVISION1:(M - 1).     SCRATCH_POOL is used for all temporary allocations.  Changes to CHILD are    allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|adjust_deleted_subtree_ranges
parameter_list|(
name|svn_client__merge_path_t
modifier|*
name|child
parameter_list|,
name|svn_client__merge_path_t
modifier|*
name|parent
parameter_list|,
name|svn_revnum_t
name|revision1
parameter_list|,
name|svn_revnum_t
name|revision2
parameter_list|,
specifier|const
name|char
modifier|*
name|primary_url
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_rollback
init|=
name|revision2
operator|<
name|revision1
decl_stmt|;
name|svn_revnum_t
name|younger_rev
init|=
name|is_rollback
condition|?
name|revision1
else|:
name|revision2
decl_stmt|;
name|svn_revnum_t
name|peg_rev
init|=
name|younger_rev
decl_stmt|;
name|svn_revnum_t
name|older_rev
init|=
name|is_rollback
condition|?
name|revision2
else|:
name|revision1
decl_stmt|;
name|apr_array_header_t
modifier|*
name|segments
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client__repos_location_segments
argument_list|(
operator|&
name|segments
argument_list|,
name|ra_session
argument_list|,
name|primary_url
argument_list|,
name|peg_rev
argument_list|,
name|younger_rev
argument_list|,
name|older_rev
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If PRIMARY_URL@peg_rev doesn't exist then       svn_client__repos_location_segments() typically returns an       SVN_ERR_FS_NOT_FOUND error, but if it doesn't exist for a       forward merge over ra_neon then we get SVN_ERR_RA_DAV_REQUEST_FAILED.       http://subversion.tigris.org/issues/show_bug.cgi?id=3137 fixed some of       the cases where different RA layers returned different error codes to       signal the "path not found"...but it looks like there is more to do.        ### Do we still need to special case for ra_neon (since it no longer           exists)? */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_REQUEST_FAILED
condition|)
block|{
comment|/* PRIMARY_URL@peg_rev doesn't exist.  Check if PRIMARY_URL@older_rev              exists, if neither exist then the editor can simply ignore this              subtree. */
specifier|const
name|char
modifier|*
name|rel_source_path
decl_stmt|;
comment|/* PRIMARY_URL relative to RA_SESSION */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_path_relative_to_session
argument_list|(
name|ra_session
argument_list|,
operator|&
name|rel_source_path
argument_list|,
name|primary_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session
argument_list|,
name|rel_source_path
argument_list|,
name|older_rev
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
comment|/* Neither PRIMARY_URL@peg_rev nor PRIMARY_URL@older_rev exist,                  so there is nothing to merge.  Set CHILD->REMAINING_RANGES                  identical to PARENT's. */
name|child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_rangelist_t
modifier|*
name|deleted_rangelist
decl_stmt|;
name|svn_revnum_t
name|rev_primary_url_deleted
decl_stmt|;
comment|/* PRIMARY_URL@older_rev exists, so it was deleted at some                  revision prior to peg_rev, find that revision. */
name|SVN_ERR
argument_list|(
name|svn_ra_get_deleted_rev
argument_list|(
name|ra_session
argument_list|,
name|rel_source_path
argument_list|,
name|older_rev
argument_list|,
name|younger_rev
argument_list|,
operator|&
name|rev_primary_url_deleted
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PRIMARY_URL@older_rev exists and PRIMARY_URL@peg_rev doesn't,                  so svn_ra_get_deleted_rev() should always find the revision                  PRIMARY_URL@older_rev was deleted. */
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev_primary_url_deleted
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a reverse merge reorder CHILD->REMAINING_RANGES and                  PARENT->REMAINING_RANGES so both will work with the                  svn_rangelist_* APIs below. */
if|if
condition|(
name|is_rollback
condition|)
block|{
comment|/* svn_rangelist_reverse operates in place so it's safe                      to use our scratch_pool. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Find the intersection of CHILD->REMAINING_RANGES with the                  range over which PRIMARY_URL@older_rev exists (ending at                  the youngest revision at which it still exists). */
name|SVN_ERR
argument_list|(
name|rangelist_intersect_range
argument_list|(
operator|&
name|child
operator|->
name|remaining_ranges
argument_list|,
name|child
operator|->
name|remaining_ranges
argument_list|,
name|older_rev
argument_list|,
name|rev_primary_url_deleted
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge into CHILD->REMAINING_RANGES the intersection of                  PARENT->REMAINING_RANGES with the range beginning when                  PRIMARY_URL@older_rev was deleted until younger_rev. */
name|SVN_ERR
argument_list|(
name|rangelist_intersect_range
argument_list|(
operator|&
name|deleted_rangelist
argument_list|,
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|rev_primary_url_deleted
operator|-
literal|1
argument_list|,
name|peg_rev
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|deleted_rangelist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return CHILD->REMAINING_RANGES and PARENT->REMAINING_RANGES                  to reverse order if necessary. */
if|if
condition|(
name|is_rollback
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
else|else
comment|/* PRIMARY_URL@peg_rev exists. */
block|{
name|svn_rangelist_t
modifier|*
name|non_existent_rangelist
decl_stmt|;
name|svn_location_segment_t
modifier|*
name|segment
init|=
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
operator|(
name|segments
operator|->
name|nelts
operator|-
literal|1
operator|)
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
decl_stmt|;
comment|/* We know PRIMARY_URL@peg_rev exists as the call to          svn_client__repos_location_segments() succeeded.  If there is only          one segment that starts at oldest_rev then we know that          PRIMARY_URL@oldest_rev:PRIMARY_URL@peg_rev describes an unbroken          line of history, so there is nothing more to adjust in          CHILD->REMAINING_RANGES. */
if|if
condition|(
name|segment
operator|->
name|range_start
operator|==
name|older_rev
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If this is a reverse merge reorder CHILD->REMAINING_RANGES and          PARENT->REMAINING_RANGES so both will work with the          svn_rangelist_* APIs below. */
if|if
condition|(
name|is_rollback
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Intersect CHILD->REMAINING_RANGES with the range where PRIMARY_URL          exists.  Since segment doesn't span older_rev:peg_rev we know          PRIMARY_URL@peg_rev didn't come into existence until          segment->range_start + 1. */
name|SVN_ERR
argument_list|(
name|rangelist_intersect_range
argument_list|(
operator|&
name|child
operator|->
name|remaining_ranges
argument_list|,
name|child
operator|->
name|remaining_ranges
argument_list|,
name|segment
operator|->
name|range_start
argument_list|,
name|peg_rev
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge into CHILD->REMAINING_RANGES the intersection of          PARENT->REMAINING_RANGES with the range before PRIMARY_URL@peg_rev          came into existence. */
name|SVN_ERR
argument_list|(
name|rangelist_intersect_range
argument_list|(
operator|&
name|non_existent_rangelist
argument_list|,
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|older_rev
argument_list|,
name|segment
operator|->
name|range_start
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|non_existent_rangelist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return CHILD->REMAINING_RANGES and PARENT->REMAINING_RANGES          to reverse order if necessary. */
if|if
condition|(
name|is_rollback
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Make a lasting copy of CHILD->REMAINING_RANGES using POOL. */
name|child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     SOURCE is cascaded from the argument of the same name in    do_directory_merge().  TARGET is the merge target.  RA_SESSION is the    session for the younger of SOURCE->loc1 and SOURCE->loc2.     Adjust the subtrees in CHILDREN_WITH_MERGEINFO so that we don't    later try to describe invalid paths in drive_merge_report_editor().    This function is just a thin wrapper around    adjust_deleted_subtree_ranges(), which see for further details.     SCRATCH_POOL is used for all temporary allocations.  Changes to    CHILDREN_WITH_MERGEINFO are allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fix_deleted_subtree_ranges
parameter_list|(
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|is_rollback
init|=
name|source
operator|->
name|loc2
operator|->
name|rev
operator|<
name|source
operator|->
name|loc1
operator|->
name|rev
decl_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|ra_session
argument_list|,
operator|(
name|is_rollback
condition|?
name|source
operator|->
name|loc1
else|:
name|source
operator|->
name|loc2
operator|)
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* CHILDREN_WITH_MERGEINFO is sorted in depth-first order, so      start at index 1 to examine only subtrees. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|parent
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|deleted_rangelist
decl_stmt|,
modifier|*
name|added_rangelist
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|absent
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Find CHILD's parent. */
name|parent
operator|=
name|find_nearest_ancestor
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
expr_stmt|;
comment|/* Since CHILD is a subtree then its parent must be in          CHILDREN_WITH_MERGEINFO, see the global comment          'THE CHILDREN_WITH_MERGEINFO ARRAY'. */
name|SVN_ERR_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
comment|/* If this is a reverse merge reorder CHILD->REMAINING_RANGES          so it will work with the svn_rangelist_diff API. */
if|if
condition|(
name|is_rollback
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_rangelist_diff
argument_list|(
operator|&
name|deleted_rangelist
argument_list|,
operator|&
name|added_rangelist
argument_list|,
name|child
operator|->
name|remaining_ranges
argument_list|,
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rollback
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If CHILD is the merge target we then know that SOURCE is provided          by normalize_merge_sources() -- see 'MERGEINFO MERGE SOURCE          NORMALIZATION'.  Due to this normalization we know that SOURCE          describes an unbroken line of history such that the entire range          described by SOURCE can potentially be merged to CHILD.           But if CHILD is a subtree we don't have the same guarantees about          SOURCE as we do for the merge target.  SOURCE->loc1 and/or          SOURCE->loc2 might not exist.           If one or both doesn't exist, then adjust CHILD->REMAINING_RANGES          such that we don't later try to describe invalid subtrees in          drive_merge_report_editor(), as that will break the merge.          If CHILD has the same remaining ranges as PARENT however, then          there is no need to make these adjustments, since          drive_merge_report_editor() won't attempt to describe CHILD in this          case, see the 'Note' in drive_merge_report_editor's docstring. */
if|if
condition|(
name|deleted_rangelist
operator|->
name|nelts
operator|||
name|added_rangelist
operator|->
name|nelts
condition|)
block|{
specifier|const
name|char
modifier|*
name|child_primary_source_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_repos_src_path
init|=
name|svn_dirent_is_child
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
comment|/* This loop is only processing subtrees, so CHILD->ABSPATH              better be a proper child of the merge target. */
name|SVN_ERR_ASSERT
argument_list|(
name|child_repos_src_path
argument_list|)
expr_stmt|;
name|child_primary_source_url
operator|=
name|svn_path_url_add_component2
argument_list|(
operator|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|<
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|?
name|source
operator|->
name|loc2
operator|->
name|url
else|:
name|source
operator|->
name|loc1
operator|->
name|url
argument_list|,
name|child_repos_src_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|adjust_deleted_subtree_ranges
argument_list|(
name|child
argument_list|,
name|parent
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|child_primary_source_url
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Determining What Remains To Be Merged ***/
end_comment

begin_comment
comment|/* Get explicit and/or implicit mergeinfo for the working copy path    TARGET_ABSPATH.     If RECORDED_MERGEINFO is not NULL then set *RECORDED_MERGEINFO    to TARGET_ABSPATH's explicit or inherited mergeinfo as dictated by    INHERIT.     If IMPLICIT_MERGEINFO is not NULL then set *IMPLICIT_MERGEINFO    to TARGET_ABSPATH's implicit mergeinfo (a.k.a. natural history).     If both RECORDED_MERGEINFO and IMPLICIT_MERGEINFO are not NULL and    *RECORDED_MERGEINFO is inherited, then *IMPLICIT_MERGEINFO will be    removed from *RECORDED_MERGEINFO.     If INHERITED is not NULL set *INHERITED to TRUE if *RECORDED_MERGEINFO    is inherited rather than explicit.  If RECORDED_MERGEINFO is NULL then    INHERITED is ignored.      If IMPLICIT_MERGEINFO is not NULL then START and END are limits on    the natural history sought, must both be valid revision numbers, and    START must be greater than END.  If TARGET_ABSPATH's base revision    is older than START, then the base revision is used as the younger    bound in place of START.     RA_SESSION is an RA session open to the repository in which TARGET_ABSPATH    lives.  It may be temporarily reparented as needed by this function.     Allocate *RECORDED_MERGEINFO and *IMPLICIT_MERGEINFO in RESULT_POOL.    Use SCRATCH_POOL for any temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_full_mergeinfo
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|recorded_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
modifier|*
name|implicit_mergeinfo
parameter_list|,
name|svn_boolean_t
modifier|*
name|inherited
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* First, we get the real mergeinfo. */
if|if
condition|(
name|recorded_mergeinfo
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_or_repos_mergeinfo
argument_list|(
name|recorded_mergeinfo
argument_list|,
name|inherited
argument_list|,
name|NULL
comment|/* from_repos */
argument_list|,
name|FALSE
argument_list|,
name|inherit
argument_list|,
name|ra_session
argument_list|,
name|target_abspath
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|implicit_mergeinfo
condition|)
block|{
name|svn_client__pathrev_t
modifier|*
name|target
decl_stmt|;
comment|/* Assert that we have sane input. */
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|end
argument_list|)
operator|&&
operator|(
name|start
operator|>
name|end
operator|)
argument_list|)
expr_stmt|;
comment|/* Retrieve the origin (original_*) of the node, or just the          url if the node was not copied. */
name|SVN_ERR
argument_list|(
name|svn_client__wc_node_get_origin
argument_list|(
operator|&
name|target
argument_list|,
name|target_abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
condition|)
block|{
comment|/* We've been asked to operate on a locally added target, so its            * implicit mergeinfo is empty. */
operator|*
name|implicit_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|target
operator|->
name|rev
operator|<=
name|end
condition|)
block|{
comment|/* We're asking about a range outside our natural history              altogether.  That means our implicit mergeinfo is empty. */
operator|*
name|implicit_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fetch so-called "implicit mergeinfo" (that is, natural              history). */
comment|/* Do not ask for implicit mergeinfo from TARGET_ABSPATH's future.              TARGET_ABSPATH might not even exist, and even if it does the              working copy is *at* TARGET_REV so its implicit history ends              at TARGET_REV! */
if|if
condition|(
name|target
operator|->
name|rev
operator|<
name|start
condition|)
name|start
operator|=
name|target
operator|->
name|rev
expr_stmt|;
comment|/* Fetch the implicit mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
name|implicit_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|target
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*if (implicit_mergeinfo) */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for ensure_implicit_mergeinfo().     PARENT, CHILD, REVISION1, REVISION2 and CTX    are all cascaded from the arguments of the same names in    ensure_implicit_mergeinfo().  PARENT and CHILD must both exist, i.e.    this function should never be called where CHILD is the merge target.     If PARENT->IMPLICIT_MERGEINFO is NULL, obtain it from the server.     Set CHILD->IMPLICIT_MERGEINFO to the mergeinfo inherited from    PARENT->IMPLICIT_MERGEINFO.  CHILD->IMPLICIT_MERGEINFO is allocated    in RESULT_POOL.     RA_SESSION is an RA session open to the repository that contains CHILD.    It may be temporarily reparented by this function.    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|inherit_implicit_mergeinfo_from_parent
parameter_list|(
name|svn_client__merge_path_t
modifier|*
name|parent
parameter_list|,
name|svn_client__merge_path_t
modifier|*
name|child
parameter_list|,
name|svn_revnum_t
name|revision1
parameter_list|,
name|svn_revnum_t
name|revision2
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_diff
decl_stmt|;
comment|/* This only works on subtrees! */
name|SVN_ERR_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
argument_list|)
expr_stmt|;
comment|/* While PARENT must exist, it is possible we've deferred      getting its implicit mergeinfo.  If so get it now. */
if|if
condition|(
operator|!
name|parent
operator|->
name|implicit_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|get_full_mergeinfo
argument_list|(
name|NULL
argument_list|,
operator|&
operator|(
name|parent
operator|->
name|implicit_mergeinfo
operator|)
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|ra_session
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|MAX
argument_list|(
name|revision1
argument_list|,
name|revision2
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|revision1
argument_list|,
name|revision2
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Let CHILD inherit PARENT's implicit mergeinfo. */
name|path_diff
operator|=
name|svn_dirent_is_child
argument_list|(
name|parent
operator|->
name|abspath
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* PARENT->PATH better be an ancestor of CHILD->ABSPATH! */
name|SVN_ERR_ASSERT
argument_list|(
name|path_diff
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_suffix_to_mergeinfo
argument_list|(
operator|&
name|child
operator|->
name|implicit_mergeinfo
argument_list|,
name|parent
operator|->
name|implicit_mergeinfo
argument_list|,
name|path_diff
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|->
name|implicit_mergeinfo
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|child
operator|->
name|implicit_mergeinfo
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper of filter_merged_revisions().     If we have deferred obtaining CHILD->IMPLICIT_MERGEINFO, then get    it now, allocating it in RESULT_POOL.  If CHILD_INHERITS_PARENT is true    then set CHILD->IMPLICIT_MERGEINFO to the mergeinfo inherited from    PARENT->IMPLICIT_MERGEINFO, otherwise contact the repository.  Use    SCRATCH_POOL for all temporary allocations.     RA_SESSION is an RA session open to the repository that contains CHILD.    It may be temporarily reparented by this function.     PARENT, CHILD, REVISION1, REVISION2 and    CTX are all cascaded from the arguments of the same name in    filter_merged_revisions() and the same conditions for that function    hold here. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_implicit_mergeinfo
parameter_list|(
name|svn_client__merge_path_t
modifier|*
name|parent
parameter_list|,
name|svn_client__merge_path_t
modifier|*
name|child
parameter_list|,
name|svn_boolean_t
name|child_inherits_parent
parameter_list|,
name|svn_revnum_t
name|revision1
parameter_list|,
name|svn_revnum_t
name|revision2
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* If we haven't already found CHILD->IMPLICIT_MERGEINFO then      contact the server to get it. */
if|if
condition|(
name|child
operator|->
name|implicit_mergeinfo
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|child_inherits_parent
condition|)
name|SVN_ERR
argument_list|(
name|inherit_implicit_mergeinfo_from_parent
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|revision1
argument_list|,
name|revision2
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|get_full_mergeinfo
argument_list|(
name|NULL
argument_list|,
operator|&
operator|(
name|child
operator|->
name|implicit_mergeinfo
operator|)
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|ra_session
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|MAX
argument_list|(
name|revision1
argument_list|,
name|revision2
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|revision1
argument_list|,
name|revision2
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for calculate_remaining_ranges().     Initialize CHILD->REMAINING_RANGES to a rangelist representing the    requested merge of REVISION1:REVISION2 from MERGEINFO_PATH to    CHILD->ABSPATH.     For forward merges remove any ranges from CHILD->REMAINING_RANGES that    have already been merged to CHILD->ABSPATH per TARGET_MERGEINFO or    CHILD->IMPLICIT_MERGEINFO.  For reverse merges remove any ranges from    CHILD->REMAINING_RANGES that have not already been merged to CHILD->ABSPATH    per TARGET_MERGEINFO or CHILD->IMPLICIT_MERGEINFO.  If we have deferred    obtaining CHILD->IMPLICIT_MERGEINFO and it is necessary to use it for    these calculations, then get it from the server, allocating it in    RESULT_POOL.     CHILD represents a working copy path which is the merge target or one of    the target's subtrees.  If not NULL, PARENT is CHILD's nearest path-wise    ancestor - see 'THE CHILDREN_WITH_MERGEINFO ARRAY'.     If the function needs to consider CHILD->IMPLICIT_MERGEINFO and    CHILD_INHERITS_IMPLICIT is true, then set CHILD->IMPLICIT_MERGEINFO to the    mergeinfo inherited from PARENT->IMPLICIT_MERGEINFO.  Otherwise contact    the repository for CHILD->IMPLICIT_MERGEINFO.     NOTE: If PARENT is present then this function must have previously been    called for PARENT, i.e. if populate_remaining_ranges() is calling this    function for a set of svn_client__merge_path_t* the calls must be made    in depth-first order.     MERGEINFO_PATH is the merge source relative to the repository root.     REVISION1 and REVISION2 describe the merge range requested from    MERGEINFO_PATH.     TARGET_RANGELIST is the portion of CHILD->ABSPATH's explicit or inherited    mergeinfo that intersects with the merge history described by    MERGEINFO_PATH@REVISION1:MERGEINFO_PATH@REVISION2.  TARGET_RANGELIST    should be NULL if there is no explicit or inherited mergeinfo on    CHILD->ABSPATH or an empty list if CHILD->ABSPATH has empty mergeinfo or    explicit mergeinfo that exclusively describes non-intersecting history    with MERGEINFO_PATH@REVISION1:MERGEINFO_PATH@REVISION2.     SCRATCH_POOL is used for all temporary allocations.     NOTE: This should only be called when honoring mergeinfo.     NOTE: Like calculate_remaining_ranges() if PARENT is present then this    function must have previously been called for PARENT. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|filter_merged_revisions
parameter_list|(
name|svn_client__merge_path_t
modifier|*
name|parent
parameter_list|,
name|svn_client__merge_path_t
modifier|*
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|mergeinfo_path
parameter_list|,
name|svn_rangelist_t
modifier|*
name|target_rangelist
parameter_list|,
name|svn_revnum_t
name|revision1
parameter_list|,
name|svn_revnum_t
name|revision2
parameter_list|,
name|svn_boolean_t
name|child_inherits_implicit
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_rangelist_t
modifier|*
name|requested_rangelist
decl_stmt|,
modifier|*
name|target_implicit_rangelist
decl_stmt|,
modifier|*
name|explicit_rangelist
decl_stmt|;
comment|/* Convert REVISION1 and REVISION2 to a rangelist.       Note: Talking about a requested merge range's inheritability      doesn't make much sense, but as we are using svn_merge_range_t      to describe it we need to pick *something*.  Since all the      rangelist manipulations in this function either don't consider      inheritance by default or we are requesting that they don't (i.e.      svn_rangelist_remove and svn_rangelist_intersect) then we could      set the inheritability as FALSE, it won't matter either way. */
name|requested_rangelist
operator|=
name|svn_rangelist__initialize
argument_list|(
name|revision1
argument_list|,
name|revision2
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Now filter out revisions that have already been merged to CHILD. */
if|if
condition|(
name|revision1
operator|>
name|revision2
condition|)
comment|/* This is a reverse merge. */
block|{
name|svn_rangelist_t
modifier|*
name|added_rangelist
decl_stmt|,
modifier|*
name|deleted_rangelist
decl_stmt|;
comment|/* The revert range and will need to be reversed for          our svn_rangelist_* APIs to work properly. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|requested_rangelist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set EXPLICIT_RANGELIST to the list of source-range revs that are          already recorded as merged to target. */
if|if
condition|(
name|target_rangelist
condition|)
block|{
comment|/* Return the intersection of the revs which are both already              represented by CHILD's explicit or inherited mergeinfo.               We don't consider inheritance when determining intersecting              ranges.  If we *did* consider inheritance, then our calculation              would be wrong.  For example, if the CHILD->REMAINING_RANGES is              5:3 and TARGET_RANGELIST is r5* (non-inheritable) then the              intersection would be r4.  And that would be wrong as we clearly              want to reverse merge both r4 and r5 in this case.  Ignoring the              ranges' inheritance results in an intersection of r4-5.               You might be wondering about CHILD's children, doesn't the above              imply that we will reverse merge r4-5 from them?  Nope, this is              safe to do because any path whose parent has non-inheritable              ranges is always considered a subtree with differing mergeinfo              even if that path has no explicit mergeinfo prior to the              merge -- See condition 3 in the doc string for              merge.c:get_mergeinfo_paths(). */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|explicit_rangelist
argument_list|,
name|target_rangelist
argument_list|,
name|requested_rangelist
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|explicit_rangelist
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Was any part of the requested reverse merge not accounted for in          CHILD's explicit or inherited mergeinfo? */
name|SVN_ERR
argument_list|(
name|svn_rangelist_diff
argument_list|(
operator|&
name|deleted_rangelist
argument_list|,
operator|&
name|added_rangelist
argument_list|,
name|requested_rangelist
argument_list|,
name|explicit_rangelist
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|deleted_rangelist
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
comment|/* The whole of REVISION1:REVISION2 was represented in CHILD's              explicit/inherited mergeinfo, allocate CHILD's remaining              ranges in POOL and then we are done. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|requested_rangelist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|requested_rangelist
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* We need to check CHILD's implicit mergeinfo. */
block|{
name|svn_rangelist_t
modifier|*
name|implicit_rangelist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_implicit_mergeinfo
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|child_inherits_implicit
argument_list|,
name|revision1
argument_list|,
name|revision2
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|target_implicit_rangelist
operator|=
name|svn_hash_gets
argument_list|(
name|child
operator|->
name|implicit_mergeinfo
argument_list|,
name|mergeinfo_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_implicit_rangelist
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|implicit_rangelist
argument_list|,
name|target_implicit_rangelist
argument_list|,
name|requested_rangelist
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|implicit_rangelist
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|implicit_rangelist
argument_list|,
name|explicit_rangelist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|implicit_rangelist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|implicit_rangelist
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* This is a forward merge */
block|{
comment|/* Set EXPLICIT_RANGELIST to the list of source-range revs that are          NOT already recorded as merged to target. */
if|if
condition|(
name|target_rangelist
condition|)
block|{
comment|/* See earlier comment preceding svn_rangelist_intersect() for              why we don't consider inheritance here. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|explicit_rangelist
argument_list|,
name|target_rangelist
argument_list|,
name|requested_rangelist
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|explicit_rangelist
operator|=
name|svn_rangelist_dup
argument_list|(
name|requested_rangelist
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|explicit_rangelist
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
name|child
operator|->
name|remaining_ranges
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ### TODO:  Which evil shall we choose?    ###    ### If we allow all forward-merges not already found in recorded    ### mergeinfo, we destroy the ability to, say, merge the whole of a    ### branch to the trunk while automatically ignoring the revisions    ### common to both.  That's bad.    ###    ### If we allow only forward-merges not found in either recorded    ### mergeinfo or implicit mergeinfo (natural history), then the    ### previous scenario works great, but we can't reverse-merge a    ### previous change made to our line of history and then remake it    ### (because the reverse-merge will leave no mergeinfo trace, and    ### the remake-it attempt will still find the original change in    ### natural mergeinfo.  But you know, that we happen to use 'merge'    ### for revision undoing is somewhat unnatural anyway, so I'm    ### finding myself having little interest in caring too much about    ### this.  That said, if we had a way of storing reverse merge    ### ranges, we'd be in good shape either way. */
ifdef|#
directive|ifdef
name|SVN_MERGE__ALLOW_ALL_FORWARD_MERGES_FROM_SELF
block|{
comment|/* ### Don't consider implicit mergeinfo. */
name|child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|explicit_rangelist
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
block|{
comment|/* Based on CHILD's TARGET_MERGEINFO there are ranges to merge.              Check CHILD's implicit mergeinfo to see if these remaining              ranges are represented there. */
name|SVN_ERR
argument_list|(
name|ensure_implicit_mergeinfo
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|child_inherits_implicit
argument_list|,
name|revision1
argument_list|,
name|revision2
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|target_implicit_rangelist
operator|=
name|svn_hash_gets
argument_list|(
name|child
operator|->
name|implicit_mergeinfo
argument_list|,
name|mergeinfo_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_implicit_rangelist
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
operator|(
name|child
operator|->
name|remaining_ranges
operator|)
argument_list|,
name|target_implicit_rangelist
argument_list|,
name|explicit_rangelist
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|explicit_rangelist
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_file_merge and do_directory_merge (by way of    populate_remaining_ranges() for the latter).     Determine what portions of SOURCE have already    been merged to CHILD->ABSPATH and populate CHILD->REMAINING_RANGES with    the ranges that still need merging.     SOURCE and CTX are all cascaded from the caller's arguments of the same    names.  Note that this means SOURCE adheres to the requirements noted in    `MERGEINFO MERGE SOURCE NORMALIZATION'.     CHILD represents a working copy path which is the merge target or one of    the target's subtrees.  If not NULL, PARENT is CHILD's nearest path-wise    ancestor - see 'THE CHILDREN_WITH_MERGEINFO ARRAY'.  TARGET_MERGEINFO is    the working mergeinfo on CHILD.     RA_SESSION is the session for the younger of SOURCE->loc1 and    SOURCE->loc2.     If the function needs to consider CHILD->IMPLICIT_MERGEINFO and    CHILD_INHERITS_IMPLICIT is true, then set CHILD->IMPLICIT_MERGEINFO to the    mergeinfo inherited from PARENT->IMPLICIT_MERGEINFO.  Otherwise contact    the repository for CHILD->IMPLICIT_MERGEINFO.     If not null, IMPLICIT_SRC_GAP is the gap, if any, in the natural history    of SOURCE, see merge_cmd_baton_t.implicit_src_gap.     SCRATCH_POOL is used for all temporary allocations.  Changes to CHILD and    PARENT are made in RESULT_POOL.     NOTE: This should only be called when honoring mergeinfo.     NOTE: If PARENT is present then this function must have previously been    called for PARENT, i.e. if populate_remaining_ranges() is calling this    function for a set of svn_client__merge_path_t* the calls must be made    in depth-first order.     NOTE: When performing reverse merges, return    SVN_ERR_CLIENT_NOT_READY_TO_MERGE if both locations in SOURCE and    CHILD->ABSPATH are all on the same line of history but CHILD->ABSPATH's    base revision is older than the SOURCE->rev1:rev2 range, see comment re    issue #2973 below. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|calculate_remaining_ranges
parameter_list|(
name|svn_client__merge_path_t
modifier|*
name|parent
parameter_list|,
name|svn_client__merge_path_t
modifier|*
name|child
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
name|svn_mergeinfo_t
name|target_mergeinfo
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|implicit_src_gap
parameter_list|,
name|svn_boolean_t
name|child_inherits_implicit
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_client__pathrev_t
modifier|*
name|primary_src
init|=
operator|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|<
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|?
name|source
operator|->
name|loc2
else|:
name|source
operator|->
name|loc1
decl_stmt|;
specifier|const
name|char
modifier|*
name|mergeinfo_path
init|=
name|svn_client__pathrev_fspath
argument_list|(
name|primary_src
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Intersection of TARGET_MERGEINFO and the merge history      described by SOURCE. */
name|svn_rangelist_t
modifier|*
name|target_rangelist
decl_stmt|;
name|svn_revnum_t
name|child_base_revision
decl_stmt|;
comment|/* Since this function should only be called when honoring mergeinfo and    * SOURCE adheres to the requirements noted in 'MERGEINFO MERGE SOURCE    * NORMALIZATION', SOURCE must be 'ancestral'. */
name|SVN_ERR_ASSERT
argument_list|(
name|source
operator|->
name|ancestral
argument_list|)
expr_stmt|;
comment|/* Determine which of the requested ranges to consider merging... */
comment|/* Set TARGET_RANGELIST to the portion of TARGET_MERGEINFO that refers      to SOURCE (excluding any gap in SOURCE): first get all ranges from      TARGET_MERGEINFO that refer to the path of SOURCE, and then prune      any ranges that lie in the gap in SOURCE.       ### [JAF] In fact, that may still leave some ranges that lie entirely      outside the range of SOURCE; it seems we don't care about that.  */
if|if
condition|(
name|target_mergeinfo
condition|)
name|target_rangelist
operator|=
name|svn_hash_gets
argument_list|(
name|target_mergeinfo
argument_list|,
name|mergeinfo_path
argument_list|)
expr_stmt|;
else|else
name|target_rangelist
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|implicit_src_gap
operator|&&
name|target_rangelist
condition|)
block|{
comment|/* Remove any mergeinfo referring to the 'gap' in SOURCE, as that          mergeinfo doesn't really refer to SOURCE at all but instead          refers to locations that are non-existent or on a different          line of history.  (Issue #3242.) */
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|target_rangelist
argument_list|,
name|implicit_src_gap
argument_list|,
name|target_rangelist
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize CHILD->REMAINING_RANGES and filter out revisions already      merged (or, in the case of reverse merges, ranges not yet merged). */
name|SVN_ERR
argument_list|(
name|filter_merged_revisions
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|mergeinfo_path
argument_list|,
name|target_rangelist
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|child_inherits_implicit
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue #2973 -- from the continuing series of "Why, since the advent of      merge tracking, allowing merges into mixed rev and locally modified      working copies isn't simple and could be considered downright evil".       If reverse merging a range to the WC path represented by CHILD, from      that path's own history, where the path inherits no locally modified      mergeinfo from its WC parents (i.e. there is no uncommitted merge to      the WC), and the path's base revision is older than the range, then      the merge will always be a no-op.  This is because we only allow reverse      merges of ranges in the path's explicit or natural mergeinfo and a      reverse merge from the path's future history obviously isn't going to be      in either, hence the no-op.       The problem is two-fold.  First, in a mixed rev WC, the change we      want to revert might actually be to some child of the target path      which is at a younger base revision.  Sure, we can merge directly      to that child or update the WC or even use --ignore-ancestry and then      successfully run the reverse merge, but that gets to the second      problem: Those courses of action are not very obvious.  Before 1.5 if      a user committed a change that didn't touch the commit target, then      immediately decided to revert that change via a reverse merge it would      just DTRT.  But with the advent of merge tracking the user gets a no-op.       So in the name of user friendliness, return an error suggesting a helpful      course of action.   */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_base
argument_list|(
name|NULL
argument_list|,
operator|&
name|child_base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|TRUE
comment|/* ignore_enoent */
argument_list|,
name|FALSE
comment|/* show_hidden */
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If CHILD has no base revision then it hasn't been committed yet, so it      can't have any "future" history. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|child_base_revision
argument_list|)
operator|&&
operator|(
operator|(
name|child
operator|->
name|remaining_ranges
operator|)
operator|->
name|nelts
operator|==
literal|0
operator|)
comment|/* Inoperative merge */
operator|&&
operator|(
name|source
operator|->
name|loc2
operator|->
name|rev
operator|<
name|source
operator|->
name|loc1
operator|->
name|rev
operator|)
comment|/* Reverse merge */
operator|&&
operator|(
name|child_base_revision
operator|<=
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|)
comment|/* From CHILD's future */
block|{
comment|/* Hmmm, an inoperative reverse merge from the "future".  If it is          from our own future return a helpful error. */
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|start_loc
decl_stmt|;
name|err
operator|=
name|svn_client__repos_location
argument_list|(
operator|&
name|start_loc
argument_list|,
name|ra_session
argument_list|,
name|source
operator|->
name|loc1
argument_list|,
name|child_base_revision
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_url
argument_list|(
operator|&
name|url
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|start_loc
operator|->
name|url
argument_list|,
name|url
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot reverse-merge a range from a "
literal|"path's own future history; try "
literal|"updating first"
argument_list|)
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for populate_remaining_ranges().     SOURCE is cascaded from the arguments of the same name in    populate_remaining_ranges().     Note: The following comments assume a forward merge, i.e.    SOURCE->loc1->rev< SOURCE->loc2->rev.  If this is a reverse merge then    all the following comments still apply, but with SOURCE->loc1 switched    with SOURCE->loc2.     Like populate_remaining_ranges(), SOURCE must adhere to the restrictions    documented in 'MERGEINFO MERGE SOURCE NORMALIZATION'.  These restrictions    allow for a *single* gap in SOURCE, GAP_REV1:GAP_REV2 exclusive:inclusive    (where SOURCE->loc1->rev == GAP_REV1<= GAP_REV2< SOURCE->loc2->rev),    if SOURCE->loc2->url@(GAP_REV2+1) was copied from SOURCE->loc1.  If such    a gap exists, set *GAP_START and *GAP_END to the starting and ending    revisions of the gap.  Otherwise set both to SVN_INVALID_REVNUM.     For example, if the natural history of URL@2:URL@9 is 'trunk/:2,7-9' this    would indicate that trunk@7 was copied from trunk@2.  This function would    return GAP_START:GAP_END of 2:6 in this case.  Note that a path 'trunk'    might exist at r3-6, but it would not be on the same line of history as    trunk@9.     ### GAP_START is basically redundant, as (if there is a gap at all) it is    necessarily the older revision of SOURCE.     RA_SESSION is an open RA session to the repository in which SOURCE lives. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_gaps_in_merge_source_history
parameter_list|(
name|svn_revnum_t
modifier|*
name|gap_start
parameter_list|,
name|svn_revnum_t
modifier|*
name|gap_end
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|implicit_src_mergeinfo
decl_stmt|;
name|svn_revnum_t
name|old_rev
init|=
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
decl_stmt|;
specifier|const
name|svn_client__pathrev_t
modifier|*
name|primary_src
init|=
operator|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|<
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|?
name|source
operator|->
name|loc2
else|:
name|source
operator|->
name|loc1
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_src_fspath
init|=
name|svn_client__pathrev_fspath
argument_list|(
name|primary_src
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|source
operator|->
name|ancestral
argument_list|)
expr_stmt|;
comment|/* Start by assuming there is no gap. */
operator|*
name|gap_start
operator|=
operator|*
name|gap_end
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Easy out: There can't be a gap between adjacent revisions. */
if|if
condition|(
name|abs
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|-
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
operator|==
literal|1
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Get SOURCE as mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|implicit_src_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|primary_src
argument_list|,
name|primary_src
operator|->
name|rev
argument_list|,
name|old_rev
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rangelist
operator|=
name|svn_hash_gets
argument_list|(
name|implicit_src_mergeinfo
argument_list|,
name|merge_src_fspath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rangelist
condition|)
comment|/* ### Can we ever not find a rangelist? */
return|return
name|SVN_NO_ERROR
return|;
comment|/* A gap in natural history can result from either a copy or      a rename.  If from a copy then history as mergeinfo will look      something like this:         '/trunk:X,Y-Z'       If from a rename it will look like this:         '/trunk_old_name:X'        '/trunk_new_name:Y-Z'      In both cases the gap, if it exists, is M-N, where M = X + 1 and     N = Y - 1.      Note that per the rules of 'MERGEINFO MERGE SOURCE NORMALIZATION' we     should never have multiple gaps, e.g. if we see anything like the     following then something is quite wrong:          '/trunk_old_name:A,B-C'         '/trunk_new_name:D-E'   */
if|if
condition|(
name|rangelist
operator|->
name|nelts
operator|>
literal|1
condition|)
comment|/* Copy */
block|{
specifier|const
name|svn_merge_range_t
modifier|*
name|gap
decl_stmt|;
comment|/* As mentioned above, multiple gaps *shouldn't* be possible. */
name|SVN_ERR_ASSERT
argument_list|(
name|apr_hash_count
argument_list|(
name|implicit_src_mergeinfo
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|gap
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|rangelist
operator|->
name|nelts
operator|-
literal|1
argument_list|,
specifier|const
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
operator|*
name|gap_start
operator|=
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
expr_stmt|;
operator|*
name|gap_end
operator|=
name|gap
operator|->
name|start
expr_stmt|;
comment|/* ### Issue #4132:          ### This assertion triggers in merge_tests.py svnmucc_abuse_1()          ### when a node is replaced by an older copy of itself.           BH: I think we should review this and the 'rename' case to find              out which behavior we really want, and if we can really              determine what happened this way. */
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|gap_start
operator|<
operator|*
name|gap_end
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|apr_hash_count
argument_list|(
name|implicit_src_mergeinfo
argument_list|)
operator|>
literal|1
condition|)
comment|/* Rename */
block|{
name|svn_rangelist_t
modifier|*
name|requested_rangelist
init|=
name|svn_rangelist__initialize
argument_list|(
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|implicit_rangelist
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|gap_rangelist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist__merge_many
argument_list|(
name|implicit_rangelist
argument_list|,
name|implicit_src_mergeinfo
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|gap_rangelist
argument_list|,
name|implicit_rangelist
argument_list|,
name|requested_rangelist
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there is anything left it is the gap. */
if|if
condition|(
name|gap_rangelist
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|gap_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|gap_rangelist
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
operator|*
name|gap_start
operator|=
name|gap_range
operator|->
name|start
expr_stmt|;
operator|*
name|gap_end
operator|=
name|gap_range
operator|->
name|end
expr_stmt|;
block|}
block|}
name|SVN_ERR_ASSERT
argument_list|(
operator|*
name|gap_start
operator|==
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
operator|||
operator|(
operator|*
name|gap_start
operator|==
name|SVN_INVALID_REVNUM
operator|&&
operator|*
name|gap_end
operator|==
name|SVN_INVALID_REVNUM
operator|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     For each (svn_client__merge_path_t *) child in CHILDREN_WITH_MERGEINFO,    populate that child's 'remaining_ranges' list with (### ... what?),    and populate that child's 'implicit_mergeinfo' with its implicit    mergeinfo (natural history).  CHILDREN_WITH_MERGEINFO is expected    to be sorted in depth first order and each child must be processed in    that order.  The inheritability of all calculated ranges is TRUE.     If mergeinfo is being honored (based on MERGE_B -- see HONOR_MERGEINFO()    for how this is determined), this function will actually try to be    intelligent about populating remaining_ranges list.  Otherwise, it    will claim that each child has a single remaining range, from    SOURCE->rev1, to SOURCE->rev2.    ### We also take the short-cut if doing record-only.  Why?     SCRATCH_POOL is used for all temporary allocations.  Changes to    CHILDREN_WITH_MERGEINFO are made in RESULT_POOL.     Note that if SOURCE->rev1> SOURCE->rev2, then each child's remaining_ranges    member does not adhere to the API rules for rangelists described in    svn_mergeinfo.h -- See svn_client__merge_path_t.     See `MERGEINFO MERGE SOURCE NORMALIZATION' for more requirements    around SOURCE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|populate_remaining_ranges
parameter_list|(
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_revnum_t
name|gap_start
decl_stmt|,
name|gap_end
decl_stmt|;
comment|/* If we aren't honoring mergeinfo or this is a --record-only merge,      we'll make quick work of this by simply adding dummy SOURCE->rev1:rev2      ranges for all children. */
if|if
condition|(
operator|!
name|HONOR_MERGEINFO
argument_list|(
name|merge_b
argument_list|)
operator|||
name|merge_b
operator|->
name|record_only
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Issue #3646 'record-only merges create self-referential              mergeinfo'.  Get the merge target's implicit mergeinfo (natural              history).  We'll use it later to avoid setting self-referential              mergeinfo -- see filter_natural_history_from_mergeinfo(). */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
comment|/* First item is always the merge target. */
block|{
name|SVN_ERR
argument_list|(
name|get_full_mergeinfo
argument_list|(
name|NULL
argument_list|,
comment|/* child->pre_merge_mergeinfo */
operator|&
operator|(
name|child
operator|->
name|implicit_mergeinfo
operator|)
argument_list|,
name|NULL
argument_list|,
comment|/* child->inherited_mergeinfo */
name|svn_mergeinfo_inherited
argument_list|,
name|ra_session
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|MAX
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Issue #3443 - Subtrees of the merge target can inherit                  their parent's implicit mergeinfo in most cases. */
name|svn_client__merge_path_t
modifier|*
name|parent
init|=
name|find_nearest_ancestor
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|child_inherits_implicit
decl_stmt|;
comment|/* If CHILD is a subtree then its parent must be in                  CHILDREN_WITH_MERGEINFO, see the global comment                  'THE CHILDREN_WITH_MERGEINFO ARRAY'. */
name|SVN_ERR_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|child_inherits_implicit
operator|=
operator|(
name|parent
operator|&&
operator|!
name|child
operator|->
name|switched
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_implicit_mergeinfo
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
name|child_inherits_implicit
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|ra_session
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist__initialize
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If, in the merge source's history, there was a copy from an older      revision, then SOURCE->loc2->url won't exist at some range M:N, where      SOURCE->loc1->rev< M< N< SOURCE->loc2->rev. The rules of 'MERGEINFO      MERGE SOURCE NORMALIZATION' allow this, but we must ignore these gaps      when calculating what ranges remain to be merged from SOURCE. If we      don't and try to merge any part of SOURCE->loc2->url@M:N we would      break the editor since no part of that actually exists.  See      http://svn.haxx.se/dev/archive-2008-11/0618.shtml.       Find the gaps in the merge target's history, if any.  Eventually      we will adjust CHILD->REMAINING_RANGES such that we don't describe      non-existent paths to the editor. */
name|SVN_ERR
argument_list|(
name|find_gaps_in_merge_source_history
argument_list|(
operator|&
name|gap_start
argument_list|,
operator|&
name|gap_end
argument_list|,
name|source
argument_list|,
name|ra_session
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stash any gap in the merge command baton, we'll need it later when      recording mergeinfo describing this merge. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|gap_start
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|gap_end
argument_list|)
condition|)
name|merge_b
operator|->
name|implicit_src_gap
operator|=
name|svn_rangelist__initialize
argument_list|(
name|gap_start
argument_list|,
name|gap_end
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_repos_path
init|=
name|svn_dirent_skip_ancestor
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
decl_stmt|;
name|merge_source_t
name|child_source
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|parent
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|child_inherits_implicit
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If the path is absent don't do subtree merge either. */
name|SVN_ERR_ASSERT
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|absent
condition|)
continue|continue;
name|SVN_ERR_ASSERT
argument_list|(
name|child_repos_path
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|child_source
operator|.
name|loc1
operator|=
name|svn_client__pathrev_join_relpath
argument_list|(
name|source
operator|->
name|loc1
argument_list|,
name|child_repos_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|child_source
operator|.
name|loc2
operator|=
name|svn_client__pathrev_join_relpath
argument_list|(
name|source
operator|->
name|loc2
argument_list|,
name|child_repos_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* ### Is the child 'ancestral' over the same revision range?  It's        * not necessarily true that a child is 'ancestral' if the parent is,        * nor that it's not if the parent is not.  However, here we claim        * that it is.  Before we had this 'ancestral' field that we need to        * set explicitly, the claim was implicit.  Either way, the impact is        * that we might pass calculate_remaining_ranges() a source that is        * not in fact 'ancestral' (despite its 'ancestral' field being true),        * contrary to its doc-string. */
name|child_source
operator|.
name|ancestral
operator|=
name|source
operator|->
name|ancestral
expr_stmt|;
comment|/* Get the explicit/inherited mergeinfo for CHILD.  If CHILD is the          merge target then also get its implicit mergeinfo.  Otherwise defer          this until we know it is absolutely necessary, since it requires an          expensive round trip communication with the server. */
name|SVN_ERR
argument_list|(
name|get_full_mergeinfo
argument_list|(
name|child
operator|->
name|pre_merge_mergeinfo
condition|?
name|NULL
else|:
operator|&
operator|(
name|child
operator|->
name|pre_merge_mergeinfo
operator|)
argument_list|,
comment|/* Get implicit only for merge target. */
operator|(
name|i
operator|==
literal|0
operator|)
condition|?
operator|&
operator|(
name|child
operator|->
name|implicit_mergeinfo
operator|)
else|:
name|NULL
argument_list|,
operator|&
operator|(
name|child
operator|->
name|inherited_mergeinfo
operator|)
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|ra_session
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|MAX
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If CHILD isn't the merge target find its parent. */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|parent
operator|=
name|find_nearest_ancestor
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
expr_stmt|;
comment|/* If CHILD is a subtree then its parent must be in              CHILDREN_WITH_MERGEINFO, see the global comment              'THE CHILDREN_WITH_MERGEINFO ARRAY'. */
name|SVN_ERR_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
block|}
comment|/* Issue #3443 - Can CHILD inherit PARENT's implicit mergeinfo, saving          us from having to ask the repos?  The only time we can't do this is if          CHILD is the merge target and so there is no PARENT to inherit from          or if CHILD is the root of a switched subtree, in which case PARENT          exists but is not CHILD's repository parent. */
name|child_inherits_implicit
operator|=
operator|(
name|parent
operator|&&
operator|!
name|child
operator|->
name|switched
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|calculate_remaining_ranges
argument_list|(
name|parent
argument_list|,
name|child
argument_list|,
operator|&
name|child_source
argument_list|,
name|child
operator|->
name|pre_merge_mergeinfo
argument_list|,
name|merge_b
operator|->
name|implicit_src_gap
argument_list|,
name|child_inherits_implicit
argument_list|,
name|ra_session
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Deal with any gap in SOURCE's natural history.           If the gap is a proper subset of CHILD->REMAINING_RANGES then we can          safely ignore it since we won't describe this path/rev pair.           If the gap exactly matches or is a superset of a range in          CHILD->REMAINING_RANGES then we must remove that range so we don't          attempt to describe non-existent paths via the reporter, this will          break the editor and our merge.           If the gap adjoins or overlaps a range in CHILD->REMAINING_RANGES          then we must *add* the gap so we span the missing revisions. */
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|&&
name|merge_b
operator|->
name|implicit_src_gap
condition|)
block|{
name|int
name|j
decl_stmt|;
name|svn_boolean_t
name|proper_subset
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|overlaps_or_adjoins
init|=
name|FALSE
decl_stmt|;
comment|/* If this is a reverse merge reorder CHILD->REMAINING_RANGES               so it will work with the svn_rangelist_* APIs below. */
if|if
condition|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|j
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|range
operator|->
name|start
operator|<=
name|gap_start
operator|&&
name|gap_end
operator|<
name|range
operator|->
name|end
operator|)
operator|||
operator|(
name|range
operator|->
name|start
operator|<
name|gap_start
operator|&&
name|gap_end
operator|<=
name|range
operator|->
name|end
operator|)
condition|)
block|{
name|proper_subset
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|gap_start
operator|==
name|range
operator|->
name|start
operator|)
operator|&&
operator|(
name|range
operator|->
name|end
operator|==
name|gap_end
operator|)
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|gap_start
operator|<=
name|range
operator|->
name|end
operator|&&
name|range
operator|->
name|start
operator|<=
name|gap_end
condition|)
comment|/* intersect */
block|{
name|overlaps_or_adjoins
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|proper_subset
condition|)
block|{
comment|/* We need to make adjustments.  Remove from, or add the gap                  to, CHILD->REMAINING_RANGES as appropriate. */
if|if
condition|(
name|overlaps_or_adjoins
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|merge_b
operator|->
name|implicit_src_gap
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* equals == TRUE */
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
operator|(
name|child
operator|->
name|remaining_ranges
operator|)
argument_list|,
name|merge_b
operator|->
name|implicit_src_gap
argument_list|,
name|child
operator|->
name|remaining_ranges
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
condition|)
comment|/* Reverse merge */
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Other Helper Functions ***/
end_comment

begin_comment
comment|/* Calculate the new mergeinfo for the target tree rooted at TARGET_ABSPATH    based on MERGES (a mapping of absolute WC paths to rangelists representing    a merge from the source SOURCE_FSPATH).     If RESULT_CATALOG is NULL, then record the new mergeinfo in the WC (at,    and possibly below, TARGET_ABSPATH).     If RESULT_CATALOG is not NULL, then don't record the new mergeinfo on the    WC, but instead record it in RESULT_CATALOG, where the keys are absolute    working copy paths and the values are the new mergeinfos for each.    Allocate additions to RESULT_CATALOG in pool which RESULT_CATALOG was    created in. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_wc_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|source_fspath
parameter_list|,
name|apr_hash_t
modifier|*
name|merges
parameter_list|,
name|svn_boolean_t
name|is_rollback
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Combine the mergeinfo for the revision range just merged into      the WC with its on-disk mergeinfo. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|merges
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|ranges
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|local_abspath_rel_to_target
decl_stmt|;
specifier|const
name|char
modifier|*
name|fspath
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* As some of the merges may've changed the WC's mergeinfo, get          a fresh copy before using it to update the WC's mergeinfo. */
name|err
operator|=
name|svn_client__parse_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If a directory PATH was skipped because it is missing or was          obstructed by an unversioned item then there's nothing we can          do with that, so skip it. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_NOT_LOCKED
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_WC_PATH_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* If we are attempting to set empty revision range override mergeinfo          on a path with no explicit mergeinfo, we first need the          mergeinfo that path inherits. */
if|if
condition|(
name|mergeinfo
operator|==
name|NULL
operator|&&
name|ranges
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_nearest_ancestor
argument_list|,
name|local_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mergeinfo
operator|==
name|NULL
condition|)
name|mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|local_abspath_rel_to_target
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|target_abspath
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|local_abspath_rel_to_target
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|fspath
operator|=
name|svn_fspath__join
argument_list|(
name|source_fspath
argument_list|,
name|local_abspath_rel_to_target
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|rangelist
operator|=
name|svn_hash_gets
argument_list|(
name|mergeinfo
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|rangelist
operator|==
name|NULL
condition|)
name|rangelist
operator|=
name|apr_array_make
argument_list|(
name|iterpool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rollback
condition|)
block|{
name|ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|ranges
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|ranges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|rangelist
argument_list|,
name|ranges
argument_list|,
name|rangelist
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|rangelist
argument_list|,
name|ranges
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update the mergeinfo by adjusting the path's rangelist. */
name|svn_hash_sets
argument_list|(
name|mergeinfo
argument_list|,
name|fspath
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rollback
operator|&&
name|apr_hash_count
argument_list|(
name|mergeinfo
argument_list|)
operator|==
literal|0
condition|)
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
name|svn_mergeinfo__remove_empty_rangelists
argument_list|(
name|mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|result_catalog
condition|)
block|{
name|svn_mergeinfo_t
name|existing_mergeinfo
init|=
name|svn_hash_gets
argument_list|(
name|result_catalog
argument_list|,
name|local_abspath
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_catalog_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|result_catalog
argument_list|)
decl_stmt|;
if|if
condition|(
name|existing_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|mergeinfo
argument_list|,
name|existing_mergeinfo
argument_list|,
name|result_catalog_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|result_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_catalog_pool
argument_list|,
name|local_abspath
argument_list|)
argument_list|,
name|svn_mergeinfo_dup
argument_list|(
name|mergeinfo
argument_list|,
name|result_catalog_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|svn_client__record_wc_mergeinfo
argument_list|(
name|local_abspath
argument_list|,
name|mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_ENTRY_NOT_FOUND
condition|)
block|{
comment|/* PATH isn't just missing, it's not even versioned as far                  as this working copy knows.  But it was included in                  MERGES, which means that the server knows about it.                  Likely we don't have access to the source due to authz                  restrictions.  For now just clear the error and                  continue...                   ### TODO:  Set non-inheritable mergeinfo on PATH's immediate                  ### parent and normal mergeinfo on PATH's siblings which we                  ### do have access to. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for record_mergeinfo_for_dir_merge().     Record override mergeinfo on any paths skipped during a merge.     Set empty mergeinfo on each path in MERGE_B->SKIPPED_ABSPATHS so the path    does not incorrectly inherit mergeinfo that will later be describing    the merge.     MERGEINFO_PATH and MERGE_B are cascaded from    arguments of the same name in the caller.     IS_ROLLBACK is true if the caller is recording a reverse merge and false    otherwise.  RANGELIST is the set of revisions being merged from    MERGEINFO_PATH to MERGE_B->target. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_skips_in_mergeinfo
parameter_list|(
specifier|const
name|char
modifier|*
name|mergeinfo_path
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|svn_boolean_t
name|is_rollback
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|merges
decl_stmt|;
name|apr_size_t
name|nbr_skips
init|=
name|apr_hash_count
argument_list|(
name|merge_b
operator|->
name|skipped_abspaths
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|nbr_skips
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|merges
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Override the mergeinfo for child paths which weren't actually merged. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|merge_b
operator|->
name|skipped_abspaths
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|skipped_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_wc_notify_state_t
name|obstruction_state
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Before we override, make sure this is a versioned path, it might          be an external or missing from disk due to authz restrictions. */
name|SVN_ERR
argument_list|(
name|perform_obstruction_check
argument_list|(
operator|&
name|obstruction_state
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|merge_b
argument_list|,
name|skipped_abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|obstruction_state
operator|==
name|svn_wc_notify_state_obstructed
operator|||
name|obstruction_state
operator|==
name|svn_wc_notify_state_missing
condition|)
continue|continue;
comment|/* Add an empty range list for this path.           ### TODO: This works fine for a file path skipped because it is          ### missing as long as the file's parent directory is present.          ### But missing directory paths skipped are not handled yet,          ### see issue #2915.           ### TODO: An empty range is fine if the skipped path doesn't          ### inherit any mergeinfo from a parent, but if it does          ### we need to account for that.  See issue #3440          ### http://subversion.tigris.org/issues/show_bug.cgi?id=3440. */
name|svn_hash_sets
argument_list|(
name|merges
argument_list|,
name|skipped_abspath
argument_list|,
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if (nbr_skips< notify_b->nbr_notifications)            ### Use RANGELIST as the mergeinfo for all children of            ### this path which were not also explicitly            ### skipped? */
block|}
name|SVN_ERR
argument_list|(
name|update_wc_mergeinfo
argument_list|(
name|NULL
argument_list|,
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|mergeinfo_path
argument_list|,
name|merges
argument_list|,
name|is_rollback
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Data for reporting when a merge aborted because of raising conflicts.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|single_range_conflict_report_t
block|{
comment|/* What sub-range of the requested source raised conflicts?    * The 'inheritable' flag is ignored. */
name|merge_source_t
modifier|*
name|conflicted_range
decl_stmt|;
comment|/* What sub-range of the requested source remains to be merged?    * NULL if no more.  The 'inheritable' flag is ignored. */
name|merge_source_t
modifier|*
name|remaining_source
decl_stmt|;
block|}
name|single_range_conflict_report_t
typedef|;
end_typedef

begin_comment
comment|/* Create a single_range_conflict_report_t, containing deep copies of  * CONFLICTED_RANGE and REMAINING_SOURCE, allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|single_range_conflict_report_t
modifier|*
name|single_range_conflict_report_create
parameter_list|(
specifier|const
name|merge_source_t
modifier|*
name|conflicted_range
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|remaining_source
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|single_range_conflict_report_t
modifier|*
name|report
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|report
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|conflicted_range
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|report
operator|->
name|conflicted_range
operator|=
name|merge_source_dup
argument_list|(
name|conflicted_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|report
operator|->
name|remaining_source
operator|=
name|remaining_source
condition|?
name|merge_source_dup
argument_list|(
name|remaining_source
argument_list|,
name|result_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
return|return
name|report
return|;
block|}
end_function

begin_comment
comment|/* Data for reporting when a merge aborted because of raising conflicts.  *  * ### TODO: More info, including the ranges (or other parameters) the user  *     needs to complete the merge.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|conflict_report_t
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|;
comment|/* The revision range during which conflicts were raised */
specifier|const
name|merge_source_t
modifier|*
name|conflicted_range
decl_stmt|;
comment|/* Was the conflicted range the last range in the whole requested merge? */
name|svn_boolean_t
name|was_last_range
decl_stmt|;
block|}
name|conflict_report_t
typedef|;
end_typedef

begin_comment
comment|/* Return a new conflict_report_t containing deep copies of the parameters,  * allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|conflict_report_t
modifier|*
name|conflict_report_create
parameter_list|(
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|conflicted_range
parameter_list|,
name|svn_boolean_t
name|was_last_range
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|conflict_report_t
modifier|*
name|report
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|report
argument_list|)
argument_list|)
decl_stmt|;
name|report
operator|->
name|target_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|target_abspath
argument_list|)
expr_stmt|;
name|report
operator|->
name|conflicted_range
operator|=
name|merge_source_dup
argument_list|(
name|conflicted_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|report
operator|->
name|was_last_range
operator|=
name|was_last_range
expr_stmt|;
return|return
name|report
return|;
block|}
end_function

begin_comment
comment|/* Return a deep copy of REPORT, allocated in RESULT_POOL. */
end_comment

begin_function
specifier|static
name|conflict_report_t
modifier|*
name|conflict_report_dup
parameter_list|(
specifier|const
name|conflict_report_t
modifier|*
name|report
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|conflict_report_t
modifier|*
name|new
init|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|report
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
decl_stmt|;
name|new
operator|->
name|target_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|report
operator|->
name|target_abspath
argument_list|)
expr_stmt|;
name|new
operator|->
name|conflicted_range
operator|=
name|merge_source_dup
argument_list|(
name|report
operator|->
name|conflicted_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* Create and return an error structure appropriate for the unmerged    revisions range(s). */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_error_t
modifier|*
name|make_merge_conflict_error
parameter_list|(
name|conflict_report_t
modifier|*
name|report
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|assert
argument_list|(
operator|!
name|report
operator|||
name|svn_dirent_is_absolute
argument_list|(
name|report
operator|->
name|target_abspath
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|report
operator|&&
operator|!
name|report
operator|->
name|was_last_range
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_FOUND_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"One or more conflicts were produced while merging r%ld:%ld into\n"
literal|"'%s' --\n"
literal|"resolve all conflicts and rerun the merge to apply the remaining\n"
literal|"unmerged revisions"
argument_list|)
argument_list|,
name|report
operator|->
name|conflicted_range
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|report
operator|->
name|conflicted_range
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|report
operator|->
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|report
operator|->
name|conflicted_range
operator|->
name|loc1
operator|->
name|rev
operator|!=
name|report
operator|->
name|conflicted_range
operator|->
name|loc2
operator|->
name|rev
argument_list|)
expr_stmt|;
comment|/* ### is a valid case in a 2-URL merge */
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     TARGET_WCPATH is a directory and CHILDREN_WITH_MERGEINFO is filled    with paths (svn_client__merge_path_t *) arranged in depth first order,    which have mergeinfo set on them or meet one of the other criteria    defined in get_mergeinfo_paths().  Remove any paths absent from disk    or scheduled for deletion from CHILDREN_WITH_MERGEINFO which are equal to    or are descendants of TARGET_WCPATH by setting those children to NULL. */
end_comment

begin_function
specifier|static
name|void
name|remove_absent_children
parameter_list|(
specifier|const
name|char
modifier|*
name|target_wcpath
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|)
block|{
comment|/* Before we try to override mergeinfo for skipped paths, make sure      the path isn't absent due to authz restrictions, because there's      nothing we can do about those. */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|child
operator|->
name|absent
operator|||
name|child
operator|->
name|scheduled_for_deletion
operator|)
operator|&&
name|svn_dirent_is_ancestor
argument_list|(
name|target_wcpath
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
condition|)
block|{
name|svn_sort__array_delete
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
operator|--
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge() to handle the case where a merge editor    drive removes explicit mergeinfo from a subtree of the merge target.     MERGE_B is cascaded from the argument of the same name in    do_directory_merge().  For each path (if any) in    MERGE_B->PATHS_WITH_DELETED_MERGEINFO remove that path from    CHILDREN_WITH_MERGEINFO.     The one exception is for the merge target itself,    MERGE_B->target->abspath, this must always be present in    CHILDREN_WITH_MERGEINFO so this is never removed by this    function. */
end_comment

begin_function
specifier|static
name|void
name|remove_children_with_deleted_mergeinfo
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|merge_b
operator|->
name|paths_with_deleted_mergeinfo
condition|)
return|return;
comment|/* CHILDREN_WITH_MERGEINFO[0] is the always the merge target      so start at the first child. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|merge_b
operator|->
name|paths_with_deleted_mergeinfo
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
condition|)
block|{
name|svn_sort__array_delete
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
operator|--
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     Set up the diff editor report to merge the SOURCE diff    into TARGET_ABSPATH and drive it.     If mergeinfo is not being honored (based on MERGE_B -- see the doc    string for HONOR_MERGEINFO() for how this is determined), then ignore    CHILDREN_WITH_MERGEINFO and merge the SOURCE diff to TARGET_ABSPATH.     If mergeinfo is being honored then perform a history-aware merge,    describing TARGET_ABSPATH and its subtrees to the reporter in such as way    as to avoid repeating merges already performed per the mergeinfo and    natural history of TARGET_ABSPATH and its subtrees.     The ranges that still need to be merged to the TARGET_ABSPATH and its    subtrees are described in CHILDREN_WITH_MERGEINFO, an array of    svn_client__merge_path_t * -- see 'THE CHILDREN_WITH_MERGEINFO ARRAY'    comment at the top of this file for more info.  Note that it is possible    TARGET_ABSPATH and/or some of its subtrees need only a subset, or no part,    of SOURCE to be merged.  Though there is little point to    calling this function if TARGET_ABSPATH and all its subtrees have already    had SOURCE merged, this will work but is a no-op.     SOURCE->rev1 and SOURCE->rev2 must be bound by the set of remaining_ranges    fields in CHILDREN_WITH_MERGEINFO's elements, specifically:     For forward merges (SOURCE->rev1< SOURCE->rev2):       1) The first svn_merge_range_t * element of each child's remaining_ranges         array must meet one of the following conditions:          a) The range's start field is greater than or equal to SOURCE->rev2.          b) The range's end field is SOURCE->rev2.       2) Among all the ranges that meet condition 'b' the oldest start         revision must equal SOURCE->rev1.     For reverse merges (SOURCE->rev1> SOURCE->rev2):       1) The first svn_merge_range_t * element of each child's remaining_ranges         array must meet one of the following conditions:          a) The range's start field is less than or equal to SOURCE->rev2.          b) The range's end field is SOURCE->rev2.       2) Among all the ranges that meet condition 'b' the youngest start         revision must equal SOURCE->rev1.     Note: If the first svn_merge_range_t * element of some subtree child's    remaining_ranges array is the same as the first range of that child's    nearest path-wise ancestor, then the subtree child *will not* be described    to the reporter.     DEPTH, NOTIFY_B, and MERGE_B are cascaded from do_directory_merge(), see    that function for more info.     MERGE_B->ra_session1 and MERGE_B->ra_session2 are RA sessions open to any    URL in the repository of SOURCE; they may be temporarily reparented within    this function.     If SOURCE->ancestral is set, then SOURCE->loc1 must be a    historical ancestor of SOURCE->loc2, or vice-versa (see    `MERGEINFO MERGE SOURCE NORMALIZATION' for more requirements around    SOURCE in this case). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|drive_merge_report_editor
parameter_list|(
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_ra_reporter3_t
modifier|*
name|reporter
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|diff_editor
decl_stmt|;
name|void
modifier|*
name|diff_edit_baton
decl_stmt|;
name|void
modifier|*
name|report_baton
decl_stmt|;
name|svn_revnum_t
name|target_start
decl_stmt|;
name|svn_boolean_t
name|honor_mergeinfo
init|=
name|HONOR_MERGEINFO
argument_list|(
name|merge_b
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_sess1_url
decl_stmt|,
modifier|*
name|old_sess2_url
decl_stmt|;
name|svn_boolean_t
name|is_rollback
init|=
name|source
operator|->
name|loc1
operator|->
name|rev
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
decl_stmt|;
comment|/* Start with a safe default starting revision for the editor and the      merge target. */
name|target_start
operator|=
name|source
operator|->
name|loc1
operator|->
name|rev
expr_stmt|;
comment|/* If we are honoring mergeinfo the starting revision for the merge target      might not be SOURCE->rev1, in fact the merge target might not need *any*      part of SOURCE merged -- Instead some subtree of the target      needs SOURCE -- So get the right starting revision for the      target. */
if|if
condition|(
name|honor_mergeinfo
condition|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
decl_stmt|;
comment|/* CHILDREN_WITH_MERGEINFO must always exist if we are honoring          mergeinfo and must have at least one element (describing the          merge target). */
name|SVN_ERR_ASSERT
argument_list|(
name|children_with_mergeinfo
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|children_with_mergeinfo
operator|->
name|nelts
argument_list|)
expr_stmt|;
comment|/* Get the merge target's svn_client__merge_path_t, which is always          the first in the array due to depth first sorting requirement,          see 'THE CHILDREN_WITH_MERGEINFO ARRAY'. */
name|child
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
literal|0
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|==
literal|0
condition|)
block|{
comment|/* The merge target doesn't need anything merged. */
name|target_start
operator|=
name|source
operator|->
name|loc2
operator|->
name|rev
expr_stmt|;
block|}
else|else
block|{
comment|/* The merge target has remaining revisions to merge.  These              ranges may fully or partially overlap the range described              by SOURCE->rev1:rev2 or may not intersect that range at              all. */
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|is_rollback
operator|&&
name|range
operator|->
name|start
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
operator|||
operator|(
name|is_rollback
operator|&&
name|range
operator|->
name|start
operator|<
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|)
block|{
comment|/* Merge target's first remaining range doesn't intersect. */
name|target_start
operator|=
name|source
operator|->
name|loc2
operator|->
name|rev
expr_stmt|;
block|}
else|else
block|{
comment|/* Merge target's first remaining range partially or                  fully overlaps. */
name|target_start
operator|=
name|range
operator|->
name|start
expr_stmt|;
block|}
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_sess1_url
argument_list|,
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Temporarily point our second RA session to SOURCE->loc1->url, too.  We use      this to request individual file contents. */
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_sess2_url
argument_list|,
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the diff editor and a reporter with which to, ultimately,      drive it. */
name|SVN_ERR
argument_list|(
name|svn_client__get_diff_editor2
argument_list|(
operator|&
name|diff_editor
argument_list|,
operator|&
name|diff_edit_baton
argument_list|,
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|depth
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|TRUE
comment|/* text_deltas */
argument_list|,
name|processor
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_func
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_do_diff3
argument_list|(
name|merge_b
operator|->
name|ra_session1
argument_list|,
operator|&
name|reporter
argument_list|,
operator|&
name|report_baton
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
literal|""
argument_list|,
name|depth
argument_list|,
name|merge_b
operator|->
name|diff_ignore_ancestry
argument_list|,
name|TRUE
argument_list|,
comment|/* text_deltas */
name|source
operator|->
name|loc2
operator|->
name|url
argument_list|,
name|diff_editor
argument_list|,
name|diff_edit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Drive the reporter. */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
literal|""
argument_list|,
name|target_start
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|honor_mergeinfo
operator|&&
name|children_with_mergeinfo
condition|)
block|{
comment|/* Describe children with mergeinfo overlapping this merge          operation such that no repeated diff is retrieved for them from          the repository. */
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Start with CHILDREN_WITH_MERGEINFO[1], CHILDREN_WITH_MERGEINFO[0]          is always the merge target (TARGET_ABSPATH). */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_repos_path
decl_stmt|;
specifier|const
name|svn_client__merge_path_t
modifier|*
name|parent
decl_stmt|;
specifier|const
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|absent
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Find this child's nearest wc ancestor with mergeinfo. */
name|parent
operator|=
name|find_nearest_ancestor
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
expr_stmt|;
comment|/* If a subtree needs the same range applied as its nearest parent              with mergeinfo or neither the subtree nor this parent need              SOURCE->rev1:rev2 merged, then we don't need to describe the              subtree separately.  In the latter case this could break the              editor if child->abspath didn't exist at SOURCE->rev2 and we              attempt to describe it via a reporter set_path call. */
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
condition|)
block|{
name|range
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|is_rollback
operator|&&
name|range
operator|->
name|start
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
operator|||
operator|(
name|is_rollback
operator|&&
name|range
operator|->
name|start
operator|<
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|)
block|{
comment|/* This child's first remaining range comes after the range                      we are currently merging, so skip it. We expect to get                      to it in a subsequent call to this function. */
continue|continue;
block|}
elseif|else
if|if
condition|(
name|parent
operator|->
name|remaining_ranges
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|parent_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|child_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|parent_range
operator|->
name|start
operator|==
name|child_range
operator|->
name|start
condition|)
continue|continue;
comment|/* Subtree needs same range as parent. */
block|}
block|}
else|else
comment|/* child->remaining_ranges->nelts == 0*/
block|{
comment|/* If both the subtree and its parent need no ranges applied                  consider that as the "same ranges" and don't describe                  the subtree. */
if|if
condition|(
name|parent
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|==
literal|0
condition|)
continue|continue;
block|}
comment|/* Ok, we really need to describe this subtree as it needs different              ranges applied than its nearest working copy parent. */
name|child_repos_path
operator|=
name|svn_dirent_is_child
argument_list|(
name|target_abspath
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* This loop is only processing subtrees, so CHILD->ABSPATH              better be a proper child of the merge target. */
name|SVN_ERR_ASSERT
argument_list|(
name|child_repos_path
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|==
literal|0
operator|)
operator|||
operator|(
name|is_rollback
operator|&&
operator|(
name|range
operator|->
name|start
operator|<
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
operator|)
operator|||
operator|(
operator|!
name|is_rollback
operator|&&
operator|(
name|range
operator|->
name|start
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
operator|)
condition|)
block|{
comment|/* Nothing to merge to this child.  We'll claim we have                  it up to date so the server doesn't send us                  anything. */
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
name|child_repos_path
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|set_path
argument_list|(
name|report_baton
argument_list|,
name|child_repos_path
argument_list|,
name|range
operator|->
name|start
argument_list|,
name|depth
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|reporter
operator|->
name|finish_report
argument_list|(
name|report_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Point the merge baton's RA sessions back where they were. */
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|old_sess1_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|old_sess2_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Iterate over each svn_client__merge_path_t * element in    CHILDREN_WITH_MERGEINFO and, if START_REV is true, find the most inclusive    start revision among those element's first remaining_ranges element.  If    START_REV is false, then look for the most inclusive end revision.     If IS_ROLLBACK is true the youngest start or end (as per START_REV)    revision is considered the "most inclusive" otherwise the oldest revision    is.     If none of CHILDREN_WITH_MERGEINFO's elements have any remaining ranges    return SVN_INVALID_REVNUM. */
end_comment

begin_function
specifier|static
name|svn_revnum_t
name|get_most_inclusive_rev
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|svn_boolean_t
name|is_rollback
parameter_list|,
name|svn_boolean_t
name|start_rev
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_revnum_t
name|most_inclusive_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|child
operator|)
operator|||
name|child
operator|->
name|absent
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Are we looking for the most inclusive start or end rev? */
name|svn_revnum_t
name|rev
init|=
name|start_rev
condition|?
name|range
operator|->
name|start
else|:
name|range
operator|->
name|end
decl_stmt|;
if|if
condition|(
operator|(
name|most_inclusive_rev
operator|==
name|SVN_INVALID_REVNUM
operator|)
operator|||
operator|(
name|is_rollback
operator|&&
operator|(
name|rev
operator|>
name|most_inclusive_rev
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|is_rollback
operator|)
operator|&&
operator|(
name|rev
operator|<
name|most_inclusive_rev
operator|)
operator|)
condition|)
name|most_inclusive_rev
operator|=
name|rev
expr_stmt|;
block|}
block|}
return|return
name|most_inclusive_rev
return|;
block|}
end_function

begin_comment
comment|/* If first item in each child of CHILDREN_WITH_MERGEINFO's    remaining_ranges is inclusive of END_REV, Slice the first range in    to two at END_REV. All the allocations are persistent and allocated    from POOL. */
end_comment

begin_function
specifier|static
name|void
name|slice_remaining_ranges
parameter_list|(
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|svn_boolean_t
name|is_rollback
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|->
name|absent
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|is_rollback
operator|&&
operator|(
name|range
operator|->
name|start
operator|>
name|end_rev
operator|)
operator|&&
operator|(
name|range
operator|->
name|end
operator|<
name|end_rev
operator|)
operator|)
operator|||
operator|(
operator|!
name|is_rollback
operator|&&
operator|(
name|range
operator|->
name|start
operator|<
name|end_rev
operator|)
operator|&&
operator|(
name|range
operator|->
name|end
operator|>
name|end_rev
operator|)
operator|)
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|split_range1
decl_stmt|,
modifier|*
name|split_range2
decl_stmt|;
name|split_range1
operator|=
name|svn_merge_range_dup
argument_list|(
name|range
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|split_range2
operator|=
name|svn_merge_range_dup
argument_list|(
name|range
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|split_range1
operator|->
name|end
operator|=
name|end_rev
expr_stmt|;
name|split_range2
operator|->
name|start
operator|=
name|end_rev
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|split_range1
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
operator|&
name|split_range2
argument_list|,
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     For each child in CHILDREN_WITH_MERGEINFO remove the first remaining_ranges    svn_merge_range_t *element of the child if that range has an end revision    equal to REVISION.     If a range is removed from a child's remaining_ranges array, allocate the    new remaining_ranges array in POOL.  */
end_comment

begin_function
specifier|static
name|void
name|remove_first_range_from_remaining_ranges
parameter_list|(
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
name|child
operator|->
name|absent
condition|)
continue|continue;
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|first_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|first_range
operator|->
name|end
operator|==
name|revision
condition|)
block|{
name|svn_sort__array_delete
argument_list|(
name|child
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Get a file's content and properties from the repository.    Set *FILENAME to the local path to a new temporary file holding its text,    and set *PROPS to a new hash of its properties.     RA_SESSION is a session open to the correct repository, which will be    temporarily reparented to the URL of the file itself.  LOCATION is the    repository location of the file.     The resulting file and the return values live as long as RESULT_POOL, all    other allocations occur in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|single_file_merge_get_file
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|location
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_sess_url
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_sess_url
argument_list|,
name|ra_session
argument_list|,
name|location
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_file
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|location
operator|->
name|rev
argument_list|,
name|stream
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|old_sess_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare two svn_client__merge_path_t elements **A and **B, given the    addresses of pointers to them. Return an integer less than, equal to, or    greater than zero if A sorts before, the same as, or after B, respectively.    This is a helper for qsort() and bsearch() on an array of such elements. */
end_comment

begin_function
specifier|static
name|int
name|compare_merge_path_t_as_paths
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_client__merge_path_t
modifier|*
name|child1
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_client__merge_path_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|svn_client__merge_path_t
modifier|*
name|child2
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_client__merge_path_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
return|return
name|svn_path_compare_paths
argument_list|(
name|child1
operator|->
name|abspath
argument_list|,
name|child2
operator|->
name|abspath
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return a pointer to the element of CHILDREN_WITH_MERGEINFO whose path  * is PATH, or return NULL if there is no such element. */
end_comment

begin_function
specifier|static
name|svn_client__merge_path_t
modifier|*
name|get_child_with_mergeinfo
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|abspath
parameter_list|)
block|{
name|svn_client__merge_path_t
name|merge_path
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|key
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
modifier|*
name|pchild
decl_stmt|;
name|merge_path
operator|.
name|abspath
operator|=
name|abspath
expr_stmt|;
name|key
operator|=
operator|&
name|merge_path
expr_stmt|;
name|pchild
operator|=
name|bsearch
argument_list|(
operator|&
name|key
argument_list|,
name|children_with_mergeinfo
operator|->
name|elts
argument_list|,
name|children_with_mergeinfo
operator|->
name|nelts
argument_list|,
name|children_with_mergeinfo
operator|->
name|elt_size
argument_list|,
name|compare_merge_path_t_as_paths
argument_list|)
expr_stmt|;
return|return
name|pchild
condition|?
operator|*
name|pchild
else|:
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Insert a deep copy of INSERT_ELEMENT into the CHILDREN_WITH_MERGEINFO    array at its correct position.  Allocate the new storage in POOL.    CHILDREN_WITH_MERGEINFO is a depth first sorted array of    (svn_client__merge_path_t *).     ### Most callers don't need this to deep-copy the new element.    ### It may be more efficient for some callers to insert a bunch of items        out of order and then sort afterwards. (One caller is doing a qsort        after calling this anyway.)  */
end_comment

begin_function
specifier|static
name|void
name|insert_child_to_merge
parameter_list|(
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|svn_client__merge_path_t
modifier|*
name|insert_element
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|insert_index
decl_stmt|;
specifier|const
name|svn_client__merge_path_t
modifier|*
name|new_element
decl_stmt|;
comment|/* Find where to insert the new element */
name|insert_index
operator|=
name|svn_sort__bsearch_lower_bound
argument_list|(
operator|&
name|insert_element
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|compare_merge_path_t_as_paths
argument_list|)
expr_stmt|;
name|new_element
operator|=
name|svn_client__merge_path_dup
argument_list|(
name|insert_element
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
operator|&
name|new_element
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|insert_index
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper for get_mergeinfo_paths().     CHILDREN_WITH_MERGEINFO, DEPTH, and POOL are    all cascaded from the arguments of the same name to get_mergeinfo_paths().     TARGET is the merge target.     *CHILD is the element in in CHILDREN_WITH_MERGEINFO that    get_mergeinfo_paths() is iterating over and *CURR_INDEX is index for    *CHILD.     If CHILD->ABSPATH is equal to MERGE_CMD_BATON->target->abspath do nothing.    Else if CHILD->ABSPATH is switched or absent then make sure its immediate    (as opposed to nearest) parent in CHILDREN_WITH_MERGEINFO is marked as    missing a child.  If the immediate parent does not exist in    CHILDREN_WITH_MERGEINFO then create it (and increment *CURR_INDEX so that    caller doesn't process the inserted element).  Also ensure that    CHILD->ABSPATH's siblings which are not already present in    CHILDREN_WITH_MERGEINFO are also added to the array, limited by DEPTH    (e.g. don't add directory siblings of a switched file).    Use POOL for temporary allocations only, any new CHILDREN_WITH_MERGEINFO    elements are allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|insert_parent_and_sibs_of_sw_absent_del_subtree
parameter_list|(
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|int
modifier|*
name|curr_index
parameter_list|,
name|svn_client__merge_path_t
modifier|*
name|child
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_client__merge_path_t
modifier|*
name|parent
decl_stmt|;
specifier|const
name|char
modifier|*
name|parent_abspath
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|child
operator|->
name|absent
operator|||
operator|(
name|child
operator|->
name|switched
operator|&&
name|strcmp
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
operator|!=
literal|0
operator|)
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|parent_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|parent
operator|=
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|parent_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
condition|)
block|{
name|parent
operator|->
name|missing_child
operator|=
name|child
operator|->
name|absent
expr_stmt|;
name|parent
operator|->
name|switched_child
operator|=
name|child
operator|->
name|switched
expr_stmt|;
block|}
else|else
block|{
comment|/* Create a new element to insert into CHILDREN_WITH_MERGEINFO. */
name|parent
operator|=
name|svn_client__merge_path_create
argument_list|(
name|parent_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|parent
operator|->
name|missing_child
operator|=
name|child
operator|->
name|absent
expr_stmt|;
name|parent
operator|->
name|switched_child
operator|=
name|child
operator|->
name|switched
expr_stmt|;
comment|/* Insert PARENT into CHILDREN_WITH_MERGEINFO. */
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Increment for loop index so we don't process the inserted element. */
operator|(
operator|*
name|curr_index
operator|)
operator|++
expr_stmt|;
block|}
comment|/*(parent == NULL) */
comment|/* Add all of PARENT's non-missing children that are not already present.*/
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_children
argument_list|(
operator|&
name|children
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|parent_abspath
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|child_abspath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|sibling_of_missing
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Does this child already exist in CHILDREN_WITH_MERGEINFO? */
name|sibling_of_missing
operator|=
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|child_abspath
argument_list|)
expr_stmt|;
comment|/* Create the missing child and insert it into CHILDREN_WITH_MERGEINFO.*/
if|if
condition|(
operator|!
name|sibling_of_missing
condition|)
block|{
comment|/* Don't add directory children if DEPTH is svn_depth_files. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
condition|)
block|{
name|svn_node_kind_t
name|child_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|child_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|child_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_kind
operator|!=
name|svn_node_file
condition|)
continue|continue;
block|}
name|sibling_of_missing
operator|=
name|svn_client__merge_path_create
argument_list|(
name|child_abspath
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|sibling_of_missing
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* pre_merge_status_cb's baton */
end_comment

begin_struct
struct|struct
name|pre_merge_status_baton_t
block|{
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
comment|/* const char *absolute_wc_path to svn_depth_t * mapping for depths      of empty, immediates, and files. */
name|apr_hash_t
modifier|*
name|shallow_subtrees
decl_stmt|;
comment|/* const char *absolute_wc_path to the same, for all paths missing      from the working copy. */
name|apr_hash_t
modifier|*
name|missing_subtrees
decl_stmt|;
comment|/* const char *absolute_wc_path const char * repos relative path, describing      the root of each switched subtree in the working copy and the repository      relative path it is switched to. */
name|apr_hash_t
modifier|*
name|switched_subtrees
decl_stmt|;
comment|/* A pool to allocate additions to the above hashes in. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A svn_wc_status_func4_t callback used by get_mergeinfo_paths to gather    all switched, depth filtered and missing subtrees under a merge target.     Note that this doesn't see server and user excluded trees. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pre_merge_status_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
specifier|const
name|svn_wc_status3_t
modifier|*
name|status
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|pre_merge_status_baton_t
modifier|*
name|pmsb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|status
operator|->
name|switched
operator|&&
operator|!
name|status
operator|->
name|file_external
condition|)
block|{
name|store_path
argument_list|(
name|pmsb
operator|->
name|switched_subtrees
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|->
name|depth
operator|==
name|svn_depth_empty
operator|||
name|status
operator|->
name|depth
operator|==
name|svn_depth_files
condition|)
block|{
specifier|const
name|char
modifier|*
name|dup_abspath
decl_stmt|;
name|svn_depth_t
modifier|*
name|depth
init|=
name|apr_pmemdup
argument_list|(
name|pmsb
operator|->
name|pool
argument_list|,
operator|&
name|status
operator|->
name|depth
argument_list|,
sizeof|sizeof
expr|*
name|depth
argument_list|)
decl_stmt|;
name|dup_abspath
operator|=
name|apr_pstrdup
argument_list|(
name|pmsb
operator|->
name|pool
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|pmsb
operator|->
name|shallow_subtrees
argument_list|,
name|dup_abspath
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|->
name|node_status
operator|==
name|svn_wc_status_missing
condition|)
block|{
name|svn_boolean_t
name|new_missing_root
init|=
name|TRUE
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|pmsb
operator|->
name|missing_subtrees
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|missing_root_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_dirent_is_ancestor
argument_list|(
name|missing_root_path
argument_list|,
name|local_abspath
argument_list|)
condition|)
block|{
name|new_missing_root
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|new_missing_root
condition|)
name|store_path
argument_list|(
name|pmsb
operator|->
name|missing_subtrees
argument_list|,
name|local_abspath
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find all the subtrees in the working copy tree rooted at TARGET_ABSPATH  * that have explicit mergeinfo.  * Set *SUBTREES_WITH_MERGEINFO to a hash mapping (const char *) absolute  * WC path to (svn_mergeinfo_t *) mergeinfo.  *  * ### Is this function equivalent to:  *  *   svn_client__get_wc_mergeinfo_catalog(  *     subtrees_with_mergeinfo, inherited=NULL, include_descendants=TRUE,  *     svn_mergeinfo_explicit, target_abspath, limit_path=NULL,  *     walked_path=NULL, ignore_invalid_mergeinfo=FALSE, ...)  *  *   except for the catalog keys being abspaths instead of repo-relpaths?  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_wc_explicit_mergeinfo_catalog
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|subtrees_with_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_opt_revision_t
name|working_revision
init|=
block|{
name|svn_opt_revision_working
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_hash_t
modifier|*
name|externals
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_propget5
argument_list|(
name|subtrees_with_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|,
name|target_abspath
argument_list|,
operator|&
name|working_revision
argument_list|,
operator|&
name|working_revision
argument_list|,
name|NULL
argument_list|,
name|depth
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__externals_defined_below
argument_list|(
operator|&
name|externals
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Convert property values to svn_mergeinfo_t. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
operator|*
name|subtrees_with_mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|wc_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* svn_client_propget5 picks up file externals with          mergeinfo, but we don't want those. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|externals
argument_list|,
name|wc_path
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
operator|*
name|subtrees_with_mergeinfo
argument_list|,
name|wc_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo_string
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Invalid mergeinfo detected on '%s', "
literal|"merge tracking not possible"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|svn_hash_sets
argument_list|(
operator|*
name|subtrees_with_mergeinfo
argument_list|,
name|wc_path
argument_list|,
name|mergeinfo
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge() when performing merge-tracking aware    merges.     Walk of the working copy tree rooted at TARGET->abspath to    depth DEPTH.  Create an svn_client__merge_path_t * for any path which meets    one or more of the following criteria:       1) Path has working svn:mergeinfo.      2) Path is switched.      3) Path is a subtree of the merge target (i.e. is not equal to         TARGET->abspath) and has no mergeinfo of its own but         its immediate parent has mergeinfo with non-inheritable ranges.  If         this isn't a dry-run and the merge is between differences in the same         repository, then this function will set working mergeinfo on the path         equal to the mergeinfo inheritable from its parent.      4) Path has an immediate child (or children) missing from the WC because         the child is switched or absent from the WC, or due to a sparse         checkout.      5) Path has a sibling (or siblings) missing from the WC because the         sibling is switched, absent, scheduled for deletion, or missing due to         a sparse checkout.      6) Path is absent from disk due to an authz restriction.      7) Path is equal to TARGET->abspath.      8) Path is an immediate *directory* child of         TARGET->abspath and DEPTH is svn_depth_immediates.      9) Path is an immediate *file* child of TARGET->abspath         and DEPTH is svn_depth_files.      10) Path is at a depth of 'empty' or 'files'.      11) Path is missing from disk (e.g. due to an OS-level deletion).     If subtrees within the requested DEPTH are unexpectedly missing disk,    then raise SVN_ERR_CLIENT_NOT_READY_TO_MERGE.     Store the svn_client__merge_path_t *'s in *CHILDREN_WITH_MERGEINFO in    depth-first order based on the svn_client__merge_path_t *s path member as    sorted by svn_path_compare_paths().  Set the remaining_ranges field of each    element to NULL.     Note: Since the walk is rooted at TARGET->abspath, the    latter is guaranteed to be in *CHILDREN_WITH_MERGEINFO and due to the    depth-first ordering it is guaranteed to be the first element in    *CHILDREN_WITH_MERGEINFO.     MERGE_CMD_BATON is cascaded from the argument of the same name in    do_directory_merge(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfo_paths
parameter_list|(
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|same_repos
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|subtrees_with_mergeinfo
decl_stmt|;
name|apr_hash_t
modifier|*
name|excluded_subtrees
decl_stmt|;
name|apr_hash_t
modifier|*
name|switched_subtrees
decl_stmt|;
name|apr_hash_t
modifier|*
name|shallow_subtrees
decl_stmt|;
name|apr_hash_t
modifier|*
name|missing_subtrees
decl_stmt|;
name|struct
name|pre_merge_status_baton_t
name|pre_merge_status_baton
decl_stmt|;
comment|/* Case 1: Subtrees with explicit mergeinfo. */
name|SVN_ERR
argument_list|(
name|get_wc_explicit_mergeinfo_catalog
argument_list|(
operator|&
name|subtrees_with_mergeinfo
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|depth
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|subtrees_with_mergeinfo
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|subtrees_with_mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|wc_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|mergeinfo_child
init|=
name|svn_client__merge_path_create
argument_list|(
name|wc_path
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Stash this child's pre-existing mergeinfo. */
name|mergeinfo_child
operator|->
name|pre_merge_mergeinfo
operator|=
name|mergeinfo
expr_stmt|;
comment|/* Note if this child has non-inheritable mergeinfo */
name|mergeinfo_child
operator|->
name|has_noninheritable
operator|=
name|svn_mergeinfo__is_noninheritable
argument_list|(
name|mergeinfo_child
operator|->
name|pre_merge_mergeinfo
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Append it.  We'll sort below. */
name|APR_ARRAY_PUSH
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
operator|=
name|svn_client__merge_path_dup
argument_list|(
name|mergeinfo_child
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Sort CHILDREN_WITH_MERGEINFO by each child's path (i.e. as per          compare_merge_path_t_as_paths).  Any subsequent insertions of new          children with insert_child_to_merge() require this ordering. */
name|qsort
argument_list|(
name|children_with_mergeinfo
operator|->
name|elts
argument_list|,
name|children_with_mergeinfo
operator|->
name|nelts
argument_list|,
name|children_with_mergeinfo
operator|->
name|elt_size
argument_list|,
name|compare_merge_path_t_as_paths
argument_list|)
expr_stmt|;
block|}
comment|/* Case 2: Switched subtrees      Case 10: Paths at depths of 'empty' or 'files'      Case 11: Paths missing from disk */
name|pre_merge_status_baton
operator|.
name|wc_ctx
operator|=
name|ctx
operator|->
name|wc_ctx
expr_stmt|;
name|switched_subtrees
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|pre_merge_status_baton
operator|.
name|switched_subtrees
operator|=
name|switched_subtrees
expr_stmt|;
name|shallow_subtrees
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|pre_merge_status_baton
operator|.
name|shallow_subtrees
operator|=
name|shallow_subtrees
expr_stmt|;
name|missing_subtrees
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|pre_merge_status_baton
operator|.
name|missing_subtrees
operator|=
name|missing_subtrees
expr_stmt|;
name|pre_merge_status_baton
operator|.
name|pool
operator|=
name|scratch_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_walk_status
argument_list|(
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|depth
argument_list|,
name|TRUE
comment|/* get_all */
argument_list|,
name|FALSE
comment|/* no_ignore */
argument_list|,
name|TRUE
comment|/* ignore_text_mods */
argument_list|,
name|NULL
comment|/* ingore_patterns */
argument_list|,
name|pre_merge_status_cb
argument_list|,
operator|&
name|pre_merge_status_baton
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue #2915: Raise an error describing the roots of any missing      subtrees, i.e. those that the WC thinks are on disk but have been      removed outside of Subversion. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|missing_subtrees
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|missing_subtree_err_buf
init|=
name|svn_stringbuf_create
argument_list|(
name|_
argument_list|(
literal|"Merge tracking not allowed with missing "
literal|"subtrees; try restoring these items "
literal|"first:\n"
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|missing_subtrees
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|missing_subtree_err_buf
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|missing_subtree_err_buf
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|missing_subtree_err_buf
operator|->
name|data
argument_list|)
return|;
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|switched_subtrees
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|switched_subtrees
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|wc_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|wc_path
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
condition|)
block|{
name|child
operator|->
name|switched
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|svn_client__merge_path_t
modifier|*
name|switched_child
init|=
name|svn_client__merge_path_create
argument_list|(
name|wc_path
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|switched_child
operator|->
name|switched
operator|=
name|TRUE
expr_stmt|;
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|switched_child
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|shallow_subtrees
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|shallow_subtrees
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_boolean_t
name|new_shallow_child
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|wc_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_depth_t
modifier|*
name|child_depth
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|shallow_child
init|=
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|wc_path
argument_list|)
decl_stmt|;
if|if
condition|(
name|shallow_child
condition|)
block|{
if|if
condition|(
operator|*
name|child_depth
operator|==
name|svn_depth_empty
operator|||
operator|*
name|child_depth
operator|==
name|svn_depth_files
condition|)
name|shallow_child
operator|->
name|missing_child
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|shallow_child
operator|=
name|svn_client__merge_path_create
argument_list|(
name|wc_path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|new_shallow_child
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|*
name|child_depth
operator|==
name|svn_depth_empty
operator|||
operator|*
name|child_depth
operator|==
name|svn_depth_files
condition|)
name|shallow_child
operator|->
name|missing_child
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* A little trickery: If PATH doesn't have any mergeinfo or has              only inheritable mergeinfo, we still describe it as having              non-inheritable mergeinfo if it is missing a child due to              a shallow depth.  Why? Because the mergeinfo we'll add to PATH              to describe the merge must be non-inheritable, so PATH's missing              children don't inherit it.  Marking these PATHs as non-              inheritable allows the logic for case 3 to properly account              for PATH's children. */
if|if
condition|(
operator|!
name|shallow_child
operator|->
name|has_noninheritable
operator|&&
operator|(
operator|*
name|child_depth
operator|==
name|svn_depth_empty
operator|||
operator|*
name|child_depth
operator|==
name|svn_depth_files
operator|)
condition|)
block|{
name|shallow_child
operator|->
name|has_noninheritable
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|new_shallow_child
condition|)
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|shallow_child
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Case 6: Paths absent from disk due to server or user exclusion. */
name|SVN_ERR
argument_list|(
name|svn_wc__get_excluded_subtrees
argument_list|(
operator|&
name|excluded_subtrees
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|excluded_subtrees
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|excluded_subtrees
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|wc_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|wc_path
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
condition|)
block|{
name|child
operator|->
name|absent
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|svn_client__merge_path_t
modifier|*
name|absent_child
init|=
name|svn_client__merge_path_create
argument_list|(
name|wc_path
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|absent_child
operator|->
name|absent
operator|=
name|TRUE
expr_stmt|;
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|absent_child
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Case 7: The merge target MERGE_CMD_BATON->target->abspath is always      present. */
if|if
condition|(
operator|!
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|target
operator|->
name|abspath
argument_list|)
condition|)
block|{
name|svn_client__merge_path_t
modifier|*
name|target_child
init|=
name|svn_client__merge_path_create
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|target_child
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Case 8: Path is an immediate *directory* child of      MERGE_CMD_BATON->target->abspath and DEPTH is svn_depth_immediates.       Case 9: Path is an immediate *file* child of      MERGE_CMD_BATON->target->abspath and DEPTH is svn_depth_files. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
operator|||
name|depth
operator|==
name|svn_depth_files
condition|)
block|{
name|int
name|j
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|immediate_children
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_children_of_working_node
argument_list|(
operator|&
name|immediate_children
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|immediate_children
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|immediate_child_abspath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|immediate_children
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_node_kind_t
name|immediate_child_kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|immediate_child_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|immediate_child_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|immediate_child_kind
operator|==
name|svn_node_dir
operator|&&
name|depth
operator|==
name|svn_depth_immediates
operator|)
operator|||
operator|(
name|immediate_child_kind
operator|==
name|svn_node_file
operator|&&
name|depth
operator|==
name|svn_depth_files
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|immediate_child_abspath
argument_list|)
condition|)
block|{
name|svn_client__merge_path_t
modifier|*
name|immediate_child
init|=
name|svn_client__merge_path_create
argument_list|(
name|immediate_child_abspath
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|immediate_child_kind
operator|==
name|svn_node_dir
operator|&&
name|depth
operator|==
name|svn_depth_immediates
condition|)
name|immediate_child
operator|->
name|immediate_child_dir
operator|=
name|TRUE
expr_stmt|;
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|immediate_child
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* If DEPTH isn't empty then cover cases 3), 4), and 5), possibly adding      elements to CHILDREN_WITH_MERGEINFO. */
if|if
condition|(
name|depth
operator|<=
name|svn_depth_empty
condition|)
return|return
name|SVN_NO_ERROR
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Case 3) Where merging to a path with a switched child the path          gets non-inheritable mergeinfo for the merge range performed and          the child gets its own set of mergeinfo.  If the switched child          later "returns", e.g. a switched path is unswitched, the child          may not have any explicit mergeinfo.  If the initial merge is          repeated we don't want to repeat the merge for the path, but we          do want to repeat it for the previously switched child.  To          ensure this we check if all of CHILD's non-missing children have          explicit mergeinfo (they should already be present in          CHILDREN_WITH_MERGEINFO if they do).  If not,          add the children without mergeinfo to CHILDREN_WITH_MERGEINFO so          do_directory_merge() will merge them independently.           But that's not enough!  Since do_directory_merge() performs          the merges on the paths in CHILDREN_WITH_MERGEINFO in a depth          first manner it will merge the previously switched path's parent          first.  As part of this merge it will update the parent's          previously non-inheritable mergeinfo and make it inheritable          (since it notices the path has no missing children), then when          do_directory_merge() finally merges the previously missing          child it needs to get mergeinfo from the child's nearest          ancestor, but since do_directory_merge() already tweaked that          mergeinfo, removing the non-inheritable flag, it appears that the          child already has been merged to.  To prevent this we set          override mergeinfo on the child now, before any merging is done,          so it has explicit mergeinfo that reflects only CHILD's          inheritable mergeinfo. */
comment|/* If depth is immediates or files then don't add new children if          CHILD is a subtree of the merge target; those children are below          the operational depth of the merge. */
if|if
condition|(
name|child
operator|->
name|has_noninheritable
operator|&&
operator|(
name|i
operator|==
literal|0
operator|||
name|depth
operator|==
name|svn_depth_infinity
operator|)
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|int
name|j
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_children
argument_list|(
operator|&
name|children
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|children
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child_of_noninheritable
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_abspath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children
argument_list|,
name|j
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* Does this child already exist in CHILDREN_WITH_MERGEINFO?                  If not, create it and insert it into                  CHILDREN_WITH_MERGEINFO and set override mergeinfo on                  it. */
name|child_of_noninheritable
operator|=
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|child_abspath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child_of_noninheritable
condition|)
block|{
comment|/* Don't add directory children if DEPTH                      is svn_depth_files. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_files
condition|)
block|{
name|svn_node_kind_t
name|child_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|child_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|child_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_kind
operator|!=
name|svn_node_file
condition|)
continue|continue;
block|}
comment|/* else DEPTH is infinity or immediates so we want both                      directory and file children. */
name|child_of_noninheritable
operator|=
name|svn_client__merge_path_create
argument_list|(
name|child_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|child_of_noninheritable
operator|->
name|child_of_noninheritable
operator|=
name|TRUE
expr_stmt|;
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|child_of_noninheritable
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
operator|&&
name|same_repos
condition|)
block|{
name|svn_mergeinfo_t
name|mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_nearest_ancestor
argument_list|,
name|child_of_noninheritable
operator|->
name|abspath
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__record_wc_mergeinfo
argument_list|(
name|child_of_noninheritable
operator|->
name|abspath
argument_list|,
name|mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Case 4 and 5 are handled by the following function. */
name|SVN_ERR
argument_list|(
name|insert_parent_and_sibs_of_sw_absent_del_subtree
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|target
argument_list|,
operator|&
name|i
argument_list|,
name|child
argument_list|,
name|depth
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* i< children_with_mergeinfo->nelts */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements the svn_log_entry_receiver_t interface.  *  * BATON is an 'apr_array_header_t *' array of 'svn_revnum_t'.  * Push a copy of LOG_ENTRY->revision onto BATON.  Thus, a  * series of invocations of this callback accumulates the  * corresponding set of revisions into BATON.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_changed_revs
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|revs
init|=
name|baton
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revs
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *MIN_REV_P to the oldest and *MAX_REV_P to the youngest start or end  * revision occurring in RANGELIST, or to SVN_INVALID_REVNUM if RANGELIST  * is empty. */
end_comment

begin_function
specifier|static
name|void
name|merge_range_find_extremes
parameter_list|(
name|svn_revnum_t
modifier|*
name|min_rev_p
parameter_list|,
name|svn_revnum_t
modifier|*
name|max_rev_p
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|min_rev_p
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|max_rev_p
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|range_min
init|=
name|MIN
argument_list|(
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|range_max
init|=
name|MAX
argument_list|(
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|min_rev_p
argument_list|)
operator|)
operator|||
operator|(
name|range_min
operator|<
operator|*
name|min_rev_p
operator|)
condition|)
operator|*
name|min_rev_p
operator|=
name|range_min
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|max_rev_p
argument_list|)
operator|)
operator|||
operator|(
name|range_max
operator|>
operator|*
name|max_rev_p
operator|)
condition|)
operator|*
name|max_rev_p
operator|=
name|range_max
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Wrapper around svn_ra_get_log2(). Invoke RECEIVER with RECEIVER_BATON  * on each commit from YOUNGEST_REV to OLDEST_REV in which TARGET_RELPATH  * changed.  TARGET_RELPATH is relative to RA_SESSION's URL.  * Important: Revision properties are not retrieved by this function for  * performance reasons.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|target_relpath
parameter_list|,
name|svn_revnum_t
name|youngest_rev
parameter_list|,
name|svn_revnum_t
name|oldest_rev
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|log_targets
decl_stmt|;
name|apr_array_header_t
modifier|*
name|revprops
decl_stmt|;
name|log_targets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|log_targets
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|target_relpath
expr_stmt|;
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_log2
argument_list|(
name|ra_session
argument_list|,
name|log_targets
argument_list|,
name|youngest_rev
argument_list|,
name|oldest_rev
argument_list|,
literal|0
comment|/* limit */
argument_list|,
name|discover_changed_paths
argument_list|,
name|FALSE
comment|/* strict_node_history */
argument_list|,
name|FALSE
comment|/* include_merged_revisions */
argument_list|,
name|revprops
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *OPERATIVE_RANGES_P to an array of svn_merge_range_t * merge    range objects copied wholesale from RANGES which have the property    that in some revision within that range the object identified by    RA_SESSION was modified (if by "modified" we mean "'svn log' would    return that revision).  *OPERATIVE_RANGES_P is allocated from the    same pool as RANGES, and the ranges within it are shared with    RANGES, too.     *OPERATIVE_RANGES_P may be the same as RANGES (that is, the output    parameter is set only after the input is no longer used).     Use POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_noop_merge_ranges
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|operative_ranges_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|ranges
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_revnum_t
name|oldest_rev
decl_stmt|,
name|youngest_rev
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changed_revs
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|ranges
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|operative_ranges
init|=
name|apr_array_make
argument_list|(
name|ranges
operator|->
name|pool
argument_list|,
name|ranges
operator|->
name|nelts
argument_list|,
name|ranges
operator|->
name|elt_size
argument_list|)
decl_stmt|;
comment|/* Find the revision extremes of the RANGES we have. */
name|merge_range_find_extremes
argument_list|(
operator|&
name|oldest_rev
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ranges
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|oldest_rev
argument_list|)
condition|)
name|oldest_rev
operator|++
expr_stmt|;
comment|/* make it inclusive */
comment|/* Get logs across those ranges, recording which revisions hold      changes to our object's history. */
name|SVN_ERR
argument_list|(
name|get_log
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|youngest_rev
argument_list|,
name|oldest_rev
argument_list|,
name|FALSE
argument_list|,
name|log_changed_revs
argument_list|,
name|changed_revs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Are there *any* changes? */
if|if
condition|(
name|changed_revs
operator|->
name|nelts
condition|)
block|{
comment|/* Our list of changed revisions should be in youngest-to-oldest          order. */
name|svn_revnum_t
name|youngest_changed_rev
init|=
name|APR_ARRAY_IDX
argument_list|(
name|changed_revs
argument_list|,
literal|0
argument_list|,
name|svn_revnum_t
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|oldest_changed_rev
init|=
name|APR_ARRAY_IDX
argument_list|(
name|changed_revs
argument_list|,
name|changed_revs
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_revnum_t
argument_list|)
decl_stmt|;
comment|/* Now, copy from RANGES to *OPERATIVE_RANGES, filtering out ranges          that aren't operative (by virtue of not having any revisions          represented in the CHANGED_REVS array). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ranges
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ranges
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|range_min
init|=
name|MIN
argument_list|(
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|)
operator|+
literal|1
decl_stmt|;
name|svn_revnum_t
name|range_max
init|=
name|MAX
argument_list|(
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* If the merge range is entirely outside the range of changed              revisions, we've no use for it. */
if|if
condition|(
operator|(
name|range_min
operator|>
name|youngest_changed_rev
operator|)
operator|||
operator|(
name|range_max
operator|<
name|oldest_changed_rev
operator|)
condition|)
continue|continue;
comment|/* Walk through the changed_revs to see if any of them fall              inside our current range. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|changed_revs
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_revnum_t
name|changed_rev
init|=
name|APR_ARRAY_IDX
argument_list|(
name|changed_revs
argument_list|,
name|j
argument_list|,
name|svn_revnum_t
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|changed_rev
operator|>=
name|range_min
operator|)
operator|&&
operator|(
name|changed_rev
operator|<=
name|range_max
operator|)
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|operative_ranges
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|range
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
operator|*
name|operative_ranges_p
operator|=
name|operative_ranges
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Merge Source Normalization ***/
end_comment

begin_comment
comment|/* qsort-compatible sort routine, rating merge_source_t * objects to    be in descending (youngest-to-oldest) order based on their ->loc1->rev    component. */
end_comment

begin_function
specifier|static
name|int
name|compare_merge_source_ts
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|svn_revnum_t
name|a_rev
init|=
operator|(
operator|*
operator|(
specifier|const
name|merge_source_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
operator|->
name|loc1
operator|->
name|rev
decl_stmt|;
name|svn_revnum_t
name|b_rev
init|=
operator|(
operator|*
operator|(
specifier|const
name|merge_source_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
operator|->
name|loc1
operator|->
name|rev
decl_stmt|;
if|if
condition|(
name|a_rev
operator|==
name|b_rev
condition|)
return|return
literal|0
return|;
return|return
name|a_rev
operator|<
name|b_rev
condition|?
literal|1
else|:
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Set *MERGE_SOURCE_TS_P to a list of merge sources generated by    slicing history location SEGMENTS with a given requested merge    RANGE.  Use SOURCE_LOC for full source URL calculation.     Order the merge sources in *MERGE_SOURCE_TS_P from oldest to    youngest. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|combine_range_with_segments
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|merge_source_ts_p
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|range
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|segments
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_loc
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|merge_source_ts
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|merge_source_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|minrev
init|=
name|MIN
argument_list|(
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|)
operator|+
literal|1
decl_stmt|;
name|svn_revnum_t
name|maxrev
init|=
name|MAX
argument_list|(
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|subtractive
init|=
operator|(
name|range
operator|->
name|start
operator|>
name|range
operator|->
name|end
operator|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|segments
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_location_segment_t
modifier|*
name|segment
init|=
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
name|i
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|loc1
decl_stmt|,
modifier|*
name|loc2
decl_stmt|;
name|merge_source_t
modifier|*
name|merge_source
decl_stmt|;
specifier|const
name|char
modifier|*
name|path1
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|rev1
decl_stmt|;
comment|/* If this segment doesn't overlap our range at all, or          represents a gap, ignore it. */
if|if
condition|(
operator|(
name|segment
operator|->
name|range_end
operator|<
name|minrev
operator|)
operator|||
operator|(
name|segment
operator|->
name|range_start
operator|>
name|maxrev
operator|)
operator|||
operator|(
operator|!
name|segment
operator|->
name|path
operator|)
condition|)
continue|continue;
comment|/* If our range spans a segment boundary, we have to point our          merge_source_t's path1 to the path of the immediately older          segment, else it points to the same location as its path2.  */
name|rev1
operator|=
name|MAX
argument_list|(
name|segment
operator|->
name|range_start
argument_list|,
name|minrev
argument_list|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|minrev
operator|<=
name|segment
operator|->
name|range_start
condition|)
block|{
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|path1
operator|=
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
operator|)
operator|->
name|path
expr_stmt|;
block|}
comment|/* If we've backed PATH1 up into a segment gap, let's back              it up further still to the segment before the gap.  We'll              have to adjust rev1, too. */
if|if
condition|(
operator|(
operator|!
name|path1
operator|)
operator|&&
operator|(
name|i
operator|>
literal|1
operator|)
condition|)
block|{
name|path1
operator|=
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
name|i
operator|-
literal|2
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
operator|)
operator|->
name|path
expr_stmt|;
name|rev1
operator|=
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
name|i
operator|-
literal|2
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
operator|)
operator|->
name|range_end
expr_stmt|;
block|}
block|}
else|else
block|{
name|path1
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|segment
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* If we don't have two valid paths, we won't know what to do          when merging.  This could happen if someone requested a merge          where the source didn't exist in a particular revision or          something.  The merge code would probably bomb out anyway, so          we'll just *not* create a merge source in this case. */
if|if
condition|(
operator|!
operator|(
name|path1
operator|&&
name|segment
operator|->
name|path
operator|)
condition|)
continue|continue;
comment|/* Build our merge source structure. */
name|loc1
operator|=
name|svn_client__pathrev_create_with_relpath
argument_list|(
name|source_loc
operator|->
name|repos_root_url
argument_list|,
name|source_loc
operator|->
name|repos_uuid
argument_list|,
name|rev1
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|loc2
operator|=
name|svn_client__pathrev_create_with_relpath
argument_list|(
name|source_loc
operator|->
name|repos_root_url
argument_list|,
name|source_loc
operator|->
name|repos_uuid
argument_list|,
name|MIN
argument_list|(
name|segment
operator|->
name|range_end
argument_list|,
name|maxrev
argument_list|)
argument_list|,
name|segment
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If this is subtractive, reverse the whole calculation. */
if|if
condition|(
name|subtractive
condition|)
name|merge_source
operator|=
name|merge_source_create
argument_list|(
name|loc2
argument_list|,
name|loc1
argument_list|,
name|TRUE
comment|/* ancestral */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|merge_source
operator|=
name|merge_source_create
argument_list|(
name|loc1
argument_list|,
name|loc2
argument_list|,
name|TRUE
comment|/* ancestral */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|merge_source_ts
argument_list|,
name|merge_source_t
operator|*
argument_list|)
operator|=
name|merge_source
expr_stmt|;
block|}
comment|/* If this was a subtractive merge, and we created more than one      merge source, we need to reverse the sort ordering of our sources. */
if|if
condition|(
name|subtractive
operator|&&
operator|(
name|merge_source_ts
operator|->
name|nelts
operator|>
literal|1
operator|)
condition|)
name|qsort
argument_list|(
name|merge_source_ts
operator|->
name|elts
argument_list|,
name|merge_source_ts
operator|->
name|nelts
argument_list|,
name|merge_source_ts
operator|->
name|elt_size
argument_list|,
name|compare_merge_source_ts
argument_list|)
expr_stmt|;
operator|*
name|merge_source_ts_p
operator|=
name|merge_source_ts
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Similar to normalize_merge_sources() except the input MERGE_RANGE_TS is a  * rangelist.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|normalize_merge_sources_internal
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|merge_sources_p
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_loc
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|merge_range_ts
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|source_peg_revnum
init|=
name|source_loc
operator|->
name|rev
decl_stmt|;
name|svn_revnum_t
name|oldest_requested
decl_stmt|,
name|youngest_requested
decl_stmt|;
name|svn_revnum_t
name|trim_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_array_header_t
modifier|*
name|segments
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize our return variable. */
operator|*
name|merge_sources_p
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|merge_source_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No ranges to merge?  No problem. */
if|if
condition|(
name|merge_range_ts
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Find the extremes of the revisions across our set of ranges. */
name|merge_range_find_extremes
argument_list|(
operator|&
name|oldest_requested
argument_list|,
operator|&
name|youngest_requested
argument_list|,
name|merge_range_ts
argument_list|)
expr_stmt|;
comment|/* ### FIXME:  Our underlying APIs can't yet handle the case where      the peg revision isn't the youngest of the three revisions.  So      we'll just verify that the source in the peg revision is related      to the source in the youngest requested revision (which is      all the underlying APIs would do in this case right now anyway). */
if|if
condition|(
name|source_peg_revnum
operator|<
name|youngest_requested
condition|)
block|{
name|svn_client__pathrev_t
modifier|*
name|start_loc
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__repos_location
argument_list|(
operator|&
name|start_loc
argument_list|,
name|ra_session
argument_list|,
name|source_loc
argument_list|,
name|youngest_requested
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|source_peg_revnum
operator|=
name|youngest_requested
expr_stmt|;
block|}
comment|/* Fetch the locations for our merge range span. */
name|SVN_ERR
argument_list|(
name|svn_client__repos_location_segments
argument_list|(
operator|&
name|segments
argument_list|,
name|ra_session
argument_list|,
name|source_loc
operator|->
name|url
argument_list|,
name|source_peg_revnum
argument_list|,
name|youngest_requested
argument_list|,
name|oldest_requested
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See if we fetched enough history to do the job.  "Surely we did,"      you say.  "After all, we covered the entire requested merge      range."  Yes, that's true, but if our first segment doesn't      extend back to the oldest request revision, we've got a special      case to deal with.  Or if the first segment represents a gap,      that's another special case.  */
name|trim_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|segments
operator|->
name|nelts
condition|)
block|{
name|svn_location_segment_t
modifier|*
name|first_segment
init|=
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
literal|0
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
decl_stmt|;
comment|/* If the first segment doesn't start with the OLDEST_REQUESTED          revision, we'll need to pass a trim revision to our range          cruncher. */
if|if
condition|(
name|first_segment
operator|->
name|range_start
operator|!=
name|oldest_requested
condition|)
block|{
name|trim_revision
operator|=
name|first_segment
operator|->
name|range_start
expr_stmt|;
block|}
comment|/* Else, if the first segment has no path (and therefore is a          gap), then we'll fetch the copy source revision from the          second segment (provided there is one, of course) and use it          to prepend an extra pathful segment to our list.           ### We could avoid this bit entirely if we'd passed          ### SVN_INVALID_REVNUM instead of OLDEST_REQUESTED to          ### svn_client__repos_location_segments(), but that would          ### really penalize clients hitting pre-1.5 repositories with          ### the typical small merge range request (because of the          ### lack of a node-origins cache in the repository).  */
elseif|else
if|if
condition|(
operator|!
name|first_segment
operator|->
name|path
condition|)
block|{
if|if
condition|(
name|segments
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|svn_location_segment_t
modifier|*
name|second_segment
init|=
name|APR_ARRAY_IDX
argument_list|(
name|segments
argument_list|,
literal|1
argument_list|,
name|svn_location_segment_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|segment_url
decl_stmt|;
specifier|const
name|char
modifier|*
name|original_repos_relpath
decl_stmt|;
name|svn_revnum_t
name|original_revision
decl_stmt|;
name|svn_opt_revision_t
name|range_start_rev
decl_stmt|;
name|range_start_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|range_start_rev
operator|.
name|value
operator|.
name|number
operator|=
name|second_segment
operator|->
name|range_start
expr_stmt|;
name|segment_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|source_loc
operator|->
name|repos_root_url
argument_list|,
name|second_segment
operator|->
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_copy_source
argument_list|(
operator|&
name|original_repos_relpath
argument_list|,
operator|&
name|original_revision
argument_list|,
name|segment_url
argument_list|,
operator|&
name|range_start_rev
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Got copyfrom data?  Fix up the first segment to cover                  back to COPYFROM_REV + 1, and then prepend a new                  segment covering just COPYFROM_REV. */
if|if
condition|(
name|original_repos_relpath
condition|)
block|{
name|svn_location_segment_t
modifier|*
name|new_segment
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_segment
argument_list|)
argument_list|)
decl_stmt|;
name|new_segment
operator|->
name|path
operator|=
name|original_repos_relpath
expr_stmt|;
name|new_segment
operator|->
name|range_start
operator|=
name|original_revision
expr_stmt|;
name|new_segment
operator|->
name|range_end
operator|=
name|original_revision
expr_stmt|;
name|svn_sort__array_insert
argument_list|(
operator|&
name|new_segment
argument_list|,
name|segments
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* For each range in our requested range set, try to determine the      path(s) associated with that range.  */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merge_range_ts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|merge_range_ts
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|merge_sources
decl_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|trim_revision
argument_list|)
condition|)
block|{
comment|/* If the range predates the trim revision, discard it. */
if|if
condition|(
name|MAX
argument_list|(
name|range
operator|->
name|start
argument_list|,
name|range
operator|->
name|end
argument_list|)
operator|<
name|trim_revision
condition|)
continue|continue;
comment|/* If the range overlaps the trim revision, trim it. */
if|if
condition|(
name|range
operator|->
name|start
operator|<
name|trim_revision
condition|)
name|range
operator|->
name|start
operator|=
name|trim_revision
expr_stmt|;
if|if
condition|(
name|range
operator|->
name|end
operator|<
name|trim_revision
condition|)
name|range
operator|->
name|end
operator|=
name|trim_revision
expr_stmt|;
block|}
comment|/* Copy the resulting merge sources into master list thereof. */
name|SVN_ERR
argument_list|(
name|combine_range_with_segments
argument_list|(
operator|&
name|merge_sources
argument_list|,
name|range
argument_list|,
name|segments
argument_list|,
name|source_loc
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_cat
argument_list|(
operator|*
name|merge_sources_p
argument_list|,
name|merge_sources
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine the normalized ranges to merge from a given line of history.     Calculate the result by intersecting the list of location segments at    which SOURCE_LOC existed along its line of history with the requested    revision ranges in RANGES_TO_MERGE.  RANGES_TO_MERGE is an array of    (svn_opt_revision_range_t *) revision ranges.  Use SOURCE_PATH_OR_URL to    resolve any WC-relative revision specifiers (such as 'base') in    RANGES_TO_MERGE.     Set *MERGE_SOURCES_P to an array of merge_source_t * objects, each    describing a normalized range of revisions to be merged from the line    history of SOURCE_LOC.  Order the objects from oldest to youngest.     RA_SESSION is an RA session open to the repository of SOURCE_LOC; it may    be temporarily reparented within this function.  Use RA_SESSION to find    the location segments along the line of history of SOURCE_LOC.     Allocate MERGE_SOURCES_P and its contents in RESULT_POOL.     See `MERGEINFO MERGE SOURCE NORMALIZATION' for more on the    background of this function. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|normalize_merge_sources
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|merge_sources_p
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_loc
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ranges_to_merge
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|source_abspath_or_url
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|merge_range_ts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|source_path_or_url
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
operator|&
name|source_abspath_or_url
argument_list|,
name|source_path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|source_abspath_or_url
operator|=
name|source_path_or_url
expr_stmt|;
comment|/* Create a list to hold svn_merge_range_t's. */
name|merge_range_ts
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|ranges_to_merge
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ranges_to_merge
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_opt_revision_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ranges_to_merge
argument_list|,
name|i
argument_list|,
name|svn_opt_revision_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
name|mrange
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Resolve revisions to real numbers, validating as we go. */
if|if
condition|(
operator|(
name|range
operator|->
name|start
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|||
operator|(
name|range
operator|->
name|end
operator|.
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not all required revisions are specified"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|mrange
operator|.
name|start
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|source_abspath_or_url
argument_list|,
name|ra_session
argument_list|,
operator|&
name|range
operator|->
name|start
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_revision_number
argument_list|(
operator|&
name|mrange
operator|.
name|end
argument_list|,
operator|&
name|youngest_rev
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|source_abspath_or_url
argument_list|,
name|ra_session
argument_list|,
operator|&
name|range
operator|->
name|end
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this isn't a no-op range... */
if|if
condition|(
name|mrange
operator|.
name|start
operator|!=
name|mrange
operator|.
name|end
condition|)
block|{
comment|/* ...then add it to the list. */
name|mrange
operator|.
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|merge_range_ts
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|svn_merge_range_dup
argument_list|(
operator|&
name|mrange
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|normalize_merge_sources_internal
argument_list|(
name|merge_sources_p
argument_list|,
name|source_loc
argument_list|,
name|merge_range_ts
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Merge Workhorse Functions ***/
end_comment

begin_comment
comment|/* Helper for do_directory_merge() and do_file_merge() which filters out a    path's own natural history from the mergeinfo describing a merge.     Given the natural history IMPLICIT_MERGEINFO of some wc merge target path,    the repository-relative merge source path SOURCE_REL_PATH, and the    requested merge range REQUESTED_RANGE from SOURCE_REL_PATH, remove any    portion of REQUESTED_RANGE which is already described in    IMPLICIT_MERGEINFO.  Store the result in *FILTERED_RANGELIST.     This function only filters natural history for mergeinfo that will be    *added* during a forward merge.  Removing natural history from explicit    mergeinfo is harmless.  If REQUESTED_RANGE describes a reverse merge,    then *FILTERED_RANGELIST is simply populated with one range described    by REQUESTED_RANGE.  *FILTERED_RANGELIST is never NULL.     Allocate *FILTERED_RANGELIST in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|filter_natural_history_from_mergeinfo
parameter_list|(
name|svn_rangelist_t
modifier|*
modifier|*
name|filtered_rangelist
parameter_list|,
specifier|const
name|char
modifier|*
name|source_rel_path
parameter_list|,
name|svn_mergeinfo_t
name|implicit_mergeinfo
parameter_list|,
name|svn_merge_range_t
modifier|*
name|requested_range
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Make the REQUESTED_RANGE into a rangelist. */
name|svn_rangelist_t
modifier|*
name|requested_rangelist
init|=
name|svn_rangelist__initialize
argument_list|(
name|requested_range
operator|->
name|start
argument_list|,
name|requested_range
operator|->
name|end
argument_list|,
name|requested_range
operator|->
name|inheritable
argument_list|,
name|pool
argument_list|)
decl_stmt|;
operator|*
name|filtered_rangelist
operator|=
name|NULL
expr_stmt|;
comment|/* For forward merges: If the IMPLICIT_MERGEINFO already describes ranges      associated with SOURCE_REL_PATH then filter those ranges out. */
if|if
condition|(
name|implicit_mergeinfo
operator|&&
operator|(
name|requested_range
operator|->
name|start
operator|<
name|requested_range
operator|->
name|end
operator|)
condition|)
block|{
name|svn_rangelist_t
modifier|*
name|implied_rangelist
init|=
name|svn_hash_gets
argument_list|(
name|implicit_mergeinfo
argument_list|,
name|source_rel_path
argument_list|)
decl_stmt|;
if|if
condition|(
name|implied_rangelist
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
name|filtered_rangelist
argument_list|,
name|implied_rangelist
argument_list|,
name|requested_rangelist
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If no filtering was performed the filtered rangelist is      simply the requested rangelist.*/
if|if
condition|(
operator|!
operator|(
operator|*
name|filtered_rangelist
operator|)
condition|)
operator|*
name|filtered_rangelist
operator|=
name|requested_rangelist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a merge source representing the sub-range from START_REV to    END_REV of SOURCE.  SOURCE obeys the rules described in the    'MERGEINFO MERGE SOURCE NORMALIZATION' comment at the top of this file.    The younger of START_REV and END_REV is inclusive while the older is    exclusive.     Allocate the result structure in POOL but leave the URLs in it as shallow    copies of the URLs in SOURCE. */
end_comment

begin_function
specifier|static
name|merge_source_t
modifier|*
name|subrange_source
parameter_list|(
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_rollback
init|=
operator|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
decl_stmt|;
name|svn_boolean_t
name|same_urls
init|=
operator|(
name|strcmp
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|url
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|url
argument_list|)
operator|==
literal|0
operator|)
decl_stmt|;
name|svn_client__pathrev_t
name|loc1
init|=
operator|*
name|source
operator|->
name|loc1
decl_stmt|;
name|svn_client__pathrev_t
name|loc2
init|=
operator|*
name|source
operator|->
name|loc2
decl_stmt|;
comment|/* For this function we require that the input source is 'ancestral'. */
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|source
operator|->
name|ancestral
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|start_rev
operator|!=
name|end_rev
argument_list|)
expr_stmt|;
name|loc1
operator|.
name|rev
operator|=
name|start_rev
expr_stmt|;
name|loc2
operator|.
name|rev
operator|=
name|end_rev
expr_stmt|;
if|if
condition|(
operator|!
name|same_urls
condition|)
block|{
if|if
condition|(
name|is_rollback
operator|&&
operator|(
name|end_rev
operator|!=
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|)
block|{
name|loc2
operator|.
name|url
operator|=
name|source
operator|->
name|loc1
operator|->
name|url
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|is_rollback
operator|)
operator|&&
operator|(
name|start_rev
operator|!=
name|source
operator|->
name|loc1
operator|->
name|rev
operator|)
condition|)
block|{
name|loc1
operator|.
name|url
operator|=
name|source
operator|->
name|loc2
operator|->
name|url
expr_stmt|;
block|}
block|}
return|return
name|merge_source_create
argument_list|(
operator|&
name|loc1
argument_list|,
operator|&
name|loc2
argument_list|,
name|source
operator|->
name|ancestral
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The single-file, simplified version of do_directory_merge(), which see for    parameter descriptions.     Additional parameters:     If SOURCES_RELATED is set, the "left" and "right" sides of SOURCE are    historically related (ancestors, uncles, second    cousins thrice removed, etc...).  (This is used to simulate the    history checks that the repository logic does in the directory case.)     If mergeinfo is being recorded to describe this merge, and RESULT_CATALOG    is not NULL, then don't record the new mergeinfo on the TARGET_ABSPATH,    but instead record it in RESULT_CATALOG, where the key is TARGET_ABSPATH    and the value is the new mergeinfo for that path.  Allocate additions    to RESULT_CATALOG in pool which RESULT_CATALOG was created in.     CONFLICTED_RANGE is as documented for do_directory_merge().     Note: MERGE_B->RA_SESSION1 must be associated with SOURCE->loc1->url and    MERGE_B->RA_SESSION2 with SOURCE->loc2->url. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_file_merge
parameter_list|(
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|single_range_conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|svn_boolean_t
name|sources_related
parameter_list|,
name|svn_boolean_t
name|squelch_mergeinfo_notifications
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_rangelist_t
modifier|*
name|remaining_ranges
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
init|=
name|merge_b
operator|->
name|ctx
decl_stmt|;
name|svn_merge_range_t
name|range
decl_stmt|;
name|svn_mergeinfo_t
name|target_mergeinfo
decl_stmt|;
name|svn_boolean_t
name|inherited
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|is_rollback
init|=
operator|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
decl_stmt|;
specifier|const
name|svn_client__pathrev_t
modifier|*
name|primary_src
init|=
name|is_rollback
condition|?
name|source
operator|->
name|loc1
else|:
name|source
operator|->
name|loc2
decl_stmt|;
name|svn_boolean_t
name|honor_mergeinfo
init|=
name|HONOR_MERGEINFO
argument_list|(
name|merge_b
argument_list|)
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|merge_target
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target_abspath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|conflict_report
operator|=
name|NULL
expr_stmt|;
comment|/* Note that this is a single-file merge. */
name|range
operator|.
name|start
operator|=
name|source
operator|->
name|loc1
operator|->
name|rev
expr_stmt|;
name|range
operator|.
name|end
operator|=
name|source
operator|->
name|loc2
operator|->
name|rev
expr_stmt|;
name|range
operator|.
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|merge_target
operator|=
name|svn_client__merge_path_create
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|honor_mergeinfo
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Fetch mergeinfo. */
name|err
operator|=
name|get_full_mergeinfo
argument_list|(
operator|&
name|target_mergeinfo
argument_list|,
operator|&
operator|(
name|merge_target
operator|->
name|implicit_mergeinfo
operator|)
argument_list|,
operator|&
name|inherited
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|target_abspath
argument_list|,
name|MAX
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Invalid mergeinfo detected on merge target '%s', "
literal|"merge tracking not possible"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* Calculate remaining merges unless this is a record only merge.          In that case the remaining range is the whole range described          by SOURCE->rev1:rev2. */
if|if
condition|(
operator|!
name|merge_b
operator|->
name|record_only
condition|)
block|{
comment|/* ### Bug?  calculate_remaining_ranges() needs 'source' to adhere            *   to the requirements of 'MERGEINFO MERGE SOURCE NORMALIZATION'            *   here, but it doesn't appear to be guaranteed so. */
name|SVN_ERR
argument_list|(
name|calculate_remaining_ranges
argument_list|(
name|NULL
argument_list|,
name|merge_target
argument_list|,
name|source
argument_list|,
name|target_mergeinfo
argument_list|,
name|merge_b
operator|->
name|implicit_src_gap
argument_list|,
name|FALSE
argument_list|,
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|remaining_ranges
operator|=
name|merge_target
operator|->
name|remaining_ranges
expr_stmt|;
comment|/* We are honoring mergeinfo and this is not a simple record only              merge which blindly records mergeinfo describing the merge of              SOURCE->LOC1->URL@SOURCE->LOC1->REV through              SOURCE->LOC2->URL@SOURCE->LOC2->REV.  This means that the oldest              and youngest revisions merged (as determined above by              calculate_remaining_ranges) might differ from those described              in SOURCE.  To keep the '--- Merging *' notifications consistent              with the '--- Recording mergeinfo *' notifications, we adjust              RANGE to account for such changes. */
if|if
condition|(
name|remaining_ranges
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|adj_start_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|adj_end_range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|remaining_ranges
argument_list|,
name|remaining_ranges
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|range
operator|.
name|start
operator|=
name|adj_start_range
operator|->
name|start
expr_stmt|;
name|range
operator|.
name|end
operator|=
name|adj_end_range
operator|->
name|end
expr_stmt|;
block|}
block|}
block|}
comment|/* The simple cases where our remaining range is SOURCE->rev1:rev2. */
if|if
condition|(
operator|!
name|honor_mergeinfo
operator|||
name|merge_b
operator|->
name|record_only
condition|)
block|{
name|remaining_ranges
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|&
name|range
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|remaining_ranges
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
operator|&
name|range
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|merge_b
operator|->
name|record_only
condition|)
block|{
name|svn_rangelist_t
modifier|*
name|ranges_to_merge
init|=
name|apr_array_copy
argument_list|(
name|scratch_pool
argument_list|,
name|remaining_ranges
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_relpath
init|=
literal|""
decl_stmt|;
comment|/* relative to root of merge */
if|if
condition|(
name|source
operator|->
name|ancestral
condition|)
block|{
name|apr_array_header_t
modifier|*
name|child_with_mergeinfo
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|target_info
decl_stmt|;
comment|/* If we have ancestrally related sources and more than one              range to merge, eliminate no-op ranges before going through              the effort of downloading the many copies of the file              required to do these merges (two copies per range). */
if|if
condition|(
name|remaining_ranges
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|old_sess_url
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_sess_url
argument_list|,
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|primary_src
operator|->
name|url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|remove_noop_merge_ranges
argument_list|(
operator|&
name|ranges_to_merge
argument_list|,
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_reparent
argument_list|(
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|old_sess_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* To support notify_merge_begin() initialize our              CHILD_WITH_MERGEINFO. See the comment              'THE CHILDREN_WITH_MERGEINFO ARRAY' at the start of this file. */
name|child_with_mergeinfo
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_client__merge_path_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Create a fake copy of merge_target as we don't keep                  remaining_ranges in sync (yet). */
name|target_info
operator|=
name|apr_pcalloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target_info
argument_list|)
argument_list|)
expr_stmt|;
name|target_info
operator|->
name|abspath
operator|=
name|merge_target
operator|->
name|abspath
expr_stmt|;
name|target_info
operator|->
name|remaining_ranges
operator|=
name|ranges_to_merge
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|child_with_mergeinfo
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
operator|=
name|target_info
expr_stmt|;
comment|/* And store in baton to allow using it from notify_merge_begin() */
name|merge_b
operator|->
name|notify_begin
operator|.
name|nodes_with_mergeinfo
operator|=
name|child_with_mergeinfo
expr_stmt|;
block|}
while|while
condition|(
name|ranges_to_merge
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|r
init|=
name|APR_ARRAY_IDX
argument_list|(
name|ranges_to_merge
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|merge_source_t
modifier|*
name|real_source
decl_stmt|;
specifier|const
name|char
modifier|*
name|left_file
decl_stmt|,
modifier|*
name|right_file
decl_stmt|;
name|apr_hash_t
modifier|*
name|left_props
decl_stmt|,
modifier|*
name|right_props
decl_stmt|;
specifier|const
name|svn_diff_source_t
modifier|*
name|left_source
decl_stmt|;
specifier|const
name|svn_diff_source_t
modifier|*
name|right_source
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Ensure any subsequent drives gets their own notification. */
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
operator|=
name|NULL
expr_stmt|;
comment|/* While we currently don't allow it, in theory we could be              fetching two fulltexts from two different repositories here. */
if|if
condition|(
name|source
operator|->
name|ancestral
condition|)
name|real_source
operator|=
name|subrange_source
argument_list|(
name|source
argument_list|,
name|r
operator|->
name|start
argument_list|,
name|r
operator|->
name|end
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
else|else
name|real_source
operator|=
name|source
expr_stmt|;
name|SVN_ERR
argument_list|(
name|single_file_merge_get_file
argument_list|(
operator|&
name|left_file
argument_list|,
operator|&
name|left_props
argument_list|,
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|real_source
operator|->
name|loc1
argument_list|,
name|target_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|single_file_merge_get_file
argument_list|(
operator|&
name|right_file
argument_list|,
operator|&
name|right_props
argument_list|,
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|real_source
operator|->
name|loc2
argument_list|,
name|target_abspath
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate sources for the diff processor */
name|left_source
operator|=
name|svn_diff__source_create
argument_list|(
name|r
operator|->
name|start
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|right_source
operator|=
name|svn_diff__source_create
argument_list|(
name|r
operator|->
name|end
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If the sources are related or we're ignoring ancestry in diffs,              do a text-n-props merge; otherwise, do a delete-n-add merge. */
if|if
condition|(
operator|!
operator|(
name|merge_b
operator|->
name|diff_ignore_ancestry
operator|||
name|sources_related
operator|)
condition|)
block|{
name|struct
name|merge_dir_baton_t
name|dir_baton
decl_stmt|;
name|void
modifier|*
name|file_baton
decl_stmt|;
name|svn_boolean_t
name|skip
decl_stmt|;
comment|/* Initialize minimal dir baton to allow calculating 'R'eplace                  from 'D'elete + 'A'dd. */
name|memset
argument_list|(
operator|&
name|dir_baton
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
name|dir_baton
operator|.
name|pool
operator|=
name|iterpool
expr_stmt|;
name|dir_baton
operator|.
name|tree_conflict_reason
operator|=
name|CONFLICT_REASON_NONE
expr_stmt|;
name|dir_baton
operator|.
name|tree_conflict_action
operator|=
name|svn_wc_conflict_action_edit
expr_stmt|;
name|dir_baton
operator|.
name|skip_reason
operator|=
name|svn_wc_notify_state_unknown
expr_stmt|;
comment|/* Delete... */
name|file_baton
operator|=
name|NULL
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|processor
operator|->
name|file_opened
argument_list|(
operator|&
name|file_baton
argument_list|,
operator|&
name|skip
argument_list|,
name|target_relpath
argument_list|,
name|left_source
argument_list|,
name|NULL
comment|/* right_source */
argument_list|,
name|NULL
comment|/* copyfrom_source */
argument_list|,
operator|&
name|dir_baton
argument_list|,
name|processor
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|SVN_ERR
argument_list|(
name|processor
operator|->
name|file_deleted
argument_list|(
name|target_relpath
argument_list|,
name|left_source
argument_list|,
name|left_file
argument_list|,
name|left_props
argument_list|,
name|file_baton
argument_list|,
name|processor
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ...plus add... */
name|file_baton
operator|=
name|NULL
expr_stmt|;
name|skip
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|processor
operator|->
name|file_opened
argument_list|(
operator|&
name|file_baton
argument_list|,
operator|&
name|skip
argument_list|,
name|target_relpath
argument_list|,
name|NULL
comment|/* left_source */
argument_list|,
name|right_source
argument_list|,
name|NULL
comment|/* copyfrom_source */
argument_list|,
operator|&
name|dir_baton
argument_list|,
name|processor
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|SVN_ERR
argument_list|(
name|processor
operator|->
name|file_added
argument_list|(
name|target_relpath
argument_list|,
name|NULL
comment|/* copyfrom_source */
argument_list|,
name|right_source
argument_list|,
name|NULL
comment|/* copyfrom_file */
argument_list|,
name|right_file
argument_list|,
name|NULL
comment|/* copyfrom_props */
argument_list|,
name|right_props
argument_list|,
name|file_baton
argument_list|,
name|processor
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... equals replace. */
block|}
else|else
block|{
name|void
modifier|*
name|file_baton
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|skip
init|=
name|FALSE
decl_stmt|;
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|;
comment|/* Deduce property diffs. */
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|propchanges
argument_list|,
name|right_props
argument_list|,
name|left_props
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|processor
operator|->
name|file_opened
argument_list|(
operator|&
name|file_baton
argument_list|,
operator|&
name|skip
argument_list|,
name|target_relpath
argument_list|,
name|left_source
argument_list|,
name|right_source
argument_list|,
name|NULL
comment|/* copyfrom_source */
argument_list|,
name|NULL
comment|/* dir_baton */
argument_list|,
name|processor
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skip
condition|)
name|SVN_ERR
argument_list|(
name|processor
operator|->
name|file_changed
argument_list|(
name|target_relpath
argument_list|,
name|left_source
argument_list|,
name|right_source
argument_list|,
name|left_file
argument_list|,
name|right_file
argument_list|,
name|left_props
argument_list|,
name|right_props
argument_list|,
name|TRUE
comment|/* file changed */
argument_list|,
name|propchanges
argument_list|,
name|file_baton
argument_list|,
name|processor
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|is_path_conflicted_by_merge
argument_list|(
name|merge_b
argument_list|)
condition|)
block|{
name|merge_source_t
modifier|*
name|remaining_range
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|real_source
operator|->
name|loc2
operator|->
name|rev
operator|!=
name|source
operator|->
name|loc2
operator|->
name|rev
condition|)
name|remaining_range
operator|=
name|subrange_source
argument_list|(
name|source
argument_list|,
name|real_source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|conflict_report
operator|=
name|single_range_conflict_report_create
argument_list|(
name|real_source
argument_list|,
name|remaining_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Only record partial mergeinfo if only a partial merge was                  performed before a conflict was encountered. */
name|range
operator|.
name|end
operator|=
name|r
operator|->
name|end
expr_stmt|;
break|break;
block|}
comment|/* Now delete the just merged range from the hash              (This list is used from notify_merge_begin)              Directory merges use remove_first_range_from_remaining_ranges() */
name|svn_sort__array_delete
argument_list|(
name|ranges_to_merge
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* !merge_b->record_only */
comment|/* Record updated WC mergeinfo to account for our new merges, minus      any unresolved conflicts and skips.  We use the original      REMAINING_RANGES here because we want to record all the requested      merge ranges, include the noop ones.  */
if|if
condition|(
name|RECORD_MERGEINFO
argument_list|(
name|merge_b
argument_list|)
operator|&&
name|remaining_ranges
operator|->
name|nelts
condition|)
block|{
specifier|const
name|char
modifier|*
name|mergeinfo_path
init|=
name|svn_client__pathrev_fspath
argument_list|(
name|primary_src
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|filtered_rangelist
decl_stmt|;
comment|/* Filter any ranges from TARGET_WCPATH's own history, there is no          need to record this explicitly in mergeinfo, it is already part          of TARGET_WCPATH's natural history (implicit mergeinfo). */
name|SVN_ERR
argument_list|(
name|filter_natural_history_from_mergeinfo
argument_list|(
operator|&
name|filtered_rangelist
argument_list|,
name|mergeinfo_path
argument_list|,
name|merge_target
operator|->
name|implicit_mergeinfo
argument_list|,
operator|&
name|range
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only record mergeinfo if there is something other than          self-referential mergeinfo, but don't record mergeinfo if          TARGET_WCPATH was skipped. */
if|if
condition|(
name|filtered_rangelist
operator|->
name|nelts
operator|&&
operator|(
name|apr_hash_count
argument_list|(
name|merge_b
operator|->
name|skipped_abspaths
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|merges
init|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
decl_stmt|;
comment|/* If merge target has inherited mergeinfo set it before              recording the first merge range. */
if|if
condition|(
name|inherited
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__record_wc_mergeinfo
argument_list|(
name|target_abspath
argument_list|,
name|target_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|merges
argument_list|,
name|target_abspath
argument_list|,
name|filtered_rangelist
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|squelch_mergeinfo_notifications
condition|)
block|{
comment|/* Notify that we are recording mergeinfo describing a merge. */
name|svn_merge_range_t
name|n_range
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__get_range_endpoints
argument_list|(
operator|&
name|n_range
operator|.
name|end
argument_list|,
operator|&
name|n_range
operator|.
name|start
argument_list|,
name|merges
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|n_range
operator|.
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|notify_mergeinfo_recording
argument_list|(
name|target_abspath
argument_list|,
operator|&
name|n_range
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|update_wc_mergeinfo
argument_list|(
name|result_catalog
argument_list|,
name|target_abspath
argument_list|,
name|mergeinfo_path
argument_list|,
name|merges
argument_list|,
name|is_rollback
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|merge_b
operator|->
name|notify_begin
operator|.
name|nodes_with_mergeinfo
operator|=
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge() to handle the case where a merge editor    drive adds explicit mergeinfo to a path which didn't have any explicit    mergeinfo previously.     MERGE_B is cascaded from the argument of the same    name in do_directory_merge().  Should be called only after    do_directory_merge() has called populate_remaining_ranges() and populated    the remaining_ranges field of each child in    CHILDREN_WITH_MERGEINFO (i.e. the remaining_ranges fields can be    empty but never NULL).     If MERGE_B->DRY_RUN is true do nothing, if it is false then    for each path (if any) in MERGE_B->PATHS_WITH_NEW_MERGEINFO merge that    path's inherited mergeinfo (if any) with its working explicit mergeinfo    and set that as the path's new explicit mergeinfo.  Then add an    svn_client__merge_path_t * element representing the path to    CHILDREN_WITH_MERGEINFO if it isn't already present.  All fields    in any elements added to CHILDREN_WITH_MERGEINFO are initialized    to FALSE/NULL with the exception of 'path' and 'remaining_ranges'.  The    latter is set to a rangelist equal to the remaining_ranges of the path's    nearest path-wise ancestor in CHILDREN_WITH_MERGEINFO.     Any elements added to CHILDREN_WITH_MERGEINFO are allocated    in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_children_with_new_mergeinfo
parameter_list|(
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
if|if
condition|(
operator|!
name|merge_b
operator|->
name|paths_with_new_mergeinfo
operator|||
name|merge_b
operator|->
name|dry_run
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Iterate over each path with explicit mergeinfo added by the merge. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|merge_b
operator|->
name|paths_with_new_mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|abspath_with_new_mergeinfo
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|path_inherited_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|path_explicit_mergeinfo
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|new_child
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Note: We could skip recording inherited mergeinfo here if this path          was added (with preexisting mergeinfo) by the merge.  That's actually          more correct, since the inherited mergeinfo likely describes          non-existent or unrelated merge history, but it's not quite so simple          as that, see http://subversion.tigris.org/issues/show_bug.cgi?id=4309          */
comment|/* Get the path's new explicit mergeinfo... */
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|path_explicit_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_explicit
argument_list|,
name|abspath_with_new_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ...there *should* always be explicit mergeinfo at this point          but you can't be too careful. */
if|if
condition|(
name|path_explicit_mergeinfo
condition|)
block|{
comment|/* Get the mergeinfo the path would have inherited before              the merge. */
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_or_repos_mergeinfo
argument_list|(
operator|&
name|path_inherited_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|svn_mergeinfo_nearest_ancestor
argument_list|,
comment|/* We only want inherited MI */
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|abspath_with_new_mergeinfo
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the path inherited any mergeinfo then merge that with the              explicit mergeinfo and record the result as the path's new              explicit mergeinfo. */
if|if
condition|(
name|path_inherited_mergeinfo
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|path_explicit_mergeinfo
argument_list|,
name|path_inherited_mergeinfo
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__record_wc_mergeinfo
argument_list|(
name|abspath_with_new_mergeinfo
argument_list|,
name|path_explicit_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the path is not in CHILDREN_WITH_MERGEINFO then add it. */
name|new_child
operator|=
name|get_child_with_mergeinfo
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|abspath_with_new_mergeinfo
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|new_child
condition|)
block|{
specifier|const
name|svn_client__merge_path_t
modifier|*
name|parent
init|=
name|find_nearest_ancestor
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|abspath_with_new_mergeinfo
argument_list|)
decl_stmt|;
name|new_child
operator|=
name|svn_client__merge_path_create
argument_list|(
name|abspath_with_new_mergeinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If path_with_new_mergeinfo is the merge target itself                  then it should already be in                  CHILDREN_WITH_MERGEINFO per the criteria of                  get_mergeinfo_paths() and we shouldn't be in this block.                  If path_with_new_mergeinfo is a subtree then it must have                  a parent in CHILDREN_WITH_MERGEINFO if only                  the merge target itself...so if we don't find a parent                  the caller has done something quite wrong. */
name|SVN_ERR_ASSERT
argument_list|(
name|parent
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|)
expr_stmt|;
comment|/* Set the path's remaining_ranges equal to its parent's. */
name|new_child
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist_dup
argument_list|(
name|parent
operator|->
name|remaining_ranges
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|insert_child_to_merge
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|new_child
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return true if any path in SUBTREES is equal to, or is a subtree of,    LOCAL_ABSPATH.  Return false otherwise.  The keys of SUBTREES are    (const char *) absolute paths and its values are irrelevant.    If SUBTREES is NULL return false. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|path_is_subtree
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|apr_hash_t
modifier|*
name|subtrees
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|subtrees
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|subtrees
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path_touched_by_merge
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_dirent_is_ancestor
argument_list|(
name|local_abspath
argument_list|,
name|path_touched_by_merge
argument_list|)
condition|)
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Return true if any merged, skipped, added or tree-conflicted path    recorded in MERGE_B is equal to, or is a subtree of LOCAL_ABSPATH.  Return    false otherwise.     ### Why not text- or prop-conflicted paths? Are such paths guaranteed        to be recorded as 'merged' or 'skipped' or 'added', perhaps? */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|subtree_touched_by_merge
parameter_list|(
specifier|const
name|char
modifier|*
name|local_abspath
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|path_is_subtree
argument_list|(
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|merged_abspaths
argument_list|,
name|pool
argument_list|)
operator|||
name|path_is_subtree
argument_list|(
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|skipped_abspaths
argument_list|,
name|pool
argument_list|)
operator|||
name|path_is_subtree
argument_list|(
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|added_abspaths
argument_list|,
name|pool
argument_list|)
operator|||
name|path_is_subtree
argument_list|(
name|local_abspath
argument_list|,
name|merge_b
operator|->
name|tree_conflicted_abspaths
argument_list|,
name|pool
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge() when performing mergeinfo unaware merges.     Merge the SOURCE diff into TARGET_DIR_WCPATH.     SOURCE, DEPTH, NOTIFY_B, and MERGE_B    are all cascaded from do_directory_merge's arguments of the same names.     CONFLICT_REPORT is as documented for do_directory_merge().     NOTE: This is a very thin wrapper around drive_merge_report_editor() and    exists only to populate CHILDREN_WITH_MERGEINFO with the single element    expected during mergeinfo unaware merges. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_mergeinfo_unaware_dir_merge
parameter_list|(
name|single_range_conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|target_dir_wcpath
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Initialize CHILDREN_WITH_MERGEINFO and populate it with      one element describing the merge of SOURCE->rev1:rev2 to      TARGET_DIR_WCPATH. */
name|svn_client__merge_path_t
modifier|*
name|item
init|=
name|svn_client__merge_path_create
argument_list|(
name|target_dir_wcpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|conflict_report
operator|=
name|NULL
expr_stmt|;
name|item
operator|->
name|remaining_ranges
operator|=
name|svn_rangelist__initialize
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
name|SVN_ERR
argument_list|(
name|drive_merge_report_editor
argument_list|(
name|target_dir_wcpath
argument_list|,
name|source
argument_list|,
name|NULL
argument_list|,
name|processor
argument_list|,
name|depth
argument_list|,
name|merge_b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_path_conflicted_by_merge
argument_list|(
name|merge_b
argument_list|)
condition|)
block|{
operator|*
name|conflict_report
operator|=
name|single_range_conflict_report_create
argument_list|(
name|source
argument_list|,
name|NULL
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A svn_log_entry_receiver_t baton for log_find_operative_subtree_revs(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|log_find_operative_subtree_baton_t
block|{
comment|/* Mapping of const char * absolute working copy paths to those      path's const char * repos absolute paths. */
name|apr_hash_t
modifier|*
name|operative_children
decl_stmt|;
comment|/* As per the arguments of the same name to      get_operative_immediate_children(). */
specifier|const
name|char
modifier|*
name|merge_source_fspath
decl_stmt|;
specifier|const
name|char
modifier|*
name|merge_target_abspath
decl_stmt|;
name|svn_depth_t
name|depth
decl_stmt|;
name|svn_wc_context_t
modifier|*
name|wc_ctx
decl_stmt|;
comment|/* A pool to allocate additions to the hashes in. */
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
name|log_find_operative_subtree_baton_t
typedef|;
end_typedef

begin_comment
comment|/* A svn_log_entry_receiver_t callback for    get_inoperative_immediate_children(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_find_operative_subtree_revs
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|log_find_operative_subtree_baton_t
modifier|*
name|log_baton
init|=
name|baton
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* It's possible that authz restrictions on the merge source prevent us      from knowing about any of the changes for LOG_ENTRY->REVISION. */
if|if
condition|(
operator|!
name|log_entry
operator|->
name|changed_paths2
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_log_changed_path2_t
modifier|*
name|change
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
block|{
specifier|const
name|char
modifier|*
name|child
decl_stmt|;
specifier|const
name|char
modifier|*
name|potential_child
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_path
init|=
name|svn_fspath__skip_ancestor
argument_list|(
name|log_baton
operator|->
name|merge_source_fspath
argument_list|,
name|path
argument_list|)
decl_stmt|;
comment|/* Some affected paths might be the root of the merge source or              entirely outside our subtree of interest. In either case they              are not operative *immediate* children. */
if|if
condition|(
name|rel_path
operator|==
name|NULL
operator|||
name|rel_path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|child
operator|=
name|svn_relpath_dirname
argument_list|(
name|rel_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
comment|/* The svn_log_changed_path2_t.node_kind members in                  LOG_ENTRY->CHANGED_PATHS2 may be set to                  svn_node_unknown, see svn_log_changed_path2_t and                  svn_fs_paths_changed2.  In that case we check the                  type of the corresponding subtree in the merge                  target. */
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
name|change
operator|->
name|node_kind
operator|==
name|svn_node_unknown
condition|)
block|{
specifier|const
name|char
modifier|*
name|wc_child_abspath
init|=
name|svn_dirent_join
argument_list|(
name|log_baton
operator|->
name|merge_target_abspath
argument_list|,
name|rel_path
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|node_kind
argument_list|,
name|log_baton
operator|->
name|wc_ctx
argument_list|,
name|wc_child_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|node_kind
operator|=
name|change
operator|->
name|node_kind
expr_stmt|;
block|}
comment|/* We only care about immediate directory children if                  DEPTH is svn_depth_files. */
if|if
condition|(
name|log_baton
operator|->
name|depth
operator|==
name|svn_depth_files
operator|&&
name|node_kind
operator|!=
name|svn_node_dir
condition|)
continue|continue;
comment|/* If depth is svn_depth_immediates, then we only care                  about changes to proper subtrees of PATH.  If the change                  is to PATH itself then PATH is within the operational                  depth of the merge. */
if|if
condition|(
name|log_baton
operator|->
name|depth
operator|==
name|svn_depth_immediates
condition|)
continue|continue;
name|child
operator|=
name|rel_path
expr_stmt|;
block|}
name|potential_child
operator|=
name|svn_dirent_join
argument_list|(
name|log_baton
operator|->
name|merge_target_abspath
argument_list|,
name|child
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|action
operator|==
literal|'A'
operator|||
operator|!
name|svn_hash_gets
argument_list|(
name|log_baton
operator|->
name|operative_children
argument_list|,
name|potential_child
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|log_baton
operator|->
name|operative_children
argument_list|,
name|apr_pstrdup
argument_list|(
name|log_baton
operator|->
name|result_pool
argument_list|,
name|potential_child
argument_list|)
argument_list|,
name|apr_pstrdup
argument_list|(
name|log_baton
operator|->
name|result_pool
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find immediate subtrees of MERGE_TARGET_ABSPATH which would have    additional differences applied if record_mergeinfo_for_dir_merge() were    recording mergeinfo describing a merge at svn_depth_infinity, rather    than at DEPTH (which is assumed to be shallow; if    DEPTH == svn_depth_infinity then this function does nothing beyond    setting *OPERATIVE_CHILDREN to an empty hash).     MERGE_SOURCE_FSPATH is the absolute repository path of the merge    source.  OLDEST_REV and YOUNGEST_REV are the revisions merged from    MERGE_SOURCE_FSPATH to MERGE_TARGET_ABSPATH.     RA_SESSION points to MERGE_SOURCE_FSPATH.     Set *OPERATIVE_CHILDREN to a hash (mapping const char * absolute    working copy paths to those path's const char * repos absolute paths)    containing all the immediate subtrees of MERGE_TARGET_ABSPATH which would    have a different diff applied if MERGE_SOURCE_FSPATH    -r(OLDEST_REV - 1):YOUNGEST_REV were merged to MERGE_TARGET_ABSPATH at    svn_depth_infinity rather than DEPTH.     RESULT_POOL is used to allocate the contents of *OPERATIVE_CHILDREN.    SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_operative_immediate_children
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|operative_children
parameter_list|,
specifier|const
name|char
modifier|*
name|merge_source_fspath
parameter_list|,
name|svn_revnum_t
name|oldest_rev
parameter_list|,
name|svn_revnum_t
name|youngest_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|merge_target_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_wc_context_t
modifier|*
name|wc_ctx
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|log_find_operative_subtree_baton_t
name|log_baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|oldest_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|youngest_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|oldest_rev
operator|<=
name|youngest_rev
argument_list|)
expr_stmt|;
operator|*
name|operative_children
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|depth
operator|==
name|svn_depth_infinity
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Now remove any paths from *OPERATIVE_CHILDREN that are inoperative when      merging MERGE_SOURCE_REPOS_PATH -r(OLDEST_REV - 1):YOUNGEST_REV to      MERGE_TARGET_ABSPATH at --depth infinity. */
name|log_baton
operator|.
name|operative_children
operator|=
operator|*
name|operative_children
expr_stmt|;
name|log_baton
operator|.
name|merge_source_fspath
operator|=
name|merge_source_fspath
expr_stmt|;
name|log_baton
operator|.
name|merge_target_abspath
operator|=
name|merge_target_abspath
expr_stmt|;
name|log_baton
operator|.
name|depth
operator|=
name|depth
expr_stmt|;
name|log_baton
operator|.
name|wc_ctx
operator|=
name|wc_ctx
expr_stmt|;
name|log_baton
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_log
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|youngest_rev
argument_list|,
name|oldest_rev
argument_list|,
name|TRUE
argument_list|,
comment|/* discover_changed_paths */
name|log_find_operative_subtree_revs
argument_list|,
operator|&
name|log_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for record_mergeinfo_for_dir_merge(): Identify which elements of    CHILDREN_WITH_MERGEINFO need new mergeinfo set to accurately    describe a merge, what inheritance type such new mergeinfo should have,    and what subtrees can be ignored altogether.     For each svn_client__merge_path_t CHILD in CHILDREN_WITH_MERGEINFO,    set CHILD->RECORD_MERGEINFO and CHILD->RECORD_NONINHERITABLE to true    if the subtree needs mergeinfo to describe the merge and if that    mergeinfo should be non-inheritable respectively.     If OPERATIVE_MERGE is true, then the merge being described is operative    as per subtree_touched_by_merge().  OPERATIVE_MERGE is false otherwise.     MERGED_RANGE, MERGEINFO_FSPATH, DEPTH, NOTIFY_B, and MERGE_B are all    cascaded from record_mergeinfo_for_dir_merge's arguments of the same    names.     SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|flag_subtrees_needing_mergeinfo
parameter_list|(
name|svn_boolean_t
name|operative_merge
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|merged_range
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|char
modifier|*
name|mergeinfo_fspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_hash_t
modifier|*
name|operative_immediate_children
init|=
name|NULL
decl_stmt|;
name|assert
argument_list|(
operator|!
name|merge_b
operator|->
name|dry_run
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|merge_b
operator|->
name|record_only
operator|&&
name|merged_range
operator|->
name|start
operator|<=
name|merged_range
operator|->
name|end
operator|&&
operator|(
name|depth
operator|<
name|svn_depth_infinity
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|get_operative_immediate_children
argument_list|(
operator|&
name|operative_immediate_children
argument_list|,
name|mergeinfo_fspath
argument_list|,
name|merged_range
operator|->
name|start
operator|+
literal|1
argument_list|,
name|merged_range
operator|->
name|end
argument_list|,
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|depth
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|merge_b
operator|->
name|ra_session1
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue #4056: Walk NOTIFY_B->CHILDREN_WITH_MERGEINFO reverse depth-first      order.  This way each child knows if it has operative missing/switched      children which necessitates non-inheritable mergeinfo. */
for|for
control|(
name|i
operator|=
name|children_with_mergeinfo
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Can't record mergeinfo on something that isn't here. */
if|if
condition|(
name|child
operator|->
name|absent
condition|)
continue|continue;
comment|/* Verify that remove_children_with_deleted_mergeinfo() did its job */
name|assert
argument_list|(
operator|(
name|i
operator|==
literal|0
operator|)
operator|||
operator|!
name|merge_b
operator|->
name|paths_with_deleted_mergeinfo
operator|||
operator|!
name|svn_hash_gets
argument_list|(
name|merge_b
operator|->
name|paths_with_deleted_mergeinfo
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't record mergeinfo on skipped paths. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|merge_b
operator|->
name|skipped_abspaths
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
condition|)
continue|continue;
comment|/* ### ptb: Yes, we could combine the following into a single          ### conditional, but clarity would suffer (even more than          ### it does now). */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* Always record mergeinfo on the merge target. */
name|child
operator|->
name|record_mergeinfo
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|merge_b
operator|->
name|record_only
operator|&&
operator|!
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
comment|/* Always record mergeinfo for --record-only merges. */
name|child
operator|->
name|record_mergeinfo
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|child
operator|->
name|immediate_child_dir
operator|&&
operator|!
name|child
operator|->
name|pre_merge_mergeinfo
operator|&&
name|operative_immediate_children
operator|&&
name|svn_hash_gets
argument_list|(
name|operative_immediate_children
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
condition|)
block|{
comment|/* We must record mergeinfo on those issue #3642 children              that are operative at a greater depth. */
name|child
operator|->
name|record_mergeinfo
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|operative_merge
operator|&&
name|subtree_touched_by_merge
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|merge_b
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* This subtree was affected by the merge. */
name|child
operator|->
name|record_mergeinfo
operator|=
name|TRUE
expr_stmt|;
comment|/* Were any CHILD's missing children skipped by the merge?              If not, then CHILD's missing children don't need to be              considered when recording mergeinfo describing the merge. */
if|if
condition|(
operator|!
name|merge_b
operator|->
name|reintegrate_merge
operator|&&
name|child
operator|->
name|missing_child
operator|&&
operator|!
name|path_is_subtree
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|merge_b
operator|->
name|skipped_abspaths
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
name|child
operator|->
name|missing_child
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* If CHILD has an immediate switched child or children and              none of these were touched by the merge, then we don't need              need to do any special handling of those switched subtrees              (e.g. record non-inheritable mergeinfo) when recording              mergeinfo describing the merge. */
if|if
condition|(
name|child
operator|->
name|switched_child
condition|)
block|{
name|int
name|j
decl_stmt|;
name|svn_boolean_t
name|operative_switched_child
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|j
operator|=
name|i
operator|+
literal|1
init|;
name|j
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|potential_child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|j
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|svn_dirent_is_ancestor
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|potential_child
operator|->
name|abspath
argument_list|)
condition|)
break|break;
comment|/* POTENTIAL_CHILD is a subtree of CHILD, but is it                      an immediate child? */
if|if
condition|(
name|strcmp
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|svn_dirent_dirname
argument_list|(
name|potential_child
operator|->
name|abspath
argument_list|,
name|iterpool
argument_list|)
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|potential_child
operator|->
name|switched
operator|&&
name|potential_child
operator|->
name|record_mergeinfo
condition|)
block|{
name|operative_switched_child
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
comment|/* Can we treat CHILD as if it has no switched children? */
if|if
condition|(
operator|!
name|operative_switched_child
condition|)
name|child
operator|->
name|switched_child
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|child
operator|->
name|record_mergeinfo
condition|)
block|{
comment|/* We need to record mergeinfo, but should that mergeinfo be              non-inheritable? */
name|svn_node_kind_t
name|path_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|path_kind
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Only directories can have non-inheritable mergeinfo. */
if|if
condition|(
name|path_kind
operator|==
name|svn_node_dir
condition|)
block|{
comment|/* There are two general cases where non-inheritable mergeinfo                  is required:                   1) There merge target has missing subtrees (due to authz                     restrictions, switched subtrees, or a shallow working                     copy).                   2) The operational depth of the merge itself is shallow. */
comment|/* We've already determined the first case. */
name|child
operator|->
name|record_noninheritable
operator|=
name|child
operator|->
name|missing_child
operator|||
name|child
operator|->
name|switched_child
expr_stmt|;
comment|/* The second case requires a bit more work. */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* If CHILD is the root of the merge target and the                      operational depth is empty or files, then the mere                      existence of operative immediate children means we                      must record non-inheritable mergeinfo.                       ### What about svn_depth_immediates?  In that case                      ### the merge target needs only normal inheritable                      ### mergeinfo and the target's immediate children will                      ### get non-inheritable mergeinfo, assuming they                      ### need even that. */
if|if
condition|(
name|depth
operator|<
name|svn_depth_immediates
operator|&&
name|operative_immediate_children
operator|&&
name|apr_hash_count
argument_list|(
name|operative_immediate_children
argument_list|)
condition|)
name|child
operator|->
name|record_noninheritable
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|depth
operator|==
name|svn_depth_immediates
condition|)
block|{
comment|/* An immediate directory child of the merge target, which                       was affected by a --depth=immediates merge, needs                       non-inheritable mergeinfo. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|operative_immediate_children
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
condition|)
name|child
operator|->
name|record_noninheritable
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* child->record_mergeinfo */
block|{
comment|/* If CHILD is in NOTIFY_B->CHILDREN_WITH_MERGEINFO simply              because it had no explicit mergeinfo of its own at the              start of the merge but is the child of of some path with              non-inheritable mergeinfo, then the explicit mergeinfo it              has *now* was set by get_mergeinfo_paths() -- see criteria              3 in that function's doc string.  So since CHILD->ABSPATH              was not touched by the merge we can remove the              mergeinfo. */
if|if
condition|(
name|child
operator|->
name|child_of_noninheritable
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__record_wc_mergeinfo
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     If RESULT_CATALOG is NULL then record mergeinfo describing a merge of    MERGED_RANGE->START:MERGED_RANGE->END from the repository relative path    MERGEINFO_FSPATH to the merge target (and possibly its subtrees) described    by NOTIFY_B->CHILDREN_WITH_MERGEINFO -- see the global comment    'THE CHILDREN_WITH_MERGEINFO ARRAY'.  Obviously this should only    be called if recording mergeinfo -- see doc string for RECORD_MERGEINFO().     If RESULT_CATALOG is not NULL, then don't record the new mergeinfo on the    WC, but instead record it in RESULT_CATALOG, where the keys are absolute    working copy paths and the values are the new mergeinfos for each.    Allocate additions to RESULT_CATALOG in pool which RESULT_CATALOG was    created in.     DEPTH, NOTIFY_B, MERGE_B, and SQUELCH_MERGEINFO_NOTIFICATIONS are all    cascaded from do_directory_merge's arguments of the same names.     SCRATCH_POOL is used for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_mergeinfo_for_dir_merge
parameter_list|(
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
specifier|const
name|svn_merge_range_t
modifier|*
name|merged_range
parameter_list|,
specifier|const
name|char
modifier|*
name|mergeinfo_fspath
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|squelch_mergeinfo_notifications
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|is_rollback
init|=
operator|(
name|merged_range
operator|->
name|start
operator|>
name|merged_range
operator|->
name|end
operator|)
decl_stmt|;
name|svn_boolean_t
name|operative_merge
decl_stmt|;
comment|/* Update the WC mergeinfo here to account for our new      merges, minus any unresolved conflicts and skips. */
comment|/* We need a scratch pool for iterations below. */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_merge_range_t
name|range
init|=
operator|*
name|merged_range
decl_stmt|;
name|assert
argument_list|(
operator|!
name|merge_b
operator|->
name|dry_run
argument_list|)
expr_stmt|;
comment|/* Regardless of what subtrees in MERGE_B->target->abspath might be missing      could this merge have been operative? */
name|operative_merge
operator|=
name|subtree_touched_by_merge
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|merge_b
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If this couldn't be an operative merge then don't bother with      the added complexity (and user confusion) of non-inheritable ranges.      There is no harm in subtrees inheriting inoperative mergeinfo. */
if|if
condition|(
operator|!
name|operative_merge
condition|)
name|range
operator|.
name|inheritable
operator|=
name|TRUE
expr_stmt|;
comment|/* Remove absent children at or under MERGE_B->target->abspath from      NOTIFY_B->CHILDREN_WITH_MERGEINFO      before we calculate the merges performed. */
name|remove_absent_children
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|children_with_mergeinfo
argument_list|)
expr_stmt|;
comment|/* Determine which subtrees of interest need mergeinfo recorded... */
name|SVN_ERR
argument_list|(
name|flag_subtrees_needing_mergeinfo
argument_list|(
name|operative_merge
argument_list|,
operator|&
name|range
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|mergeinfo_fspath
argument_list|,
name|depth
argument_list|,
name|merge_b
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ...and then record it. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|child_repos_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_merge_src_fspath
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|child_merge_rangelist
decl_stmt|;
name|apr_hash_t
modifier|*
name|child_merges
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|record_mergeinfo
condition|)
block|{
name|child_repos_path
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child_repos_path
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|child_merge_src_fspath
operator|=
name|svn_fspath__join
argument_list|(
name|mergeinfo_fspath
argument_list|,
name|child_repos_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Filter any ranges from each child's natural history before              setting mergeinfo describing the merge. */
name|SVN_ERR
argument_list|(
name|filter_natural_history_from_mergeinfo
argument_list|(
operator|&
name|child_merge_rangelist
argument_list|,
name|child_merge_src_fspath
argument_list|,
name|child
operator|->
name|implicit_mergeinfo
argument_list|,
operator|&
name|range
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_merge_rangelist
operator|->
name|nelts
operator|==
literal|0
condition|)
continue|continue;
if|if
condition|(
operator|!
name|squelch_mergeinfo_notifications
condition|)
block|{
comment|/* If the merge source has a gap, then don't mention                  those gap revisions in the notification. */
name|remove_source_gap
argument_list|(
operator|&
name|range
argument_list|,
name|merge_b
operator|->
name|implicit_src_gap
argument_list|)
expr_stmt|;
name|notify_mergeinfo_recording
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
operator|&
name|range
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* If we are here we know we will be recording some mergeinfo, but              before we do, set override mergeinfo on skipped paths so they              don't incorrectly inherit the mergeinfo we are about to set. */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|record_skips_in_mergeinfo
argument_list|(
name|mergeinfo_fspath
argument_list|,
name|child_merge_rangelist
argument_list|,
name|is_rollback
argument_list|,
name|merge_b
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We may need to record non-inheritable mergeinfo that applies              only to CHILD->ABSPATH. */
if|if
condition|(
name|child
operator|->
name|record_noninheritable
condition|)
name|svn_rangelist__set_inheritance
argument_list|(
name|child_merge_rangelist
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* If CHILD has inherited mergeinfo set it before              recording the first merge range. */
if|if
condition|(
name|child
operator|->
name|inherited_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__record_wc_mergeinfo
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|child
operator|->
name|pre_merge_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|merge_b
operator|->
name|implicit_src_gap
condition|)
block|{
comment|/* If this is a reverse merge reorder CHILD->REMAINING_RANGES                  so it will work with the svn_rangelist_remove API. */
if|if
condition|(
name|is_rollback
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child_merge_rangelist
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|child_merge_rangelist
argument_list|,
name|merge_b
operator|->
name|implicit_src_gap
argument_list|,
name|child_merge_rangelist
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_rollback
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_reverse
argument_list|(
name|child_merge_rangelist
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|child_merges
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* The short story:               If we are describing a forward merge, then the naive mergeinfo              defined by MERGE_SOURCE_PATH:MERGED_RANGE->START:              MERGE_SOURCE_PATH:MERGED_RANGE->END may contain non-existent              path-revs or may describe other lines of history.  We must              remove these invalid portion(s) before recording mergeinfo              describing the merge.               The long story:               If CHILD is the merge target we know that              MERGE_SOURCE_PATH:MERGED_RANGE->END exists.  Further, if there              were no copies in MERGE_SOURCE_PATH's history going back to              RANGE->START then we know that              MERGE_SOURCE_PATH:MERGED_RANGE->START exists too and the two              describe an unbroken line of history, and thus              MERGE_SOURCE_PATH:MERGED_RANGE->START:              MERGE_SOURCE_PATH:MERGED_RANGE->END is a valid description of              the merge -- see normalize_merge_sources() and the global comment              'MERGEINFO MERGE SOURCE NORMALIZATION'.               However, if there *was* a copy, then              MERGE_SOURCE_PATH:MERGED_RANGE->START doesn't exist or is              unrelated to MERGE_SOURCE_PATH:MERGED_RANGE->END.  Also, we              don't know if (MERGE_SOURCE_PATH:MERGED_RANGE->START)+1 through              (MERGE_SOURCE_PATH:MERGED_RANGE->END)-1 actually exist.               If CHILD is a subtree of the merge target, then nothing is              guaranteed beyond the fact that MERGE_SOURCE_PATH exists at              MERGED_RANGE->END. */
if|if
condition|(
operator|(
operator|!
name|merge_b
operator|->
name|record_only
operator|||
name|merge_b
operator|->
name|reintegrate_merge
operator|)
operator|&&
operator|(
operator|!
name|is_rollback
operator|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_mergeinfo_t
name|subtree_history_as_mergeinfo
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|child_merge_src_rangelist
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|subtree_mergeinfo_pathrev
init|=
name|svn_client__pathrev_create_with_relpath
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|loc
operator|.
name|repos_root_url
argument_list|,
name|merge_b
operator|->
name|target
operator|->
name|loc
operator|.
name|repos_uuid
argument_list|,
name|merged_range
operator|->
name|end
argument_list|,
name|child_merge_src_fspath
operator|+
literal|1
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
comment|/* Confirm that the naive mergeinfo we want to set on                  CHILD->ABSPATH both exists and is part of                  (MERGE_SOURCE_PATH+CHILD_REPOS_PATH)@MERGED_RANGE->END's                  history. */
comment|/* We know MERGED_RANGE->END is younger than MERGE_RANGE->START                  because we only do this for forward merges. */
name|err
operator|=
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|subtree_history_as_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|subtree_mergeinfo_pathrev
argument_list|,
name|merged_range
operator|->
name|end
argument_list|,
name|merged_range
operator|->
name|start
argument_list|,
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If CHILD is a subtree it may have been deleted prior to                  MERGED_RANGE->END so the above call to get its history                  will fail. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_FS_NOT_FOUND
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|child_merge_src_rangelist
operator|=
name|svn_hash_gets
argument_list|(
name|subtree_history_as_mergeinfo
argument_list|,
name|child_merge_src_fspath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|child_merge_rangelist
argument_list|,
name|child_merge_rangelist
argument_list|,
name|child_merge_src_rangelist
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|record_noninheritable
condition|)
name|svn_rangelist__set_inheritance
argument_list|(
name|child_merge_rangelist
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_hash_sets
argument_list|(
name|child_merges
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|child_merge_rangelist
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_wc_mergeinfo
argument_list|(
name|result_catalog
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|child_merge_src_fspath
argument_list|,
name|child_merges
argument_list|,
name|is_rollback
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Once is enough: We don't need to record mergeinfo describing              the merge a second.  If CHILD->ABSPATH is in              MERGE_B->ADDED_ABSPATHS, we'll do just that, so remove the              former from the latter. */
name|svn_hash_sets
argument_list|(
name|merge_b
operator|->
name|added_abspaths
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Elide explicit subtree mergeinfo whether or not we updated it. */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|svn_boolean_t
name|in_switched_subtree
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|switched
condition|)
name|in_switched_subtree
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
comment|/* Check if CHILD is part of a switched subtree */
name|svn_client__merge_path_t
modifier|*
name|parent
decl_stmt|;
name|int
name|j
init|=
name|i
operator|-
literal|1
decl_stmt|;
for|for
control|(
init|;
name|j
operator|>
literal|0
condition|;
name|j
operator|--
control|)
block|{
name|parent
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|j
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|parent
operator|&&
name|parent
operator|->
name|switched
operator|&&
name|svn_dirent_is_ancestor
argument_list|(
name|parent
operator|->
name|abspath
argument_list|,
name|child
operator|->
name|abspath
argument_list|)
condition|)
block|{
name|in_switched_subtree
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* Allow mergeinfo on switched subtrees to elide to the              repository. Otherwise limit elision to the merge target              for now.  do_directory_merge() will eventually try to              elide that when the merge is complete. */
name|SVN_ERR
argument_list|(
name|svn_client__elide_mergeinfo
argument_list|(
name|child
operator|->
name|abspath
argument_list|,
name|in_switched_subtree
condition|?
name|NULL
else|:
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* (i = 0; i< notify_b->children_with_mergeinfo->nelts; i++) */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     Record mergeinfo describing a merge of    MERGED_RANGE->START:MERGED_RANGE->END from the repository relative path    MERGEINFO_FSPATH to each path in ADDED_ABSPATHS which has explicit    mergeinfo or is the immediate child of a parent with explicit    non-inheritable mergeinfo.     DEPTH, MERGE_B, and SQUELCH_MERGEINFO_NOTIFICATIONS, are    cascaded from do_directory_merge's arguments of the same names.     Note: This is intended to support forward merges only, i.e.    MERGED_RANGE->START must be older than MERGED_RANGE->END. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|record_mergeinfo_for_added_subtrees
parameter_list|(
name|svn_merge_range_t
modifier|*
name|merged_range
parameter_list|,
specifier|const
name|char
modifier|*
name|mergeinfo_fspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|squelch_mergeinfo_notifications
parameter_list|,
name|apr_hash_t
modifier|*
name|added_abspaths
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* If no paths were added by the merge then we have nothing to do. */
if|if
condition|(
operator|!
name|added_abspaths
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR_ASSERT
argument_list|(
name|merged_range
operator|->
name|start
operator|<
name|merged_range
operator|->
name|end
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|added_abspaths
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|added_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|dir_abspath
decl_stmt|;
name|svn_mergeinfo_t
name|parent_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|added_path_mergeinfo
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|dir_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|added_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Grab the added path's explicit mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|added_path_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_explicit
argument_list|,
name|added_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the added path doesn't have explicit mergeinfo, does its immediate          parent have non-inheritable mergeinfo? */
if|if
condition|(
operator|!
name|added_path_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__get_wc_mergeinfo
argument_list|(
operator|&
name|parent_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|svn_mergeinfo_explicit
argument_list|,
name|dir_abspath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|added_path_mergeinfo
operator|||
name|svn_mergeinfo__is_noninheritable
argument_list|(
name|parent_mergeinfo
argument_list|,
name|iterpool
argument_list|)
condition|)
block|{
name|svn_node_kind_t
name|added_path_kind
decl_stmt|;
name|svn_mergeinfo_t
name|merge_mergeinfo
decl_stmt|;
name|svn_mergeinfo_t
name|adds_history_as_mergeinfo
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_added_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|added_path_mergeinfo_fspath
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|added_path_pathrev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|added_path_kind
argument_list|,
name|merge_b
operator|->
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|added_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Calculate the naive mergeinfo describing the merge. */
name|merge_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|rangelist
operator|=
name|svn_rangelist__initialize
argument_list|(
name|merged_range
operator|->
name|start
argument_list|,
name|merged_range
operator|->
name|end
argument_list|,
operator|(
operator|(
name|added_path_kind
operator|==
name|svn_node_file
operator|)
operator|||
operator|(
operator|!
operator|(
name|depth
operator|==
name|svn_depth_infinity
operator|||
name|depth
operator|==
name|svn_depth_immediates
operator|)
operator|)
operator|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Create the new mergeinfo path for added_path's mergeinfo.              (added_abspath had better be a child of MERGE_B->target->abspath              or something is *really* wrong.) */
name|rel_added_path
operator|=
name|svn_dirent_is_child
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|added_abspath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rel_added_path
argument_list|)
expr_stmt|;
name|added_path_mergeinfo_fspath
operator|=
name|svn_fspath__join
argument_list|(
name|mergeinfo_fspath
argument_list|,
name|rel_added_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|merge_mergeinfo
argument_list|,
name|added_path_mergeinfo_fspath
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
comment|/* Don't add new mergeinfo to describe the merge if that mergeinfo              contains non-existent merge sources.               We know that MERGEINFO_PATH/rel_added_path's history does not              span MERGED_RANGE->START:MERGED_RANGE->END but rather that it              was added at some revions greater than MERGED_RANGE->START              (assuming this is a forward merge).  It may have been added,              deleted, and re-added many times.  The point is that we cannot              blindly apply the naive mergeinfo calculated above because it              will describe non-existent merge sources. To avoid this we get              take the intersection of the naive mergeinfo with              MERGEINFO_PATH/rel_added_path's history. */
name|added_path_pathrev
operator|=
name|svn_client__pathrev_create_with_relpath
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|loc
operator|.
name|repos_root_url
argument_list|,
name|merge_b
operator|->
name|target
operator|->
name|loc
operator|.
name|repos_uuid
argument_list|,
name|MAX
argument_list|(
name|merged_range
operator|->
name|start
argument_list|,
name|merged_range
operator|->
name|end
argument_list|)
argument_list|,
name|added_path_mergeinfo_fspath
operator|+
literal|1
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|adds_history_as_mergeinfo
argument_list|,
name|NULL
argument_list|,
name|added_path_pathrev
argument_list|,
name|MAX
argument_list|(
name|merged_range
operator|->
name|start
argument_list|,
name|merged_range
operator|->
name|end
argument_list|)
argument_list|,
name|MIN
argument_list|(
name|merged_range
operator|->
name|start
argument_list|,
name|merged_range
operator|->
name|end
argument_list|)
argument_list|,
name|merge_b
operator|->
name|ra_session2
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_intersect2
argument_list|(
operator|&
name|merge_mergeinfo
argument_list|,
name|merge_mergeinfo
argument_list|,
name|adds_history_as_mergeinfo
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Combine the explicit mergeinfo on the added path (if any)              with the mergeinfo describing this merge. */
if|if
condition|(
name|added_path_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|merge_mergeinfo
argument_list|,
name|added_path_mergeinfo
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__record_wc_mergeinfo
argument_list|(
name|added_abspath
argument_list|,
name|merge_mergeinfo
argument_list|,
operator|!
name|squelch_mergeinfo_notifications
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton structure for log_noop_revs. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|log_noop_baton_t
block|{
comment|/* See the comment 'THE CHILDREN_WITH_MERGEINFO ARRAY' at the start      of this file.*/
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
decl_stmt|;
comment|/* Absolute repository path of younger of the two merge sources      being diffed. */
specifier|const
name|char
modifier|*
name|source_fspath
decl_stmt|;
comment|/* The merge target. */
specifier|const
name|merge_target_t
modifier|*
name|target
decl_stmt|;
comment|/* Initially empty rangelists allocated in POOL. The rangelists are    * populated across multiple invocations of log_noop_revs(). */
name|svn_rangelist_t
modifier|*
name|operative_ranges
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|merged_ranges
decl_stmt|;
comment|/* Pool to store the rangelists. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|log_noop_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Helper for log_noop_revs: Merge a svn_merge_range_t representation of    REVISION into RANGELIST. New elements added to rangelist are allocated    in RESULT_POOL.     This is *not* a general purpose rangelist merge but a special replacement    for svn_rangelist_merge when REVISION is guaranteed to be younger than any    element in RANGELIST.  svn_rangelist_merge is O(n) worst-case (i.e. when    all the ranges in output rangelist are older than the incoming changes).    This turns the special case of a single incoming younger range into O(1).    */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rangelist_merge_revision
parameter_list|(
name|svn_rangelist_t
modifier|*
name|rangelist
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_merge_range_t
modifier|*
name|new_range
decl_stmt|;
if|if
condition|(
name|rangelist
operator|->
name|nelts
condition|)
block|{
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|rangelist
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|range
operator|->
name|end
operator|==
name|revision
operator|-
literal|1
condition|)
block|{
comment|/* REVISION is adjacent to the youngest range in RANGELIST              so we can simply expand that range to encompass REVISION. */
name|range
operator|->
name|end
operator|=
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|new_range
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_range
argument_list|)
argument_list|)
expr_stmt|;
name|new_range
operator|->
name|start
operator|=
name|revision
operator|-
literal|1
expr_stmt|;
name|new_range
operator|->
name|end
operator|=
name|revision
expr_stmt|;
name|new_range
operator|->
name|inheritable
operator|=
name|TRUE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|rangelist
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|=
name|new_range
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements the svn_log_entry_receiver_t interface.     BATON is an log_noop_baton_t *.     Add LOG_ENTRY->REVISION to BATON->OPERATIVE_RANGES.     If LOG_ENTRY->REVISION has already been fully merged to    BATON->target->abspath per the mergeinfo in BATON->CHILDREN_WITH_MERGEINFO,    then add LOG_ENTRY->REVISION to BATON->MERGED_RANGES.     Use SCRATCH_POOL for temporary allocations.  Allocate additions to    BATON->MERGED_RANGES and BATON->OPERATIVE_RANGES in BATON->POOL.     Note: This callback must be invoked from oldest LOG_ENTRY->REVISION    to youngest LOG_ENTRY->REVISION -- see rangelist_merge_revision(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_noop_revs
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|log_noop_baton_t
modifier|*
name|log_gap_baton
init|=
name|baton
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_boolean_t
name|log_entry_rev_required
init|=
name|FALSE
decl_stmt|;
name|revision
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
comment|/* It's possible that authz restrictions on the merge source prevent us      from knowing about any of the changes for LOG_ENTRY->REVISION. */
if|if
condition|(
operator|!
name|log_entry
operator|->
name|changed_paths2
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Unconditionally add LOG_ENTRY->REVISION to BATON->OPERATIVE_MERGES. */
name|SVN_ERR
argument_list|(
name|rangelist_merge_revision
argument_list|(
name|log_gap_baton
operator|->
name|operative_ranges
argument_list|,
name|revision
argument_list|,
name|log_gap_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Examine each path affected by LOG_ENTRY->REVISION.  If the explicit or      inherited mergeinfo for *all* of the corresponding paths under      BATON->target->abspath reflects that LOG_ENTRY->REVISION has been      merged, then add LOG_ENTRY->REVISION to BATON->MERGED_RANGES. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|fspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|cwmi_abspath
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|paths_explicit_rangelist
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|mergeinfo_inherited
init|=
name|FALSE
decl_stmt|;
comment|/* Adjust REL_PATH so it is relative to the merge source then use it to          calculate what path in the merge target would be affected by this          revision. */
name|rel_path
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|log_gap_baton
operator|->
name|source_fspath
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
comment|/* Is PATH even within the merge target?  If it isn't we          can disregard it altogether. */
if|if
condition|(
name|rel_path
operator|==
name|NULL
condition|)
continue|continue;
name|cwmi_abspath
operator|=
name|svn_dirent_join
argument_list|(
name|log_gap_baton
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|rel_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Find any explicit or inherited mergeinfo for PATH. */
while|while
condition|(
operator|!
name|log_entry_rev_required
condition|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|get_child_with_mergeinfo
argument_list|(
name|log_gap_baton
operator|->
name|children_with_mergeinfo
argument_list|,
name|cwmi_abspath
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|&&
name|child
operator|->
name|pre_merge_mergeinfo
condition|)
block|{
comment|/* Found some explicit mergeinfo, grab any ranges                  for PATH. */
name|paths_explicit_rangelist
operator|=
name|svn_hash_gets
argument_list|(
name|child
operator|->
name|pre_merge_mergeinfo
argument_list|,
name|fspath
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cwmi_abspath
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
name|svn_dirent_is_root
argument_list|(
name|cwmi_abspath
argument_list|,
name|strlen
argument_list|(
name|cwmi_abspath
argument_list|)
argument_list|)
operator|||
name|strcmp
argument_list|(
name|log_gap_baton
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|cwmi_abspath
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't crawl any higher. */
break|break;
block|}
comment|/* Didn't find anything so crawl up to the parent. */
name|cwmi_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
name|cwmi_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|fspath
operator|=
name|svn_fspath__dirname
argument_list|(
name|fspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* At this point *if* we find mergeinfo it will be inherited. */
name|mergeinfo_inherited
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|paths_explicit_rangelist
condition|)
block|{
name|svn_rangelist_t
modifier|*
name|intersecting_range
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
decl_stmt|;
name|rangelist
operator|=
name|svn_rangelist__initialize
argument_list|(
name|revision
operator|-
literal|1
argument_list|,
name|revision
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If PATH inherited mergeinfo we must consider inheritance in the              event the inherited mergeinfo is actually non-inheritable. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|intersecting_range
argument_list|,
name|paths_explicit_rangelist
argument_list|,
name|rangelist
argument_list|,
name|mergeinfo_inherited
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|intersecting_range
operator|->
name|nelts
operator|==
literal|0
condition|)
name|log_entry_rev_required
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|log_entry_rev_required
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|log_entry_rev_required
condition|)
name|SVN_ERR
argument_list|(
name|rangelist_merge_revision
argument_list|(
name|log_gap_baton
operator|->
name|merged_ranges
argument_list|,
name|revision
argument_list|,
name|log_gap_baton
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_directory_merge().     SOURCE is cascaded from the argument of the same name in    do_directory_merge().  TARGET is the merge target.  RA_SESSION is the    session for SOURCE->loc2.     Find all the ranges required by subtrees in    CHILDREN_WITH_MERGEINFO that are *not* required by    TARGET->abspath (i.e. CHILDREN_WITH_MERGEINFO[0]).  If such    ranges exist, then find any subset of ranges which, if merged, would be    inoperative.  Finally, if any inoperative ranges are found then remove    these ranges from all of the subtree's REMAINING_RANGES.     This function should only be called when honoring mergeinfo during    forward merges (i.e. SOURCE->rev1< SOURCE->rev2). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_noop_subtree_ranges
parameter_list|(
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* ### Do we need to check that we are at a uniform working revision? */
name|int
name|i
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|root_child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
literal|0
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|requested_ranges
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|subtree_gap_ranges
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|subtree_remaining_ranges
decl_stmt|;
name|log_noop_baton_t
name|log_gap_baton
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|oldest_gap_rev
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|youngest_gap_rev
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|inoperative_ranges
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|longest_common_subtree_ancestor
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|ra_session
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This function is only intended to work with forward merges. */
if|if
condition|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Another easy out: There are no subtrees. */
if|if
condition|(
name|children_with_mergeinfo
operator|->
name|nelts
operator|<
literal|2
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|subtree_remaining_ranges
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Given the requested merge of SOURCE->rev1:rev2 might there be any      part of this range required for subtrees but not for the target? */
name|requested_ranges
operator|=
name|svn_rangelist__initialize
argument_list|(
name|MIN
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|MAX
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|)
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
name|subtree_gap_ranges
argument_list|,
name|root_child
operator|->
name|remaining_ranges
argument_list|,
name|requested_ranges
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Early out, nothing to operate on */
if|if
condition|(
operator|!
name|subtree_gap_ranges
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Create a rangelist describing every range required across all subtrees. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Issue #4269: Keep track of the longest common ancestor of all the          subtrees which require merges.  This may be a child of          TARGET->ABSPATH, which will allow us to narrow the log request          below. */
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|&&
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
condition|)
block|{
if|if
condition|(
name|longest_common_subtree_ancestor
condition|)
name|longest_common_subtree_ancestor
operator|=
name|svn_dirent_get_longest_ancestor
argument_list|(
name|longest_common_subtree_ancestor
argument_list|,
name|child
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|longest_common_subtree_ancestor
operator|=
name|child
operator|->
name|abspath
expr_stmt|;
block|}
comment|/* CHILD->REMAINING_RANGES will be NULL if child is absent. */
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|&&
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|subtree_remaining_ranges
argument_list|,
name|child
operator|->
name|remaining_ranges
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* It's possible that none of the subtrees had any remaining ranges. */
if|if
condition|(
operator|!
name|subtree_remaining_ranges
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Ok, *finally* we can answer what part(s) of SOURCE->rev1:rev2 are      required for the subtrees but not the target. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_intersect
argument_list|(
operator|&
name|subtree_gap_ranges
argument_list|,
name|subtree_gap_ranges
argument_list|,
name|subtree_remaining_ranges
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Another early out */
if|if
condition|(
operator|!
name|subtree_gap_ranges
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* One or more subtrees need some revisions that the target doesn't need.      Use log to determine if any of these revisions are inoperative. */
name|oldest_gap_rev
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|subtree_gap_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
name|youngest_gap_rev
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|subtree_gap_ranges
argument_list|,
name|subtree_gap_ranges
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Set up the log baton. */
name|log_gap_baton
operator|.
name|children_with_mergeinfo
operator|=
name|children_with_mergeinfo
expr_stmt|;
name|log_gap_baton
operator|.
name|source_fspath
operator|=
name|svn_client__pathrev_fspath
argument_list|(
name|source
operator|->
name|loc2
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|log_gap_baton
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|log_gap_baton
operator|.
name|merged_ranges
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|log_gap_baton
operator|.
name|operative_ranges
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|log_gap_baton
operator|.
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Find the longest common ancestor of all subtrees relative to      RA_SESSION's URL. */
if|if
condition|(
name|longest_common_subtree_ancestor
condition|)
name|longest_common_subtree_ancestor
operator|=
name|svn_dirent_skip_ancestor
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|longest_common_subtree_ancestor
argument_list|)
expr_stmt|;
else|else
name|longest_common_subtree_ancestor
operator|=
literal|""
expr_stmt|;
comment|/* Invoke the svn_log_entry_receiver_t receiver log_noop_revs() from      oldest to youngest.  The receiver is optimized to add ranges to      log_gap_baton.merged_ranges and log_gap_baton.operative_ranges, but      requires that the revs arrive oldest to youngest -- see log_noop_revs()      and rangelist_merge_revision(). */
name|err
operator|=
name|get_log
argument_list|(
name|ra_session
argument_list|,
name|longest_common_subtree_ancestor
argument_list|,
name|oldest_gap_rev
operator|->
name|start
operator|+
literal|1
argument_list|,
name|youngest_gap_rev
operator|->
name|end
argument_list|,
name|TRUE
argument_list|,
name|log_noop_revs
argument_list|,
operator|&
name|log_gap_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* It's possible that the only subtrees with mergeinfo in TARGET don't have      any corresponding subtree in SOURCE between SOURCE->REV1< SOURCE->REV2.      So it's also possible that we may ask for the logs of non-existent paths.      If we do, then assume that no subtree requires any ranges that are not      already required by the TARGET. */
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_FS_NOT_FOUND
operator|&&
name|longest_common_subtree_ancestor
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* Asked about a non-existent subtree in SOURCE. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|log_gap_baton
operator|.
name|merged_ranges
operator|=
name|svn_rangelist__initialize
argument_list|(
name|oldest_gap_rev
operator|->
name|start
argument_list|,
name|youngest_gap_rev
operator|->
name|end
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|inoperative_ranges
operator|=
name|svn_rangelist__initialize
argument_list|(
name|oldest_gap_rev
operator|->
name|start
argument_list|,
name|youngest_gap_rev
operator|->
name|end
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
operator|(
name|inoperative_ranges
operator|)
argument_list|,
name|log_gap_baton
operator|.
name|operative_ranges
argument_list|,
name|inoperative_ranges
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist_merge2
argument_list|(
name|log_gap_baton
operator|.
name|merged_ranges
argument_list|,
name|inoperative_ranges
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|children_with_mergeinfo
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_client__merge_path_t
modifier|*
name|child
init|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|i
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
decl_stmt|;
comment|/* CHILD->REMAINING_RANGES will be NULL if child is absent. */
if|if
condition|(
name|child
operator|->
name|remaining_ranges
operator|&&
name|child
operator|->
name|remaining_ranges
operator|->
name|nelts
condition|)
block|{
comment|/* Remove inoperative ranges from all children so we don't perform              inoperative editor drives. */
name|SVN_ERR
argument_list|(
name|svn_rangelist_remove
argument_list|(
operator|&
operator|(
name|child
operator|->
name|remaining_ranges
operator|)
argument_list|,
name|log_gap_baton
operator|.
name|merged_ranges
argument_list|,
name|child
operator|->
name|remaining_ranges
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|log_gap_baton
operator|.
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform a merge of changes in SOURCE to the working copy path    TARGET_ABSPATH. Both URLs in SOURCE, and TARGET_ABSPATH all represent    directories -- for the single file case, the caller should use    do_file_merge().     CHILDREN_WITH_MERGEINFO and MERGE_B describe the merge being performed    As this function is for a mergeinfo-aware merge, SOURCE->ancestral    should be TRUE, and SOURCE->loc1 must be a historical ancestor of    SOURCE->loc2, or vice-versa (see `MERGEINFO MERGE SOURCE NORMALIZATION'    for more requirements around SOURCE).     Mergeinfo changes will be recorded unless MERGE_B->dry_run is true.     If mergeinfo is being recorded, SQUELCH_MERGEINFO_NOTIFICATIONS is FALSE,    and MERGE_B->CTX->NOTIFY_FUNC2 is not NULL, then call    MERGE_B->CTX->NOTIFY_FUNC2 with MERGE_B->CTX->NOTIFY_BATON2 and a    svn_wc_notify_merge_record_info_begin notification before any mergeinfo    changes are made to describe the merge performed.     If mergeinfo is being recorded to describe this merge, and RESULT_CATALOG    is not NULL, then don't record the new mergeinfo on the WC, but instead    record it in RESULT_CATALOG, where the keys are absolute working copy    paths and the values are the new mergeinfos for each.  Allocate additions    to RESULT_CATALOG in pool which RESULT_CATALOG was created in.     Handle DEPTH as documented for svn_client_merge5().     CONFLICT_REPORT is as documented for do_directory_merge().     Perform any temporary allocations in SCRATCH_POOL.     NOTE: This is a wrapper around drive_merge_report_editor() which    handles the complexities inherent to situations where a given    directory's children may have intersecting merges (because they    meet one or more of the criteria described in get_mergeinfo_paths()). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_mergeinfo_aware_dir_merge
parameter_list|(
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|single_range_conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
parameter_list|,
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|squelch_mergeinfo_notifications
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* The range defining the mergeinfo we will record to describe the merge      (assuming we are recording mergeinfo       Note: This may be a subset of SOURCE->rev1:rev2 if      populate_remaining_ranges() determines that some part of      SOURCE->rev1:rev2 has already been wholly merged to TARGET_ABSPATH.      Also, the actual editor drive(s) may be a subset of RANGE, if      remove_noop_subtree_ranges() and/or fix_deleted_subtree_ranges()      further tweak things. */
name|svn_merge_range_t
name|range
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|svn_client__merge_path_t
modifier|*
name|target_merge_path
decl_stmt|;
name|svn_boolean_t
name|is_rollback
init|=
operator|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|>
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|source
operator|->
name|ancestral
argument_list|)
expr_stmt|;
comment|/*** If we get here, we're dealing with related sources from the        same repository as the target -- merge tracking might be        happenin'! ***/
operator|*
name|conflict_report
operator|=
name|NULL
expr_stmt|;
comment|/* Point our RA_SESSION to the URL of our youngest merge source side. */
name|ra_session
operator|=
name|is_rollback
condition|?
name|merge_b
operator|->
name|ra_session1
else|:
name|merge_b
operator|->
name|ra_session2
expr_stmt|;
comment|/* Fill NOTIFY_B->CHILDREN_WITH_MERGEINFO with child paths (const      svn_client__merge_path_t *) which might have intersecting merges      because they meet one or more of the criteria described in      get_mergeinfo_paths(). Here the paths are arranged in a depth      first order. */
name|SVN_ERR
argument_list|(
name|get_mergeinfo_paths
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|merge_b
operator|->
name|target
argument_list|,
name|depth
argument_list|,
name|merge_b
operator|->
name|dry_run
argument_list|,
name|merge_b
operator|->
name|same_repos
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The first item from the NOTIFY_B->CHILDREN_WITH_MERGEINFO is always      the target thanks to depth-first ordering. */
name|target_merge_path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|children_with_mergeinfo
argument_list|,
literal|0
argument_list|,
name|svn_client__merge_path_t
operator|*
argument_list|)
expr_stmt|;
comment|/* If we are honoring mergeinfo, then for each item in      NOTIFY_B->CHILDREN_WITH_MERGEINFO, we need to calculate what needs to be      merged, and then merge it.  Otherwise, we just merge what we were asked      to merge across the whole tree.  */
name|SVN_ERR
argument_list|(
name|populate_remaining_ranges
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|source
argument_list|,
name|ra_session
argument_list|,
name|merge_b
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Always start with a range which describes the most inclusive merge      possible, i.e. SOURCE->rev1:rev2. */
name|range
operator|.
name|start
operator|=
name|source
operator|->
name|loc1
operator|->
name|rev
expr_stmt|;
name|range
operator|.
name|end
operator|=
name|source
operator|->
name|loc2
operator|->
name|rev
expr_stmt|;
name|range
operator|.
name|inheritable
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|merge_b
operator|->
name|reintegrate_merge
condition|)
block|{
name|svn_revnum_t
name|new_range_start
decl_stmt|,
name|start_rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* The merge target TARGET_ABSPATH and/or its subtrees may not need all          of SOURCE->rev1:rev2 applied.  So examine          NOTIFY_B->CHILDREN_WITH_MERGEINFO to find the oldest starting          revision that actually needs to be merged (for reverse merges this is          the youngest starting revision).           We'll do this twice, right now for the start of the mergeinfo we will          ultimately record to describe this merge and then later for the          start of the actual editor drive. */
name|new_range_start
operator|=
name|get_most_inclusive_rev
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|is_rollback
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|new_range_start
argument_list|)
condition|)
name|range
operator|.
name|start
operator|=
name|new_range_start
expr_stmt|;
comment|/* Remove inoperative ranges from any subtrees' remaining_ranges          to spare the expense of noop editor drives. */
if|if
condition|(
operator|!
name|is_rollback
condition|)
name|SVN_ERR
argument_list|(
name|remove_noop_subtree_ranges
argument_list|(
name|source
argument_list|,
name|merge_b
operator|->
name|target
argument_list|,
name|ra_session
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust subtrees' remaining_ranges to deal with issue #3067:        * "subtrees that don't exist at the start or end of a merge range        * shouldn't break the merge". */
name|SVN_ERR
argument_list|(
name|fix_deleted_subtree_ranges
argument_list|(
name|source
argument_list|,
name|merge_b
operator|->
name|target
argument_list|,
name|ra_session
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|merge_b
operator|->
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove_noop_subtree_ranges() and/or fix_deleted_subtree_range()          may have further refined the starting revision for our editor          drive. */
name|start_rev
operator|=
name|get_most_inclusive_rev
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|is_rollback
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* Is there anything to merge? */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|start_rev
argument_list|)
condition|)
block|{
comment|/* Now examine NOTIFY_B->CHILDREN_WITH_MERGEINFO to find the oldest              ending revision that actually needs to be merged (for reverse              merges this is the youngest ending revision). */
name|svn_revnum_t
name|end_rev
init|=
name|get_most_inclusive_rev
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|is_rollback
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* While END_REV is valid, do the following:               1. Tweak each NOTIFY_B->CHILDREN_WITH_MERGEINFO element so that                 the element's remaining_ranges member has as its first element                 a range that ends with end_rev.               2. Starting with start_rev, call drive_merge_report_editor()                 on MERGE_B->target->abspath for start_rev:end_rev.               3. Remove the first element from each                 NOTIFY_B->CHILDREN_WITH_MERGEINFO element's remaining_ranges                 member.               4. Again examine NOTIFY_B->CHILDREN_WITH_MERGEINFO to find the most                 inclusive starting revision that actually needs to be merged and                 update start_rev.  This prevents us from needlessly contacting the                 repository and doing a diff where we describe the entire target                 tree as *not* needing any of the requested range.  This can happen                 whenever we have mergeinfo with gaps in it for the merge source.               5. Again examine NOTIFY_B->CHILDREN_WITH_MERGEINFO to find the most                 inclusive ending revision that actually needs to be merged and                 update end_rev.               6. Lather, rinse, repeat.           */
while|while
condition|(
name|end_rev
operator|!=
name|SVN_INVALID_REVNUM
condition|)
block|{
name|merge_source_t
modifier|*
name|real_source
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|first_target_range
init|=
operator|(
name|target_merge_path
operator|->
name|remaining_ranges
operator|->
name|nelts
operator|==
literal|0
condition|?
name|NULL
else|:
name|APR_ARRAY_IDX
argument_list|(
name|target_merge_path
operator|->
name|remaining_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|)
decl_stmt|;
comment|/* Issue #3324: Stop editor abuse!  Don't call                  drive_merge_report_editor() in such a way that we request an                  editor with svn_client__get_diff_editor() for some rev X,                  then call svn_ra_do_diff3() for some revision Y, and then                  call reporter->set_path(PATH=="") to set the root revision                  for the editor drive to revision Z where                  (X != Z&& X< Z< Y).  This is bogus because the server will                  send us the diff between X:Y but the client is expecting the                  diff between Y:Z.  See issue #3324 for full details on the                  problems this can cause. */
if|if
condition|(
name|first_target_range
operator|&&
name|start_rev
operator|!=
name|first_target_range
operator|->
name|start
condition|)
block|{
if|if
condition|(
name|is_rollback
condition|)
block|{
if|if
condition|(
name|end_rev
operator|<
name|first_target_range
operator|->
name|start
condition|)
name|end_rev
operator|=
name|first_target_range
operator|->
name|start
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|end_rev
operator|>
name|first_target_range
operator|->
name|start
condition|)
name|end_rev
operator|=
name|first_target_range
operator|->
name|start
expr_stmt|;
block|}
block|}
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|slice_remaining_ranges
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|is_rollback
argument_list|,
name|end_rev
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Reset variables that must be reset for every drive */
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
operator|=
name|NULL
expr_stmt|;
name|real_source
operator|=
name|subrange_source
argument_list|(
name|source
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|drive_merge_report_editor
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|real_source
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|processor
argument_list|,
name|depth
argument_list|,
name|merge_b
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If any paths picked up explicit mergeinfo as a result of                  the merge we need to make sure any mergeinfo those paths                  inherited is recorded and then add these paths to                  NOTIFY_B->CHILDREN_WITH_MERGEINFO.*/
name|SVN_ERR
argument_list|(
name|process_children_with_new_mergeinfo
argument_list|(
name|merge_b
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If any subtrees had their explicit mergeinfo deleted as a                  result of the merge then remove these paths from                  NOTIFY_B->CHILDREN_WITH_MERGEINFO since there is no need                  to consider these subtrees for subsequent editor drives                  nor do we want to record mergeinfo on them describing                  the merge itself. */
name|remove_children_with_deleted_mergeinfo
argument_list|(
name|merge_b
argument_list|,
name|children_with_mergeinfo
argument_list|)
expr_stmt|;
comment|/* Prepare for the next iteration (if any). */
name|remove_first_range_from_remaining_ranges
argument_list|(
name|end_rev
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* If we raised any conflicts, break out and report how much                  we have merged. */
if|if
condition|(
name|is_path_conflicted_by_merge
argument_list|(
name|merge_b
argument_list|)
condition|)
block|{
name|merge_source_t
modifier|*
name|remaining_range
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|real_source
operator|->
name|loc2
operator|->
name|rev
operator|!=
name|source
operator|->
name|loc2
operator|->
name|rev
condition|)
name|remaining_range
operator|=
name|subrange_source
argument_list|(
name|source
argument_list|,
name|real_source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|conflict_report
operator|=
name|single_range_conflict_report_create
argument_list|(
name|real_source
argument_list|,
name|remaining_range
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|range
operator|.
name|end
operator|=
name|end_rev
expr_stmt|;
break|break;
block|}
name|start_rev
operator|=
name|get_most_inclusive_rev
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|is_rollback
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|end_rev
operator|=
name|get_most_inclusive_rev
argument_list|(
name|children_with_mergeinfo
argument_list|,
name|is_rollback
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|merge_b
operator|->
name|record_only
condition|)
block|{
comment|/* Reset cur_ancestor_abspath to null so that subsequent cherry              picked revision ranges will be notified upon subsequent              operative merge. */
name|merge_b
operator|->
name|notify_begin
operator|.
name|last_abspath
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|drive_merge_report_editor
argument_list|(
name|merge_b
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|source
argument_list|,
name|NULL
argument_list|,
name|processor
argument_list|,
name|depth
argument_list|,
name|merge_b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Record mergeinfo where appropriate.*/
if|if
condition|(
name|RECORD_MERGEINFO
argument_list|(
name|merge_b
argument_list|)
condition|)
block|{
specifier|const
name|svn_client__pathrev_t
modifier|*
name|primary_src
init|=
name|is_rollback
condition|?
name|source
operator|->
name|loc1
else|:
name|source
operator|->
name|loc2
decl_stmt|;
specifier|const
name|char
modifier|*
name|mergeinfo_path
init|=
name|svn_client__pathrev_fspath
argument_list|(
name|primary_src
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|record_mergeinfo_for_dir_merge
argument_list|(
name|result_catalog
argument_list|,
operator|&
name|range
argument_list|,
name|mergeinfo_path
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|depth
argument_list|,
name|squelch_mergeinfo_notifications
argument_list|,
name|merge_b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If a path has an immediate parent with non-inheritable mergeinfo at          this point, then it meets criteria 3 or 5 described in          get_mergeinfo_paths' doc string.  For paths which exist prior to a          merge explicit mergeinfo has already been set.  But for paths added          during the merge this is not the case.  The path might have explicit          mergeinfo from the merge source, but no mergeinfo yet exists          describing *this* merge.  So the added path has either incomplete          explicit mergeinfo or inherits incomplete mergeinfo from its          immediate parent (if any, the parent might have only non-inheritable          ranges in which case the path simply inherits empty mergeinfo).           So here we look at the root path of each subtree added during the          merge and set explicit mergeinfo on it if it meets the aforementioned          conditions. */
if|if
condition|(
name|range
operator|.
name|start
operator|<
name|range
operator|.
name|end
condition|)
comment|/* Nothing to record on added subtrees                                       resulting from reverse merges. */
block|{
name|SVN_ERR
argument_list|(
name|record_mergeinfo_for_added_subtrees
argument_list|(
operator|&
name|range
argument_list|,
name|mergeinfo_path
argument_list|,
name|depth
argument_list|,
name|squelch_mergeinfo_notifications
argument_list|,
name|merge_b
operator|->
name|added_abspaths
argument_list|,
name|merge_b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for do_merge() when the merge target is a directory.  *  * If any conflict is raised during the merge, set *CONFLICTED_RANGE to  * the revision sub-range that raised the conflict.  In this case, the  * merge will have ended at revision CONFLICTED_RANGE and mergeinfo will  * have been recorded for all revision sub-ranges up to and including  * CONFLICTED_RANGE.  Otherwise, set *CONFLICTED_RANGE to NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_directory_merge
parameter_list|(
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|single_range_conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|squelch_mergeinfo_notifications
parameter_list|,
name|merge_cmd_baton_t
modifier|*
name|merge_b
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|children_with_mergeinfo
decl_stmt|;
comment|/* Initialize CHILDREN_WITH_MERGEINFO. See the comment      'THE CHILDREN_WITH_MERGEINFO ARRAY' at the start of this file. */
name|children_with_mergeinfo
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_client__merge_path_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* And make it read-only accessible from the baton */
name|merge_b
operator|->
name|notify_begin
operator|.
name|nodes_with_mergeinfo
operator|=
name|children_with_mergeinfo
expr_stmt|;
comment|/* If we are not honoring mergeinfo we can skip right to the      business of merging changes! */
if|if
condition|(
name|HONOR_MERGEINFO
argument_list|(
name|merge_b
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|do_mergeinfo_aware_dir_merge
argument_list|(
name|result_catalog
argument_list|,
name|conflict_report
argument_list|,
name|source
argument_list|,
name|target_abspath
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|processor
argument_list|,
name|depth
argument_list|,
name|squelch_mergeinfo_notifications
argument_list|,
name|merge_b
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|do_mergeinfo_unaware_dir_merge
argument_list|(
name|conflict_report
argument_list|,
name|source
argument_list|,
name|target_abspath
argument_list|,
name|children_with_mergeinfo
argument_list|,
name|processor
argument_list|,
name|depth
argument_list|,
name|merge_b
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|merge_b
operator|->
name|notify_begin
operator|.
name|nodes_with_mergeinfo
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Ensure that *RA_SESSION is opened to URL, either by reusing  * *RA_SESSION if it is non-null and already opened to URL's  * repository, or by allocating a new *RA_SESSION in POOL.  * (RA_SESSION itself cannot be null, of course.)  *  * CTX is used as for svn_client_open_ra_session().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_ra_session_url
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
name|wri_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
if|if
condition|(
operator|*
name|ra_session
condition|)
block|{
name|err
operator|=
name|svn_ra_reparent
argument_list|(
operator|*
name|ra_session
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* SVN_ERR_RA_ILLEGAL_URL is raised when url doesn't point to the same      repository as ra_session. */
if|if
condition|(
operator|!
operator|*
name|ra_session
operator|||
operator|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_ILLEGAL_URL
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client_open_ra_session2
argument_list|(
name|ra_session
argument_list|,
name|url
argument_list|,
name|wri_abspath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Drive a merge of MERGE_SOURCES into working copy node TARGET    and possibly record mergeinfo describing the merge -- see    RECORD_MERGEINFO().     If MODIFIED_SUBTREES is not NULL and all the MERGE_SOURCES are 'ancestral'    or REINTEGRATE_MERGE is true, then replace *MODIFIED_SUBTREES with a new    hash containing all the paths that *MODIFIED_SUBTREES contained before,    and also every path modified, skipped, added, or tree-conflicted    by the merge.  Keys and values of the hash are both (const char *)    absolute paths.  The contents of the hash are allocated in RESULT_POOL.     If the merge raises any conflicts while merging a revision range, return    early and set *CONFLICT_REPORT to describe the details.  (In this case,    notify that the merge is complete if and only if this was the last    revision range of the merge.)  If there are no conflicts, set    *CONFLICT_REPORT to NULL.  A revision range here can be one specified    in MERGE_SOURCES or an internally generated sub-range of one of those    when merge tracking is in use.     For every (const merge_source_t *) merge source in MERGE_SOURCES, if    SOURCE->ANCESTRAL is set, then the "left" and "right" side are    ancestrally related.  (See 'MERGEINFO MERGE SOURCE NORMALIZATION'    for more on what that means and how it matters.)     If SOURCES_RELATED is set, the "left" and "right" sides of the    merge source are historically related (ancestors, uncles, second    cousins thrice removed, etc...).  (This is passed through to    do_file_merge() to simulate the history checks that the repository    logic does in the directory case.)     SAME_REPOS is TRUE iff the merge sources live in the same    repository as the one from which the target working copy has been    checked out.     If mergeinfo is being recorded, SQUELCH_MERGEINFO_NOTIFICATIONS is FALSE,    and CTX->NOTIFY_FUNC2 is not NULL, then call CTX->NOTIFY_FUNC2 with    CTX->NOTIFY_BATON2 and a svn_wc_notify_merge_record_info_begin    notification before any mergeinfo changes are made to describe the merge    performed.     If mergeinfo is being recorded to describe this merge, and RESULT_CATALOG    is not NULL, then don't record the new mergeinfo on the WC, but instead    record it in RESULT_CATALOG, where the keys are absolute working copy    paths and the values are the new mergeinfos for each.  Allocate additions    to RESULT_CATALOG in pool which RESULT_CATALOG was created in.     FORCE_DELETE, DRY_RUN, RECORD_ONLY, DEPTH, MERGE_OPTIONS,    and CTX are as described in the docstring for svn_client_merge_peg3().     If IGNORE_MERGEINFO is true, disable merge tracking, by treating the two    sources as unrelated even if they actually have a common ancestor.  See    the macro HONOR_MERGEINFO().     If DIFF_IGNORE_ANCESTRY is true, diff the 'left' and 'right' versions    of a node (if they are the same kind) as if they were related, even if    they are not related.  Otherwise, diff unrelated items as a deletion    of one thing and the addition of another.     If not NULL, RECORD_ONLY_PATHS is a hash of (const char *) paths mapped    to the same.  If RECORD_ONLY is true and RECORD_ONLY_PATHS is not NULL,    then record mergeinfo describing the merge only on subtrees which contain    items from RECORD_ONLY_PATHS.  If RECORD_ONLY is true and RECORD_ONLY_PATHS    is NULL, then record mergeinfo on every subtree with mergeinfo in    TARGET.     REINTEGRATE_MERGE is TRUE if this is a reintegrate merge.     *USE_SLEEP will be set TRUE if a sleep is required to ensure timestamp    integrity, *USE_SLEEP will be unchanged if no sleep is required.     SCRATCH_POOL is used for all temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_merge
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|modified_subtrees
parameter_list|,
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
name|svn_boolean_t
modifier|*
name|use_sleep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_sources
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|svn_ra_session_t
modifier|*
name|src_session
parameter_list|,
name|svn_boolean_t
name|sources_related
parameter_list|,
name|svn_boolean_t
name|same_repos
parameter_list|,
name|svn_boolean_t
name|ignore_mergeinfo
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|apr_hash_t
modifier|*
name|record_only_paths
parameter_list|,
name|svn_boolean_t
name|reintegrate_merge
parameter_list|,
name|svn_boolean_t
name|squelch_mergeinfo_notifications
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_cmd_baton_t
name|merge_cmd_baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
specifier|const
name|char
modifier|*
name|diff3_cmd
decl_stmt|;
specifier|const
name|char
modifier|*
name|preserved_exts_str
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|checked_mergeinfo_capability
init|=
name|FALSE
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session1
init|=
name|NULL
decl_stmt|,
modifier|*
name|ra_session2
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_src_session_url
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|svn_diff_tree_processor_t
modifier|*
name|processor
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target
operator|->
name|abspath
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|conflict_report
operator|=
name|NULL
expr_stmt|;
comment|/* Check from some special conditions when in record-only mode      (which is a merge-tracking thing). */
if|if
condition|(
name|record_only
condition|)
block|{
name|svn_boolean_t
name|sources_ancestral
init|=
name|TRUE
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Find out whether all of the sources are 'ancestral'. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|merge_sources
operator|->
name|nelts
condition|;
name|j
operator|++
control|)
if|if
condition|(
operator|!
name|APR_ARRAY_IDX
argument_list|(
name|merge_sources
argument_list|,
name|j
argument_list|,
name|merge_source_t
operator|*
argument_list|)
operator|->
name|ancestral
condition|)
block|{
name|sources_ancestral
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* We can't do a record-only merge if the sources aren't related. */
if|if
condition|(
operator|!
name|sources_ancestral
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Use of two URLs is not compatible with "
literal|"mergeinfo modification"
argument_list|)
argument_list|)
return|;
comment|/* We can't do a record-only merge if the sources aren't from          the same repository as the target. */
if|if
condition|(
operator|!
name|same_repos
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Merge from foreign repository is not "
literal|"compatible with mergeinfo modification"
argument_list|)
argument_list|)
return|;
comment|/* If this is a dry-run record-only merge, there's nothing to do. */
if|if
condition|(
name|dry_run
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Ensure a known depth. */
if|if
condition|(
name|depth
operator|==
name|svn_depth_unknown
condition|)
name|depth
operator|=
name|svn_depth_infinity
expr_stmt|;
comment|/* Set up the diff3 command, so various callers don't have to. */
name|cfg
operator|=
name|ctx
operator|->
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|ctx
operator|->
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|diff3_cmd
argument_list|,
name|SVN_CONFIG_SECTION_HELPERS
argument_list|,
name|SVN_CONFIG_OPTION_DIFF3_CMD
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff3_cmd
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_path_cstring_to_utf8
argument_list|(
operator|&
name|diff3_cmd
argument_list|,
name|diff3_cmd
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* See which files the user wants to preserve the extension of when      conflict files are made. */
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|preserved_exts_str
argument_list|,
name|SVN_CONFIG_SECTION_MISCELLANY
argument_list|,
name|SVN_CONFIG_OPTION_PRESERVED_CF_EXTS
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* Build the merge context baton (or at least the parts of it that      don't need to be reset for each merge source).  */
name|merge_cmd_baton
operator|.
name|force_delete
operator|=
name|force_delete
expr_stmt|;
name|merge_cmd_baton
operator|.
name|dry_run
operator|=
name|dry_run
expr_stmt|;
name|merge_cmd_baton
operator|.
name|record_only
operator|=
name|record_only
expr_stmt|;
name|merge_cmd_baton
operator|.
name|ignore_mergeinfo
operator|=
name|ignore_mergeinfo
expr_stmt|;
name|merge_cmd_baton
operator|.
name|diff_ignore_ancestry
operator|=
name|diff_ignore_ancestry
expr_stmt|;
name|merge_cmd_baton
operator|.
name|same_repos
operator|=
name|same_repos
expr_stmt|;
name|merge_cmd_baton
operator|.
name|mergeinfo_capable
operator|=
name|FALSE
expr_stmt|;
name|merge_cmd_baton
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
name|merge_cmd_baton
operator|.
name|reintegrate_merge
operator|=
name|reintegrate_merge
expr_stmt|;
name|merge_cmd_baton
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|merge_cmd_baton
operator|.
name|pool
operator|=
name|iterpool
expr_stmt|;
name|merge_cmd_baton
operator|.
name|merge_options
operator|=
name|merge_options
expr_stmt|;
name|merge_cmd_baton
operator|.
name|diff3_cmd
operator|=
name|diff3_cmd
expr_stmt|;
name|merge_cmd_baton
operator|.
name|ext_patterns
operator|=
operator|*
name|preserved_exts_str
condition|?
name|svn_cstring_split
argument_list|(
name|preserved_exts_str
argument_list|,
literal|"\n\r\t\v "
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|merge_cmd_baton
operator|.
name|use_sleep
operator|=
name|use_sleep
expr_stmt|;
comment|/* Do we already know the specific subtrees with mergeinfo we want      to record-only mergeinfo on? */
if|if
condition|(
name|record_only
operator|&&
name|record_only_paths
condition|)
name|merge_cmd_baton
operator|.
name|merged_abspaths
operator|=
name|record_only_paths
expr_stmt|;
else|else
name|merge_cmd_baton
operator|.
name|merged_abspaths
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|merge_cmd_baton
operator|.
name|skipped_abspaths
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|merge_cmd_baton
operator|.
name|added_abspaths
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|merge_cmd_baton
operator|.
name|tree_conflicted_abspaths
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|{
name|svn_diff_tree_processor_t
modifier|*
name|merge_processor
decl_stmt|;
name|merge_processor
operator|=
name|svn_diff__tree_processor_create
argument_list|(
operator|&
name|merge_cmd_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|merge_processor
operator|->
name|dir_opened
operator|=
name|merge_dir_opened
expr_stmt|;
name|merge_processor
operator|->
name|dir_changed
operator|=
name|merge_dir_changed
expr_stmt|;
name|merge_processor
operator|->
name|dir_added
operator|=
name|merge_dir_added
expr_stmt|;
name|merge_processor
operator|->
name|dir_deleted
operator|=
name|merge_dir_deleted
expr_stmt|;
name|merge_processor
operator|->
name|dir_closed
operator|=
name|merge_dir_closed
expr_stmt|;
name|merge_processor
operator|->
name|file_opened
operator|=
name|merge_file_opened
expr_stmt|;
name|merge_processor
operator|->
name|file_changed
operator|=
name|merge_file_changed
expr_stmt|;
name|merge_processor
operator|->
name|file_added
operator|=
name|merge_file_added
expr_stmt|;
name|merge_processor
operator|->
name|file_deleted
operator|=
name|merge_file_deleted
expr_stmt|;
comment|/* Not interested in file_closed() */
name|merge_processor
operator|->
name|node_absent
operator|=
name|merge_node_absent
expr_stmt|;
name|processor
operator|=
name|merge_processor
expr_stmt|;
block|}
if|if
condition|(
name|src_session
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|src_session
argument_list|,
operator|&
name|old_src_session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ra_session1
operator|=
name|src_session
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|merge_sources
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_node_kind_t
name|src1_kind
decl_stmt|;
name|merge_source_t
modifier|*
name|source
init|=
name|APR_ARRAY_IDX
argument_list|(
name|merge_sources
argument_list|,
name|i
argument_list|,
name|merge_source_t
operator|*
argument_list|)
decl_stmt|;
name|single_range_conflict_report_t
modifier|*
name|conflicted_range_report
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Sanity check:  if our left- and right-side merge sources are          the same, there's nothing to here. */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|url
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|url
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|source
operator|->
name|loc1
operator|->
name|rev
operator|==
name|source
operator|->
name|loc2
operator|->
name|rev
operator|)
condition|)
continue|continue;
comment|/* Establish RA sessions to our URLs, reuse where possible. */
name|SVN_ERR
argument_list|(
name|ensure_ra_session_url
argument_list|(
operator|&
name|ra_session1
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|url
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_ra_session_url
argument_list|(
operator|&
name|ra_session2
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|url
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate the portions of the merge context baton that need to          be reset for each merge source iteration. */
name|merge_cmd_baton
operator|.
name|merge_source
operator|=
operator|*
name|source
expr_stmt|;
name|merge_cmd_baton
operator|.
name|implicit_src_gap
operator|=
name|NULL
expr_stmt|;
name|merge_cmd_baton
operator|.
name|conflicted_paths
operator|=
name|NULL
expr_stmt|;
name|merge_cmd_baton
operator|.
name|paths_with_new_mergeinfo
operator|=
name|NULL
expr_stmt|;
name|merge_cmd_baton
operator|.
name|paths_with_deleted_mergeinfo
operator|=
name|NULL
expr_stmt|;
name|merge_cmd_baton
operator|.
name|ra_session1
operator|=
name|ra_session1
expr_stmt|;
name|merge_cmd_baton
operator|.
name|ra_session2
operator|=
name|ra_session2
expr_stmt|;
name|merge_cmd_baton
operator|.
name|notify_begin
operator|.
name|last_abspath
operator|=
name|NULL
expr_stmt|;
comment|/* Populate the portions of the merge context baton that require          an RA session to set, but shouldn't be reset for each iteration. */
if|if
condition|(
operator|!
name|checked_mergeinfo_capability
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_has_capability
argument_list|(
name|ra_session1
argument_list|,
operator|&
name|merge_cmd_baton
operator|.
name|mergeinfo_capable
argument_list|,
name|SVN_RA_CAPABILITY_MERGEINFO
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|checked_mergeinfo_capability
operator|=
name|TRUE
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|ra_session1
argument_list|,
literal|""
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
operator|&
name|src1_kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Run the merge; if there are conflicts, allow the callback to        * resolve them, and if it resolves all of them, then run the        * merge again with the remaining revision range, until it is all        * done. */
do|do
block|{
comment|/* Merge as far as possible without resolving any conflicts */
if|if
condition|(
name|src1_kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|do_file_merge
argument_list|(
name|result_catalog
argument_list|,
operator|&
name|conflicted_range_report
argument_list|,
name|source
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|processor
argument_list|,
name|sources_related
argument_list|,
name|squelch_mergeinfo_notifications
argument_list|,
operator|&
name|merge_cmd_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Directory */
block|{
name|SVN_ERR
argument_list|(
name|do_directory_merge
argument_list|(
name|result_catalog
argument_list|,
operator|&
name|conflicted_range_report
argument_list|,
name|source
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|processor
argument_list|,
name|depth
argument_list|,
name|squelch_mergeinfo_notifications
argument_list|,
operator|&
name|merge_cmd_baton
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Give the conflict resolver callback the opportunity to            * resolve any conflicts that were raised.  If it resolves all            * of them, go around again to merge the next sub-range (if any). */
if|if
condition|(
name|conflicted_range_report
operator|&&
name|ctx
operator|->
name|conflict_func2
operator|&&
operator|!
name|dry_run
condition|)
block|{
name|svn_boolean_t
name|conflicts_remain
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__resolve_conflicts
argument_list|(
operator|&
name|conflicts_remain
argument_list|,
name|merge_cmd_baton
operator|.
name|conflicted_paths
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflicts_remain
condition|)
break|break;
name|merge_cmd_baton
operator|.
name|conflicted_paths
operator|=
name|NULL
expr_stmt|;
comment|/* Caution: this source is in iterpool */
name|source
operator|=
name|conflicted_range_report
operator|->
name|remaining_source
expr_stmt|;
name|conflicted_range_report
operator|=
name|NULL
expr_stmt|;
block|}
else|else
break|break;
block|}
do|while
condition|(
name|source
condition|)
do|;
comment|/* The final mergeinfo on TARGET_WCPATH may itself elide. */
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__elide_mergeinfo
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If conflicts occurred while merging any but the very last        * range of a multi-pass merge, we raise an error that aborts        * the merge. The user will be asked to resolve conflicts        * before merging subsequent revision ranges. */
if|if
condition|(
name|conflicted_range_report
condition|)
block|{
operator|*
name|conflict_report
operator|=
name|conflict_report_create
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|conflicted_range_report
operator|->
name|conflicted_range
argument_list|,
operator|(
name|i
operator|==
name|merge_sources
operator|->
name|nelts
operator|-
literal|1
operator|&&
operator|!
name|conflicted_range_report
operator|->
name|remaining_source
operator|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|conflict_report
operator|||
operator|(
operator|*
name|conflict_report
operator|)
operator|->
name|was_last_range
condition|)
block|{
comment|/* Let everyone know we're finished here. */
name|notify_merge_completed
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Does the caller want to know what the merge has done? */
if|if
condition|(
name|modified_subtrees
condition|)
block|{
operator|*
name|modified_subtrees
operator|=
name|apr_hash_overlay
argument_list|(
name|result_pool
argument_list|,
operator|*
name|modified_subtrees
argument_list|,
name|merge_cmd_baton
operator|.
name|merged_abspaths
argument_list|)
expr_stmt|;
operator|*
name|modified_subtrees
operator|=
name|apr_hash_overlay
argument_list|(
name|result_pool
argument_list|,
operator|*
name|modified_subtrees
argument_list|,
name|merge_cmd_baton
operator|.
name|added_abspaths
argument_list|)
expr_stmt|;
operator|*
name|modified_subtrees
operator|=
name|apr_hash_overlay
argument_list|(
name|result_pool
argument_list|,
operator|*
name|modified_subtrees
argument_list|,
name|merge_cmd_baton
operator|.
name|skipped_abspaths
argument_list|)
expr_stmt|;
operator|*
name|modified_subtrees
operator|=
name|apr_hash_overlay
argument_list|(
name|result_pool
argument_list|,
operator|*
name|modified_subtrees
argument_list|,
name|merge_cmd_baton
operator|.
name|tree_conflicted_abspaths
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|src_session
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|src_session
argument_list|,
name|old_src_session_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform a two-URL merge between URLs which are related, but neither    is a direct ancestor of the other.  This first does a real two-URL    merge (unless this is record-only), followed by record-only merges    to represent the changed mergeinfo.     Set *CONFLICT_REPORT to indicate if there were any conflicts, as in    do_merge().     The diff to be merged is between SOURCE->loc1 (in URL1_RA_SESSION1)    and SOURCE->loc2 (in URL2_RA_SESSION2); YCA is their youngest    common ancestor.     SAME_REPOS must be true if and only if the source URLs are in the same    repository as the target working copy.     DIFF_IGNORE_ANCESTRY is as in do_merge().     Other arguments are as in all of the public merge APIs.     *USE_SLEEP will be set TRUE if a sleep is required to ensure timestamp    integrity, *USE_SLEEP will be unchanged if no sleep is required.     SCRATCH_POOL is used for all temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_cousins_and_supplement_mergeinfo
parameter_list|(
name|conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
name|svn_boolean_t
modifier|*
name|use_sleep
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|svn_ra_session_t
modifier|*
name|URL1_ra_session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|URL2_ra_session
parameter_list|,
specifier|const
name|merge_source_t
modifier|*
name|source
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|yca
parameter_list|,
name|svn_boolean_t
name|same_repos
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|remove_sources
decl_stmt|,
modifier|*
name|add_sources
decl_stmt|;
name|apr_hash_t
modifier|*
name|modified_subtrees
init|=
name|NULL
decl_stmt|;
comment|/* Sure we could use SCRATCH_POOL throughout this function, but since this      is a wrapper around three separate merges we'll create a subpool we can      clear between each of the three.  If the merge target has a lot of      subtree mergeinfo, then this will help keep memory use in check. */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|URL1_ra_session
argument_list|,
name|source
operator|->
name|loc1
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|URL2_ra_session
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target
operator|->
name|abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|source
operator|->
name|ancestral
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|normalize_merge_sources_internal
argument_list|(
operator|&
name|remove_sources
argument_list|,
name|source
operator|->
name|loc1
argument_list|,
name|svn_rangelist__initialize
argument_list|(
name|source
operator|->
name|loc1
operator|->
name|rev
argument_list|,
name|yca
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|URL1_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|normalize_merge_sources_internal
argument_list|(
operator|&
name|add_sources
argument_list|,
name|source
operator|->
name|loc2
argument_list|,
name|svn_rangelist__initialize
argument_list|(
name|yca
operator|->
name|rev
argument_list|,
name|source
operator|->
name|loc2
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|URL2_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|conflict_report
operator|=
name|NULL
expr_stmt|;
comment|/* If this isn't a record-only merge, we'll first do a stupid      point-to-point merge... */
if|if
condition|(
operator|!
name|record_only
condition|)
block|{
name|apr_array_header_t
modifier|*
name|faux_sources
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|merge_source_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|modified_subtrees
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|faux_sources
argument_list|,
specifier|const
name|merge_source_t
operator|*
argument_list|)
operator|=
name|source
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_merge
argument_list|(
operator|&
name|modified_subtrees
argument_list|,
name|NULL
argument_list|,
name|conflict_report
argument_list|,
name|use_sleep
argument_list|,
name|faux_sources
argument_list|,
name|target
argument_list|,
name|URL1_ra_session
argument_list|,
name|TRUE
argument_list|,
name|same_repos
argument_list|,
name|FALSE
comment|/*ignore_mergeinfo*/
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|dry_run
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|depth
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|conflict_report
condition|)
block|{
operator|*
name|conflict_report
operator|=
name|conflict_report_dup
argument_list|(
operator|*
name|conflict_report
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|conflict_report
operator|)
operator|->
name|was_last_range
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|same_repos
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Merge from foreign repository is not "
literal|"compatible with mergeinfo modification"
argument_list|)
argument_list|)
return|;
block|}
comment|/* ... and now, if we're doing the mergeinfo thang, we execute a      pair of record-only merges using the real sources we've      calculated.       Issue #3648: We don't actually perform these two record-only merges      on the WC at first, but rather see what each would do and store that      in two mergeinfo catalogs.  We then merge the catalogs together and      then record the result in the WC.  This prevents the second record      only merge from removing legitimate mergeinfo history, from the same      source, that was made in prior merges. */
if|if
condition|(
name|same_repos
operator|&&
operator|!
name|dry_run
condition|)
block|{
name|svn_mergeinfo_catalog_t
name|add_result_catalog
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|remove_result_catalog
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|notify_mergeinfo_recording
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|NULL
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_merge
argument_list|(
name|NULL
argument_list|,
name|add_result_catalog
argument_list|,
name|conflict_report
argument_list|,
name|use_sleep
argument_list|,
name|add_sources
argument_list|,
name|target
argument_list|,
name|URL1_ra_session
argument_list|,
name|TRUE
argument_list|,
name|same_repos
argument_list|,
name|FALSE
comment|/*ignore_mergeinfo*/
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|dry_run
argument_list|,
name|TRUE
argument_list|,
name|modified_subtrees
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|depth
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|conflict_report
condition|)
block|{
operator|*
name|conflict_report
operator|=
name|conflict_report_dup
argument_list|(
operator|*
name|conflict_report
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|conflict_report
operator|)
operator|->
name|was_last_range
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_merge
argument_list|(
name|NULL
argument_list|,
name|remove_result_catalog
argument_list|,
name|conflict_report
argument_list|,
name|use_sleep
argument_list|,
name|remove_sources
argument_list|,
name|target
argument_list|,
name|URL1_ra_session
argument_list|,
name|TRUE
argument_list|,
name|same_repos
argument_list|,
name|FALSE
comment|/*ignore_mergeinfo*/
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|dry_run
argument_list|,
name|TRUE
argument_list|,
name|modified_subtrees
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|depth
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|conflict_report
condition|)
block|{
operator|*
name|conflict_report
operator|=
name|conflict_report_dup
argument_list|(
operator|*
name|conflict_report
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|*
name|conflict_report
operator|)
operator|->
name|was_last_range
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_catalog_merge
argument_list|(
name|add_result_catalog
argument_list|,
name|remove_result_catalog
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__record_wc_mergeinfo_catalog
argument_list|(
name|add_result_catalog
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform checks to determine whether the working copy at TARGET_ABSPATH  * can safely be used as a merge target. Checks are performed according to  * the ALLOW_MIXED_REV, ALLOW_LOCAL_MODS, and ALLOW_SWITCHED_SUBTREES  * parameters. If any checks fail, raise SVN_ERR_CLIENT_NOT_READY_TO_MERGE.  *  * E.g. if all the ALLOW_* parameters are FALSE, TARGET_ABSPATH must  * be a single-revision, pristine, unswitched working copy.  * In other words, it must reflect a subtree of the repository as found  * at single revision -- although sparse checkouts are permitted. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_wc_is_suitable_merge_target
parameter_list|(
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
name|svn_boolean_t
name|allow_local_mods
parameter_list|,
name|svn_boolean_t
name|allow_switched_subtrees
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|target_kind
decl_stmt|;
comment|/* Check the target exists. */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|target_abspath
argument_list|,
operator|&
name|target_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_WC_PATH_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' does not exist"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|target_kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_kind
operator|!=
name|svn_node_dir
operator|&&
name|target_kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Merge target '%s' does not exist in the "
literal|"working copy"
argument_list|)
argument_list|,
name|target_abspath
argument_list|)
return|;
comment|/* Perform the mixed-revision check first because it's the cheapest one. */
if|if
condition|(
operator|!
name|allow_mixed_rev
condition|)
block|{
name|svn_revnum_t
name|min_rev
decl_stmt|;
name|svn_revnum_t
name|max_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_min_max_revisions
argument_list|(
operator|&
name|min_rev
argument_list|,
operator|&
name|max_rev
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|min_rev
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|max_rev
argument_list|)
operator|)
condition|)
block|{
name|svn_boolean_t
name|is_added
decl_stmt|;
comment|/* Allow merge into added nodes. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_is_added
argument_list|(
operator|&
name|is_added
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_added
condition|)
return|return
name|SVN_NO_ERROR
return|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot determine revision of working "
literal|"copy"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|min_rev
operator|!=
name|max_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_MERGE_UPDATE_REQUIRED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot merge into mixed-revision working "
literal|"copy [%ld:%ld]; try updating first"
argument_list|)
argument_list|,
name|min_rev
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
comment|/* Next, check for switched subtrees. */
if|if
condition|(
operator|!
name|allow_switched_subtrees
condition|)
block|{
name|svn_boolean_t
name|is_switched
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__has_switched_subtrees
argument_list|(
operator|&
name|is_switched
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_switched
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot merge into a working copy "
literal|"with a switched subtree"
argument_list|)
argument_list|)
return|;
block|}
comment|/* This is the most expensive check, so it is performed last.*/
if|if
condition|(
operator|!
name|allow_local_mods
condition|)
block|{
name|svn_boolean_t
name|is_modified
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc__has_local_mods
argument_list|(
operator|&
name|is_modified
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|target_abspath
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_modified
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot merge into a working copy "
literal|"that has local modifications"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Throw an error if PATH_OR_URL is a path and REVISION isn't a repository  * revision. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ensure_wc_path_has_repo_revision
parameter_list|(
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_number
operator|&&
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_date
operator|&&
name|revision
operator|->
name|kind
operator|!=
name|svn_opt_revision_head
operator|&&
operator|!
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid merge source '%s'; a working copy path can only be "
literal|"used with a repository revision (a number, a date, or head)"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* "Open" the target WC for a merge.  That means:  *   - find out its exact repository location  *   - check the WC for suitability (throw an error if unsuitable)  *  * Set *TARGET_P to a new, fully initialized, target description structure.  *  * ALLOW_MIXED_REV, ALLOW_LOCAL_MODS, ALLOW_SWITCHED_SUBTREES determine  * whether the WC is deemed suitable; see ensure_wc_is_suitable_merge_target()  * for details.  *  * If the node is locally added, the rev and URL will be null/invalid. Some  * kinds of merge can use such a target; others can't.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_target_wc
parameter_list|(
name|merge_target_t
modifier|*
modifier|*
name|target_p
parameter_list|,
specifier|const
name|char
modifier|*
name|wc_abspath
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
name|svn_boolean_t
name|allow_local_mods
parameter_list|,
name|svn_boolean_t
name|allow_switched_subtrees
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_target_t
modifier|*
name|target
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target
argument_list|)
argument_list|)
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|origin
decl_stmt|;
name|target
operator|->
name|abspath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|wc_abspath
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__wc_node_get_origin
argument_list|(
operator|&
name|origin
argument_list|,
name|wc_abspath
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
condition|)
block|{
name|target
operator|->
name|loc
operator|=
operator|*
name|origin
expr_stmt|;
block|}
else|else
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* The node has no location in the repository. It's unversioned or        * locally added or locally deleted.        *        * If it's locally added or deleted, find the repository root        * URL and UUID anyway, and leave the node URL and revision as NULL        * and INVALID.  If it's unversioned, this will throw an error. */
name|err
operator|=
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|target
operator|->
name|loc
operator|.
name|repos_root_url
argument_list|,
operator|&
name|target
operator|->
name|loc
operator|.
name|repos_uuid
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|wc_abspath
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_PATH_NOT_FOUND
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_NOT_WORKING_COPY
operator|&&
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_WC_UPGRADE_REQUIRED
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Merge target '%s' does not exist in the "
literal|"working copy"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|wc_abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
name|target
operator|->
name|loc
operator|.
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|target
operator|->
name|loc
operator|.
name|url
operator|=
name|NULL
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|ensure_wc_is_suitable_merge_target
argument_list|(
name|wc_abspath
argument_list|,
name|ctx
argument_list|,
name|allow_mixed_rev
argument_list|,
name|allow_local_mods
argument_list|,
name|allow_switched_subtrees
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|target_p
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/*-----------------------------------------------------------------------*/
end_comment

begin_escape
end_escape

begin_comment
comment|/*** Public APIs ***/
end_comment

begin_comment
comment|/* The body of svn_client_merge5(), which see for details.  *  * If SOURCE1 @ REVISION1 is related to SOURCE2 @ REVISION2 then use merge  * tracking (subject to other constraints -- see HONOR_MERGEINFO());  * otherwise disable merge tracking.  *  * IGNORE_MERGEINFO and DIFF_IGNORE_ANCESTRY are as in do_merge().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_locked
parameter_list|(
name|conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|char
modifier|*
name|source1
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision1
parameter_list|,
specifier|const
name|char
modifier|*
name|source2
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision2
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_mergeinfo
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_target_t
modifier|*
name|target
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|source1_loc
decl_stmt|,
modifier|*
name|source2_loc
decl_stmt|;
name|svn_boolean_t
name|sources_related
init|=
name|FALSE
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session1
decl_stmt|,
modifier|*
name|ra_session2
decl_stmt|;
name|apr_array_header_t
modifier|*
name|merge_sources
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|use_sleep
init|=
name|FALSE
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|yca
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|sesspool
decl_stmt|;
name|svn_boolean_t
name|same_repos
decl_stmt|;
comment|/* ### FIXME: This function really ought to do a history check on      the left and right sides of the merge source, and -- if one is an      ancestor of the other -- just call svn_client_merge_peg3() with      the appropriate args. */
name|SVN_ERR
argument_list|(
name|open_target_wc
argument_list|(
operator|&
name|target
argument_list|,
name|target_abspath
argument_list|,
name|allow_mixed_rev
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open RA sessions to both sides of our merge source, and resolve URLs    * and revisions. */
name|sesspool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session1
argument_list|,
operator|&
name|source1_loc
argument_list|,
name|source1
argument_list|,
name|NULL
argument_list|,
name|revision1
argument_list|,
name|revision1
argument_list|,
name|ctx
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session2
argument_list|,
operator|&
name|source2_loc
argument_list|,
name|source2
argument_list|,
name|NULL
argument_list|,
name|revision2
argument_list|,
name|revision2
argument_list|,
name|ctx
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't do a diff between different repositories. */
comment|/* ### We should also insist that the root URLs of the two sources match,    *     as we are only carrying around a single source-repos-root from now    *     on, and URL calculations will go wrong if they differ.    *     Alternatively, teach the code to cope with differing root URLs. */
name|SVN_ERR
argument_list|(
name|check_same_repos
argument_list|(
name|source1_loc
argument_list|,
name|source1_loc
operator|->
name|url
argument_list|,
name|source2_loc
argument_list|,
name|source2_loc
operator|->
name|url
argument_list|,
name|FALSE
comment|/* strict_urls */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do our working copy and sources come from the same repository? */
name|same_repos
operator|=
name|is_same_repos
argument_list|(
operator|&
name|target
operator|->
name|loc
argument_list|,
name|source1_loc
argument_list|,
name|TRUE
comment|/* strict_urls */
argument_list|)
expr_stmt|;
comment|/* Unless we're ignoring ancestry, see if the two sources are related.  */
if|if
condition|(
operator|!
name|ignore_mergeinfo
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__get_youngest_common_ancestor
argument_list|(
operator|&
name|yca
argument_list|,
name|source1_loc
argument_list|,
name|source2_loc
argument_list|,
name|ra_session1
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for a youngest common ancestor.  If we have one, we'll be      doing merge tracking.       So, given a requested merge of the differences between A and      B, and a common ancestor of C, we will find ourselves in one of      four positions, and four different approaches:          A == B == C   there's nothing to merge          A == C != B   we merge the changes between A (or C) and B          B == C != A   we merge the changes between B (or C) and A          A != B != C   we merge the changes between A and B without                       merge recording, then record-only two merges:                       from A to C, and from C to B   */
if|if
condition|(
name|yca
condition|)
block|{
comment|/* Note that our merge sources are related. */
name|sources_related
operator|=
name|TRUE
expr_stmt|;
comment|/* If the common ancestor matches the right side of our merge,          then we only need to reverse-merge the left side. */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|yca
operator|->
name|url
argument_list|,
name|source2_loc
operator|->
name|url
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|yca
operator|->
name|rev
operator|==
name|source2_loc
operator|->
name|rev
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|normalize_merge_sources_internal
argument_list|(
operator|&
name|merge_sources
argument_list|,
name|source1_loc
argument_list|,
name|svn_rangelist__initialize
argument_list|(
name|source1_loc
operator|->
name|rev
argument_list|,
name|yca
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ra_session1
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the common ancestor matches the left side of our merge,          then we only need to merge the right side. */
elseif|else
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|yca
operator|->
name|url
argument_list|,
name|source1_loc
operator|->
name|url
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|yca
operator|->
name|rev
operator|==
name|source1_loc
operator|->
name|rev
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|normalize_merge_sources_internal
argument_list|(
operator|&
name|merge_sources
argument_list|,
name|source2_loc
argument_list|,
name|svn_rangelist__initialize
argument_list|(
name|yca
operator|->
name|rev
argument_list|,
name|source2_loc
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ra_session2
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* And otherwise, we need to do both: reverse merge the left          side, and merge the right. */
else|else
block|{
name|merge_source_t
name|source
decl_stmt|;
name|source
operator|.
name|loc1
operator|=
name|source1_loc
expr_stmt|;
name|source
operator|.
name|loc2
operator|=
name|source2_loc
expr_stmt|;
name|source
operator|.
name|ancestral
operator|=
name|FALSE
expr_stmt|;
name|err
operator|=
name|merge_cousins_and_supplement_mergeinfo
argument_list|(
name|conflict_report
argument_list|,
operator|&
name|use_sleep
argument_list|,
name|target
argument_list|,
name|ra_session1
argument_list|,
name|ra_session2
argument_list|,
operator|&
name|source
argument_list|,
name|yca
argument_list|,
name|same_repos
argument_list|,
name|depth
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Close our temporary RA sessions (this could've happened              after the second call to normalize_merge_sources() inside              the merge_cousins_and_supplement_mergeinfo() routine). */
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sleep
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
else|else
block|{
comment|/* Build a single-item merge_source_t array. */
name|merge_sources
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|merge_source_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|merge_sources
argument_list|,
name|merge_source_t
operator|*
argument_list|)
operator|=
name|merge_source_create
argument_list|(
name|source1_loc
argument_list|,
name|source2_loc
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|do_merge
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|conflict_report
argument_list|,
operator|&
name|use_sleep
argument_list|,
name|merge_sources
argument_list|,
name|target
argument_list|,
name|ra_session1
argument_list|,
name|sources_related
argument_list|,
name|same_repos
argument_list|,
name|ignore_mergeinfo
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|dry_run
argument_list|,
name|record_only
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|depth
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Close our temporary RA sessions. */
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sleep
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *TARGET_ABSPATH to the absolute path of, and *LOCK_ABSPATH to  the absolute path to lock for, TARGET_WCPATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_target_and_lock_abspath
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|target_abspath
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|lock_abspath
parameter_list|,
specifier|const
name|char
modifier|*
name|target_wcpath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_dirent_get_absolute
argument_list|(
name|target_abspath
argument_list|,
name|target_wcpath
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_wc_read_kind2
argument_list|(
operator|&
name|kind
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
operator|*
name|target_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
operator|*
name|lock_abspath
operator|=
operator|*
name|target_abspath
expr_stmt|;
else|else
operator|*
name|lock_abspath
operator|=
name|svn_dirent_dirname
argument_list|(
operator|*
name|target_abspath
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_merge5
parameter_list|(
specifier|const
name|char
modifier|*
name|source1
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision1
parameter_list|,
specifier|const
name|char
modifier|*
name|source2
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision2
parameter_list|,
specifier|const
name|char
modifier|*
name|target_wcpath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_mergeinfo
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|,
modifier|*
name|lock_abspath
decl_stmt|;
name|conflict_report_t
modifier|*
name|conflict_report
decl_stmt|;
comment|/* Sanity check our input -- we require specified revisions,    * and either 2 paths or 2 URLs. */
if|if
condition|(
operator|(
name|revision1
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
operator|||
operator|(
name|revision2
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CLIENT_BAD_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Not all required revisions are specified"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|source1
argument_list|)
operator|!=
name|svn_path_is_url
argument_list|(
name|source2
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_ILLEGAL_TARGET
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Merge sources must both be "
literal|"either paths or URLs"
argument_list|)
argument_list|)
return|;
comment|/* A WC path must be used with a repository revision, as we can't    * (currently) use the WC itself as a source, we can only read the URL    * from it and use that. */
name|SVN_ERR
argument_list|(
name|ensure_wc_path_has_repo_revision
argument_list|(
name|source1
argument_list|,
name|revision1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_wc_path_has_repo_revision
argument_list|(
name|source2
argument_list|,
name|revision2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_target_and_lock_abspath
argument_list|(
operator|&
name|target_abspath
argument_list|,
operator|&
name|lock_abspath
argument_list|,
name|target_wcpath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|merge_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|source1
argument_list|,
name|revision1
argument_list|,
name|source2
argument_list|,
name|revision2
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|ignore_mergeinfo
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|allow_mixed_rev
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|lock_abspath
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|merge_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|source1
argument_list|,
name|revision1
argument_list|,
name|source2
argument_list|,
name|revision2
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|ignore_mergeinfo
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|allow_mixed_rev
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_merge_conflict_error
argument_list|(
name|conflict_report
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Check if mergeinfo for a given path is described explicitly or via    inheritance in a mergeinfo catalog.     If REPOS_REL_PATH exists in CATALOG and has mergeinfo containing    MERGEINFO, then set *IN_CATALOG to TRUE.  If REPOS_REL_PATH does    not exist in CATALOG, then find its nearest parent which does exist.    If the mergeinfo REPOS_REL_PATH would inherit from that parent    contains MERGEINFO then set *IN_CATALOG to TRUE.  Set *IN_CATALOG    to FALSE in all other cases.     Set *CAT_KEY_PATH to the key path in CATALOG for REPOS_REL_PATH's    explicit or inherited mergeinfo.  If no explicit or inherited mergeinfo    is found for REPOS_REL_PATH then set *CAT_KEY_PATH to NULL.     User RESULT_POOL to allocate *CAT_KEY_PATH.  Use SCRATCH_POOL for    temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mergeinfo_in_catalog
parameter_list|(
name|svn_boolean_t
modifier|*
name|in_catalog
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cat_key_path
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_rel_path
parameter_list|,
name|svn_mergeinfo_t
name|mergeinfo
parameter_list|,
name|svn_mergeinfo_catalog_t
name|catalog
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|walk_path
init|=
name|NULL
decl_stmt|;
operator|*
name|in_catalog
operator|=
name|FALSE
expr_stmt|;
operator|*
name|cat_key_path
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mergeinfo
operator|&&
name|catalog
operator|&&
name|apr_hash_count
argument_list|(
name|catalog
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|repos_rel_path
decl_stmt|;
comment|/* Start with the assumption there is no explicit or inherited          mergeinfo for REPOS_REL_PATH in CATALOG. */
name|svn_mergeinfo_t
name|mergeinfo_in_cat
init|=
name|NULL
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|mergeinfo_in_cat
operator|=
name|svn_hash_gets
argument_list|(
name|catalog
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|mergeinfo_in_cat
condition|)
comment|/* Found it! */
block|{
operator|*
name|cat_key_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
comment|/* Look for inherited mergeinfo. */
block|{
name|walk_path
operator|=
name|svn_relpath_join
argument_list|(
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|walk_path
condition|?
name|walk_path
else|:
literal|""
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_relpath_dirname
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* No mergeinfo to inherit. */
break|break;
block|}
block|}
if|if
condition|(
name|mergeinfo_in_cat
condition|)
block|{
if|if
condition|(
name|walk_path
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__add_suffix_to_mergeinfo
argument_list|(
operator|&
name|mergeinfo_in_cat
argument_list|,
name|mergeinfo_in_cat
argument_list|,
name|walk_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_intersect2
argument_list|(
operator|&
name|mergeinfo_in_cat
argument_list|,
name|mergeinfo_in_cat
argument_list|,
name|mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__equals
argument_list|(
name|in_catalog
argument_list|,
name|mergeinfo_in_cat
argument_list|,
name|mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A svn_log_entry_receiver_t baton for log_find_operative_revs(). */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|log_find_operative_baton_t
block|{
comment|/* The catalog of explicit mergeinfo on a reintegrate source. */
name|svn_mergeinfo_catalog_t
name|merged_catalog
decl_stmt|;
comment|/* The catalog of unmerged history from the reintegrate target to      the source which we will create.  Allocated in RESULT_POOL. */
name|svn_mergeinfo_catalog_t
name|unmerged_catalog
decl_stmt|;
comment|/* The repository absolute path of the reintegrate target. */
specifier|const
name|char
modifier|*
name|target_fspath
decl_stmt|;
comment|/* The path of the reintegrate source relative to the repository root. */
specifier|const
name|char
modifier|*
name|source_repos_rel_path
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
block|}
name|log_find_operative_baton_t
typedef|;
end_typedef

begin_comment
comment|/* A svn_log_entry_receiver_t callback for find_unsynced_ranges(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_find_operative_revs
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|log_find_operative_baton_t
modifier|*
name|log_baton
init|=
name|baton
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* It's possible that authz restrictions on the merge source prevent us      from knowing about any of the changes for LOG_ENTRY->REVISION. */
if|if
condition|(
operator|!
name|log_entry
operator|->
name|changed_paths2
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|revision
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|log_entry
operator|->
name|changed_paths2
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|subtree_missing_this_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rel_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_rel_path
decl_stmt|;
name|svn_boolean_t
name|in_catalog
decl_stmt|;
name|svn_mergeinfo_t
name|log_entry_as_mergeinfo
decl_stmt|;
name|rel_path
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|log_baton
operator|->
name|target_fspath
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Easy out: The path is not within the tree of interest. */
if|if
condition|(
name|rel_path
operator|==
name|NULL
condition|)
continue|continue;
name|source_rel_path
operator|=
name|svn_relpath_join
argument_list|(
name|log_baton
operator|->
name|source_repos_rel_path
argument_list|,
name|rel_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|log_entry_as_mergeinfo
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%ld"
argument_list|,
name|path
argument_list|,
name|revision
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|mergeinfo_in_catalog
argument_list|(
operator|&
name|in_catalog
argument_list|,
operator|&
name|subtree_missing_this_rev
argument_list|,
name|source_rel_path
argument_list|,
name|log_entry_as_mergeinfo
argument_list|,
name|log_baton
operator|->
name|merged_catalog
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|in_catalog
condition|)
block|{
name|svn_mergeinfo_t
name|unmerged_for_key
decl_stmt|;
specifier|const
name|char
modifier|*
name|suffix
decl_stmt|,
modifier|*
name|missing_path
decl_stmt|;
comment|/* If there is no mergeinfo on the source tree we'll say              the "subtree" missing this revision is the root of the              source. */
if|if
condition|(
operator|!
name|subtree_missing_this_rev
condition|)
name|subtree_missing_this_rev
operator|=
name|log_baton
operator|->
name|source_repos_rel_path
expr_stmt|;
name|suffix
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|subtree_missing_this_rev
argument_list|,
name|source_rel_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|suffix
operator|&&
name|suffix
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|missing_path
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|path
argument_list|,
name|strlen
argument_list|(
name|path
argument_list|)
operator|-
name|strlen
argument_list|(
name|suffix
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|missing_path
operator|=
name|path
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|log_entry_as_mergeinfo
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s:%ld"
argument_list|,
name|missing_path
argument_list|,
name|revision
argument_list|)
argument_list|,
name|log_baton
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|unmerged_for_key
operator|=
name|svn_hash_gets
argument_list|(
name|log_baton
operator|->
name|unmerged_catalog
argument_list|,
name|subtree_missing_this_rev
argument_list|)
expr_stmt|;
if|if
condition|(
name|unmerged_for_key
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|unmerged_for_key
argument_list|,
name|log_entry_as_mergeinfo
argument_list|,
name|log_baton
operator|->
name|result_pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_hash_sets
argument_list|(
name|log_baton
operator|->
name|unmerged_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|log_baton
operator|->
name|result_pool
argument_list|,
name|subtree_missing_this_rev
argument_list|)
argument_list|,
name|log_entry_as_mergeinfo
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine if the mergeinfo on a reintegrate source SOURCE_LOC,    reflects that the source is fully synced with the reintegrate target    TARGET_LOC, even if a naive interpretation of the source's    mergeinfo says otherwise -- See issue #3577.     UNMERGED_CATALOG represents the history (as mergeinfo) from    TARGET_LOC that is not represented in SOURCE_LOC's    explicit/inherited mergeinfo as represented by MERGED_CATALOG.    MERGED_CATALOG may be empty if the source has no explicit or inherited    mergeinfo.     Check that all of the unmerged revisions in UNMERGED_CATALOG's    mergeinfos are "phantoms", that is, one of the following conditions holds:       1) The revision affects no corresponding paths in SOURCE_LOC.       2) The revision affects corresponding paths in SOURCE_LOC,         but based on the mergeinfo in MERGED_CATALOG, the change was         previously merged.     Make a deep copy, allocated in RESULT_POOL, of any portions of    UNMERGED_CATALOG that are not phantoms, to TRUE_UNMERGED_CATALOG.     Note: The keys in all mergeinfo catalogs used here are relative to the    root of the repository.     RA_SESSION is an RA session open to the repository of TARGET_LOC; it may    be temporarily reparented within this function.     Use SCRATCH_POOL for all temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_unsynced_ranges
parameter_list|(
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_loc
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|target_loc
parameter_list|,
name|svn_mergeinfo_catalog_t
name|unmerged_catalog
parameter_list|,
name|svn_mergeinfo_catalog_t
name|merged_catalog
parameter_list|,
name|svn_mergeinfo_catalog_t
name|true_unmerged_catalog
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_rangelist_t
modifier|*
name|potentially_unmerged_ranges
init|=
name|NULL
decl_stmt|;
comment|/* Convert all the unmerged history to a rangelist. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|unmerged_catalog
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi_catalog
decl_stmt|;
name|potentially_unmerged_ranges
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_merge_range_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi_catalog
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|unmerged_catalog
argument_list|)
init|;
name|hi_catalog
condition|;
name|hi_catalog
operator|=
name|apr_hash_next
argument_list|(
name|hi_catalog
argument_list|)
control|)
block|{
name|svn_mergeinfo_t
name|mergeinfo
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi_catalog
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_rangelist__merge_many
argument_list|(
name|potentially_unmerged_ranges
argument_list|,
name|mergeinfo
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Find any unmerged revisions which both affect the source and      are not yet merged to it. */
if|if
condition|(
name|potentially_unmerged_ranges
condition|)
block|{
name|svn_revnum_t
name|oldest_rev
init|=
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|potentially_unmerged_ranges
argument_list|,
literal|0
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|)
operator|->
name|start
operator|+
literal|1
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
init|=
operator|(
name|APR_ARRAY_IDX
argument_list|(
name|potentially_unmerged_ranges
argument_list|,
name|potentially_unmerged_ranges
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
operator|)
operator|->
name|end
decl_stmt|;
name|log_find_operative_baton_t
name|log_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|old_session_url
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|log_baton
operator|.
name|merged_catalog
operator|=
name|merged_catalog
expr_stmt|;
name|log_baton
operator|.
name|unmerged_catalog
operator|=
name|true_unmerged_catalog
expr_stmt|;
name|log_baton
operator|.
name|source_repos_rel_path
operator|=
name|svn_client__pathrev_relpath
argument_list|(
name|source_loc
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|log_baton
operator|.
name|target_fspath
operator|=
name|svn_client__pathrev_fspath
argument_list|(
name|target_loc
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|log_baton
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__ensure_ra_session_url
argument_list|(
operator|&
name|old_session_url
argument_list|,
name|ra_session
argument_list|,
name|target_loc
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|get_log
argument_list|(
name|ra_session
argument_list|,
literal|""
argument_list|,
name|youngest_rev
argument_list|,
name|oldest_rev
argument_list|,
name|TRUE
argument_list|,
comment|/* discover_changed_paths */
name|log_find_operative_revs
argument_list|,
operator|&
name|log_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|old_session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the youngest revision that has been merged from target to source.  *  * If any location in TARGET_HISTORY_AS_MERGEINFO is mentioned in  * SOURCE_MERGEINFO, then we know that at least one merge was done from the  * target to the source.  In that case, set *YOUNGEST_MERGED_REV to the  * youngest revision of that intersection (unless *YOUNGEST_MERGED_REV is  * already younger than that).  Otherwise, leave *YOUNGEST_MERGED_REV alone.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_youngest_merged_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_merged_rev
parameter_list|,
name|svn_mergeinfo_t
name|target_history_as_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|source_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|explicit_source_target_history_intersection
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_intersect2
argument_list|(
operator|&
name|explicit_source_target_history_intersection
argument_list|,
name|source_mergeinfo
argument_list|,
name|target_history_as_mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|explicit_source_target_history_intersection
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|old_rev
decl_stmt|,
name|young_rev
decl_stmt|;
comment|/* Keep track of the youngest revision merged from target to source. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__get_range_endpoints
argument_list|(
operator|&
name|young_rev
argument_list|,
operator|&
name|old_rev
argument_list|,
name|explicit_source_target_history_intersection
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|youngest_merged_rev
argument_list|)
operator|||
operator|(
name|young_rev
operator|>
operator|*
name|youngest_merged_rev
operator|)
condition|)
operator|*
name|youngest_merged_rev
operator|=
name|young_rev
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *FILTERED_MERGEINFO_P to the parts of TARGET_HISTORY_AS_MERGEINFO  * that are not present in the source branch.  *  * SOURCE_MERGEINFO is the explicit or inherited mergeinfo of the source  * branch SOURCE_PATHREV.  Extend SOURCE_MERGEINFO, modifying it in  * place, to include the natural history (implicit mergeinfo) of  * SOURCE_PATHREV.  ### But make these additions in SCRATCH_POOL.  *  * SOURCE_RA_SESSION is an RA session open to the repository containing  * SOURCE_PATHREV; it may be temporarily reparented within this function.  *  * ### [JAF] This function is named '..._subroutine' simply because I  *     factored it out based on code similarity, without knowing what it's  *     purpose is.  We should clarify its purpose and choose a better name.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_unmerged_mergeinfo_subroutine
parameter_list|(
name|svn_mergeinfo_t
modifier|*
name|filtered_mergeinfo_p
parameter_list|,
name|svn_mergeinfo_t
name|target_history_as_mergeinfo
parameter_list|,
name|svn_mergeinfo_t
name|source_mergeinfo
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_pathrev
parameter_list|,
name|svn_ra_session_t
modifier|*
name|source_ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_t
name|source_history_as_mergeinfo
decl_stmt|;
comment|/* Get the source path's natural history and merge it into source      path's explicit or inherited mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|source_history_as_mergeinfo
argument_list|,
name|NULL
comment|/* has_rev_zero_history */
argument_list|,
name|source_pathrev
argument_list|,
name|source_pathrev
operator|->
name|rev
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|source_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_merge2
argument_list|(
name|source_mergeinfo
argument_list|,
name|source_history_as_mergeinfo
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now source_mergeinfo represents everything we know about      source_path's history.  Now we need to know what part, if any, of the      corresponding target's history is *not* part of source_path's total      history; because it is neither shared history nor was it ever merged      from the target to the source. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_remove2
argument_list|(
name|filtered_mergeinfo_p
argument_list|,
name|source_mergeinfo
argument_list|,
name|target_history_as_mergeinfo
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for calculate_left_hand_side() which produces a mergeinfo catalog    describing what parts of of the reintegrate target have not previously been    merged to the reintegrate source.     SOURCE_CATALOG is the collection of explicit mergeinfo on SOURCE_LOC and    all its children, i.e. the mergeinfo catalog for the reintegrate source.     TARGET_HISTORY_HASH is a hash of (const char *) paths mapped to    svn_mergeinfo_t representing the location history.  Each of these    path keys represent a path in the reintegrate target, relative to the    repository root, which has explicit mergeinfo and/or is the reintegrate    target itself.  The svn_mergeinfo_t's contain the natural history of each    path@TARGET_REV.  Effectively this is the mergeinfo catalog on the    reintegrate target.     YC_ANCESTOR_REV is the revision of the youngest common ancestor of the    reintegrate source and the reintegrate target.     SOURCE_LOC is the reintegrate source.     SOURCE_RA_SESSION is a session opened to the URL of SOURCE_LOC    and TARGET_RA_SESSION is open to TARGET->loc.url.     For each entry in TARGET_HISTORY_HASH check that the history it    represents is contained in either the explicit mergeinfo for the    corresponding path in SOURCE_CATALOG, the corresponding path's inherited    mergeinfo (if no explicit mergeinfo for the path is found in    SOURCE_CATALOG), or the corresponding path's natural history.  Populate    *UNMERGED_TO_SOURCE_CATALOG with the corresponding source paths mapped to    the mergeinfo from the target's natural history which is *not* found.  Also    include any mergeinfo from SOURCE_CATALOG which explicitly describes the    target's history but for which *no* entry was found in    TARGET_HISTORY_HASH.     If no part of TARGET_HISTORY_HASH is found in SOURCE_CATALOG set    *YOUNGEST_MERGED_REV to SVN_INVALID_REVNUM; otherwise set it to the youngest    revision previously merged from the target to the source, and filter    *UNMERGED_TO_SOURCE_CATALOG so that it contains no ranges greater than    *YOUNGEST_MERGED_REV.     *UNMERGED_TO_SOURCE_CATALOG is (deeply) allocated in RESULT_POOL.    SCRATCH_POOL is used for all temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_unmerged_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|unmerged_to_source_catalog
parameter_list|,
name|svn_revnum_t
modifier|*
name|youngest_merged_rev
parameter_list|,
name|svn_revnum_t
name|yc_ancestor_rev
parameter_list|,
name|svn_mergeinfo_catalog_t
name|source_catalog
parameter_list|,
name|apr_hash_t
modifier|*
name|target_history_hash
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_loc
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|svn_ra_session_t
modifier|*
name|source_ra_session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|target_ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|source_repos_rel_path
init|=
name|svn_client__pathrev_relpath
argument_list|(
name|source_loc
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|target_repos_rel_path
init|=
name|svn_client__pathrev_relpath
argument_list|(
operator|&
name|target
operator|->
name|loc
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|new_catalog
init|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|source_ra_session
argument_list|,
name|source_loc
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|target_ra_session
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|youngest_merged_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Examine the natural history of each path in the reintegrate target      with explicit mergeinfo. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|target_history_hash
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|target_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|target_history_as_mergeinfo
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_rel_to_session
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|target_repos_rel_path
argument_list|,
name|target_path
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_path
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|source_pathrev
decl_stmt|;
name|svn_mergeinfo_t
name|source_mergeinfo
decl_stmt|,
name|filtered_mergeinfo
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|source_path
operator|=
name|svn_relpath_join
argument_list|(
name|source_repos_rel_path
argument_list|,
name|path_rel_to_session
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|source_pathrev
operator|=
name|svn_client__pathrev_join_relpath
argument_list|(
name|source_loc
argument_list|,
name|path_rel_to_session
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Remove any target history that is also part of the source's history,          i.e. their common ancestry.  By definition this has already been          "merged" from the target to the source.  If the source has explicit          self referential mergeinfo it would intersect with the target's          history below, making it appear that some merges had been done from          the target to the source, when this might not actually be the case. */
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|target_history_as_mergeinfo
argument_list|,
name|target_history_as_mergeinfo
argument_list|,
name|source_loc
operator|->
name|rev
argument_list|,
name|yc_ancestor_rev
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for any explicit mergeinfo on the source path corresponding to          the target path.  If we find any remove that from SOURCE_CATALOG.          When this iteration over TARGET_HISTORY_HASH is complete all that          should be left in SOURCE_CATALOG are subtrees that have explicit          mergeinfo on the reintegrate source where there is no corresponding          explicit mergeinfo on the reintegrate target. */
name|source_mergeinfo
operator|=
name|svn_hash_gets
argument_list|(
name|source_catalog
argument_list|,
name|source_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_mergeinfo
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|source_catalog
argument_list|,
name|source_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_youngest_merged_rev
argument_list|(
name|youngest_merged_rev
argument_list|,
name|target_history_as_mergeinfo
argument_list|,
name|source_mergeinfo
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* There is no mergeinfo on source_path *or* source_path doesn't              exist at all.  If simply doesn't exist we can ignore it              altogether. */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|source_ra_session
argument_list|,
name|path_rel_to_session
argument_list|,
name|source_loc
operator|->
name|rev
argument_list|,
operator|&
name|kind
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
continue|continue;
comment|/* Else source_path does exist though it has no explicit mergeinfo.              Find its inherited mergeinfo.  If it doesn't have any then simply              set source_mergeinfo to an empty hash. */
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo
argument_list|(
operator|&
name|source_mergeinfo
argument_list|,
name|source_ra_session
argument_list|,
name|source_pathrev
operator|->
name|url
argument_list|,
name|source_pathrev
operator|->
name|rev
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|FALSE
comment|/*squelch_incapable*/
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source_mergeinfo
condition|)
name|source_mergeinfo
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* Use scratch_pool rather than iterpool because filtered_mergeinfo          is going into new_catalog below and needs to last to the end of          this function. */
name|SVN_ERR
argument_list|(
name|find_unmerged_mergeinfo_subroutine
argument_list|(
operator|&
name|filtered_mergeinfo
argument_list|,
name|target_history_as_mergeinfo
argument_list|,
name|source_mergeinfo
argument_list|,
name|source_pathrev
argument_list|,
name|source_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|new_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|source_path
argument_list|)
argument_list|,
name|filtered_mergeinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Are there any subtrees with explicit mergeinfo still left in the merge      source where there was no explicit mergeinfo for the corresponding path      in the merge target?  If so, add the intersection of those path's      mergeinfo and the corresponding target path's mergeinfo to      new_catalog. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|source_catalog
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|source_path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_rel_to_session
init|=
name|svn_relpath_skip_ancestor
argument_list|(
name|source_repos_rel_path
argument_list|,
name|source_path
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|source_url
decl_stmt|;
name|svn_mergeinfo_t
name|source_mergeinfo
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_mergeinfo_t
name|filtered_mergeinfo
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|target_pathrev
decl_stmt|;
name|svn_mergeinfo_t
name|target_history_as_mergeinfo
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|source_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|source_loc
operator|->
name|url
argument_list|,
name|path_rel_to_session
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|target_pathrev
operator|=
name|svn_client__pathrev_join_relpath
argument_list|(
operator|&
name|target
operator|->
name|loc
argument_list|,
name|path_rel_to_session
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|target_history_as_mergeinfo
argument_list|,
name|NULL
comment|/* has_rev_zero_history */
argument_list|,
name|target_pathrev
argument_list|,
name|target
operator|->
name|loc
operator|.
name|rev
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|target_ra_session
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_DAV_REQUEST_FAILED
condition|)
block|{
comment|/* This path with explicit mergeinfo in the source doesn't                  exist on the target. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
else|else
block|{
name|svn_client__pathrev_t
modifier|*
name|pathrev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|find_youngest_merged_rev
argument_list|(
name|youngest_merged_rev
argument_list|,
name|target_history_as_mergeinfo
argument_list|,
name|source_mergeinfo
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use scratch_pool rather than iterpool because filtered_mergeinfo              is going into new_catalog below and needs to last to the end of              this function. */
comment|/* ### Why looking at SOURCE_url at TARGET_rev? */
name|SVN_ERR
argument_list|(
name|svn_client__pathrev_create_with_session
argument_list|(
operator|&
name|pathrev
argument_list|,
name|source_ra_session
argument_list|,
name|target
operator|->
name|loc
operator|.
name|rev
argument_list|,
name|source_url
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_unmerged_mergeinfo_subroutine
argument_list|(
operator|&
name|filtered_mergeinfo
argument_list|,
name|target_history_as_mergeinfo
argument_list|,
name|source_mergeinfo
argument_list|,
name|pathrev
argument_list|,
name|source_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|filtered_mergeinfo
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|new_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|source_path
argument_list|)
argument_list|,
name|filtered_mergeinfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Limit new_catalog to the youngest revisions previously merged from      the target to the source. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|youngest_merged_rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_catalog_by_ranges
argument_list|(
operator|&
name|new_catalog
argument_list|,
name|new_catalog
argument_list|,
operator|*
name|youngest_merged_rev
argument_list|,
literal|0
argument_list|,
comment|/* No oldest bound. */
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a shiny new copy before blowing away all the temporary pools. */
operator|*
name|unmerged_to_source_catalog
operator|=
name|svn_mergeinfo_catalog_dup
argument_list|(
name|new_catalog
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper for svn_client_merge_reintegrate() which calculates the    'left hand side' of the underlying two-URL merge that a --reintegrate    merge actually performs.  If no merge should be performed, set    *LEFT_P to NULL.     TARGET->abspath is the absolute working copy path of the reintegrate    merge.     SOURCE_LOC is the reintegrate source.     SUBTREES_WITH_MERGEINFO is a hash of (const char *) absolute paths mapped    to (svn_mergeinfo_t *) mergeinfo values for each working copy path with    explicit mergeinfo in TARGET->abspath.  Actually we only need to know the    paths, not the mergeinfo.     TARGET->loc.rev is the working revision the entire WC tree rooted at    TARGET is at.     Populate *UNMERGED_TO_SOURCE_CATALOG with the mergeinfo describing what    parts of TARGET->loc have not been merged to SOURCE_LOC, up to the    youngest revision ever merged from the TARGET->abspath to the source if    such exists, see doc string for find_unmerged_mergeinfo().     SOURCE_RA_SESSION is a session opened to the SOURCE_LOC    and TARGET_RA_SESSION is open to TARGET->loc.url.     *LEFT_P, *MERGED_TO_SOURCE_CATALOG , and *UNMERGED_TO_SOURCE_CATALOG are    allocated in RESULT_POOL.  SCRATCH_POOL is used for all temporary    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|calculate_left_hand_side
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|left_p
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|merged_to_source_catalog
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|unmerged_to_source_catalog
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|apr_hash_t
modifier|*
name|subtrees_with_mergeinfo
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_loc
parameter_list|,
name|svn_ra_session_t
modifier|*
name|source_ra_session
parameter_list|,
name|svn_ra_session_t
modifier|*
name|target_ra_session
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_catalog_t
name|mergeinfo_catalog
decl_stmt|,
name|unmerged_catalog
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* hash of paths mapped to arrays of svn_mergeinfo_t. */
name|apr_hash_t
modifier|*
name|target_history_hash
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|youngest_merged_rev
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|yc_ancestor
decl_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|source_ra_session
argument_list|,
name|source_loc
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|target_ra_session
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize our return variables. */
operator|*
name|left_p
operator|=
name|NULL
expr_stmt|;
comment|/* TARGET->abspath may not have explicit mergeinfo and thus may not be      contained within SUBTREES_WITH_MERGEINFO.  If this is the case then      add a dummy item for TARGET->abspath so we get its history (i.e. implicit      mergeinfo) below.  */
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|subtrees_with_mergeinfo
argument_list|,
name|target
operator|->
name|abspath
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|subtrees_with_mergeinfo
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the history segments (as mergeinfo) for TARGET->abspath and any of      its subtrees with explicit mergeinfo. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|subtrees_with_mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|local_abspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|target_child
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_relpath
decl_stmt|;
name|svn_mergeinfo_t
name|target_history_as_mergeinfo
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Convert the absolute path with mergeinfo on it to a path relative          to the session root. */
name|SVN_ERR
argument_list|(
name|svn_wc__node_get_repos_info
argument_list|(
name|NULL
argument_list|,
operator|&
name|repos_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|local_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|target_child
operator|=
name|svn_client__pathrev_create_with_relpath
argument_list|(
name|target
operator|->
name|loc
operator|.
name|repos_root_url
argument_list|,
name|target
operator|->
name|loc
operator|.
name|repos_uuid
argument_list|,
name|target
operator|->
name|loc
operator|.
name|rev
argument_list|,
name|repos_relpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|target_history_as_mergeinfo
argument_list|,
name|NULL
comment|/* has_rev_zero_hist */
argument_list|,
name|target_child
argument_list|,
name|target
operator|->
name|loc
operator|.
name|rev
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|target_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|target_history_hash
argument_list|,
name|repos_relpath
argument_list|,
name|target_history_as_mergeinfo
argument_list|)
expr_stmt|;
block|}
comment|/* Check that SOURCE_LOC and TARGET->loc are      actually related, we can't reintegrate if they are not.  Also      get an initial value for the YCA revision number. */
name|SVN_ERR
argument_list|(
name|svn_client__get_youngest_common_ancestor
argument_list|(
operator|&
name|yc_ancestor
argument_list|,
name|source_loc
argument_list|,
operator|&
name|target
operator|->
name|loc
argument_list|,
name|target_ra_session
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yc_ancestor
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s@%ld' must be ancestrally related to "
literal|"'%s@%ld'"
argument_list|)
argument_list|,
name|source_loc
operator|->
name|url
argument_list|,
name|source_loc
operator|->
name|rev
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|target
operator|->
name|loc
operator|.
name|rev
argument_list|)
return|;
comment|/* If the source revision is the same as the youngest common      revision, then there can't possibly be any unmerged revisions      that we need to apply to target. */
if|if
condition|(
name|source_loc
operator|->
name|rev
operator|==
name|yc_ancestor
operator|->
name|rev
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Get the mergeinfo from the source, including its descendants      with differing explicit mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_client__get_repos_mergeinfo_catalog
argument_list|(
operator|&
name|mergeinfo_catalog
argument_list|,
name|source_ra_session
argument_list|,
name|source_loc
operator|->
name|url
argument_list|,
name|source_loc
operator|->
name|rev
argument_list|,
name|svn_mergeinfo_inherited
argument_list|,
name|FALSE
comment|/* squelch_incapable */
argument_list|,
name|TRUE
comment|/* include_descendants */
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mergeinfo_catalog
condition|)
name|mergeinfo_catalog
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|merged_to_source_catalog
operator|=
name|svn_mergeinfo_catalog_dup
argument_list|(
name|mergeinfo_catalog
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Filter the source's mergeinfo catalog so that we are left with      mergeinfo that describes what has *not* previously been merged from      TARGET->loc to SOURCE_LOC. */
name|SVN_ERR
argument_list|(
name|find_unmerged_mergeinfo
argument_list|(
operator|&
name|unmerged_catalog
argument_list|,
operator|&
name|youngest_merged_rev
argument_list|,
name|yc_ancestor
operator|->
name|rev
argument_list|,
name|mergeinfo_catalog
argument_list|,
name|target_history_hash
argument_list|,
name|source_loc
argument_list|,
name|target
argument_list|,
name|source_ra_session
argument_list|,
name|target_ra_session
argument_list|,
name|ctx
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simplify unmerged_catalog through elision then make a copy in POOL. */
name|SVN_ERR
argument_list|(
name|svn_client__elide_mergeinfo_catalog
argument_list|(
name|unmerged_catalog
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|unmerged_to_source_catalog
operator|=
name|svn_mergeinfo_catalog_dup
argument_list|(
name|unmerged_catalog
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_merged_rev
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
comment|/* We never merged to the source.  Just return the branch point. */
operator|*
name|left_p
operator|=
name|svn_client__pathrev_dup
argument_list|(
name|yc_ancestor
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We've previously merged some or all of the target, up to          youngest_merged_rev, to the source.  Set          *LEFT_P to cover the youngest part of this range. */
name|SVN_ERR
argument_list|(
name|svn_client__repos_location
argument_list|(
name|left_p
argument_list|,
name|target_ra_session
argument_list|,
operator|&
name|target
operator|->
name|loc
argument_list|,
name|youngest_merged_rev
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine the URLs and revisions needed to perform a reintegrate merge  * from SOURCE_LOC into the working copy at TARGET.  *  * SOURCE_RA_SESSION and TARGET_RA_SESSION are RA sessions opened to the  * URLs of SOURCE_LOC and TARGET->loc respectively.  *  * Set *SOURCE_P to  * the source-left and source-right locations of the required merge.  Set  * *YC_ANCESTOR_P to the location of the youngest ancestor.  * Any of these output pointers may be NULL if not wanted.  *  * See svn_client_find_reintegrate_merge() for other details.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_reintegrate_merge
parameter_list|(
name|merge_source_t
modifier|*
modifier|*
name|source_p
parameter_list|,
name|svn_client__pathrev_t
modifier|*
modifier|*
name|yc_ancestor_p
parameter_list|,
name|svn_ra_session_t
modifier|*
name|source_ra_session
parameter_list|,
specifier|const
name|svn_client__pathrev_t
modifier|*
name|source_loc
parameter_list|,
name|svn_ra_session_t
modifier|*
name|target_ra_session
parameter_list|,
specifier|const
name|merge_target_t
modifier|*
name|target
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_client__pathrev_t
modifier|*
name|yc_ancestor
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|loc1
decl_stmt|;
name|merge_source_t
name|source
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|unmerged_to_source_mergeinfo_catalog
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|merged_to_source_mergeinfo_catalog
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_hash_t
modifier|*
name|subtrees_with_mergeinfo
decl_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|source_ra_session
argument_list|,
name|source_loc
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|session_url_is
argument_list|(
name|target_ra_session
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As the WC tree is "pure", use its last-updated-to revision as      the default revision for the left side of our merge, since that's      what the repository sub-tree is required to be up to date with      (with regard to the WC). */
comment|/* ### Bogus/obsolete comment? */
comment|/* Can't reintegrate to or from the root of the repository. */
if|if
condition|(
name|strcmp
argument_list|(
name|source_loc
operator|->
name|url
argument_list|,
name|source_loc
operator|->
name|repos_root_url
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|target
operator|->
name|loc
operator|.
name|repos_root_url
argument_list|)
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Neither the reintegrate source nor target "
literal|"can be the root of the repository"
argument_list|)
argument_list|)
return|;
comment|/* Find all the subtrees in TARGET_WCPATH that have explicit mergeinfo. */
name|err
operator|=
name|get_wc_explicit_mergeinfo_catalog
argument_list|(
operator|&
name|subtrees_with_mergeinfo
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|svn_depth_infinity
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Issue #3896: If invalid mergeinfo in the reintegrate target      prevents us from proceeding, then raise the best error possible. */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CLIENT_INVALID_MERGEINFO_NO_MERGETRACKING
condition|)
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Reintegrate merge not possible"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|calculate_left_hand_side
argument_list|(
operator|&
name|loc1
argument_list|,
operator|&
name|merged_to_source_mergeinfo_catalog
argument_list|,
operator|&
name|unmerged_to_source_mergeinfo_catalog
argument_list|,
name|target
argument_list|,
name|subtrees_with_mergeinfo
argument_list|,
name|source_loc
argument_list|,
name|source_ra_session
argument_list|,
name|target_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Did calculate_left_hand_side() decide that there was no merge to      be performed here?  */
if|if
condition|(
operator|!
name|loc1
condition|)
block|{
if|if
condition|(
name|source_p
condition|)
operator|*
name|source_p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|yc_ancestor_p
condition|)
operator|*
name|yc_ancestor_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|source
operator|.
name|loc1
operator|=
name|loc1
expr_stmt|;
name|source
operator|.
name|loc2
operator|=
name|source_loc
expr_stmt|;
comment|/* If the target was moved after the source was branched from it,      it is possible that the left URL differs from the target's current      URL.  If so, then adjust TARGET_RA_SESSION to point to the old URL. */
if|if
condition|(
name|strcmp
argument_list|(
name|source
operator|.
name|loc1
operator|->
name|url
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|target_ra_session
argument_list|,
name|source
operator|.
name|loc1
operator|->
name|url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_youngest_common_ancestor
argument_list|(
operator|&
name|yc_ancestor
argument_list|,
name|source
operator|.
name|loc2
argument_list|,
name|source
operator|.
name|loc1
argument_list|,
name|target_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|yc_ancestor
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s@%ld' must be ancestrally related to "
literal|"'%s@%ld'"
argument_list|)
argument_list|,
name|source
operator|.
name|loc1
operator|->
name|url
argument_list|,
name|source
operator|.
name|loc1
operator|->
name|rev
argument_list|,
name|source
operator|.
name|loc2
operator|->
name|url
argument_list|,
name|source
operator|.
name|loc2
operator|->
name|rev
argument_list|)
return|;
comment|/* The source side of a reintegrate merge is not 'ancestral', except in    * the degenerate case where source == YCA. */
name|source
operator|.
name|ancestral
operator|=
operator|(
name|loc1
operator|->
name|rev
operator|==
name|yc_ancestor
operator|->
name|rev
operator|)
expr_stmt|;
if|if
condition|(
name|source
operator|.
name|loc1
operator|->
name|rev
operator|>
name|yc_ancestor
operator|->
name|rev
condition|)
block|{
comment|/* Have we actually merged anything to the source from the          target?  If so, make sure we've merged a contiguous          prefix. */
name|svn_mergeinfo_catalog_t
name|final_unmerged_catalog
init|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|find_unsynced_ranges
argument_list|(
name|source_loc
argument_list|,
operator|&
name|target
operator|->
name|loc
argument_list|,
name|unmerged_to_source_mergeinfo_catalog
argument_list|,
name|merged_to_source_mergeinfo_catalog
argument_list|,
name|final_unmerged_catalog
argument_list|,
name|target_ra_session
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_hash_count
argument_list|(
name|final_unmerged_catalog
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|source_mergeinfo_cat_string
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__catalog_to_formatted_string
argument_list|(
operator|&
name|source_mergeinfo_cat_string
argument_list|,
name|final_unmerged_catalog
argument_list|,
literal|"  "
argument_list|,
literal|"    Missing ranges: "
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reintegrate can only be used if "
literal|"revisions %ld through %ld were "
literal|"previously merged from %s to the "
literal|"reintegrate source, but this is "
literal|"not the case:\n%s"
argument_list|)
argument_list|,
name|yc_ancestor
operator|->
name|rev
operator|+
literal|1
argument_list|,
name|source
operator|.
name|loc2
operator|->
name|rev
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|source_mergeinfo_cat_string
operator|->
name|data
argument_list|)
return|;
block|}
block|}
comment|/* Left side: trunk@youngest-trunk-rev-merged-to-branch-at-specified-peg-rev    * Right side: branch@specified-peg-revision */
if|if
condition|(
name|source_p
condition|)
operator|*
name|source_p
operator|=
name|merge_source_dup
argument_list|(
operator|&
name|source
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|yc_ancestor_p
condition|)
operator|*
name|yc_ancestor_p
operator|=
name|svn_client__pathrev_dup
argument_list|(
name|yc_ancestor
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Resolve the source and target locations and open RA sessions to them, and  * perform some checks appropriate for a reintegrate merge.  *  * Set *SOURCE_RA_SESSION_P and *SOURCE_LOC_P to a new session and the  * repository location of SOURCE_PATH_OR_URL at SOURCE_PEG_REVISION.  Set  * *TARGET_RA_SESSION_P and *TARGET_P to a new session and the repository  * location of the WC at TARGET_ABSPATH.  *  * Throw a SVN_ERR_CLIENT_UNRELATED_RESOURCES error if the target WC node is  * a locally added node or if the source and target are not in the same  * repository.  Throw a SVN_ERR_CLIENT_NOT_READY_TO_MERGE error if the  * target WC is not at a single revision without switched subtrees and  * without local mods.  *  * Allocate all the outputs in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_reintegrate_source_and_target
parameter_list|(
name|svn_ra_session_t
modifier|*
modifier|*
name|source_ra_session_p
parameter_list|,
name|svn_client__pathrev_t
modifier|*
modifier|*
name|source_loc_p
parameter_list|,
name|svn_ra_session_t
modifier|*
modifier|*
name|target_ra_session_p
parameter_list|,
name|merge_target_t
modifier|*
modifier|*
name|target_p
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_client__pathrev_t
modifier|*
name|source_loc
decl_stmt|;
name|merge_target_t
modifier|*
name|target
decl_stmt|;
comment|/* Open the target WC.  A reintegrate merge requires the merge target to    * reflect a subtree of the repository as found at a single revision. */
name|SVN_ERR
argument_list|(
name|open_target_wc
argument_list|(
operator|&
name|target
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
name|target_ra_session_p
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|target
operator|->
name|loc
operator|.
name|url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_UNRELATED_RESOURCES
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't reintegrate into '%s' because it is "
literal|"locally added and therefore not related to "
literal|"the merge source"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
name|source_ra_session_p
argument_list|,
operator|&
name|source_loc
argument_list|,
name|source_path_or_url
argument_list|,
name|NULL
argument_list|,
name|source_peg_revision
argument_list|,
name|source_peg_revision
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* source_loc and target->loc are required to be in the same repository,      as mergeinfo doesn't come into play for cross-repository merging. */
name|SVN_ERR
argument_list|(
name|check_same_repos
argument_list|(
name|source_loc
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|source_path_or_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|&
name|target
operator|->
name|loc
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|target
operator|->
name|abspath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|TRUE
comment|/* strict_urls */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|source_loc_p
operator|=
name|source_loc
expr_stmt|;
operator|*
name|target_p
operator|=
name|target
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The body of svn_client_merge_reintegrate(), which see for details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_reintegrate_locked
parameter_list|(
name|conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|target_ra_session
decl_stmt|,
modifier|*
name|source_ra_session
decl_stmt|;
name|merge_target_t
modifier|*
name|target
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|source_loc
decl_stmt|;
name|merge_source_t
modifier|*
name|source
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|yc_ancestor
decl_stmt|;
name|svn_boolean_t
name|use_sleep
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_reintegrate_source_and_target
argument_list|(
operator|&
name|source_ra_session
argument_list|,
operator|&
name|source_loc
argument_list|,
operator|&
name|target_ra_session
argument_list|,
operator|&
name|target
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|target_abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_reintegrate_merge
argument_list|(
operator|&
name|source
argument_list|,
operator|&
name|yc_ancestor
argument_list|,
name|source_ra_session
argument_list|,
name|source_loc
argument_list|,
name|target_ra_session
argument_list|,
name|target
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|source
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Do the real merge! */
comment|/* ### TODO(reint): Make sure that one isn't the same line ancestor      ### of the other (what's erroneously referred to as "ancestrally      ### related" in this source file).  For now, we just say the source      ### isn't "ancestral" even if it is (in the degenerate case where      ### source-left equals YCA). */
name|source
operator|->
name|ancestral
operator|=
name|FALSE
expr_stmt|;
name|err
operator|=
name|merge_cousins_and_supplement_mergeinfo
argument_list|(
name|conflict_report
argument_list|,
operator|&
name|use_sleep
argument_list|,
name|target
argument_list|,
name|target_ra_session
argument_list|,
name|source_ra_session
argument_list|,
name|source
argument_list|,
name|yc_ancestor
argument_list|,
name|TRUE
comment|/* same_repos */
argument_list|,
name|svn_depth_infinity
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|FALSE
comment|/* force_delete */
argument_list|,
name|FALSE
comment|/* record_only */
argument_list|,
name|dry_run
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sleep
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_merge_reintegrate
parameter_list|(
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_wcpath
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|,
modifier|*
name|lock_abspath
decl_stmt|;
name|conflict_report_t
modifier|*
name|conflict_report
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_target_and_lock_abspath
argument_list|(
operator|&
name|target_abspath
argument_list|,
operator|&
name|lock_abspath
argument_list|,
name|target_wcpath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|merge_reintegrate_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
comment|/*diff_ignore_ancestry*/
argument_list|,
name|dry_run
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|lock_abspath
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|merge_reintegrate_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|target_abspath
argument_list|,
name|FALSE
comment|/*diff_ignore_ancestry*/
argument_list|,
name|dry_run
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_merge_conflict_error
argument_list|(
name|conflict_report
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The body of svn_client_merge_peg5(), which see for details.  *  * IGNORE_MERGEINFO and DIFF_IGNORE_ANCESTRY are as in do_merge().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge_peg_locked
parameter_list|(
name|conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|svn_rangelist_t
modifier|*
name|ranges_to_merge
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_mergeinfo
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_target_t
modifier|*
name|target
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|source_loc
decl_stmt|;
name|apr_array_header_t
modifier|*
name|merge_sources
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
decl_stmt|;
name|apr_pool_t
modifier|*
name|sesspool
decl_stmt|;
name|svn_boolean_t
name|use_sleep
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|same_repos
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_dirent_is_absolute
argument_list|(
name|target_abspath
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_target_wc
argument_list|(
operator|&
name|target
argument_list|,
name|target_abspath
argument_list|,
name|allow_mixed_rev
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a short lived session pool */
name|sesspool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Open an RA session to our source URL, and determine its root URL. */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|ra_session
argument_list|,
operator|&
name|source_loc
argument_list|,
name|source_path_or_url
argument_list|,
name|NULL
argument_list|,
name|source_peg_revision
argument_list|,
name|source_peg_revision
argument_list|,
name|ctx
argument_list|,
name|sesspool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Normalize our merge sources. */
name|SVN_ERR
argument_list|(
name|normalize_merge_sources
argument_list|(
operator|&
name|merge_sources
argument_list|,
name|source_path_or_url
argument_list|,
name|source_loc
argument_list|,
name|ranges_to_merge
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for same_repos. */
name|same_repos
operator|=
name|is_same_repos
argument_list|(
operator|&
name|target
operator|->
name|loc
argument_list|,
name|source_loc
argument_list|,
name|TRUE
comment|/* strict_urls */
argument_list|)
expr_stmt|;
comment|/* Do the real merge!  (We say with confidence that our merge      sources are both ancestral and related.) */
name|err
operator|=
name|do_merge
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|conflict_report
argument_list|,
operator|&
name|use_sleep
argument_list|,
name|merge_sources
argument_list|,
name|target
argument_list|,
name|ra_session
argument_list|,
name|TRUE
comment|/*sources_related*/
argument_list|,
name|same_repos
argument_list|,
name|ignore_mergeinfo
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|dry_run
argument_list|,
name|record_only
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|depth
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* We're done with our RA session. */
name|svn_pool_destroy
argument_list|(
name|sesspool
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_sleep
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Details of an automatic merge. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|automatic_merge_t
block|{
name|svn_client__pathrev_t
modifier|*
name|yca
decl_stmt|,
modifier|*
name|base
decl_stmt|,
modifier|*
name|right
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|svn_boolean_t
name|is_reintegrate_like
decl_stmt|;
name|svn_boolean_t
name|allow_mixed_rev
decl_stmt|,
name|allow_local_mods
decl_stmt|,
name|allow_switched_subtrees
decl_stmt|;
block|}
name|automatic_merge_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|client_find_automatic_merge
parameter_list|(
name|automatic_merge_t
modifier|*
modifier|*
name|merge_p
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
name|svn_boolean_t
name|allow_local_mods
parameter_list|,
name|svn_boolean_t
name|allow_switched_subtrees
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|do_automatic_merge_locked
parameter_list|(
name|conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|automatic_merge_t
modifier|*
name|merge
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|svn_error_t
modifier|*
name|svn_client_merge_peg5
parameter_list|(
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ranges_to_merge
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_wcpath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_mergeinfo
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|target_abspath
decl_stmt|,
modifier|*
name|lock_abspath
decl_stmt|;
name|conflict_report_t
modifier|*
name|conflict_report
decl_stmt|;
comment|/* No ranges to merge?  No problem. */
if|if
condition|(
name|ranges_to_merge
operator|!=
name|NULL
operator|&&
name|ranges_to_merge
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|get_target_and_lock_abspath
argument_list|(
operator|&
name|target_abspath
argument_list|,
operator|&
name|lock_abspath
argument_list|,
name|target_wcpath
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do an automatic merge if no revision ranges are specified. */
if|if
condition|(
name|ranges_to_merge
operator|==
name|NULL
condition|)
block|{
name|automatic_merge_t
modifier|*
name|merge
decl_stmt|;
if|if
condition|(
name|ignore_mergeinfo
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot merge automatically while "
literal|"ignoring mergeinfo"
argument_list|)
argument_list|)
return|;
comment|/* Find the details of the merge needed. */
name|SVN_ERR
argument_list|(
name|client_find_automatic_merge
argument_list|(
operator|&
name|merge
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|target_abspath
argument_list|,
name|allow_mixed_rev
argument_list|,
name|TRUE
comment|/*allow_local_mods*/
argument_list|,
name|TRUE
comment|/*allow_switched_subtrees*/
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|do_automatic_merge_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|merge
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|lock_abspath
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|do_automatic_merge_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|merge
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|dry_run
condition|)
name|SVN_WC__CALL_WITH_WRITE_LOCK
argument_list|(
name|merge_peg_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|ranges_to_merge
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|ignore_mergeinfo
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|allow_mixed_rev
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
name|ctx
operator|->
name|wc_ctx
argument_list|,
name|lock_abspath
argument_list|,
name|FALSE
comment|/* lock_anchor */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|merge_peg_locked
argument_list|(
operator|&
name|conflict_report
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|ranges_to_merge
argument_list|,
name|target_abspath
argument_list|,
name|depth
argument_list|,
name|ignore_mergeinfo
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|allow_mixed_rev
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_merge_conflict_error
argument_list|(
name|conflict_report
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The location-history of a branch.  *  * This structure holds the set of path-revisions occupied by a branch,  * from an externally chosen 'tip' location back to its origin.  The  * 'tip' location is the youngest location that we are considering on  * the branch. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|branch_history_t
block|{
comment|/* The tip location of the branch.  That is, the youngest location that's    * in the repository and that we're considering.  If we're considering a    * target branch right up to an uncommitted WC, then this is the WC base    * (pristine) location. */
name|svn_client__pathrev_t
modifier|*
name|tip
decl_stmt|;
comment|/* The location-segment history, as mergeinfo. */
name|svn_mergeinfo_t
name|history
decl_stmt|;
comment|/* Whether the location-segment history reached as far as (necessarily      the root path in) revision 0 -- a fact that can't be represented as      mergeinfo. */
name|svn_boolean_t
name|has_r0_history
decl_stmt|;
block|}
name|branch_history_t
typedef|;
end_typedef

begin_comment
comment|/* Return the location on BRANCH_HISTORY at revision REV, or NULL if none. */
end_comment

begin_function
specifier|static
name|svn_client__pathrev_t
modifier|*
name|location_on_branch_at_rev
parameter_list|(
specifier|const
name|branch_history_t
modifier|*
name|branch_history
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|scratch_pool
argument_list|,
name|branch_history
operator|->
name|history
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|fspath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_merge_range_t
modifier|*
name|r
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|->
name|start
operator|<
name|rev
operator|&&
name|rev
operator|<=
name|r
operator|->
name|end
condition|)
block|{
return|return
name|svn_client__pathrev_create_with_relpath
argument_list|(
name|branch_history
operator|->
name|tip
operator|->
name|repos_root_url
argument_list|,
name|branch_history
operator|->
name|tip
operator|->
name|repos_uuid
argument_list|,
name|rev
argument_list|,
name|fspath
operator|+
literal|1
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|source_and_target_t
block|{
name|svn_client__pathrev_t
modifier|*
name|source
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|source_ra_session
decl_stmt|;
name|branch_history_t
name|source_branch
decl_stmt|;
name|merge_target_t
modifier|*
name|target
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|target_ra_session
decl_stmt|;
name|branch_history_t
name|target_branch
decl_stmt|;
comment|/* Repos location of the youngest common ancestor of SOURCE and TARGET. */
name|svn_client__pathrev_t
modifier|*
name|yca
decl_stmt|;
block|}
name|source_and_target_t
typedef|;
end_typedef

begin_comment
comment|/* Set *INTERSECTION_P to the intersection of BRANCH_HISTORY with the  * revision range OLDEST_REV to YOUNGEST_REV (inclusive).  *  * If the intersection is empty, the result will be a branch history object  * containing an empty (not null) history.  *  * ### The 'tip' of the result is currently unchanged.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|branch_history_intersect_range
parameter_list|(
name|branch_history_t
modifier|*
modifier|*
name|intersection_p
parameter_list|,
specifier|const
name|branch_history_t
modifier|*
name|branch_history
parameter_list|,
name|svn_revnum_t
name|oldest_rev
parameter_list|,
name|svn_revnum_t
name|youngest_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|branch_history_t
modifier|*
name|result
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|oldest_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|youngest_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|oldest_rev
operator|>=
literal|1
argument_list|)
expr_stmt|;
comment|/* Allow a just-empty range (oldest = youngest + 1) but not an    * arbitrary reverse range (such as oldest = youngest + 2). */
name|SVN_ERR_ASSERT
argument_list|(
name|oldest_rev
operator|<=
name|youngest_rev
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldest_rev
operator|<=
name|youngest_rev
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|result
operator|->
name|history
argument_list|,
name|branch_history
operator|->
name|history
argument_list|,
name|youngest_rev
argument_list|,
name|oldest_rev
operator|-
literal|1
argument_list|,
name|TRUE
comment|/* include_range */
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|history
operator|=
name|svn_mergeinfo_dup
argument_list|(
name|result
operator|->
name|history
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|->
name|history
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
name|result
operator|->
name|has_r0_history
operator|=
name|FALSE
expr_stmt|;
comment|/* ### TODO: Set RESULT->tip to the tip of the intersection. */
name|result
operator|->
name|tip
operator|=
name|svn_client__pathrev_dup
argument_list|(
name|branch_history
operator|->
name|tip
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
operator|*
name|intersection_p
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *OLDEST_P and *YOUNGEST_P to the oldest and youngest locations  * (inclusive) along BRANCH.  OLDEST_P and/or YOUNGEST_P may be NULL if not  * wanted.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|branch_history_get_endpoints
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|oldest_p
parameter_list|,
name|svn_client__pathrev_t
modifier|*
modifier|*
name|youngest_p
parameter_list|,
specifier|const
name|branch_history_t
modifier|*
name|branch
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_revnum_t
name|youngest_rev
decl_stmt|,
name|oldest_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__get_range_endpoints
argument_list|(
operator|&
name|youngest_rev
argument_list|,
operator|&
name|oldest_rev
argument_list|,
name|branch
operator|->
name|history
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldest_p
condition|)
operator|*
name|oldest_p
operator|=
name|location_on_branch_at_rev
argument_list|(
name|branch
argument_list|,
name|oldest_rev
operator|+
literal|1
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_p
condition|)
operator|*
name|youngest_p
operator|=
name|location_on_branch_at_rev
argument_list|(
name|branch
argument_list|,
name|youngest_rev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements the svn_log_entry_receiver_t interface.    Set *BATON to LOG_ENTRY->revision and return SVN_ERR_CEASE_INVOCATION. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|operative_rev_receiver
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_log_entry_t
modifier|*
name|log_entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
modifier|*
name|operative_rev
init|=
name|baton
decl_stmt|;
operator|*
name|operative_rev
operator|=
name|log_entry
operator|->
name|revision
expr_stmt|;
comment|/* We've found the youngest merged or oldest eligible revision, so      we're done...       ...but wait, shouldn't we care if LOG_ENTRY->NON_INHERITABLE is      true?  Because if it is, then LOG_ENTRY->REVISION is only      partially merged/elgibile!  And our only caller,      find_last_merged_location (via short_circuit_mergeinfo_log) is      interested in *fully* merged revisions.  That's all true, but if      find_last_merged_location() finds the youngest merged revision it      will also check for the oldest eligible revision.  So in the case      the youngest merged rev is non-inheritable, the *same* non-inheritable      rev will be found as the oldest eligible rev -- and      find_last_merged_location() handles that situation. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CEASE_INVOCATION
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around svn_client__mergeinfo_log. All arguments are as per    that private API.  The discover_changed_paths, depth, and revprops args to    svn_client__mergeinfo_log are always TRUE, svn_depth_infinity_t,    and empty array respectively.     If RECEIVER raises a SVN_ERR_CEASE_INVOCATION error, but still sets    *REVISION to a valid revnum, then clear the error.  Otherwise return    any error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|short_circuit_mergeinfo_log
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|target_mergeinfo_cat
parameter_list|,
name|svn_boolean_t
name|finding_merged
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|target_peg_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_peg_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_start_revision
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_end_revision
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|revprops
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|session_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_session_url
argument_list|(
name|ra_session
argument_list|,
operator|&
name|session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|revprops
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_client__mergeinfo_log
argument_list|(
name|finding_merged
argument_list|,
name|target_path_or_url
argument_list|,
name|target_peg_revision
argument_list|,
name|target_mergeinfo_cat
argument_list|,
name|source_path_or_url
argument_list|,
name|source_peg_revision
argument_list|,
name|source_start_revision
argument_list|,
name|source_end_revision
argument_list|,
name|receiver
argument_list|,
name|revision
argument_list|,
name|TRUE
argument_list|,
name|svn_depth_infinity
argument_list|,
name|revprops
argument_list|,
name|ctx
argument_list|,
name|ra_session
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_ra_reparent
argument_list|(
name|ra_session
argument_list|,
name|session_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* We expect RECEIVER to short-circuit the (potentially expensive) log          by raising an SVN_ERR_CEASE_INVOCATION -- see operative_rev_receiver.          So we can ignore that error, but only as long as we actually found a          valid revision. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|revision
argument_list|)
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CEASE_INVOCATION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *BASE_P to the last location on SOURCE_BRANCH such that all changes  * on SOURCE_BRANCH after YCA up to and including *BASE_P have already  * been fully merged into TARGET.  *  *               *BASE_P       TIP  *          o-------o-----------o--- SOURCE_BRANCH  *         /         \  *   -----o     prev. \  *     YCA \    merges \  *          o-----------o----------- TARGET branch  *  * In terms of mergeinfo:  *  *     Source     a--...                     o=change, -=no-op revision  *       branch  /   \  *     YCA -->  o     a---o---o---o---o---   d=delete, a=add-as-a-copy  *  *     Eligible -.eee.eeeeeeeeeeeeeeeeeeee   .=not a source branch location  *  *     Tgt-mi   -.mmm.mm-mm-------m-------   m=merged to root of TARGET or  *                                           subtree of TARGET with no  *                                           operative changes outside of that  *                                           subtree, -=not merged  *  *     Eligible -.---.--e--eeeeeee-eeeeeee  *  *     Next     --------^-----------------   BASE is just before here.  *  *             /         \  *       -----o     prev. \  *         YCA \    merges \  *              o-----------o-------------  *  * If no revisions from SOURCE_BRANCH have been completely merged to TARGET,  * then set *BASE_P to the YCA.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_last_merged_location
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|base_p
parameter_list|,
name|svn_client__pathrev_t
modifier|*
name|yca
parameter_list|,
specifier|const
name|branch_history_t
modifier|*
name|source_branch
parameter_list|,
name|svn_client__pathrev_t
modifier|*
name|target
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_opt_revision_t
name|source_peg_rev
decl_stmt|,
name|source_start_rev
decl_stmt|,
name|source_end_rev
decl_stmt|,
name|target_opt_rev
decl_stmt|;
name|svn_revnum_t
name|youngest_merged_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_mergeinfo_catalog_t
name|target_mergeinfo_cat
init|=
name|NULL
decl_stmt|;
name|source_peg_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|source_peg_rev
operator|.
name|value
operator|.
name|number
operator|=
name|source_branch
operator|->
name|tip
operator|->
name|rev
expr_stmt|;
name|source_start_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|source_start_rev
operator|.
name|value
operator|.
name|number
operator|=
name|yca
operator|->
name|rev
expr_stmt|;
name|source_end_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|source_end_rev
operator|.
name|value
operator|.
name|number
operator|=
name|source_branch
operator|->
name|tip
operator|->
name|rev
expr_stmt|;
name|target_opt_rev
operator|.
name|kind
operator|=
name|svn_opt_revision_number
expr_stmt|;
name|target_opt_rev
operator|.
name|value
operator|.
name|number
operator|=
name|target
operator|->
name|rev
expr_stmt|;
comment|/* Find the youngest revision fully merged from SOURCE_BRANCH to TARGET,      if such a revision exists. */
name|SVN_ERR
argument_list|(
name|short_circuit_mergeinfo_log
argument_list|(
operator|&
name|target_mergeinfo_cat
argument_list|,
name|TRUE
argument_list|,
comment|/* Find merged */
name|target
operator|->
name|url
argument_list|,
operator|&
name|target_opt_rev
argument_list|,
name|source_branch
operator|->
name|tip
operator|->
name|url
argument_list|,
operator|&
name|source_peg_rev
argument_list|,
operator|&
name|source_end_rev
argument_list|,
operator|&
name|source_start_rev
argument_list|,
name|operative_rev_receiver
argument_list|,
operator|&
name|youngest_merged_rev
argument_list|,
name|ctx
argument_list|,
name|ra_session
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|youngest_merged_rev
argument_list|)
condition|)
block|{
comment|/* No revisions have been completely merged from SOURCE_BRANCH to          TARGET so the base for the next merge is the YCA. */
operator|*
name|base_p
operator|=
name|yca
expr_stmt|;
block|}
else|else
block|{
comment|/* One or more revisions have already been completely merged from          SOURCE_BRANCH to TARGET, now find the oldest revision, older          than the youngest merged revision, which is still eligible to          be merged, if such exists. */
name|branch_history_t
modifier|*
name|contiguous_source
decl_stmt|;
name|svn_revnum_t
name|base_rev
decl_stmt|;
name|svn_revnum_t
name|oldest_eligible_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* If the only revisions eligible are younger than the youngest merged          revision we can simply assume that the youngest eligible revision          is the youngest merged revision.  Obviously this may not be true!          The revisions between the youngest merged revision and the tip of          the branch may have several inoperative revisions -- they may *all*          be inoperative revisions!  But for the purpose of this function          (i.e. finding the youngest revision after the YCA where all revs have          been merged) that doesn't matter. */
name|source_end_rev
operator|.
name|value
operator|.
name|number
operator|=
name|youngest_merged_rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|short_circuit_mergeinfo_log
argument_list|(
operator|&
name|target_mergeinfo_cat
argument_list|,
name|FALSE
argument_list|,
comment|/* Find eligible */
name|target
operator|->
name|url
argument_list|,
operator|&
name|target_opt_rev
argument_list|,
name|source_branch
operator|->
name|tip
operator|->
name|url
argument_list|,
operator|&
name|source_peg_rev
argument_list|,
operator|&
name|source_start_rev
argument_list|,
operator|&
name|source_end_rev
argument_list|,
name|operative_rev_receiver
argument_list|,
operator|&
name|oldest_eligible_rev
argument_list|,
name|ctx
argument_list|,
name|ra_session
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there are revisions eligible for merging, use the oldest one          to calculate the base.  Otherwise there are no operative revisions          to merge and we can simple set the base to the youngest revision          already merged. */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|oldest_eligible_rev
argument_list|)
condition|)
name|base_rev
operator|=
name|oldest_eligible_rev
operator|-
literal|1
expr_stmt|;
else|else
name|base_rev
operator|=
name|youngest_merged_rev
expr_stmt|;
comment|/* Find the branch location just before the oldest eligible rev.          (We can't just use the base revs calculated above because the branch          might have a gap there.) */
name|SVN_ERR
argument_list|(
name|branch_history_intersect_range
argument_list|(
operator|&
name|contiguous_source
argument_list|,
name|source_branch
argument_list|,
name|yca
operator|->
name|rev
argument_list|,
name|base_rev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|branch_history_get_endpoints
argument_list|(
name|NULL
argument_list|,
name|base_p
argument_list|,
name|contiguous_source
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find a merge base location on the target branch, like in a sync  * merge.  *  *                BASE          S_T->source  *          o-------o-----------o---  *         /         \           \  *   -----o     prev. \           \  this  *     YCA \    merge  \           \ merge  *          o-----------o-----------o  *                                  S_T->target  *  * Set *BASE_P to BASE, the youngest location in the history of S_T->source  * (at or after the YCA) at which all revisions up to BASE are effectively  * merged into S_T->target.  *  * If no locations on the history of S_T->source are effectively merged to  * S_T->target, set *BASE_P to the YCA.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_base_on_source
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|base_p
parameter_list|,
name|source_and_target_t
modifier|*
name|s_t
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|find_last_merged_location
argument_list|(
name|base_p
argument_list|,
name|s_t
operator|->
name|yca
argument_list|,
operator|&
name|s_t
operator|->
name|source_branch
argument_list|,
name|s_t
operator|->
name|target_branch
operator|.
name|tip
argument_list|,
name|ctx
argument_list|,
name|s_t
operator|->
name|source_ra_session
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find a merge base location on the target branch, like in a reintegrate  * merge.  *  *                              S_T->source  *          o-----------o-------o---  *         /    prev.  /         \  *   -----o     merge /           \  this  *     YCA \         /             \ merge  *          o-------o---------------o  *                BASE              S_T->target  *  * Set *BASE_P to BASE, the youngest location in the history of S_T->target  * (at or after the YCA) at which all revisions up to BASE are effectively  * merged into S_T->source.  *  * If no locations on the history of S_T->target are effectively merged to  * S_T->source, set *BASE_P to the YCA.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_base_on_target
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|base_p
parameter_list|,
name|source_and_target_t
modifier|*
name|s_t
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|find_last_merged_location
argument_list|(
name|base_p
argument_list|,
name|s_t
operator|->
name|yca
argument_list|,
operator|&
name|s_t
operator|->
name|target_branch
argument_list|,
name|s_t
operator|->
name|source
argument_list|,
name|ctx
argument_list|,
name|s_t
operator|->
name|target_ra_session
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The body of client_find_automatic_merge(), which see.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_automatic_merge
parameter_list|(
name|svn_client__pathrev_t
modifier|*
modifier|*
name|base_p
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_reintegrate_like
parameter_list|,
name|source_and_target_t
modifier|*
name|s_t
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_client__pathrev_t
modifier|*
name|base_on_source
decl_stmt|,
modifier|*
name|base_on_target
decl_stmt|;
comment|/* Get the location-history of each branch. */
name|s_t
operator|->
name|source_branch
operator|.
name|tip
operator|=
name|s_t
operator|->
name|source
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|s_t
operator|->
name|source_branch
operator|.
name|history
argument_list|,
operator|&
name|s_t
operator|->
name|source_branch
operator|.
name|has_r0_history
argument_list|,
name|s_t
operator|->
name|source
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|s_t
operator|->
name|source_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|s_t
operator|->
name|target_branch
operator|.
name|tip
operator|=
operator|&
name|s_t
operator|->
name|target
operator|->
name|loc
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__get_history_as_mergeinfo
argument_list|(
operator|&
name|s_t
operator|->
name|target_branch
operator|.
name|history
argument_list|,
operator|&
name|s_t
operator|->
name|target_branch
operator|.
name|has_r0_history
argument_list|,
operator|&
name|s_t
operator|->
name|target
operator|->
name|loc
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|s_t
operator|->
name|target_ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__calc_youngest_common_ancestor
argument_list|(
operator|&
name|s_t
operator|->
name|yca
argument_list|,
name|s_t
operator|->
name|source
argument_list|,
name|s_t
operator|->
name|source_branch
operator|.
name|history
argument_list|,
name|s_t
operator|->
name|source_branch
operator|.
name|has_r0_history
argument_list|,
operator|&
name|s_t
operator|->
name|target
operator|->
name|loc
argument_list|,
name|s_t
operator|->
name|target_branch
operator|.
name|history
argument_list|,
name|s_t
operator|->
name|target_branch
operator|.
name|has_r0_history
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s_t
operator|->
name|yca
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CLIENT_NOT_READY_TO_MERGE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s@%ld' must be ancestrally related to "
literal|"'%s@%ld'"
argument_list|)
argument_list|,
name|s_t
operator|->
name|source
operator|->
name|url
argument_list|,
name|s_t
operator|->
name|source
operator|->
name|rev
argument_list|,
name|s_t
operator|->
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|s_t
operator|->
name|target
operator|->
name|loc
operator|.
name|rev
argument_list|)
return|;
comment|/* Find the latest revision of A synced to B and the latest    * revision of B synced to A.    *    *   base_on_source = youngest_complete_synced_point(source, target)    *   base_on_target = youngest_complete_synced_point(target, source)    */
name|SVN_ERR
argument_list|(
name|find_base_on_source
argument_list|(
operator|&
name|base_on_source
argument_list|,
name|s_t
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_base_on_target
argument_list|(
operator|&
name|base_on_target
argument_list|,
name|s_t
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Choose a base. */
if|if
condition|(
name|base_on_source
operator|->
name|rev
operator|>=
name|base_on_target
operator|->
name|rev
condition|)
block|{
operator|*
name|base_p
operator|=
name|base_on_source
expr_stmt|;
operator|*
name|is_reintegrate_like
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|base_p
operator|=
name|base_on_target
expr_stmt|;
operator|*
name|is_reintegrate_like
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Find out what kind of automatic merge would be needed, when the target  * is only known as a repository location rather than a WC.  *  * Like find_automatic_merge() except that the target is  * specified by @a target_path_or_url at @a target_revision, which must  * refer to a repository location, instead of by a WC path argument.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_automatic_merge_no_wc
parameter_list|(
name|automatic_merge_t
modifier|*
modifier|*
name|merge_p
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|target_revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|source_and_target_t
modifier|*
name|s_t
init|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_client__pathrev_t
modifier|*
name|target_loc
decl_stmt|;
name|automatic_merge_t
modifier|*
name|merge
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|merge
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Source */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|s_t
operator|->
name|source_ra_session
argument_list|,
operator|&
name|s_t
operator|->
name|source
argument_list|,
name|source_path_or_url
argument_list|,
name|NULL
argument_list|,
name|source_revision
argument_list|,
name|source_revision
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Target */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|s_t
operator|->
name|target_ra_session
argument_list|,
operator|&
name|target_loc
argument_list|,
name|target_path_or_url
argument_list|,
name|NULL
argument_list|,
name|target_revision
argument_list|,
name|target_revision
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|s_t
operator|->
name|target
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s_t
operator|->
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|s_t
operator|->
name|target
operator|->
name|abspath
operator|=
name|NULL
expr_stmt|;
comment|/* indicate the target is not a WC */
name|s_t
operator|->
name|target
operator|->
name|loc
operator|=
operator|*
name|target_loc
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_automatic_merge
argument_list|(
operator|&
name|merge
operator|->
name|base
argument_list|,
operator|&
name|merge
operator|->
name|is_reintegrate_like
argument_list|,
name|s_t
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|merge
operator|->
name|right
operator|=
name|s_t
operator|->
name|source
expr_stmt|;
name|merge
operator|->
name|target
operator|=
operator|&
name|s_t
operator|->
name|target
operator|->
name|loc
expr_stmt|;
name|merge
operator|->
name|yca
operator|=
name|s_t
operator|->
name|yca
expr_stmt|;
operator|*
name|merge_p
operator|=
name|merge
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the information needed to merge all unmerged changes from a source  * branch into a target branch.  *  * Set @a *merge_p to the information needed to merge all unmerged changes  * (up to @a source_revision) from the source branch @a source_path_or_url  * at @a source_revision into the target WC at @a target_abspath.  *  * The flags @a allow_mixed_rev, @a allow_local_mods and  * @a allow_switched_subtrees enable merging into a WC that is in any or all  * of the states described by their names, but only if this function decides  * that the merge will be in the same direction as the last automatic merge.  * If, on the other hand, the last automatic merge was in the opposite  * direction, then such states of the WC are not allowed regardless  * of these flags.  This function merely records these flags in the  * @a *merge_p structure; do_automatic_merge_locked() checks the WC  * state for compliance.  *  * Allocate the @a *merge_p structure in @a result_pool.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|client_find_automatic_merge
parameter_list|(
name|automatic_merge_t
modifier|*
modifier|*
name|merge_p
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_boolean_t
name|allow_mixed_rev
parameter_list|,
name|svn_boolean_t
name|allow_local_mods
parameter_list|,
name|svn_boolean_t
name|allow_switched_subtrees
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|source_and_target_t
modifier|*
name|s_t
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|s_t
argument_list|)
argument_list|)
decl_stmt|;
name|automatic_merge_t
modifier|*
name|merge
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|merge
argument_list|)
argument_list|)
decl_stmt|;
comment|/* "Open" the target WC.  Check the target WC for mixed-rev, local mods and    * switched subtrees yet to faster exit and notify user before contacting    * with server.  After we find out what kind of merge is required, then if a    * reintegrate-like merge is required we'll do the stricter checks, in    * do_automatic_merge_locked(). */
name|SVN_ERR
argument_list|(
name|open_target_wc
argument_list|(
operator|&
name|s_t
operator|->
name|target
argument_list|,
name|target_abspath
argument_list|,
name|allow_mixed_rev
argument_list|,
name|allow_local_mods
argument_list|,
name|allow_switched_subtrees
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open RA sessions to the source and target trees. */
name|SVN_ERR
argument_list|(
name|svn_client_open_ra_session2
argument_list|(
operator|&
name|s_t
operator|->
name|target_ra_session
argument_list|,
name|s_t
operator|->
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|s_t
operator|->
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### check for null URL (i.e. added path) here, like in reintegrate? */
name|SVN_ERR
argument_list|(
name|svn_client__ra_session_from_path2
argument_list|(
operator|&
name|s_t
operator|->
name|source_ra_session
argument_list|,
operator|&
name|s_t
operator|->
name|source
argument_list|,
name|source_path_or_url
argument_list|,
name|NULL
argument_list|,
name|source_revision
argument_list|,
name|source_revision
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check source is in same repos as target. */
name|SVN_ERR
argument_list|(
name|check_same_repos
argument_list|(
name|s_t
operator|->
name|source
argument_list|,
name|source_path_or_url
argument_list|,
operator|&
name|s_t
operator|->
name|target
operator|->
name|loc
argument_list|,
name|target_abspath
argument_list|,
name|TRUE
comment|/* strict_urls */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|find_automatic_merge
argument_list|(
operator|&
name|merge
operator|->
name|base
argument_list|,
operator|&
name|merge
operator|->
name|is_reintegrate_like
argument_list|,
name|s_t
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|merge
operator|->
name|yca
operator|=
name|s_t
operator|->
name|yca
expr_stmt|;
name|merge
operator|->
name|right
operator|=
name|s_t
operator|->
name|source
expr_stmt|;
name|merge
operator|->
name|allow_mixed_rev
operator|=
name|allow_mixed_rev
expr_stmt|;
name|merge
operator|->
name|allow_local_mods
operator|=
name|allow_local_mods
expr_stmt|;
name|merge
operator|->
name|allow_switched_subtrees
operator|=
name|allow_switched_subtrees
expr_stmt|;
operator|*
name|merge_p
operator|=
name|merge
expr_stmt|;
comment|/* TODO: Close the source and target sessions here? */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform an automatic merge, given the information in MERGE which  * must have come from calling client_find_automatic_merge().  *  * Four locations are inputs: YCA, BASE, RIGHT, TARGET, as shown  * depending on whether the base is on the source branch or the target  * branch of this merge.  *  *                            RIGHT     (is_reintegrate_like)  *          o-----------o-------o---  *         /    prev.  /         \  *   -----o     merge /           \  this  *     YCA \         /             \ merge  *          o-------o---------------o  *                BASE            TARGET  *  * or  *  *                BASE        RIGHT      (! is_reintegrate_like)  *          o-------o-----------o---  *         /         \           \  *   -----o     prev. \           \  this  *     YCA \    merge  \           \ merge  *          o-----------o-----------o  *                                TARGET  *  * ### TODO: The reintegrate-like code path does not yet  * eliminate already-cherry-picked revisions from the source.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_automatic_merge_locked
parameter_list|(
name|conflict_report_t
modifier|*
modifier|*
name|conflict_report
parameter_list|,
specifier|const
name|automatic_merge_t
modifier|*
name|merge
parameter_list|,
specifier|const
name|char
modifier|*
name|target_abspath
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|diff_ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|force_delete
parameter_list|,
name|svn_boolean_t
name|record_only
parameter_list|,
name|svn_boolean_t
name|dry_run
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|merge_options
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|merge_target_t
modifier|*
name|target
decl_stmt|;
name|svn_boolean_t
name|reintegrate_like
init|=
name|merge
operator|->
name|is_reintegrate_like
decl_stmt|;
name|svn_boolean_t
name|use_sleep
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_target_wc
argument_list|(
operator|&
name|target
argument_list|,
name|target_abspath
argument_list|,
name|merge
operator|->
name|allow_mixed_rev
operator|&&
operator|!
name|reintegrate_like
argument_list|,
name|merge
operator|->
name|allow_local_mods
operator|&&
operator|!
name|reintegrate_like
argument_list|,
name|merge
operator|->
name|allow_switched_subtrees
operator|&&
operator|!
name|reintegrate_like
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|reintegrate_like
condition|)
block|{
name|merge_source_t
name|source
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|base_ra_session
init|=
name|NULL
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|right_ra_session
init|=
name|NULL
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|target_ra_session
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|record_only
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The required merge is reintegrate-like, "
literal|"and the record-only option "
literal|"cannot be used with this kind of merge"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|depth
operator|!=
name|svn_depth_unknown
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The required merge is reintegrate-like, "
literal|"and the depth option "
literal|"cannot be used with this kind of merge"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|force_delete
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The required merge is reintegrate-like, "
literal|"and the force_delete option "
literal|"cannot be used with this kind of merge"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|ensure_ra_session_url
argument_list|(
operator|&
name|base_ra_session
argument_list|,
name|merge
operator|->
name|base
operator|->
name|url
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_ra_session_url
argument_list|(
operator|&
name|right_ra_session
argument_list|,
name|merge
operator|->
name|right
operator|->
name|url
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|ensure_ra_session_url
argument_list|(
operator|&
name|target_ra_session
argument_list|,
name|target
operator|->
name|loc
operator|.
name|url
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for and reject any abnormalities -- such as revisions that        * have not yet been merged in the opposite direction -- that a        * 'reintegrate' merge would have rejected. */
block|{
name|merge_source_t
modifier|*
name|source2
decl_stmt|;
name|SVN_ERR
argument_list|(
name|find_reintegrate_merge
argument_list|(
operator|&
name|source2
argument_list|,
name|NULL
argument_list|,
name|right_ra_session
argument_list|,
name|merge
operator|->
name|right
argument_list|,
name|target_ra_session
argument_list|,
name|target
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|source
operator|.
name|loc1
operator|=
name|merge
operator|->
name|base
expr_stmt|;
name|source
operator|.
name|loc2
operator|=
name|merge
operator|->
name|right
expr_stmt|;
name|source
operator|.
name|ancestral
operator|=
operator|!
name|merge
operator|->
name|is_reintegrate_like
expr_stmt|;
name|err
operator|=
name|merge_cousins_and_supplement_mergeinfo
argument_list|(
name|conflict_report
argument_list|,
operator|&
name|use_sleep
argument_list|,
name|target
argument_list|,
name|base_ra_session
argument_list|,
name|right_ra_session
argument_list|,
operator|&
name|source
argument_list|,
name|merge
operator|->
name|yca
argument_list|,
name|TRUE
comment|/* same_repos */
argument_list|,
name|depth
argument_list|,
name|FALSE
comment|/*diff_ignore_ancestry*/
argument_list|,
name|force_delete
argument_list|,
name|record_only
argument_list|,
name|dry_run
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* ! merge->is_reintegrate_like */
block|{
comment|/* Ignoring the base that we found, we pass the YCA instead and let          do_merge() work out which subtrees need which revision ranges to          be merged.  This enables do_merge() to fill in revision-range          gaps that are older than the base that we calculated (which is          for the root path of the merge).           An improvement would be to change find_automatic_merge() to          find the base for each sutree, and then here use the oldest base          among all subtrees. */
name|apr_array_header_t
modifier|*
name|merge_sources
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|ra_session
init|=
name|NULL
decl_stmt|;
comment|/* Normalize our merge sources, do_merge() requires this.  See the          'MERGEINFO MERGE SOURCE NORMALIZATION' global comment. */
name|SVN_ERR
argument_list|(
name|ensure_ra_session_url
argument_list|(
operator|&
name|ra_session
argument_list|,
name|merge
operator|->
name|right
operator|->
name|url
argument_list|,
name|target
operator|->
name|abspath
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|normalize_merge_sources_internal
argument_list|(
operator|&
name|merge_sources
argument_list|,
name|merge
operator|->
name|right
argument_list|,
name|svn_rangelist__initialize
argument_list|(
name|merge
operator|->
name|yca
operator|->
name|rev
argument_list|,
name|merge
operator|->
name|right
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|ra_session
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|do_merge
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|conflict_report
argument_list|,
operator|&
name|use_sleep
argument_list|,
name|merge_sources
argument_list|,
name|target
argument_list|,
name|ra_session
argument_list|,
name|TRUE
comment|/*related*/
argument_list|,
name|TRUE
comment|/*same_repos*/
argument_list|,
name|FALSE
comment|/*ignore_mergeinfo*/
argument_list|,
name|diff_ignore_ancestry
argument_list|,
name|force_delete
argument_list|,
name|dry_run
argument_list|,
name|record_only
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|depth
argument_list|,
name|merge_options
argument_list|,
name|ctx
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|use_sleep
condition|)
name|svn_io_sleep_for_timestamps
argument_list|(
name|target_abspath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_client_get_merging_summary
parameter_list|(
name|svn_boolean_t
modifier|*
name|needs_reintegration
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|yca_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|yca_rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|base_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|base_rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|right_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|right_rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|target_url
parameter_list|,
name|svn_revnum_t
modifier|*
name|target_rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|repos_root_url
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|source_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path_or_url
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|target_revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|target_is_wc
decl_stmt|;
name|automatic_merge_t
modifier|*
name|merge
decl_stmt|;
name|target_is_wc
operator|=
operator|(
operator|!
name|svn_path_is_url
argument_list|(
name|target_path_or_url
argument_list|)
operator|)
operator|&&
operator|(
name|target_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
operator|||
name|target_revision
operator|->
name|kind
operator|==
name|svn_opt_revision_working
operator|)
expr_stmt|;
if|if
condition|(
name|target_is_wc
condition|)
name|SVN_ERR
argument_list|(
name|client_find_automatic_merge
argument_list|(
operator|&
name|merge
argument_list|,
name|source_path_or_url
argument_list|,
name|source_revision
argument_list|,
name|target_path_or_url
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|,
comment|/* allow_* */
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|find_automatic_merge_no_wc
argument_list|(
operator|&
name|merge
argument_list|,
name|source_path_or_url
argument_list|,
name|source_revision
argument_list|,
name|target_path_or_url
argument_list|,
name|target_revision
argument_list|,
name|ctx
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|needs_reintegration
condition|)
operator|*
name|needs_reintegration
operator|=
name|merge
operator|->
name|is_reintegrate_like
expr_stmt|;
if|if
condition|(
name|yca_url
condition|)
operator|*
name|yca_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|merge
operator|->
name|yca
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|yca_rev
condition|)
operator|*
name|yca_rev
operator|=
name|merge
operator|->
name|yca
operator|->
name|rev
expr_stmt|;
if|if
condition|(
name|base_url
condition|)
operator|*
name|base_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|merge
operator|->
name|base
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_rev
condition|)
operator|*
name|base_rev
operator|=
name|merge
operator|->
name|base
operator|->
name|rev
expr_stmt|;
if|if
condition|(
name|right_url
condition|)
operator|*
name|right_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|merge
operator|->
name|right
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|right_rev
condition|)
operator|*
name|right_rev
operator|=
name|merge
operator|->
name|right
operator|->
name|rev
expr_stmt|;
if|if
condition|(
name|target_url
condition|)
operator|*
name|target_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|merge
operator|->
name|target
operator|->
name|url
argument_list|)
expr_stmt|;
if|if
condition|(
name|target_rev
condition|)
operator|*
name|target_rev
operator|=
name|merge
operator|->
name|target
operator|->
name|rev
expr_stmt|;
if|if
condition|(
name|repos_root_url
condition|)
operator|*
name|repos_root_url
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|merge
operator|->
name|yca
operator|->
name|repos_root_url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

