begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cached_data.c --- cached (read) access to FSX data  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_ctype.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"fs_x.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"changes.h"
end_include

begin_include
include|#
directive|include
file|"noderevs.h"
end_include

begin_include
include|#
directive|include
file|"reps.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_delta/delta.h"
end_include

begin_comment
comment|/* for SVN_DELTA_WINDOW_SIZE */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* forward-declare. See implementation for the docstring */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|block_read
parameter_list|(
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|revision_file
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Defined this to enable access logging via dgb__log_access #define SVN_FS_X__LOG_ACCESS */
end_comment

begin_comment
comment|/* When SVN_FS_X__LOG_ACCESS has been defined, write a line to console  * showing where ID is located in FS and use ITEM to show details on it's  * contents if not NULL.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dgb__log_access
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|void
modifier|*
name|item
parameter_list|,
name|apr_uint32_t
name|item_type
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* no-op if this macro is not defined */
ifdef|#
directive|ifdef
name|SVN_FS_X__LOG_ACCESS
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|apr_off_t
name|end_offset
init|=
literal|0
decl_stmt|;
name|apr_uint32_t
name|sub_item
init|=
literal|0
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
name|NULL
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|types
index|[]
init|=
block|{
literal|"<n/a>"
block|,
literal|"frep "
block|,
literal|"drep "
block|,
literal|"fprop"
block|,
literal|"dprop"
block|,
literal|"node "
block|,
literal|"chgs "
block|,
literal|"rep  "
block|,
literal|"c:"
block|,
literal|"n:"
block|,
literal|"r:"
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|description
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|type
init|=
name|types
index|[
name|item_type
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|pack
init|=
literal|""
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
decl_stmt|;
comment|/* determine rev / pack file offset */
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* constructing the pack file description */
if|if
condition|(
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
condition|)
name|pack
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%4ld|"
argument_list|,
name|revision
operator|/
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
expr_stmt|;
comment|/* construct description if possible */
if|if
condition|(
name|item_type
operator|==
name|SVN_FS_X__ITEM_TYPE_NODEREV
operator|&&
name|item
operator|!=
name|NULL
condition|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|node
init|=
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|data_rep
init|=
name|node
operator|->
name|data_rep
condition|?
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|" d=%ld/%"
name|APR_UINT64_T_FMT
argument_list|,
name|svn_fs_x__get_revnum
argument_list|(
name|node
operator|->
name|data_rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
argument_list|,
name|node
operator|->
name|data_rep
operator|->
name|id
operator|.
name|number
argument_list|)
else|:
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_rep
init|=
name|node
operator|->
name|prop_rep
condition|?
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|" p=%ld/%"
name|APR_UINT64_T_FMT
argument_list|,
name|svn_fs_x__get_revnum
argument_list|(
name|node
operator|->
name|prop_rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
argument_list|,
name|node
operator|->
name|prop_rep
operator|->
name|id
operator|.
name|number
argument_list|)
else|:
literal|""
decl_stmt|;
name|description
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s   (pc=%d%s%s)"
argument_list|,
name|node
operator|->
name|created_path
argument_list|,
name|node
operator|->
name|predecessor_count
argument_list|,
name|data_rep
argument_list|,
name|prop_rep
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item_type
operator|==
name|SVN_FS_X__ITEM_TYPE_ANY_REP
condition|)
block|{
name|svn_fs_x__rep_header_t
modifier|*
name|header
init|=
name|item
decl_stmt|;
if|if
condition|(
name|header
operator|==
name|NULL
condition|)
name|description
operator|=
literal|"  (txdelta window)"
expr_stmt|;
elseif|else
if|if
condition|(
name|header
operator|->
name|type
operator|==
name|svn_fs_x__rep_self_delta
condition|)
name|description
operator|=
literal|"  DELTA"
expr_stmt|;
else|else
name|description
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"  DELTA against %ld/%"
name|APR_UINT64_T_FMT
argument_list|,
name|header
operator|->
name|base_revision
argument_list|,
name|header
operator|->
name|base_item_index
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|item_type
operator|==
name|SVN_FS_X__ITEM_TYPE_CHANGES
operator|&&
name|item
operator|!=
name|NULL
condition|)
block|{
name|apr_array_header_t
modifier|*
name|changes
init|=
name|item
decl_stmt|;
switch|switch
condition|(
name|changes
operator|->
name|nelts
condition|)
block|{
case|case
literal|0
case|:
name|description
operator|=
literal|"  no change"
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|description
operator|=
literal|"  1 change"
expr_stmt|;
break|break;
default|default:
name|description
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"  %d changes"
argument_list|,
name|changes
operator|->
name|nelts
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* reverse index lookup: get item description in ENTRY */
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_entry_lookup
argument_list|(
operator|&
name|entry
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
comment|/* more details */
name|end_offset
operator|=
name|offset
operator|+
name|entry
operator|->
name|size
expr_stmt|;
name|type
operator|=
name|types
index|[
name|entry
operator|->
name|type
index|]
expr_stmt|;
comment|/* merge the sub-item number with the container type */
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_CHANGES_CONT
operator|||
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_NODEREVS_CONT
operator|||
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_REPS_CONT
condition|)
name|type
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%s%-3d"
argument_list|,
name|type
argument_list|,
name|sub_item
argument_list|)
expr_stmt|;
block|}
comment|/* line output */
name|printf
argument_list|(
literal|"%5s%4lx:%04lx -%4lx:%04lx %s %7ld %5"
name|APR_UINT64_T_FMT
literal|"   %s\n"
argument_list|,
name|pack
argument_list|,
call|(
name|long
call|)
argument_list|(
name|offset
operator|/
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|offset
operator|%
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|end_offset
operator|/
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
call|(
name|long
call|)
argument_list|(
name|end_offset
operator|%
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|,
name|type
argument_list|,
name|revision
argument_list|,
name|id
operator|->
name|number
argument_list|,
name|description
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Convenience wrapper around svn_io_file_aligned_seek, taking filesystem    FS instead of a block size. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|aligned_seek
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|apr_off_t
modifier|*
name|buffer_start
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|file
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|buffer_start
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open the revision file for the item given by ID in filesystem FS and    store the newly opened file in FILE.  Seek to the item's location before    returning.     Allocate the result in RESULT_POOL and temporaries in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_revision
parameter_list|(
name|svn_fs_x__revision_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_off_t
name|offset
init|=
operator|-
literal|1
decl_stmt|;
name|apr_uint32_t
name|sub_item
init|=
literal|0
decl_stmt|;
name|svn_revnum_t
name|rev
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file
operator|=
name|rev_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the representation REP for a node-revision in filesystem FS, seek    to its position and store the newly opened file in FILE.     Allocate the result in RESULT_POOL and temporaries in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_transaction
parameter_list|(
name|svn_fs_x__revision_file_t
modifier|*
modifier|*
name|file
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|apr_uint32_t
name|sub_item
init|=
literal|0
decl_stmt|;
name|apr_int64_t
name|txn_id
init|=
name|svn_fs_x__get_txn_id
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_proto_rev_file
argument_list|(
name|file
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
operator|*
name|file
argument_list|,
operator|&
name|rep
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
operator|(
operator|*
name|file
operator|)
operator|->
name|file
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given a node-id ID, and a representation REP in filesystem FS, open    the correct file and seek to the correction location.  Store this    file in *FILE_P.     Allocate the result in RESULT_POOL and temporaries in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_and_seek_representation
parameter_list|(
name|svn_fs_x__revision_file_t
modifier|*
modifier|*
name|file_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|svn_fs_x__is_revision
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
condition|)
return|return
name|open_and_seek_revision
argument_list|(
name|file_p
argument_list|,
name|fs
argument_list|,
operator|&
name|rep
operator|->
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
else|else
return|return
name|open_and_seek_transaction
argument_list|(
name|file_p
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|err_dangling_id
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_x__id_unparse
argument_list|(
name|id
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_ID_NOT_FOUND
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Reference to non-existent node '%s' in filesystem '%s'"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the node-revision for the node ID in FS.    Set *NODEREV_P to the new node-revision structure, allocated in POOL.    See svn_fs_x__get_node_revision, which wraps this and adds another    error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_revision_body
parameter_list|(
name|svn_fs_x__noderev_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|svn_fs_x__is_txn
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
condition|)
block|{
name|apr_file_t
modifier|*
name|file
decl_stmt|;
comment|/* This is a transaction node-rev.  Its storage logic is very          different from that of rev / pack files. */
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|svn_fs_x__path_txn_node_rev
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err_dangling_id
argument_list|(
name|fs
argument_list|,
name|id
argument_list|)
argument_list|)
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_noderev
argument_list|(
name|noderev_p
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_x__revision_file_t
modifier|*
name|revision_file
decl_stmt|;
comment|/* noderevs in rev / pack files can be cached */
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* First, try a noderevs container cache lookup. */
if|if
condition|(
name|svn_fs_x__is_packed_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
operator|&&
name|ffd
operator|->
name|noderevs_container_cache
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|noderev_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|noderevs_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|svn_fs_x__noderevs_get_func
argument_list|,
operator|&
name|sub_item
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|key
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|id
operator|->
name|number
expr_stmt|;
comment|/* Not found or not applicable. Try a noderev cache lookup.        * If that succeeds, we are done here. */
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|noderev_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|node_revision_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* block-read will parse the whole block and will also return          the one noderev that we need right now. */
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|noderev_p
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|revision_file
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__close_revision_file
argument_list|(
name|revision_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_node_revision
parameter_list|(
name|svn_fs_x__noderev_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|get_node_revision_body
argument_list|(
name|noderev_p
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
condition|)
block|{
name|svn_string_t
modifier|*
name|id_string
init|=
name|svn_fs_x__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
literal|"Corrupt node-revision '%s'"
argument_list|,
name|id_string
operator|->
name|data
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|dgb__log_access
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
operator|*
name|noderev_p
argument_list|,
name|SVN_FS_X__ITEM_TYPE_NODEREV
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_mergeinfo_count
parameter_list|(
name|apr_int64_t
modifier|*
name|count
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* If we want a full acccess log, we need to provide full data and      cannot take shortcuts here. */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|SVN_FS_X__LOG_ACCESS
argument_list|)
comment|/* First, try a noderevs container cache lookup. */
if|if
condition|(
operator|!
name|svn_fs_x__is_txn
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
condition|)
block|{
comment|/* noderevs in rev / pack files can be cached */
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_x__is_packed_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
operator|&&
name|ffd
operator|->
name|noderevs_container_cache
condition|)
block|{
name|svn_fs_x__pair_cache_key_t
name|key
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|count
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|noderevs_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|svn_fs_x__mergeinfo_count_get_func
argument_list|,
operator|&
name|sub_item
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
endif|#
directive|endif
comment|/* fallback to the naive implementation handling all edge cases */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|noderev
operator|->
name|mergeinfo_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Describes a lazily opened rev / pack file.  Instances will be shared    between multiple instances of rep_state_t. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|shared_file_t
block|{
comment|/* The opened file. NULL while file is not open, yet. */
name|svn_fs_x__revision_file_t
modifier|*
name|rfile
decl_stmt|;
comment|/* file system to open the file in */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* a revision contained in the FILE.  Since this file may be shared,      that value may be different from REP_STATE_T->REVISION. */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* pool to use when creating the FILE.  This guarantees that the file      remains open / valid beyond the respective local context that required      the file to be opened eventually. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|shared_file_t
typedef|;
end_typedef

begin_comment
comment|/* Represents where in the current svndiff data block each    representation is. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rep_state_t
block|{
comment|/* shared lazy-open rev/pack file structure */
name|shared_file_t
modifier|*
name|sfile
decl_stmt|;
comment|/* The txdelta window cache to use or NULL. */
name|svn_cache__t
modifier|*
name|window_cache
decl_stmt|;
comment|/* Caches un-deltified windows. May be NULL. */
name|svn_cache__t
modifier|*
name|combined_cache
decl_stmt|;
comment|/* ID addressing the representation */
name|svn_fs_x__id_t
name|rep_id
decl_stmt|;
comment|/* length of the header at the start of the rep.                        0 iff this is rep is stored in a container                        (i.e. does not have a header) */
name|apr_size_t
name|header_size
decl_stmt|;
name|apr_off_t
name|start
decl_stmt|;
comment|/* The starting offset for the raw                        svndiff data minus header.                        -1 if the offset is yet unknown. */
comment|/* sub-item index in case the rep is containered */
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|apr_off_t
name|current
decl_stmt|;
comment|/* The current offset relative to START. */
name|apr_off_t
name|size
decl_stmt|;
comment|/* The on-disk size of the representation. */
name|int
name|ver
decl_stmt|;
comment|/* If a delta, what svndiff version?                        -1 for unknown delta version. */
name|int
name|chunk_index
decl_stmt|;
comment|/* number of the window to read */
block|}
name|rep_state_t
typedef|;
end_typedef

begin_comment
comment|/* Simple wrapper around svn_fs_x__get_file_offset to simplify callers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_file_offset
parameter_list|(
name|apr_off_t
modifier|*
name|offset
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|svn_fs_x__get_file_offset
argument_list|(
name|offset
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Simple wrapper around svn_io_file_aligned_seek to simplify callers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rs_aligned_seek
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_off_t
modifier|*
name|buffer_start
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|rs
operator|->
name|sfile
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_io_file_aligned_seek
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|buffer_start
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Open FILE->FILE and FILE->STREAM if they haven't been opened, yet. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_open_shared_file
parameter_list|(
name|shared_file_t
modifier|*
name|file
parameter_list|)
block|{
if|if
condition|(
name|file
operator|->
name|rfile
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|file
operator|->
name|rfile
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|file
operator|->
name|revision
argument_list|,
name|file
operator|->
name|pool
argument_list|,
name|file
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set RS->START to the begin of the representation raw in RS->SFILE->RFILE,    if that hasn't been done yet.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_set_start_offset
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|start
operator|==
operator|-
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|rs
operator|->
name|start
argument_list|,
operator|&
name|rs
operator|->
name|sub_item
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|fs
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
operator|&
name|rs
operator|->
name|rep_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|start
operator|+=
name|rs
operator|->
name|header_size
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set RS->VER depending on what is found in the already open RS->FILE->FILE    if the diff version is still unknown.  Use SCRATCH_POOL for temporary    allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_read_diff_version
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|ver
operator|==
operator|-
literal|1
condition|)
block|{
name|char
name|buf
index|[
literal|4
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|rs
operator|->
name|start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### Layering violation */
if|if
condition|(
operator|!
operator|(
operator|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'S'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'V'
operator|)
operator|&&
operator|(
name|buf
index|[
literal|2
index|]
operator|==
literal|'N'
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Malformed svndiff data in representation"
argument_list|)
argument_list|)
return|;
name|rs
operator|->
name|ver
operator|=
name|buf
index|[
literal|3
index|]
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|current
operator|=
literal|4
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* See create_rep_state, which wraps this and adds another error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_rep_state_body
parameter_list|(
name|rep_state_t
modifier|*
modifier|*
name|rep_state
parameter_list|,
name|svn_fs_x__rep_header_t
modifier|*
modifier|*
name|rep_header
parameter_list|,
name|shared_file_t
modifier|*
modifier|*
name|shared_file
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rs
argument_list|)
argument_list|)
decl_stmt|;
name|svn_fs_x__rep_header_t
modifier|*
name|rh
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|apr_uint64_t
name|estimated_window_storage
decl_stmt|;
comment|/* If the hint is    * - given,    * - refers to a valid revision,    * - refers to a packed revision,    * - as does the rep we want to read, and    * - refers to the same pack file as the rep    * we can re-use the same, already open file object    */
name|svn_boolean_t
name|reuse_shared_file
init|=
name|shared_file
operator|&&
operator|*
name|shared_file
operator|&&
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|rfile
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|revision
argument_list|)
operator|&&
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|&&
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
operator|&&
operator|(
operator|(
operator|(
operator|*
name|shared_file
operator|)
operator|->
name|revision
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|==
operator|(
name|revision
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|)
decl_stmt|;
name|svn_fs_x__representation_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|key
operator|.
name|is_packed
operator|=
name|revision
operator|<
name|ffd
operator|->
name|min_unpacked_rev
expr_stmt|;
name|key
operator|.
name|item_index
operator|=
name|rep
operator|->
name|id
operator|.
name|number
expr_stmt|;
comment|/* continue constructing RS and RA */
name|rs
operator|->
name|size
operator|=
name|rep
operator|->
name|size
expr_stmt|;
name|rs
operator|->
name|rep_id
operator|=
name|rep
operator|->
name|id
expr_stmt|;
name|rs
operator|->
name|ver
operator|=
operator|-
literal|1
expr_stmt|;
name|rs
operator|->
name|start
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* Very long files stored as self-delta will produce a huge number of      delta windows.  Don't cache them lest we don't thrash the cache.      Since we don't know the depth of the delta chain, let's assume, the      whole contents get rewritten 3 times.    */
name|estimated_window_storage
operator|=
literal|4
operator|*
operator|(
operator|(
name|rep
operator|->
name|expanded_size
condition|?
name|rep
operator|->
name|expanded_size
else|:
name|rep
operator|->
name|size
operator|)
operator|+
name|SVN_DELTA_WINDOW_SIZE
operator|)
expr_stmt|;
name|estimated_window_storage
operator|=
name|MIN
argument_list|(
name|estimated_window_storage
argument_list|,
name|APR_SIZE_MAX
argument_list|)
expr_stmt|;
name|rs
operator|->
name|window_cache
operator|=
name|ffd
operator|->
name|txdelta_window_cache
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|txdelta_window_cache
argument_list|,
operator|(
name|apr_size_t
operator|)
name|estimated_window_storage
argument_list|)
condition|?
name|ffd
operator|->
name|txdelta_window_cache
else|:
name|NULL
expr_stmt|;
name|rs
operator|->
name|combined_cache
operator|=
name|ffd
operator|->
name|combined_window_cache
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|combined_window_cache
argument_list|,
operator|(
name|apr_size_t
operator|)
name|estimated_window_storage
argument_list|)
condition|?
name|ffd
operator|->
name|combined_window_cache
else|:
name|NULL
expr_stmt|;
comment|/* cache lookup, i.e. skip reading the rep header if possible */
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|rh
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|rep_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* initialize the (shared) FILE member in RS */
if|if
condition|(
name|reuse_shared_file
condition|)
block|{
name|rs
operator|->
name|sfile
operator|=
operator|*
name|shared_file
expr_stmt|;
block|}
else|else
block|{
name|shared_file_t
modifier|*
name|file
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|file
argument_list|)
argument_list|)
decl_stmt|;
name|file
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|file
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|file
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|rs
operator|->
name|sfile
operator|=
name|file
expr_stmt|;
comment|/* remember the current file, if suggested by the caller */
if|if
condition|(
name|shared_file
condition|)
operator|*
name|shared_file
operator|=
name|file
expr_stmt|;
block|}
comment|/* read rep header, if necessary */
if|if
condition|(
operator|!
name|is_cached
condition|)
block|{
comment|/* we will need the on-disk location for non-txn reps */
name|apr_off_t
name|offset
decl_stmt|;
name|svn_boolean_t
name|in_container
init|=
name|TRUE
decl_stmt|;
comment|/* ensure file is open and navigate to the start of rep header */
if|if
condition|(
name|reuse_shared_file
condition|)
block|{
comment|/* ... we can re-use the same, already open file object.            * This implies that we don't read from a txn.            */
name|rs
operator|->
name|sfile
operator|=
operator|*
name|shared_file
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_open_shared_file
argument_list|(
name|rs
operator|->
name|sfile
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* otherwise, create a new file object.  May or may not be            * an in-txn file.            */
name|SVN_ERR
argument_list|(
name|open_and_seek_representation
argument_list|(
operator|&
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
operator|&
name|rep
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is rep stored in some star-deltified container? */
if|if
condition|(
name|sub_item
operator|==
literal|0
condition|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_entry_lookup
argument_list|(
operator|&
name|entry
argument_list|,
name|fs
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|in_container
operator|=
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_REPS_CONT
expr_stmt|;
block|}
if|if
condition|(
name|in_container
condition|)
block|{
comment|/* construct a container rep header */
operator|*
name|rep_header
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rep_header
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|rep_header
operator|)
operator|->
name|type
operator|=
name|svn_fs_x__rep_container
expr_stmt|;
comment|/* exit to caller */
operator|*
name|rep_state
operator|=
name|rs
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_rep_header
argument_list|(
operator|&
name|rh
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|rs
operator|->
name|start
argument_list|,
name|rs
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* populate the cache if appropriate */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
name|NULL
argument_list|,
name|fs
argument_list|,
operator|&
name|rs
operator|->
name|rep_id
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|rep_header_cache
argument_list|,
operator|&
name|key
argument_list|,
name|rh
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* finalize */
name|SVN_ERR
argument_list|(
name|dgb__log_access
argument_list|(
name|fs
argument_list|,
operator|&
name|rs
operator|->
name|rep_id
argument_list|,
name|rh
argument_list|,
name|SVN_FS_X__ITEM_TYPE_ANY_REP
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|header_size
operator|=
name|rh
operator|->
name|header_size
expr_stmt|;
operator|*
name|rep_state
operator|=
name|rs
expr_stmt|;
operator|*
name|rep_header
operator|=
name|rh
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
comment|/* skip "SVNx" diff marker */
name|rs
operator|->
name|current
operator|=
literal|4
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the rep args for REP in filesystem FS and create a rep_state    for reading the representation.  Return the rep_state in *REP_STATE    and the rep args in *REP_ARGS, both allocated in POOL.     When reading multiple reps, i.e. a skip delta chain, you may provide    non-NULL SHARED_FILE.  (If SHARED_FILE is not NULL, in the first    call it should be a pointer to NULL.)  The function will use this    variable to store the previous call results and tries to re-use it.    This may result in significant savings in I/O for packed files and    number of open file handles.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_rep_state
parameter_list|(
name|rep_state_t
modifier|*
modifier|*
name|rep_state
parameter_list|,
name|svn_fs_x__rep_header_t
modifier|*
modifier|*
name|rep_header
parameter_list|,
name|shared_file_t
modifier|*
modifier|*
name|shared_file
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|create_rep_state_body
argument_list|(
name|rep_state
argument_list|,
name|rep_header
argument_list|,
name|shared_file
argument_list|,
name|rep
argument_list|,
name|fs
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CORRUPT
condition|)
block|{
comment|/* ### This always returns "-1" for transaction reps, because          ### this particular bit of code doesn't know if the rep is          ### stored in the protorev or in the mutable area (for props          ### or dir contents).  It is pretty rare for FSX to *read*          ### from the protorev file, though, so this is probably OK.          ### And anyone going to debug corruption errors is probably          ### going to jump straight to this comment anyway! */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
literal|"Corrupt representation '%s'"
argument_list|,
name|rep
condition|?
name|svn_fs_x__unparse_representation
argument_list|(
name|rep
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
else|:
literal|"(null)"
argument_list|)
return|;
block|}
comment|/* ### Call representation_string() ? */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__check_rep
parameter_list|(
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Does REP->ID refer to an actual item? Which one is it? */
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
operator|&
name|rep
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* What is the type of that item? */
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_entry_lookup
argument_list|(
operator|&
name|entry
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Verify that we've got an item that is actually a representation. */
if|if
condition|(
name|entry
operator|==
name|NULL
operator|||
operator|(
name|entry
operator|->
name|type
operator|!=
name|SVN_FS_X__ITEM_TYPE_FILE_REP
operator|&&
name|entry
operator|->
name|type
operator|!=
name|SVN_FS_X__ITEM_TYPE_DIR_REP
operator|&&
name|entry
operator|->
name|type
operator|!=
name|SVN_FS_X__ITEM_TYPE_FILE_PROPS
operator|&&
name|entry
operator|->
name|type
operator|!=
name|SVN_FS_X__ITEM_TYPE_DIR_PROPS
operator|&&
name|entry
operator|->
name|type
operator|!=
name|SVN_FS_X__ITEM_TYPE_REPS_CONT
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No representation found at offset %s "
literal|"for item %s in revision %ld"
argument_list|)
argument_list|,
name|apr_off_t_toa
argument_list|(
name|scratch_pool
argument_list|,
name|offset
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_UINT64_T_FMT
argument_list|,
name|rep
operator|->
name|id
operator|.
name|number
argument_list|)
argument_list|,
name|revision
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* .    Do any allocations in POOL. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__rep_chain_length
parameter_list|(
name|int
modifier|*
name|chain_length
parameter_list|,
name|int
modifier|*
name|shard_count
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|shard_size
init|=
name|ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|svn_boolean_t
name|is_delta
init|=
name|FALSE
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|int
name|shards
init|=
literal|1
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|last_shard
init|=
name|revision
operator|/
name|shard_size
decl_stmt|;
comment|/* Note that this iteration pool will be used in a non-standard way.    * To reuse open file handles between iterations (e.g. while within the    * same pack file), we only clear this pool once in a while instead of    * at the start of each iteration. */
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Check whether the length of the deltification chain is acceptable.    * Otherwise, shared reps may form a non-skipping delta chain in    * extreme cases. */
name|svn_fs_x__representation_t
name|base_rep
init|=
operator|*
name|rep
decl_stmt|;
comment|/* re-use open files between iterations */
name|shared_file_t
modifier|*
name|file_hint
init|=
name|NULL
decl_stmt|;
name|svn_fs_x__rep_header_t
modifier|*
name|header
decl_stmt|;
comment|/* follow the delta chain towards the end but for at most    * MAX_CHAIN_LENGTH steps. */
do|do
block|{
name|rep_state_t
modifier|*
name|rep_state
decl_stmt|;
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|base_rep
operator|.
name|id
operator|.
name|change_set
argument_list|)
expr_stmt|;
if|if
condition|(
name|revision
operator|/
name|shard_size
operator|!=
name|last_shard
condition|)
block|{
name|last_shard
operator|=
name|revision
operator|/
name|shard_size
expr_stmt|;
operator|++
name|shards
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|create_rep_state_body
argument_list|(
operator|&
name|rep_state
argument_list|,
operator|&
name|header
argument_list|,
operator|&
name|file_hint
argument_list|,
operator|&
name|base_rep
argument_list|,
name|fs
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|base_rep
operator|.
name|id
operator|.
name|change_set
operator|=
name|svn_fs_x__change_set_by_rev
argument_list|(
name|header
operator|->
name|base_revision
argument_list|)
expr_stmt|;
name|base_rep
operator|.
name|id
operator|.
name|number
operator|=
name|header
operator|->
name|base_item_index
expr_stmt|;
name|base_rep
operator|.
name|size
operator|=
name|header
operator|->
name|base_length
expr_stmt|;
name|is_delta
operator|=
name|header
operator|->
name|type
operator|==
name|svn_fs_x__rep_delta
expr_stmt|;
comment|/* Clear it the ITERPOOL once in a while.  Doing it too frequently        * renders the FILE_HINT ineffective.  Doing too infrequently, may        * leave us with too many open file handles.        *        * Note that this is mostly about efficiency, with larger values        * being more efficient, and any non-zero value is legal here.  When        * reading deltified contents, we may keep 10s of rev files open at        * the same time and the system has to cope with that.  Thus, the        * limit of 16 chosen below is in the same ballpark.        */
operator|++
name|count
expr_stmt|;
if|if
condition|(
name|count
operator|%
literal|16
operator|==
literal|0
condition|)
block|{
name|file_hint
operator|=
name|NULL
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|is_delta
operator|&&
name|base_rep
operator|.
name|id
operator|.
name|change_set
condition|)
do|;
operator|*
name|chain_length
operator|=
name|count
expr_stmt|;
operator|*
name|shard_count
operator|=
name|shards
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|rep_read_baton_t
block|{
comment|/* The FS from which we're reading. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* Representation to read. */
name|svn_fs_x__representation_t
name|rep
decl_stmt|;
comment|/* If not NULL, this is the base for the first delta window in rs_list */
name|svn_stringbuf_t
modifier|*
name|base_window
decl_stmt|;
comment|/* The state of all prior delta representations. */
name|apr_array_header_t
modifier|*
name|rs_list
decl_stmt|;
comment|/* The plaintext state, if there is a plaintext. */
name|rep_state_t
modifier|*
name|src_state
decl_stmt|;
comment|/* The index of the current delta chunk, if we are reading a delta. */
name|int
name|chunk_index
decl_stmt|;
comment|/* The buffer where we store undeltified data. */
name|char
modifier|*
name|buf
decl_stmt|;
name|apr_size_t
name|buf_pos
decl_stmt|;
name|apr_size_t
name|buf_len
decl_stmt|;
comment|/* A checksum context for summing the data read in order to verify it.      Note: we don't need to use the sha1 checksum because we're only doing      data verification, for which md5 is perfectly safe.  */
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
name|svn_boolean_t
name|checksum_finalized
decl_stmt|;
comment|/* The stored checksum of the representation we are reading, its      length, and the amount we've read so far.  Some of this      information is redundant with rs_list and src_state, but it's      convenient for the checksumming code to have it here. */
name|unsigned
name|char
name|md5_digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
name|svn_filesize_t
name|len
decl_stmt|;
name|svn_filesize_t
name|off
decl_stmt|;
comment|/* The key for the fulltext cache for this rep, if there is a      fulltext cache. */
name|svn_fs_x__pair_cache_key_t
name|fulltext_cache_key
decl_stmt|;
comment|/* The text we've been reading, if we're going to cache it. */
name|svn_stringbuf_t
modifier|*
name|current_fulltext
decl_stmt|;
comment|/* If not NULL, attempt to read the data from this cache.      Once that lookup fails, reset it to NULL. */
name|svn_cache__t
modifier|*
name|fulltext_cache
decl_stmt|;
comment|/* Bytes delivered from the FULLTEXT_CACHE so far.  If the next      lookup fails, we need to skip that much data from the reconstructed      window stream before we continue normal operation. */
name|svn_filesize_t
name|fulltext_delivered
decl_stmt|;
comment|/* Used for temporary allocations during the read. */
name|apr_pool_t
modifier|*
name|scratch_pool
decl_stmt|;
comment|/* Pool used to store file handles and other data that is persistant      for the entire stream read. */
name|apr_pool_t
modifier|*
name|filehandle_pool
decl_stmt|;
block|}
name|rep_read_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Set window key in *KEY to address the window described by RS.    For convenience, return the KEY. */
end_comment

begin_function
specifier|static
name|svn_fs_x__window_cache_key_t
modifier|*
name|get_window_key
parameter_list|(
name|svn_fs_x__window_cache_key_t
modifier|*
name|key
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|)
block|{
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|rs
operator|->
name|rep_id
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|assert
argument_list|(
name|revision
operator|<=
name|APR_UINT32_MAX
argument_list|)
expr_stmt|;
name|key
operator|->
name|revision
operator|=
operator|(
name|apr_uint32_t
operator|)
name|revision
expr_stmt|;
name|key
operator|->
name|item_index
operator|=
name|rs
operator|->
name|rep_id
operator|.
name|number
expr_stmt|;
name|key
operator|->
name|chunk_index
operator|=
name|rs
operator|->
name|chunk_index
expr_stmt|;
return|return
name|key
return|;
block|}
end_function

begin_comment
comment|/* Read the WINDOW_P number CHUNK_INDEX for the representation given in  * rep state RS from the current FSX session's cache.  This will be a  * no-op and IS_CACHED will be set to FALSE if no cache has been given.  * If a cache is available IS_CACHED will inform the caller about the  * success of the lookup. Allocations (of the window in particualar) will  * be made from POOL.  *  * If the information could be found, put RS to CHUNK_INDEX.  */
end_comment

begin_comment
comment|/* Return data type for get_cached_window_sizes_func.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|window_sizes_t
block|{
comment|/* length of the txdelta window in its on-disk format */
name|svn_filesize_t
name|packed_len
decl_stmt|;
comment|/* expanded (and combined) window length */
name|svn_filesize_t
name|target_len
decl_stmt|;
block|}
name|window_sizes_t
typedef|;
end_typedef

begin_comment
comment|/* Implements svn_cache__partial_getter_func_t extracting the packed  * and expanded window sizes from a cached window and return the size  * info as a window_sizes_t* in *OUT.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_window_sizes_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_x__txdelta_cached_window_t
modifier|*
name|window
init|=
name|data
decl_stmt|;
specifier|const
name|svn_txdelta_window_t
modifier|*
name|txdelta_window
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|window
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|window
operator|->
name|window
argument_list|)
decl_stmt|;
name|window_sizes_t
modifier|*
name|result
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|packed_len
operator|=
name|window
operator|->
name|end_offset
operator|-
name|window
operator|->
name|start_offset
expr_stmt|;
name|result
operator|->
name|target_len
operator|=
name|txdelta_window
operator|->
name|tview_len
expr_stmt|;
operator|*
name|out
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the WINDOW_P number CHUNK_INDEX for the representation given in  * rep state RS from the current FSFS session's cache.  This will be a  * no-op and IS_CACHED will be set to FALSE if no cache has been given.  * If a cache is available IS_CACHED will inform the caller about the  * success of the lookup. Allocations of the window in will be made  * from RESULT_POOL. Use SCRATCH_POOL for temporary allocations.  *  * If the information could be found, put RS to CHUNK_INDEX.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_window_sizes
parameter_list|(
name|window_sizes_t
modifier|*
modifier|*
name|sizes
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|->
name|window_cache
condition|)
block|{
comment|/* txdelta window has not been enabled */
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_x__window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|sizes
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|window_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
name|get_cached_window_sizes_func
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|int
name|chunk_index
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|->
name|window_cache
condition|)
block|{
comment|/* txdelta window has not been enabled */
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* ask the cache for the desired txdelta window */
name|svn_fs_x__txdelta_cached_window_t
modifier|*
name|cached_window
decl_stmt|;
name|svn_fs_x__window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
expr_stmt|;
name|key
operator|.
name|chunk_index
operator|=
name|chunk_index
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|cached_window
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|window_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|is_cached
condition|)
block|{
comment|/* found it. Pass it back to the caller. */
operator|*
name|window_p
operator|=
name|cached_window
operator|->
name|window
expr_stmt|;
comment|/* manipulate the RS as if we just read the data */
name|rs
operator|->
name|current
operator|=
name|cached_window
operator|->
name|end_offset
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
name|chunk_index
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store the WINDOW read for the rep state RS with the given START_OFFSET  * within the pack / rev file in the current FSX session's cache.  This  * will be a no-op if no cache has been given.  * Temporary allocations will be made from SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_cached_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_off_t
name|start_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|window_cache
condition|)
block|{
comment|/* store the window and the first offset _past_ it */
name|svn_fs_x__txdelta_cached_window_t
name|cached_window
decl_stmt|;
name|svn_fs_x__window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|cached_window
operator|.
name|window
operator|=
name|window
expr_stmt|;
name|cached_window
operator|.
name|start_offset
operator|=
name|start_offset
operator|-
name|rs
operator|->
name|start
expr_stmt|;
name|cached_window
operator|.
name|end_offset
operator|=
name|rs
operator|->
name|current
expr_stmt|;
comment|/* but key it with the start offset because that is the known state        * when we will look it up */
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|window_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
operator|&
name|cached_window
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the WINDOW_P for the rep state RS from the current FSX session's  * cache. This will be a no-op and IS_CACHED will be set to FALSE if no  * cache has been given. If a cache is available IS_CACHED will inform  * the caller about the success of the lookup. Allocations (of the window  * in particular) will be made from POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_cached_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_cached
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rs
operator|->
name|combined_cache
condition|)
block|{
comment|/* txdelta window has not been enabled */
operator|*
name|is_cached
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* ask the cache for the desired txdelta window */
name|svn_fs_x__window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
return|return
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|window_p
argument_list|,
name|is_cached
argument_list|,
name|rs
operator|->
name|combined_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
name|pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Store the WINDOW read for the rep state RS in the current FSX session's  * cache. This will be a no-op if no cache has been given.  * Temporary allocations will be made from SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_cached_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|window
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|rs
operator|->
name|combined_cache
condition|)
block|{
comment|/* but key it with the start offset because that is the known state        * when we will look it up */
name|svn_fs_x__window_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|rs
operator|->
name|combined_cache
argument_list|,
name|get_window_key
argument_list|(
operator|&
name|key
argument_list|,
name|rs
argument_list|)
argument_list|,
name|window
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Build an array of rep_state structures in *LIST giving the delta    reps from first_rep to a  self-compressed rep.  Set *SRC_STATE to    the container rep we find at the end of the chain, or to NULL if    the final delta representation is self-compressed.    The representation to start from is designated by filesystem FS, id    ID, and representation REP.    Also, set *WINDOW_P to the base window content for *LIST, if it    could be found in cache. Otherwise, *LIST will contain the base    representation for the whole delta chain.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build_rep_list
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|list
parameter_list|,
name|svn_stringbuf_t
modifier|*
modifier|*
name|window_p
parameter_list|,
name|rep_state_t
modifier|*
modifier|*
name|src_state
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|first_rep
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__representation_t
name|rep
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
init|=
name|NULL
decl_stmt|;
name|svn_fs_x__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|shared_file_t
modifier|*
name|shared_file
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|list
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_state_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|rep
operator|=
operator|*
name|first_rep
expr_stmt|;
comment|/* for the top-level rep, we need the rep_args */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_header
argument_list|,
operator|&
name|shared_file
argument_list|,
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* fetch state, if that has not been done already */
if|if
condition|(
operator|!
name|rs
condition|)
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
operator|&
name|rep_header
argument_list|,
operator|&
name|shared_file
argument_list|,
operator|&
name|rep
argument_list|,
name|fs
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for txn reps and containered reps, there won't be a cached        * combined window */
if|if
condition|(
name|svn_fs_x__is_revision
argument_list|(
name|rep
operator|.
name|id
operator|.
name|change_set
argument_list|)
operator|&&
name|rep_header
operator|->
name|type
operator|!=
name|svn_fs_x__rep_container
condition|)
name|SVN_ERR
argument_list|(
name|get_cached_combined_window
argument_list|(
name|window_p
argument_list|,
name|rs
argument_list|,
operator|&
name|is_cached
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
comment|/* We already have a reconstructed window in our cache.              Write a pseudo rep_state with the full length. */
name|rs
operator|->
name|start
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|current
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|size
operator|=
operator|(
operator|*
name|window_p
operator|)
operator|->
name|len
expr_stmt|;
operator|*
name|src_state
operator|=
name|rs
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_x__rep_container
condition|)
block|{
comment|/* This is a container item, so just return the current rep_state. */
operator|*
name|src_state
operator|=
name|rs
expr_stmt|;
break|break;
block|}
comment|/* Push this rep onto the list.  If it's self-compressed, we're done. */
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|list
argument_list|,
name|rep_state_t
operator|*
argument_list|)
operator|=
name|rs
expr_stmt|;
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_x__rep_self_delta
condition|)
block|{
operator|*
name|src_state
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
name|rep
operator|.
name|id
operator|.
name|change_set
operator|=
name|svn_fs_x__change_set_by_rev
argument_list|(
name|rep_header
operator|->
name|base_revision
argument_list|)
expr_stmt|;
name|rep
operator|.
name|id
operator|.
name|number
operator|=
name|rep_header
operator|->
name|base_item_index
expr_stmt|;
name|rep
operator|.
name|size
operator|=
name|rep_header
operator|->
name|base_length
expr_stmt|;
name|rs
operator|=
name|NULL
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a rep_read_baton structure for node revision NODEREV in    filesystem FS and store it in *RB_P.  If FULLTEXT_CACHE_KEY is not    NULL, it is the rep's key in the fulltext cache, and a stringbuf    must be allocated to store the text.  If rep is mutable, it must be    refer to file contents.     Allocate the result in RESULT_POOL.  This includes the pools within *RB_P.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_get_baton
parameter_list|(
name|rep_read_baton_t
modifier|*
modifier|*
name|rb_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|svn_fs_x__pair_cache_key_t
name|fulltext_cache_key
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|rep_read_baton_t
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|->
name|rep
operator|=
operator|*
name|rep
expr_stmt|;
name|b
operator|->
name|base_window
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|checksum_finalized
operator|=
name|FALSE
expr_stmt|;
name|memcpy
argument_list|(
name|b
operator|->
name|md5_digest
argument_list|,
name|rep
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|len
operator|=
name|rep
operator|->
name|expanded_size
expr_stmt|;
name|b
operator|->
name|off
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|fulltext_cache_key
operator|=
name|fulltext_cache_key
expr_stmt|;
comment|/* Clearable sub-pools.  Since they have to remain valid for as long as B      lives, we can't take them from some scratch pool.  The caller of this      function will have no control over how those subpools will be used. */
name|b
operator|->
name|scratch_pool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|filehandle_pool
operator|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|b
operator|->
name|fulltext_cache
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|fulltext_delivered
operator|=
literal|0
expr_stmt|;
name|b
operator|->
name|current_fulltext
operator|=
name|NULL
expr_stmt|;
comment|/* Save our output baton. */
operator|*
name|rb_p
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Skip forwards to THIS_CHUNK in REP_STATE and then read the next delta    window into *NWIN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_delta_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|nwin
parameter_list|,
name|int
name|this_chunk
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|apr_off_t
name|start_offset
decl_stmt|;
name|apr_off_t
name|end_offset
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|rs
operator|->
name|chunk_index
operator|<=
name|this_chunk
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dgb__log_access
argument_list|(
name|rs
operator|->
name|sfile
operator|->
name|fs
argument_list|,
operator|&
name|rs
operator|->
name|rep_id
argument_list|,
name|NULL
argument_list|,
name|SVN_FS_X__ITEM_TYPE_ANY_REP
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the next window.  But first, try to find it in the cache. */
name|SVN_ERR
argument_list|(
name|get_cached_window
argument_list|(
name|nwin
argument_list|,
name|rs
argument_list|,
name|this_chunk
argument_list|,
operator|&
name|is_cached
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* someone has to actually read the data from file.  Open it */
name|SVN_ERR
argument_list|(
name|auto_open_shared_file
argument_list|(
name|rs
operator|->
name|sfile
argument_list|)
argument_list|)
expr_stmt|;
comment|/* invoke the 'block-read' feature for non-txn data.      However, don't do that if we are in the middle of some representation,      because the block is unlikely to contain other data. */
if|if
condition|(
name|rs
operator|->
name|chunk_index
operator|==
literal|0
operator|&&
name|svn_fs_x__is_revision
argument_list|(
name|rs
operator|->
name|rep_id
operator|.
name|change_set
argument_list|)
operator|&&
name|rs
operator|->
name|window_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
name|NULL
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|fs
argument_list|,
operator|&
name|rs
operator|->
name|rep_id
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* reading the whole block probably also provided us with the          desired txdelta window */
name|SVN_ERR
argument_list|(
name|get_cached_window
argument_list|(
name|nwin
argument_list|,
name|rs
argument_list|,
name|this_chunk
argument_list|,
operator|&
name|is_cached
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* data is still not cached -> we need to read it.      Make sure we have all the necessary info. */
name|SVN_ERR
argument_list|(
name|auto_set_start_offset
argument_list|(
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|auto_read_diff_version
argument_list|(
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RS->FILE may be shared between RS instances -> make sure we point    * to the right data. */
name|start_offset
operator|=
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
expr_stmt|;
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
name|NULL
argument_list|,
name|start_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Skip windows to reach the current chunk if we aren't there yet. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|rs
operator|->
name|chunk_index
operator|<
name|this_chunk
condition|)
block|{
name|apr_file_t
modifier|*
name|file
init|=
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_skip_svndiff_window
argument_list|(
name|file
argument_list|,
name|rs
operator|->
name|ver
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_file_offset
argument_list|(
operator|&
name|start_offset
argument_list|,
name|file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|current
operator|=
name|start_offset
operator|-
name|rs
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|current
operator|>=
name|rs
operator|->
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read "
literal|"beyond the end of the "
literal|"representation"
argument_list|)
argument_list|)
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Actually read the next window. */
name|SVN_ERR
argument_list|(
name|svn_txdelta_read_svndiff_window
argument_list|(
name|nwin
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|stream
argument_list|,
name|rs
operator|->
name|ver
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_file_offset
argument_list|(
operator|&
name|end_offset
argument_list|,
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|current
operator|=
name|end_offset
operator|-
name|rs
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|current
operator|>
name|rs
operator|->
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read beyond "
literal|"the end of the representation"
argument_list|)
argument_list|)
return|;
comment|/* the window has not been cached before, thus cache it now    * (if caching is used for them at all) */
if|if
condition|(
name|svn_fs_x__is_revision
argument_list|(
name|rs
operator|->
name|rep_id
operator|.
name|change_set
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|set_cached_window
argument_list|(
operator|*
name|nwin
argument_list|,
name|rs
argument_list|,
name|start_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the whole representation RS and return it in *NWIN. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_container_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|nwin
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__rep_extractor_t
modifier|*
name|extractor
init|=
name|NULL
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|rs
operator|->
name|sfile
operator|->
name|fs
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|rs
operator|->
name|rep_id
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|auto_set_start_offset
argument_list|(
name|rs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rs
operator|->
name|start
expr_stmt|;
comment|/* already in cache? */
if|if
condition|(
name|ffd
operator|->
name|reps_container_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|svn_fs_x__reps_baton_t
name|baton
decl_stmt|;
name|baton
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|baton
operator|.
name|idx
operator|=
name|rs
operator|->
name|sub_item
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|extractor
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|reps_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|svn_fs_x__reps_get_func
argument_list|,
operator|&
name|baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* read from disk, if necessary */
if|if
condition|(
name|extractor
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|auto_open_shared_file
argument_list|(
name|rs
operator|->
name|sfile
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|extractor
argument_list|,
name|fs
argument_list|,
operator|&
name|rs
operator|->
name|rep_id
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_x__extractor_drive
argument_list|(
name|nwin
argument_list|,
name|extractor
argument_list|,
name|rs
operator|->
name|current
argument_list|,
name|size
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update RS. */
name|rs
operator|->
name|current
operator|+=
operator|(
name|apr_off_t
operator|)
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the undeltified window that is a result of combining all deltas    from the current desired representation identified in *RB with its    base representation.  Store the window in *RESULT. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_combined_window
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|result
parameter_list|,
name|rep_read_baton_t
modifier|*
name|rb
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|,
modifier|*
name|new_pool
decl_stmt|,
modifier|*
name|window_pool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|windows
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|source
decl_stmt|,
modifier|*
name|buf
init|=
name|rb
operator|->
name|base_window
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Read all windows that we need to combine. This is fine because      the size of each window is relatively small (100kB) and skip-      delta limits the number of deltas in a chain to well under 100.      Stop early if one of them does not depend on its predecessors. */
name|window_pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|windows
operator|=
name|apr_array_make
argument_list|(
name|window_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_txdelta_window_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rb
operator|->
name|rs_list
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
name|i
argument_list|,
name|rep_state_t
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_delta_window
argument_list|(
operator|&
name|window
argument_list|,
name|rb
operator|->
name|chunk_index
argument_list|,
name|rs
argument_list|,
name|window_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|windows
argument_list|,
name|svn_txdelta_window_t
operator|*
argument_list|)
operator|=
name|window
expr_stmt|;
if|if
condition|(
name|window
operator|->
name|src_ops
operator|==
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* Combine in the windows from the other delta reps. */
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
operator|--
name|i
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
name|i
argument_list|,
name|rep_state_t
operator|*
argument_list|)
expr_stmt|;
name|window
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|windows
argument_list|,
name|i
argument_list|,
name|svn_txdelta_window_t
operator|*
argument_list|)
expr_stmt|;
comment|/* Maybe, we've got a start representation in a container.  If we do,          read as much data from it as the needed for the txdelta window's          source view.          Note that BUF / SOURCE may only be NULL in the first iteration. */
name|source
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|source
operator|==
name|NULL
operator|&&
name|rb
operator|->
name|src_state
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|read_container_window
argument_list|(
operator|&
name|source
argument_list|,
name|rb
operator|->
name|src_state
argument_list|,
name|window
operator|->
name|sview_len
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Combine this window with the current one. */
name|new_pool
operator|=
name|svn_pool_create
argument_list|(
name|rb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|buf
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|window
operator|->
name|tview_len
argument_list|,
name|new_pool
argument_list|)
expr_stmt|;
name|buf
operator|->
name|len
operator|=
name|window
operator|->
name|tview_len
expr_stmt|;
name|svn_txdelta_apply_instructions
argument_list|(
name|window
argument_list|,
name|source
condition|?
name|source
operator|->
name|data
else|:
name|NULL
argument_list|,
name|buf
operator|->
name|data
argument_list|,
operator|&
name|buf
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|!=
name|window
operator|->
name|tview_len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"svndiff window length is "
literal|"corrupt"
argument_list|)
argument_list|)
return|;
comment|/* Cache windows only if the whole rep content could be read as a          single chunk.  Only then will no other chunk need a deeper RS          list than the cached chunk. */
if|if
condition|(
operator|(
name|rb
operator|->
name|chunk_index
operator|==
literal|0
operator|)
operator|&&
operator|(
name|rs
operator|->
name|current
operator|==
name|rs
operator|->
name|size
operator|)
operator|&&
name|svn_fs_x__is_revision
argument_list|(
name|rs
operator|->
name|rep_id
operator|.
name|change_set
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|set_cached_combined_window
argument_list|(
name|buf
argument_list|,
name|rs
argument_list|,
name|new_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
comment|/* Cycle pools so that we only need to hold three windows at a time. */
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|pool
operator|=
name|new_pool
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|window_pool
argument_list|)
expr_stmt|;
operator|*
name|result
operator|=
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Returns whether or not the expanded fulltext of the file is cachable  * based on its size SIZE.  The decision depends on the cache used by RB.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|fulltext_size_is_cachable
parameter_list|(
name|svn_fs_x__data_t
modifier|*
name|ffd
parameter_list|,
name|svn_filesize_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|size
operator|<
name|APR_SIZE_MAX
operator|)
operator|&&
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|(
name|apr_size_t
operator|)
name|size
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close method used on streams returned by read_representation().  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_contents_close
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|rep_read_baton_t
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|rb
operator|->
name|filehandle_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Inialize the representation read state RS for the given REP_HEADER and  * p2l index ENTRY.  If not NULL, assign FILE and STREAM to RS.  * Allocate all sub-structures of RS in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|init_rep_state
parameter_list|(
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|svn_fs_x__rep_header_t
modifier|*
name|rep_header
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|shared_file_t
modifier|*
name|shared_file
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shared_file
argument_list|)
argument_list|)
decl_stmt|;
comment|/* this function does not apply to representation containers */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|type
operator|>=
name|SVN_FS_X__ITEM_TYPE_FILE_REP
operator|&&
name|entry
operator|->
name|type
operator|<=
name|SVN_FS_X__ITEM_TYPE_DIR_PROPS
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|item_count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|shared_file
operator|->
name|rfile
operator|=
name|rev_file
expr_stmt|;
name|shared_file
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|shared_file
operator|->
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|shared_file
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|rs
operator|->
name|sfile
operator|=
name|shared_file
expr_stmt|;
name|rs
operator|->
name|rep_id
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
name|rs
operator|->
name|header_size
operator|=
name|rep_header
operator|->
name|header_size
expr_stmt|;
name|rs
operator|->
name|start
operator|=
name|entry
operator|->
name|offset
operator|+
name|rs
operator|->
name|header_size
expr_stmt|;
name|rs
operator|->
name|current
operator|=
literal|4
expr_stmt|;
name|rs
operator|->
name|size
operator|=
name|entry
operator|->
name|size
operator|-
name|rep_header
operator|->
name|header_size
operator|-
literal|7
expr_stmt|;
name|rs
operator|->
name|ver
operator|=
literal|1
expr_stmt|;
name|rs
operator|->
name|chunk_index
operator|=
literal|0
expr_stmt|;
name|rs
operator|->
name|window_cache
operator|=
name|ffd
operator|->
name|txdelta_window_cache
expr_stmt|;
name|rs
operator|->
name|combined_cache
operator|=
name|ffd
operator|->
name|combined_window_cache
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Walk through all windows in the representation addressed by RS in FS  * (excluding the delta bases) and put those not already cached into the  * window caches.  If MAX_OFFSET is not -1, don't read windows that start  * at or beyond that offset.  As a side effect, return the total sum of all  * expanded window sizes in *FULLTEXT_LEN.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cache_windows
parameter_list|(
name|svn_filesize_t
modifier|*
name|fulltext_len
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|rep_state_t
modifier|*
name|rs
parameter_list|,
name|apr_off_t
name|max_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|fulltext_len
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|rs
operator|->
name|current
operator|<
name|rs
operator|->
name|size
condition|)
block|{
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|window_sizes_t
modifier|*
name|window_sizes
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_offset
operator|!=
operator|-
literal|1
operator|&&
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
operator|>=
name|max_offset
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* efficiently skip windows that are still being cached instead        * of fully decoding them */
name|SVN_ERR
argument_list|(
name|get_cached_window_sizes
argument_list|(
operator|&
name|window_sizes
argument_list|,
name|rs
argument_list|,
operator|&
name|is_cached
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
block|{
operator|*
name|fulltext_len
operator|+=
name|window_sizes
operator|->
name|target_len
expr_stmt|;
name|rs
operator|->
name|current
operator|+=
name|window_sizes
operator|->
name|packed_len
expr_stmt|;
block|}
else|else
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|apr_off_t
name|start_offset
init|=
name|rs
operator|->
name|start
operator|+
name|rs
operator|->
name|current
decl_stmt|;
name|apr_off_t
name|end_offset
decl_stmt|;
name|apr_off_t
name|block_start
decl_stmt|;
comment|/* navigate to& read the current window */
name|SVN_ERR
argument_list|(
name|rs_aligned_seek
argument_list|(
name|rs
argument_list|,
operator|&
name|block_start
argument_list|,
name|start_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_txdelta_read_svndiff_window
argument_list|(
operator|&
name|window
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|stream
argument_list|,
name|rs
operator|->
name|ver
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* aggregate expanded window size */
operator|*
name|fulltext_len
operator|+=
name|window
operator|->
name|tview_len
expr_stmt|;
comment|/* determine on-disk window size */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_file_offset
argument_list|(
operator|&
name|end_offset
argument_list|,
name|rs
operator|->
name|sfile
operator|->
name|rfile
operator|->
name|file
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|current
operator|=
name|end_offset
operator|-
name|rs
operator|->
name|start
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|current
operator|>
name|rs
operator|->
name|size
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Reading one svndiff window read beyond "
literal|"the end of the representation"
argument_list|)
argument_list|)
return|;
comment|/* if the window has not been cached before, cache it now            * (if caching is used for them at all) */
if|if
condition|(
operator|!
name|is_cached
condition|)
name|SVN_ERR
argument_list|(
name|set_cached_window
argument_list|(
name|window
argument_list|,
name|rs
argument_list|,
name|start_offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Try to get the representation header identified by KEY from FS's cache.  * If it has not been cached, read it from the current position in STREAM  * and put it into the cache (if caching has been enabled for rep headers).  * Return the result in *REP_HEADER.  Use POOL for allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_rep_header
parameter_list|(
name|svn_fs_x__rep_header_t
modifier|*
modifier|*
name|rep_header
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_fs_x__representation_cache_key_t
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|rep_header
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|rep_header_cache
argument_list|,
name|key
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_rep_header
argument_list|(
name|rep_header
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|rep_header_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|rep_header_cache
argument_list|,
name|key
argument_list|,
operator|*
name|rep_header
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_representation_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|packed_len
parameter_list|,
name|svn_filesize_t
modifier|*
name|expanded_len
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__representation_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|rep_state_t
name|rs
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_fs_x__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
comment|/* this function does not apply to representation containers */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|type
operator|>=
name|SVN_FS_X__ITEM_TYPE_FILE_REP
operator|&&
name|entry
operator|->
name|type
operator|<=
name|SVN_FS_X__ITEM_TYPE_DIR_PROPS
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|item_count
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* get / read the representation header */
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|key
operator|.
name|is_packed
operator|=
name|svn_fs_x__is_packed_rev
argument_list|(
name|fs
argument_list|,
name|key
operator|.
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|item_index
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_rep_header
argument_list|(
operator|&
name|rep_header
argument_list|,
name|fs
argument_list|,
name|rev_file
operator|->
name|stream
argument_list|,
operator|&
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* prepare representation reader state (rs) structure */
name|SVN_ERR
argument_list|(
name|init_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
name|rep_header
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* RS->SFILE may be shared between RS instances -> make sure we point    * to the right data. */
operator|*
name|packed_len
operator|=
name|rs
operator|.
name|size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cache_windows
argument_list|(
name|expanded_len
argument_list|,
name|fs
argument_list|,
operator|&
name|rs
argument_list|,
operator|-
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the next *LEN bytes of the rep from our plain / delta windows    and store them in *BUF. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_contents_from_windows
parameter_list|(
name|rep_read_baton_t
modifier|*
name|rb
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|apr_size_t
name|copy_len
decl_stmt|,
name|remaining
init|=
operator|*
name|len
decl_stmt|;
name|char
modifier|*
name|cur
init|=
name|buf
decl_stmt|;
name|rep_state_t
modifier|*
name|rs
decl_stmt|;
comment|/* Special case for when there are no delta reps, only a      containered text. */
if|if
condition|(
name|rb
operator|->
name|rs_list
operator|->
name|nelts
operator|==
literal|0
operator|&&
name|rb
operator|->
name|buf
operator|==
name|NULL
condition|)
block|{
name|copy_len
operator|=
name|remaining
expr_stmt|;
name|rs
operator|=
name|rb
operator|->
name|src_state
expr_stmt|;
comment|/* reps in containers don't have a header */
if|if
condition|(
name|rs
operator|->
name|header_size
operator|==
literal|0
operator|&&
name|rb
operator|->
name|base_window
operator|==
name|NULL
condition|)
block|{
comment|/* RS->SIZE is unreliable here because it is based upon            * the delta rep size _before_ putting the data into a            * a container. */
name|SVN_ERR
argument_list|(
name|read_container_window
argument_list|(
operator|&
name|rb
operator|->
name|base_window
argument_list|,
name|rs
argument_list|,
name|rb
operator|->
name|len
argument_list|,
name|rb
operator|->
name|scratch_pool
argument_list|,
name|rb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rs
operator|->
name|current
operator|-=
name|rb
operator|->
name|base_window
operator|->
name|len
expr_stmt|;
block|}
if|if
condition|(
name|rb
operator|->
name|base_window
operator|!=
name|NULL
condition|)
block|{
comment|/* We got the desired rep directly from the cache.              This is where we need the pseudo rep_state created              by build_rep_list(). */
name|apr_size_t
name|offset
init|=
operator|(
name|apr_size_t
operator|)
name|rs
operator|->
name|current
decl_stmt|;
if|if
condition|(
name|copy_len
operator|+
name|offset
operator|>
name|rb
operator|->
name|base_window
operator|->
name|len
condition|)
name|copy_len
operator|=
name|offset
operator|<
name|rb
operator|->
name|base_window
operator|->
name|len
condition|?
name|rb
operator|->
name|base_window
operator|->
name|len
operator|-
name|offset
else|:
literal|0ul
expr_stmt|;
name|memcpy
argument_list|(
name|cur
argument_list|,
name|rb
operator|->
name|base_window
operator|->
name|data
operator|+
name|offset
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
block|}
name|rs
operator|->
name|current
operator|+=
name|copy_len
expr_stmt|;
operator|*
name|len
operator|=
name|copy_len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
while|while
condition|(
name|remaining
operator|>
literal|0
condition|)
block|{
comment|/* If we have buffered data from a previous chunk, use that. */
if|if
condition|(
name|rb
operator|->
name|buf
condition|)
block|{
comment|/* Determine how much to copy from the buffer. */
name|copy_len
operator|=
name|rb
operator|->
name|buf_len
operator|-
name|rb
operator|->
name|buf_pos
expr_stmt|;
if|if
condition|(
name|copy_len
operator|>
name|remaining
condition|)
name|copy_len
operator|=
name|remaining
expr_stmt|;
comment|/* Actually copy the data. */
name|memcpy
argument_list|(
name|cur
argument_list|,
name|rb
operator|->
name|buf
operator|+
name|rb
operator|->
name|buf_pos
argument_list|,
name|copy_len
argument_list|)
expr_stmt|;
name|rb
operator|->
name|buf_pos
operator|+=
name|copy_len
expr_stmt|;
name|cur
operator|+=
name|copy_len
expr_stmt|;
name|remaining
operator|-=
name|copy_len
expr_stmt|;
comment|/* If the buffer is all used up, clear it and empty the              local pool. */
if|if
condition|(
name|rb
operator|->
name|buf_pos
operator|==
name|rb
operator|->
name|buf_len
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|rb
operator|->
name|scratch_pool
argument_list|)
expr_stmt|;
name|rb
operator|->
name|buf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
else|else
block|{
name|svn_stringbuf_t
modifier|*
name|sbuf
init|=
name|NULL
decl_stmt|;
name|rs
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rb
operator|->
name|rs_list
argument_list|,
literal|0
argument_list|,
name|rep_state_t
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|rs
operator|->
name|current
operator|==
name|rs
operator|->
name|size
condition|)
break|break;
comment|/* Get more buffered data by evaluating a chunk. */
name|SVN_ERR
argument_list|(
name|get_combined_window
argument_list|(
operator|&
name|sbuf
argument_list|,
name|rb
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|chunk_index
operator|++
expr_stmt|;
name|rb
operator|->
name|buf_len
operator|=
name|sbuf
operator|->
name|len
expr_stmt|;
name|rb
operator|->
name|buf
operator|=
name|sbuf
operator|->
name|data
expr_stmt|;
name|rb
operator|->
name|buf_pos
operator|=
literal|0
expr_stmt|;
block|}
block|}
operator|*
name|len
operator|=
name|cur
operator|-
name|buf
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton type for get_fulltext_partial. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fulltext_baton_t
block|{
comment|/* Target buffer to write to; of at least LEN bytes. */
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Offset within the respective fulltext at which we shall start to      copy data into BUFFER. */
name|apr_size_t
name|start
decl_stmt|;
comment|/* Number of bytes to copy.  The actual amount may be less in case      the fulltext is short(er). */
name|apr_size_t
name|len
decl_stmt|;
comment|/* Number of bytes actually copied into BUFFER. */
name|apr_size_t
name|read
decl_stmt|;
block|}
name|fulltext_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Implement svn_cache__partial_getter_func_t for fulltext caches.  * From the fulltext in DATA, we copy the range specified by the  * fulltext_baton_t* BATON into the buffer provided by that baton.  * OUT and RESULT_POOL are not used.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_fulltext_partial
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|fulltext_baton_t
modifier|*
name|fulltext_baton
init|=
name|baton
decl_stmt|;
comment|/* We cached the fulltext with an NUL appended to it. */
name|apr_size_t
name|fulltext_len
init|=
name|data_len
operator|-
literal|1
decl_stmt|;
comment|/* Clip the copy range to what the fulltext size allows. */
name|apr_size_t
name|start
init|=
name|MIN
argument_list|(
name|fulltext_baton
operator|->
name|start
argument_list|,
name|fulltext_len
argument_list|)
decl_stmt|;
name|fulltext_baton
operator|->
name|read
operator|=
name|MIN
argument_list|(
name|fulltext_len
operator|-
name|start
argument_list|,
name|fulltext_baton
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Copy the data to the output buffer and be done. */
name|memcpy
argument_list|(
name|fulltext_baton
operator|->
name|buffer
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
operator|+
name|start
argument_list|,
name|fulltext_baton
operator|->
name|read
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the fulltext specified in BATON in the fulltext cache given  * as well by BATON.  If that succeeds, set *CACHED to TRUE and copy  * up to the next *LEN bytes into BUFFER.  Set *LEN to the actual  * number of bytes copied.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_contents_from_fulltext
parameter_list|(
name|svn_boolean_t
modifier|*
name|cached
parameter_list|,
name|rep_read_baton_t
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|void
modifier|*
name|dummy
decl_stmt|;
name|fulltext_baton_t
name|fulltext_baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|apr_size_t
operator|)
name|baton
operator|->
name|fulltext_delivered
operator|==
name|baton
operator|->
name|fulltext_delivered
argument_list|)
expr_stmt|;
name|fulltext_baton
operator|.
name|buffer
operator|=
name|buffer
expr_stmt|;
name|fulltext_baton
operator|.
name|start
operator|=
operator|(
name|apr_size_t
operator|)
name|baton
operator|->
name|fulltext_delivered
expr_stmt|;
name|fulltext_baton
operator|.
name|len
operator|=
operator|*
name|len
expr_stmt|;
name|fulltext_baton
operator|.
name|read
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|&
name|dummy
argument_list|,
name|cached
argument_list|,
name|baton
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|baton
operator|->
name|fulltext_cache_key
argument_list|,
name|get_fulltext_partial
argument_list|,
operator|&
name|fulltext_baton
argument_list|,
name|baton
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cached
condition|)
block|{
name|baton
operator|->
name|fulltext_delivered
operator|+=
name|fulltext_baton
operator|.
name|read
expr_stmt|;
operator|*
name|len
operator|=
name|fulltext_baton
operator|.
name|read
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Determine the optimal size of a string buf that shall receive a  * (full-) text of NEEDED bytes.  *  * The critical point is that those buffers may be very large and  * can cause memory fragmentation.  We apply simple heuristics to  * make fragmentation less likely.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|optimimal_allocation_size
parameter_list|(
name|apr_size_t
name|needed
parameter_list|)
block|{
comment|/* For all allocations, assume some overhead that is shared between    * OS memory managemnt, APR memory management and svn_stringbuf_t. */
specifier|const
name|apr_size_t
name|overhead
init|=
literal|0x400
decl_stmt|;
name|apr_size_t
name|optimal
decl_stmt|;
comment|/* If an allocation size if safe for other ephemeral buffers, it should    * be safe for ours. */
if|if
condition|(
name|needed
operator|<=
name|SVN__STREAM_CHUNK_SIZE
condition|)
return|return
name|needed
return|;
comment|/* Paranoia edge case:    * Skip our heuristics if they created arithmetical overflow.    * Beware to make this test work for NEEDED = APR_SIZE_MAX as well! */
if|if
condition|(
name|needed
operator|>=
name|APR_SIZE_MAX
operator|/
literal|2
operator|-
name|overhead
condition|)
return|return
name|needed
return|;
comment|/* As per definition SVN__STREAM_CHUNK_SIZE is a power of two.    * Since we know NEEDED to be larger than that, use it as the    * starting point.    *    * Heuristics: Allocate a power-of-two number of bytes that fit    *             NEEDED plus some OVERHEAD.  The APR allocator    *             will round it up to the next full page size.    */
name|optimal
operator|=
name|SVN__STREAM_CHUNK_SIZE
expr_stmt|;
while|while
condition|(
name|optimal
operator|-
name|overhead
operator|<
name|needed
condition|)
name|optimal
operator|*=
literal|2
expr_stmt|;
comment|/* This is above or equal to NEEDED. */
return|return
name|optimal
operator|-
name|overhead
return|;
block|}
end_function

begin_comment
comment|/* After a fulltext cache lookup failure, we will continue to read from  * combined delta or plain windows.  However, we must first make that data  * stream in BATON catch up tho the position LEN already delivered from the  * fulltext cache.  Also, we need to store the reconstructed fulltext if we  * want to cache it at the end.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skip_contents
parameter_list|(
name|rep_read_baton_t
modifier|*
name|baton
parameter_list|,
name|svn_filesize_t
name|len
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Do we want to cache the reconstructed fulltext? */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|baton
operator|->
name|fulltext_cache_key
operator|.
name|revision
argument_list|)
condition|)
block|{
name|char
modifier|*
name|buffer
decl_stmt|;
name|svn_filesize_t
name|to_alloc
init|=
name|MAX
argument_list|(
name|len
argument_list|,
name|baton
operator|->
name|len
argument_list|)
decl_stmt|;
comment|/* This should only be happening if BATON->LEN and LEN are        * cacheable, implying they fit into memory. */
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|apr_size_t
operator|)
name|to_alloc
operator|==
name|to_alloc
argument_list|)
expr_stmt|;
comment|/* Allocate the fulltext buffer. */
name|baton
operator|->
name|current_fulltext
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|optimimal_allocation_size
argument_list|(
operator|(
name|apr_size_t
operator|)
name|to_alloc
argument_list|)
argument_list|,
name|baton
operator|->
name|filehandle_pool
argument_list|)
expr_stmt|;
comment|/* Read LEN bytes from the window stream and store the data        * in the fulltext buffer (will be filled by further reads later). */
name|baton
operator|->
name|current_fulltext
operator|->
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|len
expr_stmt|;
name|baton
operator|->
name|current_fulltext
operator|->
name|data
index|[
operator|(
name|apr_size_t
operator|)
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|buffer
operator|=
name|baton
operator|->
name|current_fulltext
operator|->
name|data
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|!
name|err
condition|)
block|{
name|apr_size_t
name|to_read
init|=
operator|(
name|apr_size_t
operator|)
name|len
decl_stmt|;
name|err
operator|=
name|get_contents_from_windows
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
operator|&
name|to_read
argument_list|)
expr_stmt|;
name|len
operator|-=
name|to_read
expr_stmt|;
name|buffer
operator|+=
name|to_read
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Simply drain LEN bytes from the window stream. */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|baton
operator|->
name|scratch_pool
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
name|SVN__STREAM_CHUNK_SIZE
argument_list|)
decl_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
operator|&&
operator|!
name|err
condition|)
block|{
name|apr_size_t
name|to_read
init|=
name|len
operator|>
name|SVN__STREAM_CHUNK_SIZE
condition|?
name|SVN__STREAM_CHUNK_SIZE
else|:
operator|(
name|apr_size_t
operator|)
name|len
decl_stmt|;
name|err
operator|=
name|get_contents_from_windows
argument_list|(
name|baton
argument_list|,
name|buffer
argument_list|,
operator|&
name|to_read
argument_list|)
expr_stmt|;
name|len
operator|-=
name|to_read
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* BATON is of type `rep_read_baton_t'; read the next *LEN bytes of the    representation and store them in *BUF.  Sum as we read and verify    the MD5 sum at the end. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rep_read_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|rep_read_baton_t
modifier|*
name|rb
init|=
name|baton
decl_stmt|;
comment|/* Get data from the fulltext cache for as long as we can. */
if|if
condition|(
name|rb
operator|->
name|fulltext_cache
condition|)
block|{
name|svn_boolean_t
name|cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_contents_from_fulltext
argument_list|(
operator|&
name|cached
argument_list|,
name|rb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Cache miss.  From now on, we will never read from the fulltext        * cache for this representation anymore. */
name|rb
operator|->
name|fulltext_cache
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* No fulltext cache to help us.  We must read from the window stream. */
if|if
condition|(
operator|!
name|rb
operator|->
name|rs_list
condition|)
block|{
comment|/* Window stream not initialized, yet.  Do it now. */
name|SVN_ERR
argument_list|(
name|build_rep_list
argument_list|(
operator|&
name|rb
operator|->
name|rs_list
argument_list|,
operator|&
name|rb
operator|->
name|base_window
argument_list|,
operator|&
name|rb
operator|->
name|src_state
argument_list|,
name|rb
operator|->
name|fs
argument_list|,
operator|&
name|rb
operator|->
name|rep
argument_list|,
name|rb
operator|->
name|filehandle_pool
argument_list|,
name|rb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In case we did read from the fulltext cache before, make the        * window stream catch up.  Also, initialize the fulltext buffer        * if we want to cache the fulltext at the end. */
name|SVN_ERR
argument_list|(
name|skip_contents
argument_list|(
name|rb
argument_list|,
name|rb
operator|->
name|fulltext_delivered
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Get the next block of data. */
name|SVN_ERR
argument_list|(
name|get_contents_from_windows
argument_list|(
name|rb
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|current_fulltext
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|rb
operator|->
name|current_fulltext
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
comment|/* Perform checksumming.  We want to check the checksum as soon as      the last byte of data is read, in case the caller never performs      a short read, but we don't want to finalize the MD5 context      twice. */
if|if
condition|(
operator|!
name|rb
operator|->
name|checksum_finalized
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|buf
argument_list|,
operator|*
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|off
operator|+=
operator|*
name|len
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|off
operator|==
name|rb
operator|->
name|len
condition|)
block|{
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|svn_checksum_t
name|expected
decl_stmt|;
name|expected
operator|.
name|kind
operator|=
name|svn_checksum_md5
expr_stmt|;
name|expected
operator|.
name|digest
operator|=
name|rb
operator|->
name|md5_digest
expr_stmt|;
name|rb
operator|->
name|checksum_finalized
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|md5_checksum
argument_list|,
name|rb
operator|->
name|md5_checksum_ctx
argument_list|,
name|rb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|md5_checksum
argument_list|,
operator|&
name|expected
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|svn_checksum_mismatch_err
argument_list|(
operator|&
name|expected
argument_list|,
name|md5_checksum
argument_list|,
name|rb
operator|->
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch while reading representation"
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
if|if
condition|(
name|rb
operator|->
name|off
operator|==
name|rb
operator|->
name|len
operator|&&
name|rb
operator|->
name|current_fulltext
condition|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|rb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|rb
operator|->
name|fulltext_cache_key
argument_list|,
name|rb
operator|->
name|current_fulltext
argument_list|,
name|rb
operator|->
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|->
name|current_fulltext
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|svn_boolean_t
name|cache_fulltext
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|if
condition|(
operator|!
name|rep
condition|)
block|{
operator|*
name|contents_p
operator|=
name|svn_stream_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_filesize_t
name|len
init|=
name|rep
operator|->
name|expanded_size
decl_stmt|;
name|rep_read_baton_t
modifier|*
name|rb
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|fulltext_cache_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|fulltext_cache_key
operator|.
name|second
operator|=
name|rep
operator|->
name|id
operator|.
name|number
expr_stmt|;
comment|/* Initialize the reader baton.  Some members may added lazily        * while reading from the stream */
name|SVN_ERR
argument_list|(
name|rep_read_get_baton
argument_list|(
operator|&
name|rb
argument_list|,
name|fs
argument_list|,
name|rep
argument_list|,
name|fulltext_cache_key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make the stream attempt fulltext cache lookups if the fulltext        * is cacheable.  If it is not, then also don't try to buffer and        * cache it. */
if|if
condition|(
name|ffd
operator|->
name|fulltext_cache
operator|&&
name|cache_fulltext
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
operator|&&
name|fulltext_size_is_cachable
argument_list|(
name|ffd
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|rb
operator|->
name|fulltext_cache
operator|=
name|ffd
operator|->
name|fulltext_cache
expr_stmt|;
block|}
else|else
block|{
comment|/* This will also prevent the reconstructed fulltext from being              put into the cache. */
name|rb
operator|->
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
operator|*
name|contents_p
operator|=
name|svn_stream_create
argument_list|(
name|rb
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|svn_stream_set_read2
argument_list|(
operator|*
name|contents_p
argument_list|,
name|NULL
comment|/* only full read support */
argument_list|,
name|rep_read_contents
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
operator|*
name|contents_p
argument_list|,
name|rep_read_contents_close
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for cache_access_wrapper. Wraps the original parameters of  * svn_fs_x__try_process_file_content().  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|cache_access_wrapper_baton_t
block|{
name|svn_fs_process_contents_func_t
name|func
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
block|}
name|cache_access_wrapper_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Wrapper to translate between svn_fs_process_contents_func_t and  * svn_cache__partial_getter_func_t.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cache_access_wrapper
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|cache_access_wrapper_baton_t
modifier|*
name|wrapper_baton
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|wrapper_baton
operator|->
name|func
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
argument_list|,
name|data_len
operator|-
literal|1
argument_list|,
comment|/* cache adds terminating 0 */
name|wrapper_baton
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* non-NULL value to signal the calling cache that all went well */
operator|*
name|out
operator|=
name|baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__try_process_file_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|,
name|svn_fs_process_contents_func_t
name|processor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__representation_t
modifier|*
name|rep
init|=
name|noderev
operator|->
name|data_rep
decl_stmt|;
if|if
condition|(
name|rep
condition|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|fulltext_cache_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|fulltext_cache_key
operator|.
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|fulltext_cache_key
operator|.
name|second
operator|=
name|rep
operator|->
name|id
operator|.
name|number
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|fulltext_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|fulltext_cache_key
operator|.
name|revision
argument_list|)
operator|&&
name|fulltext_size_is_cachable
argument_list|(
name|ffd
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|)
condition|)
block|{
name|cache_access_wrapper_baton_t
name|wrapper_baton
decl_stmt|;
name|void
modifier|*
name|dummy
init|=
name|NULL
decl_stmt|;
name|wrapper_baton
operator|.
name|func
operator|=
name|processor
expr_stmt|;
name|wrapper_baton
operator|.
name|baton
operator|=
name|baton
expr_stmt|;
return|return
name|svn_cache__get_partial
argument_list|(
operator|&
name|dummy
argument_list|,
name|success
argument_list|,
name|ffd
operator|->
name|fulltext_cache
argument_list|,
operator|&
name|fulltext_cache_key
argument_list|,
name|cache_access_wrapper
argument_list|,
operator|&
name|wrapper_baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
block|}
operator|*
name|success
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used when reading delta windows. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|delta_read_baton_t
block|{
name|struct
name|rep_state_t
modifier|*
name|rs
decl_stmt|;
name|unsigned
name|char
name|md5_digest
index|[
name|APR_MD5_DIGESTSIZE
index|]
decl_stmt|;
block|}
name|delta_read_baton_t
typedef|;
end_typedef

begin_comment
comment|/* This implements the svn_txdelta_next_window_fn_t interface. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delta_read_next_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|delta_read_baton_t
modifier|*
name|drb
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
operator|*
name|window
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|drb
operator|->
name|rs
operator|->
name|current
operator|<
name|drb
operator|->
name|rs
operator|->
name|size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_delta_window
argument_list|(
name|window
argument_list|,
name|drb
operator|->
name|rs
operator|->
name|chunk_index
argument_list|,
name|drb
operator|->
name|rs
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|drb
operator|->
name|rs
operator|->
name|chunk_index
operator|++
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the svn_txdelta_md5_digest_fn_t interface. */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|delta_read_md5_digest
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|delta_read_baton_t
modifier|*
name|drb
init|=
name|baton
decl_stmt|;
return|return
name|drb
operator|->
name|md5_digest
return|;
block|}
end_function

begin_comment
comment|/* Return a txdelta stream for on-disk representation REP_STATE  * of TARGET.  Allocate the result in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_txdelta_stream_t
modifier|*
name|get_storaged_delta_stream
parameter_list|(
name|rep_state_t
modifier|*
name|rep_state
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* Create the delta read baton. */
name|delta_read_baton_t
modifier|*
name|drb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|drb
argument_list|)
argument_list|)
decl_stmt|;
name|drb
operator|->
name|rs
operator|=
name|rep_state
expr_stmt|;
name|memcpy
argument_list|(
name|drb
operator|->
name|md5_digest
argument_list|,
name|target
operator|->
name|data_rep
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|drb
operator|->
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_txdelta_stream_create
argument_list|(
name|drb
argument_list|,
name|delta_read_next_window
argument_list|,
name|delta_read_md5_digest
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|source
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|,
modifier|*
name|target_stream
decl_stmt|;
name|rep_state_t
modifier|*
name|rep_state
decl_stmt|;
name|svn_fs_x__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Try a shortcut: if the target is stored as a delta against the source,      then just use that delta.  However, prefer using the fulltext cache      whenever that is available. */
if|if
condition|(
name|target
operator|->
name|data_rep
operator|&&
operator|(
name|source
operator|||
operator|!
name|ffd
operator|->
name|fulltext_cache
operator|)
condition|)
block|{
comment|/* Read target's base rep if any. */
name|SVN_ERR
argument_list|(
name|create_rep_state
argument_list|(
operator|&
name|rep_state
argument_list|,
operator|&
name|rep_header
argument_list|,
name|NULL
argument_list|,
name|target
operator|->
name|data_rep
argument_list|,
name|fs
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try a shortcut: if the target is stored as a delta against the source,          then just use that delta. */
if|if
condition|(
name|source
operator|&&
name|source
operator|->
name|data_rep
operator|&&
name|target
operator|->
name|data_rep
condition|)
block|{
comment|/* If that matches source, then use this delta as is.              Note that we want an actual delta here.  E.g. a self-delta would              not be good enough. */
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_x__rep_delta
operator|&&
name|rep_header
operator|->
name|base_revision
operator|==
name|svn_fs_x__get_revnum
argument_list|(
name|source
operator|->
name|data_rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
operator|&&
name|rep_header
operator|->
name|base_item_index
operator|==
name|source
operator|->
name|data_rep
operator|->
name|id
operator|.
name|number
condition|)
block|{
operator|*
name|stream_p
operator|=
name|get_storaged_delta_stream
argument_list|(
name|rep_state
argument_list|,
name|target
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|source
condition|)
block|{
comment|/* We want a self-delta. There is a fair chance that TARGET got              added in this revision and is already stored in the requested              format. */
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_x__rep_self_delta
condition|)
block|{
operator|*
name|stream_p
operator|=
name|get_storaged_delta_stream
argument_list|(
name|rep_state
argument_list|,
name|target
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Don't keep file handles open for longer than necessary. */
if|if
condition|(
name|rep_state
operator|->
name|sfile
operator|->
name|rfile
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_x__close_revision_file
argument_list|(
name|rep_state
operator|->
name|sfile
operator|->
name|rfile
argument_list|)
argument_list|)
expr_stmt|;
name|rep_state
operator|->
name|sfile
operator|->
name|rfile
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* Read both fulltexts and construct a delta. */
if|if
condition|(
name|source
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_contents
argument_list|(
operator|&
name|source_stream
argument_list|,
name|fs
argument_list|,
name|source
operator|->
name|data_rep
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|source_stream
operator|=
name|svn_stream_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_contents
argument_list|(
operator|&
name|target_stream
argument_list|,
name|fs
argument_list|,
name|target
operator|->
name|data_rep
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Because source and target stream will already verify their content,    * there is no need to do this once more.  In particular if the stream    * content is being fetched from cache. */
name|svn_txdelta2
argument_list|(
name|stream_p
argument_list|,
name|source_stream
argument_list|,
name|target_stream
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE when all svn_fs_x__dirent_t* in ENTRIES are already sorted    by their respective name. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|sorted
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|svn_fs_x__dirent_t
modifier|*
specifier|const
modifier|*
name|dirents
init|=
operator|(
specifier|const
name|void
operator|*
operator|)
name|entries
operator|->
name|elts
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
operator|-
literal|1
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|dirents
index|[
name|i
index|]
operator|->
name|name
argument_list|,
name|dirents
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|name
argument_list|)
operator|>
literal|0
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Compare the names of the two dirents given in **A and **B. */
end_comment

begin_function
specifier|static
name|int
name|compare_dirents
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_fs_x__dirent_t
modifier|*
name|lhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_fs_x__dirent_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|svn_fs_x__dirent_t
modifier|*
name|rhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_fs_x__dirent_t
operator|*
specifier|const
operator|*
operator|)
name|b
operator|)
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|lhs
operator|->
name|name
argument_list|,
name|rhs
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare the name of the dirents given in **A with the C string in *B. */
end_comment

begin_function
specifier|static
name|int
name|compare_dirent_name
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_fs_x__dirent_t
modifier|*
name|lhs
init|=
operator|*
operator|(
operator|(
specifier|const
name|svn_fs_x__dirent_t
operator|*
specifier|const
operator|*
operator|)
name|a
operator|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|rhs
init|=
name|b
decl_stmt|;
return|return
name|strcmp
argument_list|(
name|lhs
operator|->
name|name
argument_list|,
name|rhs
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Into ENTRIES, read all directories entries from the key-value text in  * STREAM.  If INCREMENTAL is TRUE, read until the end of the STREAM and  * update the data.  ID is provided for nicer error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_dir_entries
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|hash
init|=
name|incremental
condition|?
name|svn_hash__make
argument_list|(
name|scratch_pool
argument_list|)
else|:
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|terminator
init|=
name|SVN_HASH_TERMINATOR
decl_stmt|;
comment|/* Read until the terminator (non-incremental) or the end of STREAM      (incremental mode).  In the latter mode, we use a temporary HASH      to make updating and removing entries cheaper. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_hash__entry_t
name|entry
decl_stmt|;
name|svn_fs_x__dirent_t
modifier|*
name|dirent
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash__read_entry
argument_list|(
operator|&
name|entry
argument_list|,
name|stream
argument_list|,
name|terminator
argument_list|,
name|incremental
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* End of directory? */
if|if
condition|(
name|entry
operator|.
name|key
operator|==
name|NULL
condition|)
block|{
comment|/* In incremental mode, we skip the terminator and read the              increments following it until the end of the stream. */
if|if
condition|(
name|incremental
operator|&&
name|terminator
condition|)
name|terminator
operator|=
name|NULL
expr_stmt|;
else|else
break|break;
block|}
comment|/* Deleted entry? */
if|if
condition|(
name|entry
operator|.
name|val
operator|==
name|NULL
condition|)
block|{
comment|/* We must be in incremental mode */
name|assert
argument_list|(
name|hash
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|entry
operator|.
name|key
argument_list|,
name|entry
operator|.
name|keylen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Add a new directory entry. */
name|dirent
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dirent
argument_list|)
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|name
operator|=
name|apr_pstrmemdup
argument_list|(
name|result_pool
argument_list|,
name|entry
operator|.
name|key
argument_list|,
name|entry
operator|.
name|keylen
argument_list|)
expr_stmt|;
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|entry
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|svn_fs_x__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|SVN_FS_X__KIND_FILE
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dirent
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|str
argument_list|,
name|SVN_FS_X__KIND_DIR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dirent
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|svn_fs_x__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
block|}
name|str
operator|=
name|svn_cstring_tokenize
argument_list|(
literal|" "
argument_list|,
operator|&
name|entry
operator|.
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Directory entry corrupt in '%s'"
argument_list|)
argument_list|,
name|svn_fs_x__id_unparse
argument_list|(
name|id
argument_list|,
name|scratch_pool
argument_list|)
operator|->
name|data
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__id_parse
argument_list|(
operator|&
name|dirent
operator|->
name|id
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In incremental mode, update the hash; otherwise, write to the        * final array. */
if|if
condition|(
name|incremental
condition|)
name|apr_hash_set
argument_list|(
name|hash
argument_list|,
name|dirent
operator|->
name|name
argument_list|,
name|entry
operator|.
name|keylen
argument_list|,
name|dirent
argument_list|)
expr_stmt|;
else|else
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|svn_fs_x__dirent_t
operator|*
argument_list|)
operator|=
name|dirent
expr_stmt|;
block|}
comment|/* Convert container to a sorted array. */
if|if
condition|(
name|incremental
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|hash
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|svn_fs_x__dirent_t
operator|*
argument_list|)
operator|=
name|apr_hash_this_val
argument_list|(
name|hi
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|sorted
argument_list|(
name|entries
argument_list|)
condition|)
name|svn_sort__array
argument_list|(
name|entries
argument_list|,
name|compare_dirents
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch the contents of a directory into ENTRIES.  Values are stored    as filename to string mappings; further conversion is necessary to    convert them into svn_fs_x__dirent_t values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dir_contents
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
init|=
operator|&
name|noderev
operator|->
name|noderev_id
decl_stmt|;
operator|*
name|entries
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|16
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__dirent_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
operator|!
name|svn_fs_x__is_revision
argument_list|(
name|noderev
operator|->
name|data_rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|svn_fs_x__path_txn_node_children
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* The representation is mutable.  Read the old directory          contents from the mutable children file, followed by the          changes we've made in this transaction. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|contents
argument_list|,
name|filename
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_dir_entries
argument_list|(
operator|*
name|entries
argument_list|,
name|contents
argument_list|,
name|TRUE
argument_list|,
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
comment|/* Undeltify content before parsing it. Otherwise, we could only        * parse it byte-by-byte.        */
name|apr_size_t
name|len
init|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|text
decl_stmt|;
comment|/* The representation is immutable.  Read it normally. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_stream
argument_list|(
operator|&
name|text
argument_list|,
name|contents
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
comment|/* de-serialize hash */
name|contents
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|text
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_dir_entries
argument_list|(
operator|*
name|entries
argument_list|,
name|contents
argument_list|,
name|FALSE
argument_list|,
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the cache object in FS responsible to storing the directory the  * NODEREV plus the corresponding pre-allocated *KEY.  */
end_comment

begin_function
specifier|static
name|svn_cache__t
modifier|*
name|locate_dir_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__id_t
modifier|*
name|key
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|svn_fs_x__is_txn
argument_list|(
name|noderev
operator|->
name|noderev_id
operator|.
name|change_set
argument_list|)
condition|)
block|{
comment|/* data in txns must be addressed by ID since the representation has          not been created, yet. */
operator|*
name|key
operator|=
name|noderev
operator|->
name|noderev_id
expr_stmt|;
block|}
else|else
block|{
comment|/* committed data can use simple rev,item pairs */
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
operator|*
name|key
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|id
expr_stmt|;
block|}
else|else
block|{
comment|/* no data rep -> empty directory.              Use a key that does definitely not clash with non-NULL reps. */
name|key
operator|->
name|change_set
operator|=
name|SVN_FS_X__INVALID_CHANGE_SET
expr_stmt|;
name|key
operator|->
name|number
operator|=
name|SVN_FS_X__ITEM_INDEX_UNUSED
expr_stmt|;
block|}
block|}
return|return
name|ffd
operator|->
name|dir_cache
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__rep_contents_dir
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|entries_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__id_t
name|key
decl_stmt|;
comment|/* find the cache we may use */
name|svn_cache__t
modifier|*
name|cache
init|=
name|locate_dir_cache
argument_list|(
name|fs
argument_list|,
operator|&
name|key
argument_list|,
name|noderev
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|svn_boolean_t
name|found
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|entries_p
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Read in the directory contents. */
name|SVN_ERR
argument_list|(
name|get_dir_contents
argument_list|(
name|entries_p
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Update the cache, if we are to use one. */
if|if
condition|(
name|cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|cache
argument_list|,
operator|&
name|key
argument_list|,
operator|*
name|entries_p
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_fs_x__dirent_t
modifier|*
name|svn_fs_x__find_dir_entry
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
modifier|*
name|hint
parameter_list|)
block|{
name|svn_fs_x__dirent_t
modifier|*
modifier|*
name|result
init|=
name|svn_sort__array_lookup
argument_list|(
name|entries
argument_list|,
name|name
argument_list|,
name|hint
argument_list|,
name|compare_dirent_name
argument_list|)
decl_stmt|;
return|return
name|result
condition|?
operator|*
name|result
else|:
name|NULL
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__rep_contents_dir_entry
parameter_list|(
name|svn_fs_x__dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_size_t
modifier|*
name|hint
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|found
init|=
name|FALSE
decl_stmt|;
comment|/* find the cache we may use */
name|svn_fs_x__id_t
name|key
decl_stmt|;
name|svn_cache__t
modifier|*
name|cache
init|=
name|locate_dir_cache
argument_list|(
name|fs
argument_list|,
operator|&
name|key
argument_list|,
name|noderev
argument_list|)
decl_stmt|;
if|if
condition|(
name|cache
condition|)
block|{
name|svn_fs_x__ede_baton_t
name|baton
decl_stmt|;
name|baton
operator|.
name|hint
operator|=
operator|*
name|hint
expr_stmt|;
name|baton
operator|.
name|name
operator|=
name|name
expr_stmt|;
comment|/* Cache lookup. */
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|dirent
argument_list|,
operator|&
name|found
argument_list|,
name|cache
argument_list|,
operator|&
name|key
argument_list|,
name|svn_fs_x__extract_dir_entry
argument_list|,
operator|&
name|baton
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember the new clue only if we found something at that spot. */
if|if
condition|(
name|found
condition|)
operator|*
name|hint
operator|=
name|baton
operator|.
name|hint
expr_stmt|;
block|}
comment|/* fetch data from disk if we did not find it in the cache */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|svn_fs_x__dirent_t
modifier|*
name|entry
decl_stmt|;
name|svn_fs_x__dirent_t
modifier|*
name|entry_copy
init|=
name|NULL
decl_stmt|;
comment|/* read the dir from the file system. It will probably be put it          into the cache for faster lookup in future calls. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__rep_contents_dir
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* find desired entry and return a copy in POOL, if found */
name|entry
operator|=
name|svn_fs_x__find_dir_entry
argument_list|(
name|entries
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|entry_copy
operator|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry_copy
argument_list|)
argument_list|)
expr_stmt|;
name|entry_copy
operator|->
name|name
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|entry
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
operator|*
name|dirent
operator|=
name|entry_copy
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
specifier|const
name|svn_fs_x__id_t
modifier|*
name|noderev_id
init|=
operator|&
name|noderev
operator|->
name|noderev_id
decl_stmt|;
if|if
condition|(
name|noderev
operator|->
name|prop_rep
operator|&&
operator|!
name|svn_fs_x__is_revision
argument_list|(
name|noderev
operator|->
name|prop_rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|svn_fs_x__path_txn_node_props
argument_list|(
name|fs
argument_list|,
name|noderev_id
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|filename
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|noderev
operator|->
name|prop_rep
condition|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__representation_t
modifier|*
name|rep
init|=
name|noderev
operator|->
name|prop_rep
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|rep
operator|->
name|id
operator|.
name|number
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|properties_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|key
operator|.
name|revision
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|proplist_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|properties_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_contents
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|noderev
operator|->
name|prop_rep
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|properties_cache
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|properties_cache
argument_list|,
operator|&
name|key
argument_list|,
name|proplist
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* return an empty prop list if the node doesn't have any props */
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
operator|*
name|proplist_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__revision_file_t
modifier|*
name|revision_file
decl_stmt|;
name|svn_boolean_t
name|found
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|svn_fs_x__id_t
name|id
decl_stmt|;
name|id
operator|.
name|change_set
operator|=
name|svn_fs_x__change_set_by_rev
argument_list|(
name|rev
argument_list|)
expr_stmt|;
name|id
operator|.
name|number
operator|=
name|SVN_FS_X__ITEM_INDEX_CHANGES
expr_stmt|;
comment|/* Provide revision file. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|revision_file
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* try cache lookup first */
if|if
condition|(
name|ffd
operator|->
name|changes_container_cache
operator|&&
name|svn_fs_x__is_packed_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|apr_off_t
name|offset
decl_stmt|;
name|apr_uint32_t
name|sub_item
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|offset
argument_list|,
operator|&
name|sub_item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
operator|&
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|offset
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|changes
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|changes_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|svn_fs_x__changes_get_list_func
argument_list|,
operator|&
name|sub_item
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ffd
operator|->
name|changes_cache
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|changes
argument_list|,
operator|&
name|found
argument_list|,
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|rev
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|found
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|found
condition|)
block|{
comment|/* 'block-read' will also provide us with the desired data */
name|SVN_ERR
argument_list|(
name|block_read
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|changes
argument_list|,
name|fs
argument_list|,
operator|&
name|id
argument_list|,
name|revision_file
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__close_revision_file
argument_list|(
name|revision_file
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|dgb__log_access
argument_list|(
name|fs
argument_list|,
operator|&
name|id
argument_list|,
operator|*
name|changes
argument_list|,
name|SVN_FS_X__ITEM_TYPE_CHANGES
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Fetch the representation data (header, txdelta / plain windows)  * addressed by ENTRY->ITEM in FS and cache it if caches are enabled.  * Read the data from the already open FILE and the wrapping  * STREAM object.  If MAX_OFFSET is not -1, don't read windows that start  * at or beyond that offset.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_contents
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_fs_x__pair_cache_key_t
modifier|*
name|key
parameter_list|,
name|apr_off_t
name|max_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__representation_cache_key_t
name|header_key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|rep_state_t
name|rs
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_filesize_t
name|fulltext_len
decl_stmt|;
name|svn_fs_x__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
if|if
condition|(
operator|!
name|ffd
operator|->
name|txdelta_window_cache
operator|||
operator|!
name|ffd
operator|->
name|combined_window_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|header_key
operator|.
name|revision
operator|=
operator|(
name|apr_int32_t
operator|)
name|key
operator|->
name|revision
expr_stmt|;
name|header_key
operator|.
name|is_packed
operator|=
name|svn_fs_x__is_packed_rev
argument_list|(
name|fs
argument_list|,
name|header_key
operator|.
name|revision
argument_list|)
expr_stmt|;
name|header_key
operator|.
name|item_index
operator|=
name|key
operator|->
name|second
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_rep_header
argument_list|(
operator|&
name|rep_header
argument_list|,
name|fs
argument_list|,
name|rev_file
operator|->
name|stream
argument_list|,
operator|&
name|header_key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|init_rep_state
argument_list|(
operator|&
name|rs
argument_list|,
name|rep_header
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cache_windows
argument_list|(
operator|&
name|fulltext_len
argument_list|,
name|fs
argument_list|,
operator|&
name|rs
argument_list|,
name|max_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For the given REV_FILE in FS, in *STREAM return a stream covering the  * item specified by ENTRY.  Also, verify the item's content by low-level  * checksum.  Allocate the result in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_item
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint32_t
name|digest
decl_stmt|;
name|svn_checksum_t
modifier|*
name|expected
decl_stmt|,
modifier|*
name|actual
decl_stmt|;
name|apr_uint32_t
name|plain_digest
decl_stmt|;
comment|/* Read item into string buffer. */
name|svn_stringbuf_t
modifier|*
name|text
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|entry
operator|->
name|size
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|text
operator|->
name|len
operator|=
name|entry
operator|->
name|size
expr_stmt|;
name|text
operator|->
name|data
index|[
name|text
operator|->
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|text
operator|->
name|data
argument_list|,
name|text
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return (construct, calculate) stream and checksum. */
operator|*
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|text
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|digest
operator|=
name|svn__fnv1a_32x4
argument_list|(
name|text
operator|->
name|data
argument_list|,
name|text
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Checksums will match most of the time. */
if|if
condition|(
name|entry
operator|->
name|fnv1_checksum
operator|==
name|digest
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Construct proper checksum objects from their digests to allow for    * nice error messages. */
name|plain_digest
operator|=
name|htonl
argument_list|(
name|entry
operator|->
name|fnv1_checksum
argument_list|)
expr_stmt|;
name|expected
operator|=
name|svn_checksum__from_digest_fnv1a_32x4
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|plain_digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|plain_digest
operator|=
name|htonl
argument_list|(
name|digest
argument_list|)
expr_stmt|;
name|actual
operator|=
name|svn_checksum__from_digest_fnv1a_32x4
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|&
name|plain_digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Construct the full error message with all the info we have. */
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Low-level checksum mismatch while reading\n"
literal|"%s bytes of meta data at offset %s "
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
argument_list|,
name|entry
operator|->
name|size
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
argument_list|,
name|entry
operator|->
name|offset
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read all txdelta / plain windows following REP_HEADER in FS as described  * by ENTRY.  Read the data from the already open FILE and the wrapping  * STREAM object.  If MAX_OFFSET is not -1, don't read windows that start  * at or beyond that offset.  Use SCRATCH_POOL for temporary allocations.  * If caching is not enabled, this is a no-op.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_changes
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_boolean_t
name|must_read
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|must_read
operator|&&
operator|!
name|ffd
operator|->
name|changes_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* we don't support containers, yet */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|item_count
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* already in cache? */
if|if
condition|(
operator|!
name|must_read
operator|&&
name|ffd
operator|->
name|changes_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read changes from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_changes
argument_list|(
name|changes
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* cache for future reference */
if|if
condition|(
name|ffd
operator|->
name|changes_cache
condition|)
block|{
comment|/* Guesstimate for the size of the in-cache representation. */
name|apr_size_t
name|estimated_size
init|=
operator|(
name|apr_size_t
operator|)
literal|250
operator|*
operator|(
operator|*
name|changes
operator|)
operator|->
name|nelts
decl_stmt|;
comment|/* Don't even serialize data that probably won't fit into the         * cache.  This often implies that either CHANGES is very         * large, memory is scarce or both.  Having a huge temporary         * copy would not be a good thing in either case. */
if|if
condition|(
name|svn_cache__is_cachable
argument_list|(
name|ffd
operator|->
name|changes_cache
argument_list|,
name|estimated_size
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|changes_cache
argument_list|,
operator|&
name|revision
argument_list|,
operator|*
name|changes
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_changes_container
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_uint32_t
name|sub_item
parameter_list|,
name|svn_boolean_t
name|must_read
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__changes_t
modifier|*
name|container
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
comment|/* already in cache? */
if|if
condition|(
operator|!
name|must_read
operator|&&
name|ffd
operator|->
name|changes_container_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|changes_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read changes from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_changes_container
argument_list|(
operator|&
name|container
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* extract requested data */
if|if
condition|(
name|must_read
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__changes_get_list
argument_list|(
name|changes
argument_list|,
name|container
argument_list|,
name|sub_item
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|changes_container_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|changes_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|container
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_noderev
parameter_list|(
name|svn_fs_x__noderev_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|svn_fs_x__pair_cache_key_t
modifier|*
name|key
parameter_list|,
name|svn_boolean_t
name|must_read
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
operator|!
name|must_read
operator|&&
operator|!
name|ffd
operator|->
name|node_revision_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* we don't support containers, yet */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|item_count
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* already in cache? */
if|if
condition|(
operator|!
name|must_read
operator|&&
name|ffd
operator|->
name|node_revision_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|node_revision_cache
argument_list|,
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read node rev from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_noderev
argument_list|(
name|noderev_p
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|node_revision_cache
argument_list|,
name|key
argument_list|,
operator|*
name|noderev_p
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_noderevs_container
parameter_list|(
name|svn_fs_x__noderev_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_uint32_t
name|sub_item
parameter_list|,
name|svn_boolean_t
name|must_read
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__noderevs_t
modifier|*
name|container
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
comment|/* already in cache? */
if|if
condition|(
operator|!
name|must_read
operator|&&
name|ffd
operator|->
name|noderevs_container_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|noderevs_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read noderevs from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_noderevs_container
argument_list|(
operator|&
name|container
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* extract requested data */
if|if
condition|(
name|must_read
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__noderevs_get
argument_list|(
name|noderev_p
argument_list|,
name|container
argument_list|,
name|sub_item
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|noderevs_container_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|noderevs_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|container
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read_reps_container
parameter_list|(
name|svn_fs_x__rep_extractor_t
modifier|*
modifier|*
name|extractor
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_uint32_t
name|sub_item
parameter_list|,
name|svn_boolean_t
name|must_read
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__reps_t
modifier|*
name|container
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|)
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__packed_base_rev
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
comment|/* already in cache? */
if|if
condition|(
operator|!
name|must_read
operator|&&
name|ffd
operator|->
name|reps_container_cache
condition|)
block|{
name|svn_boolean_t
name|is_cached
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__has_key
argument_list|(
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|reps_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|read_item
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read noderevs from revision file */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_reps_container
argument_list|(
operator|&
name|container
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* extract requested data */
if|if
condition|(
name|must_read
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__reps_get
argument_list|(
name|extractor
argument_list|,
name|fs
argument_list|,
name|container
argument_list|,
name|sub_item
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ffd
operator|->
name|noderevs_container_cache
condition|)
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|reps_container_cache
argument_list|,
operator|&
name|key
argument_list|,
name|container
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|block_read
parameter_list|(
name|void
modifier|*
modifier|*
name|result
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|revision_file
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|,
name|wanted_offset
init|=
literal|0
decl_stmt|;
name|apr_off_t
name|block_start
init|=
literal|0
decl_stmt|;
name|apr_uint32_t
name|wanted_sub_item
init|=
literal|0
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|int
name|run_count
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* don't try this on transaction protorev files */
name|SVN_ERR_ASSERT
argument_list|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* index lookup: find the OFFSET of the item we *must* read plus (in the    * "do-while" block) the list of items in the same block. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__item_offset
argument_list|(
operator|&
name|wanted_offset
argument_list|,
operator|&
name|wanted_sub_item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|wanted_offset
expr_stmt|;
do|do
block|{
comment|/* fetch list of items in the block surrounding OFFSET */
name|SVN_ERR
argument_list|(
name|aligned_seek
argument_list|(
name|fs
argument_list|,
name|revision_file
operator|->
name|file
argument_list|,
operator|&
name|block_start
argument_list|,
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|revision
argument_list|,
name|block_start
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read all items from the block */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_boolean_t
name|is_result
decl_stmt|,
name|is_wanted
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* skip empty sections */
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_UNUSED
condition|)
continue|continue;
comment|/* the item / container we were looking for? */
name|is_wanted
operator|=
name|entry
operator|->
name|offset
operator|==
name|wanted_offset
operator|&&
name|entry
operator|->
name|item_count
operator|>=
name|wanted_sub_item
operator|&&
name|svn_fs_x__id_eq
argument_list|(
name|entry
operator|->
name|items
operator|+
name|wanted_sub_item
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|is_result
operator|=
name|result
operator|&&
name|is_wanted
expr_stmt|;
comment|/* select the pool that we want the item to be allocated in */
name|pool
operator|=
name|is_result
condition|?
name|result_pool
else|:
name|iterpool
expr_stmt|;
comment|/* handle all items that start within this block and are relatively            * small (i.e.< block size).  Always read the item we need to return.            */
if|if
condition|(
name|is_result
operator|||
operator|(
name|entry
operator|->
name|offset
operator|>=
name|block_start
operator|&&
name|entry
operator|->
name|size
operator|<
name|ffd
operator|->
name|block_size
operator|)
condition|)
block|{
name|void
modifier|*
name|item
init|=
name|NULL
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|revision_file
operator|->
name|file
argument_list|,
name|SEEK_SET
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|entry
operator|->
name|type
condition|)
block|{
case|case
name|SVN_FS_X__ITEM_TYPE_FILE_REP
case|:
case|case
name|SVN_FS_X__ITEM_TYPE_DIR_REP
case|:
case|case
name|SVN_FS_X__ITEM_TYPE_FILE_PROPS
case|:
case|case
name|SVN_FS_X__ITEM_TYPE_DIR_PROPS
case|:
name|SVN_ERR
argument_list|(
name|block_read_contents
argument_list|(
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
operator|&
name|key
argument_list|,
name|is_wanted
condition|?
operator|-
literal|1
else|:
name|block_start
operator|+
name|ffd
operator|->
name|block_size
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVN_FS_X__ITEM_TYPE_NODEREV
case|:
if|if
condition|(
name|ffd
operator|->
name|node_revision_cache
operator|||
name|is_result
condition|)
name|SVN_ERR
argument_list|(
name|block_read_noderev
argument_list|(
operator|(
name|svn_fs_x__noderev_t
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
operator|&
name|key
argument_list|,
name|is_result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVN_FS_X__ITEM_TYPE_CHANGES
case|:
name|SVN_ERR
argument_list|(
name|block_read_changes
argument_list|(
operator|(
name|apr_array_header_t
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
name|is_result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVN_FS_X__ITEM_TYPE_CHANGES_CONT
case|:
name|SVN_ERR
argument_list|(
name|block_read_changes_container
argument_list|(
operator|(
name|apr_array_header_t
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
name|wanted_sub_item
argument_list|,
name|is_result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVN_FS_X__ITEM_TYPE_NODEREVS_CONT
case|:
name|SVN_ERR
argument_list|(
name|block_read_noderevs_container
argument_list|(
operator|(
name|svn_fs_x__noderev_t
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
name|wanted_sub_item
argument_list|,
name|is_result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|SVN_FS_X__ITEM_TYPE_REPS_CONT
case|:
name|SVN_ERR
argument_list|(
name|block_read_reps_container
argument_list|(
operator|(
name|svn_fs_x__rep_extractor_t
operator|*
operator|*
operator|)
operator|&
name|item
argument_list|,
name|fs
argument_list|,
name|revision_file
argument_list|,
name|entry
argument_list|,
name|wanted_sub_item
argument_list|,
name|is_result
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
if|if
condition|(
name|is_result
condition|)
operator|*
name|result
operator|=
name|item
expr_stmt|;
comment|/* if we crossed a block boundary, read the remainder of                * the last block as well */
name|offset
operator|=
name|entry
operator|->
name|offset
operator|+
name|entry
operator|->
name|size
expr_stmt|;
if|if
condition|(
name|offset
operator|>
name|block_start
operator|+
name|ffd
operator|->
name|block_size
condition|)
operator|++
name|run_count
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|run_count
operator|++
operator|==
literal|1
condition|)
do|;
comment|/* can only be true once and only if a block                             * boundary got crossed */
comment|/* if the caller requested a result, we must have provided one by now */
name|assert
argument_list|(
operator|!
name|result
operator|||
operator|*
name|result
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

