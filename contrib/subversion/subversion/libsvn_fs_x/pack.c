begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* pack.c --- FSX shard packing functionality  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"fs_x.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"changes.h"
end_include

begin_include
include|#
directive|include
file|"noderevs.h"
end_include

begin_include
include|#
directive|include
file|"reps.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_comment
comment|/* Packing logic:  *  * We pack files on a pack file basis (e.g. 1000 revs) without changing  * existing pack files nor the revision files outside the range to pack.  *  * First, we will scan the revision file indexes to determine the number  * of items to "place" (i.e. determine their optimal position within the  * future pack file).  For each item, we will need a constant amount of  * memory to track it.  A MAX_MEM parameter sets a limit to the number of  * items we may place in one go.  That means, we may not be able to add  * all revisions at once.  Instead, we will run the placement for a subset  * of revisions at a time.  The very unlikely worst case will simply append  * all revision data with just a little reshuffling inside each revision.  *  * In a second step, we read all revisions in the selected range, build  * the item tracking information and copy the items themselves from the  * revision files to temporary files.  The latter serve as buckets for a  * very coarse bucket presort:  Separate change lists, file properties,  * directory properties and noderevs + representations from one another.  *  * The third step will determine an optimized placement for the items in  * each of the 4 buckets separately.  The first three will simply order  * their items by revision, starting with the newest once.  Placing rep  * and noderev items is a more elaborate process documented in the code.  *  * In short, we store items in the following order:  * - changed paths lists  * - node property  * - directory properties  * - directory representations corresponding noderevs, lexical path order  *   with special treatment of "trunk" and "branches"  * - same for file representations  *  * Step 4 copies the items from the temporary buckets into the final  * pack file and writes the temporary index files.  *  * Finally, after the last range of revisions, create the final indexes.  */
end_comment

begin_comment
comment|/* Maximum amount of memory we allocate for placement information during  * the pack process.  */
end_comment

begin_define
define|#
directive|define
name|DEFAULT_MAX_MEM
value|(64 * 1024 * 1024)
end_define

begin_comment
comment|/* Data structure describing a node change at PATH, REVISION.  * We will sort these instances by PATH and NODE_ID such that we can combine  * similar nodes in the same reps container and store containers in path  * major order.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|path_order_t
block|{
comment|/* changed path */
name|svn_prefix_string__t
modifier|*
name|path
decl_stmt|;
comment|/* node ID for this PATH in REVISION */
name|svn_fs_x__id_t
name|node_id
decl_stmt|;
comment|/* when this change happened */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* this is a directory node */
name|svn_boolean_t
name|is_dir
decl_stmt|;
comment|/* length of the expanded representation content */
name|apr_int64_t
name|expanded_size
decl_stmt|;
comment|/* item ID of the noderev linked to the change. May be (0, 0). */
name|svn_fs_x__id_t
name|noderev_id
decl_stmt|;
comment|/* item ID of the representation containing the new data. May be (0, 0). */
name|svn_fs_x__id_t
name|rep_id
decl_stmt|;
block|}
name|path_order_t
typedef|;
end_typedef

begin_comment
comment|/* Represents a reference from item FROM to item TO.  FROM may be a noderev  * or rep_id while TO is (currently) always a representation.  We will sort  * them by TO which allows us to collect all dependent items.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|reference_t
block|{
name|svn_fs_x__id_t
name|to
decl_stmt|;
name|svn_fs_x__id_t
name|from
decl_stmt|;
block|}
name|reference_t
typedef|;
end_typedef

begin_comment
comment|/* This structure keeps track of all the temporary data and status that  * needs to be kept around during the creation of one pack file.  After  * each revision range (in case we can't process all revs at once due to  * memory restrictions), parts of the data will get re-initialized.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|pack_context_t
block|{
comment|/* file system that we operate on */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* cancel function to invoke at regular intervals. May be NULL */
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
comment|/* baton to pass to CANCEL_FUNC */
name|void
modifier|*
name|cancel_baton
decl_stmt|;
comment|/* first revision in the shard (and future pack file) */
name|svn_revnum_t
name|shard_rev
decl_stmt|;
comment|/* first revision in the range to process (>= SHARD_REV) */
name|svn_revnum_t
name|start_rev
decl_stmt|;
comment|/* first revision after the range to process (<= SHARD_END_REV) */
name|svn_revnum_t
name|end_rev
decl_stmt|;
comment|/* first revision after the current shard */
name|svn_revnum_t
name|shard_end_rev
decl_stmt|;
comment|/* log-to-phys proto index for the whole pack file */
name|apr_file_t
modifier|*
name|proto_l2p_index
decl_stmt|;
comment|/* phys-to-log proto index for the whole pack file */
name|apr_file_t
modifier|*
name|proto_p2l_index
decl_stmt|;
comment|/* full shard directory path (containing the unpacked revisions) */
specifier|const
name|char
modifier|*
name|shard_dir
decl_stmt|;
comment|/* full packed shard directory path (containing the pack file + indexes) */
specifier|const
name|char
modifier|*
name|pack_file_dir
decl_stmt|;
comment|/* full pack file path (including PACK_FILE_DIR) */
specifier|const
name|char
modifier|*
name|pack_file_path
decl_stmt|;
comment|/* current write position (i.e. file length) in the pack file */
name|apr_off_t
name|pack_offset
decl_stmt|;
comment|/* the pack file to ultimately write all data to */
name|apr_file_t
modifier|*
name|pack_file
decl_stmt|;
comment|/* array of svn_fs_x__p2l_entry_t *, all referring to change lists.    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_array_header_t
modifier|*
name|changes
decl_stmt|;
comment|/* temp file receiving all change list items (referenced by CHANGES).    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_file_t
modifier|*
name|changes_file
decl_stmt|;
comment|/* array of svn_fs_x__p2l_entry_t *, all referring to file properties.    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_array_header_t
modifier|*
name|file_props
decl_stmt|;
comment|/* temp file receiving all file prop items (referenced by FILE_PROPS).    * Will be filled in phase 2 and be cleared after each revision range.*/
name|apr_file_t
modifier|*
name|file_props_file
decl_stmt|;
comment|/* array of svn_fs_x__p2l_entry_t *, all referring to directory properties.    * Will be filled in phase 2 and be cleared after each revision range. */
name|apr_array_header_t
modifier|*
name|dir_props
decl_stmt|;
comment|/* temp file receiving all directory prop items (referenced by DIR_PROPS).    * Will be filled in phase 2 and be cleared after each revision range.*/
name|apr_file_t
modifier|*
name|dir_props_file
decl_stmt|;
comment|/* container for all PATH members in PATH_ORDER. */
name|svn_prefix_tree__t
modifier|*
name|paths
decl_stmt|;
comment|/* array of path_order_t *.  Will be filled in phase 2 and be cleared    * after each revision range.  Sorted by PATH, NODE_ID. */
name|apr_array_header_t
modifier|*
name|path_order
decl_stmt|;
comment|/* array of reference_t* linking representations to their delta bases.    * Will be filled in phase 2 and be cleared after each revision range.    * It will be sorted by the FROM members (for rep->base rep lookup). */
name|apr_array_header_t
modifier|*
name|references
decl_stmt|;
comment|/* array of svn_fs_x__p2l_entry_t*.  Will be filled in phase 2 and be    * cleared after each revision range.  During phase 3, we will set items    * to NULL that we already processed. */
name|apr_array_header_t
modifier|*
name|reps
decl_stmt|;
comment|/* array of int, marking for each revision, the which offset their items    * begin in REPS.  Will be filled in phase 2 and be cleared after    * each revision range. */
name|apr_array_header_t
modifier|*
name|rev_offsets
decl_stmt|;
comment|/* temp file receiving all items referenced by REPS.    * Will be filled in phase 2 and be cleared after each revision range.*/
name|apr_file_t
modifier|*
name|reps_file
decl_stmt|;
comment|/* pool used for temporary data structures that will be cleaned up when    * the next range of revisions is being processed */
name|apr_pool_t
modifier|*
name|info_pool
decl_stmt|;
block|}
name|pack_context_t
typedef|;
end_typedef

begin_comment
comment|/* Create and initialize a new pack context for packing shard SHARD_REV in  * SHARD_DIR into PACK_FILE_DIR within filesystem FS.  Allocate it in POOL  * and return the structure in *CONTEXT.  *  * Limit the number of items being copied per iteration to MAX_ITEMS.  * Set CANCEL_FUNC and CANCEL_BATON as well.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|initialize_pack_context
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_dir
parameter_list|,
name|svn_revnum_t
name|shard_rev
parameter_list|,
name|int
name|max_items
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_dir
decl_stmt|;
name|int
name|max_revs
init|=
name|MIN
argument_list|(
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|max_items
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|shard_rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* where we will place our various temp files */
name|SVN_ERR
argument_list|(
name|svn_io_temp_dir
argument_list|(
operator|&
name|temp_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store parameters */
name|context
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|context
operator|->
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|context
operator|->
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
name|context
operator|->
name|shard_rev
operator|=
name|shard_rev
expr_stmt|;
name|context
operator|->
name|start_rev
operator|=
name|shard_rev
expr_stmt|;
name|context
operator|->
name|end_rev
operator|=
name|shard_rev
expr_stmt|;
name|context
operator|->
name|shard_end_rev
operator|=
name|shard_rev
operator|+
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* Create the new directory and pack file. */
name|context
operator|->
name|shard_dir
operator|=
name|shard_dir
expr_stmt|;
name|context
operator|->
name|pack_file_dir
operator|=
name|pack_file_dir
expr_stmt|;
name|context
operator|->
name|pack_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_PACKED
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|context
operator|->
name|pack_file
argument_list|,
name|context
operator|->
name|pack_file_path
argument_list|,
name|APR_WRITE
operator||
name|APR_BUFFERED
operator||
name|APR_BINARY
operator||
name|APR_EXCL
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Proto index files */
name|SVN_ERR
argument_list|(
name|svn_fs_x__l2p_proto_index_open
argument_list|(
operator|&
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|svn_dirent_join
argument_list|(
argument|pack_file_dir
argument_list|,
argument|PATH_INDEX PATH_EXT_L2P_INDEX
argument_list|,
argument|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_proto_index_open
argument_list|(
operator|&
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|svn_dirent_join
argument_list|(
argument|pack_file_dir
argument_list|,
argument|PATH_INDEX PATH_EXT_P2L_INDEX
argument_list|,
argument|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* item buckets: one item info array and one temp file per bucket */
name|context
operator|->
name|changes
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|changes_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|file_props
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|file_props_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|dir_props
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|dir_props_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* noderev and representation item bucket */
name|context
operator|->
name|rev_offsets
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_revs
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|path_order
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|path_order_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|references
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|reference_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|reps
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|max_items
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|context
operator|->
name|reps_file
argument_list|,
name|NULL
argument_list|,
name|temp_dir
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the pool used for temp structures */
name|context
operator|->
name|info_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|context
operator|->
name|paths
operator|=
name|svn_prefix_tree__create
argument_list|(
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Clean up / free all revision range specific data and files in CONTEXT.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|reset_pack_context
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_clear
argument_list|(
name|context
operator|->
name|changes
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|changes_file
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|file_props
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|file_props_file
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|dir_props
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|dir_props_file
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|rev_offsets
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|path_order
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|references
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|context
operator|->
name|reps
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_trunc
argument_list|(
name|context
operator|->
name|reps_file
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Call this after the last revision range.  It will finalize all index files  * for CONTEXT and close any open files.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_pack_context
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|proto_l2p_index_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto_p2l_index_path
decl_stmt|;
comment|/* need the file names for the actual index creation call further down */
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|proto_l2p_index_path
argument_list|,
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|proto_p2l_index_path
argument_list|,
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finalize proto index files */
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append the actual index data to the pack file. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__add_index_data
argument_list|(
name|context
operator|->
name|fs
argument_list|,
name|context
operator|->
name|pack_file
argument_list|,
name|proto_l2p_index_path
argument_list|,
name|proto_p2l_index_path
argument_list|,
name|context
operator|->
name|shard_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove proto index files */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|proto_l2p_index_path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|proto_p2l_index_path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Efficiently copy SIZE bytes from SOURCE to DEST.  Invoke the CANCEL_FUNC  * from CONTEXT at regular intervals.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_file_data
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|dest
parameter_list|,
name|apr_file_t
modifier|*
name|source
parameter_list|,
name|apr_off_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* most non-representation items will be small.  Minimize the buffer    * and infrastructure overhead in that case. */
enum|enum
block|{
name|STACK_BUFFER_SIZE
init|=
literal|1024
block|}
enum|;
if|if
condition|(
name|size
operator|<
name|STACK_BUFFER_SIZE
condition|)
block|{
comment|/* copy small data using a fixed-size buffer on stack */
name|char
name|buffer
index|[
name|STACK_BUFFER_SIZE
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|source
argument_list|,
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dest
argument_list|,
name|buffer
argument_list|,
operator|(
name|apr_size_t
operator|)
name|size
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use streaming copies for larger data blocks.  That may require        * the allocation of larger buffers and we should make sure that        * this extra memory is released asap. */
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|copypool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|char
modifier|*
name|buffer
init|=
name|apr_palloc
argument_list|(
name|copypool
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
decl_stmt|;
while|while
condition|(
name|size
condition|)
block|{
name|apr_size_t
name|to_copy
init|=
call|(
name|apr_size_t
call|)
argument_list|(
name|MIN
argument_list|(
name|size
argument_list|,
name|ffd
operator|->
name|block_size
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|context
operator|->
name|cancel_func
argument_list|(
name|context
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_read_full2
argument_list|(
name|source
argument_list|,
name|buffer
argument_list|,
name|to_copy
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dest
argument_list|,
name|buffer
argument_list|,
name|to_copy
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|to_copy
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|copypool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Writes SIZE bytes, all 0, to DEST.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_null_bytes
parameter_list|(
name|apr_file_t
modifier|*
name|dest
parameter_list|,
name|apr_off_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Have a collection of high-quality, easy to access NUL bytes handy. */
enum|enum
block|{
name|BUFFER_SIZE
init|=
literal|1024
block|}
enum|;
specifier|static
specifier|const
name|char
name|buffer
index|[
name|BUFFER_SIZE
index|]
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* copy SIZE of them into the file's buffer */
while|while
condition|(
name|size
condition|)
block|{
name|apr_size_t
name|to_write
init|=
name|MIN
argument_list|(
name|size
argument_list|,
name|BUFFER_SIZE
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dest
argument_list|,
name|buffer
argument_list|,
name|to_write
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|-=
name|to_write
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the "simple" item (changed paths list or property representation)  * from the current position in REV_FILE to TEMP_FILE using CONTEXT.  Add  * a copy of ENTRY to ENTRIES but with an updated offset value that points  * to the copy destination in TEMP_FILE.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_item_to_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|new_entry
init|=
name|svn_fs_x__p2l_entry_dup
argument_list|(
name|entry
argument_list|,
name|context
operator|->
name|info_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_file_offset
argument_list|(
operator|&
name|new_entry
operator|->
name|offset
argument_list|,
name|temp_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|entries
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|new_entry
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the offset within CONTEXT->REPS that corresponds to item  * ITEM_INDEX in  REVISION.  */
end_comment

begin_function
specifier|static
name|int
name|get_item_array_index
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_int64_t
name|item_index
parameter_list|)
block|{
name|assert
argument_list|(
name|revision
operator|>=
name|context
operator|->
name|start_rev
argument_list|)
expr_stmt|;
return|return
operator|(
name|int
operator|)
name|item_index
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|rev_offsets
argument_list|,
name|revision
operator|-
name|context
operator|->
name|start_rev
argument_list|,
name|int
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write INFO to the correct position in CONTEXT->REPS.  The latter may  * need auto-expanding.  Overwriting an array element is not allowed.  */
end_comment

begin_function
specifier|static
name|void
name|add_item_rep_mapping
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|assert
argument_list|(
name|entry
operator|->
name|item_count
operator|==
literal|1
argument_list|)
expr_stmt|;
comment|/* index of INFO */
name|idx
operator|=
name|get_item_array_index
argument_list|(
name|context
argument_list|,
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
argument_list|,
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
argument_list|)
expr_stmt|;
comment|/* make sure the index exists in the array */
while|while
condition|(
name|context
operator|->
name|reps
operator|->
name|nelts
operator|<=
name|idx
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* set the element.  If there is already an entry, there are probably    * two items claiming to be the same -> bail out */
name|assert
argument_list|(
operator|!
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the P2L entry from CONTEXT->REPS for the given ID.  If there is  * none (or not anymore), return NULL.  If RESET has been specified, set  * the array entry to NULL after returning the entry.  */
end_comment

begin_function
specifier|static
name|svn_fs_x__p2l_entry_t
modifier|*
name|get_item
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|svn_boolean_t
name|reset
parameter_list|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
name|svn_fs_x__get_revnum
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
decl_stmt|;
if|if
condition|(
name|id
operator|->
name|number
operator|&&
name|revision
operator|>=
name|context
operator|->
name|start_rev
condition|)
block|{
name|int
name|idx
init|=
name|get_item_array_index
argument_list|(
name|context
argument_list|,
name|revision
argument_list|,
name|id
operator|->
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|reps
operator|->
name|nelts
operator|>
name|idx
condition|)
block|{
name|result
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|&&
name|reset
condition|)
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|idx
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Copy representation item identified by ENTRY from the current position  * in REV_FILE into CONTEXT->REPS_FILE.  Add all tracking into needed by  * our placement algorithm to CONTEXT.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_rep_to_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__rep_header_t
modifier|*
name|rep_header
decl_stmt|;
name|apr_off_t
name|source_offset
init|=
name|entry
operator|->
name|offset
decl_stmt|;
comment|/* create a copy of ENTRY, make it point to the copy destination and    * store it in CONTEXT */
name|entry
operator|=
name|svn_fs_x__p2l_entry_dup
argument_list|(
name|entry
argument_list|,
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_file_offset
argument_list|(
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|add_item_rep_mapping
argument_list|(
name|context
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* read& parse the representation header */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_rep_header
argument_list|(
operator|&
name|rep_header
argument_list|,
name|rev_file
operator|->
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the representation is a delta against some other rep, link the two */
if|if
condition|(
name|rep_header
operator|->
name|type
operator|==
name|svn_fs_x__rep_delta
operator|&&
name|rep_header
operator|->
name|base_revision
operator|>=
name|context
operator|->
name|start_rev
condition|)
block|{
name|reference_t
modifier|*
name|reference
init|=
name|apr_pcalloc
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reference
argument_list|)
argument_list|)
decl_stmt|;
name|reference
operator|->
name|from
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
name|reference
operator|->
name|to
operator|.
name|change_set
operator|=
name|svn_fs_x__change_set_by_rev
argument_list|(
name|rep_header
operator|->
name|base_revision
argument_list|)
expr_stmt|;
name|reference
operator|->
name|to
operator|.
name|number
operator|=
name|rep_header
operator|->
name|base_item_index
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|references
argument_list|,
name|reference_t
operator|*
argument_list|)
operator|=
name|reference
expr_stmt|;
block|}
comment|/* copy the whole rep (including header!) to our temp file */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|source_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Directories first, dirs / files sorted by name in reverse lexical order.  * This maximizes the chance of two items being located close to one another  * in *all* pack files independent of their change order.  It also groups  * multi-project repos nicely according to their sub-projects.  The reverse  * order aspect gives "trunk" preference over "tags" and "branches", so  * trunk-related items are more likely to be contiguous.  */
end_comment

begin_function
specifier|static
name|int
name|compare_dir_entries
parameter_list|(
specifier|const
name|svn_sort__item_t
modifier|*
name|a
parameter_list|,
specifier|const
name|svn_sort__item_t
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|svn_fs_dirent_t
modifier|*
name|lhs
init|=
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
operator|)
name|a
operator|->
name|value
decl_stmt|;
specifier|const
name|svn_fs_dirent_t
modifier|*
name|rhs
init|=
operator|(
specifier|const
name|svn_fs_dirent_t
operator|*
operator|)
name|b
operator|->
name|value
decl_stmt|;
if|if
condition|(
name|lhs
operator|->
name|kind
operator|!=
name|rhs
operator|->
name|kind
condition|)
return|return
name|lhs
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
name|strcmp
argument_list|(
name|lhs
operator|->
name|name
argument_list|,
name|rhs
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_function
name|apr_array_header_t
modifier|*
name|svn_fs_x__order_dir_entries
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_hash_t
modifier|*
name|directory
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|ordered
init|=
name|svn_sort__hash
argument_list|(
name|directory
argument_list|,
name|compare_dir_entries
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|result
init|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|ordered
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_dirent_t
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ordered
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|result
argument_list|,
name|svn_fs_dirent_t
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|ordered
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
operator|.
name|value
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Return a duplicate of the the ORIGINAL path and with special sub-strins  * (e.g. "trunk") modified in such a way that have a lower lexicographic  * value than any other "normal" file name.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|tweak_path_for_ordering
parameter_list|(
specifier|const
name|char
modifier|*
name|original
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* We may add further special cases as needed. */
enum|enum
block|{
name|SPECIAL_COUNT
init|=
literal|2
block|}
enum|;
specifier|static
specifier|const
name|char
modifier|*
name|special
index|[
name|SPECIAL_COUNT
index|]
init|=
block|{
literal|"trunk"
block|,
literal|"branch"
block|}
decl_stmt|;
name|char
modifier|*
name|pos
decl_stmt|;
name|char
modifier|*
name|path
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|original
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Replace the first char of any "special" sub-string we find by    * a control char, i.e. '\1' .. '\31'.  In the rare event that this    * would clash with existing paths, no data will be lost but merely    * the node ordering will be sub-optimal.    */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SPECIAL_COUNT
condition|;
operator|++
name|i
control|)
for|for
control|(
name|pos
operator|=
name|strstr
argument_list|(
name|path
argument_list|,
name|special
index|[
name|i
index|]
argument_list|)
init|;
name|pos
condition|;
name|pos
operator|=
name|strstr
argument_list|(
name|pos
operator|+
literal|1
argument_list|,
name|special
index|[
name|i
index|]
argument_list|)
control|)
block|{
operator|*
name|pos
operator|=
call|(
name|char
call|)
argument_list|(
name|i
operator|+
literal|'\1'
argument_list|)
expr_stmt|;
block|}
return|return
name|path
return|;
block|}
end_function

begin_comment
comment|/* Copy node revision item identified by ENTRY from the current position  * in REV_FILE into CONTEXT->REPS_FILE.  Add all tracking into needed by  * our placement algorithm to CONTEXT.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_node_to_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|path_order_t
modifier|*
name|path_order
init|=
name|apr_pcalloc
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|path_order
argument_list|)
argument_list|)
decl_stmt|;
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
specifier|const
name|char
modifier|*
name|sort_path
decl_stmt|;
name|apr_off_t
name|source_offset
init|=
name|entry
operator|->
name|offset
decl_stmt|;
comment|/* read& parse noderev */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_noderev
argument_list|(
operator|&
name|noderev
argument_list|,
name|rev_file
operator|->
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create a copy of ENTRY, make it point to the copy destination and    * store it in CONTEXT */
name|entry
operator|=
name|svn_fs_x__p2l_entry_dup
argument_list|(
name|entry
argument_list|,
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_file_offset
argument_list|(
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|add_item_rep_mapping
argument_list|(
name|context
argument_list|,
name|entry
argument_list|)
expr_stmt|;
comment|/* copy the noderev to our temp file */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|source_offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if the node has a data representation, make that the node's "base".    * This will (often) cause the noderev to be placed right in front of    * its data representation. */
if|if
condition|(
name|noderev
operator|->
name|data_rep
operator|&&
name|svn_fs_x__get_revnum
argument_list|(
name|noderev
operator|->
name|data_rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
operator|>=
name|context
operator|->
name|start_rev
condition|)
block|{
name|reference_t
modifier|*
name|reference
init|=
name|apr_pcalloc
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reference
argument_list|)
argument_list|)
decl_stmt|;
name|reference
operator|->
name|from
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
name|reference
operator|->
name|to
operator|.
name|change_set
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|id
operator|.
name|change_set
expr_stmt|;
name|reference
operator|->
name|to
operator|.
name|number
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|id
operator|.
name|number
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|references
argument_list|,
name|reference_t
operator|*
argument_list|)
operator|=
name|reference
expr_stmt|;
name|path_order
operator|->
name|rep_id
operator|=
name|reference
operator|->
name|to
expr_stmt|;
name|path_order
operator|->
name|expanded_size
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
expr_stmt|;
block|}
comment|/* Sort path is the key used for ordering noderevs and associated reps.    * It will not be stored in the final pack file. */
name|sort_path
operator|=
name|tweak_path_for_ordering
argument_list|(
name|noderev
operator|->
name|created_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|path_order
operator|->
name|path
operator|=
name|svn_prefix_string__create
argument_list|(
name|context
operator|->
name|paths
argument_list|,
name|sort_path
argument_list|)
expr_stmt|;
name|path_order
operator|->
name|node_id
operator|=
name|noderev
operator|->
name|node_id
expr_stmt|;
name|path_order
operator|->
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|noderev
operator|->
name|noderev_id
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|path_order
operator|->
name|is_dir
operator|=
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
expr_stmt|;
name|path_order
operator|->
name|noderev_id
operator|=
name|noderev
operator|->
name|noderev_id
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|path_order
argument_list|,
name|path_order_t
operator|*
argument_list|)
operator|=
name|path_order
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t. Place LHS before RHS, if the latter is older.  */
end_comment

begin_function
specifier|static
name|int
name|compare_p2l_info
parameter_list|(
specifier|const
name|svn_fs_x__p2l_entry_t
modifier|*
specifier|const
modifier|*
name|lhs
parameter_list|,
specifier|const
name|svn_fs_x__p2l_entry_t
modifier|*
specifier|const
modifier|*
name|rhs
parameter_list|)
block|{
name|assert
argument_list|(
operator|*
name|lhs
operator|!=
operator|*
name|rhs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|lhs
operator|)
operator|->
name|item_count
operator|==
literal|0
condition|)
return|return
operator|(
operator|*
name|lhs
operator|)
operator|->
name|item_count
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
return|;
if|if
condition|(
operator|(
operator|*
name|lhs
operator|)
operator|->
name|item_count
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|(
operator|*
name|lhs
operator|)
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
operator|==
operator|(
operator|*
name|rhs
operator|)
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
condition|)
return|return
operator|(
operator|*
name|lhs
operator|)
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
operator|>
operator|(
operator|*
name|rhs
operator|)
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
condition|?
operator|-
literal|1
else|:
literal|1
return|;
return|return
operator|(
operator|*
name|lhs
operator|)
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
operator|>
operator|(
operator|*
name|rhs
operator|)
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
condition|?
operator|-
literal|1
else|:
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Sort svn_fs_x__p2l_entry_t * array ENTRIES by age.  Place the latest  * items first.  */
end_comment

begin_function
specifier|static
name|void
name|sort_items
parameter_list|(
name|apr_array_header_t
modifier|*
name|entries
parameter_list|)
block|{
name|svn_sort__array
argument_list|(
name|entries
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_p2l_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t.  Sort descending by PATH, NODE_ID and REVISION.  */
end_comment

begin_function
specifier|static
name|int
name|compare_path_order
parameter_list|(
specifier|const
name|path_order_t
modifier|*
specifier|const
modifier|*
name|lhs_p
parameter_list|,
specifier|const
name|path_order_t
modifier|*
specifier|const
modifier|*
name|rhs_p
parameter_list|)
block|{
specifier|const
name|path_order_t
modifier|*
name|lhs
init|=
operator|*
name|lhs_p
decl_stmt|;
specifier|const
name|path_order_t
modifier|*
name|rhs
init|=
operator|*
name|rhs_p
decl_stmt|;
comment|/* cluster all directories */
name|int
name|diff
init|=
name|rhs
operator|->
name|is_dir
operator|-
name|lhs
operator|->
name|is_dir
decl_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
comment|/* lexicographic order on path and node (i.e. latest first) */
name|diff
operator|=
name|svn_prefix_string__compare
argument_list|(
name|lhs
operator|->
name|path
argument_list|,
name|rhs
operator|->
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
comment|/* reverse order on node (i.e. latest first) */
name|diff
operator|=
name|svn_fs_x__id_compare
argument_list|(
operator|&
name|rhs
operator|->
name|node_id
argument_list|,
operator|&
name|lhs
operator|->
name|node_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
comment|/* reverse order on revision (i.e. latest first) */
if|if
condition|(
name|lhs
operator|->
name|revision
operator|!=
name|rhs
operator|->
name|revision
condition|)
return|return
name|lhs
operator|->
name|revision
operator|<
name|rhs
operator|->
name|revision
condition|?
literal|1
else|:
operator|-
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* implements compare_fn_t.  Sort ascending by TO, FROM.  */
end_comment

begin_function
specifier|static
name|int
name|compare_references
parameter_list|(
specifier|const
name|reference_t
modifier|*
specifier|const
modifier|*
name|lhs_p
parameter_list|,
specifier|const
name|reference_t
modifier|*
specifier|const
modifier|*
name|rhs_p
parameter_list|)
block|{
specifier|const
name|reference_t
modifier|*
name|lhs
init|=
operator|*
name|lhs_p
decl_stmt|;
specifier|const
name|reference_t
modifier|*
name|rhs
init|=
operator|*
name|rhs_p
decl_stmt|;
name|int
name|diff
init|=
name|svn_fs_x__id_compare
argument_list|(
operator|&
name|lhs
operator|->
name|to
argument_list|,
operator|&
name|rhs
operator|->
name|to
argument_list|)
decl_stmt|;
return|return
name|diff
condition|?
name|diff
else|:
name|svn_fs_x__id_compare
argument_list|(
operator|&
name|lhs
operator|->
name|from
argument_list|,
operator|&
name|rhs
operator|->
name|from
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Order the data collected in CONTEXT such that we can place them in the  * desired order.  */
end_comment

begin_function
specifier|static
name|void
name|sort_reps
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|)
block|{
name|svn_sort__array
argument_list|(
name|context
operator|->
name|path_order
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_path_order
argument_list|)
expr_stmt|;
name|svn_sort__array
argument_list|(
name|context
operator|->
name|references
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
specifier|const
name|void
operator|*
argument_list|,
specifier|const
name|void
operator|*
argument_list|)
operator|)
name|compare_references
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the remaining unused bytes in the current block in CONTEXT's  * pack file.  */
end_comment

begin_function
specifier|static
name|apr_ssize_t
name|get_block_left
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
name|ffd
operator|->
name|block_size
operator|-
operator|(
name|context
operator|->
name|pack_offset
operator|%
name|ffd
operator|->
name|block_size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* To prevent items from overlapping a block boundary, we will usually  * put them into the next block and top up the old one with NUL bytes.  * Pad CONTEXT's pack file to the end of the current block, if that padding  * is short enough.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|auto_pad_block
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* This is the maximum number of bytes "wasted" that way per block.    * Larger items will cross the block boundaries. */
specifier|const
name|apr_off_t
name|max_padding
init|=
name|MAX
argument_list|(
name|ffd
operator|->
name|block_size
operator|/
literal|50
argument_list|,
literal|512
argument_list|)
decl_stmt|;
comment|/* Is wasted space small enough to align the current item to the next    * block? */
name|apr_off_t
name|padding
init|=
name|get_block_left
argument_list|(
name|context
argument_list|)
decl_stmt|;
if|if
condition|(
name|padding
operator|<
name|max_padding
condition|)
block|{
comment|/* Yes. To up with NUL bytes and don't forget to create        * an P2L index entry marking this section as unused. */
name|svn_fs_x__p2l_entry_t
name|null_entry
decl_stmt|;
name|null_entry
operator|.
name|offset
operator|=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|null_entry
operator|.
name|size
operator|=
name|padding
expr_stmt|;
name|null_entry
operator|.
name|type
operator|=
name|SVN_FS_X__ITEM_TYPE_UNUSED
expr_stmt|;
name|null_entry
operator|.
name|fnv1_checksum
operator|=
literal|0
expr_stmt|;
name|null_entry
operator|.
name|item_count
operator|=
literal|0
expr_stmt|;
name|null_entry
operator|.
name|items
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_null_bytes
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|padding
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
operator|&
name|null_entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|+=
name|padding
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the index of the first entry in CONTEXT->REFERENCES that  * references ITEM->ITEMS[0] if such entries exist.  All matching items  * will be consecutive.  */
end_comment

begin_function
specifier|static
name|int
name|find_first_reference
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|item
parameter_list|)
block|{
name|int
name|lower
init|=
literal|0
decl_stmt|;
name|int
name|upper
init|=
name|context
operator|->
name|references
operator|->
name|nelts
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|lower
operator|<=
name|upper
condition|)
block|{
name|int
name|current
init|=
name|lower
operator|+
operator|(
name|upper
operator|-
name|lower
operator|)
operator|/
literal|2
decl_stmt|;
name|reference_t
modifier|*
name|reference
init|=
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|references
argument_list|,
name|current
argument_list|,
name|reference_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_fs_x__id_compare
argument_list|(
operator|&
name|reference
operator|->
name|to
argument_list|,
name|item
operator|->
name|items
argument_list|)
operator|<
literal|0
condition|)
name|lower
operator|=
name|current
operator|+
literal|1
expr_stmt|;
else|else
name|upper
operator|=
name|current
operator|-
literal|1
expr_stmt|;
block|}
return|return
name|lower
return|;
block|}
end_function

begin_comment
comment|/* Check whether entry number IDX in CONTEXT->REFERENCES references ITEM.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_reference_match
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|int
name|idx
parameter_list|,
name|svn_fs_x__p2l_entry_t
modifier|*
name|item
parameter_list|)
block|{
name|reference_t
modifier|*
name|reference
decl_stmt|;
if|if
condition|(
name|context
operator|->
name|references
operator|->
name|nelts
operator|<=
name|idx
condition|)
return|return
name|FALSE
return|;
name|reference
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|references
argument_list|,
name|idx
argument_list|,
name|reference_t
operator|*
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|reference
operator|->
name|to
argument_list|,
name|item
operator|->
name|items
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Starting at IDX in CONTEXT->PATH_ORDER, select all representations and  * noderevs that should be placed into the same container, respectively.  * Append the path_order_t * elements encountered in SELECTED, the  * svn_fs_x__p2l_entry_t * of the representations that should be placed  * into the same reps container will be appended to REP_PARTS and the  * svn_fs_x__p2l_entry_t * of the noderevs referencing those reps will  * be appended to NODE_PARTS.  *  * Remove all returned items from the CONTEXT->REPS container and prevent  * them from being placed a second time later on.  That also means that the  * caller has to place all items returned.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|select_reps
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|int
name|idx
parameter_list|,
name|apr_array_header_t
modifier|*
name|selected
parameter_list|,
name|apr_array_header_t
modifier|*
name|node_parts
parameter_list|,
name|apr_array_header_t
modifier|*
name|rep_parts
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|path_order
init|=
name|context
operator|->
name|path_order
decl_stmt|;
name|path_order_t
modifier|*
name|start_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_order
argument_list|,
name|idx
argument_list|,
name|path_order_t
operator|*
argument_list|)
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|node_part
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|rep_part
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|depending
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
comment|/* collect all path_order records as well as rep and noderev items    * that occupy the same path with the same node. */
for|for
control|(
init|;
name|idx
operator|<
name|path_order
operator|->
name|nelts
condition|;
operator|++
name|idx
control|)
block|{
name|path_order_t
modifier|*
name|current_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_order
argument_list|,
name|idx
argument_list|,
name|path_order_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|start_path
operator|->
name|node_id
argument_list|,
operator|&
name|current_path
operator|->
name|node_id
argument_list|)
condition|)
break|break;
name|APR_ARRAY_IDX
argument_list|(
name|path_order
argument_list|,
name|idx
argument_list|,
name|path_order_t
operator|*
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|node_part
operator|=
name|get_item
argument_list|(
name|context
argument_list|,
operator|&
name|current_path
operator|->
name|noderev_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|rep_part
operator|=
name|get_item
argument_list|(
name|context
argument_list|,
operator|&
name|current_path
operator|->
name|rep_id
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_part
operator|&&
name|rep_part
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|selected
argument_list|,
name|path_order_t
operator|*
argument_list|)
operator|=
name|current_path
expr_stmt|;
if|if
condition|(
name|node_part
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|node_parts
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|node_part
expr_stmt|;
if|if
condition|(
name|rep_part
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|rep_parts
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|rep_part
expr_stmt|;
block|}
comment|/* collect depending reps and noderevs that reference any of the collected    * reps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rep_parts
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|rep_part
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|rep_parts
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
name|find_first_reference
argument_list|(
name|context
argument_list|,
name|rep_part
argument_list|)
init|;
name|is_reference_match
argument_list|(
name|context
argument_list|,
name|k
argument_list|,
name|rep_part
argument_list|)
condition|;
operator|++
name|k
control|)
block|{
name|reference_t
modifier|*
name|reference
init|=
name|APR_ARRAY_IDX
argument_list|(
name|context
operator|->
name|references
argument_list|,
name|k
argument_list|,
name|reference_t
operator|*
argument_list|)
decl_stmt|;
name|depending
operator|=
name|get_item
argument_list|(
name|context
argument_list|,
operator|&
name|reference
operator|->
name|from
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|depending
condition|)
continue|continue;
if|if
condition|(
name|depending
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_NODEREV
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|node_parts
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|depending
expr_stmt|;
else|else
name|APR_ARRAY_PUSH
argument_list|(
name|rep_parts
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|depending
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if all path_order_t * in SELECTED reference contents that is  * not longer than LIMIT.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|reps_fit_into_containers
parameter_list|(
name|apr_array_header_t
modifier|*
name|selected
parameter_list|,
name|apr_uint64_t
name|limit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|selected
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|APR_ARRAY_IDX
argument_list|(
name|selected
argument_list|,
name|i
argument_list|,
name|path_order_t
operator|*
argument_list|)
operator|->
name|expanded_size
operator|>
name|limit
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Write the *CONTAINER containing the noderevs described by the  * svn_fs_x__p2l_entry_t * in ITEMS to the pack file on CONTEXT.  * Append a P2L entry for the container to CONTAINER->REPS.  * Afterwards, clear ITEMS and re-allocate *CONTAINER in CONTAINER_POOL  * so the caller may fill them again.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_nodes_container
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__noderevs_t
modifier|*
modifier|*
name|container
parameter_list|,
name|apr_array_header_t
modifier|*
name|items
parameter_list|,
name|apr_pool_t
modifier|*
name|container_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|container_entry
decl_stmt|;
name|svn_stream_t
modifier|*
name|pack_stream
decl_stmt|;
if|if
condition|(
name|items
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* serialize container */
name|container_entry
operator|=
name|apr_palloc
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|container_entry
argument_list|)
argument_list|)
expr_stmt|;
name|pack_stream
operator|=
name|svn_checksum__wrap_write_stream_fnv1a_32x4
argument_list|(
operator|&
name|container_entry
operator|->
name|fnv1_checksum
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_noderevs_container
argument_list|(
name|pack_stream
argument_list|,
operator|*
name|container
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|pack_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* replace first noderev item in ENTRIES with the container      and set all others to NULL */
name|container_entry
operator|->
name|offset
operator|=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|container_entry
operator|->
name|size
operator|=
name|offset
operator|-
name|container_entry
operator|->
name|offset
expr_stmt|;
name|container_entry
operator|->
name|type
operator|=
name|SVN_FS_X__ITEM_TYPE_NODEREVS_CONT
expr_stmt|;
name|container_entry
operator|->
name|item_count
operator|=
name|items
operator|->
name|nelts
expr_stmt|;
name|container_entry
operator|->
name|items
operator|=
name|apr_palloc
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__id_t
argument_list|)
operator|*
name|container_entry
operator|->
name|item_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|items
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|container_entry
operator|->
name|items
index|[
name|i
index|]
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|items
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|=
name|offset
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|container_entry
expr_stmt|;
comment|/* Write P2L index for copied items, i.e. the 1 container */
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|container_entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|container_pool
argument_list|)
expr_stmt|;
operator|*
name|container
operator|=
name|svn_fs_x__noderevs_create
argument_list|(
literal|16
argument_list|,
name|container_pool
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|items
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the noderevs given by the svn_fs_x__p2l_entry_t * in NODE_PARTS  * from TEMP_FILE and add them to *CONTAINER and NODES_IN_CONTAINER.  * Whenever the container grows bigger than the current block in CONTEXT,  * write the data to disk and continue in the next block.  *  * Use CONTAINER_POOL to re-allocate the *CONTAINER as necessary and  * SCRATCH_POOL to temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_nodes
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_array_header_t
modifier|*
name|node_parts
parameter_list|,
name|svn_fs_x__noderevs_t
modifier|*
modifier|*
name|container
parameter_list|,
name|apr_array_header_t
modifier|*
name|nodes_in_container
parameter_list|,
name|apr_pool_t
modifier|*
name|container_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
init|=
name|svn_stream_from_aprfile2
argument_list|(
name|temp_file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* number of bytes in the current block not being spent on fixed-size      items (i.e. those not put into the container). */
name|apr_size_t
name|capacity_left
init|=
name|get_block_left
argument_list|(
name|context
argument_list|)
decl_stmt|;
comment|/* Estimated noderev container size */
name|apr_size_t
name|last_container_size
init|=
literal|0
decl_stmt|,
name|container_size
init|=
literal|0
decl_stmt|;
comment|/* Estimate extra capacity we will gain from container compression. */
name|apr_size_t
name|pack_savings
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|node_parts
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|node_parts
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
comment|/* if we reached the limit, check whether we saved some space          through the container. */
if|if
condition|(
name|capacity_left
operator|+
name|pack_savings
operator|<
name|container_size
operator|+
name|entry
operator|->
name|size
condition|)
name|container_size
operator|=
name|svn_fs_x__noderevs_estimate_size
argument_list|(
operator|*
name|container
argument_list|)
expr_stmt|;
comment|/* If necessary and the container is large enough, try harder          by actually serializing the container and determine current          savings due to compression. */
if|if
condition|(
name|capacity_left
operator|+
name|pack_savings
operator|<
name|container_size
operator|+
name|entry
operator|->
name|size
operator|&&
name|container_size
operator|>
name|last_container_size
operator|+
literal|2000
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|serialized
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|container_size
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|temp_stream
init|=
name|svn_stream_from_stringbuf
argument_list|(
name|serialized
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_noderevs_container
argument_list|(
name|temp_stream
argument_list|,
operator|*
name|container
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|temp_stream
argument_list|)
argument_list|)
expr_stmt|;
name|last_container_size
operator|=
name|container_size
expr_stmt|;
name|pack_savings
operator|=
name|container_size
operator|-
name|serialized
operator|->
name|len
expr_stmt|;
block|}
comment|/* still doesn't fit? -> block is full. Flush */
if|if
condition|(
name|capacity_left
operator|+
name|pack_savings
operator|<
name|container_size
operator|+
name|entry
operator|->
name|size
operator|&&
name|nodes_in_container
operator|->
name|nelts
operator|<
literal|2
condition|)
block|{
name|SVN_ERR
argument_list|(
name|auto_pad_block
argument_list|(
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|capacity_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* still doesn't fit? -> block is full. Flush */
if|if
condition|(
name|capacity_left
operator|+
name|pack_savings
operator|<
name|container_size
operator|+
name|entry
operator|->
name|size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|write_nodes_container
argument_list|(
name|context
argument_list|,
name|container
argument_list|,
name|nodes_in_container
argument_list|,
name|container_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|capacity_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|pack_savings
operator|=
literal|0
expr_stmt|;
name|container_size
operator|=
literal|0
expr_stmt|;
block|}
comment|/* item will fit into the block. */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|temp_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_noderev
argument_list|(
operator|&
name|noderev
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_x__noderevs_add
argument_list|(
operator|*
name|container
argument_list|,
name|noderev
argument_list|)
expr_stmt|;
name|container_size
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|nodes_in_container
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Finalize CONTAINER and write it to CONTEXT's pack file.  * Append an P2L entry containing the given SUB_ITEMS to NEW_ENTRIES.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_reps_container
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__reps_builder_t
modifier|*
name|container
parameter_list|,
name|apr_array_header_t
modifier|*
name|sub_items
parameter_list|,
name|apr_array_header_t
modifier|*
name|new_entries
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_fs_x__p2l_entry_t
name|container_entry
decl_stmt|;
name|svn_stream_t
modifier|*
name|pack_stream
init|=
name|svn_checksum__wrap_write_stream_fnv1a_32x4
argument_list|(
operator|&
name|container_entry
operator|.
name|fnv1_checksum
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_reps_container
argument_list|(
name|pack_stream
argument_list|,
name|container
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|pack_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|container_entry
operator|.
name|offset
operator|=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|container_entry
operator|.
name|size
operator|=
name|offset
operator|-
name|container_entry
operator|.
name|offset
expr_stmt|;
name|container_entry
operator|.
name|type
operator|=
name|SVN_FS_X__ITEM_TYPE_REPS_CONT
expr_stmt|;
name|container_entry
operator|.
name|item_count
operator|=
name|sub_items
operator|->
name|nelts
expr_stmt|;
name|container_entry
operator|.
name|items
operator|=
operator|(
name|svn_fs_x__id_t
operator|*
operator|)
name|sub_items
operator|->
name|elts
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|=
name|offset
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|new_entries
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|svn_fs_x__p2l_entry_dup
argument_list|(
operator|&
name|container_entry
argument_list|,
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
operator|&
name|container_entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the (property) representations identified by svn_fs_x__p2l_entry_t  * elements in ENTRIES from TEMP_FILE, aggregate them and write them into  * CONTEXT->PACK_FILE.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_reps_containers
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_array_header_t
modifier|*
name|new_entries
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|container_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_ssize_t
name|block_left
init|=
name|get_block_left
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|svn_fs_x__reps_builder_t
modifier|*
name|container
init|=
name|svn_fs_x__reps_builder_create
argument_list|(
name|context
operator|->
name|fs
argument_list|,
name|container_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sub_items
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|64
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__id_t
argument_list|)
argument_list|)
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__wrap_temp_rev_file
argument_list|(
operator|&
name|file
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|temp_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy all items in strict order */
for|for
control|(
name|i
operator|=
name|entries
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|svn_fs_x__representation_t
name|representation
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|contents
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_size_t
name|list_index
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|block_left
operator|<
name|entry
operator|->
name|size
operator|)
operator|&&
name|sub_items
operator|->
name|nelts
condition|)
block|{
name|block_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
operator|-
name|svn_fs_x__reps_estimate_size
argument_list|(
name|container
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|block_left
operator|<
name|entry
operator|->
name|size
operator|)
operator|&&
name|sub_items
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|write_reps_container
argument_list|(
name|context
argument_list|,
name|container
argument_list|,
name|sub_items
argument_list|,
name|new_entries
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|sub_items
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|container_pool
argument_list|)
expr_stmt|;
name|container
operator|=
name|svn_fs_x__reps_builder_create
argument_list|(
name|context
operator|->
name|fs
argument_list|,
name|container_pool
argument_list|)
expr_stmt|;
name|block_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* still enough space in current block? */
if|if
condition|(
name|block_left
operator|<
name|entry
operator|->
name|size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|auto_pad_block
argument_list|(
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|block_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
name|assert
argument_list|(
name|entry
operator|->
name|item_count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|representation
operator|.
name|id
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
comment|/* select the change list in the source file, parse it and add it to        * the container */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|temp_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_representation_length
argument_list|(
operator|&
name|representation
operator|.
name|size
argument_list|,
operator|&
name|representation
operator|.
name|expanded_size
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_contents
argument_list|(
operator|&
name|stream
argument_list|,
name|context
operator|->
name|fs
argument_list|,
operator|&
name|representation
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|contents
operator|=
name|svn_stringbuf_create_ensure
argument_list|(
name|representation
operator|.
name|expanded_size
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|contents
operator|->
name|len
operator|=
name|representation
operator|.
name|expanded_size
expr_stmt|;
comment|/* The representation is immutable.  Read it normally. */
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
name|contents
operator|->
name|data
argument_list|,
operator|&
name|contents
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__reps_add
argument_list|(
operator|&
name|list_index
argument_list|,
name|container
argument_list|,
name|svn_stringbuf__morph_into_string
argument_list|(
name|contents
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|list_index
operator|==
name|sub_items
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|block_left
operator|-=
name|entry
operator|->
name|size
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|sub_items
argument_list|,
name|svn_fs_x__id_t
argument_list|)
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sub_items
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|write_reps_container
argument_list|(
name|context
argument_list|,
name|container
argument_list|,
name|sub_items
argument_list|,
name|new_entries
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|container_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE if the estimated size of the NODES_IN_CONTAINER plus the  * representations given as svn_fs_x__p2l_entry_t * in ENTRIES may exceed  * the space left in the current block.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|should_flush_nodes_container
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__noderevs_t
modifier|*
name|nodes_container
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|)
block|{
name|apr_ssize_t
name|block_left
init|=
name|get_block_left
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|rep_sum
init|=
literal|0
decl_stmt|;
name|apr_ssize_t
name|container_size
init|=
name|svn_fs_x__noderevs_estimate_size
argument_list|(
name|nodes_container
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
name|rep_sum
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
block|}
return|return
name|block_left
operator|<
name|rep_sum
operator|+
name|container_size
return|;
block|}
end_function

begin_comment
comment|/* Read the contents of the first COUNT non-NULL, non-empty items in ITEMS  * from TEMP_FILE and write them to CONTEXT->PACK_FILE.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|store_items
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_array_header_t
modifier|*
name|items
parameter_list|,
name|int
name|count
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* copy all items in strict order */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|items
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|entry
operator|||
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_UNUSED
operator|||
name|entry
operator|->
name|item_count
operator|==
literal|0
condition|)
continue|continue;
comment|/* select the item in the source file and copy it into the target        * pack file */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|temp_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|pack_file
argument_list|,
name|temp_file
argument_list|,
name|entry
operator|->
name|size
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write index entry and update current position */
name|entry
operator|->
name|offset
operator|=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy (append) the items identified by svn_fs_x__p2l_entry_t * elements  * in ENTRIES strictly in order from TEMP_FILE into CONTEXT->PACK_FILE.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_reps_from_temp
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|container_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|path_order
init|=
name|context
operator|->
name|path_order
decl_stmt|;
name|apr_array_header_t
modifier|*
name|reps
init|=
name|context
operator|->
name|reps
decl_stmt|;
name|apr_array_header_t
modifier|*
name|selected
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|16
argument_list|,
name|path_order
operator|->
name|elt_size
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|node_parts
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|16
argument_list|,
name|reps
operator|->
name|elt_size
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|rep_parts
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|16
argument_list|,
name|reps
operator|->
name|elt_size
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|nodes_in_container
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|16
argument_list|,
name|reps
operator|->
name|elt_size
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|,
name|k
decl_stmt|;
name|int
name|initial_reps_count
init|=
name|reps
operator|->
name|nelts
decl_stmt|;
comment|/* 1 container for all noderevs in the current block.  We will try to    * not write it to disk until the current block fills up, i.e. aim for    * a single noderevs container per block. */
name|svn_fs_x__noderevs_t
modifier|*
name|nodes_container
init|=
name|svn_fs_x__noderevs_create
argument_list|(
literal|16
argument_list|,
name|container_pool
argument_list|)
decl_stmt|;
comment|/* copy items in path order. Create block-sized containers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_order
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|APR_ARRAY_IDX
argument_list|(
name|path_order
argument_list|,
name|i
argument_list|,
name|path_order_t
operator|*
argument_list|)
operator|==
name|NULL
condition|)
continue|continue;
comment|/* Collect reps to combine and all noderevs referencing them */
name|SVN_ERR
argument_list|(
name|select_reps
argument_list|(
name|context
argument_list|,
name|i
argument_list|,
name|selected
argument_list|,
name|node_parts
argument_list|,
name|rep_parts
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store the noderevs container in front of the reps */
name|SVN_ERR
argument_list|(
name|store_nodes
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|node_parts
argument_list|,
operator|&
name|nodes_container
argument_list|,
name|nodes_in_container
argument_list|,
name|container_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* actually flush the noderevs to disk if the reps container is likely        * to fill the block, i.e. no further noderevs will be added to the        * nodes container. */
if|if
condition|(
name|should_flush_nodes_container
argument_list|(
name|context
argument_list|,
name|nodes_container
argument_list|,
name|node_parts
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|write_nodes_container
argument_list|(
name|context
argument_list|,
operator|&
name|nodes_container
argument_list|,
name|nodes_in_container
argument_list|,
name|container_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if all reps are short enough put them into one container.        * Otherwise, just store all containers here. */
if|if
condition|(
name|reps_fit_into_containers
argument_list|(
name|selected
argument_list|,
literal|2
operator|*
name|ffd
operator|->
name|block_size
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|write_reps_containers
argument_list|(
name|context
argument_list|,
name|rep_parts
argument_list|,
name|temp_file
argument_list|,
name|context
operator|->
name|reps
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|store_items
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|rep_parts
argument_list|,
name|rep_parts
operator|->
name|nelts
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* processed all items */
name|apr_array_clear
argument_list|(
name|selected
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|node_parts
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|rep_parts
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* flush noderevs container to disk */
if|if
condition|(
name|nodes_in_container
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|write_nodes_container
argument_list|(
name|context
argument_list|,
operator|&
name|nodes_container
argument_list|,
name|nodes_in_container
argument_list|,
name|container_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* copy all items in strict order */
name|SVN_ERR
argument_list|(
name|store_items
argument_list|(
name|context
argument_list|,
name|temp_file
argument_list|,
name|reps
argument_list|,
name|initial_reps_count
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* vaccum ENTRIES array: eliminate NULL entries */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|k
operator|=
literal|0
init|;
name|i
operator|<
name|reps
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|reps
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|entry
condition|)
block|{
name|APR_ARRAY_IDX
argument_list|(
name|reps
argument_list|,
name|k
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
operator|++
name|k
expr_stmt|;
block|}
block|}
name|reps
operator|->
name|nelts
operator|=
name|k
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|container_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Finalize CONTAINER and write it to CONTEXT's pack file.  * Append an P2L entry containing the given SUB_ITEMS to NEW_ENTRIES.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_changes_container
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|svn_fs_x__changes_t
modifier|*
name|container
parameter_list|,
name|apr_array_header_t
modifier|*
name|sub_items
parameter_list|,
name|apr_array_header_t
modifier|*
name|new_entries
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_fs_x__p2l_entry_t
name|container_entry
decl_stmt|;
name|svn_stream_t
modifier|*
name|pack_stream
init|=
name|svn_checksum__wrap_write_stream_fnv1a_32x4
argument_list|(
operator|&
name|container_entry
operator|.
name|fnv1_checksum
argument_list|,
name|svn_stream_from_aprfile2
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_changes_container
argument_list|(
name|pack_stream
argument_list|,
name|container
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|pack_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|context
operator|->
name|pack_file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|container_entry
operator|.
name|offset
operator|=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|container_entry
operator|.
name|size
operator|=
name|offset
operator|-
name|container_entry
operator|.
name|offset
expr_stmt|;
name|container_entry
operator|.
name|type
operator|=
name|SVN_FS_X__ITEM_TYPE_CHANGES_CONT
expr_stmt|;
name|container_entry
operator|.
name|item_count
operator|=
name|sub_items
operator|->
name|nelts
expr_stmt|;
name|container_entry
operator|.
name|items
operator|=
operator|(
name|svn_fs_x__id_t
operator|*
operator|)
name|sub_items
operator|->
name|elts
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|=
name|offset
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|new_entries
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|svn_fs_x__p2l_entry_dup
argument_list|(
operator|&
name|container_entry
argument_list|,
name|context
operator|->
name|info_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
operator|&
name|container_entry
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the change lists identified by svn_fs_x__p2l_entry_t * elements  * in ENTRIES strictly in from TEMP_FILE, aggregate them and write them  * into CONTEXT->PACK_FILE.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_changes_containers
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|container_pool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_ssize_t
name|block_left
init|=
name|get_block_left
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|apr_ssize_t
name|estimated_addition
init|=
literal|0
decl_stmt|;
name|svn_fs_x__changes_t
modifier|*
name|container
init|=
name|svn_fs_x__changes_create
argument_list|(
literal|1000
argument_list|,
name|container_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sub_items
init|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
literal|64
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__id_t
argument_list|)
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|new_entries
init|=
name|apr_array_make
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
literal|16
argument_list|,
name|entries
operator|->
name|elt_size
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|temp_stream
init|=
name|svn_stream_from_aprfile2
argument_list|(
name|temp_file
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* copy all items in strict order */
for|for
control|(
name|i
operator|=
name|entries
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|apr_array_header_t
modifier|*
name|changes
decl_stmt|;
name|apr_size_t
name|list_index
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
decl_stmt|;
comment|/* zip compression alone will significantly reduce the size of large        * change lists. So, we will probably need even less than this estimate.        */
name|apr_ssize_t
name|estimated_size
init|=
operator|(
name|entry
operator|->
name|size
operator|/
literal|5
operator|)
operator|+
literal|250
decl_stmt|;
comment|/* If necessary and enough data has been added to the container since        * the last test, try harder by actually serializing the container and        * determine current savings due to compression. */
if|if
condition|(
name|block_left
operator|<
name|estimated_size
operator|&&
name|estimated_addition
operator|>
literal|2000
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|serialized
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|get_block_left
argument_list|(
name|context
argument_list|)
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|memory_stream
init|=
name|svn_stream_from_stringbuf
argument_list|(
name|serialized
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_changes_container
argument_list|(
name|memory_stream
argument_list|,
name|container
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|temp_stream
argument_list|)
argument_list|)
expr_stmt|;
name|block_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
operator|-
name|serialized
operator|->
name|len
expr_stmt|;
name|estimated_addition
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|block_left
operator|<
name|estimated_size
operator|)
operator|&&
name|sub_items
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|write_changes_container
argument_list|(
name|context
argument_list|,
name|container
argument_list|,
name|sub_items
argument_list|,
name|new_entries
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_array_clear
argument_list|(
name|sub_items
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|container_pool
argument_list|)
expr_stmt|;
name|container
operator|=
name|svn_fs_x__changes_create
argument_list|(
literal|1000
argument_list|,
name|container_pool
argument_list|)
expr_stmt|;
name|block_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|estimated_addition
operator|=
literal|0
expr_stmt|;
block|}
comment|/* still enough space in current block? */
if|if
condition|(
name|block_left
operator|<
name|estimated_size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|auto_pad_block
argument_list|(
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|block_left
operator|=
name|get_block_left
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* select the change list in the source file, parse it and add it to        * the container */
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|temp_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|entry
operator|->
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_changes
argument_list|(
operator|&
name|changes
argument_list|,
name|temp_stream
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__changes_append_list
argument_list|(
operator|&
name|list_index
argument_list|,
name|container
argument_list|,
name|changes
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|list_index
operator|==
name|sub_items
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|block_left
operator|-=
name|estimated_size
expr_stmt|;
name|estimated_addition
operator|+=
name|estimated_size
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|sub_items
argument_list|,
name|svn_fs_x__id_t
argument_list|)
operator|=
name|entry
operator|->
name|items
index|[
literal|0
index|]
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sub_items
operator|->
name|nelts
condition|)
name|SVN_ERR
argument_list|(
name|write_changes_container
argument_list|(
name|context
argument_list|,
name|container
argument_list|,
name|sub_items
argument_list|,
name|new_entries
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|entries
operator|=
operator|*
name|new_entries
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|container_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the (property) representations identified by svn_fs_x__p2l_entry_t  * elements in ENTRIES from TEMP_FILE, aggregate them and write them into  * CONTEXT->PACK_FILE.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_property_containers
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_array_header_t
modifier|*
name|entries
parameter_list|,
name|apr_file_t
modifier|*
name|temp_file
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|new_entries
init|=
name|apr_array_make
argument_list|(
name|context
operator|->
name|info_pool
argument_list|,
literal|16
argument_list|,
name|entries
operator|->
name|elt_size
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|write_reps_containers
argument_list|(
name|context
argument_list|,
name|entries
argument_list|,
name|temp_file
argument_list|,
name|new_entries
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|entries
operator|=
operator|*
name|new_entries
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Append all entries of svn_fs_x__p2l_entry_t * array TO_APPEND to  * svn_fs_x__p2l_entry_t * array DEST.  */
end_comment

begin_function
specifier|static
name|void
name|append_entries
parameter_list|(
name|apr_array_header_t
modifier|*
name|dest
parameter_list|,
name|apr_array_header_t
modifier|*
name|to_append
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|to_append
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|APR_ARRAY_PUSH
argument_list|(
name|dest
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|to_append
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write the log-to-phys proto index file for CONTEXT and use POOL for  * temporary allocations.  All items in all buckets must have been placed  * by now.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_l2p_index
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|temp_name
decl_stmt|;
specifier|const
name|char
modifier|*
name|proto_index
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
comment|/* lump all items into one bucket.  As target, use the bucket that    * probably has the most entries already. */
name|append_entries
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|context
operator|->
name|changes
argument_list|)
expr_stmt|;
name|append_entries
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|context
operator|->
name|file_props
argument_list|)
expr_stmt|;
name|append_entries
argument_list|(
name|context
operator|->
name|reps
argument_list|,
name|context
operator|->
name|dir_props
argument_list|)
expr_stmt|;
comment|/* Let the index code do the expensive L2P -> P2L transformation. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__l2p_index_from_p2l_entries
argument_list|(
operator|&
name|temp_name
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|context
operator|->
name|reps
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Append newly written segment to exisiting proto index file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_name_get
argument_list|(
operator|&
name|proto_index
argument_list|,
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_append_file
argument_list|(
name|temp_name
argument_list|,
name|proto_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|temp_name
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|APR_END
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Done. */
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Pack the current revision range of CONTEXT, i.e. this covers phases 2  * to 4.  Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_range
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|revpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Phase 2: Copy items into various buckets and build tracking info */
name|svn_revnum_t
name|revision
decl_stmt|;
for|for
control|(
name|revision
operator|=
name|context
operator|->
name|start_rev
init|;
name|revision
operator|<
name|context
operator|->
name|end_rev
condition|;
operator|++
name|revision
control|)
block|{
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
comment|/* Get the rev file dimensions (mainly index locations). */
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|revpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__auto_read_footer
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* store the indirect array index */
name|APR_ARRAY_PUSH
argument_list|(
name|context
operator|->
name|rev_offsets
argument_list|,
name|int
argument_list|)
operator|=
name|context
operator|->
name|reps
operator|->
name|nelts
expr_stmt|;
comment|/* read the phys-to-log index file until we covered the whole rev file.        * That index contains enough info to build both target indexes from it. */
while|while
condition|(
name|offset
operator|<
name|rev_file
operator|->
name|l2p_offset
condition|)
block|{
comment|/* read one cluster */
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|rev_file
argument_list|,
name|revision
argument_list|,
name|offset
argument_list|,
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* skip first entry if that was duplicated due crossing a                  cluster boundary */
if|if
condition|(
name|offset
operator|>
name|entry
operator|->
name|offset
condition|)
continue|continue;
comment|/* process entry while inside the rev file */
name|offset
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|rev_file
operator|->
name|l2p_offset
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|rev_file
operator|->
name|file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_CHANGES
condition|)
name|SVN_ERR
argument_list|(
name|copy_item_to_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|changes
argument_list|,
name|context
operator|->
name|changes_file
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_FILE_PROPS
condition|)
name|SVN_ERR
argument_list|(
name|copy_item_to_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|file_props
argument_list|,
name|context
operator|->
name|file_props_file
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_DIR_PROPS
condition|)
name|SVN_ERR
argument_list|(
name|copy_item_to_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|dir_props
argument_list|,
name|context
operator|->
name|dir_props_file
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_FILE_REP
operator|||
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_DIR_REP
condition|)
name|SVN_ERR
argument_list|(
name|copy_rep_to_temp
argument_list|(
name|context
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_NODEREV
condition|)
name|SVN_ERR
argument_list|(
name|copy_node_to_temp
argument_list|(
name|context
argument_list|,
name|rev_file
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|type
operator|==
name|SVN_FS_X__ITEM_TYPE_UNUSED
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
block|}
block|}
if|if
condition|(
name|context
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|context
operator|->
name|cancel_func
argument_list|(
name|context
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* phase 3: placement.    * Use "newest first" placement for simple items. */
name|sort_items
argument_list|(
name|context
operator|->
name|changes
argument_list|)
expr_stmt|;
name|sort_items
argument_list|(
name|context
operator|->
name|file_props
argument_list|)
expr_stmt|;
name|sort_items
argument_list|(
name|context
operator|->
name|dir_props
argument_list|)
expr_stmt|;
comment|/* follow dependencies recursively for noderevs and data representations */
name|sort_reps
argument_list|(
name|context
argument_list|)
expr_stmt|;
comment|/* phase 4: copy bucket data to pack file.  Write P2L index. */
name|SVN_ERR
argument_list|(
name|write_changes_containers
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|changes
argument_list|,
name|context
operator|->
name|changes_file
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_property_containers
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|file_props
argument_list|,
name|context
operator|->
name|file_props_file
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_property_containers
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|dir_props
argument_list|,
name|context
operator|->
name|dir_props_file
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_reps_from_temp
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|reps_file
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
comment|/* write L2P index as well (now that we know all target offsets) */
name|SVN_ERR
argument_list|(
name|write_l2p_index
argument_list|(
name|context
argument_list|,
name|revpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|revpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Append CONTEXT->START_REV to the context's pack file with no re-ordering.  * This function will only be used for very large revisions (>>100k changes).  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|append_revision
parameter_list|(
name|pack_context_t
modifier|*
name|context
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
comment|/* Get the size of the file. */
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_dirent_join
argument_list|(
name|context
operator|->
name|shard_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|context
operator|->
name|start_rev
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy all the bits from the rev file to the end of the pack file. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|rev_file
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|context
operator|->
name|start_rev
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_file_data
argument_list|(
name|context
argument_list|,
name|context
operator|->
name|pack_file
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|finfo
operator|.
name|size
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark the start of a new revision */
name|SVN_ERR
argument_list|(
name|svn_fs_x__l2p_proto_index_add_revision
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read the phys-to-log index file until we covered the whole rev file.    * That index contains enough info to build both target indexes from it. */
while|while
condition|(
name|offset
operator|<
name|finfo
operator|.
name|size
condition|)
block|{
comment|/* read one cluster */
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_index_lookup
argument_list|(
operator|&
name|entries
argument_list|,
name|context
operator|->
name|fs
argument_list|,
name|rev_file
argument_list|,
name|context
operator|->
name|start_rev
argument_list|,
name|offset
argument_list|,
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__p2l_entry_t
argument_list|)
decl_stmt|;
comment|/* skip first entry if that was duplicated due crossing a              cluster boundary */
if|if
condition|(
name|offset
operator|>
name|entry
operator|->
name|offset
condition|)
continue|continue;
comment|/* process entry while inside the rev file */
name|offset
operator|=
name|entry
operator|->
name|offset
expr_stmt|;
if|if
condition|(
name|offset
operator|<
name|finfo
operator|.
name|size
condition|)
block|{
comment|/* there should be true containers */
name|SVN_ERR_ASSERT
argument_list|(
name|entry
operator|->
name|item_count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|+=
name|context
operator|->
name|pack_offset
expr_stmt|;
name|offset
operator|+=
name|entry
operator|->
name|size
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__l2p_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_l2p_index
argument_list|,
name|entry
operator|->
name|offset
argument_list|,
literal|0
argument_list|,
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_proto_index_add_entry
argument_list|(
name|context
operator|->
name|proto_p2l_index
argument_list|,
name|entry
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|context
operator|->
name|pack_offset
operator|+=
name|finfo
operator|.
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Format 7 packing logic.  *  * Pack the revision shard starting at SHARD_REV in filesystem FS from  * SHARD_DIR into the PACK_FILE_DIR, using SCRATCH_POOL for temporary  * allocations.  Limit the extra memory consumption to MAX_MEM bytes.  * CANCEL_FUNC and CANCEL_BATON are what you think they are.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_log_addressed
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_dir
parameter_list|,
name|svn_revnum_t
name|shard_rev
parameter_list|,
name|apr_size_t
name|max_mem
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
enum|enum
block|{
comment|/* estimated amount of memory used to represent one item in memory        * during rev file packing */
name|PER_ITEM_MEM
init|=
name|APR_ALIGN_DEFAULT
argument_list|(
sizeof|sizeof
argument_list|(
name|path_order_t
argument_list|)
argument_list|)
operator|+
name|APR_ALIGN_DEFAULT
argument_list|(
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
operator|+
name|APR_ALIGN_DEFAULT
argument_list|(
sizeof|sizeof
argument_list|(
name|reference_t
argument_list|)
argument_list|)
operator|+
name|APR_ALIGN_DEFAULT
argument_list|(
sizeof|sizeof
argument_list|(
name|svn_fs_x__p2l_entry_t
argument_list|)
argument_list|)
operator|+
literal|6
operator|*
expr|sizeof
operator|(
name|void
operator|*
operator|)
block|}
enum|;
name|int
name|max_items
init|=
name|max_mem
operator|/
name|PER_ITEM_MEM
operator|>
name|INT_MAX
condition|?
name|INT_MAX
else|:
call|(
name|int
call|)
argument_list|(
name|max_mem
operator|/
name|PER_ITEM_MEM
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|max_ids
decl_stmt|;
name|pack_context_t
name|context
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_size_t
name|item_count
init|=
literal|0
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* set up a pack context */
name|SVN_ERR
argument_list|(
name|initialize_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|fs
argument_list|,
name|pack_file_dir
argument_list|,
name|shard_dir
argument_list|,
name|shard_rev
argument_list|,
name|max_items
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* phase 1: determine the size of the revisions to pack */
name|SVN_ERR
argument_list|(
name|svn_fs_x__l2p_get_max_ids
argument_list|(
operator|&
name|max_ids
argument_list|,
name|fs
argument_list|,
name|shard_rev
argument_list|,
name|context
operator|.
name|shard_end_rev
operator|-
name|shard_rev
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* pack revisions in ranges that don't exceed MAX_MEM */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|max_ids
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|APR_ARRAY_IDX
argument_list|(
name|max_ids
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
operator|+
name|item_count
operator|<=
name|max_items
condition|)
block|{
name|context
operator|.
name|end_rev
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* some unpacked revisions before this one? */
if|if
condition|(
name|context
operator|.
name|start_rev
operator|<
name|context
operator|.
name|end_rev
condition|)
block|{
comment|/* pack them intelligently (might be just 1 rev but still ...) */
name|SVN_ERR
argument_list|(
name|pack_range
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|reset_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|item_count
operator|=
literal|0
expr_stmt|;
block|}
comment|/* next revision range is to start with the current revision */
name|context
operator|.
name|start_rev
operator|=
name|i
operator|+
name|context
operator|.
name|shard_rev
expr_stmt|;
name|context
operator|.
name|end_rev
operator|=
name|context
operator|.
name|start_rev
operator|+
literal|1
expr_stmt|;
comment|/* if this is a very large revision, we must place it as is */
if|if
condition|(
name|APR_ARRAY_IDX
argument_list|(
name|max_ids
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
operator|>
name|max_items
condition|)
block|{
name|SVN_ERR
argument_list|(
name|append_revision
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|context
operator|.
name|start_rev
operator|++
expr_stmt|;
block|}
else|else
name|item_count
operator|+=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|max_ids
argument_list|,
name|i
argument_list|,
name|apr_uint64_t
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* non-empty revision range at the end? */
if|if
condition|(
name|context
operator|.
name|start_rev
operator|<
name|context
operator|.
name|end_rev
condition|)
name|SVN_ERR
argument_list|(
name|pack_range
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* last phase: finalize indexes and clean up */
name|SVN_ERR
argument_list|(
name|reset_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|close_pack_context
argument_list|(
operator|&
name|context
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Given REV in FS, set *REV_OFFSET to REV's offset in the packed file.    Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_packed_offset
parameter_list|(
name|apr_off_t
modifier|*
name|rev_offset
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|svn_revnum_t
name|shard
decl_stmt|;
name|apr_int64_t
name|shard_pos
decl_stmt|;
name|apr_array_header_t
modifier|*
name|manifest
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|shard
operator|=
name|rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* position of the shard within the manifest */
name|shard_pos
operator|=
name|rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* fetch exactly that element into *rev_offset, if the manifest is found      in the cache */
name|SVN_ERR
argument_list|(
name|svn_cache__get_partial
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|rev_offset
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|packed_offset_cache
argument_list|,
operator|&
name|shard
argument_list|,
name|svn_fs_x__get_sharded_offset
argument_list|,
operator|&
name|shard_pos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Open the manifest file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|manifest_stream
argument_list|,
name|svn_fs_x__path_rev_packed
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* While we're here, let's just read the entire manifest file into an array,      so we can cache the entire thing. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|manifest
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_number_from_stream
argument_list|(
operator|&
name|val
argument_list|,
operator|&
name|eof
argument_list|,
name|manifest_stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
break|break;
name|APR_ARRAY_PUSH
argument_list|(
name|manifest
argument_list|,
name|apr_off_t
argument_list|)
operator|=
operator|(
name|apr_off_t
operator|)
name|val
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|rev_offset
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|manifest
argument_list|,
name|rev
operator|%
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|apr_off_t
argument_list|)
expr_stmt|;
comment|/* Close up shop and cache the array. */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|packed_offset_cache
argument_list|,
operator|&
name|shard
argument_list|,
name|manifest
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* In filesystem FS, pack the revision SHARD containing exactly  * MAX_FILES_PER_DIR revisions from SHARD_PATH into the PACK_FILE_DIR,  * using SCRATCH_POOL for temporary allocations.  Try to limit the amount of  * temporary memory needed to MAX_MEM bytes.  CANCEL_FUNC and CANCEL_BATON  * are what you think they are.  *  * If for some reason we detect a partial packing already performed, we  * remove the pack file and start again.  *  * The actual packing will be done in a format-specific sub-function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_rev_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_size_t
name|max_mem
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pack_file_path
decl_stmt|;
name|svn_revnum_t
name|shard_rev
init|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|shard
operator|*
name|max_files_per_dir
argument_list|)
decl_stmt|;
comment|/* Some useful paths. */
name|pack_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_PACKED
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Remove any existing pack file for this shard, since it is incomplete. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|pack_file_dir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory and pack file. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|pack_file_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Index information files */
name|SVN_ERR
argument_list|(
name|pack_log_addressed
argument_list|(
name|fs
argument_list|,
name|pack_file_dir
argument_list|,
name|shard_path
argument_list|,
name|shard_rev
argument_list|,
name|max_mem
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|shard_path
argument_list|,
name|pack_file_dir
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|pack_file_path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In the file system at FS_PATH, pack the SHARD in REVS_DIR and  * REVPROPS_DIR containing exactly MAX_FILES_PER_DIR revisions, using  * SCRATCH_POOL temporary for allocations.  REVPROPS_DIR will be NULL if  * revprop packing is not supported.  COMPRESSION_LEVEL and MAX_PACK_SIZE  * will be ignored in that case.  *  * CANCEL_FUNC and CANCEL_BATON are what you think they are; similarly  * NOTIFY_FUNC and NOTIFY_BATON.  *  * If for some reason we detect a partial packing already performed, we  * remove the pack file and start again.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|revs_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|revsprops_dir
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_off_t
name|max_pack_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_fs_pack_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_shard_path
decl_stmt|,
modifier|*
name|rev_pack_file_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|,
modifier|*
name|revprops_pack_file_dir
decl_stmt|;
comment|/* Notify caller we're starting to pack this shard. */
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_pack_notify_start
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some useful paths. */
name|rev_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|revs_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|scratch_pool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|shard
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|rev_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revs_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* pack the revision content */
name|SVN_ERR
argument_list|(
name|pack_rev_shard
argument_list|(
name|fs
argument_list|,
name|rev_pack_file_dir
argument_list|,
name|rev_shard_path
argument_list|,
name|shard
argument_list|,
name|max_files_per_dir
argument_list|,
name|DEFAULT_MAX_MEM
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if enabled, pack the revprops in an equivalent way */
if|if
condition|(
name|revsprops_dir
condition|)
block|{
name|revprops_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|scratch_pool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|shard
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__pack_revprops_shard
argument_list|(
name|revprops_pack_file_dir
argument_list|,
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|max_files_per_dir
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|0.9
operator|*
name|max_pack_size
argument_list|)
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update the min-unpacked-rev file to reflect our newly packed shard. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|shard
operator|+
literal|1
operator|)
operator|*
name|max_files_per_dir
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|min_unpacked_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|shard
operator|+
literal|1
operator|)
operator|*
name|max_files_per_dir
argument_list|)
expr_stmt|;
comment|/* Finally, remove the existing shard directories.    * For revprops, clean up older obsolete shards as well as they might    * have been left over from an interrupted FS upgrade. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|rev_shard_path
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revsprops_dir
condition|)
block|{
name|svn_node_kind_t
name|kind
init|=
name|svn_node_dir
decl_stmt|;
name|apr_int64_t
name|to_cleanup
init|=
name|shard
decl_stmt|;
do|do
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_x__delete_revprops_shard
argument_list|(
name|revprops_shard_path
argument_list|,
name|to_cleanup
argument_list|,
name|max_files_per_dir
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the previous shard exists, clean it up as well.              Don't try to clean up shard 0 as it we can't tell quickly              whether it actually needs cleaning up. */
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
operator|--
name|to_cleanup
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|revprops_shard_path
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|kind
operator|==
name|svn_node_dir
operator|&&
name|to_cleanup
operator|>
literal|0
condition|)
do|;
block|}
comment|/* Notify caller we're starting to pack this shard. */
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_pack_notify_end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|pack_baton_t
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_pack_notify_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
name|pack_baton_t
typedef|;
end_typedef

begin_comment
comment|/* The work-horse for svn_fs_x__pack, called with the FS write lock.    This implements the svn_fs_x__with_write_lock() 'body' callback    type.  BATON is a 'pack_baton_t *'.     WARNING: if you add a call to this function, please note:      The code currently assumes that any piece of code running with      the write-lock set can rely on the ffd->min_unpacked_rev and      ffd->min_unpacked_revprop caches to be up-to-date (and, by      extension, on not having to use a retry when calling      svn_fs_x__path_rev_absolute() and friends).  If you add a call      to this function, consider whether you have to call      update_min_unpacked_rev().      See this thread: http://thread.gmane.org/1291206765.3782.3309.camel@edith  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pack_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|pack_baton_t
modifier|*
name|pb
init|=
name|baton
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|pb
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_int64_t
name|completed_shards
decl_stmt|;
name|apr_int64_t
name|i
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_data_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_data_path
init|=
name|NULL
decl_stmt|;
comment|/* If we aren't using sharding, we can't do any packing, so quit. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_min_unpacked_rev
argument_list|(
operator|&
name|ffd
operator|->
name|min_unpacked_rev
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|completed_shards
operator|=
operator|(
name|youngest
operator|+
literal|1
operator|)
operator|/
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
comment|/* See if we've already completed all possible shards thus far. */
if|if
condition|(
name|ffd
operator|->
name|min_unpacked_rev
operator|==
operator|(
name|completed_shards
operator|*
name|ffd
operator|->
name|max_files_per_dir
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|rev_data_path
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|revprops_data_path
operator|=
name|svn_dirent_join
argument_list|(
name|pb
operator|->
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
init|;
name|i
operator|<
name|completed_shards
condition|;
name|i
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|pb
operator|->
name|cancel_func
argument_list|(
name|pb
operator|->
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|pack_shard
argument_list|(
name|rev_data_path
argument_list|,
name|revprops_data_path
argument_list|,
name|pb
operator|->
name|fs
argument_list|,
name|i
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|ffd
operator|->
name|revprop_pack_size
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN__COMPRESSION_ZLIB_DEFAULT
else|:
name|SVN__COMPRESSION_NONE
argument_list|,
name|pb
operator|->
name|notify_func
argument_list|,
name|pb
operator|->
name|notify_baton
argument_list|,
name|pb
operator|->
name|cancel_func
argument_list|,
name|pb
operator|->
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__pack
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_pack_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|pack_baton_t
name|pb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|pb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|pb
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|pb
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|pb
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|pb
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|svn_fs_x__with_pack_lock
argument_list|(
name|fs
argument_list|,
name|pack_body
argument_list|,
operator|&
name|pb
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

end_unit

