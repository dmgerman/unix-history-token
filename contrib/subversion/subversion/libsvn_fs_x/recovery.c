begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* recovery.c --- FSX recovery functionality *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"recovery.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"low_level.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Part of the recovery procedure.  Return the largest revision *REV in    filesystem FS.  Use SCRATCH_POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_get_largest_revision
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Discovering the largest revision in the filesystem would be an      expensive operation if we did a readdir() or searched linearly,      so we'll do a form of binary search.  left is a revision that we      know exists, right a revision that we know does not exist. */
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_revnum_t
name|left
decl_stmt|,
name|right
init|=
literal|1
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Keep doubling right, until we find a revision that doesn't exist. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|file
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|right
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|right
operator|<<=
literal|1
expr_stmt|;
block|}
name|left
operator|=
name|right
operator|>>
literal|1
expr_stmt|;
comment|/* We know that left exists and right doesn't.  Do a normal bsearch to find      the last revision. */
while|while
condition|(
name|left
operator|+
literal|1
operator|<
name|right
condition|)
block|{
name|svn_revnum_t
name|probe
init|=
name|left
operator|+
operator|(
operator|(
name|right
operator|-
name|left
operator|)
operator|/
literal|2
operator|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|file
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_x__open_pack_or_rev_file
argument_list|(
operator|&
name|file
argument_list|,
name|fs
argument_list|,
name|probe
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_REVISION
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|right
operator|=
name|probe
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|left
operator|=
name|probe
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* left is now the largest revision that exists. */
operator|*
name|rev
operator|=
name|left
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for recover_body below. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|recover_baton_t
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
name|recover_baton_t
typedef|;
end_typedef

begin_comment
comment|/* The work-horse for svn_fs_x__recover, called with the FS    write lock.  This implements the svn_fs_x__with_write_lock()    'body' callback type.  BATON is a 'recover_baton_t *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recover_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|recover_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|b
operator|->
name|fs
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_revnum_t
name|max_rev
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_boolean_t
name|revprop_missing
init|=
name|TRUE
decl_stmt|;
name|svn_boolean_t
name|revprop_accessible
init|=
name|FALSE
decl_stmt|;
comment|/* Lose potentially corrupted data in temp files */
name|SVN_ERR
argument_list|(
name|svn_fs_x__reset_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The admin may have created a plain copy of this repo before attempting      to recover it (hotcopy may or may not work with corrupted repos).      Bump the instance ID. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__set_uuid
argument_list|(
name|fs
argument_list|,
name|fs
operator|->
name|uuid
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We need to know the largest revision in the filesystem. */
name|SVN_ERR
argument_list|(
name|recover_get_largest_revision
argument_list|(
name|fs
argument_list|,
operator|&
name|max_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the expected youngest revision */
name|SVN_ERR
argument_list|(
name|svn_fs_x__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Policy note:       Since the revprops file is written after the revs file, the true      maximum available revision is the youngest one for which both are      present.  That's probably the same as the max_rev we just found,      but if it's not, we could, in theory, repeatedly decrement      max_rev until we find a revision that has both a revs and      revprops file, then write db/current with that.       But we choose not to.  If a repository is so corrupt that it's      missing at least one revprops file, we shouldn't assume that the      youngest revision for which both the revs and revprops files are      present is healthy.  In other words, we're willing to recover      from a missing or out-of-date db/current file, because db/current      is truly redundant -- it's basically a cache so we don't have to      find max_rev each time, albeit a cache with unusual semantics,      since it also officially defines when a revision goes live.  But      if we're missing more than the cache, it's time to back out and      let the admin reconstruct things by hand: correctness at that      point may depend on external things like checking a commit email      list, looking in particular working copies, etc.       This policy matches well with a typical naive backup scenario.      Say you're rsyncing your FSX repository nightly to the same      location.  Once revs and revprops are written, you've got the      maximum rev; if the backup should bomb before db/current is      written, then db/current could stay arbitrarily out-of-date, but      we can still recover.  It's a small window, but we might as well      do what we can. */
comment|/* Even if db/current were missing, it would be created with 0 by      get_youngest(), so this conditional remains valid. */
if|if
condition|(
name|youngest_rev
operator|>
name|max_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected current rev to be<= %ld "
literal|"but found %ld"
argument_list|)
argument_list|,
name|max_rev
argument_list|,
name|youngest_rev
argument_list|)
return|;
comment|/* Before setting current, verify that there is a revprops file      for the youngest revision.  (Issue #2992) */
if|if
condition|(
name|svn_fs_x__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|)
condition|)
block|{
name|revprop_accessible
operator|=
name|svn_fs_x__packed_revprop_available
argument_list|(
operator|&
name|revprop_missing
argument_list|,
name|fs
argument_list|,
name|max_rev
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_node_kind_t
name|youngest_revprops_kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|svn_fs_x__path_revprops
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|&
name|youngest_revprops_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|youngest_revprops_kind
operator|==
name|svn_node_file
condition|)
block|{
name|revprop_missing
operator|=
name|FALSE
expr_stmt|;
name|revprop_accessible
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|youngest_revprops_kind
operator|!=
name|svn_node_none
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a non-file where its "
literal|"revprops file should be"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|revprop_accessible
condition|)
block|{
if|if
condition|(
name|revprop_missing
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a revs file but no "
literal|"revprops file"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision %ld has a revs file but the "
literal|"revprops file is inaccessible"
argument_list|)
argument_list|,
name|max_rev
argument_list|)
return|;
block|}
block|}
comment|/* Prune younger-than-(newfound-youngest) revisions from the rep      cache if sharing is enabled taking care not to create the cache      if it does not exist. */
if|if
condition|(
name|ffd
operator|->
name|rep_sharing_allowed
condition|)
block|{
name|svn_boolean_t
name|rep_cache_exists
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__exists_rep_cache
argument_list|(
operator|&
name|rep_cache_exists
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_cache_exists
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__del_rep_reference
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now store the discovered youngest revision, and the next IDs if      relevant, in a new 'current' file. */
return|return
name|svn_fs_x__write_current
argument_list|(
name|fs
argument_list|,
name|max_rev
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements the fs_library_vtable_t.recover() API. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__recover
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|recover_baton_t
name|b
decl_stmt|;
comment|/* We have no way to take out an exclusive lock in FSX, so we're      restricted as to the types of recovery we can do.  Luckily,      we just want to recreate the 'current' file, and we can do that just      by blocking other writers. */
name|b
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|b
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|svn_fs_x__with_all_locks
argument_list|(
name|fs
argument_list|,
name|recover_body
argument_list|,
operator|&
name|b
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

end_unit

