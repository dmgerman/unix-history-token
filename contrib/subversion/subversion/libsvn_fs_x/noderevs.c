begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* noderevs.h --- FSX node revision container  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_packed_data.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"noderevs.h"
end_include

begin_include
include|#
directive|include
file|"string_table.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_comment
comment|/* These flags will be used with the FLAGS field in binary_noderev_t.  */
end_comment

begin_comment
comment|/* (flags& NODEREV_KIND_MASK) extracts the noderev type */
end_comment

begin_define
define|#
directive|define
name|NODEREV_KIND_MASK
value|0x00007
end_define

begin_comment
comment|/* the noderev has merge info */
end_comment

begin_define
define|#
directive|define
name|NODEREV_HAS_MINFO
value|0x00008
end_define

begin_comment
comment|/* the noderev has copy-from-path and revision */
end_comment

begin_define
define|#
directive|define
name|NODEREV_HAS_COPYFROM
value|0x00010
end_define

begin_comment
comment|/* the noderev has copy-root path and revision */
end_comment

begin_define
define|#
directive|define
name|NODEREV_HAS_COPYROOT
value|0x00020
end_define

begin_comment
comment|/* the noderev has copy-root path and revision */
end_comment

begin_define
define|#
directive|define
name|NODEREV_HAS_CPATH
value|0x00040
end_define

begin_comment
comment|/* Our internal representation of a svn_fs_x__noderev_t.  *  * We will store path strings in a string container and reference them  * from here.  Similarly, IDs and representations are being stored in  * separate containers and then also referenced here.  This eliminates  * the need to store the same IDs and representations more than once.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|binary_noderev_t
block|{
comment|/* node type and presence indicators */
name|apr_uint32_t
name|flags
decl_stmt|;
comment|/* Index+1 of the noderev-id for this node-rev. */
name|int
name|id
decl_stmt|;
comment|/* Index+1 of the node-id for this node-rev. */
name|int
name|node_id
decl_stmt|;
comment|/* Index+1 of the copy-id for this node-rev. */
name|int
name|copy_id
decl_stmt|;
comment|/* Index+1 of the predecessor node revision id, or 0 if there is no      predecessor for this node revision */
name|int
name|predecessor_id
decl_stmt|;
comment|/* number of predecessors this node revision has (recursively), or      -1 if not known (for backward compatibility). */
name|int
name|predecessor_count
decl_stmt|;
comment|/* If this node-rev is a copy, what revision was it copied from? */
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* Helper for history tracing, root revision of the parent tree from      whence this node-rev was copied. */
name|svn_revnum_t
name|copyroot_rev
decl_stmt|;
comment|/* If this node-rev is a copy, this is the string index+1 of the path      from which that copy way made. 0, otherwise. */
name|apr_size_t
name|copyfrom_path
decl_stmt|;
comment|/* String index+1 of the root of the parent tree from whence this node-    * rev was copied. */
name|apr_size_t
name|copyroot_path
decl_stmt|;
comment|/* Index+1 of the representation key for this node's properties.      May be 0 if there are no properties.  */
name|int
name|prop_rep
decl_stmt|;
comment|/* Index+1 of the representation for this node's data.      May be 0 if there is no data. */
name|int
name|data_rep
decl_stmt|;
comment|/* String index+1 of the path at which this node first came into      existence.  */
name|apr_size_t
name|created_path
decl_stmt|;
comment|/* Number of nodes with svn:mergeinfo properties that are      descendants of this node (including it itself) */
name|apr_int64_t
name|mergeinfo_count
decl_stmt|;
block|}
name|binary_noderev_t
typedef|;
end_typedef

begin_comment
comment|/* The actual container object.  Node revisions are concatenated into  * NODEREVS, referenced representations are stored in DATA_REPS / PROP_REPS  * and the ids in IDs.  PATHS is the string table for all paths.  *  * During construction, BUILDER will be used instead of PATHS. IDS_DICT,  * DATA_REPS_DICT and PROP_REPS_DICT are also only used during construction  * and are NULL otherwise.  */
end_comment

begin_struct
struct|struct
name|svn_fs_x__noderevs_t
block|{
comment|/* The paths - either in 'builder' mode or finalized mode.    * The respective other pointer will be NULL. */
name|string_table_builder_t
modifier|*
name|builder
decl_stmt|;
name|string_table_t
modifier|*
name|paths
decl_stmt|;
comment|/* During construction, maps a full binary_id_t to an index into IDS */
name|apr_hash_t
modifier|*
name|ids_dict
decl_stmt|;
comment|/* During construction, maps a full binary_representation_t to an index    * into REPS. */
name|apr_hash_t
modifier|*
name|reps_dict
decl_stmt|;
comment|/* array of binary_id_t */
name|apr_array_header_t
modifier|*
name|ids
decl_stmt|;
comment|/* array of binary_representation_t */
name|apr_array_header_t
modifier|*
name|reps
decl_stmt|;
comment|/* array of binary_noderev_t. */
name|apr_array_header_t
modifier|*
name|noderevs
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|svn_fs_x__noderevs_t
modifier|*
name|svn_fs_x__noderevs_create
parameter_list|(
name|int
name|initial_count
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__noderevs_t
modifier|*
name|noderevs
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderevs
argument_list|)
argument_list|)
decl_stmt|;
name|noderevs
operator|->
name|builder
operator|=
name|svn_fs_x__string_table_builder_create
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|noderevs
operator|->
name|ids_dict
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|noderevs
operator|->
name|reps_dict
operator|=
name|svn_hash__make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|noderevs
operator|->
name|paths
operator|=
name|NULL
expr_stmt|;
name|noderevs
operator|->
name|ids
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|2
operator|*
name|initial_count
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__id_t
argument_list|)
argument_list|)
expr_stmt|;
name|noderevs
operator|->
name|reps
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|2
operator|*
name|initial_count
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__representation_t
argument_list|)
argument_list|)
expr_stmt|;
name|noderevs
operator|->
name|noderevs
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|initial_count
argument_list|,
sizeof|sizeof
argument_list|(
name|binary_noderev_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|noderevs
return|;
block|}
end_function

begin_comment
comment|/* Given the ID, return the index+1 into IDS that contains a binary_id  * for it.  Returns 0 for NULL IDs.  We use DICT to detect duplicates.  */
end_comment

begin_function
specifier|static
name|int
name|store_id
parameter_list|(
name|apr_array_header_t
modifier|*
name|ids
parameter_list|,
name|apr_hash_t
modifier|*
name|dict
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|void
modifier|*
name|idx_void
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fs_x__id_used
argument_list|(
name|id
argument_list|)
condition|)
return|return
literal|0
return|;
name|idx_void
operator|=
name|apr_hash_get
argument_list|(
name|dict
argument_list|,
operator|&
name|id
argument_list|,
sizeof|sizeof
argument_list|(
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|int
operator|)
operator|(
name|apr_uintptr_t
operator|)
name|idx_void
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|ids
argument_list|,
name|svn_fs_x__id_t
argument_list|)
operator|=
operator|*
name|id
expr_stmt|;
name|idx
operator|=
name|ids
operator|->
name|nelts
expr_stmt|;
name|apr_hash_set
argument_list|(
name|dict
argument_list|,
name|ids
operator|->
name|elts
operator|+
operator|(
name|idx
operator|-
literal|1
operator|)
operator|*
name|ids
operator|->
name|elt_size
argument_list|,
name|ids
operator|->
name|elt_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|apr_uintptr_t
operator|)
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_comment
comment|/* Given the REP, return the index+1 into REPS that contains a copy of it.  * Returns 0 for NULL IDs.  We use DICT to detect duplicates.  */
end_comment

begin_function
specifier|static
name|int
name|store_representation
parameter_list|(
name|apr_array_header_t
modifier|*
name|reps
parameter_list|,
name|apr_hash_t
modifier|*
name|dict
parameter_list|,
specifier|const
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|)
block|{
name|int
name|idx
decl_stmt|;
name|void
modifier|*
name|idx_void
decl_stmt|;
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
name|idx_void
operator|=
name|apr_hash_get
argument_list|(
name|dict
argument_list|,
name|rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|(
name|int
operator|)
operator|(
name|apr_uintptr_t
operator|)
name|idx_void
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
name|reps
argument_list|,
name|svn_fs_x__representation_t
argument_list|)
operator|=
operator|*
name|rep
expr_stmt|;
name|idx
operator|=
name|reps
operator|->
name|nelts
expr_stmt|;
name|apr_hash_set
argument_list|(
name|dict
argument_list|,
name|reps
operator|->
name|elts
operator|+
operator|(
name|idx
operator|-
literal|1
operator|)
operator|*
name|reps
operator|->
name|elt_size
argument_list|,
name|reps
operator|->
name|elt_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|apr_uintptr_t
operator|)
name|idx
argument_list|)
expr_stmt|;
block|}
return|return
name|idx
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_fs_x__noderevs_add
parameter_list|(
name|svn_fs_x__noderevs_t
modifier|*
name|container
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|)
block|{
name|binary_noderev_t
name|binary_noderev
init|=
block|{
literal|0
block|}
decl_stmt|;
name|binary_noderev
operator|.
name|flags
operator|=
operator|(
name|noderev
operator|->
name|has_mergeinfo
condition|?
name|NODEREV_HAS_MINFO
else|:
literal|0
operator|)
operator||
operator|(
name|noderev
operator|->
name|copyfrom_path
condition|?
name|NODEREV_HAS_COPYFROM
else|:
literal|0
operator|)
operator||
operator|(
name|noderev
operator|->
name|copyroot_path
condition|?
name|NODEREV_HAS_COPYROOT
else|:
literal|0
operator|)
operator||
operator|(
name|noderev
operator|->
name|created_path
condition|?
name|NODEREV_HAS_CPATH
else|:
literal|0
operator|)
operator||
operator|(
name|int
operator|)
name|noderev
operator|->
name|kind
expr_stmt|;
name|binary_noderev
operator|.
name|id
operator|=
name|store_id
argument_list|(
name|container
operator|->
name|ids
argument_list|,
name|container
operator|->
name|ids_dict
argument_list|,
operator|&
name|noderev
operator|->
name|noderev_id
argument_list|)
expr_stmt|;
name|binary_noderev
operator|.
name|node_id
operator|=
name|store_id
argument_list|(
name|container
operator|->
name|ids
argument_list|,
name|container
operator|->
name|ids_dict
argument_list|,
operator|&
name|noderev
operator|->
name|node_id
argument_list|)
expr_stmt|;
name|binary_noderev
operator|.
name|copy_id
operator|=
name|store_id
argument_list|(
name|container
operator|->
name|ids
argument_list|,
name|container
operator|->
name|ids_dict
argument_list|,
operator|&
name|noderev
operator|->
name|copy_id
argument_list|)
expr_stmt|;
name|binary_noderev
operator|.
name|predecessor_id
operator|=
name|store_id
argument_list|(
name|container
operator|->
name|ids
argument_list|,
name|container
operator|->
name|ids_dict
argument_list|,
operator|&
name|noderev
operator|->
name|predecessor_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|copyfrom_path
condition|)
block|{
name|binary_noderev
operator|.
name|copyfrom_path
operator|=
name|svn_fs_x__string_table_builder_add
argument_list|(
name|container
operator|->
name|builder
argument_list|,
name|noderev
operator|->
name|copyfrom_path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binary_noderev
operator|.
name|copyfrom_rev
operator|=
name|noderev
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
if|if
condition|(
name|noderev
operator|->
name|copyroot_path
condition|)
block|{
name|binary_noderev
operator|.
name|copyroot_path
operator|=
name|svn_fs_x__string_table_builder_add
argument_list|(
name|container
operator|->
name|builder
argument_list|,
name|noderev
operator|->
name|copyroot_path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binary_noderev
operator|.
name|copyroot_rev
operator|=
name|noderev
operator|->
name|copyroot_rev
expr_stmt|;
block|}
name|binary_noderev
operator|.
name|predecessor_count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
name|binary_noderev
operator|.
name|prop_rep
operator|=
name|store_representation
argument_list|(
name|container
operator|->
name|reps
argument_list|,
name|container
operator|->
name|reps_dict
argument_list|,
name|noderev
operator|->
name|prop_rep
argument_list|)
expr_stmt|;
name|binary_noderev
operator|.
name|data_rep
operator|=
name|store_representation
argument_list|(
name|container
operator|->
name|reps
argument_list|,
name|container
operator|->
name|reps_dict
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|created_path
condition|)
name|binary_noderev
operator|.
name|created_path
operator|=
name|svn_fs_x__string_table_builder_add
argument_list|(
name|container
operator|->
name|builder
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|binary_noderev
operator|.
name|mergeinfo_count
operator|=
name|noderev
operator|->
name|mergeinfo_count
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|container
operator|->
name|noderevs
argument_list|,
name|binary_noderev_t
argument_list|)
operator|=
name|binary_noderev
expr_stmt|;
return|return
name|container
operator|->
name|noderevs
operator|->
name|nelts
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_fs_x__noderevs_estimate_size
parameter_list|(
specifier|const
name|svn_fs_x__noderevs_t
modifier|*
name|container
parameter_list|)
block|{
comment|/* CONTAINER must be in 'builder' mode */
if|if
condition|(
name|container
operator|->
name|builder
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
comment|/* string table code makes its own prediction,    * noderevs should be< 16 bytes each,    * id parts< 4 bytes each,    * data representations< 40 bytes each,    * property representations< 30 bytes each,    * some static overhead should be assumed */
return|return
name|svn_fs_x__string_table_builder_estimate_size
argument_list|(
name|container
operator|->
name|builder
argument_list|)
operator|+
name|container
operator|->
name|noderevs
operator|->
name|nelts
operator|*
literal|16
operator|+
name|container
operator|->
name|ids
operator|->
name|nelts
operator|*
literal|4
operator|+
name|container
operator|->
name|reps
operator|->
name|nelts
operator|*
literal|40
operator|+
literal|100
return|;
block|}
end_function

begin_comment
comment|/* Set *ID to the ID part stored at index IDX in IDS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_id
parameter_list|(
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|ids
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
comment|/* handle NULL IDs  */
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
name|svn_fs_x__id_reset
argument_list|(
name|id
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* check for corrupted data */
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>
name|ids
operator|->
name|nelts
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONTAINER_INDEX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"ID part index %d exceeds container size %d"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|ids
operator|->
name|nelts
argument_list|)
return|;
comment|/* Return the requested ID. */
operator|*
name|id
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|ids
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|svn_fs_x__id_t
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create a svn_fs_x__representation_t in *REP, allocated in POOL based on the  * representation stored at index IDX in REPS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_representation
parameter_list|(
name|svn_fs_x__representation_t
modifier|*
modifier|*
name|rep
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|reps
parameter_list|,
name|int
name|idx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* handle NULL representations  */
if|if
condition|(
name|idx
operator|==
literal|0
condition|)
block|{
operator|*
name|rep
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* check for corrupted data */
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
name|idx
operator|>
name|reps
operator|->
name|nelts
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONTAINER_INDEX
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node revision ID index %d"
literal|" exceeds container size %d"
argument_list|)
argument_list|,
name|idx
argument_list|,
name|reps
operator|->
name|nelts
argument_list|)
return|;
comment|/* no translation required. Just duplicate the info */
operator|*
name|rep
operator|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|reps
argument_list|,
name|idx
operator|-
literal|1
argument_list|,
name|svn_fs_x__representation_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__noderevs_get
parameter_list|(
name|svn_fs_x__noderev_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
specifier|const
name|svn_fs_x__noderevs_t
modifier|*
name|container
parameter_list|,
name|apr_size_t
name|idx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|binary_noderev_t
modifier|*
name|binary_noderev
decl_stmt|;
comment|/* CONTAINER must be in 'finalized' mode */
name|SVN_ERR_ASSERT
argument_list|(
name|container
operator|->
name|builder
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|container
operator|->
name|paths
argument_list|)
expr_stmt|;
comment|/* validate index */
if|if
condition|(
name|idx
operator|>=
operator|(
name|apr_size_t
operator|)
name|container
operator|->
name|noderevs
operator|->
name|nelts
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONTAINER_INDEX
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Node revision index %%%s"
literal|" exceeds container size %%d"
argument_list|)
argument_list|,
name|APR_SIZE_T_FMT
argument_list|)
argument_list|,
name|idx
argument_list|,
name|container
operator|->
name|noderevs
operator|->
name|nelts
argument_list|)
return|;
comment|/* allocate result struct and fill it field by field */
name|noderev
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
argument_list|)
argument_list|)
expr_stmt|;
name|binary_noderev
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|container
operator|->
name|noderevs
argument_list|,
name|idx
argument_list|,
name|binary_noderev_t
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|kind
operator|=
call|(
name|svn_node_kind_t
call|)
argument_list|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_KIND_MASK
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|noderev_id
argument_list|,
name|container
operator|->
name|ids
argument_list|,
name|binary_noderev
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|node_id
argument_list|,
name|container
operator|->
name|ids
argument_list|,
name|binary_noderev
operator|->
name|node_id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|copy_id
argument_list|,
name|container
operator|->
name|ids
argument_list|,
name|binary_noderev
operator|->
name|copy_id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|container
operator|->
name|ids
argument_list|,
name|binary_noderev
operator|->
name|predecessor_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_COPYFROM
condition|)
block|{
name|noderev
operator|->
name|copyfrom_path
operator|=
name|svn_fs_x__string_table_get
argument_list|(
name|container
operator|->
name|paths
argument_list|,
name|binary_noderev
operator|->
name|copyfrom_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|binary_noderev
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
else|else
block|{
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
if|if
condition|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_COPYROOT
condition|)
block|{
name|noderev
operator|->
name|copyroot_path
operator|=
name|svn_fs_x__string_table_get
argument_list|(
name|container
operator|->
name|paths
argument_list|,
name|binary_noderev
operator|->
name|copyroot_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
name|binary_noderev
operator|->
name|copyroot_rev
expr_stmt|;
block|}
else|else
block|{
name|noderev
operator|->
name|copyroot_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
literal|0
expr_stmt|;
block|}
name|noderev
operator|->
name|predecessor_count
operator|=
name|binary_noderev
operator|->
name|predecessor_count
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_representation
argument_list|(
operator|&
name|noderev
operator|->
name|prop_rep
argument_list|,
name|container
operator|->
name|reps
argument_list|,
name|binary_noderev
operator|->
name|prop_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_representation
argument_list|(
operator|&
name|noderev
operator|->
name|data_rep
argument_list|,
name|container
operator|->
name|reps
argument_list|,
name|binary_noderev
operator|->
name|data_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_CPATH
condition|)
name|noderev
operator|->
name|created_path
operator|=
name|svn_fs_x__string_table_get
argument_list|(
name|container
operator|->
name|paths
argument_list|,
name|binary_noderev
operator|->
name|created_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|mergeinfo_count
operator|=
name|binary_noderev
operator|->
name|mergeinfo_count
expr_stmt|;
name|noderev
operator|->
name|has_mergeinfo
operator|=
operator|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_MINFO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|noderev_p
operator|=
name|noderev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create and return a stream for representations in PARENT.  * Initialize the sub-streams for all fields, except checksums.  */
end_comment

begin_function
specifier|static
name|svn_packed__int_stream_t
modifier|*
name|create_rep_stream
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|parent
parameter_list|)
block|{
name|svn_packed__int_stream_t
modifier|*
name|stream
init|=
name|svn_packed__create_int_substream
argument_list|(
name|parent
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* sub-streams for members - except for checksums */
comment|/* has_sha1 */
name|svn_packed__create_int_substream
argument_list|(
name|stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* rev, item_index, size, expanded_size */
name|svn_packed__create_int_substream
argument_list|(
name|stream
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Serialize all representations in REP.  Store checksums in DIGEST_STREAM,  * put all other fields into REP_STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|write_reps
parameter_list|(
name|svn_packed__int_stream_t
modifier|*
name|rep_stream
parameter_list|,
name|svn_packed__byte_stream_t
modifier|*
name|digest_stream
parameter_list|,
name|apr_array_header_t
modifier|*
name|reps
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__representation_t
modifier|*
name|rep
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|reps
argument_list|,
name|i
argument_list|,
name|svn_fs_x__representation_t
argument_list|)
decl_stmt|;
name|svn_packed__add_uint
argument_list|(
name|rep_stream
argument_list|,
name|rep
operator|->
name|has_sha1
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|rep_stream
argument_list|,
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|rep_stream
argument_list|,
name|rep
operator|->
name|id
operator|.
name|number
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|rep_stream
argument_list|,
name|rep
operator|->
name|size
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|rep_stream
argument_list|,
name|rep
operator|->
name|expanded_size
argument_list|)
expr_stmt|;
name|svn_packed__add_bytes
argument_list|(
name|digest_stream
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|rep
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|->
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|->
name|has_sha1
condition|)
name|svn_packed__add_bytes
argument_list|(
name|digest_stream
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|rep
operator|->
name|sha1_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|->
name|sha1_digest
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__write_noderevs_container
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|svn_fs_x__noderevs_t
modifier|*
name|container
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|string_table_t
modifier|*
name|paths
init|=
name|container
operator|->
name|paths
condition|?
name|container
operator|->
name|paths
else|:
name|svn_fs_x__string_table_create
argument_list|(
name|container
operator|->
name|builder
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_packed__data_root_t
modifier|*
name|root
init|=
name|svn_packed__data_create_root
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* one common top-level stream for all arrays. One sub-stream */
name|svn_packed__int_stream_t
modifier|*
name|structs_stream
init|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|ids_stream
init|=
name|svn_packed__create_int_substream
argument_list|(
name|structs_stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|reps_stream
init|=
name|create_rep_stream
argument_list|(
name|structs_stream
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|noderevs_stream
init|=
name|svn_packed__create_int_substream
argument_list|(
name|structs_stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|digests_stream
init|=
name|svn_packed__create_bytes_stream
argument_list|(
name|root
argument_list|)
decl_stmt|;
comment|/* structure the IDS_STREAM such we can extract much of the redundancy    * from the svn_fs_x__ip_part_t structs */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|2
condition|;
operator|++
name|i
control|)
name|svn_packed__create_int_substream
argument_list|(
name|ids_stream
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* Same storing binary_noderev_t in the NODEREVS_STREAM */
name|svn_packed__create_int_substream
argument_list|(
name|noderevs_stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|13
condition|;
operator|++
name|i
control|)
name|svn_packed__create_int_substream
argument_list|(
name|noderevs_stream
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* serialize ids array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|container
operator|->
name|ids
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__id_t
modifier|*
name|id
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|container
operator|->
name|ids
argument_list|,
name|i
argument_list|,
name|svn_fs_x__id_t
argument_list|)
decl_stmt|;
name|svn_packed__add_int
argument_list|(
name|ids_stream
argument_list|,
name|id
operator|->
name|change_set
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|ids_stream
argument_list|,
name|id
operator|->
name|number
argument_list|)
expr_stmt|;
block|}
comment|/* serialize rep arrays */
name|write_reps
argument_list|(
name|reps_stream
argument_list|,
name|digests_stream
argument_list|,
name|container
operator|->
name|reps
argument_list|)
expr_stmt|;
comment|/* serialize noderevs array */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|container
operator|->
name|noderevs
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|binary_noderev_t
modifier|*
name|noderev
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|container
operator|->
name|noderevs
argument_list|,
name|i
argument_list|,
name|binary_noderev_t
argument_list|)
decl_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|flags
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|id
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|node_id
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|copy_id
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|predecessor_id
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|predecessor_count
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|svn_packed__add_int
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|copyfrom_rev
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
name|svn_packed__add_int
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|copyroot_rev
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|prop_rep
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|noderevs_stream
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
expr_stmt|;
block|}
comment|/* write to disk */
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_string_table
argument_list|(
name|stream
argument_list|,
name|paths
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_packed__data_write
argument_list|(
name|stream
argument_list|,
name|root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate a svn_fs_x__representation_t array in POOL and return it in  * REPS_P.  Deserialize the data in REP_STREAM and DIGEST_STREAM and store  * the resulting representations into the *REPS_P.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_reps
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|reps_p
parameter_list|,
name|svn_packed__int_stream_t
modifier|*
name|rep_stream
parameter_list|,
name|svn_packed__byte_stream_t
modifier|*
name|digest_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|bytes
decl_stmt|;
name|apr_size_t
name|count
init|=
name|svn_packed__int_count
argument_list|(
name|svn_packed__first_int_substream
argument_list|(
name|rep_stream
argument_list|)
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|reps
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__representation_t
argument_list|)
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__representation_t
name|rep
decl_stmt|;
name|rep
operator|.
name|has_sha1
operator|=
operator|(
name|svn_boolean_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|rep_stream
argument_list|)
expr_stmt|;
name|rep
operator|.
name|id
operator|.
name|change_set
operator|=
operator|(
name|svn_revnum_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|rep_stream
argument_list|)
expr_stmt|;
name|rep
operator|.
name|id
operator|.
name|number
operator|=
name|svn_packed__get_uint
argument_list|(
name|rep_stream
argument_list|)
expr_stmt|;
name|rep
operator|.
name|size
operator|=
name|svn_packed__get_uint
argument_list|(
name|rep_stream
argument_list|)
expr_stmt|;
name|rep
operator|.
name|expanded_size
operator|=
name|svn_packed__get_uint
argument_list|(
name|rep_stream
argument_list|)
expr_stmt|;
comment|/* when extracting the checksums, beware of buffer under/overflows          caused by disk data corruption. */
name|bytes
operator|=
name|svn_packed__get_bytes
argument_list|(
name|digest_stream
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|rep
operator|.
name|md5_digest
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONTAINER_INDEX
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unexpected MD5"
literal|" digest size %%%s"
argument_list|)
argument_list|,
name|APR_SIZE_T_FMT
argument_list|)
argument_list|,
name|len
argument_list|)
return|;
name|memcpy
argument_list|(
name|rep
operator|.
name|md5_digest
argument_list|,
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|.
name|md5_digest
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep
operator|.
name|has_sha1
condition|)
block|{
name|bytes
operator|=
name|svn_packed__get_bytes
argument_list|(
name|digest_stream
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|!=
sizeof|sizeof
argument_list|(
name|rep
operator|.
name|sha1_digest
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONTAINER_INDEX
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unexpected SHA1"
literal|" digest size %%%s"
argument_list|)
argument_list|,
name|APR_SIZE_T_FMT
argument_list|)
argument_list|,
name|len
argument_list|)
return|;
name|memcpy
argument_list|(
name|rep
operator|.
name|sha1_digest
argument_list|,
name|bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|rep
operator|.
name|sha1_digest
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|reps
argument_list|,
name|svn_fs_x__representation_t
argument_list|)
operator|=
name|rep
expr_stmt|;
block|}
operator|*
name|reps_p
operator|=
name|reps
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__read_noderevs_container
parameter_list|(
name|svn_fs_x__noderevs_t
modifier|*
modifier|*
name|container
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|apr_size_t
name|count
decl_stmt|;
name|svn_fs_x__noderevs_t
modifier|*
name|noderevs
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderevs
argument_list|)
argument_list|)
decl_stmt|;
name|svn_packed__data_root_t
modifier|*
name|root
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|structs_stream
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|ids_stream
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|reps_stream
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|noderevs_stream
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|digests_stream
decl_stmt|;
comment|/* read everything from disk */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_string_table
argument_list|(
operator|&
name|noderevs
operator|->
name|paths
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_packed__data_read
argument_list|(
operator|&
name|root
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get streams */
name|structs_stream
operator|=
name|svn_packed__first_int_stream
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|ids_stream
operator|=
name|svn_packed__first_int_substream
argument_list|(
name|structs_stream
argument_list|)
expr_stmt|;
name|reps_stream
operator|=
name|svn_packed__next_int_stream
argument_list|(
name|ids_stream
argument_list|)
expr_stmt|;
name|noderevs_stream
operator|=
name|svn_packed__next_int_stream
argument_list|(
name|reps_stream
argument_list|)
expr_stmt|;
name|digests_stream
operator|=
name|svn_packed__first_byte_stream
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* read ids array */
name|count
operator|=
name|svn_packed__int_count
argument_list|(
name|svn_packed__first_int_substream
argument_list|(
name|ids_stream
argument_list|)
argument_list|)
expr_stmt|;
name|noderevs
operator|->
name|ids
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_fs_x__id_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|svn_fs_x__id_t
name|id
decl_stmt|;
name|id
operator|.
name|change_set
operator|=
operator|(
name|svn_revnum_t
operator|)
name|svn_packed__get_int
argument_list|(
name|ids_stream
argument_list|)
expr_stmt|;
name|id
operator|.
name|number
operator|=
name|svn_packed__get_uint
argument_list|(
name|ids_stream
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|noderevs
operator|->
name|ids
argument_list|,
name|svn_fs_x__id_t
argument_list|)
operator|=
name|id
expr_stmt|;
block|}
comment|/* read rep arrays */
name|SVN_ERR
argument_list|(
name|read_reps
argument_list|(
operator|&
name|noderevs
operator|->
name|reps
argument_list|,
name|reps_stream
argument_list|,
name|digests_stream
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read noderevs array */
name|count
operator|=
name|svn_packed__int_count
argument_list|(
name|svn_packed__first_int_substream
argument_list|(
name|noderevs_stream
argument_list|)
argument_list|)
expr_stmt|;
name|noderevs
operator|->
name|noderevs
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|binary_noderev_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|binary_noderev_t
name|noderev
decl_stmt|;
name|noderev
operator|.
name|flags
operator|=
operator|(
name|apr_uint32_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|id
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|node_id
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|copy_id
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|predecessor_id
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|predecessor_count
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|copyfrom_path
operator|=
operator|(
name|apr_size_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|copyfrom_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|svn_packed__get_int
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|copyroot_path
operator|=
operator|(
name|apr_size_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|copyroot_rev
operator|=
operator|(
name|svn_revnum_t
operator|)
name|svn_packed__get_int
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|prop_rep
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|data_rep
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|created_path
operator|=
operator|(
name|apr_size_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|noderev
operator|.
name|mergeinfo_count
operator|=
name|svn_packed__get_uint
argument_list|(
name|noderevs_stream
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|noderevs
operator|->
name|noderevs
argument_list|,
name|binary_noderev_t
argument_list|)
operator|=
name|noderev
expr_stmt|;
block|}
operator|*
name|container
operator|=
name|noderevs
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__serialize_noderevs_container
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__noderevs_t
modifier|*
name|noderevs
init|=
name|in
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_size_t
name|size
init|=
name|noderevs
operator|->
name|ids
operator|->
name|elt_size
operator|*
name|noderevs
operator|->
name|ids
operator|->
name|nelts
operator|+
name|noderevs
operator|->
name|reps
operator|->
name|elt_size
operator|*
name|noderevs
operator|->
name|reps
operator|->
name|nelts
operator|+
name|noderevs
operator|->
name|noderevs
operator|->
name|elt_size
operator|*
name|noderevs
operator|->
name|noderevs
operator|->
name|nelts
operator|+
literal|10
operator|*
name|noderevs
operator|->
name|noderevs
operator|->
name|elt_size
operator|+
literal|100
decl_stmt|;
comment|/* serialize array header and all its elements */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|svn_temp_serializer__init
argument_list|(
name|noderevs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderevs
argument_list|)
argument_list|,
name|size
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* serialize sub-structures */
name|svn_fs_x__serialize_string_table
argument_list|(
name|context
argument_list|,
operator|&
name|noderevs
operator|->
name|paths
argument_list|)
expr_stmt|;
name|svn_fs_x__serialize_apr_array
argument_list|(
name|context
argument_list|,
operator|&
name|noderevs
operator|->
name|ids
argument_list|)
expr_stmt|;
name|svn_fs_x__serialize_apr_array
argument_list|(
name|context
argument_list|,
operator|&
name|noderevs
operator|->
name|reps
argument_list|)
expr_stmt|;
name|svn_fs_x__serialize_apr_array
argument_list|(
name|context
argument_list|,
operator|&
name|noderevs
operator|->
name|noderevs
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__deserialize_noderevs_container
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__noderevs_t
modifier|*
name|noderevs
init|=
operator|(
name|svn_fs_x__noderevs_t
operator|*
operator|)
name|data
decl_stmt|;
comment|/* de-serialize sub-structures */
name|svn_fs_x__deserialize_string_table
argument_list|(
name|noderevs
argument_list|,
operator|&
name|noderevs
operator|->
name|paths
argument_list|)
expr_stmt|;
name|svn_fs_x__deserialize_apr_array
argument_list|(
name|noderevs
argument_list|,
operator|&
name|noderevs
operator|->
name|ids
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_fs_x__deserialize_apr_array
argument_list|(
name|noderevs
argument_list|,
operator|&
name|noderevs
operator|->
name|reps
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_fs_x__deserialize_apr_array
argument_list|(
name|noderevs
argument_list|,
operator|&
name|noderevs
operator|->
name|noderevs
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|out
operator|=
name|noderevs
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Deserialize the cache serialized APR struct at *IN in BUFFER and write  * the result to OUT.  Note that this will only resolve the pointers and  * not the array elements themselves. */
end_comment

begin_function
specifier|static
name|void
name|resolve_apr_array_header
parameter_list|(
name|apr_array_header_t
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|buffer
parameter_list|,
name|apr_array_header_t
modifier|*
specifier|const
modifier|*
name|in
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|array
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|buffer
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|in
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|elements
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|array
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|array
operator|->
name|elts
argument_list|)
decl_stmt|;
operator|*
name|out
operator|=
operator|*
name|array
expr_stmt|;
name|out
operator|->
name|elts
operator|=
operator|(
name|char
operator|*
operator|)
name|elements
expr_stmt|;
name|out
operator|->
name|pool
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__noderevs_get_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|binary_noderev_t
modifier|*
name|binary_noderev
decl_stmt|;
name|apr_array_header_t
name|ids
decl_stmt|;
name|apr_array_header_t
name|reps
decl_stmt|;
name|apr_array_header_t
name|noderevs
decl_stmt|;
name|apr_uint32_t
name|idx
init|=
operator|*
operator|(
name|apr_uint32_t
operator|*
operator|)
name|baton
decl_stmt|;
specifier|const
name|svn_fs_x__noderevs_t
modifier|*
name|container
init|=
name|data
decl_stmt|;
comment|/* Resolve all container pointers */
specifier|const
name|string_table_t
modifier|*
name|paths
init|=
name|svn_temp_deserializer__ptr
argument_list|(
name|container
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|container
operator|->
name|paths
argument_list|)
decl_stmt|;
name|resolve_apr_array_header
argument_list|(
operator|&
name|ids
argument_list|,
name|container
argument_list|,
operator|&
name|container
operator|->
name|ids
argument_list|)
expr_stmt|;
name|resolve_apr_array_header
argument_list|(
operator|&
name|reps
argument_list|,
name|container
argument_list|,
operator|&
name|container
operator|->
name|reps
argument_list|)
expr_stmt|;
name|resolve_apr_array_header
argument_list|(
operator|&
name|noderevs
argument_list|,
name|container
argument_list|,
operator|&
name|container
operator|->
name|noderevs
argument_list|)
expr_stmt|;
comment|/* allocate result struct and fill it field by field */
name|noderev
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
argument_list|)
argument_list|)
expr_stmt|;
name|binary_noderev
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
operator|&
name|noderevs
argument_list|,
name|idx
argument_list|,
name|binary_noderev_t
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|kind
operator|=
call|(
name|svn_node_kind_t
call|)
argument_list|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_KIND_MASK
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|noderev_id
argument_list|,
operator|&
name|ids
argument_list|,
name|binary_noderev
operator|->
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|node_id
argument_list|,
operator|&
name|ids
argument_list|,
name|binary_noderev
operator|->
name|node_id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|copy_id
argument_list|,
operator|&
name|ids
argument_list|,
name|binary_noderev
operator|->
name|copy_id
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_id
argument_list|(
operator|&
name|noderev
operator|->
name|predecessor_id
argument_list|,
operator|&
name|ids
argument_list|,
name|binary_noderev
operator|->
name|predecessor_id
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_COPYFROM
condition|)
block|{
name|noderev
operator|->
name|copyfrom_path
operator|=
name|svn_fs_x__string_table_get_func
argument_list|(
name|paths
argument_list|,
name|binary_noderev
operator|->
name|copyfrom_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|binary_noderev
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
else|else
block|{
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
if|if
condition|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_COPYROOT
condition|)
block|{
name|noderev
operator|->
name|copyroot_path
operator|=
name|svn_fs_x__string_table_get_func
argument_list|(
name|paths
argument_list|,
name|binary_noderev
operator|->
name|copyroot_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
name|binary_noderev
operator|->
name|copyroot_rev
expr_stmt|;
block|}
else|else
block|{
name|noderev
operator|->
name|copyroot_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
literal|0
expr_stmt|;
block|}
name|noderev
operator|->
name|predecessor_count
operator|=
name|binary_noderev
operator|->
name|predecessor_count
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_representation
argument_list|(
operator|&
name|noderev
operator|->
name|prop_rep
argument_list|,
operator|&
name|reps
argument_list|,
name|binary_noderev
operator|->
name|prop_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_representation
argument_list|(
operator|&
name|noderev
operator|->
name|data_rep
argument_list|,
operator|&
name|reps
argument_list|,
name|binary_noderev
operator|->
name|data_rep
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_CPATH
condition|)
name|noderev
operator|->
name|created_path
operator|=
name|svn_fs_x__string_table_get_func
argument_list|(
name|paths
argument_list|,
name|binary_noderev
operator|->
name|created_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|mergeinfo_count
operator|=
name|binary_noderev
operator|->
name|mergeinfo_count
expr_stmt|;
name|noderev
operator|->
name|has_mergeinfo
operator|=
operator|(
name|binary_noderev
operator|->
name|flags
operator|&
name|NODEREV_HAS_MINFO
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
operator|*
name|out
operator|=
name|noderev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__mergeinfo_count_get_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|binary_noderev_t
modifier|*
name|binary_noderev
decl_stmt|;
name|apr_array_header_t
name|noderevs
decl_stmt|;
name|apr_uint32_t
name|idx
init|=
operator|*
operator|(
name|apr_uint32_t
operator|*
operator|)
name|baton
decl_stmt|;
specifier|const
name|svn_fs_x__noderevs_t
modifier|*
name|container
init|=
name|data
decl_stmt|;
comment|/* Resolve all container pointers */
name|resolve_apr_array_header
argument_list|(
operator|&
name|noderevs
argument_list|,
name|container
argument_list|,
operator|&
name|container
operator|->
name|noderevs
argument_list|)
expr_stmt|;
name|binary_noderev
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
operator|&
name|noderevs
argument_list|,
name|idx
argument_list|,
name|binary_noderev_t
argument_list|)
expr_stmt|;
operator|*
operator|(
name|apr_int64_t
operator|*
operator|)
name|out
operator|=
name|binary_noderev
operator|->
name|mergeinfo_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

