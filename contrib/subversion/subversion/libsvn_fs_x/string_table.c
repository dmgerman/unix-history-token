begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* string_table.c : operations on string tables  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_packed_data.h"
end_include

begin_include
include|#
directive|include
file|"string_table.h"
end_include

begin_escape
end_escape

begin_define
define|#
directive|define
name|MAX_DATA_SIZE
value|0xffff
end_define

begin_define
define|#
directive|define
name|MAX_SHORT_STRING_LEN
value|(MAX_DATA_SIZE / 4)
end_define

begin_define
define|#
directive|define
name|TABLE_SHIFT
value|13
end_define

begin_define
define|#
directive|define
name|MAX_STRINGS_PER_TABLE
value|(1<< (TABLE_SHIFT - 1))
end_define

begin_define
define|#
directive|define
name|LONG_STRING_MASK
value|(1<< (TABLE_SHIFT - 1))
end_define

begin_define
define|#
directive|define
name|STRING_INDEX_MASK
value|((1<< (TABLE_SHIFT - 1)) - 1)
end_define

begin_define
define|#
directive|define
name|PADDING
value|(sizeof(apr_uint64_t))
end_define

begin_escape
end_escape

begin_typedef
typedef|typedef
struct|struct
name|builder_string_t
block|{
name|svn_string_t
name|string
decl_stmt|;
name|int
name|position
decl_stmt|;
name|apr_size_t
name|depth
decl_stmt|;
name|struct
name|builder_string_t
modifier|*
name|previous
decl_stmt|;
name|struct
name|builder_string_t
modifier|*
name|next
decl_stmt|;
name|apr_size_t
name|previous_match_len
decl_stmt|;
name|apr_size_t
name|next_match_len
decl_stmt|;
name|struct
name|builder_string_t
modifier|*
name|left
decl_stmt|;
name|struct
name|builder_string_t
modifier|*
name|right
decl_stmt|;
block|}
name|builder_string_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|builder_table_t
block|{
name|apr_size_t
name|max_data_size
decl_stmt|;
name|builder_string_t
modifier|*
name|top
decl_stmt|;
name|builder_string_t
modifier|*
name|first
decl_stmt|;
name|builder_string_t
modifier|*
name|last
decl_stmt|;
name|apr_array_header_t
modifier|*
name|short_strings
decl_stmt|;
name|apr_array_header_t
modifier|*
name|long_strings
decl_stmt|;
name|apr_hash_t
modifier|*
name|long_string_dict
decl_stmt|;
name|apr_size_t
name|long_string_size
decl_stmt|;
block|}
name|builder_table_t
typedef|;
end_typedef

begin_struct
struct|struct
name|string_table_builder_t
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_array_header_t
modifier|*
name|tables
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|string_header_t
block|{
name|apr_uint16_t
name|head_string
decl_stmt|;
name|apr_uint16_t
name|head_length
decl_stmt|;
name|apr_uint16_t
name|tail_start
decl_stmt|;
name|apr_uint16_t
name|tail_length
decl_stmt|;
block|}
name|string_header_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|string_sub_table_t
block|{
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
name|apr_size_t
name|data_size
decl_stmt|;
name|string_header_t
modifier|*
name|short_strings
decl_stmt|;
name|apr_size_t
name|short_string_count
decl_stmt|;
name|svn_string_t
modifier|*
name|long_strings
decl_stmt|;
name|apr_size_t
name|long_string_count
decl_stmt|;
block|}
name|string_sub_table_t
typedef|;
end_typedef

begin_struct
struct|struct
name|string_table_t
block|{
name|apr_size_t
name|size
decl_stmt|;
name|string_sub_table_t
modifier|*
name|sub_tables
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Accessing ID Pieces.  */
end_comment

begin_function
specifier|static
name|builder_table_t
modifier|*
name|add_table
parameter_list|(
name|string_table_builder_t
modifier|*
name|builder
parameter_list|)
block|{
name|builder_table_t
modifier|*
name|table
init|=
name|apr_pcalloc
argument_list|(
name|builder
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
decl_stmt|;
name|table
operator|->
name|max_data_size
operator|=
name|MAX_DATA_SIZE
operator|-
name|PADDING
expr_stmt|;
comment|/* ensure there remain a few                                                      unused bytes at the end */
name|table
operator|->
name|short_strings
operator|=
name|apr_array_make
argument_list|(
name|builder
operator|->
name|pool
argument_list|,
literal|64
argument_list|,
sizeof|sizeof
argument_list|(
name|builder_string_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|long_strings
operator|=
name|apr_array_make
argument_list|(
name|builder
operator|->
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_string_t
argument_list|)
argument_list|)
expr_stmt|;
name|table
operator|->
name|long_string_dict
operator|=
name|svn_hash__make
argument_list|(
name|builder
operator|->
name|pool
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|builder
operator|->
name|tables
argument_list|,
name|builder_table_t
operator|*
argument_list|)
operator|=
name|table
expr_stmt|;
return|return
name|table
return|;
block|}
end_function

begin_function
name|string_table_builder_t
modifier|*
name|svn_fs_x__string_table_builder_create
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|string_table_builder_t
modifier|*
name|result
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|result
operator|->
name|tables
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|builder_table_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|add_table
argument_list|(
name|result
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|balance
parameter_list|(
name|builder_table_t
modifier|*
name|table
parameter_list|,
name|builder_string_t
modifier|*
modifier|*
name|parent
parameter_list|,
name|builder_string_t
modifier|*
name|node
parameter_list|)
block|{
name|apr_size_t
name|left_height
init|=
name|node
operator|->
name|left
condition|?
name|node
operator|->
name|left
operator|->
name|depth
operator|+
literal|1
else|:
literal|0
decl_stmt|;
name|apr_size_t
name|right_height
init|=
name|node
operator|->
name|right
condition|?
name|node
operator|->
name|right
operator|->
name|depth
operator|+
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|left_height
operator|>
name|right_height
operator|+
literal|1
condition|)
block|{
name|builder_string_t
modifier|*
name|temp
init|=
name|node
operator|->
name|left
operator|->
name|right
decl_stmt|;
name|node
operator|->
name|left
operator|->
name|right
operator|=
name|node
expr_stmt|;
operator|*
name|parent
operator|=
name|node
operator|->
name|left
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|temp
expr_stmt|;
operator|--
name|left_height
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|left_height
operator|+
literal|1
operator|<
name|right_height
condition|)
block|{
name|builder_string_t
modifier|*
name|temp
init|=
name|node
operator|->
name|right
operator|->
name|left
decl_stmt|;
operator|*
name|parent
operator|=
name|node
operator|->
name|right
expr_stmt|;
name|node
operator|->
name|right
operator|->
name|left
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|temp
expr_stmt|;
operator|--
name|right_height
expr_stmt|;
block|}
name|node
operator|->
name|depth
operator|=
name|MAX
argument_list|(
name|left_height
argument_list|,
name|right_height
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_uint16_t
name|match_length
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|lhs
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|rhs
parameter_list|)
block|{
name|apr_size_t
name|len
init|=
name|MIN
argument_list|(
name|lhs
operator|->
name|len
argument_list|,
name|rhs
operator|->
name|len
argument_list|)
decl_stmt|;
return|return
operator|(
name|apr_uint16_t
operator|)
name|svn_cstring__match_length
argument_list|(
name|lhs
operator|->
name|data
argument_list|,
name|rhs
operator|->
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|apr_uint16_t
name|insert_string
parameter_list|(
name|builder_table_t
modifier|*
name|table
parameter_list|,
name|builder_string_t
modifier|*
modifier|*
name|parent
parameter_list|,
name|builder_string_t
modifier|*
name|to_insert
parameter_list|)
block|{
name|apr_uint16_t
name|result
decl_stmt|;
name|builder_string_t
modifier|*
name|current
init|=
operator|*
name|parent
decl_stmt|;
name|int
name|diff
init|=
name|strcmp
argument_list|(
name|current
operator|->
name|string
operator|.
name|data
argument_list|,
name|to_insert
operator|->
name|string
operator|.
name|data
argument_list|)
decl_stmt|;
if|if
condition|(
name|diff
operator|==
literal|0
condition|)
block|{
name|apr_array_pop
argument_list|(
name|table
operator|->
name|short_strings
argument_list|)
expr_stmt|;
return|return
name|current
operator|->
name|position
return|;
block|}
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|current
operator|->
name|left
operator|==
name|NULL
condition|)
block|{
name|current
operator|->
name|left
operator|=
name|to_insert
expr_stmt|;
name|to_insert
operator|->
name|previous
operator|=
name|current
operator|->
name|previous
expr_stmt|;
name|to_insert
operator|->
name|next
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|to_insert
operator|->
name|previous
operator|==
name|NULL
condition|)
block|{
name|table
operator|->
name|first
operator|=
name|to_insert
expr_stmt|;
block|}
else|else
block|{
name|builder_string_t
modifier|*
name|previous
init|=
name|to_insert
operator|->
name|previous
decl_stmt|;
name|to_insert
operator|->
name|previous_match_len
operator|=
name|match_length
argument_list|(
operator|&
name|previous
operator|->
name|string
argument_list|,
operator|&
name|to_insert
operator|->
name|string
argument_list|)
expr_stmt|;
name|previous
operator|->
name|next
operator|=
name|to_insert
expr_stmt|;
name|previous
operator|->
name|next_match_len
operator|=
name|to_insert
operator|->
name|previous_match_len
expr_stmt|;
block|}
name|current
operator|->
name|previous
operator|=
name|to_insert
expr_stmt|;
name|to_insert
operator|->
name|next_match_len
operator|=
name|match_length
argument_list|(
operator|&
name|current
operator|->
name|string
argument_list|,
operator|&
name|to_insert
operator|->
name|string
argument_list|)
expr_stmt|;
name|current
operator|->
name|previous_match_len
operator|=
name|to_insert
operator|->
name|next_match_len
expr_stmt|;
name|table
operator|->
name|max_data_size
operator|-=
name|to_insert
operator|->
name|string
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|to_insert
operator|->
name|previous
operator|==
name|NULL
condition|)
name|table
operator|->
name|max_data_size
operator|+=
name|to_insert
operator|->
name|next_match_len
expr_stmt|;
else|else
name|table
operator|->
name|max_data_size
operator|+=
name|MIN
argument_list|(
name|to_insert
operator|->
name|previous_match_len
argument_list|,
name|to_insert
operator|->
name|next_match_len
argument_list|)
expr_stmt|;
return|return
name|to_insert
operator|->
name|position
return|;
block|}
else|else
name|result
operator|=
name|insert_string
argument_list|(
name|table
argument_list|,
operator|&
name|current
operator|->
name|left
argument_list|,
name|to_insert
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|current
operator|->
name|right
operator|==
name|NULL
condition|)
block|{
name|current
operator|->
name|right
operator|=
name|to_insert
expr_stmt|;
name|to_insert
operator|->
name|next
operator|=
name|current
operator|->
name|next
expr_stmt|;
name|to_insert
operator|->
name|previous
operator|=
name|current
expr_stmt|;
if|if
condition|(
name|to_insert
operator|->
name|next
operator|==
name|NULL
condition|)
block|{
name|table
operator|->
name|last
operator|=
name|to_insert
expr_stmt|;
block|}
else|else
block|{
name|builder_string_t
modifier|*
name|next
init|=
name|to_insert
operator|->
name|next
decl_stmt|;
name|to_insert
operator|->
name|next_match_len
operator|=
name|match_length
argument_list|(
operator|&
name|next
operator|->
name|string
argument_list|,
operator|&
name|to_insert
operator|->
name|string
argument_list|)
expr_stmt|;
name|next
operator|->
name|previous
operator|=
name|to_insert
expr_stmt|;
name|next
operator|->
name|previous_match_len
operator|=
name|to_insert
operator|->
name|next_match_len
expr_stmt|;
block|}
name|current
operator|->
name|next
operator|=
name|current
operator|->
name|right
expr_stmt|;
name|to_insert
operator|->
name|previous_match_len
operator|=
name|match_length
argument_list|(
operator|&
name|current
operator|->
name|string
argument_list|,
operator|&
name|to_insert
operator|->
name|string
argument_list|)
expr_stmt|;
name|current
operator|->
name|next_match_len
operator|=
name|to_insert
operator|->
name|previous_match_len
expr_stmt|;
name|table
operator|->
name|max_data_size
operator|-=
name|to_insert
operator|->
name|string
operator|.
name|len
expr_stmt|;
if|if
condition|(
name|to_insert
operator|->
name|next
operator|==
name|NULL
condition|)
name|table
operator|->
name|max_data_size
operator|+=
name|to_insert
operator|->
name|previous_match_len
expr_stmt|;
else|else
name|table
operator|->
name|max_data_size
operator|+=
name|MIN
argument_list|(
name|to_insert
operator|->
name|previous_match_len
argument_list|,
name|to_insert
operator|->
name|next_match_len
argument_list|)
expr_stmt|;
return|return
name|to_insert
operator|->
name|position
return|;
block|}
else|else
name|result
operator|=
name|insert_string
argument_list|(
name|table
argument_list|,
operator|&
name|current
operator|->
name|right
argument_list|,
name|to_insert
argument_list|)
expr_stmt|;
block|}
name|balance
argument_list|(
name|table
argument_list|,
name|parent
argument_list|,
name|current
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_fs_x__string_table_builder_add
parameter_list|(
name|string_table_builder_t
modifier|*
name|builder
parameter_list|,
specifier|const
name|char
modifier|*
name|string
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|apr_size_t
name|result
decl_stmt|;
name|builder_table_t
modifier|*
name|table
init|=
name|APR_ARRAY_IDX
argument_list|(
name|builder
operator|->
name|tables
argument_list|,
name|builder
operator|->
name|tables
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|builder_table_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|len
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
name|string
operator|=
name|apr_pstrmemdup
argument_list|(
name|builder
operator|->
name|pool
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MAX_SHORT_STRING_LEN
condition|)
block|{
name|void
modifier|*
name|idx_void
decl_stmt|;
name|svn_string_t
name|item
decl_stmt|;
name|item
operator|.
name|data
operator|=
name|string
expr_stmt|;
name|item
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|idx_void
operator|=
name|apr_hash_get
argument_list|(
name|table
operator|->
name|long_string_dict
argument_list|,
name|string
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|result
operator|=
operator|(
name|apr_uintptr_t
operator|)
name|idx_void
expr_stmt|;
if|if
condition|(
name|result
condition|)
return|return
name|result
operator|-
literal|1
operator|+
name|LONG_STRING_MASK
operator|+
operator|(
operator|(
operator|(
name|apr_size_t
operator|)
name|builder
operator|->
name|tables
operator|->
name|nelts
operator|-
literal|1
operator|)
operator|<<
name|TABLE_SHIFT
operator|)
return|;
if|if
condition|(
name|table
operator|->
name|long_strings
operator|->
name|nelts
operator|==
name|MAX_STRINGS_PER_TABLE
condition|)
name|table
operator|=
name|add_table
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|result
operator|=
name|table
operator|->
name|long_strings
operator|->
name|nelts
operator|+
name|LONG_STRING_MASK
operator|+
operator|(
operator|(
operator|(
name|apr_size_t
operator|)
name|builder
operator|->
name|tables
operator|->
name|nelts
operator|-
literal|1
operator|)
operator|<<
name|TABLE_SHIFT
operator|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|table
operator|->
name|long_strings
argument_list|,
name|svn_string_t
argument_list|)
operator|=
name|item
expr_stmt|;
name|apr_hash_set
argument_list|(
name|table
operator|->
name|long_string_dict
argument_list|,
name|string
argument_list|,
name|len
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|apr_uintptr_t
operator|)
name|table
operator|->
name|long_strings
operator|->
name|nelts
argument_list|)
expr_stmt|;
name|table
operator|->
name|long_string_size
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
name|builder_string_t
modifier|*
name|item
init|=
name|apr_pcalloc
argument_list|(
name|builder
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
decl_stmt|;
name|item
operator|->
name|string
operator|.
name|data
operator|=
name|string
expr_stmt|;
name|item
operator|->
name|string
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|item
operator|->
name|previous_match_len
operator|=
literal|0
expr_stmt|;
name|item
operator|->
name|next_match_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|short_strings
operator|->
name|nelts
operator|==
name|MAX_STRINGS_PER_TABLE
operator|||
name|table
operator|->
name|max_data_size
operator|<
name|len
condition|)
name|table
operator|=
name|add_table
argument_list|(
name|builder
argument_list|)
expr_stmt|;
name|item
operator|->
name|position
operator|=
name|table
operator|->
name|short_strings
operator|->
name|nelts
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|table
operator|->
name|short_strings
argument_list|,
name|builder_string_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
if|if
condition|(
name|table
operator|->
name|top
operator|==
name|NULL
condition|)
block|{
name|table
operator|->
name|max_data_size
operator|-=
name|len
expr_stmt|;
name|table
operator|->
name|top
operator|=
name|item
expr_stmt|;
name|table
operator|->
name|first
operator|=
name|item
expr_stmt|;
name|table
operator|->
name|last
operator|=
name|item
expr_stmt|;
name|result
operator|=
operator|(
operator|(
name|apr_size_t
operator|)
name|builder
operator|->
name|tables
operator|->
name|nelts
operator|-
literal|1
operator|)
operator|<<
name|TABLE_SHIFT
expr_stmt|;
block|}
else|else
block|{
name|result
operator|=
name|insert_string
argument_list|(
name|table
argument_list|,
operator|&
name|table
operator|->
name|top
argument_list|,
name|item
argument_list|)
operator|+
operator|(
operator|(
operator|(
name|apr_size_t
operator|)
name|builder
operator|->
name|tables
operator|->
name|nelts
operator|-
literal|1
operator|)
operator|<<
name|TABLE_SHIFT
operator|)
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_fs_x__string_table_builder_estimate_size
parameter_list|(
name|string_table_builder_t
modifier|*
name|builder
parameter_list|)
block|{
name|apr_size_t
name|total
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|builder
operator|->
name|tables
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|builder_table_t
modifier|*
name|table
init|=
name|APR_ARRAY_IDX
argument_list|(
name|builder
operator|->
name|tables
argument_list|,
name|i
argument_list|,
name|builder_table_t
operator|*
argument_list|)
decl_stmt|;
comment|/* total number of chars to store,        * 8 bytes per short string table entry        * 4 bytes per long string table entry        * some static overhead */
name|apr_size_t
name|table_size
init|=
name|MAX_DATA_SIZE
operator|-
name|table
operator|->
name|max_data_size
operator|+
name|table
operator|->
name|long_string_size
operator|+
name|table
operator|->
name|short_strings
operator|->
name|nelts
operator|*
literal|8
operator|+
name|table
operator|->
name|long_strings
operator|->
name|nelts
operator|*
literal|4
operator|+
literal|10
decl_stmt|;
name|total
operator|+=
name|table_size
expr_stmt|;
block|}
comment|/* ZIP compression should give us a 50% reduction.    * add some static overhead */
return|return
literal|200
operator|+
name|total
operator|/
literal|2
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|create_table
parameter_list|(
name|string_sub_table_t
modifier|*
name|target
parameter_list|,
name|builder_table_t
modifier|*
name|source
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
init|=
literal|0
decl_stmt|;
name|apr_hash_t
modifier|*
name|tails
init|=
name|svn_hash__make
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|data
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|MAX_DATA_SIZE
operator|-
name|source
operator|->
name|max_data_size
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* pack sub-strings */
name|target
operator|->
name|short_string_count
operator|=
operator|(
name|apr_size_t
operator|)
name|source
operator|->
name|short_strings
operator|->
name|nelts
expr_stmt|;
name|target
operator|->
name|short_strings
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target
operator|->
name|short_strings
argument_list|)
operator|*
name|target
operator|->
name|short_string_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|source
operator|->
name|short_strings
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|builder_string_t
modifier|*
name|string
init|=
name|APR_ARRAY_IDX
argument_list|(
name|source
operator|->
name|short_strings
argument_list|,
name|i
argument_list|,
specifier|const
name|builder_string_t
operator|*
argument_list|)
decl_stmt|;
name|string_header_t
modifier|*
name|entry
init|=
operator|&
name|target
operator|->
name|short_strings
index|[
name|i
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
init|=
name|string
operator|->
name|string
operator|.
name|data
operator|+
name|string
operator|->
name|previous_match_len
decl_stmt|;
name|string_header_t
modifier|*
name|tail_match
decl_stmt|;
name|apr_size_t
name|head_length
init|=
name|string
operator|->
name|previous_match_len
decl_stmt|;
comment|/* Minimize the number of strings to visit when reconstructing the          string head.  So, skip all predecessors that don't contribute to          first HEAD_LENGTH chars of our string. */
if|if
condition|(
name|head_length
condition|)
block|{
specifier|const
name|builder_string_t
modifier|*
name|furthest_prev
init|=
name|string
operator|->
name|previous
decl_stmt|;
while|while
condition|(
name|furthest_prev
operator|->
name|previous_match_len
operator|>=
name|head_length
condition|)
name|furthest_prev
operator|=
name|furthest_prev
operator|->
name|previous
expr_stmt|;
name|entry
operator|->
name|head_string
operator|=
name|furthest_prev
operator|->
name|position
expr_stmt|;
block|}
else|else
name|entry
operator|->
name|head_string
operator|=
literal|0
expr_stmt|;
comment|/* head& tail length are known */
name|entry
operator|->
name|head_length
operator|=
operator|(
name|apr_uint16_t
operator|)
name|head_length
expr_stmt|;
name|entry
operator|->
name|tail_length
operator|=
call|(
name|apr_uint16_t
call|)
argument_list|(
name|string
operator|->
name|string
operator|.
name|len
operator|-
name|entry
operator|->
name|head_length
argument_list|)
expr_stmt|;
comment|/* try to reuse an existing tail segment */
name|tail_match
operator|=
name|apr_hash_get
argument_list|(
name|tails
argument_list|,
name|tail
argument_list|,
name|entry
operator|->
name|tail_length
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail_match
condition|)
block|{
name|entry
operator|->
name|tail_start
operator|=
name|tail_match
operator|->
name|tail_start
expr_stmt|;
block|}
else|else
block|{
name|entry
operator|->
name|tail_start
operator|=
operator|(
name|apr_uint16_t
operator|)
name|data
operator|->
name|len
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|data
argument_list|,
name|tail
argument_list|,
name|entry
operator|->
name|tail_length
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
name|tails
argument_list|,
name|tail
argument_list|,
name|entry
operator|->
name|tail_length
argument_list|,
name|entry
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* pack long strings */
name|target
operator|->
name|long_string_count
operator|=
operator|(
name|apr_size_t
operator|)
name|source
operator|->
name|long_strings
operator|->
name|nelts
expr_stmt|;
name|target
operator|->
name|long_strings
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|target
operator|->
name|long_strings
argument_list|)
operator|*
name|target
operator|->
name|long_string_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|source
operator|->
name|long_strings
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_string_t
modifier|*
name|string
init|=
operator|&
name|target
operator|->
name|long_strings
index|[
name|i
index|]
decl_stmt|;
operator|*
name|string
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|source
operator|->
name|long_strings
argument_list|,
name|i
argument_list|,
name|svn_string_t
argument_list|)
expr_stmt|;
name|string
operator|->
name|data
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|string
operator|->
name|data
argument_list|,
name|string
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
name|data
operator|->
name|len
operator|+=
name|PADDING
expr_stmt|;
comment|/* add a few extra bytes at the end of the buffer                            that we want to keep valid for chunky access */
name|assert
argument_list|(
name|data
operator|->
name|len
operator|<
name|data
operator|->
name|blocksize
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
operator|->
name|data
operator|+
name|data
operator|->
name|len
operator|-
name|PADDING
argument_list|,
literal|0
argument_list|,
name|PADDING
argument_list|)
expr_stmt|;
name|target
operator|->
name|data
operator|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|data
operator|->
name|data
argument_list|,
name|data
operator|->
name|len
argument_list|)
expr_stmt|;
name|target
operator|->
name|data_size
operator|=
name|data
operator|->
name|len
expr_stmt|;
block|}
end_function

begin_function
name|string_table_t
modifier|*
name|svn_fs_x__string_table_create
parameter_list|(
specifier|const
name|string_table_builder_t
modifier|*
name|builder
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|string_table_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|size
operator|=
operator|(
name|apr_size_t
operator|)
name|builder
operator|->
name|tables
operator|->
name|nelts
expr_stmt|;
name|result
operator|->
name|sub_tables
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
name|result
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|result
operator|->
name|sub_tables
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|result
operator|->
name|size
condition|;
operator|++
name|i
control|)
name|create_table
argument_list|(
operator|&
name|result
operator|->
name|sub_tables
index|[
name|i
index|]
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|builder
operator|->
name|tables
argument_list|,
name|i
argument_list|,
name|builder_table_t
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|,
name|builder
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Masks used by table_copy_string.  copy_mask[I] is used if the target    content to be preserved starts at byte I within the current chunk.    This is used to work around alignment issues.  */
end_comment

begin_if
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|copy_masks
index|[
literal|8
index|]
init|=
block|{
literal|"\xff\xff\xff\xff\xff\xff\xff\xff"
block|,
literal|"\x00\xff\xff\xff\xff\xff\xff\xff"
block|,
literal|"\x00\x00\xff\xff\xff\xff\xff\xff"
block|,
literal|"\x00\x00\x00\xff\xff\xff\xff\xff"
block|,
literal|"\x00\x00\x00\x00\xff\xff\xff\xff"
block|,
literal|"\x00\x00\x00\x00\x00\xff\xff\xff"
block|,
literal|"\x00\x00\x00\x00\x00\x00\xff\xff"
block|,
literal|"\x00\x00\x00\x00\x00\x00\x00\xff"
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|table_copy_string
parameter_list|(
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
specifier|const
name|string_sub_table_t
modifier|*
name|table
parameter_list|,
name|string_header_t
modifier|*
name|header
parameter_list|)
block|{
name|buffer
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
name|assert
argument_list|(
name|header
operator|->
name|head_length
operator|<=
name|len
argument_list|)
expr_stmt|;
block|{
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* the sections that we copy tend to be short but we can copy              *all* of it chunky because we made sure that source and target              buffer have some extra padding to prevent segfaults. */
name|apr_uint64_t
name|mask
decl_stmt|;
name|apr_size_t
name|to_copy
init|=
name|len
operator|-
name|header
operator|->
name|head_length
decl_stmt|;
name|apr_size_t
name|copied
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|source
init|=
name|table
operator|->
name|data
operator|+
name|header
operator|->
name|tail_start
decl_stmt|;
name|char
modifier|*
name|target
init|=
name|buffer
operator|+
name|header
operator|->
name|head_length
decl_stmt|;
name|len
operator|=
name|header
operator|->
name|head_length
expr_stmt|;
comment|/* copy whole chunks */
while|while
condition|(
name|to_copy
operator|>=
name|copied
operator|+
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
condition|)
block|{
operator|*
operator|(
name|apr_uint64_t
operator|*
operator|)
operator|(
name|target
operator|+
name|copied
operator|)
operator|=
operator|*
operator|(
specifier|const
name|apr_uint64_t
operator|*
operator|)
operator|(
name|source
operator|+
name|copied
operator|)
expr_stmt|;
name|copied
operator|+=
sizeof|sizeof
argument_list|(
name|apr_uint64_t
argument_list|)
expr_stmt|;
block|}
comment|/* copy the remainder assuming that we have up to 8 extra bytes              of addressable buffer on the source and target sides.              Now, we simply copy 8 bytes and use a mask to filter& merge              old with new data. */
name|mask
operator|=
operator|*
operator|(
specifier|const
name|apr_uint64_t
operator|*
operator|)
name|copy_masks
index|[
name|to_copy
operator|-
name|copied
index|]
expr_stmt|;
operator|*
operator|(
name|apr_uint64_t
operator|*
operator|)
operator|(
name|target
operator|+
name|copied
operator|)
operator|=
operator|(
operator|*
operator|(
name|apr_uint64_t
operator|*
operator|)
operator|(
name|target
operator|+
name|copied
operator|)
operator|&
name|mask
operator|)
operator||
operator|(
operator|*
operator|(
specifier|const
name|apr_uint64_t
operator|*
operator|)
operator|(
name|source
operator|+
name|copied
operator|)
operator|&
operator|~
name|mask
operator|)
expr_stmt|;
else|#
directive|else
name|memcpy
argument_list|(
name|buffer
operator|+
name|header
operator|->
name|head_length
argument_list|,
name|table
operator|->
name|data
operator|+
name|header
operator|->
name|tail_start
argument_list|,
name|len
operator|-
name|header
operator|->
name|head_length
argument_list|)
expr_stmt|;
name|len
operator|=
name|header
operator|->
name|head_length
expr_stmt|;
endif|#
directive|endif
block|}
name|header
operator|=
operator|&
name|table
operator|->
name|short_strings
index|[
name|header
operator|->
name|head_string
index|]
expr_stmt|;
block|}
do|while
condition|(
name|len
condition|)
do|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_x__string_table_get
parameter_list|(
specifier|const
name|string_table_t
modifier|*
name|table
parameter_list|,
name|apr_size_t
name|idx
parameter_list|,
name|apr_size_t
modifier|*
name|length
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|table_number
init|=
name|idx
operator|>>
name|TABLE_SHIFT
decl_stmt|;
name|apr_size_t
name|sub_index
init|=
name|idx
operator|&
name|STRING_INDEX_MASK
decl_stmt|;
if|if
condition|(
name|table_number
operator|<
name|table
operator|->
name|size
condition|)
block|{
name|string_sub_table_t
modifier|*
name|sub_table
init|=
operator|&
name|table
operator|->
name|sub_tables
index|[
name|table_number
index|]
decl_stmt|;
if|if
condition|(
name|idx
operator|&
name|LONG_STRING_MASK
condition|)
block|{
if|if
condition|(
name|sub_index
operator|<
name|sub_table
operator|->
name|long_string_count
condition|)
block|{
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|sub_table
operator|->
name|long_strings
index|[
name|sub_index
index|]
operator|.
name|len
expr_stmt|;
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|sub_table
operator|->
name|long_strings
index|[
name|sub_index
index|]
operator|.
name|data
argument_list|,
name|sub_table
operator|->
name|long_strings
index|[
name|sub_index
index|]
operator|.
name|len
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sub_index
operator|<
name|sub_table
operator|->
name|short_string_count
condition|)
block|{
name|string_header_t
modifier|*
name|header
init|=
name|sub_table
operator|->
name|short_strings
operator|+
name|sub_index
decl_stmt|;
name|apr_size_t
name|len
init|=
name|header
operator|->
name|head_length
operator|+
name|header
operator|->
name|tail_length
decl_stmt|;
name|char
modifier|*
name|result
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|len
operator|+
name|PADDING
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|len
expr_stmt|;
name|table_copy_string
argument_list|(
name|result
argument_list|,
name|len
argument_list|,
name|sub_table
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__write_string_table
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|string_table_t
modifier|*
name|table
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|k
decl_stmt|;
name|svn_packed__data_root_t
modifier|*
name|root
init|=
name|svn_packed__data_create_root
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|table_sizes
init|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|small_strings_headers
init|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|large_strings
init|=
name|svn_packed__create_bytes_stream
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|small_strings_data
init|=
name|svn_packed__create_bytes_stream
argument_list|(
name|root
argument_list|)
decl_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|small_strings_headers
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|small_strings_headers
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|small_strings_headers
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|small_strings_headers
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* number of sub-tables */
name|svn_packed__add_uint
argument_list|(
name|table_sizes
argument_list|,
name|table
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* all short-string char data sizes */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
operator|++
name|i
control|)
name|svn_packed__add_uint
argument_list|(
name|table_sizes
argument_list|,
name|table
operator|->
name|sub_tables
index|[
name|i
index|]
operator|.
name|short_string_count
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
operator|++
name|i
control|)
name|svn_packed__add_uint
argument_list|(
name|table_sizes
argument_list|,
name|table
operator|->
name|sub_tables
index|[
name|i
index|]
operator|.
name|long_string_count
argument_list|)
expr_stmt|;
comment|/* all strings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|string_sub_table_t
modifier|*
name|sub_table
init|=
operator|&
name|table
operator|->
name|sub_tables
index|[
name|i
index|]
decl_stmt|;
name|svn_packed__add_bytes
argument_list|(
name|small_strings_data
argument_list|,
name|sub_table
operator|->
name|data
argument_list|,
name|sub_table
operator|->
name|data_size
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|sub_table
operator|->
name|short_string_count
condition|;
operator|++
name|k
control|)
block|{
name|string_header_t
modifier|*
name|string
init|=
operator|&
name|sub_table
operator|->
name|short_strings
index|[
name|k
index|]
decl_stmt|;
name|svn_packed__add_uint
argument_list|(
name|small_strings_headers
argument_list|,
name|string
operator|->
name|head_string
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|small_strings_headers
argument_list|,
name|string
operator|->
name|head_length
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|small_strings_headers
argument_list|,
name|string
operator|->
name|tail_start
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|small_strings_headers
argument_list|,
name|string
operator|->
name|tail_length
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|sub_table
operator|->
name|long_string_count
condition|;
operator|++
name|k
control|)
name|svn_packed__add_bytes
argument_list|(
name|large_strings
argument_list|,
name|sub_table
operator|->
name|long_strings
index|[
name|k
index|]
operator|.
name|data
argument_list|,
name|sub_table
operator|->
name|long_strings
index|[
name|k
index|]
operator|.
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* write to target stream */
name|SVN_ERR
argument_list|(
name|svn_packed__data_write
argument_list|(
name|stream
argument_list|,
name|root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__read_string_table
parameter_list|(
name|string_table_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|k
decl_stmt|;
name|string_table_t
modifier|*
name|table
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|table
argument_list|)
argument_list|)
decl_stmt|;
name|svn_packed__data_root_t
modifier|*
name|root
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|table_sizes
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|large_strings
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|small_strings_data
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|headers
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_packed__data_read
argument_list|(
operator|&
name|root
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|table_sizes
operator|=
name|svn_packed__first_int_stream
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|headers
operator|=
name|svn_packed__next_int_stream
argument_list|(
name|table_sizes
argument_list|)
expr_stmt|;
name|large_strings
operator|=
name|svn_packed__first_byte_stream
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|small_strings_data
operator|=
name|svn_packed__next_byte_stream
argument_list|(
name|large_strings
argument_list|)
expr_stmt|;
comment|/* create sub-tables */
name|table
operator|->
name|size
operator|=
operator|(
name|apr_size_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|table_sizes
argument_list|)
expr_stmt|;
name|table
operator|->
name|sub_tables
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
name|table
operator|->
name|size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|table
operator|->
name|sub_tables
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read short strings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|string_sub_table_t
modifier|*
name|sub_table
init|=
operator|&
name|table
operator|->
name|sub_tables
index|[
name|i
index|]
decl_stmt|;
name|sub_table
operator|->
name|short_string_count
operator|=
operator|(
name|apr_size_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|table_sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_table
operator|->
name|short_string_count
condition|)
block|{
name|sub_table
operator|->
name|short_strings
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
name|sub_table
operator|->
name|short_string_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sub_table
operator|->
name|short_strings
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read short string headers */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|sub_table
operator|->
name|short_string_count
condition|;
operator|++
name|k
control|)
block|{
name|string_header_t
modifier|*
name|string
init|=
operator|&
name|sub_table
operator|->
name|short_strings
index|[
name|k
index|]
decl_stmt|;
name|string
operator|->
name|head_string
operator|=
operator|(
name|apr_uint16_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|string
operator|->
name|head_length
operator|=
operator|(
name|apr_uint16_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|string
operator|->
name|tail_start
operator|=
operator|(
name|apr_uint16_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|headers
argument_list|)
expr_stmt|;
name|string
operator|->
name|tail_length
operator|=
operator|(
name|apr_uint16_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|headers
argument_list|)
expr_stmt|;
block|}
block|}
name|sub_table
operator|->
name|data
operator|=
name|svn_packed__get_bytes
argument_list|(
name|small_strings_data
argument_list|,
operator|&
name|sub_table
operator|->
name|data_size
argument_list|)
expr_stmt|;
block|}
comment|/* read long strings */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|table
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
comment|/* initialize long string table */
name|string_sub_table_t
modifier|*
name|sub_table
init|=
operator|&
name|table
operator|->
name|sub_tables
index|[
name|i
index|]
decl_stmt|;
name|sub_table
operator|->
name|long_string_count
operator|=
name|svn_packed__get_uint
argument_list|(
name|table_sizes
argument_list|)
expr_stmt|;
if|if
condition|(
name|sub_table
operator|->
name|long_string_count
condition|)
block|{
name|sub_table
operator|->
name|long_strings
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
name|sub_table
operator|->
name|long_string_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sub_table
operator|->
name|long_strings
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read long strings */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|sub_table
operator|->
name|long_string_count
condition|;
operator|++
name|k
control|)
block|{
name|svn_string_t
modifier|*
name|string
init|=
operator|&
name|sub_table
operator|->
name|long_strings
index|[
name|k
index|]
decl_stmt|;
name|string
operator|->
name|data
operator|=
name|svn_packed__get_bytes
argument_list|(
name|large_strings
argument_list|,
operator|&
name|string
operator|->
name|len
argument_list|)
expr_stmt|;
name|string
operator|->
name|len
operator|--
expr_stmt|;
block|}
block|}
block|}
comment|/* done */
operator|*
name|table_p
operator|=
name|table
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_fs_x__serialize_string_table
parameter_list|(
name|svn_temp_serializer__context_t
modifier|*
name|context
parameter_list|,
name|string_table_t
modifier|*
modifier|*
name|st
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|k
decl_stmt|;
name|string_table_t
modifier|*
name|string_table
init|=
operator|*
name|st
decl_stmt|;
if|if
condition|(
name|string_table
operator|==
name|NULL
condition|)
return|return;
comment|/* string table struct */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
name|st
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|string_table
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sub-table array (all structs in a single memory block) */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|string_table
operator|->
name|sub_tables
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|string_table
operator|->
name|sub_tables
argument_list|)
operator|*
name|string_table
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* sub-elements of all sub-tables */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|string_table
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|string_sub_table_t
modifier|*
name|sub_table
init|=
operator|&
name|string_table
operator|->
name|sub_tables
index|[
name|i
index|]
decl_stmt|;
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|data
argument_list|,
name|sub_table
operator|->
name|data_size
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|short_strings
argument_list|,
name|sub_table
operator|->
name|short_string_count
operator|*
sizeof|sizeof
argument_list|(
name|string_header_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* all "long string" instances form a single memory block */
name|svn_temp_serializer__push
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|long_strings
argument_list|,
name|sub_table
operator|->
name|long_string_count
operator|*
sizeof|sizeof
argument_list|(
name|svn_string_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize actual long string contents */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|sub_table
operator|->
name|long_string_count
condition|;
operator|++
name|k
control|)
block|{
name|svn_string_t
modifier|*
name|string
init|=
operator|&
name|sub_table
operator|->
name|long_strings
index|[
name|k
index|]
decl_stmt|;
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|string
operator|->
name|data
argument_list|,
name|string
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
comment|/* back to the caller's nesting level */
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
name|svn_temp_serializer__pop
argument_list|(
name|context
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_fs_x__deserialize_string_table
parameter_list|(
name|void
modifier|*
name|buffer
parameter_list|,
name|string_table_t
modifier|*
modifier|*
name|table
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|,
name|k
decl_stmt|;
name|string_sub_table_t
modifier|*
name|sub_tables
decl_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|buffer
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
name|table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|table
operator|==
name|NULL
condition|)
return|return;
name|svn_temp_deserializer__resolve
argument_list|(
operator|*
name|table
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|table
operator|)
operator|->
name|sub_tables
argument_list|)
expr_stmt|;
name|sub_tables
operator|=
operator|(
operator|*
name|table
operator|)
operator|->
name|sub_tables
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
operator|*
name|table
operator|)
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|string_sub_table_t
modifier|*
name|sub_table
init|=
name|sub_tables
operator|+
name|i
decl_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|sub_tables
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|data
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|sub_tables
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|short_strings
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|sub_tables
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|long_strings
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
name|sub_table
operator|->
name|long_string_count
condition|;
operator|++
name|k
control|)
name|svn_temp_deserializer__resolve
argument_list|(
name|sub_table
operator|->
name|long_strings
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|long_strings
index|[
name|k
index|]
operator|.
name|data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_x__string_table_get_func
parameter_list|(
specifier|const
name|string_table_t
modifier|*
name|table
parameter_list|,
name|apr_size_t
name|idx
parameter_list|,
name|apr_size_t
modifier|*
name|length
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|table_number
init|=
name|idx
operator|>>
name|TABLE_SHIFT
decl_stmt|;
name|apr_size_t
name|sub_index
init|=
name|idx
operator|&
name|STRING_INDEX_MASK
decl_stmt|;
if|if
condition|(
name|table_number
operator|<
name|table
operator|->
name|size
condition|)
block|{
comment|/* resolve TABLE->SUB_TABLES pointer and select sub-table */
name|string_sub_table_t
modifier|*
name|sub_tables
init|=
operator|(
name|string_sub_table_t
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
name|table
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|table
operator|->
name|sub_tables
argument_list|)
decl_stmt|;
name|string_sub_table_t
modifier|*
name|sub_table
init|=
name|sub_tables
operator|+
name|table_number
decl_stmt|;
comment|/* pick the right kind of string */
if|if
condition|(
name|idx
operator|&
name|LONG_STRING_MASK
condition|)
block|{
if|if
condition|(
name|sub_index
operator|<
name|sub_table
operator|->
name|long_string_count
condition|)
block|{
comment|/* resolve SUB_TABLE->LONG_STRINGS, select the string we want                  and resolve the pointer to its char data */
name|svn_string_t
modifier|*
name|long_strings
init|=
operator|(
name|svn_string_t
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
name|sub_table
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|long_strings
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_data
init|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
name|long_strings
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|long_strings
index|[
name|sub_index
index|]
operator|.
name|data
argument_list|)
decl_stmt|;
comment|/* return a copy of the char data */
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|long_strings
index|[
name|sub_index
index|]
operator|.
name|len
expr_stmt|;
return|return
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|str_data
argument_list|,
name|long_strings
index|[
name|sub_index
index|]
operator|.
name|len
argument_list|)
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|sub_index
operator|<
name|sub_table
operator|->
name|short_string_count
condition|)
block|{
name|string_header_t
modifier|*
name|header
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|char
modifier|*
name|result
decl_stmt|;
comment|/* construct a copy of our sub-table struct with SHORT_STRINGS                  and DATA pointers resolved.  Leave all other pointers as                  they are.  This allows us to use the same code for string                  reconstruction here as in the non-serialized case. */
name|string_sub_table_t
name|table_copy
init|=
operator|*
name|sub_table
decl_stmt|;
name|table_copy
operator|.
name|data
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
name|sub_tables
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|data
argument_list|)
expr_stmt|;
name|table_copy
operator|.
name|short_strings
operator|=
operator|(
name|string_header_t
operator|*
operator|)
name|svn_temp_deserializer__ptr
argument_list|(
name|sub_tables
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|sub_table
operator|->
name|short_strings
argument_list|)
expr_stmt|;
comment|/* reconstruct the char data and return it */
name|header
operator|=
name|table_copy
operator|.
name|short_strings
operator|+
name|sub_index
expr_stmt|;
name|len
operator|=
name|header
operator|->
name|head_length
operator|+
name|header
operator|->
name|tail_length
expr_stmt|;
name|result
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|len
operator|+
name|PADDING
argument_list|)
expr_stmt|;
if|if
condition|(
name|length
condition|)
operator|*
name|length
operator|=
name|len
expr_stmt|;
name|table_copy_string
argument_list|(
name|result
argument_list|,
name|len
argument_list|,
operator|&
name|table_copy
argument_list|,
name|header
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
block|}
block|}
return|return
literal|""
return|;
block|}
end_function

end_unit

