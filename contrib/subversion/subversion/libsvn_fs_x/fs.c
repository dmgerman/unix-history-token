begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs.c --- creating, opening and closing filesystems  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_thread_mutex.h>
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"fs_x.h"
end_include

begin_include
include|#
directive|include
file|"pack.h"
end_include

begin_include
include|#
directive|include
file|"recovery.h"
end_include

begin_include
include|#
directive|include
file|"hotcopy.h"
end_include

begin_include
include|#
directive|include
file|"verify.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_comment
comment|/* A prefix for the pool userdata variables used to hold    per-filesystem shared data.  See fs_serialized_init. */
end_comment

begin_define
define|#
directive|define
name|SVN_FSX_SHARED_USERDATA_PREFIX
value|"svn-fsx-shared-"
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize the part of FS that requires global serialization across all    instances.  The caller is responsible of ensuring that serialization.    Use COMMON_POOL for process-wide and SCRATCH_POOL for temporary    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_serialized_init
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_fs_x__shared_data_t
modifier|*
name|ffsd
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
comment|/* Note that we are allocating a small amount of long-lived data for      each separate repository opened during the lifetime of the      svn_fs_initialize pool.  It's unlikely that anyone will notice      the modest expenditure; the alternative is to allocate each structure      in a subpool, add a reference-count, and add a serialized destructor      to the FS vtable.  That's more machinery than it's worth.       Picking an appropriate key for the shared data is tricky, because,      unfortunately, a filesystem UUID is not really unique.  It is implicitly      shared between hotcopied (1), dump / loaded (2) or naively copied (3)      filesystems.  We tackle this problem by using a combination of the UUID      and an instance ID as the key.  This allows us to avoid key clashing      in (1) and (2).       Speaking of (3), there is not so much we can do about it, except maybe      provide a convenient way of fixing things.  Naively copied filesystems      have identical filesystem UUIDs *and* instance IDs.  With the key being      a combination of these two, clashes can be fixed by changing either of      them (or both), e.g. with svn_fs_set_uuid(). */
name|SVN_ERR_ASSERT
argument_list|(
name|fs
operator|->
name|uuid
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ffd
operator|->
name|instance_id
argument_list|)
expr_stmt|;
name|key
operator|=
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
name|SVN_FSX_SHARED_USERDATA_PREFIX
argument_list|,
name|fs
operator|->
name|uuid
argument_list|,
literal|":"
argument_list|,
name|ffd
operator|->
name|instance_id
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_pool_userdata_get
argument_list|(
operator|&
name|val
argument_list|,
name|key
argument_list|,
name|common_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't fetch FSX shared data"
argument_list|)
argument_list|)
return|;
name|ffsd
operator|=
name|val
expr_stmt|;
if|if
condition|(
operator|!
name|ffsd
condition|)
block|{
name|ffsd
operator|=
name|apr_pcalloc
argument_list|(
name|common_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffsd
argument_list|)
argument_list|)
expr_stmt|;
name|ffsd
operator|->
name|common_pool
operator|=
name|common_pool
expr_stmt|;
comment|/* POSIX fcntl locks are per-process, so we need a mutex for          intra-process synchronization when grabbing the repository write          lock. */
name|SVN_ERR
argument_list|(
name|svn_mutex__init
argument_list|(
operator|&
name|ffsd
operator|->
name|fs_write_lock
argument_list|,
name|SVN_FS_X__USE_LOCK_MUTEX
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... the pack lock ... */
name|SVN_ERR
argument_list|(
name|svn_mutex__init
argument_list|(
operator|&
name|ffsd
operator|->
name|fs_pack_lock
argument_list|,
name|SVN_FS_X__USE_LOCK_MUTEX
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ... not to mention locking the txn-current file. */
name|SVN_ERR
argument_list|(
name|svn_mutex__init
argument_list|(
operator|&
name|ffsd
operator|->
name|txn_current_lock
argument_list|,
name|SVN_FS_X__USE_LOCK_MUTEX
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We also need a mutex for synchronizing access to the active          transaction list and free transaction pointer. */
name|SVN_ERR
argument_list|(
name|svn_mutex__init
argument_list|(
operator|&
name|ffsd
operator|->
name|txn_list_lock
argument_list|,
name|TRUE
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|apr_pstrdup
argument_list|(
name|common_pool
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|status
operator|=
name|apr_pool_userdata_set
argument_list|(
name|ffsd
argument_list|,
name|key
argument_list|,
name|NULL
argument_list|,
name|common_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't store FSX shared data"
argument_list|)
argument_list|)
return|;
block|}
name|ffd
operator|->
name|shared
operator|=
name|ffsd
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is provided for Subversion 1.0.x compatibility.  It    has no effect for fsx backed Subversion filesystems.  It conforms    to the fs_library_vtable_t.bdb_set_errcall() API. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_set_errcall
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|void
function_decl|(
modifier|*
name|db_errcall_fcn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|errpfx
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|x_freeze_baton_t
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_freeze_func_t
name|freeze_func
decl_stmt|;
name|void
modifier|*
name|freeze_baton
decl_stmt|;
block|}
name|x_freeze_baton_t
typedef|;
end_typedef

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_freeze_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|x_freeze_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_boolean_t
name|exists
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__exists_rep_cache
argument_list|(
operator|&
name|exists
argument_list|,
name|b
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|exists
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__with_rep_cache_lock
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|b
operator|->
name|freeze_func
argument_list|,
name|b
operator|->
name|freeze_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|b
operator|->
name|freeze_func
argument_list|(
name|b
operator|->
name|freeze_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_freeze_body2
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|x_freeze_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__with_write_lock
argument_list|(
name|b
operator|->
name|fs
argument_list|,
name|x_freeze_body
argument_list|,
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_freeze
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_freeze_func_t
name|freeze_func
parameter_list|,
name|void
modifier|*
name|freeze_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|x_freeze_baton_t
name|b
decl_stmt|;
name|b
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|b
operator|.
name|freeze_func
operator|=
name|freeze_func
expr_stmt|;
name|b
operator|.
name|freeze_baton
operator|=
name|freeze_baton
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__with_pack_lock
argument_list|(
name|fs
argument_list|,
name|x_freeze_body2
argument_list|,
operator|&
name|b
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_info
parameter_list|(
specifier|const
name|void
modifier|*
modifier|*
name|fsx_info
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_fsx_info_t
modifier|*
name|info
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|info
argument_list|)
argument_list|)
decl_stmt|;
name|info
operator|->
name|fs_type
operator|=
name|SVN_FS_TYPE_FSX
expr_stmt|;
name|info
operator|->
name|shard_size
operator|=
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
name|info
operator|->
name|min_unpacked_rev
operator|=
name|ffd
operator|->
name|min_unpacked_rev
expr_stmt|;
operator|*
name|fsx_info
operator|=
name|info
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around svn_fs_x__revision_prop() adapting between function    signatures. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_revision_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__revision_prop
argument_list|(
name|value_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|propname
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around svn_fs_x__get_revision_proplist() adapting between function    signatures. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_revision_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* No need to bypass the caches for r/o access to revprops. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_revision_proplist
argument_list|(
name|proplist_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around svn_fs_x__set_uuid() adapting between function    signatures. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_set_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Whenever we set a new UUID, imply that FS will also be a different    * instance (on formats that support this). */
return|return
name|svn_error_trace
argument_list|(
name|svn_fs_x__set_uuid
argument_list|(
name|fs
argument_list|,
name|uuid
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Wrapper around svn_fs_x__begin_txn() providing the scratch pool. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_begin_txn
parameter_list|(
name|svn_fs_txn_t
modifier|*
modifier|*
name|txn_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__begin_txn
argument_list|(
name|txn_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|flags
argument_list|,
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The vtable associated with a specific open filesystem. */
end_comment

begin_decl_stmt
specifier|static
name|fs_vtable_t
name|fs_vtable
init|=
block|{
name|svn_fs_x__youngest_rev
block|,
name|x_revision_prop
block|,
name|x_revision_proplist
block|,
name|svn_fs_x__change_rev_prop
block|,
name|x_set_uuid
block|,
name|svn_fs_x__revision_root
block|,
name|x_begin_txn
block|,
name|svn_fs_x__open_txn
block|,
name|svn_fs_x__purge_txn
block|,
name|svn_fs_x__list_transactions
block|,
name|svn_fs_x__deltify
block|,
name|svn_fs_x__lock
block|,
name|svn_fs_x__generate_lock_token
block|,
name|svn_fs_x__unlock
block|,
name|svn_fs_x__get_lock
block|,
name|svn_fs_x__get_locks
block|,
name|svn_fs_x__info_format
block|,
name|svn_fs_x__info_config_files
block|,
name|x_info
block|,
name|svn_fs_x__verify_root
block|,
name|x_freeze
block|,
name|x_set_errcall
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Creating a new filesystem. */
end_comment

begin_comment
comment|/* Set up vtable and fsap_data fields in FS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|initialize_fs_struct
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|apr_pcalloc
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ffd
argument_list|)
argument_list|)
decl_stmt|;
name|fs
operator|->
name|vtable
operator|=
operator|&
name|fs_vtable
expr_stmt|;
name|fs
operator|->
name|fsap_data
operator|=
name|ffd
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Reset vtable and fsap_data fields in FS such that the FS is basically  * closed now.  Note that FS must not hold locks when you call this. */
end_comment

begin_function
specifier|static
name|void
name|uninitialize_fs_struct
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|fs
operator|->
name|vtable
operator|=
name|NULL
expr_stmt|;
name|fs
operator|->
name|fsap_data
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This implements the fs_library_vtable_t.create() API.  Create a new    fsx-backed Subversion filesystem at path PATH and link it into    *FS.     Perform temporary allocations in SCRATCH_POOL, and fs-global allocations    in COMMON_POOL.  The latter must be serialized using COMMON_POOL_LOCK. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_create
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_mutex__t
modifier|*
name|common_pool_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|initialize_fs_struct
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__create
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__initialize_caches
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|common_pool_lock
argument_list|,
name|x_serialized_init
argument_list|(
name|fs
argument_list|,
name|common_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Gaining access to an existing filesystem.  */
end_comment

begin_comment
comment|/* This implements the fs_library_vtable_t.open() API.  Open an FSX    Subversion filesystem located at PATH, set *FS to point to the    correct vtable for the filesystem.  Use SCRATCH_POOL for any temporary    allocations, and COMMON_POOL for fs-global allocations.    The latter must be serialized using COMMON_POOL_LOCK.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_open
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_mutex__t
modifier|*
name|common_pool_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|initialize_fs_struct
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__open
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__initialize_caches
argument_list|(
name|fs
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|common_pool_lock
argument_list|,
name|x_serialized_init
argument_list|(
name|fs
argument_list|,
name|common_pool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This implements the fs_library_vtable_t.open_for_recovery() API. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_open_for_recovery
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_mutex__t
modifier|*
name|common_pool_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Recovery for FSFS is currently limited to recreating the 'current'      file from the latest revision. */
comment|/* The only thing we have to watch out for is that the 'current' file      might not exist or contain garbage.  So we'll try to read it here      and provide or replace the existing file if we couldn't read it.      (We'll also need it to exist later anyway as a source for the new      file's permissions). */
comment|/* Use a partly-filled fs pointer first to create 'current'. */
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|initialize_fs_struct
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Figure out the repo format and check that we can even handle it. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_format_file
argument_list|(
name|fs
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, read 'current' and try to patch it if necessary. */
name|err
operator|=
name|svn_fs_x__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
specifier|const
name|char
modifier|*
name|file_path
decl_stmt|;
comment|/* 'current' file is missing or contains garbage.  Since we are trying        * to recover from whatever problem there is, being picky about the        * error code here won't do us much good.  If there is a persistent        * problem that we can't fix, it will show up when we try rewrite the        * file a few lines further below and we will report the failure back        * to the caller.        *        * Start recovery with HEAD = 0. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|file_path
operator|=
name|svn_fs_x__path_current
argument_list|(
name|fs
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* Best effort to ensure the file exists and is valid.        * This may fail for r/o filesystems etc. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|file_path
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|file_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_current
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|uninitialize_fs_struct
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Now open the filesystem properly by calling the vtable method directly. */
return|return
name|x_open
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|common_pool_lock
argument_list|,
name|scratch_pool
argument_list|,
name|common_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This implements the fs_library_vtable_t.upgrade_fs() API. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_upgrade
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_upgrade_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_mutex__t
modifier|*
name|common_pool_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|x_open
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|common_pool_lock
argument_list|,
name|scratch_pool
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__upgrade
argument_list|(
name|fs
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_verify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_fs_progress_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_mutex__t
modifier|*
name|common_pool_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|x_open
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|common_pool_lock
argument_list|,
name|scratch_pool
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__verify
argument_list|(
name|fs
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_pack
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_pack_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_mutex__t
modifier|*
name|common_pool_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|x_open
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|common_pool_lock
argument_list|,
name|scratch_pool
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__pack
argument_list|(
name|fs
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This implements the fs_library_vtable_t.hotcopy() API.  Copy a    possibly live Subversion filesystem SRC_FS from SRC_PATH to a    DST_FS at DEST_PATH. If INCREMENTAL is TRUE, make an effort not to    re-copy data which already exists in DST_FS.    The CLEAN_LOGS argument is ignored and included for Subversion    1.0.x compatibility.  The NOTIFY_FUNC and NOTIFY_BATON arguments    are also currently ignored.    Perform all temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_hotcopy
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_path
parameter_list|,
name|svn_boolean_t
name|clean_logs
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|svn_fs_hotcopy_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_mutex__t
modifier|*
name|common_pool_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
comment|/* Open the source repo as usual. */
name|SVN_ERR
argument_list|(
name|x_open
argument_list|(
name|src_fs
argument_list|,
name|src_path
argument_list|,
name|common_pool_lock
argument_list|,
name|scratch_pool
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Test target repo when in INCREMENTAL mode, initialize it when not.    * For this, we need our FS internal data structures to be temporarily    * available. */
name|SVN_ERR
argument_list|(
name|initialize_fs_struct
argument_list|(
name|dst_fs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__hotcopy_prepare_target
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|incremental
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|uninitialize_fs_struct
argument_list|(
name|dst_fs
argument_list|)
expr_stmt|;
comment|/* Now, the destination repo should open just fine. */
name|SVN_ERR
argument_list|(
name|x_open
argument_list|(
name|dst_fs
argument_list|,
name|dst_path
argument_list|,
name|common_pool_lock
argument_list|,
name|scratch_pool
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, we may copy data as needed ... */
return|return
name|svn_fs_x__hotcopy
argument_list|(
name|src_fs
argument_list|,
name|dst_fs
argument_list|,
name|incremental
argument_list|,
name|notify_func
argument_list|,
name|notify_baton
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function is included for Subversion 1.0.x compatibility.  It    has no effect for fsx backed Subversion filesystems.  It conforms    to the fs_library_vtable_t.bdb_logfiles() API. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_logfiles
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|logfiles
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|only_unused
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* A no-op for FSX. */
operator|*
name|logfiles
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Delete the filesystem located at path PATH.  Perform any temporary    allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_delete_fs
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Remove everything. */
return|return
name|svn_error_trace
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|svn_version_t
modifier|*
name|x_version
parameter_list|(
name|void
parameter_list|)
block|{
name|SVN_VERSION_BODY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|x_get_description
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|_
argument_list|(
literal|"Module for working with an experimental (FSX) repository."
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|x_set_svn_fs_open
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_fs_open_
function_decl|)
parameter_list|(
name|svn_fs_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|apr_hash_t
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|ffd
operator|->
name|svn_fs_open_
operator|=
name|svn_fs_open_
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|void
modifier|*
name|x_info_dup
parameter_list|(
specifier|const
name|void
modifier|*
name|fsx_info_void
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* All fields are either ints or static strings. */
specifier|const
name|svn_fs_fsx_info_t
modifier|*
name|fsx_info
init|=
name|fsx_info_void
decl_stmt|;
return|return
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|fsx_info
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fsx_info
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Base FS library vtable, used by the FS loader library. */
end_comment

begin_decl_stmt
specifier|static
name|fs_library_vtable_t
name|library_vtable
init|=
block|{
name|x_version
block|,
name|x_create
block|,
name|x_open
block|,
name|x_open_for_recovery
block|,
name|x_upgrade
block|,
name|x_verify
block|,
name|x_delete_fs
block|,
name|x_hotcopy
block|,
name|x_get_description
block|,
name|svn_fs_x__recover
block|,
name|x_pack
block|,
name|x_logfiles
block|,
name|NULL
comment|/* parse_id */
block|,
name|x_set_svn_fs_open
block|,
name|x_info_dup
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__init
parameter_list|(
specifier|const
name|svn_version_t
modifier|*
name|loader_version
parameter_list|,
name|fs_library_vtable_t
modifier|*
modifier|*
name|vtable
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
literal|"svn_fs_util"
block|,
name|svn_fs_util__version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
comment|/* Simplified version check to make sure we can safely use the      VTABLE parameter. The FS loader does a more exhaustive check. */
if|if
condition|(
name|loader_version
operator|->
name|major
operator|!=
name|SVN_VER_MAJOR
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported FS loader version (%d) for fsx"
argument_list|)
argument_list|,
name|loader_version
operator|->
name|major
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ver_check_list2
argument_list|(
name|x_version
argument_list|()
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vtable
operator|=
operator|&
name|library_vtable
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

