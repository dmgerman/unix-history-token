begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* reps.c --- FSX representation container  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"reps.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_packed_data.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_comment
comment|/* Length of the text chunks we hash and match.  The algorithm will find  * most matches with a length of 2 * MATCH_BLOCKSIZE and only specific  * ones that are shorter than MATCH_BLOCKSIZE.  *  * This should be a power of two and must be a multiple of 8.  * Good choices are 32, 64 and 128.  */
end_comment

begin_define
define|#
directive|define
name|MATCH_BLOCKSIZE
value|64
end_define

begin_comment
comment|/* Limit the total text body within a container to 16MB.  Larger values  * of up to 2GB are possible but become increasingly impractical as the  * container has to be loaded in its entirety before any of it can be read.  */
end_comment

begin_define
define|#
directive|define
name|MAX_TEXT_BODY
value|0x1000000
end_define

begin_comment
comment|/* Limit the size of the instructions stream.  This should not exceed the  * text body size limit. */
end_comment

begin_define
define|#
directive|define
name|MAX_INSTRUCTIONS
value|(MAX_TEXT_BODY / 8)
end_define

begin_comment
comment|/* value of unused hash buckets */
end_comment

begin_define
define|#
directive|define
name|NO_OFFSET
value|((apr_uint32_t)(-1))
end_define

begin_comment
comment|/* Byte strings are described by a series of copy instructions that each  * do one of the following  *  * - copy a given number of bytes from the text corpus starting at a  *   given offset  * - reference other instruction and specify how many of instructions of  *   that sequence shall be executed (i.e. a sub-sequence)  * - copy a number of bytes from the base representation buffer starting  *   at a given offset  */
end_comment

begin_comment
comment|/* The contents of a fulltext / representation is defined by its first  * instruction and the number of instructions to execute.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|rep_t
block|{
name|apr_uint32_t
name|first_instruction
decl_stmt|;
name|apr_uint32_t
name|instruction_count
decl_stmt|;
block|}
name|rep_t
typedef|;
end_typedef

begin_comment
comment|/* A single instruction.  The instruction type is being encoded in OFFSET.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|instruction_t
block|{
comment|/* Instruction type and offset.    * - offset< 0    *   reference to instruction sub-sequence starting with    *   container->instructions[-offset].    * - 0<= offset< container->base_text_len    *   reference to the base text corpus;    *   start copy at offset    * - offset>= container->base_text_len    *   reference to the text corpus;    *   start copy at offset-container->base_text_len    */
name|apr_int32_t
name|offset
decl_stmt|;
comment|/* Number of bytes to copy / instructions to execute    */
name|apr_uint32_t
name|count
decl_stmt|;
block|}
name|instruction_t
typedef|;
end_typedef

begin_comment
comment|/* Describe a base fulltext.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|base_t
block|{
comment|/* Revision */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* Item within that revision */
name|apr_uint64_t
name|item_index
decl_stmt|;
comment|/* Priority with which to use this base over others */
name|int
name|priority
decl_stmt|;
comment|/* Index into builder->representations that identifies the copy    * instructions for this base. */
name|apr_uint32_t
name|rep
decl_stmt|;
block|}
name|base_t
typedef|;
end_typedef

begin_comment
comment|/* Yet another hash data structure.  This one tries to be more cache  * friendly by putting the first byte of each hashed sequence in a  * common array.  This array will often fit into L1 or L2 at least and  * give a 99% accurate test for a match without giving false negatives.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|hash_t
block|{
comment|/* for used entries i, prefixes[i] == text[offsets[i]]; 0 otherwise.    * This allows for a quick check without resolving the double    * indirection. */
name|char
modifier|*
name|prefixes
decl_stmt|;
comment|/* for used entries i, offsets[i] is start offset in the text corpus;    * NO_OFFSET otherwise.    */
name|apr_uint32_t
modifier|*
name|offsets
decl_stmt|;
comment|/* to be used later for optimizations. */
name|apr_uint32_t
modifier|*
name|last_matches
decl_stmt|;
comment|/* number of buckets in this hash, i.e. elements in each array above.    * Must be 1<< (8 * sizeof(hash_key_t) - shift) */
name|apr_size_t
name|size
decl_stmt|;
comment|/* number of buckets actually in use. Must be<= size. */
name|apr_size_t
name|used
decl_stmt|;
comment|/* number of bits to shift right to map a hash_key_t to a bucket index */
name|apr_size_t
name|shift
decl_stmt|;
comment|/* pool to use when growing the hash */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|hash_t
typedef|;
end_typedef

begin_comment
comment|/* Hash key type. 32 bits for pseudo-Adler32 hash sums.  */
end_comment

begin_typedef
typedef|typedef
name|apr_uint32_t
name|hash_key_t
typedef|;
end_typedef

begin_comment
comment|/* Constructor data structure.  */
end_comment

begin_struct
struct|struct
name|svn_fs_x__reps_builder_t
block|{
comment|/* file system to read base representations from */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* text corpus */
name|svn_stringbuf_t
modifier|*
name|text
decl_stmt|;
comment|/* text block hash */
name|hash_t
name|hash
decl_stmt|;
comment|/* array of base_t objects describing all bases defined so far */
name|apr_array_header_t
modifier|*
name|bases
decl_stmt|;
comment|/* array of rep_t objects describing all fulltexts (including bases)    * added so far */
name|apr_array_header_t
modifier|*
name|reps
decl_stmt|;
comment|/* array of instruction_t objects describing all instructions */
name|apr_array_header_t
modifier|*
name|instructions
decl_stmt|;
comment|/* number of bytes in the text corpus that belongs to bases */
name|apr_size_t
name|base_text_len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* R/o container.  */
end_comment

begin_struct
struct|struct
name|svn_fs_x__reps_t
block|{
comment|/* text corpus */
specifier|const
name|char
modifier|*
name|text
decl_stmt|;
comment|/* length of the text corpus in bytes */
name|apr_size_t
name|text_len
decl_stmt|;
comment|/* bases used */
specifier|const
name|base_t
modifier|*
name|bases
decl_stmt|;
comment|/* number of bases used */
name|apr_size_t
name|base_count
decl_stmt|;
comment|/* fulltext i can be reconstructed by executing instructions    * first_instructions[i] .. first_instructions[i+1]-1    * (this array has one extra element at the end)    */
specifier|const
name|apr_uint32_t
modifier|*
name|first_instructions
decl_stmt|;
comment|/* number of fulltexts (no bases) */
name|apr_size_t
name|rep_count
decl_stmt|;
comment|/* instructions */
specifier|const
name|instruction_t
modifier|*
name|instructions
decl_stmt|;
comment|/* total number of instructions */
name|apr_size_t
name|instruction_count
decl_stmt|;
comment|/* offsets> 0 but smaller that this are considered base references */
name|apr_size_t
name|base_text_len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* describe a section in the extractor's result string that is not filled  * yet (but already exists).  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|missing_t
block|{
comment|/* start offset within the result string */
name|apr_uint32_t
name|start
decl_stmt|;
comment|/* number of bytes to write */
name|apr_uint32_t
name|count
decl_stmt|;
comment|/* index into extractor->bases selecting the base representation to    * copy from */
name|apr_uint32_t
name|base
decl_stmt|;
comment|/* copy source offset within that base representation */
name|apr_uint32_t
name|offset
decl_stmt|;
block|}
name|missing_t
typedef|;
end_typedef

begin_comment
comment|/* Fulltext extractor data structure.  */
end_comment

begin_struct
struct|struct
name|svn_fs_x__rep_extractor_t
block|{
comment|/* filesystem to read the bases from */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* fulltext being constructed */
name|svn_stringbuf_t
modifier|*
name|result
decl_stmt|;
comment|/* bases (base_t) yet to process (not used ATM) */
name|apr_array_header_t
modifier|*
name|bases
decl_stmt|;
comment|/* missing sections (missing_t) in result->data that need to be filled,    * yet */
name|apr_array_header_t
modifier|*
name|missing
decl_stmt|;
comment|/* pool to use for allocating the above arrays */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Given the ADLER32 checksum for a certain range of MATCH_BLOCKSIZE  * bytes, return the checksum for the range excluding the first byte  * C_OUT and appending C_IN.  */
end_comment

begin_function
specifier|static
name|hash_key_t
name|hash_key_replace
parameter_list|(
name|hash_key_t
name|adler32
parameter_list|,
specifier|const
name|char
name|c_out
parameter_list|,
specifier|const
name|char
name|c_in
parameter_list|)
block|{
name|adler32
operator|-=
operator|(
name|MATCH_BLOCKSIZE
operator|*
literal|0x10000u
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|)
name|c_out
operator|)
operator|)
expr_stmt|;
name|adler32
operator|-=
operator|(
name|unsigned
name|char
operator|)
name|c_out
expr_stmt|;
name|adler32
operator|+=
operator|(
name|unsigned
name|char
operator|)
name|c_in
expr_stmt|;
return|return
name|adler32
operator|+
name|adler32
operator|*
literal|0x10000
return|;
block|}
end_function

begin_comment
comment|/* Calculate an pseudo-adler32 checksum for MATCH_BLOCKSIZE bytes starting    at DATA.  Return the checksum value.  */
end_comment

begin_function
specifier|static
name|hash_key_t
name|hash_key
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|last
init|=
name|input
operator|+
name|MATCH_BLOCKSIZE
decl_stmt|;
name|hash_key_t
name|s1
init|=
literal|0
decl_stmt|;
name|hash_key_t
name|s2
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|input
operator|<
name|last
condition|;
name|input
operator|+=
literal|8
control|)
block|{
name|s1
operator|+=
name|input
index|[
literal|0
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|1
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|2
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|3
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|4
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|5
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|6
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|7
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
block|}
return|return
name|s2
operator|*
literal|0x10000
operator|+
name|s1
return|;
block|}
end_function

begin_comment
comment|/* Map the ADLER32 key to a bucket index in HASH and return that index.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|hash_to_index
parameter_list|(
name|hash_t
modifier|*
name|hash
parameter_list|,
name|hash_key_t
name|adler32
parameter_list|)
block|{
return|return
operator|(
name|adler32
operator|*
literal|0xd1f3da69
operator|)
operator|>>
name|hash
operator|->
name|shift
return|;
block|}
end_function

begin_comment
comment|/* Allocate and initialized SIZE buckets in RESULT_POOL.  * Assign them to HASH.  */
end_comment

begin_function
specifier|static
name|void
name|allocate_hash_members
parameter_list|(
name|hash_t
modifier|*
name|hash
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|hash
operator|->
name|pool
operator|=
name|result_pool
expr_stmt|;
name|hash
operator|->
name|size
operator|=
name|size
expr_stmt|;
name|hash
operator|->
name|prefixes
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|hash
operator|->
name|last_matches
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hash
operator|->
name|last_matches
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
name|hash
operator|->
name|offsets
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hash
operator|->
name|offsets
argument_list|)
operator|*
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
operator|++
name|i
control|)
name|hash
operator|->
name|offsets
index|[
name|i
index|]
operator|=
name|NO_OFFSET
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Initialize the HASH data structure with 2**TWOPOWER buckets allocated  * in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|void
name|init_hash
parameter_list|(
name|hash_t
modifier|*
name|hash
parameter_list|,
name|apr_size_t
name|twoPower
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|hash
operator|->
name|used
operator|=
literal|0
expr_stmt|;
name|hash
operator|->
name|shift
operator|=
sizeof|sizeof
argument_list|(
name|hash_key_t
argument_list|)
operator|*
literal|8
operator|-
name|twoPower
expr_stmt|;
name|allocate_hash_members
argument_list|(
name|hash
argument_list|,
literal|1
operator|<<
name|twoPower
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make HASH have at least MIN_SIZE buckets but at least double the number  * of buckets in HASH by rehashing it based TEXT.  */
end_comment

begin_function
specifier|static
name|void
name|grow_hash
parameter_list|(
name|hash_t
modifier|*
name|hash
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|text
parameter_list|,
name|apr_size_t
name|min_size
parameter_list|)
block|{
name|hash_t
name|copy
decl_stmt|;
name|apr_size_t
name|i
decl_stmt|;
comment|/* determine the new hash size */
name|apr_size_t
name|new_size
init|=
name|hash
operator|->
name|size
operator|*
literal|2
decl_stmt|;
name|apr_size_t
name|new_shift
init|=
name|hash
operator|->
name|shift
operator|-
literal|1
decl_stmt|;
while|while
condition|(
name|new_size
operator|<
name|min_size
condition|)
block|{
name|new_size
operator|*=
literal|2
expr_stmt|;
operator|--
name|new_shift
expr_stmt|;
block|}
comment|/* allocate new hash */
name|allocate_hash_members
argument_list|(
operator|&
name|copy
argument_list|,
name|new_size
argument_list|,
name|hash
operator|->
name|pool
argument_list|)
expr_stmt|;
name|copy
operator|.
name|used
operator|=
literal|0
expr_stmt|;
name|copy
operator|.
name|shift
operator|=
name|new_shift
expr_stmt|;
comment|/* copy / translate data */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|hash
operator|->
name|size
condition|;
operator|++
name|i
control|)
block|{
name|apr_uint32_t
name|offset
init|=
name|hash
operator|->
name|offsets
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|offset
operator|!=
name|NO_OFFSET
condition|)
block|{
name|hash_key_t
name|key
init|=
name|hash_key
argument_list|(
name|text
operator|->
name|data
operator|+
name|offset
argument_list|)
decl_stmt|;
name|size_t
name|idx
init|=
name|hash_to_index
argument_list|(
operator|&
name|copy
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|copy
operator|.
name|offsets
index|[
name|idx
index|]
operator|==
name|NO_OFFSET
condition|)
name|copy
operator|.
name|used
operator|++
expr_stmt|;
name|copy
operator|.
name|prefixes
index|[
name|idx
index|]
operator|=
name|hash
operator|->
name|prefixes
index|[
name|i
index|]
expr_stmt|;
name|copy
operator|.
name|offsets
index|[
name|idx
index|]
operator|=
name|offset
expr_stmt|;
name|copy
operator|.
name|last_matches
index|[
name|idx
index|]
operator|=
name|hash
operator|->
name|last_matches
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
operator|*
name|hash
operator|=
name|copy
expr_stmt|;
block|}
end_function

begin_function
name|svn_fs_x__reps_builder_t
modifier|*
name|svn_fs_x__reps_builder_create
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__reps_builder_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|result
operator|->
name|text
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|init_hash
argument_list|(
operator|&
name|result
operator|->
name|hash
argument_list|,
literal|4
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|result
operator|->
name|bases
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|base_t
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|reps
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_t
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|instructions
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|instruction_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__reps_add_base
parameter_list|(
name|svn_fs_x__reps_builder_t
modifier|*
name|builder
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|int
name|priority
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|base_t
name|base
decl_stmt|;
name|apr_size_t
name|text_start_offset
init|=
name|builder
operator|->
name|text
operator|->
name|len
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_string_t
modifier|*
name|contents
decl_stmt|;
name|apr_size_t
name|idx
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_contents
argument_list|(
operator|&
name|stream
argument_list|,
name|builder
operator|->
name|fs
argument_list|,
name|rep
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_string_from_stream
argument_list|(
operator|&
name|contents
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__reps_add
argument_list|(
operator|&
name|idx
argument_list|,
name|builder
argument_list|,
name|contents
argument_list|)
argument_list|)
expr_stmt|;
name|base
operator|.
name|revision
operator|=
name|svn_fs_x__get_revnum
argument_list|(
name|rep
operator|->
name|id
operator|.
name|change_set
argument_list|)
expr_stmt|;
name|base
operator|.
name|item_index
operator|=
name|rep
operator|->
name|id
operator|.
name|number
expr_stmt|;
name|base
operator|.
name|priority
operator|=
name|priority
expr_stmt|;
name|base
operator|.
name|rep
operator|=
operator|(
name|apr_uint32_t
operator|)
name|idx
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|builder
operator|->
name|bases
argument_list|,
name|base_t
argument_list|)
operator|=
name|base
expr_stmt|;
name|builder
operator|->
name|base_text_len
operator|+=
name|builder
operator|->
name|text
operator|->
name|len
operator|-
name|text_start_offset
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add LEN bytes from DATA to BUILDER's text corpus. Also, add a copy  * operation for that text fragment.  */
end_comment

begin_function
specifier|static
name|void
name|add_new_text
parameter_list|(
name|svn_fs_x__reps_builder_t
modifier|*
name|builder
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
name|instruction_t
name|instruction
decl_stmt|;
name|apr_size_t
name|offset
decl_stmt|;
name|apr_size_t
name|buckets_required
decl_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return;
comment|/* new instruction */
name|instruction
operator|.
name|offset
operator|=
operator|(
name|apr_int32_t
operator|)
name|builder
operator|->
name|text
operator|->
name|len
expr_stmt|;
name|instruction
operator|.
name|count
operator|=
operator|(
name|apr_uint32_t
operator|)
name|len
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|builder
operator|->
name|instructions
argument_list|,
name|instruction_t
argument_list|)
operator|=
name|instruction
expr_stmt|;
comment|/* add to text corpus */
name|svn_stringbuf_appendbytes
argument_list|(
name|builder
operator|->
name|text
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* expand the hash upfront to minimize the chances of collisions */
name|buckets_required
operator|=
name|builder
operator|->
name|hash
operator|.
name|used
operator|+
name|len
operator|/
name|MATCH_BLOCKSIZE
expr_stmt|;
if|if
condition|(
name|buckets_required
operator|*
literal|3
operator|>=
name|builder
operator|->
name|hash
operator|.
name|size
operator|*
literal|2
condition|)
name|grow_hash
argument_list|(
operator|&
name|builder
operator|->
name|hash
argument_list|,
name|builder
operator|->
name|text
argument_list|,
literal|2
operator|*
name|buckets_required
argument_list|)
expr_stmt|;
comment|/* add hash entries for the new sequence */
for|for
control|(
name|offset
operator|=
name|instruction
operator|.
name|offset
init|;
name|offset
operator|+
name|MATCH_BLOCKSIZE
operator|<=
name|builder
operator|->
name|text
operator|->
name|len
condition|;
name|offset
operator|+=
name|MATCH_BLOCKSIZE
control|)
block|{
name|hash_key_t
name|key
init|=
name|hash_key
argument_list|(
name|builder
operator|->
name|text
operator|->
name|data
operator|+
name|offset
argument_list|)
decl_stmt|;
name|size_t
name|idx
init|=
name|hash_to_index
argument_list|(
operator|&
name|builder
operator|->
name|hash
argument_list|,
name|key
argument_list|)
decl_stmt|;
comment|/* Don't replace hash entries that stem from the current text.        * This makes early matches more likely. */
if|if
condition|(
name|builder
operator|->
name|hash
operator|.
name|offsets
index|[
name|idx
index|]
operator|==
name|NO_OFFSET
condition|)
operator|++
name|builder
operator|->
name|hash
operator|.
name|used
expr_stmt|;
elseif|else
if|if
condition|(
name|builder
operator|->
name|hash
operator|.
name|offsets
index|[
name|idx
index|]
operator|>=
name|instruction
operator|.
name|offset
condition|)
continue|continue;
name|builder
operator|->
name|hash
operator|.
name|offsets
index|[
name|idx
index|]
operator|=
operator|(
name|apr_uint32_t
operator|)
name|offset
expr_stmt|;
name|builder
operator|->
name|hash
operator|.
name|prefixes
index|[
name|idx
index|]
operator|=
name|builder
operator|->
name|text
operator|->
name|data
index|[
name|offset
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__reps_add
parameter_list|(
name|apr_size_t
modifier|*
name|rep_idx
parameter_list|,
name|svn_fs_x__reps_builder_t
modifier|*
name|builder
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|contents
parameter_list|)
block|{
name|rep_t
name|rep
decl_stmt|;
specifier|const
name|char
modifier|*
name|current
init|=
name|contents
operator|->
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|processed
init|=
name|current
decl_stmt|;
specifier|const
name|char
modifier|*
name|end
init|=
name|current
operator|+
name|contents
operator|->
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_to_test
init|=
name|end
operator|-
name|MATCH_BLOCKSIZE
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|builder
operator|->
name|text
operator|->
name|len
operator|+
name|contents
operator|->
name|len
operator|>
name|MAX_TEXT_BODY
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CONTAINER_SIZE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Text body exceeds star delta container capacity"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|builder
operator|->
name|instructions
operator|->
name|nelts
operator|+
literal|2
operator|*
name|contents
operator|->
name|len
operator|/
name|MATCH_BLOCKSIZE
operator|>
name|MAX_INSTRUCTIONS
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CONTAINER_SIZE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Instruction count exceeds star delta container capacity"
argument_list|)
argument_list|)
return|;
name|rep
operator|.
name|first_instruction
operator|=
operator|(
name|apr_uint32_t
operator|)
name|builder
operator|->
name|instructions
operator|->
name|nelts
expr_stmt|;
while|while
condition|(
name|current
operator|<
name|last_to_test
condition|)
block|{
name|hash_key_t
name|key
init|=
name|hash_key
argument_list|(
name|current
argument_list|)
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|size_t
name|idx
decl_stmt|;
comment|/* search for the next matching sequence */
for|for
control|(
init|;
name|current
operator|<
name|last_to_test
condition|;
operator|++
name|current
control|)
block|{
name|idx
operator|=
name|hash_to_index
argument_list|(
operator|&
name|builder
operator|->
name|hash
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
name|builder
operator|->
name|hash
operator|.
name|prefixes
index|[
name|idx
index|]
operator|==
name|current
index|[
literal|0
index|]
condition|)
block|{
name|offset
operator|=
name|builder
operator|->
name|hash
operator|.
name|offsets
index|[
name|idx
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|offset
operator|!=
name|NO_OFFSET
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
operator|&
name|builder
operator|->
name|text
operator|->
name|data
index|[
name|offset
index|]
argument_list|,
name|current
argument_list|,
name|MATCH_BLOCKSIZE
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
name|key
operator|=
name|hash_key_replace
argument_list|(
name|key
argument_list|,
name|current
index|[
literal|0
index|]
argument_list|,
name|current
index|[
name|MATCH_BLOCKSIZE
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* found it? */
if|if
condition|(
name|current
operator|<
name|last_to_test
condition|)
block|{
name|instruction_t
name|instruction
decl_stmt|;
comment|/* extend the match */
name|size_t
name|prefix_match
init|=
name|svn_cstring__reverse_match_length
argument_list|(
name|current
argument_list|,
name|builder
operator|->
name|text
operator|->
name|data
operator|+
name|offset
argument_list|,
name|MIN
argument_list|(
name|offset
argument_list|,
name|current
operator|-
name|processed
argument_list|)
argument_list|)
decl_stmt|;
name|size_t
name|postfix_match
init|=
name|svn_cstring__match_length
argument_list|(
name|current
operator|+
name|MATCH_BLOCKSIZE
argument_list|,
name|builder
operator|->
name|text
operator|->
name|data
operator|+
name|offset
operator|+
name|MATCH_BLOCKSIZE
argument_list|,
name|MIN
argument_list|(
name|builder
operator|->
name|text
operator|->
name|len
operator|-
name|offset
operator|-
name|MATCH_BLOCKSIZE
argument_list|,
name|end
operator|-
name|current
operator|-
name|MATCH_BLOCKSIZE
argument_list|)
argument_list|)
decl_stmt|;
comment|/* non-matched section */
name|size_t
name|new_copy
init|=
operator|(
name|current
operator|-
name|processed
operator|)
operator|-
name|prefix_match
decl_stmt|;
if|if
condition|(
name|new_copy
condition|)
name|add_new_text
argument_list|(
name|builder
argument_list|,
name|processed
argument_list|,
name|new_copy
argument_list|)
expr_stmt|;
comment|/* add instruction for matching section */
name|instruction
operator|.
name|offset
operator|=
call|(
name|apr_int32_t
call|)
argument_list|(
name|offset
operator|-
name|prefix_match
argument_list|)
expr_stmt|;
name|instruction
operator|.
name|count
operator|=
call|(
name|apr_uint32_t
call|)
argument_list|(
name|prefix_match
operator|+
name|postfix_match
operator|+
name|MATCH_BLOCKSIZE
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|builder
operator|->
name|instructions
argument_list|,
name|instruction_t
argument_list|)
operator|=
name|instruction
expr_stmt|;
name|processed
operator|=
name|current
operator|+
name|MATCH_BLOCKSIZE
operator|+
name|postfix_match
expr_stmt|;
name|current
operator|=
name|processed
expr_stmt|;
block|}
block|}
name|add_new_text
argument_list|(
name|builder
argument_list|,
name|processed
argument_list|,
name|end
operator|-
name|processed
argument_list|)
expr_stmt|;
name|rep
operator|.
name|instruction_count
operator|=
operator|(
name|apr_uint32_t
operator|)
name|builder
operator|->
name|instructions
operator|->
name|nelts
operator|-
name|rep
operator|.
name|first_instruction
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|builder
operator|->
name|reps
argument_list|,
name|rep_t
argument_list|)
operator|=
name|rep
expr_stmt|;
operator|*
name|rep_idx
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|builder
operator|->
name|reps
operator|->
name|nelts
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_fs_x__reps_estimate_size
parameter_list|(
specifier|const
name|svn_fs_x__reps_builder_t
modifier|*
name|builder
parameter_list|)
block|{
comment|/* approx: size of the text exclusive to us @ 50% compression rate    *       + 2 bytes per instruction    *       + 2 bytes per representation    *       + 8 bytes per base representation    *       + 1:8 inefficiency in using the base representations    *       + 100 bytes static overhead    */
return|return
operator|(
name|builder
operator|->
name|text
operator|->
name|len
operator|-
name|builder
operator|->
name|base_text_len
operator|)
operator|/
literal|2
operator|+
name|builder
operator|->
name|instructions
operator|->
name|nelts
operator|*
literal|2
operator|+
name|builder
operator|->
name|reps
operator|->
name|nelts
operator|*
literal|2
operator|+
name|builder
operator|->
name|bases
operator|->
name|nelts
operator|*
literal|8
operator|+
name|builder
operator|->
name|base_text_len
operator|/
literal|8
operator|+
literal|100
return|;
block|}
end_function

begin_comment
comment|/* Execute COUNT instructions starting at INSTRUCTION_IDX in CONTAINER  * and fill the parts of EXTRACTOR->RESULT that we can from this container.  * Record the remainder in EXTRACTOR->MISSING.  *  * This function will recurse for instructions that reference other  * instruction sequences. COUNT refers to the top-level instructions only.  */
end_comment

begin_function
specifier|static
name|void
name|get_text
parameter_list|(
name|svn_fs_x__rep_extractor_t
modifier|*
name|extractor
parameter_list|,
specifier|const
name|svn_fs_x__reps_t
modifier|*
name|container
parameter_list|,
name|apr_size_t
name|instruction_idx
parameter_list|,
name|apr_size_t
name|count
parameter_list|)
block|{
specifier|const
name|instruction_t
modifier|*
name|instruction
decl_stmt|;
specifier|const
name|char
modifier|*
name|offset_0
init|=
name|container
operator|->
name|text
operator|-
name|container
operator|->
name|base_text_len
decl_stmt|;
for|for
control|(
name|instruction
operator|=
name|container
operator|->
name|instructions
operator|+
name|instruction_idx
init|;
name|instruction
operator|<
name|container
operator|->
name|instructions
operator|+
name|instruction_idx
operator|+
name|count
condition|;
name|instruction
operator|++
control|)
if|if
condition|(
name|instruction
operator|->
name|offset
operator|<
literal|0
condition|)
block|{
comment|/* instruction sub-sequence */
name|get_text
argument_list|(
name|extractor
argument_list|,
name|container
argument_list|,
operator|-
name|instruction
operator|->
name|offset
argument_list|,
name|instruction
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|instruction
operator|->
name|offset
operator|>=
name|container
operator|->
name|base_text_len
condition|)
block|{
comment|/* direct copy instruction */
name|svn_stringbuf_appendbytes
argument_list|(
name|extractor
operator|->
name|result
argument_list|,
name|offset_0
operator|+
name|instruction
operator|->
name|offset
argument_list|,
name|instruction
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* a section that we need to fill from some external base rep. */
name|missing_t
name|missing
decl_stmt|;
name|missing
operator|.
name|base
operator|=
literal|0
expr_stmt|;
name|missing
operator|.
name|start
operator|=
operator|(
name|apr_uint32_t
operator|)
name|extractor
operator|->
name|result
operator|->
name|len
expr_stmt|;
name|missing
operator|.
name|count
operator|=
name|instruction
operator|->
name|count
expr_stmt|;
name|missing
operator|.
name|offset
operator|=
name|instruction
operator|->
name|offset
expr_stmt|;
name|svn_stringbuf_appendfill
argument_list|(
name|extractor
operator|->
name|result
argument_list|,
literal|0
argument_list|,
name|instruction
operator|->
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|extractor
operator|->
name|missing
operator|==
name|NULL
condition|)
name|extractor
operator|->
name|missing
operator|=
name|apr_array_make
argument_list|(
name|extractor
operator|->
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|missing
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|extractor
operator|->
name|missing
argument_list|,
name|missing_t
argument_list|)
operator|=
name|missing
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__reps_get
parameter_list|(
name|svn_fs_x__rep_extractor_t
modifier|*
modifier|*
name|extractor
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__reps_t
modifier|*
name|container
parameter_list|,
name|apr_size_t
name|idx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_uint32_t
name|first
init|=
name|container
operator|->
name|first_instructions
index|[
name|idx
index|]
decl_stmt|;
name|apr_uint32_t
name|last
init|=
name|container
operator|->
name|first_instructions
index|[
name|idx
operator|+
literal|1
index|]
decl_stmt|;
comment|/* create the extractor object */
name|svn_fs_x__rep_extractor_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|result
operator|->
name|result
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|result
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* fill all the bits of the result that we can, i.e. all but bits coming    * from base representations */
name|get_text
argument_list|(
name|result
argument_list|,
name|container
argument_list|,
name|first
argument_list|,
name|last
operator|-
name|first
argument_list|)
expr_stmt|;
operator|*
name|extractor
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__extractor_drive
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_fs_x__rep_extractor_t
modifier|*
name|extractor
parameter_list|,
name|apr_size_t
name|start_offset
parameter_list|,
name|apr_size_t
name|size
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* we don't support base reps right now */
name|SVN_ERR_ASSERT
argument_list|(
name|extractor
operator|->
name|missing
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
operator|*
name|contents
operator|=
name|svn_stringbuf_dup
argument_list|(
name|extractor
operator|->
name|result
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* clip the selected range */
if|if
condition|(
name|start_offset
operator|>
name|extractor
operator|->
name|result
operator|->
name|len
condition|)
name|start_offset
operator|=
name|extractor
operator|->
name|result
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|extractor
operator|->
name|result
operator|->
name|len
operator|-
name|start_offset
condition|)
name|size
operator|=
name|extractor
operator|->
name|result
operator|->
name|len
operator|-
name|start_offset
expr_stmt|;
operator|*
name|contents
operator|=
name|svn_stringbuf_ncreate
argument_list|(
name|extractor
operator|->
name|result
operator|->
name|data
operator|+
name|start_offset
argument_list|,
name|size
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__write_reps_container
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
specifier|const
name|svn_fs_x__reps_builder_t
modifier|*
name|builder
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|svn_packed__data_root_t
modifier|*
name|root
init|=
name|svn_packed__data_create_root
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* one top-level stream for each array */
name|svn_packed__int_stream_t
modifier|*
name|bases_stream
init|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|reps_stream
init|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|instructions_stream
init|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* for misc stuff */
name|svn_packed__int_stream_t
modifier|*
name|misc_stream
init|=
name|svn_packed__create_int_stream
argument_list|(
name|root
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
decl_stmt|;
comment|/* TEXT will be just a single string */
name|svn_packed__byte_stream_t
modifier|*
name|text_stream
init|=
name|svn_packed__create_bytes_stream
argument_list|(
name|root
argument_list|)
decl_stmt|;
comment|/* structure the struct streams such we can extract much of the redundancy    */
name|svn_packed__create_int_substream
argument_list|(
name|bases_stream
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|bases_stream
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|bases_stream
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|bases_stream
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|instructions_stream
argument_list|,
name|TRUE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|svn_packed__create_int_substream
argument_list|(
name|instructions_stream
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
comment|/* text */
name|svn_packed__add_bytes
argument_list|(
name|text_stream
argument_list|,
name|builder
operator|->
name|text
operator|->
name|data
argument_list|,
name|builder
operator|->
name|text
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* serialize bases */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|builder
operator|->
name|bases
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|base_t
modifier|*
name|base
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|builder
operator|->
name|bases
argument_list|,
name|i
argument_list|,
name|base_t
argument_list|)
decl_stmt|;
name|svn_packed__add_int
argument_list|(
name|bases_stream
argument_list|,
name|base
operator|->
name|revision
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|bases_stream
argument_list|,
name|base
operator|->
name|item_index
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|bases_stream
argument_list|,
name|base
operator|->
name|priority
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|bases_stream
argument_list|,
name|base
operator|->
name|rep
argument_list|)
expr_stmt|;
block|}
comment|/* serialize reps */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|builder
operator|->
name|reps
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|rep_t
modifier|*
name|rep
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|builder
operator|->
name|reps
argument_list|,
name|i
argument_list|,
name|rep_t
argument_list|)
decl_stmt|;
name|svn_packed__add_uint
argument_list|(
name|reps_stream
argument_list|,
name|rep
operator|->
name|first_instruction
argument_list|)
expr_stmt|;
block|}
name|svn_packed__add_uint
argument_list|(
name|reps_stream
argument_list|,
name|builder
operator|->
name|instructions
operator|->
name|nelts
argument_list|)
expr_stmt|;
comment|/* serialize instructions */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|builder
operator|->
name|instructions
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|instruction_t
modifier|*
name|instruction
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|builder
operator|->
name|instructions
argument_list|,
name|i
argument_list|,
name|instruction_t
argument_list|)
decl_stmt|;
name|svn_packed__add_int
argument_list|(
name|instructions_stream
argument_list|,
name|instruction
operator|->
name|offset
argument_list|)
expr_stmt|;
name|svn_packed__add_uint
argument_list|(
name|instructions_stream
argument_list|,
name|instruction
operator|->
name|count
argument_list|)
expr_stmt|;
block|}
comment|/* other elements */
name|svn_packed__add_uint
argument_list|(
name|misc_stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* write to stream */
name|SVN_ERR
argument_list|(
name|svn_packed__data_write
argument_list|(
name|stream
argument_list|,
name|root
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__read_reps_container
parameter_list|(
name|svn_fs_x__reps_t
modifier|*
modifier|*
name|container
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_size_t
name|i
decl_stmt|;
name|base_t
modifier|*
name|bases
decl_stmt|;
name|apr_uint32_t
modifier|*
name|first_instructions
decl_stmt|;
name|instruction_t
modifier|*
name|instructions
decl_stmt|;
name|svn_fs_x__reps_t
modifier|*
name|reps
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reps
argument_list|)
argument_list|)
decl_stmt|;
name|svn_packed__data_root_t
modifier|*
name|root
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|bases_stream
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|reps_stream
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|instructions_stream
decl_stmt|;
name|svn_packed__int_stream_t
modifier|*
name|misc_stream
decl_stmt|;
name|svn_packed__byte_stream_t
modifier|*
name|text_stream
decl_stmt|;
comment|/* read from disk */
name|SVN_ERR
argument_list|(
name|svn_packed__data_read
argument_list|(
operator|&
name|root
argument_list|,
name|stream
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|bases_stream
operator|=
name|svn_packed__first_int_stream
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|reps_stream
operator|=
name|svn_packed__next_int_stream
argument_list|(
name|bases_stream
argument_list|)
expr_stmt|;
name|instructions_stream
operator|=
name|svn_packed__next_int_stream
argument_list|(
name|reps_stream
argument_list|)
expr_stmt|;
name|misc_stream
operator|=
name|svn_packed__next_int_stream
argument_list|(
name|instructions_stream
argument_list|)
expr_stmt|;
name|text_stream
operator|=
name|svn_packed__first_byte_stream
argument_list|(
name|root
argument_list|)
expr_stmt|;
comment|/* text */
name|reps
operator|->
name|text
operator|=
name|svn_packed__get_bytes
argument_list|(
name|text_stream
argument_list|,
operator|&
name|reps
operator|->
name|text_len
argument_list|)
expr_stmt|;
name|reps
operator|->
name|text
operator|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|reps
operator|->
name|text
argument_list|,
name|reps
operator|->
name|text_len
argument_list|)
expr_stmt|;
comment|/* de-serialize  bases */
name|reps
operator|->
name|base_count
operator|=
name|svn_packed__int_count
argument_list|(
name|svn_packed__first_int_substream
argument_list|(
name|bases_stream
argument_list|)
argument_list|)
expr_stmt|;
name|bases
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|reps
operator|->
name|base_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|bases
argument_list|)
argument_list|)
expr_stmt|;
name|reps
operator|->
name|bases
operator|=
name|bases
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps
operator|->
name|base_count
condition|;
operator|++
name|i
control|)
block|{
name|base_t
modifier|*
name|base
init|=
name|bases
operator|+
name|i
decl_stmt|;
name|base
operator|->
name|revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|svn_packed__get_int
argument_list|(
name|bases_stream
argument_list|)
expr_stmt|;
name|base
operator|->
name|item_index
operator|=
name|svn_packed__get_uint
argument_list|(
name|bases_stream
argument_list|)
expr_stmt|;
name|base
operator|->
name|priority
operator|=
operator|(
name|int
operator|)
name|svn_packed__get_uint
argument_list|(
name|bases_stream
argument_list|)
expr_stmt|;
name|base
operator|->
name|rep
operator|=
operator|(
name|apr_uint32_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|bases_stream
argument_list|)
expr_stmt|;
block|}
comment|/* de-serialize instructions */
name|reps
operator|->
name|instruction_count
operator|=
name|svn_packed__int_count
argument_list|(
name|svn_packed__first_int_substream
argument_list|(
name|instructions_stream
argument_list|)
argument_list|)
expr_stmt|;
name|instructions
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
name|reps
operator|->
name|instruction_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|instructions
argument_list|)
argument_list|)
expr_stmt|;
name|reps
operator|->
name|instructions
operator|=
name|instructions
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps
operator|->
name|instruction_count
condition|;
operator|++
name|i
control|)
block|{
name|instruction_t
modifier|*
name|instruction
init|=
name|instructions
operator|+
name|i
decl_stmt|;
name|instruction
operator|->
name|offset
operator|=
operator|(
name|apr_int32_t
operator|)
name|svn_packed__get_int
argument_list|(
name|instructions_stream
argument_list|)
expr_stmt|;
name|instruction
operator|->
name|count
operator|=
operator|(
name|apr_uint32_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|instructions_stream
argument_list|)
expr_stmt|;
block|}
comment|/* de-serialize reps */
name|reps
operator|->
name|rep_count
operator|=
name|svn_packed__int_count
argument_list|(
name|reps_stream
argument_list|)
expr_stmt|;
name|first_instructions
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
operator|(
name|reps
operator|->
name|rep_count
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|first_instructions
argument_list|)
argument_list|)
expr_stmt|;
name|reps
operator|->
name|first_instructions
operator|=
name|first_instructions
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|reps
operator|->
name|rep_count
condition|;
operator|++
name|i
control|)
name|first_instructions
index|[
name|i
index|]
operator|=
operator|(
name|apr_uint32_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|reps_stream
argument_list|)
expr_stmt|;
name|first_instructions
index|[
name|reps
operator|->
name|rep_count
index|]
operator|=
operator|(
name|apr_uint32_t
operator|)
name|reps
operator|->
name|instruction_count
expr_stmt|;
comment|/* other elements */
name|reps
operator|->
name|base_text_len
operator|=
operator|(
name|apr_size_t
operator|)
name|svn_packed__get_uint
argument_list|(
name|misc_stream
argument_list|)
expr_stmt|;
comment|/* return result */
operator|*
name|container
operator|=
name|reps
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__serialize_reps_container
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__reps_t
modifier|*
name|reps
init|=
name|in
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
comment|/* make a guesstimate on the size of the serialized data.  Erring on the    * low side will cause the serializer to re-alloc its buffer. */
name|apr_size_t
name|size
init|=
name|reps
operator|->
name|text_len
operator|+
name|reps
operator|->
name|base_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reps
operator|->
name|bases
argument_list|)
operator|+
name|reps
operator|->
name|rep_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reps
operator|->
name|first_instructions
argument_list|)
operator|+
name|reps
operator|->
name|instruction_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reps
operator|->
name|instructions
argument_list|)
operator|+
literal|100
decl_stmt|;
comment|/* serialize array header and all its elements */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|svn_temp_serializer__init
argument_list|(
name|reps
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reps
argument_list|)
argument_list|,
name|size
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* serialize sub-structures */
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|text
argument_list|,
name|reps
operator|->
name|text_len
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|bases
argument_list|,
name|reps
operator|->
name|base_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reps
operator|->
name|bases
argument_list|)
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|first_instructions
argument_list|,
name|reps
operator|->
name|rep_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reps
operator|->
name|first_instructions
argument_list|)
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_leaf
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|instructions
argument_list|,
name|reps
operator|->
name|instruction_count
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|reps
operator|->
name|instructions
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return the serialized result */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__deserialize_reps_container
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__reps_t
modifier|*
name|reps
init|=
operator|(
name|svn_fs_x__reps_t
operator|*
operator|)
name|data
decl_stmt|;
comment|/* de-serialize sub-structures */
name|svn_temp_deserializer__resolve
argument_list|(
name|reps
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|text
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|reps
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|bases
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|reps
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|first_instructions
argument_list|)
expr_stmt|;
name|svn_temp_deserializer__resolve
argument_list|(
name|reps
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|reps
operator|->
name|instructions
argument_list|)
expr_stmt|;
comment|/* done */
operator|*
name|out
operator|=
name|reps
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__reps_get_func
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_x__reps_baton_t
modifier|*
name|reps_baton
init|=
name|baton
decl_stmt|;
comment|/* get a usable reps structure  */
specifier|const
name|svn_fs_x__reps_t
modifier|*
name|cached
init|=
name|data
decl_stmt|;
name|svn_fs_x__reps_t
modifier|*
name|reps
init|=
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
name|cached
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|reps
argument_list|)
argument_list|)
decl_stmt|;
name|reps
operator|->
name|text
operator|=
name|svn_temp_deserializer__ptr
argument_list|(
name|cached
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|cached
operator|->
name|text
argument_list|)
expr_stmt|;
name|reps
operator|->
name|bases
operator|=
name|svn_temp_deserializer__ptr
argument_list|(
name|cached
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|cached
operator|->
name|bases
argument_list|)
expr_stmt|;
name|reps
operator|->
name|first_instructions
operator|=
name|svn_temp_deserializer__ptr
argument_list|(
name|cached
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|cached
operator|->
name|first_instructions
argument_list|)
expr_stmt|;
name|reps
operator|->
name|instructions
operator|=
name|svn_temp_deserializer__ptr
argument_list|(
name|cached
argument_list|,
operator|(
specifier|const
name|void
operator|*
operator|*
operator|)
operator|&
name|cached
operator|->
name|instructions
argument_list|)
expr_stmt|;
comment|/* return an extractor for the selected item */
name|SVN_ERR
argument_list|(
name|svn_fs_x__reps_get
argument_list|(
operator|(
name|svn_fs_x__rep_extractor_t
operator|*
operator|*
operator|)
name|out
argument_list|,
name|reps_baton
operator|->
name|fs
argument_list|,
name|reps
argument_list|,
name|reps_baton
operator|->
name|idx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

