begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* revprops.c --- everything needed to handle revprops in FSX  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"fs_x.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* Give writing processes 10 seconds to replace an existing revprop    file with a new one. After that time, we assume that the writing    process got aborted and that we have re-read revprops. */
end_comment

begin_define
define|#
directive|define
name|REVPROP_CHANGE_TIMEOUT
value|(10 * 1000000)
end_define

begin_comment
comment|/* In case of an inconsistent read, close the generation file, yield,    re-open and re-read.  This is the number of times we try this before    giving up. */
end_comment

begin_define
define|#
directive|define
name|GENERATION_READ_RETRY_COUNT
value|100
end_define

begin_comment
comment|/* Maximum size of the generation number file contents (including NUL). */
end_comment

begin_define
define|#
directive|define
name|CHECKSUMMED_NUMBER_BUFFER_LEN
define|\
value|(SVN_INT64_BUFFER_SIZE + 3 + APR_MD5_DIGESTSIZE * 2)
end_define

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__upgrade_pack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_upgrade_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_pack_file_dir
decl_stmt|;
name|apr_int64_t
name|shard
decl_stmt|;
name|apr_int64_t
name|first_unpacked_shard
init|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revsprops_dir
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|compression_level
init|=
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
else|:
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
decl_stmt|;
comment|/* first, pack all revprops shards to match the packed revision shards */
for|for
control|(
name|shard
operator|=
literal|0
init|;
name|shard
operator|<
name|first_unpacked_shard
condition|;
operator|++
name|shard
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|revprops_pack_file_dir
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
argument|iterpool
argument_list|,
literal|"%"
argument|APR_INT64_T_FMT PATH_EXT_PACKED_SHARD
argument_list|,
argument|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__pack_revprops_shard
argument_list|(
name|revprops_pack_file_dir
argument_list|,
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
call|(
name|int
call|)
argument_list|(
literal|0.9
operator|*
name|ffd
operator|->
name|revprop_pack_size
argument_list|)
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_upgrade_pack_revprops
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__upgrade_cleanup_pack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_upgrade_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|revprops_shard_path
decl_stmt|;
name|apr_int64_t
name|shard
decl_stmt|;
name|apr_int64_t
name|first_unpacked_shard
init|=
name|ffd
operator|->
name|min_unpacked_rev
operator|/
name|ffd
operator|->
name|max_files_per_dir
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|revsprops_dir
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_REVPROPS_DIR
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* delete the non-packed revprops shards afterwards */
for|for
control|(
name|shard
operator|=
literal|0
init|;
name|shard
operator|<
name|first_unpacked_shard
condition|;
operator|++
name|shard
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|revprops_shard_path
operator|=
name|svn_dirent_join
argument_list|(
name|revsprops_dir
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|shard
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__delete_revprops_shard
argument_list|(
name|revprops_shard_path
argument_list|,
name|shard
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|notify_func
condition|)
name|SVN_ERR
argument_list|(
name|notify_func
argument_list|(
name|notify_baton
argument_list|,
name|shard
argument_list|,
name|svn_fs_upgrade_cleanup_revprops
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Revprop caching management.  *  * Mechanism:  * ----------  *  * Revprop caching needs to be activated and will be deactivated for the  * respective FS instance if the necessary infrastructure could not be  * initialized.  As long as no revprops are being read or changed, revprop  * caching imposes no overhead.  *  * When activated, we cache revprops using (revision, generation) pairs  * as keys with the generation being incremented upon every revprop change.  * Since the cache is process-local, the generation needs to be tracked  * for at least as long as the process lives but may be reset afterwards.  *  * We track the revprop generation in a persistent, unbuffered file that  * we may keep open for the lifetime of the svn_fs_t.  It is the OS'  * responsibility to provide us with the latest contents upon read.  To  * detect incomplete updates due to non-atomic reads, we put a MD5 checksum  * next to the actual generation number and verify that it matches.  *  * Since we cannot guarantee that the OS will provide us with up-to-date  * data buffers for open files, we re-open and re-read the file before  * modifying it.  This will prevent lost updates.  *  * A race condition exists between switching to the modified revprop data  * and bumping the generation number.  In particular, the process may crash  * just after switching to the new revprop data and before bumping the  * generation.  To be able to detect this scenario, we bump the generation  * twice per revprop change: once immediately before (creating an odd number)  * and once after the atomic switch (even generation).  *  * A writer holding the write lock can immediately assume a crashed writer  * in case of an odd generation or they would not have been able to acquire  * the lock.  A reader detecting an odd generation will use that number and  * be forced to re-read any revprop data - usually getting the new revprops  * already.  If the generation file modification timestamp is too old, the  * reader will assume a crashed writer, acquire the write lock and bump  * the generation if it is still odd.  So, for about REVPROP_CHANGE_TIMEOUT  * after the crash, reader caches may be stale.  */
end_comment

begin_comment
comment|/* If the revprop generation file in FS is open, close it.  This is a no-op  * if the file is not open.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_revprop_generation_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|ffd
operator|->
name|revprop_generation_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|ffd
operator|->
name|revprop_generation_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|revprop_generation_file
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make sure the revprop_generation member in FS is set.  If READ_ONLY is  * set, open the file w/o write permission if the file is not open yet.  * The file is kept open if it has sufficient rights (or more) but will be  * closed and re-opened if it provided insufficient access rights.  *  * Call only for repos that support revprop caching.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_revprop_generation_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|read_only
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_int32_t
name|flags
init|=
name|read_only
condition|?
name|APR_READ
else|:
operator|(
name|APR_READ
operator||
name|APR_WRITE
operator|)
decl_stmt|;
comment|/* Close the current file handle if it has insufficient rights. */
if|if
condition|(
name|ffd
operator|->
name|revprop_generation_file
operator|&&
operator|(
name|apr_file_flags_get
argument_list|(
name|ffd
operator|->
name|revprop_generation_file
argument_list|)
operator|&
name|flags
operator|)
operator|!=
name|flags
condition|)
name|SVN_ERR
argument_list|(
name|close_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If not open already, open with sufficient rights. */
if|if
condition|(
name|ffd
operator|->
name|revprop_generation_file
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_fs_x__path_revprop_generation
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|ffd
operator|->
name|revprop_generation_file
argument_list|,
name|path
argument_list|,
name|flags
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the textual representation of NUMBER and its checksum in *BUFFER.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|checkedsummed_number
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|buffer
parameter_list|,
name|apr_int64_t
name|number
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
specifier|const
name|char
modifier|*
name|digest
decl_stmt|;
name|char
name|str
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|len
init|=
name|svn__i64toa
argument_list|(
name|str
argument_list|,
name|number
argument_list|)
decl_stmt|;
name|str
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|str
argument_list|,
name|len
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|digest
operator|=
name|svn_checksum_to_cstring_display
argument_list|(
name|checksum
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
operator|*
name|buffer
operator|=
name|svn_stringbuf_createf
argument_list|(
name|result_pool
argument_list|,
literal|"%s %s\n"
argument_list|,
name|digest
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Extract the generation number from the text BUFFER of LEN bytes and  * verify it against the checksum in the same BUFFER.  If they match, return  * the generation in *NUMBER.  Otherwise, return an error.  * BUFFER does not need to be NUL-terminated.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_extract_number
parameter_list|(
name|apr_int64_t
modifier|*
name|number
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|digest_end
init|=
name|strchr
argument_list|(
name|buffer
argument_list|,
literal|' '
argument_list|)
decl_stmt|;
comment|/* Does the buffer even contain checksum _and_ number? */
if|if
condition|(
name|digest_end
operator|!=
name|NULL
condition|)
block|{
name|svn_checksum_t
modifier|*
name|expected
decl_stmt|;
name|svn_checksum_t
modifier|*
name|actual
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|expected
argument_list|,
name|svn_checksum_md5
argument_list|,
name|buffer
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum
argument_list|(
operator|&
name|actual
argument_list|,
name|svn_checksum_md5
argument_list|,
name|digest_end
operator|+
literal|1
argument_list|,
operator|(
name|buffer
operator|+
name|len
operator|)
operator|-
operator|(
name|digest_end
operator|+
literal|1
operator|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_checksum_match
argument_list|(
name|expected
argument_list|,
name|actual
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_cstring_atoi64
argument_list|(
name|number
argument_list|,
name|digest_end
operator|+
literal|1
argument_list|)
argument_list|)
return|;
block|}
comment|/* Incomplete buffer or not a match. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_INVALID_GENERATION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid generation number data."
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read revprop generation as stored on disk for repository FS. The result is  * returned in *CURRENT.  Call only for repos that support revprop caching.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_revprop_generation_file
parameter_list|(
name|apr_int64_t
modifier|*
name|current
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|char
name|buf
index|[
name|CHECKSUMMED_NUMBER_BUFFER_LEN
index|]
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* Retry in case of incomplete file buffer updates. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GENERATION_READ_RETRY_COUNT
condition|;
operator|++
name|i
control|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If we can't even access the data, things are very wrong.        * Don't retry in that case.        */
name|SVN_ERR
argument_list|(
name|open_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|ffd
operator|->
name|revprop_generation_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|ffd
operator|->
name|revprop_generation_file
argument_list|,
name|buf
argument_list|,
operator|&
name|len
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some data has been read.  It will most likely be complete and        * consistent.  Extract and verify anyway. */
name|err
operator|=
name|verify_extract_number
argument_list|(
name|current
argument_list|,
name|buf
argument_list|,
name|len
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
break|break;
comment|/* Got unlucky and data was invalid.  Retry. */
name|SVN_ERR
argument_list|(
name|close_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|apr_thread_yield
argument_list|()
expr_stmt|;
else|#
directive|else
name|apr_sleep
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* If we had to give up, propagate the error. */
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write the CURRENT revprop generation to disk for repository FS.  * Call only for repos that support revprop caching.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revprop_generation_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_int64_t
name|current
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|;
name|apr_off_t
name|offset
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|checkedsummed_number
argument_list|(
operator|&
name|buffer
argument_list|,
name|current
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_seek
argument_list|(
name|ffd
operator|->
name|revprop_generation_file
argument_list|,
name|APR_SET
argument_list|,
operator|&
name|offset
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|ffd
operator|->
name|revprop_generation_file
argument_list|,
name|buffer
operator|->
name|data
argument_list|,
name|buffer
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_flush_to_disk
argument_list|(
name|ffd
operator|->
name|revprop_generation_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__reset_revprop_generation_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_fs_x__path_revprop_generation
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|;
comment|/* Unconditionally close the revprop generation file.    * Don't care about FS formats. This ensures consistent internal state. */
name|SVN_ERR
argument_list|(
name|close_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Unconditionally remove any old revprop generation file.    * Don't care about FS formats.  This ensures consistent on-disk state    * for old format repositories. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the initial revprop generation file contents, if supported by    * the current format.  This ensures consistent on-disk state for new    * format repositories. */
name|SVN_ERR
argument_list|(
name|checkedsummed_number
argument_list|(
operator|&
name|buffer
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_write_atomic
argument_list|(
name|path
argument_list|,
name|buffer
operator|->
name|data
argument_list|,
name|buffer
operator|->
name|len
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ffd->revprop_generation_file will be re-opened on demand. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Create an error object with the given MESSAGE and pass it to the    WARNING member of FS. Clears UNDERLYING_ERR. */
end_comment

begin_function
specifier|static
name|void
name|log_revprop_cache_init_warning
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
name|underlying_err
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_REVPROP_CACHE_INIT_FAILURE
argument_list|,
name|underlying_err
argument_list|,
name|message
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|warning
condition|)
call|(
name|fs
operator|->
name|warning
call|)
argument_list|(
name|fs
operator|->
name|warning_baton
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Test whether revprop cache and necessary infrastructure are    available in FS. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|has_revprop_cache
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_error_t
modifier|*
name|error
decl_stmt|;
comment|/* is the cache (still) enabled? */
if|if
condition|(
name|ffd
operator|->
name|revprop_cache
operator|==
name|NULL
condition|)
return|return
name|FALSE
return|;
comment|/* try initialize our file-backed infrastructure */
name|error
operator|=
name|open_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* failure -> disable revprop cache for good */
name|ffd
operator|->
name|revprop_cache
operator|=
name|NULL
expr_stmt|;
name|log_revprop_cache_init_warning
argument_list|(
name|fs
argument_list|,
name|error
argument_list|,
literal|"Revprop caching for '%s' disabled "
literal|"because infrastructure for revprop "
literal|"caching failed to initialize."
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* Baton structure for revprop_generation_fixup. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|revprop_generation_fixup_t
block|{
comment|/* revprop generation to read */
name|apr_int64_t
modifier|*
name|generation
decl_stmt|;
comment|/* file system context */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
block|}
name|revprop_generation_upgrade_t
typedef|;
end_typedef

begin_comment
comment|/* If the revprop generation has an odd value, it means the original writer    of the revprop got killed. We don't know whether that process as able    to change the revprop data but we assume that it was. Therefore, we    increase the generation in that case to basically invalidate everyone's    cache content.    Execute this only while holding the write lock to the repo in baton->FFD.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|revprop_generation_fixup
parameter_list|(
name|void
modifier|*
name|void_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|revprop_generation_upgrade_t
modifier|*
name|baton
init|=
name|void_baton
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|baton
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|assert
argument_list|(
name|ffd
operator|->
name|has_write_lock
argument_list|)
expr_stmt|;
comment|/* Make sure we don't operate on stale OS buffers. */
name|SVN_ERR
argument_list|(
name|close_revprop_generation_file
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Maybe, either the original revprop writer or some other reader has      already corrected / bumped the revprop generation.  Thus, we need      to read it again.  However, we will now be the only ones changing      the file contents due to us holding the write lock. */
name|SVN_ERR
argument_list|(
name|read_revprop_generation_file
argument_list|(
name|baton
operator|->
name|generation
argument_list|,
name|baton
operator|->
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Cause everyone to re-read revprops upon their next access, if the      last revprop write did not complete properly. */
if|if
condition|(
operator|*
name|baton
operator|->
name|generation
operator|%
literal|2
condition|)
block|{
operator|++
operator|*
name|baton
operator|->
name|generation
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_revprop_generation_file
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
operator|*
name|baton
operator|->
name|generation
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the current revprop generation and return it in *GENERATION.    Also, detect aborted / crashed writers and recover from that.    Use the access object in FS to set the shared mem values. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_revprop_generation
parameter_list|(
name|apr_int64_t
modifier|*
name|generation
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_int64_t
name|current
init|=
literal|0
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* read the current revprop generation number */
name|SVN_ERR
argument_list|(
name|read_revprop_generation_file
argument_list|(
operator|&
name|current
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* is an unfinished revprop write under the way? */
if|if
condition|(
name|current
operator|%
literal|2
condition|)
block|{
name|svn_boolean_t
name|timeout
init|=
name|FALSE
decl_stmt|;
comment|/* Has the writer process been aborted?        * Either by timeout or by us being the writer now.        */
if|if
condition|(
operator|!
name|ffd
operator|->
name|has_write_lock
condition|)
block|{
name|apr_time_t
name|mtime
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_affected_time
argument_list|(
operator|&
name|mtime
argument_list|,
name|svn_fs_x__path_revprop_generation
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|timeout
operator|=
name|apr_time_now
argument_list|()
operator|>
name|mtime
operator|+
name|REVPROP_CHANGE_TIMEOUT
expr_stmt|;
block|}
if|if
condition|(
name|ffd
operator|->
name|has_write_lock
operator|||
name|timeout
condition|)
block|{
name|revprop_generation_upgrade_t
name|baton
decl_stmt|;
name|baton
operator|.
name|generation
operator|=
operator|&
name|current
expr_stmt|;
name|baton
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
comment|/* Ensure that the original writer process no longer exists by            * acquiring the write lock to this repository.  Then, fix up            * the revprop generation.            */
if|if
condition|(
name|ffd
operator|->
name|has_write_lock
condition|)
name|SVN_ERR
argument_list|(
name|revprop_generation_fixup
argument_list|(
operator|&
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_x__with_write_lock
argument_list|(
name|fs
argument_list|,
name|revprop_generation_fixup
argument_list|,
operator|&
name|baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* return the value we just got */
operator|*
name|generation
operator|=
name|current
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the revprop generation in FS to the next odd number to indicate    that there is a revprop write process under way.  Return that value    in *GENERATION.  If the change times out, readers shall recover from    that state& re-read revprops.    This is a no-op for repo formats that don't support revprop caching. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|begin_revprop_change
parameter_list|(
name|apr_int64_t
modifier|*
name|generation
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ffd
operator|->
name|has_write_lock
argument_list|)
expr_stmt|;
comment|/* Close and re-open to make sure we read the latest data. */
name|SVN_ERR
argument_list|(
name|close_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the revprop generation to an odd value to indicate    * that a write is in progress.    */
name|SVN_ERR
argument_list|(
name|read_revprop_generation
argument_list|(
name|generation
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|++
operator|*
name|generation
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_revprop_generation_file
argument_list|(
name|fs
argument_list|,
operator|*
name|generation
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the revprop generation in FS to the next even generation after    the odd value in GENERATION to indicate that    a) readers shall re-read revprops, and    b) the write process has been completed (no recovery required).    This is a no-op for repo formats that don't support revprop caching. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|end_revprop_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|ffd
operator|->
name|has_write_lock
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|generation
operator|%
literal|2
argument_list|)
expr_stmt|;
comment|/* Set the revprop generation to an even value to indicate    * that a write has been completed.  Since we held the write    * lock, nobody else could have updated the file contents.    */
name|SVN_ERR
argument_list|(
name|write_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|generation
operator|+
literal|1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Container for all data required to access the packed revprop file  * for a given REVISION.  This structure will be filled incrementally  * by read_pack_revprops() its sub-routines.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|packed_revprops_t
block|{
comment|/* revision number to read (not necessarily the first in the pack) */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* current revprop generation. Used when populating the revprop cache */
name|apr_int64_t
name|generation
decl_stmt|;
comment|/* the actual revision properties */
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
comment|/* their size when serialized to a single string    * (as found in PACKED_REVPROPS) */
name|apr_size_t
name|serialized_size
decl_stmt|;
comment|/* name of the pack file (without folder path) */
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* packed shard folder path */
specifier|const
name|char
modifier|*
name|folder
decl_stmt|;
comment|/* sum of values in SIZES */
name|apr_size_t
name|total_size
decl_stmt|;
comment|/* first revision in the pack (>= MANIFEST_START) */
name|svn_revnum_t
name|start_revision
decl_stmt|;
comment|/* size of the revprops in PACKED_REVPROPS */
name|apr_array_header_t
modifier|*
name|sizes
decl_stmt|;
comment|/* offset of the revprops in PACKED_REVPROPS */
name|apr_array_header_t
modifier|*
name|offsets
decl_stmt|;
comment|/* concatenation of the serialized representation of all revprops    * in the pack, i.e. the pack content without header and compression */
name|svn_stringbuf_t
modifier|*
name|packed_revprops
decl_stmt|;
comment|/* First revision covered by MANIFEST.    * Will equal the shard start revision or 1, for the 1st shard. */
name|svn_revnum_t
name|manifest_start
decl_stmt|;
comment|/* content of the manifest.    * Maps long(rev - MANIFEST_START) to const char* pack file name */
name|apr_array_header_t
modifier|*
name|manifest
decl_stmt|;
block|}
name|packed_revprops_t
typedef|;
end_typedef

begin_comment
comment|/* Parse the serialized revprops in CONTENT and return them in *PROPERTIES.  * Also, put them into the revprop cache, if activated, for future use.  * Three more parameters are being used to update the revprop cache: FS is  * our file system, the revprops belong to REVISION and the global revprop  * GENERATION is used as well.  *  * The returned hash will be allocated in RESULT_POOL, SCRATCH_POOL is  * being used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_revprop
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|properties
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|svn_string_t
modifier|*
name|content
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
init|=
name|svn_stream_from_string
argument_list|(
name|content
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
operator|*
name|properties
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_read2
argument_list|(
operator|*
name|properties
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
condition|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|key
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|generation
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__set
argument_list|(
name|ffd
operator|->
name|revprop_cache
argument_list|,
operator|&
name|key
argument_list|,
operator|*
name|properties
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the non-packed revprops for revision REV in FS, put them into the  * revprop cache if activated and return them in *PROPERTIES.  GENERATION  * is the current revprop generation.  *  * If the data could not be read due to an otherwise recoverable error,  * leave *PROPERTIES unchanged. No error will be returned in that case.  *  * Allocate *PROPERTIES in RESULT_POOL and temporaries in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_non_packed_revprop
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|properties
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|missing
init|=
name|FALSE
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_FS_X__RECOVERABLE_RETRY_COUNT
operator|&&
operator|!
name|missing
operator|&&
operator|!
name|content
condition|;
operator|++
name|i
control|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__try_stringbuf_from_file
argument_list|(
operator|&
name|content
argument_list|,
operator|&
name|missing
argument_list|,
name|svn_fs_x__path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|i
operator|+
literal|1
operator|<
name|SVN_FS_X__RECOVERABLE_RETRY_COUNT
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|content
condition|)
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
name|properties
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|svn_stringbuf__morph_into_string
argument_list|(
name|content
argument_list|)
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the minimum length of any packed revprop file name in REVPROPS. */
end_comment

begin_function
specifier|static
name|apr_size_t
name|get_min_filename_len
parameter_list|(
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|)
block|{
name|char
name|number_buffer
index|[
name|SVN_INT64_BUFFER_SIZE
index|]
decl_stmt|;
comment|/* The revprop filenames have the format<REV>.<COUNT> - with<REV> being    * at least the first rev in the shard and<COUNT> having at least one    * digit.  Thus, the minimum is 2 + #decimal places in the start rev.    */
return|return
name|svn__i64toa
argument_list|(
name|number_buffer
argument_list|,
name|revprops
operator|->
name|manifest_start
argument_list|)
operator|+
literal|2
return|;
block|}
end_function

begin_comment
comment|/* Given FS and REVPROPS->REVISION, fill the FILENAME, FOLDER and MANIFEST  * members. Use RESULT_POOL for allocating results and SCRATCH_POOL for  * temporaries.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_revprop_packname
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|manifest_file_path
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|rev_count
decl_stmt|;
name|char
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|buffer_end
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|filenames
decl_stmt|,
modifier|*
modifier|*
name|filenames_end
decl_stmt|;
name|apr_size_t
name|min_filename_len
decl_stmt|;
comment|/* Determine the dimensions. Rev 0 is excluded from the first shard. */
name|rev_count
operator|=
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
name|revprops
operator|->
name|manifest_start
operator|=
name|revprops
operator|->
name|revision
operator|-
operator|(
name|revprops
operator|->
name|revision
operator|%
name|rev_count
operator|)
expr_stmt|;
if|if
condition|(
name|revprops
operator|->
name|manifest_start
operator|==
literal|0
condition|)
block|{
operator|++
name|revprops
operator|->
name|manifest_start
expr_stmt|;
operator|--
name|rev_count
expr_stmt|;
block|}
name|revprops
operator|->
name|manifest
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|rev_count
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No line in the file can be less than this number of chars long. */
name|min_filename_len
operator|=
name|get_min_filename_len
argument_list|(
name|revprops
argument_list|)
expr_stmt|;
comment|/* Read the content of the manifest file */
name|revprops
operator|->
name|folder
operator|=
name|svn_fs_x__path_revprops_pack_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_content
argument_list|(
operator|&
name|content
argument_list|,
name|manifest_file_path
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There CONTENT must have a certain minimal size and there no    * unterminated lines at the end of the file.  Both guarantees also    * simplify the parser loop below.    */
if|if
condition|(
name|content
operator|->
name|len
operator|<
name|rev_count
operator|*
operator|(
name|min_filename_len
operator|+
literal|1
operator|)
operator|||
name|content
operator|->
name|data
index|[
name|content
operator|->
name|len
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop manifest for r%ld not "
literal|"properly terminated"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|)
return|;
comment|/* Chop (parse) the manifest CONTENT into filenames, one per line.    * We only have to replace all newlines with NUL and add all line    * starts to REVPROPS->MANIFEST.    *    * There must be exactly REV_COUNT lines and that is the number of    * lines we parse from BUFFER to FILENAMES.  Set the end pointer for    * the source BUFFER such that BUFFER+MIN_FILENAME_LEN is still valid    * BUFFER_END is always valid due to CONTENT->LEN> MIN_FILENAME_LEN.    *    * Please note that this loop is performance critical for e.g. 'svn log'.    * It is run 1000x per revprop access, i.e. per revision and about    * 50 million times per sec (and CPU core).    */
for|for
control|(
name|filenames
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|revprops
operator|->
name|manifest
operator|->
name|elts
operator|,
name|filenames_end
operator|=
name|filenames
operator|+
name|rev_count
operator|,
name|buffer
operator|=
name|content
operator|->
name|data
operator|,
name|buffer_end
operator|=
name|buffer
operator|+
name|content
operator|->
name|len
operator|-
name|min_filename_len
init|;
operator|(
name|filenames
operator|<
name|filenames_end
operator|)
operator|&&
operator|(
name|buffer
operator|<
name|buffer_end
operator|)
condition|;
operator|++
name|filenames
control|)
block|{
comment|/* BUFFER always points to the start of the next line / filename. */
operator|*
name|filenames
operator|=
name|buffer
expr_stmt|;
comment|/* Find the next EOL.  This is guaranteed to stay within the CONTENT        * buffer because we left enough room after BUFFER_END and we know        * we will always see a newline as the last non-NUL char. */
name|buffer
operator|+=
name|min_filename_len
expr_stmt|;
while|while
condition|(
operator|*
name|buffer
operator|!=
literal|'\n'
condition|)
operator|++
name|buffer
expr_stmt|;
comment|/* Found EOL.  Turn it into the filename terminator and move BUFFER        * to the start of the next line or CONTENT buffer end. */
operator|*
name|buffer
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|buffer
expr_stmt|;
block|}
comment|/* We must have reached the end of both buffers. */
if|if
condition|(
name|buffer
operator|<
name|content
operator|->
name|data
operator|+
name|content
operator|->
name|len
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop manifest for r%ld "
literal|"has too many entries"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|)
return|;
if|if
condition|(
name|filenames
operator|<
name|filenames_end
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop manifest for r%ld "
literal|"has too few entries"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|)
return|;
comment|/* The target array has now exactly one entry per revision. */
name|revprops
operator|->
name|manifest
operator|->
name|nelts
operator|=
name|rev_count
expr_stmt|;
comment|/* Now get the file name */
name|idx
operator|=
call|(
name|int
call|)
argument_list|(
name|revprops
operator|->
name|revision
operator|-
name|revprops
operator|->
name|manifest_start
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|filename
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|idx
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if revision R1 and R2 refer to the same shard in FS.  */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|same_shard
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|r1
parameter_list|,
name|svn_revnum_t
name|r2
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
return|return
operator|(
name|r1
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
operator|==
operator|(
name|r2
operator|/
name|ffd
operator|->
name|max_files_per_dir
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Given FS and the full packed file content in REVPROPS->PACKED_REVPROPS,  * fill the START_REVISION member, and make PACKED_REVPROPS point to the  * first serialized revprop.  If READ_ALL is set, initialize the SIZES  * and OFFSETS members as well.  *  * Parse the revprops for REVPROPS->REVISION and set the PROPERTIES as  * well as the SERIALIZED_SIZE member.  If revprop caching has been  * enabled, parse all revprops in the pack and cache them.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_packed_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|svn_boolean_t
name|read_all
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|apr_int64_t
name|first_rev
decl_stmt|,
name|count
decl_stmt|,
name|i
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
specifier|const
name|char
modifier|*
name|header_end
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|cache_all
init|=
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* decompress (even if the data is only "stored", there is still a    * length header to remove) */
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|revprops
operator|->
name|packed_revprops
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn__decompress
argument_list|(
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|APR_SIZE_MAX
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read first revision number and number of revisions in the pack */
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_number_from_stream
argument_list|(
operator|&
name|first_rev
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_number_from_stream
argument_list|(
operator|&
name|count
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check revision range for validity. */
if|if
condition|(
operator|!
name|same_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|first_rev
argument_list|)
operator|||
operator|!
name|same_shard
argument_list|(
name|fs
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
name|first_rev
operator|+
name|count
operator|-
literal|1
argument_list|)
operator|||
name|count
operator|<
literal|1
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revprop pack for revision r%ld"
literal|" contains revprops for r%ld .. r%ld"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|first_rev
argument_list|,
call|(
name|svn_revnum_t
call|)
argument_list|(
name|first_rev
operator|+
name|count
operator|-
literal|1
argument_list|)
argument_list|)
return|;
comment|/* Since start& end are in the same shard, it is enough to just test    * the FIRST_REV for being actually packed.  That will also cover the    * special case of rev 0 never being packed. */
if|if
condition|(
operator|!
name|svn_fs_x__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|first_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revprop pack for revision r%ld"
literal|" starts at non-packed revisions r%ld"
argument_list|)
argument_list|,
name|revprops
operator|->
name|revision
argument_list|,
operator|(
name|svn_revnum_t
operator|)
name|first_rev
argument_list|)
return|;
comment|/* make PACKED_REVPROPS point to the first char after the header.    * This is where the serialized revprops are. */
name|header_end
operator|=
name|strstr
argument_list|(
name|uncompressed
operator|->
name|data
argument_list|,
literal|"\n\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|header_end
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Header end not found"
argument_list|)
argument_list|)
return|;
name|offset
operator|=
name|header_end
operator|-
name|uncompressed
operator|->
name|data
operator|+
literal|2
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|=
name|uncompressed
operator|->
name|data
operator|+
name|offset
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|len
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|uncompressed
operator|->
name|len
operator|-
name|offset
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|packed_revprops
operator|->
name|blocksize
operator|=
call|(
name|apr_size_t
call|)
argument_list|(
name|uncompressed
operator|->
name|blocksize
operator|-
name|offset
argument_list|)
expr_stmt|;
comment|/* STREAM still points to the first entry in the sizes list. */
name|revprops
operator|->
name|start_revision
operator|=
operator|(
name|svn_revnum_t
operator|)
name|first_rev
expr_stmt|;
if|if
condition|(
name|read_all
condition|)
block|{
comment|/* Init / construct REVPROPS members. */
name|revprops
operator|->
name|sizes
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|offsets
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
operator|(
name|int
operator|)
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|offset
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now parse, revision by revision, the size and content of each    * revisions' revprops. */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|offset
operator|=
literal|0
operator|,
name|revprops
operator|->
name|total_size
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
operator|++
name|i
control|)
block|{
name|apr_int64_t
name|size
decl_stmt|;
name|svn_string_t
name|serialized
decl_stmt|;
name|svn_revnum_t
name|revision
init|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|first_rev
operator|+
name|i
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* read& check the serialized size */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_number_from_stream
argument_list|(
operator|&
name|size
argument_list|,
name|NULL
argument_list|,
name|stream
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|+
name|offset
operator|>
operator|(
name|apr_int64_t
operator|)
name|revprops
operator|->
name|packed_revprops
operator|->
name|len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed revprop size exceeds pack file size"
argument_list|)
argument_list|)
return|;
comment|/* Parse this revprops list, if necessary */
name|serialized
operator|.
name|data
operator|=
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|+
name|offset
expr_stmt|;
name|serialized
operator|.
name|len
operator|=
operator|(
name|apr_size_t
operator|)
name|size
expr_stmt|;
if|if
condition|(
name|revision
operator|==
name|revprops
operator|->
name|revision
condition|)
block|{
comment|/* Parse (and possibly cache) the one revprop list we care about. */
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
operator|&
name|revprops
operator|->
name|properties
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|revprops
operator|->
name|generation
argument_list|,
operator|&
name|serialized
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|revprops
operator|->
name|serialized_size
operator|=
name|serialized
operator|.
name|len
expr_stmt|;
comment|/* If we only wanted the revprops for REVISION then we are done. */
if|if
condition|(
operator|!
name|read_all
operator|&&
operator|!
name|cache_all
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|cache_all
condition|)
block|{
comment|/* Parse and cache all other revprop lists. */
name|apr_hash_t
modifier|*
name|properties
decl_stmt|;
name|SVN_ERR
argument_list|(
name|parse_revprop
argument_list|(
operator|&
name|properties
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|revprops
operator|->
name|generation
argument_list|,
operator|&
name|serialized
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read_all
condition|)
block|{
comment|/* fill REVPROPS data structures */
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|serialized
operator|.
name|len
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|revprops
operator|->
name|offsets
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|offset
expr_stmt|;
block|}
name|revprops
operator|->
name|total_size
operator|+=
name|serialized
operator|.
name|len
expr_stmt|;
name|offset
operator|+=
name|serialized
operator|.
name|len
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* In filesystem FS, read the packed revprops for revision REV into  * *REVPROPS.  Use GENERATION to populate the revprop cache, if enabled.  * If you want to modify revprop contents / update REVPROPS, READ_ALL  * must be set.  Otherwise, only the properties of REV are being provided.  *  * Allocate *PROPERTIES in RESULT_POOL and temporaries in SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_pack_revprop
parameter_list|(
name|packed_revprops_t
modifier|*
modifier|*
name|revprops
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_int64_t
name|generation
parameter_list|,
name|svn_boolean_t
name|read_all
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_boolean_t
name|missing
init|=
name|FALSE
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|packed_revprops_t
modifier|*
name|result
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* someone insisted that REV is packed. Double-check if necessary */
if|if
condition|(
operator|!
name|svn_fs_x__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_x__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such packed revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* initialize the result data structure */
name|result
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|result
operator|->
name|generation
operator|=
name|generation
expr_stmt|;
comment|/* try to read the packed revprops. This may require retries if we have    * concurrent writers. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SVN_FS_X__RECOVERABLE_RETRY_COUNT
operator|&&
operator|!
name|result
operator|->
name|packed_revprops
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|file_path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* there might have been concurrent writes.        * Re-read the manifest and the pack file.        */
name|SVN_ERR
argument_list|(
name|get_revprop_packname
argument_list|(
name|fs
argument_list|,
name|result
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|file_path
operator|=
name|svn_dirent_join
argument_list|(
name|result
operator|->
name|folder
argument_list|,
name|result
operator|->
name|filename
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__try_stringbuf_from_file
argument_list|(
operator|&
name|result
operator|->
name|packed_revprops
argument_list|,
operator|&
name|missing
argument_list|,
name|file_path
argument_list|,
name|i
operator|+
literal|1
operator|<
name|SVN_FS_X__RECOVERABLE_RETRY_COUNT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we could not find the file, there was a write.        * So, we should refresh our revprop generation info as well such        * that others may find data we will put into the cache.  They would        * consider it outdated, otherwise.        */
if|if
condition|(
name|missing
operator|&&
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|iterpool
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|read_revprop_generation
argument_list|(
operator|&
name|result
operator|->
name|generation
argument_list|,
name|fs
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* the file content should be available now */
if|if
condition|(
operator|!
name|result
operator|->
name|packed_revprops
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PACKED_REVPROP_READ_FAILURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to read revprop pack file for r%ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* parse it. RESULT will be complete afterwards. */
name|err
operator|=
name|parse_packed_revprops
argument_list|(
name|fs
argument_list|,
name|result
argument_list|,
name|read_all
argument_list|,
name|result_pool
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Revprop pack file for r%ld is corrupt"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
operator|*
name|revprops
operator|=
name|result
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the revprops for revision REV in FS and return them in *PROPERTIES_P.  *  * Allocations will be done in POOL.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__get_revision_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_boolean_t
name|bypass_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_int64_t
name|generation
init|=
literal|0
decl_stmt|;
comment|/* not found, yet */
operator|*
name|proplist_p
operator|=
name|NULL
expr_stmt|;
comment|/* should they be available at all? */
name|SVN_ERR
argument_list|(
name|svn_fs_x__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try cache lookup first. */
if|if
condition|(
operator|!
name|bypass_cache
operator|&&
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
condition|)
block|{
name|svn_boolean_t
name|is_cached
decl_stmt|;
name|svn_fs_x__pair_cache_key_t
name|key
init|=
block|{
literal|0
block|}
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_revprop_generation
argument_list|(
operator|&
name|generation
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|.
name|revision
operator|=
name|rev
expr_stmt|;
name|key
operator|.
name|second
operator|=
name|generation
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cache__get
argument_list|(
operator|(
name|void
operator|*
operator|*
operator|)
name|proplist_p
argument_list|,
operator|&
name|is_cached
argument_list|,
name|ffd
operator|->
name|revprop_cache
argument_list|,
operator|&
name|key
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_cached
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* if REV had not been packed when we began, try reading it from the    * non-packed shard.  If that fails, we will fall through to packed    * shard reads. */
if|if
condition|(
operator|!
name|svn_fs_x__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|read_non_packed_revprop
argument_list|(
name|proplist_p
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|NULL
expr_stmt|;
comment|/* in case read_non_packed_revprop changed it */
block|}
block|}
comment|/* if revprop packing is available and we have not read the revprops, yet,    * try reading them from a packed shard.  If that fails, REV is most    * likely invalid (or its revprops highly contested). */
if|if
condition|(
operator|!
operator|*
name|proplist_p
condition|)
block|{
name|packed_revprops_t
modifier|*
name|revprops
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_pack_revprop
argument_list|(
operator|&
name|revprops
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|revprops
operator|->
name|properties
expr_stmt|;
block|}
comment|/* The revprops should have been there. Did we get them? */
if|if
condition|(
operator|!
operator|*
name|proplist_p
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Could not read revprops for revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Serialize the revision property list PROPLIST of revision REV in  * filesystem FS to a non-packed file.  Return the name of that temporary  * file in *TMP_PATH and the file path that it must be moved to in  * *FINAL_PATH.  *  * Allocate *FINAL_PATH and *TMP_PATH in RESULT_POOL.  Use SCRATCH_POOL  * for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_non_packed_revprop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
operator|*
name|final_path
operator|=
name|svn_fs_x__path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* ### do we have a directory sitting around already? we really shouldn't      ### have to get the dirname here. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmp_path
argument_list|,
name|svn_dirent_dirname
argument_list|(
operator|*
name|final_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* After writing the new revprop file(s), call this function to move the  * file at TMP_PATH to FINAL_PATH and give it the permissions from  * PERMS_REFERENCE.  *  * If indicated in BUMP_GENERATION, increase FS' revprop generation.  * Finally, delete all the temporary files given in FILES_TO_DELETE.  * The latter may be NULL.  *  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|switch_to_new_revprop
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
name|tmp_path
parameter_list|,
specifier|const
name|char
modifier|*
name|perms_reference
parameter_list|,
name|apr_array_header_t
modifier|*
name|files_to_delete
parameter_list|,
name|svn_boolean_t
name|bump_generation
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_int64_t
name|generation
decl_stmt|;
comment|/* Now, we may actually be replacing revprops. Make sure that all other      threads and processes will know about this. */
if|if
condition|(
name|bump_generation
condition|)
name|SVN_ERR
argument_list|(
name|begin_revprop_change
argument_list|(
operator|&
name|generation
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__move_into_place
argument_list|(
name|tmp_path
argument_list|,
name|final_path
argument_list|,
name|perms_reference
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Indicate that the update (if relevant) has been completed. */
if|if
condition|(
name|bump_generation
condition|)
name|SVN_ERR
argument_list|(
name|end_revprop_change
argument_list|(
name|fs
argument_list|,
name|generation
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Clean up temporary files, if necessary. */
if|if
condition|(
name|files_to_delete
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|files_to_delete
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|files_to_delete
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write a pack file header to STREAM that starts at revision START_REVISION  * and contains the indexes [START,END) of SIZES.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|serialize_revprops_header
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|apr_array_header_t
modifier|*
name|sizes
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|start
operator|<
name|end
argument_list|)
expr_stmt|;
comment|/* start revision and entry count */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"%ld\n"
argument_list|,
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"%d\n"
argument_list|,
name|end
operator|-
name|start
argument_list|)
argument_list|)
expr_stmt|;
comment|/* the sizes array */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
block|{
comment|/* Non-standard pool usage.        *        * We only allocate a few bytes each iteration -- even with a        * million iterations we would still be in good shape memory-wise.        */
name|apr_off_t
name|size
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sizes
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|iterpool
argument_list|,
literal|"%"
name|APR_OFF_T_FMT
literal|"\n"
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* the double newline char indicates the end of the header */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|iterpool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Writes the a pack file to FILE_STREAM.  It copies the serialized data  * from REVPROPS for the indexes [START,END) except for index CHANGED_INDEX.  *  * The data for the latter is taken from NEW_SERIALIZED.  Note, that  * CHANGED_INDEX may be outside the [START,END) range, i.e. no new data is  * taken in that case but only a subset of the old data will be copied.  *  * NEW_TOTAL_SIZE is a hint for pre-allocating buffers of appropriate size.  * SCRATCH_POOL is used for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repack_revprops
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|int
name|changed_index
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|new_serialized
parameter_list|,
name|apr_off_t
name|new_total_size
parameter_list|,
name|svn_stream_t
modifier|*
name|file_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* create data empty buffers and the stream object */
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
operator|(
name|apr_size_t
operator|)
name|new_total_size
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* write the header*/
name|SVN_ERR
argument_list|(
name|serialize_revprops_header
argument_list|(
name|stream
argument_list|,
name|revprops
operator|->
name|start_revision
operator|+
name|start
argument_list|,
name|revprops
operator|->
name|sizes
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* append the serialized revprops */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|i
operator|==
name|changed_index
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|new_serialized
operator|->
name|data
argument_list|,
operator|&
name|new_serialized
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|apr_size_t
name|size
init|=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|apr_size_t
name|offset
init|=
operator|(
name|apr_size_t
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|offsets
argument_list|,
name|i
argument_list|,
name|apr_off_t
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|revprops
operator|->
name|packed_revprops
operator|->
name|data
operator|+
name|offset
argument_list|,
operator|&
name|size
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush the stream buffer (if any) to our underlying data buffer */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compress / store the data */
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|uncompressed
argument_list|,
name|compressed
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
else|:
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* finally, write the content to the target stream and close it */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|file_stream
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
operator|&
name|compressed
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|file_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new pack file name for revisions  *     [REVPROPS->START_REVISION + START, REVPROPS->START_REVISION + END - 1]  * of REVPROPS->MANIFEST.  Add the name of old file to FILES_TO_DELETE,  * auto-create that array if necessary.  Return an open file stream to  * the new file in *STREAM allocated in RESULT_POOL.  Allocate the paths  * in *FILES_TO_DELETE from the same pool that contains the array itself.  *  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|repack_stream_open
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|packed_revprops_t
modifier|*
name|revprops
parameter_list|,
name|int
name|start
parameter_list|,
name|int
name|end
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|files_to_delete
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_int64_t
name|tag
decl_stmt|;
specifier|const
name|char
modifier|*
name|tag_string
decl_stmt|;
name|svn_string_t
modifier|*
name|new_filename
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_file_t
modifier|*
name|file
decl_stmt|;
name|int
name|manifest_offset
init|=
call|(
name|int
call|)
argument_list|(
name|revprops
operator|->
name|start_revision
operator|-
name|revprops
operator|->
name|manifest_start
argument_list|)
decl_stmt|;
comment|/* get the old (= current) file name and enlist it for later deletion */
specifier|const
name|char
modifier|*
name|old_filename
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|start
operator|+
name|manifest_offset
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|files_to_delete
operator|==
name|NULL
condition|)
operator|*
name|files_to_delete
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|files_to_delete
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|old_filename
argument_list|,
operator|(
operator|*
name|files_to_delete
operator|)
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* increase the tag part, i.e. the counter after the dot */
name|tag_string
operator|=
name|strchr
argument_list|(
name|old_filename
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tag_string
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Packed file '%s' misses a tag"
argument_list|)
argument_list|,
name|old_filename
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|tag
argument_list|,
name|tag_string
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|new_filename
operator|=
name|svn_string_createf
argument_list|(
operator|(
operator|*
name|files_to_delete
operator|)
operator|->
name|pool
argument_list|,
literal|"%ld.%"
name|APR_INT64_T_FMT
argument_list|,
name|revprops
operator|->
name|start_revision
operator|+
name|start
argument_list|,
operator|++
name|tag
argument_list|)
expr_stmt|;
comment|/* update the manifest to point to the new file */
for|for
control|(
name|i
operator|=
name|start
init|;
name|i
operator|<
name|end
condition|;
operator|++
name|i
control|)
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|i
operator|+
name|manifest_offset
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|new_filename
operator|->
name|data
expr_stmt|;
comment|/* create a file stream for the new file */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|file
argument_list|,
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|new_filename
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|FALSE
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For revision REV in filesystem FS, set the revision properties to  * PROPLIST.  Return a new file in *TMP_PATH that the caller shall move  * to *FINAL_PATH to make the change visible.  Files to be deleted will  * be listed in *FILES_TO_DELETE which may remain unchanged / unallocated.  *  * Allocate output values in RESULT_POOL and temporaries from SCRATCH_POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_packed_revprop
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|final_path
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_path
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|files_to_delete
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|packed_revprops_t
modifier|*
name|revprops
decl_stmt|;
name|apr_int64_t
name|generation
init|=
literal|0
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
name|apr_off_t
name|new_total_size
decl_stmt|;
name|int
name|changed_index
decl_stmt|;
comment|/* read the current revprop generation. This value will not change    * while we hold the global write lock to this FS. */
if|if
condition|(
name|has_revprop_cache
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|read_revprop_generation
argument_list|(
operator|&
name|generation
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* read contents of the current pack file */
name|SVN_ERR
argument_list|(
name|read_pack_revprop
argument_list|(
operator|&
name|revprops
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|generation
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* serialize the new revprops */
name|serialized
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|serialized
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_hash_write2
argument_list|(
name|proplist
argument_list|,
name|stream
argument_list|,
name|SVN_HASH_TERMINATOR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* calculate the size of the new data */
name|changed_index
operator|=
call|(
name|int
call|)
argument_list|(
name|rev
operator|-
name|revprops
operator|->
name|start_revision
argument_list|)
expr_stmt|;
name|new_total_size
operator|=
name|revprops
operator|->
name|total_size
operator|-
name|revprops
operator|->
name|serialized_size
operator|+
name|serialized
operator|->
name|len
operator|+
operator|(
name|revprops
operator|->
name|offsets
operator|->
name|nelts
operator|+
literal|2
operator|)
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|changed_index
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
comment|/* can we put the new data into the same pack as the before? */
if|if
condition|(
name|new_total_size
operator|<
name|ffd
operator|->
name|revprop_pack_size
operator|||
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|==
literal|1
condition|)
block|{
comment|/* simply replace the old pack file with new content as we do it        * in the non-packed case */
operator|*
name|final_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|revprops
operator|->
name|filename
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmp_path
argument_list|,
name|revprops
operator|->
name|folder
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* split the pack file into two of roughly equal size */
name|int
name|right_count
decl_stmt|,
name|left_count
decl_stmt|,
name|i
decl_stmt|;
name|int
name|left
init|=
literal|0
decl_stmt|;
name|int
name|right
init|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
literal|1
decl_stmt|;
name|apr_off_t
name|left_size
init|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
decl_stmt|;
name|apr_off_t
name|right_size
init|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
decl_stmt|;
comment|/* let left and right side grow such that their size difference        * is minimal after each step. */
while|while
condition|(
name|left
operator|<=
name|right
condition|)
if|if
condition|(
name|left_size
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|left
argument_list|,
name|apr_off_t
argument_list|)
operator|<
name|right_size
operator|+
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|right
argument_list|,
name|apr_off_t
argument_list|)
condition|)
block|{
name|left_size
operator|+=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|left
argument_list|,
name|apr_off_t
argument_list|)
operator|+
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
operator|++
name|left
expr_stmt|;
block|}
else|else
block|{
name|right_size
operator|+=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|sizes
argument_list|,
name|right
argument_list|,
name|apr_off_t
argument_list|)
operator|+
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
operator|--
name|right
expr_stmt|;
block|}
comment|/* since the items need much less than SVN_INT64_BUFFER_SIZE         * bytes to represent their length, the split may not be optimal */
name|left_count
operator|=
name|left
expr_stmt|;
name|right_count
operator|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|left
expr_stmt|;
comment|/* if new_size is large, one side may exceed the pack size limit.        * In that case, split before and after the modified revprop.*/
if|if
condition|(
name|left_size
operator|>
name|ffd
operator|->
name|revprop_pack_size
operator|||
name|right_size
operator|>
name|ffd
operator|->
name|revprop_pack_size
condition|)
block|{
name|left_count
operator|=
name|changed_index
expr_stmt|;
name|right_count
operator|=
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|left_count
operator|-
literal|1
expr_stmt|;
block|}
comment|/* Allocate this here such that we can call the repack functions with        * the scratch pool alone. */
if|if
condition|(
operator|*
name|files_to_delete
operator|==
name|NULL
condition|)
operator|*
name|files_to_delete
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|3
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the new, split files */
if|if
condition|(
name|left_count
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_stream_open
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|left_count
argument_list|,
name|files_to_delete
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
literal|0
argument_list|,
name|left_count
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|left_count
operator|+
name|right_count
operator|<
name|revprops
operator|->
name|sizes
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_stream_open
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
name|changed_index
argument_list|,
name|changed_index
operator|+
literal|1
argument_list|,
name|files_to_delete
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
name|changed_index
argument_list|,
name|changed_index
operator|+
literal|1
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|right_count
condition|)
block|{
name|SVN_ERR
argument_list|(
name|repack_stream_open
argument_list|(
operator|&
name|stream
argument_list|,
name|fs
argument_list|,
name|revprops
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|right_count
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|files_to_delete
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|repack_revprops
argument_list|(
name|fs
argument_list|,
name|revprops
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
operator|-
name|right_count
argument_list|,
name|revprops
operator|->
name|sizes
operator|->
name|nelts
argument_list|,
name|changed_index
argument_list|,
name|serialized
argument_list|,
name|new_total_size
argument_list|,
name|stream
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* write the new manifest */
operator|*
name|final_path
operator|=
name|svn_dirent_join
argument_list|(
name|revprops
operator|->
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmp_path
argument_list|,
name|revprops
operator|->
name|folder
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|manifest
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|filename
init|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
operator|->
name|manifest
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s\n"
argument_list|,
name|filename
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set the revision property list of revision REV in filesystem FS to    PROPLIST.  Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__set_revision_proplist
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_boolean_t
name|is_packed
decl_stmt|;
name|svn_boolean_t
name|bump_generation
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|final_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|perms_reference
decl_stmt|;
name|apr_array_header_t
modifier|*
name|files_to_delete
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__ensure_revision_exists
argument_list|(
name|rev
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this info will not change while we hold the global FS write lock */
name|is_packed
operator|=
name|svn_fs_x__is_packed_revprop
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|)
expr_stmt|;
comment|/* Test whether revprops already exist for this revision.    * Only then will we need to bump the revprop generation.    * The fact that they did not yet exist is never cached. */
if|if
condition|(
name|is_packed
condition|)
block|{
name|bump_generation
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|svn_fs_x__path_revprops
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|bump_generation
operator|=
name|kind
operator|!=
name|svn_node_none
expr_stmt|;
block|}
comment|/* Serialize the new revprop data */
if|if
condition|(
name|is_packed
condition|)
name|SVN_ERR
argument_list|(
name|write_packed_revprop
argument_list|(
operator|&
name|final_path
argument_list|,
operator|&
name|tmp_path
argument_list|,
operator|&
name|files_to_delete
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|proplist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|write_non_packed_revprop
argument_list|(
operator|&
name|final_path
argument_list|,
operator|&
name|tmp_path
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|proplist
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We use the rev file of this revision as the perms reference,    * because when setting revprops for the first time, the revprop    * file won't exist and therefore can't serve as its own reference.    * (Whereas the rev file should already exist at this point.)    */
name|perms_reference
operator|=
name|svn_fs_x__path_rev_absolute
argument_list|(
name|fs
argument_list|,
name|rev
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Now, switch to the new revprop data. */
name|SVN_ERR
argument_list|(
name|switch_to_new_revprop
argument_list|(
name|fs
argument_list|,
name|final_path
argument_list|,
name|tmp_path
argument_list|,
name|perms_reference
argument_list|,
name|files_to_delete
argument_list|,
name|bump_generation
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return TRUE, if for REVISION in FS, we can find the revprop pack file.  * Use SCRATCH_POOL for temporary allocations.  * Set *MISSING, if the reason is a missing manifest or pack file.  */
end_comment

begin_function
name|svn_boolean_t
name|svn_fs_x__packed_revprop_available
parameter_list|(
name|svn_boolean_t
modifier|*
name|missing
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
init|=
name|NULL
decl_stmt|;
comment|/* try to read the manifest file */
specifier|const
name|char
modifier|*
name|folder
init|=
name|svn_fs_x__path_revprops_pack_shard
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|manifest_path
init|=
name|svn_dirent_join
argument_list|(
name|folder
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_x__try_stringbuf_from_file
argument_list|(
operator|&
name|content
argument_list|,
name|missing
argument_list|,
name|manifest_path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* if the manifest cannot be read, consider the pack files inaccessible    * even if the file itself exists. */
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|*
name|missing
condition|)
return|return
name|FALSE
return|;
comment|/* parse manifest content until we find the entry for REVISION.    * Revision 0 is never packed. */
name|revision
operator|=
name|revision
operator|<
name|ffd
operator|->
name|max_files_per_dir
condition|?
name|revision
operator|-
literal|1
else|:
name|revision
operator|%
name|ffd
operator|->
name|max_files_per_dir
expr_stmt|;
while|while
condition|(
name|content
operator|->
name|data
condition|)
block|{
name|char
modifier|*
name|next
init|=
name|strchr
argument_list|(
name|content
operator|->
name|data
argument_list|,
literal|'\n'
argument_list|)
decl_stmt|;
if|if
condition|(
name|next
condition|)
block|{
operator|*
name|next
operator|=
literal|0
expr_stmt|;
operator|++
name|next
expr_stmt|;
block|}
if|if
condition|(
name|revision
operator|--
operator|==
literal|0
condition|)
block|{
comment|/* the respective pack file must exist (and be a file) */
name|svn_node_kind_t
name|kind
decl_stmt|;
name|err
operator|=
name|svn_io_check_path
argument_list|(
name|svn_dirent_join
argument_list|(
name|folder
argument_list|,
name|content
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
operator|&
name|kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
operator|*
name|missing
operator|=
name|kind
operator|==
name|svn_node_none
expr_stmt|;
return|return
name|kind
operator|==
name|svn_node_file
return|;
block|}
name|content
operator|->
name|data
operator|=
name|next
expr_stmt|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/****** Packing FSX shards *********/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__copy_revprops
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|pack_filename
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|apr_array_header_t
modifier|*
name|sizes
parameter_list|,
name|apr_size_t
name|total_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|pack_stream
decl_stmt|;
name|apr_file_t
modifier|*
name|pack_file
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* create empty data buffer and a write stream on top of it */
name|svn_stringbuf_t
modifier|*
name|uncompressed
init|=
name|svn_stringbuf_create_ensure
argument_list|(
name|total_size
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|pack_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|uncompressed
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* write the pack file header */
name|SVN_ERR
argument_list|(
name|serialize_revprops_header
argument_list|(
name|pack_stream
argument_list|,
name|start_rev
argument_list|,
name|sizes
argument_list|,
literal|0
argument_list|,
name|sizes
operator|->
name|nelts
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Some useful paths. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|pack_file
argument_list|,
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Iterate over the revisions in this shard, squashing them together. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Construct the file name. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Copy all the bits from the non-packed revprop file to the end of        * the pack file. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|stream
argument_list|,
name|pack_stream
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* flush stream buffers to content buffer */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|pack_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compress the content (or just store it for COMPRESSION_LEVEL 0) */
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|uncompressed
argument_list|,
name|compressed
argument_list|,
name|compression_level
argument_list|)
argument_list|)
expr_stmt|;
comment|/* write the pack file content to disk */
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|pack_file
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|compressed
operator|->
name|data
argument_list|,
operator|&
name|compressed
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__pack_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|pack_file_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|apr_off_t
name|max_pack_size
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|manifest_file_path
decl_stmt|,
modifier|*
name|pack_filename
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|manifest_stream
decl_stmt|;
name|svn_revnum_t
name|start_rev
decl_stmt|,
name|end_rev
decl_stmt|,
name|rev
decl_stmt|;
name|apr_off_t
name|total_size
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|sizes
decl_stmt|;
comment|/* Some useful paths. */
name|manifest_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|pack_file_dir
argument_list|,
name|PATH_MANIFEST
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Remove any existing pack file for this shard, since it is incomplete. */
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|pack_file_dir
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the new directory and manifest file stream. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_make
argument_list|(
name|pack_file_dir
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_writable
argument_list|(
operator|&
name|manifest_stream
argument_list|,
name|manifest_file_path
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* revisions to handle. Special case: revision 0 */
name|start_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
name|shard
operator|*
name|max_files_per_dir
argument_list|)
expr_stmt|;
name|end_rev
operator|=
call|(
name|svn_revnum_t
call|)
argument_list|(
operator|(
name|shard
operator|+
literal|1
operator|)
operator|*
operator|(
name|max_files_per_dir
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|start_rev
operator|==
literal|0
condition|)
operator|++
name|start_rev
expr_stmt|;
comment|/* Special special case: if max_files_per_dir is 1, then at this point        start_rev == 1 and end_rev == 0 (!).  Fortunately, everything just        works. */
comment|/* initialize the revprop size info */
name|sizes
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|max_files_per_dir
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|)
expr_stmt|;
name|total_size
operator|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
comment|/* Iterate over the revisions in this shard, determine their size and    * squashing them together into pack files. */
for|for
control|(
name|rev
operator|=
name|start_rev
init|;
name|rev
operator|<=
name|end_rev
condition|;
name|rev
operator|++
control|)
block|{
name|apr_finfo_t
name|finfo
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the size of the file. */
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%ld"
argument_list|,
name|rev
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_stat
argument_list|(
operator|&
name|finfo
argument_list|,
name|path
argument_list|,
name|APR_FINFO_SIZE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if we already have started a pack file and this revprop cannot be        * appended to it, write the previous pack file. */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|!=
literal|0
operator|&&
name|total_size
operator|+
name|SVN_INT64_BUFFER_SIZE
operator|+
name|finfo
operator|.
name|size
operator|>
name|max_pack_size
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_x__copy_revprops
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|shard_path
argument_list|,
name|start_rev
argument_list|,
name|rev
operator|-
literal|1
argument_list|,
name|sizes
argument_list|,
operator|(
name|apr_size_t
operator|)
name|total_size
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* next pack file starts empty again */
name|apr_array_clear
argument_list|(
name|sizes
argument_list|)
expr_stmt|;
name|total_size
operator|=
literal|2
operator|*
name|SVN_INT64_BUFFER_SIZE
expr_stmt|;
name|start_rev
operator|=
name|rev
expr_stmt|;
block|}
comment|/* Update the manifest. Allocate a file name for the current pack        * file if it is a new one */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|==
literal|0
condition|)
name|pack_filename
operator|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%ld.0"
argument_list|,
name|rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|manifest_stream
argument_list|,
name|iterpool
argument_list|,
literal|"%s\n"
argument_list|,
name|pack_filename
argument_list|)
argument_list|)
expr_stmt|;
comment|/* add to list of files to put into the current pack file */
name|APR_ARRAY_PUSH
argument_list|(
name|sizes
argument_list|,
name|apr_off_t
argument_list|)
operator|=
name|finfo
operator|.
name|size
expr_stmt|;
name|total_size
operator|+=
name|SVN_INT64_BUFFER_SIZE
operator|+
name|finfo
operator|.
name|size
expr_stmt|;
block|}
comment|/* write the last pack file */
if|if
condition|(
name|sizes
operator|->
name|nelts
operator|!=
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_x__copy_revprops
argument_list|(
name|pack_file_dir
argument_list|,
name|pack_filename
argument_list|,
name|shard_path
argument_list|,
name|start_rev
argument_list|,
name|rev
operator|-
literal|1
argument_list|,
name|sizes
argument_list|,
operator|(
name|apr_size_t
operator|)
name|total_size
argument_list|,
name|compression_level
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flush the manifest file and update permissions */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|manifest_stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_copy_perms
argument_list|(
name|shard_path
argument_list|,
name|pack_file_dir
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__delete_revprops_shard
parameter_list|(
specifier|const
name|char
modifier|*
name|shard_path
parameter_list|,
name|apr_int64_t
name|shard
parameter_list|,
name|int
name|max_files_per_dir
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|shard
operator|==
literal|0
condition|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* delete all files except the one for revision 0 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|max_files_per_dir
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_dirent_join
argument_list|(
name|shard_path
argument_list|,
name|apr_psprintf
argument_list|(
name|iterpool
argument_list|,
literal|"%d"
argument_list|,
name|i
argument_list|)
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|cancel_func
call|)
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|svn_io_remove_dir2
argument_list|(
name|shard_path
argument_list|,
name|TRUE
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

