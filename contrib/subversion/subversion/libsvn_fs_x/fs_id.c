begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs_id.c : FSX's implementation of svn_fs_id_t  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"fs_id.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Structure holding everything needed to implement svn_fs_id_t for FSX.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|fs_x__id_t
block|{
comment|/* API visible part.      The fsap_data member points to our svn_fs_x__id_context_t object. */
name|svn_fs_id_t
name|generic_id
decl_stmt|;
comment|/* Private members.      This addresses the DAG node identified by this ID object.      If it refers to a TXN, it may become . */
name|svn_fs_x__id_t
name|noderev_id
decl_stmt|;
block|}
name|fs_x__id_t
typedef|;
end_typedef

begin_escape
end_escape

begin_comment
comment|/* The state machine behind this is as follows:     (A) FS passed in during context construction still open and uses a        different pool as the context (Usually the initial state).  In that        case, FS_PATH is NULL and we watch for either pool's cleanup.         Next states:        (B). Transition triggered by FS->POOL cleanup.        (D). Transition triggered by OWNER cleanup.     (B) FS has been closed but not the OWNER pool, i.e. the context is valid.        FS is NULL, FS_NAME has been set. No cleanup functions are registered.         Next states:        (C). Transition triggered by successful access to the file system.        (D). Transition triggered by OWNER cleanup.     (C) FS is open, allocated in the context's OWNER pool (maybe the initial        state but that is atypical). No cleanup functions are registered.         Next states:        (D). Transition triggered by OWNER cleanup.     (D) Destroyed.  No access nor notification is allowed.        Final state.   */
end_comment

begin_struct
struct|struct
name|svn_fs_x__id_context_t
block|{
comment|/* If this is NULL, FS_PATH points to the on-disk path to the file system      we need to re-open the FS. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* If FS is NULL, this points to the on-disk path to pass into svn_fs_open2      to reopen the filesystem.  Allocated in OWNER.  May only be NULL if FS      is not.*/
specifier|const
name|char
modifier|*
name|fs_path
decl_stmt|;
comment|/* If FS is NULL, this points to svn_fs_open() as passed to the library. */
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_fs_open_
function_decl|)
parameter_list|(
name|svn_fs_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|apr_hash_t
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
function_decl|;
comment|/* Pool that this context struct got allocated in. */
name|apr_pool_t
modifier|*
name|owner
decl_stmt|;
comment|/* A sub-pool of ONWER.  We use this when querying data from FS.  Gets      cleanup up immediately after usage.  NULL until needed for the first      time. */
name|apr_pool_t
modifier|*
name|aux_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Forward declaration. */
end_comment

begin_function_decl
specifier|static
name|apr_status_t
name|fs_cleanup
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* APR pool cleanup notification for the svn_fs_x__id_context_t given as    BATON.  Sent at state (A)->(D) transition. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|owner_cleanup
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_fs_x__id_context_t
modifier|*
name|context
init|=
name|baton
decl_stmt|;
comment|/* Everything in CONTEXT gets cleaned up automatically.      However, we must prevent notifications from other pools. */
name|apr_pool_cleanup_kill
argument_list|(
name|context
operator|->
name|fs
operator|->
name|pool
argument_list|,
name|context
argument_list|,
name|fs_cleanup
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* APR pool cleanup notification for the svn_fs_x__id_context_t given as    BATON.  Sent at state (A)->(B) transition. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|fs_cleanup
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|svn_fs_x__id_context_t
modifier|*
name|context
init|=
name|baton
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|context
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Remember the FS_PATH to potentially reopen and mark the FS as n/a. */
name|context
operator|->
name|fs_path
operator|=
name|apr_pstrdup
argument_list|(
name|context
operator|->
name|owner
argument_list|,
name|context
operator|->
name|fs
operator|->
name|path
argument_list|)
expr_stmt|;
name|context
operator|->
name|svn_fs_open_
operator|=
name|ffd
operator|->
name|svn_fs_open_
expr_stmt|;
name|context
operator|->
name|fs
operator|=
name|NULL
expr_stmt|;
comment|/* No need for further notifications because from now on, everything is      allocated in OWNER. */
name|apr_pool_cleanup_kill
argument_list|(
name|context
operator|->
name|owner
argument_list|,
name|context
argument_list|,
name|owner_cleanup
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_comment
comment|/* Return the filesystem provided by CONTEXT.  Re-open it if necessary.    Returns NULL if the FS could not be opened. */
end_comment

begin_function
specifier|static
name|svn_fs_t
modifier|*
name|get_fs
parameter_list|(
name|svn_fs_x__id_context_t
modifier|*
name|context
parameter_list|)
block|{
if|if
condition|(
operator|!
name|context
operator|->
name|fs
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|context
operator|->
name|svn_fs_open_
argument_list|)
expr_stmt|;
name|err
operator|=
name|context
operator|->
name|svn_fs_open_
argument_list|(
operator|&
name|context
operator|->
name|fs
argument_list|,
name|context
operator|->
name|fs_path
argument_list|,
name|NULL
argument_list|,
name|context
operator|->
name|owner
argument_list|,
name|context
operator|->
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|context
operator|->
name|fs
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|context
operator|->
name|fs
return|;
block|}
end_function

begin_comment
comment|/* Provide the auto-created auxiliary pool from ID's context object. */
end_comment

begin_function
specifier|static
name|apr_pool_t
modifier|*
name|get_aux_pool
parameter_list|(
specifier|const
name|fs_x__id_t
modifier|*
name|id
parameter_list|)
block|{
name|svn_fs_x__id_context_t
modifier|*
name|context
init|=
name|id
operator|->
name|generic_id
operator|.
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|context
operator|->
name|aux_pool
condition|)
name|context
operator|->
name|aux_pool
operator|=
name|svn_pool_create
argument_list|(
name|context
operator|->
name|owner
argument_list|)
expr_stmt|;
return|return
name|context
operator|->
name|aux_pool
return|;
block|}
end_function

begin_comment
comment|/* Return the noderev structure identified by ID.  Returns NULL for invalid    IDs or inaccessible repositories.  The caller should clear the auxiliary    pool before returning to its respective caller. */
end_comment

begin_function
specifier|static
name|svn_fs_x__noderev_t
modifier|*
name|get_noderev
parameter_list|(
specifier|const
name|fs_x__id_t
modifier|*
name|id
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|result
init|=
name|NULL
decl_stmt|;
name|svn_fs_x__id_context_t
modifier|*
name|context
init|=
name|id
operator|->
name|generic_id
operator|.
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|get_fs
argument_list|(
name|context
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|get_aux_pool
argument_list|(
name|id
argument_list|)
decl_stmt|;
if|if
condition|(
name|fs
condition|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_x__get_node_revision
argument_list|(
operator|&
name|result
argument_list|,
name|fs
argument_list|,
operator|&
name|id
operator|->
name|noderev_id
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|result
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Implement v-table functions ***/
end_comment

begin_comment
comment|/* Implement id_vtable_t.unparse */
end_comment

begin_function
specifier|static
name|svn_string_t
modifier|*
name|id_unparse
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
name|fs_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
specifier|const
name|fs_x__id_t
modifier|*
name|id
init|=
operator|(
specifier|const
name|fs_x__id_t
operator|*
operator|)
name|fs_id
decl_stmt|;
return|return
name|svn_fs_x__id_unparse
argument_list|(
operator|&
name|id
operator|->
name|noderev_id
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implement id_vtable_t.compare.     The result is efficiently computed for matching IDs.  The far less    meaningful "common ancestor" relationship has a larger latency when    evaluated first for a given context object.  Subsequent calls are    moderately fast. */
end_comment

begin_function
specifier|static
name|svn_fs_node_relation_t
name|id_compare
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
name|a
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|fs_x__id_t
modifier|*
name|id_a
init|=
operator|(
specifier|const
name|fs_x__id_t
operator|*
operator|)
name|a
decl_stmt|;
specifier|const
name|fs_x__id_t
modifier|*
name|id_b
init|=
operator|(
specifier|const
name|fs_x__id_t
operator|*
operator|)
name|b
decl_stmt|;
name|svn_fs_x__noderev_t
modifier|*
name|noderev_a
decl_stmt|,
modifier|*
name|noderev_b
decl_stmt|;
name|svn_boolean_t
name|same_node
decl_stmt|;
comment|/* Quick check: same IDs? */
if|if
condition|(
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|id_a
operator|->
name|noderev_id
argument_list|,
operator|&
name|id_b
operator|->
name|noderev_id
argument_list|)
condition|)
return|return
name|svn_fs_node_unchanged
return|;
comment|/* Fetch the nodesrevs, compare the IDs of the nodes they belong to and      clean up any temporaries.  If we can't find one of the noderevs, don't      get access to the FS etc., report the IDs as "unrelated" as only      valid / existing things may be related. */
name|noderev_a
operator|=
name|get_noderev
argument_list|(
name|id_a
argument_list|)
expr_stmt|;
name|noderev_b
operator|=
name|get_noderev
argument_list|(
name|id_b
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev_a
operator|&&
name|noderev_b
condition|)
name|same_node
operator|=
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|noderev_a
operator|->
name|node_id
argument_list|,
operator|&
name|noderev_b
operator|->
name|node_id
argument_list|)
expr_stmt|;
else|else
name|same_node
operator|=
name|FALSE
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|get_aux_pool
argument_list|(
name|id_a
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|get_aux_pool
argument_list|(
name|id_b
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return result. */
return|return
name|same_node
condition|?
name|svn_fs_node_common_ancestor
else|:
name|svn_fs_node_unrelated
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creating ID's.  */
end_comment

begin_decl_stmt
specifier|static
name|id_vtable_t
name|id_vtable
init|=
block|{
name|id_unparse
block|,
name|id_compare
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_fs_x__id_context_t
modifier|*
name|svn_fs_x__id_create_context
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__id_context_t
modifier|*
name|result
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|result
argument_list|)
argument_list|)
decl_stmt|;
name|result
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|result
operator|->
name|owner
operator|=
name|result_pool
expr_stmt|;
comment|/* Check for a special case:      If the owner of the context also owns the FS, there will be no reason      to notify them of the respective other's cleanup. */
if|if
condition|(
name|result_pool
operator|!=
name|fs
operator|->
name|pool
condition|)
block|{
comment|/* If the context's owner gets cleaned up before FS, we must disconnect          from the FS. */
name|apr_pool_cleanup_register
argument_list|(
name|result_pool
argument_list|,
name|result
argument_list|,
name|owner_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* If the FS gets cleaned up before the context's owner, disconnect          from the FS and remember its path on disk to be able to re-open it          later if necessary. */
name|apr_pool_cleanup_register
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|result
argument_list|,
name|fs_cleanup
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_function
name|svn_fs_id_t
modifier|*
name|svn_fs_x__id_create
parameter_list|(
name|svn_fs_x__id_context_t
modifier|*
name|context
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|noderev_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|fs_x__id_t
modifier|*
name|id
decl_stmt|;
comment|/* Special case: NULL IDs */
if|if
condition|(
operator|!
name|svn_fs_x__id_used
argument_list|(
name|noderev_id
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* In theory, the CONTEXT might not be owned by POOL.  It's FS might even      have been closed.  Make sure we have a context owned by POOL. */
if|if
condition|(
name|context
operator|->
name|owner
operator|!=
name|result_pool
condition|)
name|context
operator|=
name|svn_fs_x__id_create_context
argument_list|(
name|get_fs
argument_list|(
name|context
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
comment|/* Finally, construct the ID object. */
name|id
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|id
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|->
name|noderev_id
operator|=
operator|*
name|noderev_id
expr_stmt|;
name|id
operator|->
name|generic_id
operator|.
name|vtable
operator|=
operator|&
name|id_vtable
expr_stmt|;
name|id
operator|->
name|generic_id
operator|.
name|fsap_data
operator|=
name|context
expr_stmt|;
return|return
operator|(
name|svn_fs_id_t
operator|*
operator|)
name|id
return|;
block|}
end_function

end_unit

