begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs_x.c --- filesystem operations specific to fs_x  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"fs_x.h"
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"rep-cache.h"
end_include

begin_include
include|#
directive|include
file|"revprops.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"index.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_comment
comment|/* The default maximum number of files per directory to store in the    rev and revprops directory.  The number below is somewhat arbitrary,    and can be overridden by defining the macro while compiling; the    figure of 1000 is reasonable for VFAT filesystems, which are by far    the worst performers in this area. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|SVN_FS_X_DEFAULT_MAX_FILES_PER_DIR
end_ifndef

begin_define
define|#
directive|define
name|SVN_FS_X_DEFAULT_MAX_FILES_PER_DIR
value|1000
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Begin deltification after a node history exceeded this this limit.    Useful values are 4 to 64 with 16 being a good compromise between    computational overhead and repository size savings.    Should be a power of 2.    Values< 2 will result in standard skip-delta behavior. */
end_comment

begin_define
define|#
directive|define
name|SVN_FS_X_MAX_LINEAR_DELTIFICATION
value|16
end_define

begin_comment
comment|/* Finding a deltification base takes operations proportional to the    number of changes being skipped. To prevent exploding runtime    during commits, limit the deltification range to this value.    Should be a power of 2 minus one.    Values< 1 disable deltification. */
end_comment

begin_define
define|#
directive|define
name|SVN_FS_X_MAX_DELTIFICATION_WALK
value|1023
end_define

begin_escape
end_escape

begin_comment
comment|/* Check that BUF, a nul-terminated buffer of text from format file PATH,    contains only digits at OFFSET and beyond, raising an error if not.     Uses SCRATCH_POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_format_file_buffer_numeric
parameter_list|(
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|apr_off_t
name|offset
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|svn_fs_x__check_file_buffer_numeric
argument_list|(
name|buf
argument_list|,
name|offset
argument_list|,
name|path
argument_list|,
literal|"Format"
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return the error SVN_ERR_FS_UNSUPPORTED_FORMAT if FS's format    number is not the same as a format number supported by this    Subversion. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_format
parameter_list|(
name|int
name|format
parameter_list|)
block|{
comment|/* Put blacklisted versions here. */
comment|/* We support all formats from 1-current simultaneously */
if|if
condition|(
literal|1
operator|<=
name|format
operator|&&
name|format
operator|<=
name|SVN_FS_X__FORMAT_NUMBER
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected FS format between '1' and '%d'; found format '%d'"
argument_list|)
argument_list|,
name|SVN_FS_X__FORMAT_NUMBER
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read the format file at PATH and set *PFORMAT to the format version found  * and *MAX_FILES_PER_DIR to the shard size.  Use SCRATCH_POOL for temporary  * allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_format
parameter_list|(
name|int
modifier|*
name|pformat
parameter_list|,
name|int
modifier|*
name|max_files_per_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|content
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_boolean_t
name|eos
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|content
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|content
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|->
name|len
operator|==
literal|0
operator|&&
name|eos
condition|)
block|{
comment|/* Return a more useful error message. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't read first line of format file '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
comment|/* Check that the first line contains only digits. */
name|SVN_ERR
argument_list|(
name|check_format_file_buffer_numeric
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
name|pformat
argument_list|,
name|buf
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check that we support this format at all */
name|SVN_ERR
argument_list|(
name|check_format
argument_list|(
operator|*
name|pformat
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read any options. */
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eos
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eos
operator|&&
name|strncmp
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|"layout sharded "
argument_list|,
literal|15
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Check that the argument is numeric. */
name|SVN_ERR
argument_list|(
name|check_format_file_buffer_numeric
argument_list|(
name|buf
operator|->
name|data
argument_list|,
literal|15
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
name|max_files_per_dir
argument_list|,
name|buf
operator|->
name|data
operator|+
literal|15
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_VERSION_FILE_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' contains invalid filesystem format option '%s'"
argument_list|)
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|buf
operator|->
name|data
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write the format number and maximum number of files per directory    to a new format file in PATH, possibly expecting to overwrite a    previously existing file.     Use SCRATCH_POOL for temporary allocation. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__write_format
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|overwrite
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|sb
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|svn_fs_x__path_format
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
literal|1
operator|<=
name|ffd
operator|->
name|format
operator|&&
name|ffd
operator|->
name|format
operator|<=
name|SVN_FS_X__FORMAT_NUMBER
argument_list|)
expr_stmt|;
name|sb
operator|=
name|svn_stringbuf_createf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%d\n"
argument_list|,
name|ffd
operator|->
name|format
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|sb
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"layout sharded %d\n"
argument_list|,
name|ffd
operator|->
name|max_files_per_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* svn_io_write_version_file() does a load of magic to allow it to      replace version files that already exist.  We only need to do      that when we're allowed to overwrite an existing file. */
if|if
condition|(
operator|!
name|overwrite
condition|)
block|{
comment|/* Create the file */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_io_write_atomic
argument_list|(
name|path
argument_list|,
name|sb
operator|->
name|data
argument_list|,
name|sb
operator|->
name|len
argument_list|,
name|NULL
comment|/* copy_perms_path */
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* And set the perms to make it read only */
return|return
name|svn_io_set_file_read_only
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Check that BLOCK_SIZE is a valid block / page size, i.e. it is within  * the range of what the current system may address in RAM and it is a  * power of 2.  Assume that the element size within the block is ITEM_SIZE.  * Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_block_size
parameter_list|(
name|apr_int64_t
name|block_size
parameter_list|,
name|apr_size_t
name|item_size
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Limit range. */
if|if
condition|(
name|block_size
operator|<=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s is too small for fsfs.conf setting '%s'."
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|block_size
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
if|if
condition|(
name|block_size
operator|>
name|SVN_MAX_OBJECT_SIZE
operator|/
name|item_size
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s is too large for fsfs.conf setting '%s'."
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|block_size
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Ensure it is a power of two.    * For positive X,  X& (X-1) will reset the lowest bit set.    * If the result is 0, at most one bit has been set. */
if|if
condition|(
literal|0
operator|!=
operator|(
name|block_size
operator|&
operator|(
name|block_size
operator|-
literal|1
operator|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_CONFIG_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"%s is invalid for fsfs.conf setting '%s' "
literal|"because it is not a power of 2."
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|block_size
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read the configuration information of the file system at FS_PATH  * and set the respective values in FFD.  Use pools as usual.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_config
parameter_list|(
name|svn_fs_x__data_t
modifier|*
name|ffd
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|config
decl_stmt|;
name|apr_int64_t
name|compression_level
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_read3
argument_list|(
operator|&
name|config
argument_list|,
name|svn_dirent_join
argument_list|(
name|fs_path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize ffd->rep_sharing_allowed. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|rep_sharing_allowed
argument_list|,
name|CONFIG_SECTION_REP_SHARING
argument_list|,
name|CONFIG_OPTION_ENABLE_REP_SHARING
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize deltification settings in ffd. */
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|max_deltification_walk
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_MAX_DELTIFICATION_WALK
argument_list|,
name|SVN_FS_X_MAX_DELTIFICATION_WALK
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|max_linear_deltification
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_MAX_LINEAR_DELTIFICATION
argument_list|,
name|SVN_FS_X_MAX_LINEAR_DELTIFICATION
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|compression_level
argument_list|,
name|CONFIG_SECTION_DELTIFICATION
argument_list|,
name|CONFIG_OPTION_COMPRESSION_LEVEL
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|delta_compression_level
operator|=
operator|(
name|int
operator|)
name|MIN
argument_list|(
name|MAX
argument_list|(
name|SVN_DELTA_COMPRESSION_LEVEL_NONE
argument_list|,
name|compression_level
argument_list|)
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_MAX
argument_list|)
expr_stmt|;
comment|/* Initialize revprop packing settings in ffd. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|compress_packed_revprops
argument_list|,
name|CONFIG_SECTION_PACKED_REVPROPS
argument_list|,
name|CONFIG_OPTION_COMPRESS_PACKED_REVPROPS
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|revprop_pack_size
argument_list|,
name|CONFIG_SECTION_PACKED_REVPROPS
argument_list|,
name|CONFIG_OPTION_REVPROP_PACK_SIZE
argument_list|,
name|ffd
operator|->
name|compress_packed_revprops
condition|?
literal|0x100
else|:
literal|0x40
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|revprop_pack_size
operator|*=
literal|1024
expr_stmt|;
comment|/* I/O settings in ffd. */
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|block_size
argument_list|,
name|CONFIG_SECTION_IO
argument_list|,
name|CONFIG_OPTION_BLOCK_SIZE
argument_list|,
literal|64
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|l2p_page_size
argument_list|,
name|CONFIG_SECTION_IO
argument_list|,
name|CONFIG_OPTION_L2P_PAGE_SIZE
argument_list|,
literal|0x2000
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_int64
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|p2l_page_size
argument_list|,
name|CONFIG_SECTION_IO
argument_list|,
name|CONFIG_OPTION_P2L_PAGE_SIZE
argument_list|,
literal|0x400
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't accept unreasonable or illegal values.    * Block size and P2L page size are in kbytes;    * L2P blocks are arrays of apr_off_t. */
name|SVN_ERR
argument_list|(
name|verify_block_size
argument_list|(
name|ffd
operator|->
name|block_size
argument_list|,
literal|0x400
argument_list|,
name|CONFIG_OPTION_BLOCK_SIZE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_block_size
argument_list|(
name|ffd
operator|->
name|p2l_page_size
argument_list|,
literal|0x400
argument_list|,
name|CONFIG_OPTION_P2L_PAGE_SIZE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_block_size
argument_list|(
name|ffd
operator|->
name|l2p_page_size
argument_list|,
sizeof|sizeof
argument_list|(
name|apr_off_t
argument_list|)
argument_list|,
name|CONFIG_OPTION_L2P_PAGE_SIZE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* convert kBytes to bytes */
name|ffd
operator|->
name|block_size
operator|*=
literal|0x400
expr_stmt|;
name|ffd
operator|->
name|p2l_page_size
operator|*=
literal|0x400
expr_stmt|;
comment|/* L2P pages are in entries - not in (k)Bytes */
comment|/* Debug options. */
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|pack_after_commit
argument_list|,
name|CONFIG_SECTION_DEBUG
argument_list|,
name|CONFIG_OPTION_PACK_AFTER_COMMIT
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* memcached configuration */
name|SVN_ERR
argument_list|(
name|svn_cache__make_memcache_from_config
argument_list|(
operator|&
name|ffd
operator|->
name|memcache
argument_list|,
name|config
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_bool
argument_list|(
name|config
argument_list|,
operator|&
name|ffd
operator|->
name|fail_stop
argument_list|,
name|CONFIG_SECTION_CACHES
argument_list|,
name|CONFIG_OPTION_FAIL_STOP
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Write FS' initial configuration file.  * Use SCRATCH_POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_config
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
define|#
directive|define
name|NL
value|APR_EOL_STR
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|fsx_conf_contents
init|=
literal|"### This file controls the configuration of the FSX filesystem."
name|NL
literal|""
name|NL
literal|"["
name|SVN_CACHE_CONFIG_CATEGORY_MEMCACHED_SERVERS
literal|"]"
name|NL
literal|"### These options name memcached servers used to cache internal FSX"
name|NL
literal|"### data.  See http://www.danga.com/memcached/ for more information on"
name|NL
literal|"### memcached.  To use memcached with FSX, run one or more memcached"
name|NL
literal|"### servers, and specify each of them as an option like so:"
name|NL
literal|"# first-server = 127.0.0.1:11211"
name|NL
literal|"# remote-memcached = mymemcached.corp.example.com:11212"
name|NL
literal|"### The option name is ignored; the value is of the form HOST:PORT."
name|NL
literal|"### memcached servers can be shared between multiple repositories;"
name|NL
literal|"### however, if you do this, you *must* ensure that repositories have"
name|NL
literal|"### distinct UUIDs and paths, or else cached data from one repository"
name|NL
literal|"### might be used by another accidentally.  Note also that memcached has"
name|NL
literal|"### no authentication for reads or writes, so you must ensure that your"
name|NL
literal|"### memcached servers are only accessible by trusted users."
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_CACHES
literal|"]"
name|NL
literal|"### When a cache-related error occurs, normally Subversion ignores it"
name|NL
literal|"### and continues, logging an error if the server is appropriately"
name|NL
literal|"### configured (and ignoring it with file:// access).  To make"
name|NL
literal|"### Subversion never ignore cache errors, uncomment this line."
name|NL
literal|"# "
name|CONFIG_OPTION_FAIL_STOP
literal|" = true"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_REP_SHARING
literal|"]"
name|NL
literal|"### To conserve space, the filesystem can optionally avoid storing"
name|NL
literal|"### duplicate representations.  This comes at a slight cost in"
name|NL
literal|"### performance, as maintaining a database of shared representations can"
name|NL
literal|"### increase commit times.  The space savings are dependent upon the size"
name|NL
literal|"### of the repository, the number of objects it contains and the amount of"
name|NL
literal|"### duplication between them, usually a function of the branching and"
name|NL
literal|"### merging process."
name|NL
literal|"###"
name|NL
literal|"### The following parameter enables rep-sharing in the repository.  It can"
name|NL
literal|"### be switched on and off at will, but for best space-saving results"
name|NL
literal|"### should be enabled consistently over the life of the repository."
name|NL
literal|"### 'svnadmin verify' will check the rep-cache regardless of this setting."
name|NL
literal|"### rep-sharing is enabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_ENABLE_REP_SHARING
literal|" = true"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_DELTIFICATION
literal|"]"
name|NL
literal|"### To conserve space, the filesystem stores data as differences against"
name|NL
literal|"### existing representations.  This comes at a slight cost in performance,"
name|NL
literal|"### as calculating differences can increase commit times.  Reading data"
name|NL
literal|"### will also create higher CPU load and the data will be fragmented."
name|NL
literal|"### Since deltification tends to save significant amounts of disk space,"
name|NL
literal|"### the overall I/O load can actually be lower."
name|NL
literal|"###"
name|NL
literal|"### The options in this section allow for tuning the deltification"
name|NL
literal|"### strategy.  Their effects on data size and server performance may vary"
name|NL
literal|"### from one repository to another."
name|NL
literal|"###"
name|NL
literal|"### During commit, the server may need to walk the whole change history of"
name|NL
literal|"### of a given node to find a suitable deltification base.  This linear"
name|NL
literal|"### process can impact commit times, svnadmin load and similar operations."
name|NL
literal|"### This setting limits the depth of the deltification history.  If the"
name|NL
literal|"### threshold has been reached, the node will be stored as fulltext and a"
name|NL
literal|"### new deltification history begins."
name|NL
literal|"### Note, this is unrelated to svn log."
name|NL
literal|"### Very large values rarely provide significant additional savings but"
name|NL
literal|"### can impact performance greatly - in particular if directory"
name|NL
literal|"### deltification has been activated.  Very small values may be useful in"
name|NL
literal|"### repositories that are dominated by large, changing binaries."
name|NL
literal|"### Should be a power of two minus 1.  A value of 0 will effectively"
name|NL
literal|"### disable deltification."
name|NL
literal|"### For 1.9, the default value is 1023."
name|NL
literal|"# "
name|CONFIG_OPTION_MAX_DELTIFICATION_WALK
literal|" = 1023"
name|NL
literal|"###"
name|NL
literal|"### The skip-delta scheme used by FSX tends to repeatably store redundant"
name|NL
literal|"### delta information where a simple delta against the latest version is"
name|NL
literal|"### often smaller.  By default, 1.9+ will therefore use skip deltas only"
name|NL
literal|"### after the linear chain of deltas has grown beyond the threshold"
name|NL
literal|"### specified by this setting."
name|NL
literal|"### Values up to 64 can result in some reduction in repository size for"
name|NL
literal|"### the cost of quickly increasing I/O and CPU costs. Similarly, smaller"
name|NL
literal|"### numbers can reduce those costs at the cost of more disk space.  For"
name|NL
literal|"### rarely read repositories or those containing larger binaries, this may"
name|NL
literal|"### present a better trade-off."
name|NL
literal|"### Should be a power of two.  A value of 1 or smaller will cause the"
name|NL
literal|"### exclusive use of skip-deltas."
name|NL
literal|"### For 1.8, the default value is 16."
name|NL
literal|"# "
name|CONFIG_OPTION_MAX_LINEAR_DELTIFICATION
literal|" = 16"
name|NL
literal|"###"
name|NL
literal|"### After deltification, we compress the data through zlib to minimize on-"
name|NL
literal|"### disk size.  That can be an expensive and ineffective process.  This"
name|NL
literal|"### setting controls the usage of zlib in future revisions."
name|NL
literal|"### Revisions with highly compressible data in them may shrink in size"
name|NL
literal|"### if the setting is increased but may take much longer to commit.  The"
name|NL
literal|"### time taken to uncompress that data again is widely independent of the"
name|NL
literal|"### compression level."
name|NL
literal|"### Compression will be ineffective if the incoming content is already"
name|NL
literal|"### highly compressed.  In that case, disabling the compression entirely"
name|NL
literal|"### will speed up commits as well as reading the data.  Repositories with"
name|NL
literal|"### many small compressible files (source code) but also a high percentage"
name|NL
literal|"### of large incompressible ones (artwork) may benefit from compression"
name|NL
literal|"### levels lowered to e.g. 1."
name|NL
literal|"### Valid values are 0 to 9 with 9 providing the highest compression ratio"
name|NL
literal|"### and 0 disabling it altogether."
name|NL
literal|"### The default value is 5."
name|NL
literal|"# "
name|CONFIG_OPTION_COMPRESSION_LEVEL
literal|" = 5"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_PACKED_REVPROPS
literal|"]"
name|NL
literal|"### This parameter controls the size (in kBytes) of packed revprop files."
name|NL
literal|"### Revprops of consecutive revisions will be concatenated into a single"
name|NL
literal|"### file up to but not exceeding the threshold given here.  However, each"
name|NL
literal|"### pack file may be much smaller and revprops of a single revision may be"
name|NL
literal|"### much larger than the limit set here.  The threshold will be applied"
name|NL
literal|"### before optional compression takes place."
name|NL
literal|"### Large values will reduce disk space usage at the expense of increased"
name|NL
literal|"### latency and CPU usage reading and changing individual revprops.  They"
name|NL
literal|"### become an advantage when revprop caching has been enabled because a"
name|NL
literal|"### lot of data can be read in one go.  Values smaller than 4 kByte will"
name|NL
literal|"### not improve latency any further and quickly render revprop packing"
name|NL
literal|"### ineffective."
name|NL
literal|"### revprop-pack-size is 64 kBytes by default for non-compressed revprop"
name|NL
literal|"### pack files and 256 kBytes when compression has been enabled."
name|NL
literal|"# "
name|CONFIG_OPTION_REVPROP_PACK_SIZE
literal|" = 64"
name|NL
literal|"###"
name|NL
literal|"### To save disk space, packed revprop files may be compressed.  Standard"
name|NL
literal|"### revprops tend to allow for very effective compression.  Reading and"
name|NL
literal|"### even more so writing, become significantly more CPU intensive.  With"
name|NL
literal|"### revprop caching enabled, the overhead can be offset by reduced I/O"
name|NL
literal|"### unless you often modify revprops after packing."
name|NL
literal|"### Compressing packed revprops is enabled by default."
name|NL
literal|"# "
name|CONFIG_OPTION_COMPRESS_PACKED_REVPROPS
literal|" = true"
name|NL
literal|""
name|NL
literal|"["
name|CONFIG_SECTION_IO
literal|"]"
name|NL
literal|"### Parameters in this section control the data access granularity in"
name|NL
literal|"### format 7 repositories and later.  The defaults should translate into"
name|NL
literal|"### decent performance over a wide range of setups."
name|NL
literal|"###"
name|NL
literal|"### When a specific piece of information needs to be read from disk,  a"
name|NL
literal|"### data block is being read at once and its contents are being cached."
name|NL
literal|"### If the repository is being stored on a RAID, the block size should be"
name|NL
literal|"### either 50% or 100% of RAID block size / granularity.  Also, your file"
name|NL
literal|"### system blocks/clusters should be properly aligned and sized.  In that"
name|NL
literal|"### setup, each access will hit only one disk (minimizes I/O load) but"
name|NL
literal|"### uses all the data provided by the disk in a single access."
name|NL
literal|"### For SSD-based storage systems, slightly lower values around 16 kB"
name|NL
literal|"### may improve latency while still maximizing throughput."
name|NL
literal|"### Can be changed at any time but must be a power of 2."
name|NL
literal|"### block-size is given in kBytes and with a default of 64 kBytes."
name|NL
literal|"# "
name|CONFIG_OPTION_BLOCK_SIZE
literal|" = 64"
name|NL
literal|"###"
name|NL
literal|"### The log-to-phys index maps data item numbers to offsets within the"
name|NL
literal|"### rev or pack file.  This index is organized in pages of a fixed maximum"
name|NL
literal|"### capacity.  To access an item, the page table and the respective page"
name|NL
literal|"### must be read."
name|NL
literal|"### This parameter only affects revisions with thousands of changed paths."
name|NL
literal|"### If you have several extremely large revisions (~1 mio changes), think"
name|NL
literal|"### about increasing this setting.  Reducing the value will rarely result"
name|NL
literal|"### in a net speedup."
name|NL
literal|"### This is an expert setting.  Must be a power of 2."
name|NL
literal|"### l2p-page-size is 8192 entries by default."
name|NL
literal|"# "
name|CONFIG_OPTION_L2P_PAGE_SIZE
literal|" = 8192"
name|NL
literal|"###"
name|NL
literal|"### The phys-to-log index maps positions within the rev or pack file to"
name|NL
literal|"### to data items,  i.e. describes what piece of information is being"
name|NL
literal|"### stored at any particular offset.  The index describes the rev file"
name|NL
literal|"### in chunks (pages) and keeps a global list of all those pages.  Large"
name|NL
literal|"### pages mean a shorter page table but a larger per-page description of"
name|NL
literal|"### data items in it.  The latency sweet spot depends on the change size"
name|NL
literal|"### distribution but covers a relatively wide range."
name|NL
literal|"### If the repository contains very large files,  i.e. individual changes"
name|NL
literal|"### of tens of MB each,  increasing the page size will shorten the index"
name|NL
literal|"### file at the expense of a slightly increased latency in sections with"
name|NL
literal|"### smaller changes."
name|NL
literal|"### For source code repositories, this should be about 16x the block-size."
name|NL
literal|"### Must be a power of 2."
name|NL
literal|"### p2l-page-size is given in kBytes and with a default of 1024 kBytes."
name|NL
literal|"# "
name|CONFIG_OPTION_P2L_PAGE_SIZE
literal|" = 1024"
name|NL
decl_stmt|;
undef|#
directive|undef
name|NL
return|return
name|svn_io_file_create
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|fsx_conf_contents
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Read FS's UUID file and store the data in the FS struct. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|apr_file_t
modifier|*
name|uuid_file
decl_stmt|;
name|char
name|buf
index|[
name|APR_UUID_FORMATTED_LENGTH
operator|+
literal|2
index|]
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
comment|/* Read the repository uuid. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|uuid_file
argument_list|,
name|svn_fs_x__path_uuid
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|APR_READ
operator||
name|APR_BUFFERED
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|uuid_file
argument_list|,
name|buf
argument_list|,
operator|&
name|limit
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* Read the instance ID. */
name|limit
operator|=
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_read_length_line
argument_list|(
name|uuid_file
argument_list|,
name|buf
argument_list|,
operator|&
name|limit
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|instance_id
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|uuid_file
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__read_format_file
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|format
decl_stmt|,
name|max_files_per_dir
decl_stmt|;
comment|/* Read info from format file. */
name|SVN_ERR
argument_list|(
name|read_format
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|max_files_per_dir
argument_list|,
name|svn_fs_x__path_format
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now that we've got *all* info, store / update values in FFD. */
name|ffd
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|ffd
operator|->
name|max_files_per_dir
operator|=
name|max_files_per_dir
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__open
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* Read the FS format file. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_format_file
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read in and cache the repository uuid. */
name|SVN_ERR
argument_list|(
name|read_uuid
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the min unpacked revision. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__update_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the configuration file. */
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
name|ffd
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|fs
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_fs_x__read_current
argument_list|(
operator|&
name|ffd
operator|->
name|youngest_rev_cache
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Baton type bridging svn_fs_x__upgrade and upgrade_body carrying  * parameters over between them. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|upgrade_baton_t
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_upgrade_notify_t
name|notify_func
decl_stmt|;
name|void
modifier|*
name|notify_baton
decl_stmt|;
name|svn_cancel_func_t
name|cancel_func
decl_stmt|;
name|void
modifier|*
name|cancel_baton
decl_stmt|;
block|}
name|upgrade_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Upgrade the FS given in upgrade_baton_t *)BATON to the latest format  * version.  Apply options an invoke callback from that BATON.  * Temporary allocations are to be made from SCRATCH_POOL.  *  * At the moment, this is a simple placeholder as we don't support upgrades  * from experimental FSX versions.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|upgrade_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|upgrade_baton_t
modifier|*
name|upgrade_baton
init|=
name|baton
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|upgrade_baton
operator|->
name|fs
decl_stmt|;
name|int
name|format
decl_stmt|,
name|max_files_per_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|format_path
init|=
name|svn_fs_x__path_format
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Read the FS format number and max-files-per-dir setting. */
name|SVN_ERR
argument_list|(
name|read_format
argument_list|(
operator|&
name|format
argument_list|,
operator|&
name|max_files_per_dir
argument_list|,
name|format_path
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we're already up-to-date, there's nothing else to be done here. */
if|if
condition|(
name|format
operator|==
name|SVN_FS_X__FORMAT_NUMBER
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Done */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__upgrade
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_upgrade_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|upgrade_baton_t
name|baton
decl_stmt|;
name|baton
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|baton
operator|.
name|notify_func
operator|=
name|notify_func
expr_stmt|;
name|baton
operator|.
name|notify_baton
operator|=
name|notify_baton
expr_stmt|;
name|baton
operator|.
name|cancel_func
operator|=
name|cancel_func
expr_stmt|;
name|baton
operator|.
name|cancel_baton
operator|=
name|cancel_baton
expr_stmt|;
return|return
name|svn_fs_x__with_all_locks
argument_list|(
name|fs
argument_list|,
name|upgrade_body
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__youngest_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|youngest_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_current
argument_list|(
name|youngest_p
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
operator|*
name|youngest_p
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__ensure_revision_exists
parameter_list|(
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number '%ld'"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
comment|/* Did the revision exist the last time we checked the current      file? */
if|if
condition|(
name|rev
operator|<=
name|ffd
operator|->
name|youngest_rev_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__read_current
argument_list|(
operator|&
name|ffd
operator|->
name|youngest_rev_cache
argument_list|,
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check again. */
if|if
condition|(
name|rev
operator|<=
name|ffd
operator|->
name|youngest_rev_cache
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No such revision %ld"
argument_list|)
argument_list|,
name|rev
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|)
block|{
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
operator|*
name|length
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|expanded_size
expr_stmt|;
else|else
operator|*
name|length
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fs_x__file_text_rep_equal
parameter_list|(
name|svn_fs_x__representation_t
modifier|*
name|a
parameter_list|,
name|svn_fs_x__representation_t
modifier|*
name|b
parameter_list|)
block|{
name|svn_boolean_t
name|a_empty
init|=
name|a
operator|==
name|NULL
operator|||
name|a
operator|->
name|expanded_size
operator|==
literal|0
decl_stmt|;
name|svn_boolean_t
name|b_empty
init|=
name|b
operator|==
name|NULL
operator|||
name|b
operator|->
name|expanded_size
operator|==
literal|0
decl_stmt|;
comment|/* This makes sure that neither rep will be NULL later on */
if|if
condition|(
name|a_empty
operator|&&
name|b_empty
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|a_empty
operator|!=
name|b_empty
condition|)
return|return
name|FALSE
return|;
comment|/* Same physical representation?  Note that these IDs are always up-to-date      instead of e.g. being set lazily. */
if|if
condition|(
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|a
operator|->
name|id
argument_list|,
operator|&
name|b
operator|->
name|id
argument_list|)
condition|)
return|return
name|TRUE
return|;
comment|/* Contents are equal if the checksums match.  These are also always known.    */
return|return
name|memcmp
argument_list|(
name|a
operator|->
name|md5_digest
argument_list|,
name|b
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|->
name|md5_digest
argument_list|)
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|a
operator|->
name|sha1_digest
argument_list|,
name|b
operator|->
name|sha1_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|a
operator|->
name|sha1_digest
argument_list|)
argument_list|)
operator|==
literal|0
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__prop_rep_equal
parameter_list|(
name|svn_boolean_t
modifier|*
name|equal
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|a
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|b
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__representation_t
modifier|*
name|rep_a
init|=
name|a
operator|->
name|prop_rep
decl_stmt|;
name|svn_fs_x__representation_t
modifier|*
name|rep_b
init|=
name|b
operator|->
name|prop_rep
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist_a
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist_b
decl_stmt|;
comment|/* Mainly for a==b==NULL */
if|if
condition|(
name|rep_a
operator|==
name|rep_b
condition|)
block|{
operator|*
name|equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Committed property lists can be compared quickly */
if|if
condition|(
name|rep_a
operator|&&
name|rep_b
operator|&&
name|svn_fs_x__is_revision
argument_list|(
name|rep_a
operator|->
name|id
operator|.
name|change_set
argument_list|)
operator|&&
name|svn_fs_x__is_revision
argument_list|(
name|rep_b
operator|->
name|id
operator|.
name|change_set
argument_list|)
condition|)
block|{
comment|/* MD5 must be given. Having the same checksum is good enough for          accepting the prop lists as equal. */
operator|*
name|equal
operator|=
name|memcmp
argument_list|(
name|rep_a
operator|->
name|md5_digest
argument_list|,
name|rep_b
operator|->
name|md5_digest
argument_list|,
sizeof|sizeof
argument_list|(
name|rep_a
operator|->
name|md5_digest
argument_list|)
argument_list|)
operator|==
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Same path in same txn? */
if|if
condition|(
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|a
operator|->
name|noderev_id
argument_list|,
operator|&
name|b
operator|->
name|noderev_id
argument_list|)
condition|)
block|{
operator|*
name|equal
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Skip the expensive bits unless we are in strict mode.      Simply assume that there is a different. */
if|if
condition|(
operator|!
name|strict
condition|)
block|{
operator|*
name|equal
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* At least one of the reps has been modified in a txn.      Fetch and compare them. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_proplist
argument_list|(
operator|&
name|proplist_a
argument_list|,
name|fs
argument_list|,
name|a
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_proplist
argument_list|(
operator|&
name|proplist_b
argument_list|,
name|fs
argument_list|,
name|b
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|equal
operator|=
name|svn_fs__prop_lists_equal
argument_list|(
name|proplist_a
argument_list|,
name|proplist_b
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
operator|*
name|checksum
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|data_rep
condition|)
block|{
name|svn_checksum_t
name|temp
decl_stmt|;
name|temp
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
switch|switch
condition|(
name|kind
condition|)
block|{
case|case
name|svn_checksum_md5
case|:
name|temp
operator|.
name|digest
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|md5_digest
expr_stmt|;
break|break;
case|case
name|svn_checksum_sha1
case|:
if|if
condition|(
operator|!
name|noderev
operator|->
name|data_rep
operator|->
name|has_sha1
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|temp
operator|.
name|digest
operator|=
name|noderev
operator|->
name|data_rep
operator|->
name|sha1_digest
expr_stmt|;
break|break;
default|default:
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
operator|&
name|temp
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_fs_x__representation_t
modifier|*
name|svn_fs_x__rep_copy
parameter_list|(
name|svn_fs_x__representation_t
modifier|*
name|rep
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|if
condition|(
name|rep
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
return|return
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|rep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write out the zeroth revision for filesystem FS.    Perform temporary allocations in SCRATCH_POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_revision_zero
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Use an explicit sub-pool to have full control over temp file lifetimes.    * Since we have it, use it for everything else as well. */
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_revision_zero
init|=
name|svn_fs_x__path_rev
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_string_t
name|date
decl_stmt|;
name|apr_array_header_t
modifier|*
name|index_entries
decl_stmt|;
name|svn_fs_x__p2l_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_fs_x__revision_file_t
modifier|*
name|rev_file
decl_stmt|;
specifier|const
name|char
modifier|*
name|l2p_proto_index
decl_stmt|,
modifier|*
name|p2l_proto_index
decl_stmt|;
comment|/* Construct a skeleton r0 with no indexes. */
name|svn_string_t
modifier|*
name|noderev_str
init|=
name|svn_string_create
argument_list|(
literal|"id: 2+0\n"
literal|"node: 0+0\n"
literal|"copy: 0+0\n"
literal|"type: dir\n"
literal|"count: 0\n"
literal|"cpath: /\n"
literal|"\n"
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|changes_str
init|=
name|svn_string_create
argument_list|(
literal|"\n"
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|r0
init|=
name|svn_string_createf
argument_list|(
name|subpool
argument_list|,
literal|"%s%s"
argument_list|,
name|noderev_str
operator|->
name|data
argument_list|,
name|changes_str
operator|->
name|data
argument_list|)
decl_stmt|;
comment|/* Write skeleton r0 to disk. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|path_revision_zero
argument_list|,
name|r0
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Construct the index P2L contents: describe the 2 items we have.      Be sure to create them in on-disk order. */
name|index_entries
operator|=
name|apr_array_make
argument_list|(
name|subpool
argument_list|,
literal|2
argument_list|,
sizeof|sizeof
argument_list|(
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|size
operator|=
operator|(
name|apr_off_t
operator|)
name|noderev_str
operator|->
name|len
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|SVN_FS_X__ITEM_TYPE_NODEREV
expr_stmt|;
name|entry
operator|->
name|item_count
operator|=
literal|1
expr_stmt|;
name|entry
operator|->
name|items
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|items
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
operator|=
name|SVN_FS_X__ITEM_INDEX_ROOT_NODE
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|index_entries
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
name|entry
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|offset
operator|=
operator|(
name|apr_off_t
operator|)
name|noderev_str
operator|->
name|len
expr_stmt|;
name|entry
operator|->
name|size
operator|=
operator|(
name|apr_off_t
operator|)
name|changes_str
operator|->
name|len
expr_stmt|;
name|entry
operator|->
name|type
operator|=
name|SVN_FS_X__ITEM_TYPE_CHANGES
expr_stmt|;
name|entry
operator|->
name|item_count
operator|=
literal|1
expr_stmt|;
name|entry
operator|->
name|items
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
operator|->
name|items
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|change_set
operator|=
literal|0
expr_stmt|;
name|entry
operator|->
name|items
index|[
literal|0
index|]
operator|.
name|number
operator|=
name|SVN_FS_X__ITEM_INDEX_CHANGES
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|index_entries
argument_list|,
name|svn_fs_x__p2l_entry_t
operator|*
argument_list|)
operator|=
name|entry
expr_stmt|;
comment|/* Now re-open r0, create proto-index files from our entries and       rewrite the index section of r0. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__open_pack_or_rev_file_writable
argument_list|(
operator|&
name|rev_file
argument_list|,
name|fs
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__p2l_index_from_p2l_entries
argument_list|(
operator|&
name|p2l_proto_index
argument_list|,
name|fs
argument_list|,
name|rev_file
argument_list|,
name|index_entries
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__l2p_index_from_p2l_entries
argument_list|(
operator|&
name|l2p_proto_index
argument_list|,
name|fs
argument_list|,
name|index_entries
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__add_index_data
argument_list|(
name|fs
argument_list|,
name|rev_file
operator|->
name|file
argument_list|,
name|l2p_proto_index
argument_list|,
name|p2l_proto_index
argument_list|,
literal|0
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__close_revision_file
argument_list|(
name|rev_file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_set_file_read_only
argument_list|(
name|path_revision_zero
argument_list|,
name|FALSE
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set a date on revision 0. */
name|date
operator|.
name|data
operator|=
name|svn_time_to_cstring
argument_list|(
name|apr_time_now
argument_list|()
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
expr_stmt|;
name|date
operator|.
name|len
operator|=
name|strlen
argument_list|(
name|date
operator|.
name|data
argument_list|)
expr_stmt|;
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|fs
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
operator|&
name|date
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__set_revision_proplist
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|proplist
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__create_file_tree
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|format
parameter_list|,
name|int
name|shard_size
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|format
operator|=
name|format
expr_stmt|;
comment|/* Use an appropriate sharding mode if supported by the format. */
name|ffd
operator|->
name|max_files_per_dir
operator|=
name|shard_size
expr_stmt|;
comment|/* Create the revision data directories. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_x__path_rev_shard
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the revprops directory. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_x__path_revprops_shard
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the transaction directory. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_x__path_txns_dir
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the protorevs directory. */
name|SVN_ERR
argument_list|(
name|svn_io_make_dir_recursively
argument_list|(
name|svn_fs_x__path_txn_proto_revs
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the 'current' file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_x__path_current
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_current
argument_list|(
name|fs
argument_list|,
literal|0
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the 'uuid' file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_x__path_lock
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__set_uuid
argument_list|(
name|fs
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the fsfs.conf file. */
name|SVN_ERR
argument_list|(
name|write_config
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_config
argument_list|(
name|ffd
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|fs
operator|->
name|pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add revision 0. */
name|SVN_ERR
argument_list|(
name|write_revision_zero
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the min unpacked rev file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_fs_x__path_min_unpacked_rev
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the txn-current file if the repository supports      the transaction sequence file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_create
argument_list|(
name|svn_fs_x__path_txn_current
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
literal|"0\n"
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_create_empty
argument_list|(
name|svn_fs_x__path_txn_current_lock
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the revprop caching info. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__reset_revprop_generation_file
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__create
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|format
init|=
name|SVN_FS_X__FORMAT_NUMBER
decl_stmt|;
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* See if compatibility with older versions was explicitly requested. */
if|if
condition|(
name|fs
operator|->
name|config
condition|)
block|{
name|svn_version_t
modifier|*
name|compatible_version
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__compatible_version
argument_list|(
operator|&
name|compatible_version
argument_list|,
name|fs
operator|->
name|config
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* select format number */
switch|switch
condition|(
name|compatible_version
operator|->
name|minor
condition|)
block|{
case|case
literal|0
case|:
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
case|case
literal|4
case|:
case|case
literal|5
case|:
case|case
literal|6
case|:
case|case
literal|7
case|:
case|case
literal|8
case|:
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"FSX is not compatible with Subversion prior to 1.9"
argument_list|)
argument_list|)
return|;
default|default:
name|format
operator|=
name|SVN_FS_X__FORMAT_NUMBER
expr_stmt|;
block|}
block|}
comment|/* Actual FS creation. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__create_file_tree
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|format
argument_list|,
name|SVN_FS_X_DEFAULT_MAX_FILES_PER_DIR
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This filesystem is ready.  Stamp it with a format number. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__write_format
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|youngest_rev_cache
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__set_uuid
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
specifier|const
name|char
modifier|*
name|instance_id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid_path
init|=
name|svn_fs_x__path_uuid
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|contents
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|uuid
condition|)
name|uuid
operator|=
name|svn_uuid_generate
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|instance_id
condition|)
name|instance_id
operator|=
name|svn_uuid_generate
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
name|instance_id
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|contents
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* We use the permissions of the 'current' file, because the 'uuid'      file does not exist during repository creation. */
name|SVN_ERR
argument_list|(
name|svn_io_write_atomic
argument_list|(
name|uuid_path
argument_list|,
name|contents
operator|->
name|data
argument_list|,
name|contents
operator|->
name|len
argument_list|,
comment|/* perms */
name|svn_fs_x__path_current
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|uuid
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
name|ffd
operator|->
name|instance_id
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|instance_id
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/** Node origin lazy cache. */
end_comment

begin_comment
comment|/* If directory PATH does not exist, create it and give it the same    permissions as FS_path.*/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__ensure_dir_exists
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|fs_path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_io_dir_make
argument_list|(
name|path
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_EEXIST
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* We successfully created a new directory.  Dup the permissions      from FS->path. */
return|return
name|svn_io_copy_perms
argument_list|(
name|fs_path
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Revisions ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__revision_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_revision_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|svn_string_dup
argument_list|(
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|propname
argument_list|)
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton used for change_rev_prop_body below. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|change_rev_prop_baton_t
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
block|}
name|change_rev_prop_baton_t
typedef|;
end_typedef

begin_comment
comment|/* The work-horse for svn_fs_x__change_rev_prop, called with the FS    write lock.  This implements the svn_fs_x__with_write_lock()    'body' callback type.  BATON is a 'change_rev_prop_baton_t *'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_rev_prop_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|change_rev_prop_baton_t
modifier|*
name|cb
init|=
name|baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
comment|/* Read current revprop values from disk (never from cache).      Even if somehow the cache got out of sync, we want to make sure that      we read, update and write up-to-date data. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_revision_proplist
argument_list|(
operator|&
name|table
argument_list|,
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|rev
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|old_value_p
condition|)
block|{
specifier|const
name|svn_string_t
modifier|*
name|wanted_value
init|=
operator|*
name|cb
operator|->
name|old_value_p
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|present_value
init|=
name|svn_hash_gets
argument_list|(
name|table
argument_list|,
name|cb
operator|->
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|wanted_value
operator|!=
operator|!
name|present_value
operator|)
operator|||
operator|(
name|wanted_value
operator|&&
name|present_value
operator|&&
operator|!
name|svn_string_compare
argument_list|(
name|wanted_value
argument_list|,
name|present_value
argument_list|)
operator|)
condition|)
block|{
comment|/* What we expected isn't what we found. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_PROP_BASEVALUE_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"revprop '%s' has unexpected value in "
literal|"filesystem"
argument_list|)
argument_list|,
name|cb
operator|->
name|name
argument_list|)
return|;
block|}
comment|/* Fall through. */
block|}
name|svn_hash_sets
argument_list|(
name|table
argument_list|,
name|cb
operator|->
name|name
argument_list|,
name|cb
operator|->
name|value
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__set_revision_proplist
argument_list|(
name|cb
operator|->
name|fs
argument_list|,
name|cb
operator|->
name|rev
argument_list|,
name|table
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__change_rev_prop
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|change_rev_prop_baton_t
name|cb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|cb
operator|.
name|fs
operator|=
name|fs
expr_stmt|;
name|cb
operator|.
name|rev
operator|=
name|rev
expr_stmt|;
name|cb
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|cb
operator|.
name|old_value_p
operator|=
name|old_value_p
expr_stmt|;
name|cb
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|svn_fs_x__with_write_lock
argument_list|(
name|fs
argument_list|,
name|change_rev_prop_body
argument_list|,
operator|&
name|cb
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__info_format
parameter_list|(
name|int
modifier|*
name|fs_format
parameter_list|,
name|svn_version_t
modifier|*
modifier|*
name|supports_version
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__data_t
modifier|*
name|ffd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|fs_format
operator|=
name|ffd
operator|->
name|format
expr_stmt|;
operator|*
name|supports_version
operator|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_version_t
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|major
operator|=
name|SVN_VER_MAJOR
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|minor
operator|=
literal|9
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|patch
operator|=
literal|0
expr_stmt|;
operator|(
operator|*
name|supports_version
operator|)
operator|->
name|tag
operator|=
literal|""
expr_stmt|;
switch|switch
condition|(
name|ffd
operator|->
name|format
condition|)
block|{
case|case
literal|1
case|:
break|break;
ifdef|#
directive|ifdef
name|SVN_DEBUG
if|#
directive|if
name|SVN_FS_X__FORMAT_NUMBER
operator|!=
literal|1
error|#
directive|error
literal|"Need to add a 'case' statement here"
endif|#
directive|endif
endif|#
directive|endif
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__info_config_files
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|files
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
operator|*
name|files
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|files
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|PATH_CONFIG
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

