begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* dag.c : DAG-like interface filesystem, private to libsvn_fs  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"fs_x.h"
end_include

begin_include
include|#
directive|include
file|"fs_id.h"
end_include

begin_include
include|#
directive|include
file|"cached_data.h"
end_include

begin_include
include|#
directive|include
file|"transaction.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_temp_serializer.h"
end_include

begin_include
include|#
directive|include
file|"temp_serializer.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Initializing a filesystem.  */
end_comment

begin_struct
struct|struct
name|dag_node_t
block|{
comment|/* The filesystem this dag node came from. */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* The node revision ID for this dag node.  */
name|svn_fs_x__id_t
name|id
decl_stmt|;
comment|/* In the special case that this node is the root of a transaction      that has not yet been modified, the revision of this node is the      respective txn's base rev.  Otherwise, this is SVN_INVALID_REVNUM      for txn nodes and the respective crev for committed nodes.      (Used in svn_fs_node_created_rev.) */
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* The node's type (file, dir, etc.) */
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* The node's NODE-REVISION, or NULL if we haven't read it in yet.      This is allocated in this node's POOL.       If you're willing to respect all the rules above, you can munge      this yourself, but you're probably better off just calling      `get_node_revision' and `set_node_revision', which take care of      things for you.  */
name|svn_fs_x__noderev_t
modifier|*
name|node_revision
decl_stmt|;
comment|/* The pool to allocate NODE_REVISION in. */
name|apr_pool_t
modifier|*
name|node_pool
decl_stmt|;
comment|/* the path at which this node was created. */
specifier|const
name|char
modifier|*
name|created_path
decl_stmt|;
comment|/* Directory entry lookup hint to speed up consecutive calls to      svn_fs_x__rep_contents_dir_entry(). Only used for directory nodes.      Any value is legal but should default to APR_SIZE_MAX. */
name|apr_size_t
name|hint
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Trivial helper/accessor functions. */
end_comment

begin_function
name|svn_node_kind_t
name|svn_fs_x__dag_node_kind
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|kind
return|;
block|}
end_function

begin_function
specifier|const
name|svn_fs_x__id_t
modifier|*
name|svn_fs_x__dag_get_id
parameter_list|(
specifier|const
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
operator|&
name|node
operator|->
name|id
return|;
block|}
end_function

begin_function
specifier|const
name|char
modifier|*
name|svn_fs_x__dag_get_created_path
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|created_path
return|;
block|}
end_function

begin_function
name|svn_fs_t
modifier|*
name|svn_fs_x__dag_get_fs
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|fs
return|;
block|}
end_function

begin_function
name|void
name|svn_fs_x__dag_set_fs
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|node
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Dup NODEREV and all associated data into RESULT_POOL.    Leaves the id and is_fresh_txn_root fields as zero bytes. */
end_comment

begin_function
specifier|static
name|svn_fs_x__noderev_t
modifier|*
name|copy_node_revision
parameter_list|(
name|svn_fs_x__noderev_t
modifier|*
name|noderev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|nr
init|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|noderev
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|noderev
operator|->
name|copyfrom_path
condition|)
name|nr
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|noderev
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|nr
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
name|nr
operator|->
name|data_rep
operator|=
name|svn_fs_x__rep_copy
argument_list|(
name|noderev
operator|->
name|data_rep
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|nr
operator|->
name|prop_rep
operator|=
name|svn_fs_x__rep_copy
argument_list|(
name|noderev
operator|->
name|prop_rep
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|created_path
condition|)
name|nr
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|noderev
operator|->
name|created_path
argument_list|)
expr_stmt|;
return|return
name|nr
return|;
block|}
end_function

begin_comment
comment|/* Set *NODEREV_P to the cached node-revision for NODE.    If the node-revision was not already cached in NODE, read it in,    allocating the cache in NODE->NODE_POOL.     If you plan to change the contents of NODE, be careful!  We're    handing you a pointer directly to our cached node-revision, not    your own copy.  If you change it as part of some operation, but    then some Berkeley DB function deadlocks or gets an error, you'll    need to back out your changes, or else the cache will reflect    changes that never got committed.  It's probably best not to change    the structure at all.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_node_revision
parameter_list|(
name|svn_fs_x__noderev_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
comment|/* If we've already got a copy, there's no need to read it in.  */
if|if
condition|(
operator|!
name|node
operator|->
name|node_revision
condition|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|node
operator|->
name|node_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
operator|->
name|fs
argument_list|,
operator|&
name|node
operator|->
name|id
argument_list|,
name|node
operator|->
name|node_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|->
name|node_revision
operator|=
name|noderev
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
comment|/* Now NODE->node_revision is set.  */
operator|*
name|noderev_p
operator|=
name|node
operator|->
name|node_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the node revision ID of NODE.  The value returned is shared    with NODE, and will be deallocated when NODE is.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_node_id
parameter_list|(
name|svn_fs_x__id_t
modifier|*
name|node_id
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|node_id
operator|=
name|noderev
operator|->
name|node_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the node revision ID of NODE.  The value returned is shared    with NODE, and will be deallocated when NODE is.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_copy_id
parameter_list|(
name|svn_fs_x__id_t
modifier|*
name|copy_id
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|copy_id
operator|=
name|noderev
operator|->
name|copy_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the node ID of NODE.  The value returned is shared with NODE,    and will be deallocated when NODE is.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_related_node
parameter_list|(
name|svn_boolean_t
modifier|*
name|same
parameter_list|,
name|dag_node_t
modifier|*
name|lhs
parameter_list|,
name|dag_node_t
modifier|*
name|rhs
parameter_list|)
block|{
name|svn_fs_x__id_t
name|lhs_node
decl_stmt|,
name|rhs_node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__dag_get_node_id
argument_list|(
operator|&
name|lhs_node
argument_list|,
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__dag_get_node_id
argument_list|(
operator|&
name|rhs_node
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|same
operator|=
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|lhs_node
argument_list|,
operator|&
name|rhs_node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_same_line_of_history
parameter_list|(
name|svn_boolean_t
modifier|*
name|same
parameter_list|,
name|dag_node_t
modifier|*
name|lhs
parameter_list|,
name|dag_node_t
modifier|*
name|rhs
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|lhs_noderev
decl_stmt|,
modifier|*
name|rhs_noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|lhs_noderev
argument_list|,
name|lhs
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|rhs_noderev
argument_list|,
name|rhs
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|same
operator|=
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|lhs_noderev
operator|->
name|node_id
argument_list|,
operator|&
name|rhs_noderev
operator|->
name|node_id
argument_list|)
operator|&&
name|svn_fs_x__id_eq
argument_list|(
operator|&
name|lhs_noderev
operator|->
name|copy_id
argument_list|,
operator|&
name|rhs_noderev
operator|->
name|copy_id
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_boolean_t
name|svn_fs_x__dag_check_mutable
parameter_list|(
specifier|const
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|svn_fs_x__is_txn
argument_list|(
name|svn_fs_x__dag_get_id
argument_list|(
name|node
argument_list|)
operator|->
name|change_set
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|new_node
decl_stmt|;
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Construct the node. */
name|new_node
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|new_node
operator|->
name|id
operator|=
operator|*
name|id
expr_stmt|;
name|new_node
operator|->
name|hint
operator|=
name|APR_SIZE_MAX
expr_stmt|;
comment|/* Grab the contents so we can inspect the node's kind and created path. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|node_pool
operator|=
name|result_pool
expr_stmt|;
name|new_node
operator|->
name|node_revision
operator|=
name|noderev
expr_stmt|;
comment|/* Initialize the KIND and CREATED_PATH attributes */
name|new_node
operator|->
name|kind
operator|=
name|noderev
operator|->
name|kind
expr_stmt|;
name|new_node
operator|->
name|created_path
operator|=
name|noderev
operator|->
name|created_path
expr_stmt|;
comment|/* Support our quirky svn_fs_node_created_rev API.      Untouched txn roots report the base rev as theirs. */
name|new_node
operator|->
name|revision
operator|=
operator|(
name|svn_fs_x__is_fresh_txn_root
argument_list|(
name|noderev
argument_list|)
condition|?
name|svn_fs_x__get_revnum
argument_list|(
name|noderev
operator|->
name|predecessor_id
operator|.
name|change_set
argument_list|)
else|:
name|svn_fs_x__get_revnum
argument_list|(
name|id
operator|->
name|change_set
argument_list|)
operator|)
expr_stmt|;
comment|/* Return a fresh new node */
operator|*
name|node
operator|=
name|new_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_revnum_t
name|svn_fs_x__dag_get_revision
parameter_list|(
specifier|const
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
return|return
name|node
operator|->
name|revision
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_predecessor_id
parameter_list|(
name|svn_fs_x__id_t
modifier|*
name|id_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|noderev
operator|->
name|predecessor_id
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_predecessor_count
parameter_list|(
name|int
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_mergeinfo_count
parameter_list|(
name|apr_int64_t
modifier|*
name|count
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|count
operator|=
name|noderev
operator|->
name|mergeinfo_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_has_mergeinfo
parameter_list|(
name|svn_boolean_t
modifier|*
name|has_mergeinfo
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|has_mergeinfo
operator|=
name|noderev
operator|->
name|has_mergeinfo
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_has_descendants_with_mergeinfo
parameter_list|(
name|svn_boolean_t
modifier|*
name|do_they
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
operator|*
name|do_they
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|>
literal|1
condition|)
operator|*
name|do_they
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|==
literal|1
operator|&&
operator|!
name|noderev
operator|->
name|has_mergeinfo
condition|)
operator|*
name|do_they
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|do_they
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Directory node functions ***/
end_comment

begin_comment
comment|/* Some of these are helpers for functions outside this section. */
end_comment

begin_comment
comment|/* Set *ID_P to the noderev-id for entry NAME in PARENT.  If no such    entry, set *ID_P to NULL but do not error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dir_entry_id_from_node
parameter_list|(
name|svn_fs_x__id_t
modifier|*
name|id_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__dirent_t
modifier|*
name|dirent
decl_stmt|;
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get entries of non-directory"
argument_list|)
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to open node with an illegal name '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Get a dirent hash for this directory. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__rep_contents_dir_entry
argument_list|(
operator|&
name|dirent
argument_list|,
name|parent
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|name
argument_list|,
operator|&
name|parent
operator|->
name|hint
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent
condition|)
operator|*
name|id_p
operator|=
name|dirent
operator|->
name|id
expr_stmt|;
else|else
name|svn_fs_x__id_reset
argument_list|(
name|id_p
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Add or set in PARENT a directory entry NAME pointing to ID.    Temporary allocations are done in SCRATCH_POOL.     Assumptions:    - PARENT is a mutable directory.    - ID does not refer to an ancestor of parent    - NAME is a single path component */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_entry
parameter_list|(
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|parent_noderev
decl_stmt|;
comment|/* Get the parent's node-revision. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the new entry. */
return|return
name|svn_fs_x__set_entry
argument_list|(
name|parent
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|parent_noderev
argument_list|,
name|name
argument_list|,
name|id
argument_list|,
name|kind
argument_list|,
name|parent
operator|->
name|node_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Make a new entry named NAME in PARENT.  If IS_DIR is true, then the    node revision the new entry points to will be a directory, else it    will be a file.  The new node will be allocated in RESULT_POOL.  PARENT    must be mutable, and must not have an entry named NAME.     Use SCRATCH_POOL for all temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_entry
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_boolean_t
name|is_dir
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
name|new_noderev
decl_stmt|,
modifier|*
name|parent_noderev
decl_stmt|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to create a node with an illegal name '%s'"
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that parent is a directory */
if|if
condition|(
name|parent
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to create entry in non-directory parent"
argument_list|)
argument_list|)
return|;
comment|/* Check that the parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to clone child of non-mutable node"
argument_list|)
argument_list|)
return|;
comment|/* Create the new node's NODE-REVISION */
name|memset
argument_list|(
operator|&
name|new_noderev
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|new_noderev
argument_list|)
argument_list|)
expr_stmt|;
name|new_noderev
operator|.
name|kind
operator|=
name|is_dir
condition|?
name|svn_node_dir
else|:
name|svn_node_file
expr_stmt|;
name|new_noderev
operator|.
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|parent_path
argument_list|,
name|name
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|new_noderev
operator|.
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|parent_noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
name|new_noderev
operator|.
name|copyroot_rev
operator|=
name|parent_noderev
operator|->
name|copyroot_rev
expr_stmt|;
name|new_noderev
operator|.
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|new_noderev
operator|.
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|svn_fs_x__id_reset
argument_list|(
operator|&
name|new_noderev
operator|.
name|predecessor_id
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__create_node
argument_list|(
name|svn_fs_x__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
operator|&
name|new_noderev
argument_list|,
operator|&
name|parent_noderev
operator|->
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a new dag_node_t for our new node */
name|SVN_ERR
argument_list|(
name|svn_fs_x__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|svn_fs_x__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
operator|&
name|new_noderev
operator|.
name|noderev_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can safely call set_entry because we already know that      PARENT is mutable, and we just created CHILD, so we know it has      no ancestors (therefore, PARENT cannot be an ancestor of CHILD) */
return|return
name|set_entry
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
operator|&
name|new_noderev
operator|.
name|noderev_id
argument_list|,
name|new_noderev
operator|.
name|kind
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_dir_entries
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|entries
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Can't get entries of non-directory"
argument_list|)
argument_list|)
return|;
return|return
name|svn_fs_x__rep_contents_dir
argument_list|(
name|entries
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_set_entry
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry_name
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Check it's a directory. */
if|if
condition|(
name|node
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set entry in non-directory node"
argument_list|)
argument_list|)
return|;
comment|/* Check it's mutable. */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to set entry in immutable node"
argument_list|)
argument_list|)
return|;
return|return
name|set_entry
argument_list|(
name|node
argument_list|,
name|entry_name
argument_list|,
name|id
argument_list|,
name|kind
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Proplists. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|proplist_p
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|proplist_p
operator|=
name|proplist
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_set_proplist
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_hash_t
modifier|*
name|proplist
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Sanity check: this node better be mutable! */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_x__id_unparse
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Can't set proplist on *immutable* node-revision %s"
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set the new proplist. */
return|return
name|svn_fs_x__set_proplist
argument_list|(
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|proplist
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_increment_mergeinfo_count
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_int64_t
name|increment
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Sanity check: this node better be mutable! */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_x__id_unparse
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Can't increment mergeinfo count on *immutable* node-revision %s"
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
if|if
condition|(
name|increment
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|mergeinfo_count
operator|+=
name|increment
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|<
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_x__id_unparse
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Can't increment mergeinfo count on node-revision %%s "
literal|"to negative value %%%s"
argument_list|)
argument_list|,
name|APR_INT64_T_FMT
argument_list|)
argument_list|,
name|idstr
operator|->
name|data
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
return|;
block|}
if|if
condition|(
name|noderev
operator|->
name|mergeinfo_count
operator|>
literal|1
operator|&&
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_x__id_unparse
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Can't increment mergeinfo count on *file* "
literal|"node-revision %%s to %%%s (> 1)"
argument_list|)
argument_list|,
name|APR_INT64_T_FMT
argument_list|)
argument_list|,
name|idstr
operator|->
name|data
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
return|;
block|}
comment|/* Flush it out. */
return|return
name|svn_fs_x__put_node_revision
argument_list|(
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_set_has_mergeinfo
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_boolean_t
name|has_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Sanity check: this node better be mutable! */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|idstr
init|=
name|svn_fs_x__id_unparse
argument_list|(
operator|&
name|node
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Can't set mergeinfo flag on *immutable* node-revision %s"
argument_list|,
name|idstr
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Go get a fresh NODE-REVISION for this node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|has_mergeinfo
operator|=
name|has_mergeinfo
expr_stmt|;
comment|/* Flush it out. */
return|return
name|svn_fs_x__put_node_revision
argument_list|(
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Roots. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_revision_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__id_t
name|root_id
decl_stmt|;
name|svn_fs_x__init_rev_root
argument_list|(
operator|&
name|root_id
argument_list|,
name|rev
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
operator|&
name|root_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_txn_root
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__id_t
name|root_id
decl_stmt|;
name|svn_fs_x__init_txn_root
argument_list|(
operator|&
name|root_id
argument_list|,
name|txn_id
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__dag_get_node
argument_list|(
name|node_p
argument_list|,
name|fs
argument_list|,
operator|&
name|root_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_clone_child
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|copy_id
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|svn_boolean_t
name|is_parent_copyroot
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|cur_entry
decl_stmt|;
comment|/* parent's current entry named NAME */
specifier|const
name|svn_fs_x__id_t
modifier|*
name|new_node_id
decl_stmt|;
comment|/* node id we'll put into NEW_NODE */
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_x__dag_get_fs
argument_list|(
name|parent
argument_list|)
decl_stmt|;
comment|/* First check that the parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to clone child of non-mutable node"
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to make a child clone with an illegal name '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Find the node named NAME in PARENT's entries list if it exists. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__dag_open
argument_list|(
operator|&
name|cur_entry
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cur_entry
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to open non-existent child node '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Check for mutability in the node we found.  If it's mutable, we      don't need to clone it. */
if|if
condition|(
name|svn_fs_x__dag_check_mutable
argument_list|(
name|cur_entry
argument_list|)
condition|)
block|{
comment|/* This has already been cloned */
name|new_node_id
operator|=
name|svn_fs_x__dag_get_id
argument_list|(
name|cur_entry
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|,
modifier|*
name|parent_noderev
decl_stmt|;
comment|/* Go get a fresh NODE-REVISION for current child node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|cur_entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_parent_copyroot
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|copyroot_rev
operator|=
name|parent_noderev
operator|->
name|copyroot_rev
expr_stmt|;
name|noderev
operator|->
name|copyroot_path
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|parent_noderev
operator|->
name|copyroot_path
argument_list|)
expr_stmt|;
block|}
name|noderev
operator|->
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
name|noderev
operator|->
name|copyfrom_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|noderev
operator|->
name|predecessor_id
operator|=
name|noderev
operator|->
name|noderev_id
expr_stmt|;
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|noderev
operator|->
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|parent_path
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_id
operator|==
name|NULL
condition|)
name|copy_id
operator|=
operator|&
name|noderev
operator|->
name|copy_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__create_successor
argument_list|(
name|fs
argument_list|,
name|noderev
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_node_id
operator|=
operator|&
name|noderev
operator|->
name|noderev_id
expr_stmt|;
comment|/* Replace the ID in the parent's ENTRY list with the ID which          refers to the mutable clone of this child. */
name|SVN_ERR
argument_list|(
name|set_entry
argument_list|(
name|parent
argument_list|,
name|name
argument_list|,
name|new_node_id
argument_list|,
name|noderev
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Initialize the youngster. */
return|return
name|svn_fs_x__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|fs
argument_list|,
name|new_node_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete all mutable node revisions reachable from node ID, including    ID itself, from FS's `nodes' table.  Also delete any mutable    representations and strings associated with that node revision.    ID may refer to a file or directory, which may be mutable or immutable.     Use SCRATCH_POOL for temporary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_if_mutable
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* Get the node. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If immutable, do nothing and return immediately. */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Else it's mutable.  Recurse on directories... */
if|if
condition|(
name|node
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
comment|/* Loop over directory entries */
name|SVN_ERR
argument_list|(
name|svn_fs_x__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|node
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_fs_x__id_t
modifier|*
name|noderev_id
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|entries
argument_list|,
name|i
argument_list|,
name|svn_fs_x__dirent_t
operator|*
argument_list|)
operator|->
name|id
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|delete_if_mutable
argument_list|(
name|fs
argument_list|,
name|noderev_id
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
comment|/* ... then delete the node itself, after deleting any mutable      representations and strings it points to. */
return|return
name|svn_fs_x__delete_node_revision
argument_list|(
name|fs
argument_list|,
name|id
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_delete
parameter_list|(
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|parent_noderev
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|parent
operator|->
name|fs
decl_stmt|;
name|svn_fs_x__dirent_t
modifier|*
name|dirent
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
comment|/* Make sure parent is a directory. */
if|if
condition|(
name|parent
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_DIRECTORY
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to delete entry '%s' from *non*-directory node"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure parent is mutable. */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|parent
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to delete entry '%s' from immutable directory node"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Make sure that NAME is a single path component. */
if|if
condition|(
operator|!
name|svn_path_is_single_path_component
argument_list|(
name|name
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to delete a node with an illegal name '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* Get a fresh NODE-REVISION for the parent node. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|parent_noderev
argument_list|,
name|parent
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Search this directory for a dirent with that NAME. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__rep_contents_dir_entry
argument_list|(
operator|&
name|dirent
argument_list|,
name|fs
argument_list|,
name|parent_noderev
argument_list|,
name|name
argument_list|,
operator|&
name|parent
operator|->
name|hint
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we never found ID in ENTRIES (perhaps because there are no      ENTRIES, perhaps because ID just isn't in the existing ENTRIES      ... it doesn't matter), return an error.  */
if|if
condition|(
operator|!
name|dirent
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_ENTRY
argument_list|,
name|NULL
argument_list|,
literal|"Delete failed--directory has no entry '%s'"
argument_list|,
name|name
argument_list|)
return|;
comment|/* If mutable, remove it and any mutable children from db. */
name|SVN_ERR
argument_list|(
name|delete_if_mutable
argument_list|(
name|parent
operator|->
name|fs
argument_list|,
operator|&
name|dirent
operator|->
name|id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Remove this entry from its parent's entries list. */
return|return
name|svn_fs_x__set_entry
argument_list|(
name|parent
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|parent_noderev
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|,
name|svn_node_unknown
argument_list|,
name|parent
operator|->
name|node_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_make_file
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Call our little helper function */
return|return
name|make_entry
argument_list|(
name|child_p
argument_list|,
name|parent
argument_list|,
name|parent_path
argument_list|,
name|name
argument_list|,
name|FALSE
argument_list|,
name|txn_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_make_dir
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Call our little helper function */
return|return
name|make_entry
argument_list|(
name|child_p
argument_list|,
name|parent
argument_list|,
name|parent_path
argument_list|,
name|name
argument_list|,
name|TRUE
argument_list|,
name|txn_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get textual contents of a *non*-file node"
argument_list|)
return|;
comment|/* Go get a fresh node-revision for FILE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get a stream to the contents. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__get_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
operator|->
name|data_rep
argument_list|,
name|TRUE
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|contents
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|src_noderev
decl_stmt|;
name|svn_fs_x__noderev_t
modifier|*
name|tgt_noderev
decl_stmt|;
comment|/* Make sure our nodes are files. */
if|if
condition|(
operator|(
name|source
operator|&&
name|source
operator|->
name|kind
operator|!=
name|svn_node_file
operator|)
operator|||
name|target
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get textual contents of a *non*-file node"
argument_list|)
return|;
comment|/* Go get fresh node-revisions for the nodes. */
if|if
condition|(
name|source
condition|)
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|src_noderev
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|src_noderev
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|tgt_noderev
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the delta stream. */
return|return
name|svn_fs_x__get_file_delta_stream
argument_list|(
name|stream_p
argument_list|,
name|target
operator|->
name|fs
argument_list|,
name|src_noderev
argument_list|,
name|tgt_noderev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_try_process_file_contents
parameter_list|(
name|svn_boolean_t
modifier|*
name|success
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|svn_fs_process_contents_func_t
name|processor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get fresh node-revisions for the nodes. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__try_process_file_contents
argument_list|(
name|success
argument_list|,
name|node
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|processor
argument_list|,
name|baton
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get length of a *non*-file node"
argument_list|)
return|;
comment|/* Go get a fresh node-revision for FILE, and . */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__file_length
argument_list|(
name|length
argument_list|,
name|noderev
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to get checksum of a *non*-file node"
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_x__file_checksum
argument_list|(
name|checksum
argument_list|,
name|noderev
argument_list|,
name|kind
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_edit_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|dag_node_t
modifier|*
name|file
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
name|svn_stream_t
modifier|*
name|ws
decl_stmt|;
comment|/* Make sure our node is a file. */
if|if
condition|(
name|file
operator|->
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to set textual contents of a *non*-file node"
argument_list|)
return|;
comment|/* Make sure our node is mutable. */
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|file
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
literal|"Attempted to set textual contents of an immutable node"
argument_list|)
return|;
comment|/* Get the node revision. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__set_contents
argument_list|(
operator|&
name|ws
argument_list|,
name|file
operator|->
name|fs
argument_list|,
name|noderev
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|ws
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_finalize_edits
parameter_list|(
name|dag_node_t
modifier|*
name|file
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|if
condition|(
name|checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|file_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__dag_file_checksum
argument_list|(
operator|&
name|file_checksum
argument_list|,
name|file
argument_list|,
name|checksum
operator|->
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|checksum
argument_list|,
name|file_checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|checksum
argument_list|,
name|file_checksum
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|file
operator|->
name|created_path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|dag_node_t
modifier|*
name|svn_fs_x__dag_dup
parameter_list|(
specifier|const
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* Allocate our new node. */
name|dag_node_t
modifier|*
name|new_node
init|=
name|apr_pmemdup
argument_list|(
name|result_pool
argument_list|,
name|node
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_node
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Only copy cached svn_fs_x__noderev_t for immutable nodes. */
if|if
condition|(
name|node
operator|->
name|node_revision
operator|&&
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|new_node
operator|->
name|node_revision
operator|=
name|copy_node_revision
argument_list|(
name|node
operator|->
name|node_revision
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|new_node
operator|->
name|created_path
operator|=
name|new_node
operator|->
name|node_revision
operator|->
name|created_path
expr_stmt|;
block|}
else|else
block|{
name|new_node
operator|->
name|node_revision
operator|=
name|NULL
expr_stmt|;
name|new_node
operator|->
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|node
operator|->
name|created_path
argument_list|)
expr_stmt|;
block|}
name|new_node
operator|->
name|node_pool
operator|=
name|result_pool
expr_stmt|;
return|return
name|new_node
return|;
block|}
end_function

begin_function
name|dag_node_t
modifier|*
name|svn_fs_x__dag_copy_into_pool
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
return|return
operator|(
name|node
operator|->
name|node_pool
operator|==
name|result_pool
condition|?
name|node
else|:
name|svn_fs_x__dag_dup
argument_list|(
name|node
argument_list|,
name|result_pool
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_serialize
parameter_list|(
name|void
modifier|*
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|data_len
parameter_list|,
name|void
modifier|*
name|in
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
init|=
name|in
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|serialized
decl_stmt|;
comment|/* create an serialization context and serialize the dag node as root */
name|svn_temp_serializer__context_t
modifier|*
name|context
init|=
name|svn_temp_serializer__init
argument_list|(
name|node
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|node
argument_list|)
argument_list|,
literal|1024
operator|-
name|SVN_TEMP_SERIALIZER__OVERHEAD
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* for mutable nodes, we will _never_ cache the noderev */
if|if
condition|(
name|node
operator|->
name|node_revision
operator|&&
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|node
argument_list|)
condition|)
block|{
name|svn_fs_x__noderev_serialize
argument_list|(
name|context
argument_list|,
operator|&
name|node
operator|->
name|node_revision
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_temp_serializer__set_null
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|node
operator|->
name|node_revision
argument_list|)
expr_stmt|;
name|svn_temp_serializer__add_string
argument_list|(
name|context
argument_list|,
operator|&
name|node
operator|->
name|created_path
argument_list|)
expr_stmt|;
block|}
comment|/* The deserializer will use its own pool. */
name|svn_temp_serializer__set_null
argument_list|(
name|context
argument_list|,
operator|(
specifier|const
name|void
operator|*
specifier|const
operator|*
operator|)
operator|&
name|node
operator|->
name|node_pool
argument_list|)
expr_stmt|;
comment|/* return serialized data */
name|serialized
operator|=
name|svn_temp_serializer__get
argument_list|(
name|context
argument_list|)
expr_stmt|;
operator|*
name|data
operator|=
name|serialized
operator|->
name|data
expr_stmt|;
operator|*
name|data_len
operator|=
name|serialized
operator|->
name|len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_deserialize
parameter_list|(
name|void
modifier|*
modifier|*
name|out
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|data_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|node
init|=
operator|(
name|dag_node_t
operator|*
operator|)
name|data
decl_stmt|;
if|if
condition|(
name|data_len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Empty noderev in cache"
argument_list|)
argument_list|)
return|;
comment|/* Copy the _full_ buffer as it also contains the sub-structures. */
name|node
operator|->
name|fs
operator|=
name|NULL
expr_stmt|;
comment|/* fixup all references to sub-structures */
name|svn_fs_x__noderev_deserialize
argument_list|(
name|node
argument_list|,
operator|&
name|node
operator|->
name|node_revision
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|node
operator|->
name|node_pool
operator|=
name|pool
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|node_revision
condition|)
name|node
operator|->
name|created_path
operator|=
name|node
operator|->
name|node_revision
operator|->
name|created_path
expr_stmt|;
else|else
name|svn_temp_deserializer__resolve
argument_list|(
name|node
argument_list|,
operator|(
name|void
operator|*
operator|*
operator|)
operator|&
name|node
operator|->
name|created_path
argument_list|)
expr_stmt|;
comment|/* return result */
operator|*
name|out
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_open
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|child_p
parameter_list|,
name|dag_node_t
modifier|*
name|parent
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__id_t
name|node_id
decl_stmt|;
comment|/* Ensure that NAME exists in PARENT's entry list. */
name|SVN_ERR
argument_list|(
name|dir_entry_id_from_node
argument_list|(
operator|&
name|node_id
argument_list|,
name|parent
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_fs_x__id_used
argument_list|(
operator|&
name|node_id
argument_list|)
condition|)
block|{
operator|*
name|child_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Now get the node that was requested. */
return|return
name|svn_fs_x__dag_get_node
argument_list|(
name|child_p
argument_list|,
name|svn_fs_x__dag_get_fs
argument_list|(
name|parent
argument_list|)
argument_list|,
operator|&
name|node_id
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_copy
parameter_list|(
name|dag_node_t
modifier|*
name|to_node
parameter_list|,
specifier|const
name|char
modifier|*
name|entry
parameter_list|,
name|dag_node_t
modifier|*
name|from_node
parameter_list|,
name|svn_boolean_t
name|preserve_history
parameter_list|,
name|svn_revnum_t
name|from_rev
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
name|svn_fs_x__txn_id_t
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|svn_fs_x__id_t
modifier|*
name|id
decl_stmt|;
if|if
condition|(
name|preserve_history
condition|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|from_noderev
decl_stmt|,
modifier|*
name|to_noderev
decl_stmt|;
name|svn_fs_x__id_t
name|copy_id
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_x__dag_get_fs
argument_list|(
name|from_node
argument_list|)
decl_stmt|;
comment|/* Make a copy of the original node revision. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|from_noderev
argument_list|,
name|from_node
argument_list|)
argument_list|)
expr_stmt|;
name|to_noderev
operator|=
name|copy_node_revision
argument_list|(
name|from_noderev
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Reserve a copy ID for this new copy. */
name|SVN_ERR
argument_list|(
name|svn_fs_x__reserve_copy_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a successor with its predecessor pointing at the copy          source. */
name|to_noderev
operator|->
name|predecessor_id
operator|=
name|to_noderev
operator|->
name|noderev_id
expr_stmt|;
name|to_noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
name|to_noderev
operator|->
name|created_path
operator|=
name|svn_fspath__join
argument_list|(
name|svn_fs_x__dag_get_created_path
argument_list|(
name|to_node
argument_list|)
argument_list|,
name|entry
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|to_noderev
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|scratch_pool
argument_list|,
name|from_path
argument_list|)
expr_stmt|;
name|to_noderev
operator|->
name|copyfrom_rev
operator|=
name|from_rev
expr_stmt|;
comment|/* Set the copyroot equal to our own id. */
name|to_noderev
operator|->
name|copyroot_path
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_x__create_successor
argument_list|(
name|fs
argument_list|,
name|to_noderev
argument_list|,
operator|&
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|id
operator|=
operator|&
name|to_noderev
operator|->
name|noderev_id
expr_stmt|;
block|}
else|else
comment|/* don't preserve history */
block|{
name|id
operator|=
name|svn_fs_x__dag_get_id
argument_list|(
name|from_node
argument_list|)
expr_stmt|;
block|}
comment|/* Set the entry in to_node to the new id. */
return|return
name|svn_fs_x__dag_set_entry
argument_list|(
name|to_node
argument_list|,
name|entry
argument_list|,
name|id
argument_list|,
name|from_node
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Comparison. ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_things_different
parameter_list|(
name|svn_boolean_t
modifier|*
name|props_changed
parameter_list|,
name|svn_boolean_t
modifier|*
name|contents_changed
parameter_list|,
name|dag_node_t
modifier|*
name|node1
parameter_list|,
name|dag_node_t
modifier|*
name|node2
parameter_list|,
name|svn_boolean_t
name|strict
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev1
decl_stmt|,
modifier|*
name|noderev2
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_boolean_t
name|same
decl_stmt|;
comment|/* If we have no place to store our results, don't bother doing      anything. */
if|if
condition|(
operator|!
name|props_changed
operator|&&
operator|!
name|contents_changed
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|fs
operator|=
name|svn_fs_x__dag_get_fs
argument_list|(
name|node1
argument_list|)
expr_stmt|;
comment|/* The node revision skels for these two nodes. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev1
argument_list|,
name|node1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev2
argument_list|,
name|node2
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Compare property keys. */
if|if
condition|(
name|props_changed
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_x__prop_rep_equal
argument_list|(
operator|&
name|same
argument_list|,
name|fs
argument_list|,
name|noderev1
argument_list|,
name|noderev2
argument_list|,
name|strict
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|props_changed
operator|=
operator|!
name|same
expr_stmt|;
block|}
comment|/* Compare contents keys. */
if|if
condition|(
name|contents_changed
operator|!=
name|NULL
condition|)
operator|*
name|contents_changed
operator|=
operator|!
name|svn_fs_x__file_text_rep_equal
argument_list|(
name|noderev1
operator|->
name|data_rep
argument_list|,
name|noderev2
operator|->
name|data_rep
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_copyroot
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get a fresh node-revision for NODE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
name|noderev
operator|->
name|copyroot_rev
expr_stmt|;
operator|*
name|path
operator|=
name|noderev
operator|->
name|copyroot_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_copyfrom_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get a fresh node-revision for NODE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
name|noderev
operator|->
name|copyfrom_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_get_copyfrom_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Go get a fresh node-revision for NODE. */
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|path
operator|=
name|noderev
operator|->
name|copyfrom_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_x__dag_update_ancestry
parameter_list|(
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_fs_x__noderev_t
modifier|*
name|source_noderev
decl_stmt|,
modifier|*
name|target_noderev
decl_stmt|;
if|if
condition|(
operator|!
name|svn_fs_x__dag_check_mutable
argument_list|(
name|target
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Attempted to update ancestry of non-mutable node"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|source_noderev
argument_list|,
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_node_revision
argument_list|(
operator|&
name|target_noderev
argument_list|,
name|target
argument_list|)
argument_list|)
expr_stmt|;
name|target_noderev
operator|->
name|predecessor_id
operator|=
name|source_noderev
operator|->
name|noderev_id
expr_stmt|;
name|target_noderev
operator|->
name|predecessor_count
operator|=
name|source_noderev
operator|->
name|predecessor_count
expr_stmt|;
name|target_noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
return|return
name|svn_fs_x__put_node_revision
argument_list|(
name|target
operator|->
name|fs
argument_list|,
name|target_noderev
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

end_unit

