begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * editorp.c :  Driving and consuming an editor across an svn connection  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra_svn.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_editor.h"
end_include

begin_include
include|#
directive|include
file|"ra_svn.h"
end_include

begin_comment
comment|/*  * Both the client and server in the svn protocol need to drive and  * consume editors.  For a commit, the client drives and the server  * consumes; for an update/switch/status/diff, the server drives and  * the client consumes.  This file provides a generic framework for  * marshalling and unmarshalling editor operations over an svn  * connection; both ends are useful for both server and client.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ra_svn_edit_baton_t
block|{
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|svn_ra_svn_edit_callback
name|callback
decl_stmt|;
comment|/* Called on successful completion. */
name|void
modifier|*
name|callback_baton
decl_stmt|;
name|int
name|next_token
decl_stmt|;
name|svn_boolean_t
name|got_status
decl_stmt|;
block|}
name|ra_svn_edit_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Works for both directories and files. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ra_svn_baton_t
block|{
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|ra_svn_edit_baton_t
modifier|*
name|eb
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
block|}
name|ra_svn_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ra_svn_driver_state_t
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|tokens
decl_stmt|;
name|svn_boolean_t
modifier|*
name|aborted
decl_stmt|;
name|svn_boolean_t
name|done
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|apr_pool_t
modifier|*
name|file_pool
decl_stmt|;
name|int
name|file_refs
decl_stmt|;
name|svn_boolean_t
name|for_replay
decl_stmt|;
block|}
name|ra_svn_driver_state_t
typedef|;
end_typedef

begin_comment
comment|/* Works for both directories and files; however, the pool handling is    different for files.  To save space during commits (where file    batons generally last until the end of the commit), token entries    for files are all created in a single reference-counted pool (the    file_pool member of the driver state structure), which is cleared    at close_file time when the reference count hits zero.  So the pool    field in this structure is vestigial for files, and we use it for a    different purpose instead: at apply-textdelta time, we set it to a    subpool of the file pool, which is destroyed in textdelta-end. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|ra_svn_token_entry_t
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
name|svn_boolean_t
name|is_file
decl_stmt|;
name|svn_stream_t
modifier|*
name|dstream
decl_stmt|;
comment|/* svndiff stream for apply_textdelta */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|ra_svn_token_entry_t
typedef|;
end_typedef

begin_comment
comment|/* --- CONSUMING AN EDITOR BY PASSING EDIT OPERATIONS OVER THE NET --- */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|make_token
parameter_list|(
name|char
name|type
parameter_list|,
name|ra_svn_edit_baton_t
modifier|*
name|eb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%c%d"
argument_list|,
name|type
argument_list|,
name|eb
operator|->
name|next_token
operator|++
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|ra_svn_baton_t
modifier|*
name|ra_svn_make_baton
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|ra_svn_edit_baton_t
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
decl_stmt|;
name|b
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|b
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|b
operator|->
name|eb
operator|=
name|eb
expr_stmt|;
name|b
operator|->
name|token
operator|=
name|token
expr_stmt|;
return|return
name|b
return|;
block|}
end_function

begin_comment
comment|/* Check for an early error status report from the consumer.  If we  * get one, abort the edit and return the error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_for_error_internal
parameter_list|(
name|ra_svn_edit_baton_t
modifier|*
name|eb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|eb
operator|->
name|got_status
argument_list|)
expr_stmt|;
comment|/* reset TX counter */
name|eb
operator|->
name|conn
operator|->
name|written_since_error_check
operator|=
literal|0
expr_stmt|;
comment|/* if we weren't asked to always check, wait for at least the next TX */
name|eb
operator|->
name|conn
operator|->
name|may_check_for_error
operator|=
name|eb
operator|->
name|conn
operator|->
name|error_check_interval
operator|==
literal|0
expr_stmt|;
comment|/* any incoming data? */
if|if
condition|(
name|svn_ra_svn__input_waiting
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
condition|)
block|{
name|eb
operator|->
name|got_status
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_abort_edit
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We shouldn't get here if the consumer is doing its job. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Successful edit status returned too soon"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_for_error
parameter_list|(
name|ra_svn_edit_baton_t
modifier|*
name|eb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|eb
operator|->
name|conn
operator|->
name|may_check_for_error
condition|?
name|check_for_error_internal
argument_list|(
name|eb
argument_list|,
name|pool
argument_list|)
else|:
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_target_rev
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_target_rev
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|ra_svn_edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|make_token
argument_list|(
literal|'d'
argument_list|,
name|eb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_open_root
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_baton
operator|=
name|ra_svn_make_baton
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|eb
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|parent_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_delete_entry
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
name|b
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_add_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_path
parameter_list|,
name|svn_revnum_t
name|copy_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|make_token
argument_list|(
literal|'d'
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|copy_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copy_rev
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|copy_path
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copy_rev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_add_dir
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|token
argument_list|,
name|copy_path
argument_list|,
name|copy_rev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|ra_svn_make_baton
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_open_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|make_token
argument_list|(
literal|'d'
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_open_dir
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|token
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|child_baton
operator|=
name|ra_svn_make_baton
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|dir_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_change_dir_prop
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_close_dir
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|dir_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_close_dir
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_absent_dir
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|parent_baton
decl_stmt|;
comment|/* Avoid sending an unknown command if the other end doesn't support      absent-dir. */
if|if
condition|(
operator|!
name|svn_ra_svn_has_capability
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_ABSENT_ENTRIES
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_absent_dir
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copy_path
parameter_list|,
name|svn_revnum_t
name|copy_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|make_token
argument_list|(
literal|'c'
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|(
name|copy_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copy_rev
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|copy_path
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|copy_rev
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_add_file
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|token
argument_list|,
name|copy_path
argument_list|,
name|copy_rev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|ra_svn_make_baton
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
init|=
name|make_token
argument_list|(
literal|'c'
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_open_file
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|token
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|file_baton
operator|=
name|ra_svn_make_baton
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|eb
argument_list|,
name|token
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_svndiff_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|svn_string_t
name|str
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|str
operator|.
name|data
operator|=
name|data
expr_stmt|;
name|str
operator|.
name|len
operator|=
operator|*
name|len
expr_stmt|;
return|return
name|svn_ra_svn__write_cmd_textdelta_chunk
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|,
name|b
operator|->
name|token
argument_list|,
operator|&
name|str
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_svndiff_close_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_textdelta_end
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|,
name|b
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|wh
parameter_list|,
name|void
modifier|*
modifier|*
name|wh_baton
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|file_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|diff_stream
decl_stmt|;
comment|/* Tell the other side we're starting a text delta. */
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_apply_textdelta
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|base_checksum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Transform the window stream to an svndiff stream.  Reuse the    * file baton for the stream handler, since it has all the    * needed information. */
name|diff_stream
operator|=
name|svn_stream_create
argument_list|(
name|b
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|diff_stream
argument_list|,
name|ra_svn_svndiff_handler
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|diff_stream
argument_list|,
name|ra_svn_svndiff_close_handler
argument_list|)
expr_stmt|;
comment|/* If the connection does not support SVNDIFF1 or if we don't want to use    * compression, use the non-compressing "version 0" implementation */
if|if
condition|(
name|svn_ra_svn_compression_level
argument_list|(
name|b
operator|->
name|conn
argument_list|)
operator|>
literal|0
operator|&&
name|svn_ra_svn_has_capability
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_SVNDIFF1
argument_list|)
condition|)
name|svn_txdelta_to_svndiff3
argument_list|(
name|wh
argument_list|,
name|wh_baton
argument_list|,
name|diff_stream
argument_list|,
literal|1
argument_list|,
name|b
operator|->
name|conn
operator|->
name|compression_level
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_txdelta_to_svndiff3
argument_list|(
name|wh
argument_list|,
name|wh_baton
argument_list|,
name|diff_stream
argument_list|,
literal|0
argument_list|,
name|b
operator|->
name|conn
operator|->
name|compression_level
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|file_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_change_file_prop
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|file_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_close_file
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|b
operator|->
name|token
argument_list|,
name|text_checksum
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_absent_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_baton_t
modifier|*
name|b
init|=
name|parent_baton
decl_stmt|;
comment|/* Avoid sending an unknown command if the other end doesn't support      absent-file. */
if|if
condition|(
operator|!
name|svn_ra_svn_has_capability
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_ABSENT_ENTRIES
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|check_for_error
argument_list|(
name|b
operator|->
name|eb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_absent_file
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|b
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|eb
operator|->
name|got_status
argument_list|)
expr_stmt|;
name|eb
operator|->
name|got_status
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_close_edit
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__read_cmd_response
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_ra_svn__write_cmd_abort_edit
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
if|if
condition|(
name|eb
operator|->
name|callback
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|callback
argument_list|(
name|eb
operator|->
name|callback_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_abort_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_edit_baton_t
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|got_status
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_abort_edit
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|eb
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_ra_svn_get_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_ra_svn_edit_callback
name|callback
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|)
block|{
name|svn_delta_editor_t
modifier|*
name|ra_svn_editor
init|=
name|svn_delta_default_editor
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|ra_svn_edit_baton_t
modifier|*
name|eb
decl_stmt|;
name|eb
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|eb
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|eb
operator|->
name|callback_baton
operator|=
name|callback_baton
expr_stmt|;
name|eb
operator|->
name|next_token
operator|=
literal|0
expr_stmt|;
name|eb
operator|->
name|got_status
operator|=
name|FALSE
expr_stmt|;
name|ra_svn_editor
operator|->
name|set_target_revision
operator|=
name|ra_svn_target_rev
expr_stmt|;
name|ra_svn_editor
operator|->
name|open_root
operator|=
name|ra_svn_open_root
expr_stmt|;
name|ra_svn_editor
operator|->
name|delete_entry
operator|=
name|ra_svn_delete_entry
expr_stmt|;
name|ra_svn_editor
operator|->
name|add_directory
operator|=
name|ra_svn_add_dir
expr_stmt|;
name|ra_svn_editor
operator|->
name|open_directory
operator|=
name|ra_svn_open_dir
expr_stmt|;
name|ra_svn_editor
operator|->
name|change_dir_prop
operator|=
name|ra_svn_change_dir_prop
expr_stmt|;
name|ra_svn_editor
operator|->
name|close_directory
operator|=
name|ra_svn_close_dir
expr_stmt|;
name|ra_svn_editor
operator|->
name|absent_directory
operator|=
name|ra_svn_absent_dir
expr_stmt|;
name|ra_svn_editor
operator|->
name|add_file
operator|=
name|ra_svn_add_file
expr_stmt|;
name|ra_svn_editor
operator|->
name|open_file
operator|=
name|ra_svn_open_file
expr_stmt|;
name|ra_svn_editor
operator|->
name|apply_textdelta
operator|=
name|ra_svn_apply_textdelta
expr_stmt|;
name|ra_svn_editor
operator|->
name|change_file_prop
operator|=
name|ra_svn_change_file_prop
expr_stmt|;
name|ra_svn_editor
operator|->
name|close_file
operator|=
name|ra_svn_close_file
expr_stmt|;
name|ra_svn_editor
operator|->
name|absent_file
operator|=
name|ra_svn_absent_file
expr_stmt|;
name|ra_svn_editor
operator|->
name|close_edit
operator|=
name|ra_svn_close_edit
expr_stmt|;
name|ra_svn_editor
operator|->
name|abort_edit
operator|=
name|ra_svn_abort_edit
expr_stmt|;
operator|*
name|editor
operator|=
name|ra_svn_editor
expr_stmt|;
operator|*
name|edit_baton
operator|=
name|eb
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_editor__insert_shims
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|*
name|editor
argument_list|,
operator|*
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|conn
operator|->
name|shim_callbacks
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* --- DRIVING AN EDITOR --- */
end_comment

begin_comment
comment|/* Store a token entry.  The token string will be copied into pool. */
end_comment

begin_function
specifier|static
name|ra_svn_token_entry_t
modifier|*
name|store_token
parameter_list|(
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|svn_boolean_t
name|is_file
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|entry
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|token
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|entry
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
name|entry
operator|->
name|is_file
operator|=
name|is_file
expr_stmt|;
name|entry
operator|->
name|dstream
operator|=
name|NULL
expr_stmt|;
name|entry
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|ds
operator|->
name|tokens
argument_list|,
name|entry
operator|->
name|token
argument_list|,
name|entry
argument_list|)
expr_stmt|;
return|return
name|entry
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|lookup_token
parameter_list|(
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|svn_boolean_t
name|is_file
parameter_list|,
name|ra_svn_token_entry_t
modifier|*
modifier|*
name|entry
parameter_list|)
block|{
operator|*
name|entry
operator|=
name|svn_hash_gets
argument_list|(
name|ds
operator|->
name|tokens
argument_list|,
name|token
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|entry
operator|||
operator|(
operator|*
name|entry
operator|)
operator|->
name|is_file
operator|!=
name|is_file
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid file or dir token during edit"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_target_rev
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|set_target_revision
argument_list|(
name|ds
operator|->
name|edit_baton
argument_list|,
name|rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_open_root
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|void
modifier|*
name|root_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"(?r)c"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|ds
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|open_root
argument_list|(
name|ds
operator|->
name|edit_baton
argument_list|,
name|rev
argument_list|,
name|subpool
argument_list|,
operator|&
name|root_baton
argument_list|)
argument_list|)
expr_stmt|;
name|store_token
argument_list|(
name|ds
argument_list|,
name|root_baton
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_delete_entry
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?r)c"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|delete_entry
argument_list|(
name|path
argument_list|,
name|rev
argument_list|,
name|entry
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_add_dir
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|child_token
decl_stmt|,
modifier|*
name|copy_path
decl_stmt|;
name|svn_revnum_t
name|copy_rev
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|void
modifier|*
name|child_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"ccc(?cr)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|child_token
argument_list|,
operator|&
name|copy_path
argument_list|,
operator|&
name|copy_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|entry
operator|->
name|pool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Some operations pass COPY_PATH as a full URL (commits, etc.).      Others (replay, e.g.) deliver an fspath.  That's ... annoying. */
if|if
condition|(
name|copy_path
condition|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|copy_path
argument_list|)
condition|)
name|copy_path
operator|=
name|svn_uri_canonicalize
argument_list|(
name|copy_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|copy_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|copy_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|add_directory
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|baton
argument_list|,
name|copy_path
argument_list|,
name|copy_rev
argument_list|,
name|subpool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|store_token
argument_list|(
name|ds
argument_list|,
name|child_baton
argument_list|,
name|child_token
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_open_dir
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|child_token
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|void
modifier|*
name|child_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"ccc(?r)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|child_token
argument_list|,
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|entry
operator|->
name|pool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|open_directory
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|baton
argument_list|,
name|rev
argument_list|,
name|subpool
argument_list|,
operator|&
name|child_baton
argument_list|)
argument_list|)
expr_stmt|;
name|store_token
argument_list|(
name|ds
argument_list|,
name|child_baton
argument_list|,
name|child_token
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_change_dir_prop
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"cc(?s)"
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|entry
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|entry
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_close_dir
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
comment|/* Parse and look up the directory token. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the directory and destroy the baton. */
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|close_directory
argument_list|(
name|entry
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|ds
operator|->
name|tokens
argument_list|,
name|token
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|entry
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_absent_dir
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
comment|/* Parse parameters and look up the directory token. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"cc"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the editor. */
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|absent_directory
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_add_file
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|file_token
decl_stmt|,
modifier|*
name|copy_path
decl_stmt|;
name|svn_revnum_t
name|copy_rev
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|file_entry
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"ccc(?cr)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|file_token
argument_list|,
operator|&
name|copy_path
argument_list|,
operator|&
name|copy_rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|file_refs
operator|++
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Some operations pass COPY_PATH as a full URL (commits, etc.).      Others (replay, e.g.) deliver an fspath.  That's ... annoying. */
if|if
condition|(
name|copy_path
condition|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|copy_path
argument_list|)
condition|)
name|copy_path
operator|=
name|svn_uri_canonicalize
argument_list|(
name|copy_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|copy_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|copy_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|file_entry
operator|=
name|store_token
argument_list|(
name|ds
argument_list|,
name|NULL
argument_list|,
name|file_token
argument_list|,
name|TRUE
argument_list|,
name|ds
operator|->
name|file_pool
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|add_file
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|baton
argument_list|,
name|copy_path
argument_list|,
name|copy_rev
argument_list|,
name|ds
operator|->
name|file_pool
argument_list|,
operator|&
name|file_entry
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_open_file
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|,
modifier|*
name|file_token
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|,
modifier|*
name|file_entry
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"ccc(?r)"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|file_token
argument_list|,
operator|&
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|file_refs
operator|++
expr_stmt|;
name|path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|file_entry
operator|=
name|store_token
argument_list|(
name|ds
argument_list|,
name|NULL
argument_list|,
name|file_token
argument_list|,
name|TRUE
argument_list|,
name|ds
operator|->
name|file_pool
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|open_file
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|baton
argument_list|,
name|rev
argument_list|,
name|ds
operator|->
name|file_pool
argument_list|,
operator|&
name|file_entry
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_apply_textdelta
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_txdelta_window_handler_t
name|wh
decl_stmt|;
name|void
modifier|*
name|wh_baton
decl_stmt|;
name|char
modifier|*
name|base_checksum
decl_stmt|;
comment|/* Parse arguments and look up the token. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?c)"
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|base_checksum
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|TRUE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|entry
operator|->
name|dstream
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Apply-textdelta already active"
argument_list|)
argument_list|)
return|;
name|entry
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|ds
operator|->
name|file_pool
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|entry
operator|->
name|baton
argument_list|,
name|base_checksum
argument_list|,
name|entry
operator|->
name|pool
argument_list|,
operator|&
name|wh
argument_list|,
operator|&
name|wh_baton
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|dstream
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|wh
argument_list|,
name|wh_baton
argument_list|,
name|TRUE
argument_list|,
name|entry
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_textdelta_chunk
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|svn_string_t
modifier|*
name|str
decl_stmt|;
comment|/* Parse arguments and look up the token. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"cs"
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|TRUE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|dstream
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Apply-textdelta not active"
argument_list|)
argument_list|)
return|;
name|SVN_CMD_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|entry
operator|->
name|dstream
argument_list|,
name|str
operator|->
name|data
argument_list|,
operator|&
name|str
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_textdelta_end
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
comment|/* Parse arguments and look up the token. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|TRUE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|entry
operator|->
name|dstream
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Apply-textdelta not active"
argument_list|)
argument_list|)
return|;
name|SVN_CMD_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|entry
operator|->
name|dstream
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|dstream
operator|=
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|entry
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_change_file_prop
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|,
modifier|*
name|name
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"cc(?s)"
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|TRUE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|change_file_prop
argument_list|(
name|entry
operator|->
name|baton
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_close_file
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
specifier|const
name|char
modifier|*
name|text_checksum
decl_stmt|;
comment|/* Parse arguments and look up the file token. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"c(?c)"
argument_list|,
operator|&
name|token
argument_list|,
operator|&
name|text_checksum
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|TRUE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Close the file and destroy the baton. */
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|close_file
argument_list|(
name|entry
operator|->
name|baton
argument_list|,
name|text_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|ds
operator|->
name|tokens
argument_list|,
name|token
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|ds
operator|->
name|file_refs
operator|==
literal|0
condition|)
name|svn_pool_clear
argument_list|(
name|ds
operator|->
name|file_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_absent_file
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|ra_svn_token_entry_t
modifier|*
name|entry
decl_stmt|;
comment|/* Parse parameters and look up the parent directory token. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|params
argument_list|,
name|pool
argument_list|,
literal|"cc"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|lookup_token
argument_list|(
name|ds
argument_list|,
name|token
argument_list|,
name|FALSE
argument_list|,
operator|&
name|entry
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Call the editor. */
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|absent_file
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_close_edit
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|close_edit
argument_list|(
name|ds
operator|->
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|aborted
condition|)
operator|*
name|ds
operator|->
name|aborted
operator|=
name|FALSE
expr_stmt|;
return|return
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_abort_edit
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
name|ds
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|aborted
condition|)
operator|*
name|ds
operator|->
name|aborted
operator|=
name|TRUE
expr_stmt|;
name|SVN_CMD_ERR
argument_list|(
name|ds
operator|->
name|editor
operator|->
name|abort_edit
argument_list|(
name|ds
operator|->
name|edit_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_handle_finish_replay
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
block|{
if|if
condition|(
operator|!
name|ds
operator|->
name|for_replay
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_SVN_UNKNOWN_CMD
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Command 'finish-replay' invalid outside of replays"
argument_list|)
argument_list|)
return|;
name|ds
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|aborted
condition|)
operator|*
name|ds
operator|->
name|aborted
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
specifier|static
specifier|const
struct|struct
block|{
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|params
parameter_list|,
name|ra_svn_driver_state_t
modifier|*
name|ds
parameter_list|)
function_decl|;
block|}
name|ra_svn_edit_cmds
index|[]
init|=
block|{
block|{
literal|"change-file-prop"
block|,
name|ra_svn_handle_change_file_prop
block|}
block|,
block|{
literal|"open-file"
block|,
name|ra_svn_handle_open_file
block|}
block|,
block|{
literal|"apply-textdelta"
block|,
name|ra_svn_handle_apply_textdelta
block|}
block|,
block|{
literal|"textdelta-chunk"
block|,
name|ra_svn_handle_textdelta_chunk
block|}
block|,
block|{
literal|"close-file"
block|,
name|ra_svn_handle_close_file
block|}
block|,
block|{
literal|"add-dir"
block|,
name|ra_svn_handle_add_dir
block|}
block|,
block|{
literal|"open-dir"
block|,
name|ra_svn_handle_open_dir
block|}
block|,
block|{
literal|"change-dir-prop"
block|,
name|ra_svn_handle_change_dir_prop
block|}
block|,
block|{
literal|"delete-entry"
block|,
name|ra_svn_handle_delete_entry
block|}
block|,
block|{
literal|"close-dir"
block|,
name|ra_svn_handle_close_dir
block|}
block|,
block|{
literal|"absent-dir"
block|,
name|ra_svn_handle_absent_dir
block|}
block|,
block|{
literal|"add-file"
block|,
name|ra_svn_handle_add_file
block|}
block|,
block|{
literal|"textdelta-end"
block|,
name|ra_svn_handle_textdelta_end
block|}
block|,
block|{
literal|"absent-file"
block|,
name|ra_svn_handle_absent_file
block|}
block|,
block|{
literal|"abort-edit"
block|,
name|ra_svn_handle_abort_edit
block|}
block|,
block|{
literal|"finish-replay"
block|,
name|ra_svn_handle_finish_replay
block|}
block|,
block|{
literal|"target-rev"
block|,
name|ra_svn_handle_target_rev
block|}
block|,
block|{
literal|"open-root"
block|,
name|ra_svn_handle_open_root
block|}
block|,
block|{
literal|"close-edit"
block|,
name|ra_svn_handle_close_edit
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|blocked_write
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|ra_svn_driver_state_t
modifier|*
name|ds
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|apr_array_header_t
modifier|*
name|params
decl_stmt|;
comment|/* We blocked trying to send an error.  Read and discard an editing    * command in order to avoid deadlock. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"wl"
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|params
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"abort-edit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ds
operator|->
name|done
operator|=
name|TRUE
expr_stmt|;
name|svn_ra_svn__set_block_handler
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn_drive_editor2
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|aborted
parameter_list|,
name|svn_boolean_t
name|for_replay
parameter_list|)
block|{
name|ra_svn_driver_state_t
name|state
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|cmd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
name|apr_array_header_t
modifier|*
name|params
decl_stmt|;
name|state
operator|.
name|editor
operator|=
name|editor
expr_stmt|;
name|state
operator|.
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
name|state
operator|.
name|tokens
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|state
operator|.
name|aborted
operator|=
name|aborted
expr_stmt|;
name|state
operator|.
name|done
operator|=
name|FALSE
expr_stmt|;
name|state
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|state
operator|.
name|file_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|state
operator|.
name|file_refs
operator|=
literal|0
expr_stmt|;
name|state
operator|.
name|for_replay
operator|=
name|for_replay
expr_stmt|;
while|while
condition|(
operator|!
name|state
operator|.
name|done
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|editor
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
literal|"wl"
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|params
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ra_svn_edit_cmds
index|[
name|i
index|]
operator|.
name|cmd
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
name|ra_svn_edit_cmds
index|[
name|i
index|]
operator|.
name|cmd
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ra_svn_edit_cmds
index|[
name|i
index|]
operator|.
name|cmd
condition|)
name|err
operator|=
operator|(
operator|*
name|ra_svn_edit_cmds
index|[
name|i
index|]
operator|.
name|handler
operator|)
operator|(
name|conn
operator|,
name|subpool
operator|,
name|params
operator|,
operator|&
name|state
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* While not really an editor command this can occur when                 reporter->finish_report() fails before the first editor                 command */
if|if
condition|(
name|aborted
condition|)
operator|*
name|aborted
operator|=
name|TRUE
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__handle_failure_status
argument_list|(
name|params
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_SVN_UNKNOWN_CMD
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown editor command '%s'"
argument_list|)
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_CMD_ERR
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|command
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_command_only
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
operator|&
name|command
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|command
argument_list|,
literal|"close-edit"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|state
operator|.
name|done
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|aborted
condition|)
operator|*
name|aborted
operator|=
name|FALSE
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__write_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
else|else
name|err
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_SVN_CMD_ERR
condition|)
block|{
if|if
condition|(
name|aborted
condition|)
operator|*
name|aborted
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|state
operator|.
name|done
condition|)
block|{
comment|/* Abort the edit and use non-blocking I/O to write the error. */
if|if
condition|(
name|editor
condition|)
name|svn_error_clear
argument_list|(
name|editor
operator|->
name|abort_edit
argument_list|(
name|edit_baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_ra_svn__set_block_handler
argument_list|(
name|conn
argument_list|,
name|blocked_write
argument_list|,
operator|&
name|state
argument_list|)
expr_stmt|;
block|}
name|write_err
operator|=
name|svn_ra_svn__write_cmd_failure
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
name|svn_ra_svn__locate_real_error_child
argument_list|(
name|err
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|write_err
condition|)
name|write_err
operator|=
name|svn_ra_svn__flush
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
name|svn_ra_svn__set_block_handler
argument_list|(
name|conn
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|write_err
argument_list|)
expr_stmt|;
break|break;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* Read and discard editing commands until the edit is complete.      Hopefully, the other side will call another editor command, run      check_for_error, notice the error, write "abort-edit" at us, and      throw the error up a few levels on its side (possibly even      tossing it right back at us, which is why we can return      SVN_NO_ERROR below).       However, if the other side is way ahead of us, it might      completely finish the edit (or sequence of edit/revprops, for      "replay-range") before we send over our "failure".  So we should      also stop if we see "success".  (Then the other side will try to      interpret our "failure" as a command, which will itself fail...      The net effect is that whatever error we wrote to the other side      will be replaced with SVN_ERR_RA_SVN_UNKNOWN_CMD.)    */
while|while
condition|(
operator|!
name|state
operator|.
name|done
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__read_tuple
argument_list|(
name|conn
argument_list|,
name|subpool
argument_list|,
literal|"wl"
argument_list|,
operator|&
name|cmd
argument_list|,
operator|&
name|params
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_SVN_CONNECTION_CLOSED
condition|)
block|{
comment|/* Other side disconnected; that's no error. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"abort-edit"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
name|state
operator|.
name|done
operator|=
name|TRUE
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn_drive_editor
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|aborted
parameter_list|)
block|{
return|return
name|svn_ra_svn_drive_editor2
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|aborted
argument_list|,
name|FALSE
argument_list|)
return|;
block|}
end_function

end_unit

