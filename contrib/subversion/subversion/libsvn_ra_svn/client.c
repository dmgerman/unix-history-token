begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * client.c :  Functions for repository access via the Subversion protocol  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_escape
end_escape

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_network_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_uri.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra_svn.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_ra/ra_loader.h"
end_include

begin_include
include|#
directive|include
file|"ra_svn.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
end_ifdef

begin_define
define|#
directive|define
name|DO_AUTH
value|svn_ra_svn__do_cyrus_auth
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DO_AUTH
value|svn_ra_svn__do_internal_auth
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* We aren't using SVN_DEPTH_IS_RECURSIVE here because that macro (for    whatever reason) deems svn_depth_immediates as non-recursive, which    is ... kinda true, but not true enough for our purposes.  We need    our requested recursion level to be *at least* as recursive as the    real depth we're looking for.  */
end_comment

begin_define
define|#
directive|define
name|DEPTH_TO_RECURSE
parameter_list|(
name|d
parameter_list|)
define|\
value|((d) == svn_depth_unknown || (d)> svn_depth_files)
end_define

begin_typedef
typedef|typedef
struct|struct
name|ra_svn_commit_callback_baton_t
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_revnum_t
modifier|*
name|new_rev
decl_stmt|;
name|svn_commit_callback2_t
name|callback
decl_stmt|;
name|void
modifier|*
name|callback_baton
decl_stmt|;
block|}
name|ra_svn_commit_callback_baton_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|ra_svn_reporter_baton_t
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
block|}
name|ra_svn_reporter_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Parse an svn URL's tunnel portion into tunnel, if there is a tunnel    portion. */
end_comment

begin_function
specifier|static
name|void
name|parse_tunnel
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tunnel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|tunnel
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|strncasecmp
argument_list|(
name|url
argument_list|,
literal|"svn"
argument_list|,
literal|3
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|url
operator|+=
literal|3
expr_stmt|;
comment|/* Get the tunnel specification, if any. */
if|if
condition|(
operator|*
name|url
operator|==
literal|'+'
condition|)
block|{
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|url
operator|++
expr_stmt|;
name|p
operator|=
name|strchr
argument_list|(
name|url
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
return|return;
operator|*
name|tunnel
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|url
argument_list|,
name|p
operator|-
name|url
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_connection
parameter_list|(
specifier|const
name|char
modifier|*
name|hostname
parameter_list|,
name|unsigned
name|short
name|port
parameter_list|,
name|apr_socket_t
modifier|*
modifier|*
name|sock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_sockaddr_t
modifier|*
name|sa
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|int
name|family
init|=
name|APR_INET
decl_stmt|;
comment|/* Make sure we have IPV6 support first before giving apr_sockaddr_info_get      APR_UNSPEC, because it may give us back an IPV6 address even if we can't      create IPV6 sockets.  */
if|#
directive|if
name|APR_HAVE_IPV6
ifdef|#
directive|ifdef
name|MAX_SECS_TO_LINGER
name|status
operator|=
name|apr_socket_create
argument_list|(
name|sock
argument_list|,
name|APR_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|apr_socket_create
argument_list|(
name|sock
argument_list|,
name|APR_INET6
argument_list|,
name|SOCK_STREAM
argument_list|,
name|APR_PROTO_TCP
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
literal|0
condition|)
block|{
name|apr_socket_close
argument_list|(
operator|*
name|sock
argument_list|)
expr_stmt|;
name|family
operator|=
name|APR_UNSPEC
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Resolve the hostname. */
name|status
operator|=
name|apr_sockaddr_info_get
argument_list|(
operator|&
name|sa
argument_list|,
name|hostname
argument_list|,
name|family
argument_list|,
name|port
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_createf
argument_list|(
name|status
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown hostname '%s'"
argument_list|)
argument_list|,
name|hostname
argument_list|)
return|;
comment|/* Iterate through the returned list of addresses attempting to    * connect to each in turn. */
do|do
block|{
comment|/* Create the socket. */
ifdef|#
directive|ifdef
name|MAX_SECS_TO_LINGER
comment|/* ### old APR interface */
name|status
operator|=
name|apr_socket_create
argument_list|(
name|sock
argument_list|,
name|sa
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|status
operator|=
name|apr_socket_create
argument_list|(
name|sock
argument_list|,
name|sa
operator|->
name|family
argument_list|,
name|SOCK_STREAM
argument_list|,
name|APR_PROTO_TCP
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
block|{
name|status
operator|=
name|apr_socket_connect
argument_list|(
operator|*
name|sock
argument_list|,
name|sa
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
name|apr_socket_close
argument_list|(
operator|*
name|sock
argument_list|)
expr_stmt|;
block|}
name|sa
operator|=
name|sa
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|status
operator|!=
name|APR_SUCCESS
operator|&&
name|sa
condition|)
do|;
if|if
condition|(
name|status
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't connect to host '%s'"
argument_list|)
argument_list|,
name|hostname
argument_list|)
return|;
comment|/* Enable TCP keep-alives on the socket so we time out when    * the connection breaks due to network-layer problems.    * If the peer has dropped the connection due to a network partition    * or a crash, or if the peer no longer considers the connection    * valid because we are behind a NAT and our public IP has changed,    * it will respond to the keep-alive probe with a RST instead of an    * acknowledgment segment, which will cause svn to abort the session    * even while it is currently blocked waiting for data from the peer.    * See issue #3347. */
name|status
operator|=
name|apr_socket_opt_set
argument_list|(
operator|*
name|sock
argument_list|,
name|APR_SO_KEEPALIVE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
block|{
comment|/* It's not a fatal error if we cannot enable keep-alives. */
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *DIFFS to an array of svn_prop_t, allocated in POOL, based on the    property diffs in LIST, received from the server. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_prop_diffs
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|list
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|diffs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
operator|*
name|diffs
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|list
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_t
modifier|*
name|prop
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|list
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Prop diffs element not a list"
argument_list|)
argument_list|)
return|;
name|prop
operator|=
name|apr_array_push
argument_list|(
operator|*
name|diffs
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|pool
argument_list|,
literal|"c(?s)"
argument_list|,
operator|&
name|prop
operator|->
name|name
argument_list|,
operator|&
name|prop
operator|->
name|value
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse a lockdesc, provided in LIST as specified by the protocol into    LOCK, allocated in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_lock
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|list
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cdate
decl_stmt|,
modifier|*
name|edate
decl_stmt|;
operator|*
name|lock
operator|=
name|svn_lock_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|list
argument_list|,
name|pool
argument_list|,
literal|"ccc(?c)c(?c)"
argument_list|,
operator|&
operator|(
operator|*
name|lock
operator|)
operator|->
name|path
argument_list|,
operator|&
operator|(
operator|*
name|lock
operator|)
operator|->
name|token
argument_list|,
operator|&
operator|(
operator|*
name|lock
operator|)
operator|->
name|owner
argument_list|,
operator|&
operator|(
operator|*
name|lock
operator|)
operator|->
name|comment
argument_list|,
operator|&
name|cdate
argument_list|,
operator|&
name|edate
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|lock
operator|)
operator|->
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
operator|(
operator|*
name|lock
operator|)
operator|->
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
operator|*
name|lock
operator|)
operator|->
name|creation_date
argument_list|,
name|cdate
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|edate
condition|)
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
operator|*
name|lock
operator|)
operator|->
name|expiration_date
argument_list|,
name|edate
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- AUTHENTICATION ROUTINES --- */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn__auth_response
parameter_list|(
name|svn_ra_svn_conn_t
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|mech
parameter_list|,
specifier|const
name|char
modifier|*
name|mech_arg
parameter_list|)
block|{
return|return
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(?c)"
argument_list|,
name|mech
argument_list|,
name|mech_arg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_auth_request
parameter_list|(
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|mechlist
decl_stmt|;
specifier|const
name|char
modifier|*
name|realm
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"lc"
argument_list|,
operator|&
name|mechlist
argument_list|,
operator|&
name|realm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mechlist
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|DO_AUTH
argument_list|(
name|sess
argument_list|,
name|mechlist
argument_list|,
name|realm
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* --- REPORTER IMPLEMENTATION --- */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_set_path
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_reporter_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_set_path
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|depth
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_delete_path
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_reporter_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_delete_path
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_link_path
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|start_empty
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_reporter_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_link_path
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|url
argument_list|,
name|rev
argument_list|,
name|start_empty
argument_list|,
name|lock_token
argument_list|,
name|depth
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_finish_report
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_reporter_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_finish_report
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|b
operator|->
name|sess_baton
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn_drive_editor2
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|,
name|b
operator|->
name|editor
argument_list|,
name|b
operator|->
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_abort_report
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|ra_svn_reporter_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_abort_report
argument_list|(
name|b
operator|->
name|conn
argument_list|,
name|b
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|svn_ra_reporter3_t
name|ra_svn_reporter
init|=
block|{
name|ra_svn_set_path
block|,
name|ra_svn_delete_path
block|,
name|ra_svn_link_path
block|,
name|ra_svn_finish_report
block|,
name|ra_svn_abort_report
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set *REPORTER and *REPORT_BATON to a new reporter which will drive  * EDITOR/EDIT_BATON when it gets the finish_report() call.  *  * Allocate the new reporter in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_reporter
parameter_list|(
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|)
block|{
name|ra_svn_reporter_baton_t
modifier|*
name|b
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|filter_editor
decl_stmt|;
name|void
modifier|*
name|filter_baton
decl_stmt|;
comment|/* We can skip the depth filtering when the user requested      depth_files or depth_infinity because the server will      transmit the right stuff anyway. */
if|if
condition|(
operator|(
name|depth
operator|!=
name|svn_depth_files
operator|)
operator|&&
operator|(
name|depth
operator|!=
name|svn_depth_infinity
operator|)
operator|&&
operator|!
name|svn_ra_svn_has_capability
argument_list|(
name|sess_baton
operator|->
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_DEPTH
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_delta_depth_filter_editor
argument_list|(
operator|&
name|filter_editor
argument_list|,
operator|&
name|filter_baton
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|depth
argument_list|,
operator|*
name|target
operator|!=
literal|'\0'
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|editor
operator|=
name|filter_editor
expr_stmt|;
name|edit_baton
operator|=
name|filter_baton
expr_stmt|;
block|}
name|b
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|sess_baton
operator|=
name|sess_baton
expr_stmt|;
name|b
operator|->
name|conn
operator|=
name|sess_baton
operator|->
name|conn
expr_stmt|;
name|b
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|b
operator|->
name|editor
operator|=
name|editor
expr_stmt|;
name|b
operator|->
name|edit_baton
operator|=
name|edit_baton
expr_stmt|;
operator|*
name|reporter
operator|=
operator|&
name|ra_svn_reporter
expr_stmt|;
operator|*
name|report_baton
operator|=
name|b
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- RA LAYER IMPLEMENTATION --- */
end_comment

begin_comment
comment|/* (Note: *ARGV is an output parameter.) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|find_tunnel_agent
parameter_list|(
specifier|const
name|char
modifier|*
name|tunnel
parameter_list|,
specifier|const
name|char
modifier|*
name|hostinfo
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
modifier|*
name|argv
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_config_t
modifier|*
name|cfg
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|,
modifier|*
name|var
decl_stmt|,
modifier|*
name|cmd
decl_stmt|;
name|char
modifier|*
modifier|*
name|cmd_argv
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_status_t
name|status
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* Look up the tunnel specification in config. */
name|cfg
operator|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_config_get
argument_list|(
name|cfg
argument_list|,
operator|&
name|val
argument_list|,
name|SVN_CONFIG_SECTION_TUNNELS
argument_list|,
name|tunnel
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* We have one predefined tunnel scheme, if it isn't overridden by config. */
if|if
condition|(
operator|!
name|val
operator|&&
name|strcmp
argument_list|(
name|tunnel
argument_list|,
literal|"ssh"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Killing the tunnel agent with SIGTERM leads to unsightly        * stderr output from ssh, unless we pass -q.        * The "-q" option to ssh is widely supported: all versions of        * OpenSSH have it, the old ssh-1.x and the 2.x, 3.x ssh.com        * versions have it too. If the user is using some other ssh        * implementation that doesn't accept it, they can override it        * in the [tunnels] section of the config. */
name|val
operator|=
literal|"$SVN_SSH ssh -q"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|val
operator|||
operator|!
operator|*
name|val
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Undefined tunnel scheme '%s'"
argument_list|)
argument_list|,
name|tunnel
argument_list|)
return|;
comment|/* If the scheme definition begins with "$varname", it means there    * is an environment variable which can override the command. */
if|if
condition|(
operator|*
name|val
operator|==
literal|'$'
condition|)
block|{
name|val
operator|++
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|val
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|var
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|val
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|getenv
argument_list|(
name|var
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cmd
condition|)
block|{
name|cmd
operator|=
name|val
operator|+
name|len
expr_stmt|;
while|while
condition|(
operator|*
name|cmd
operator|==
literal|' '
condition|)
name|cmd
operator|++
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cmd
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Tunnel scheme %s requires environment "
literal|"variable %s to be defined"
argument_list|)
argument_list|,
name|tunnel
argument_list|,
name|var
argument_list|)
return|;
block|}
block|}
else|else
name|cmd
operator|=
name|val
expr_stmt|;
comment|/* Tokenize the command into a list of arguments. */
name|status
operator|=
name|apr_tokenize_to_argv
argument_list|(
name|cmd
argument_list|,
operator|&
name|cmd_argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't tokenize command '%s'"
argument_list|)
argument_list|,
name|cmd
argument_list|)
return|;
comment|/* Append the fixed arguments to the result. */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|cmd_argv
index|[
name|n
index|]
operator|!=
name|NULL
condition|;
name|n
operator|++
control|)
empty_stmt|;
operator|*
name|argv
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
operator|(
name|n
operator|+
literal|4
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|*
name|argv
argument_list|,
name|cmd_argv
argument_list|,
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argv
operator|)
index|[
name|n
operator|++
index|]
operator|=
name|svn_path_uri_decode
argument_list|(
name|hostinfo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argv
operator|)
index|[
name|n
operator|++
index|]
operator|=
literal|"svnserve"
expr_stmt|;
operator|(
operator|*
name|argv
operator|)
index|[
name|n
operator|++
index|]
operator|=
literal|"-t"
expr_stmt|;
operator|(
operator|*
name|argv
operator|)
index|[
name|n
index|]
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This function handles any errors which occur in the child process  * created for a tunnel agent.  We write the error out as a command  * failure; the code in ra_svn_open() to read the server's greeting  * will see the error and return it to the caller. */
end_comment

begin_function
specifier|static
name|void
name|handle_child_process_error
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_status_t
name|status
parameter_list|,
specifier|const
name|char
modifier|*
name|desc
parameter_list|)
block|{
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|apr_file_t
modifier|*
name|in_file
decl_stmt|,
modifier|*
name|out_file
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|apr_file_open_stdin
argument_list|(
operator|&
name|in_file
argument_list|,
name|pool
argument_list|)
operator|||
name|apr_file_open_stdout
argument_list|(
operator|&
name|out_file
argument_list|,
name|pool
argument_list|)
condition|)
return|return;
name|conn
operator|=
name|svn_ra_svn_create_conn3
argument_list|(
name|NULL
argument_list|,
name|in_file
argument_list|,
name|out_file
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Error in child process: %s"
argument_list|)
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_ra_svn__write_cmd_failure
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|err
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_ra_svn__flush
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* (Note: *CONN is an output parameter.) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_tunnel
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|args
parameter_list|,
name|svn_ra_svn_conn_t
modifier|*
modifier|*
name|conn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|status
decl_stmt|;
name|apr_proc_t
modifier|*
name|proc
decl_stmt|;
name|apr_procattr_t
modifier|*
name|attr
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|status
operator|=
name|apr_procattr_create
argument_list|(
operator|&
name|attr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
name|status
operator|=
name|apr_procattr_io_set
argument_list|(
name|attr
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
name|status
operator|=
name|apr_procattr_cmdtype_set
argument_list|(
name|attr
argument_list|,
name|APR_PROGRAM_PATH
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
name|status
operator|=
name|apr_procattr_child_errfn_set
argument_list|(
name|attr
argument_list|,
name|handle_child_process_error
argument_list|)
expr_stmt|;
name|proc
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|proc
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|APR_SUCCESS
condition|)
name|status
operator|=
name|apr_proc_create
argument_list|(
name|proc
argument_list|,
operator|*
name|args
argument_list|,
name|args
argument_list|,
name|NULL
argument_list|,
name|attr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_CANNOT_CREATE_TUNNEL
argument_list|,
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
name|_
argument_list|(
literal|"Can't create tunnel"
argument_list|)
argument_list|)
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Arrange for the tunnel agent to get a SIGTERM on pool    * cleanup.  This is a little extreme, but the alternatives    * weren't working out.    *    * Closing the pipes and waiting for the process to die    * was prone to mysterious hangs which are difficult to    * diagnose (e.g. svnserve dumps core due to unrelated bug;    * sshd goes into zombie state; ssh connection is never    * closed; ssh never terminates).    * See also the long dicussion in issue #2580 if you really    * want to know various reasons for these problems and    * the different opinions on this issue.    *    * On Win32, APR does not support KILL_ONLY_ONCE. It only has    * KILL_ALWAYS and KILL_NEVER. Other modes are converted to    * KILL_ALWAYS, which immediately calls TerminateProcess().    * This instantly kills the tunnel, leaving sshd and svnserve    * on a remote machine running indefinitely. These processes    * accumulate. The problem is most often seen with a fast client    * machine and a modest internet connection, as the tunnel    * is killed before being able to gracefully complete the    * session. In that case, svn is unusable 100% of the time on    * the windows machine. Thus, on Win32, we use KILL_NEVER and    * take the lesser of two evils.    */
ifdef|#
directive|ifdef
name|WIN32
name|apr_pool_note_subprocess
argument_list|(
name|pool
argument_list|,
name|proc
argument_list|,
name|APR_KILL_NEVER
argument_list|)
expr_stmt|;
else|#
directive|else
name|apr_pool_note_subprocess
argument_list|(
name|pool
argument_list|,
name|proc
argument_list|,
name|APR_KILL_ONLY_ONCE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR pipe objects inherit by default.  But we don't want the    * tunnel agent's pipes held open by future child processes    * (such as other ra_svn sessions), so turn that off. */
name|apr_file_inherit_unset
argument_list|(
name|proc
operator|->
name|in
argument_list|)
expr_stmt|;
name|apr_file_inherit_unset
argument_list|(
name|proc
operator|->
name|out
argument_list|)
expr_stmt|;
comment|/* Guard against dotfile output to stdout on the server. */
operator|*
name|conn
operator|=
name|svn_ra_svn_create_conn3
argument_list|(
name|NULL
argument_list|,
name|proc
operator|->
name|out
argument_list|,
name|proc
operator|->
name|in
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__skip_leading_garbage
argument_list|(
operator|*
name|conn
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"To better debug SSH connection problems, remove the -q "
literal|"option from 'ssh' in the [tunnels] section of your "
literal|"Subversion configuration file."
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse URL inot URI, validating it and setting the default port if none    was given.  Allocate the URI fileds out of POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_uri_t
modifier|*
name|uri
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_err
operator|=
name|apr_uri_parse
argument_list|(
name|pool
argument_list|,
name|url
argument_list|,
name|uri
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Illegal svn repository URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|)
return|;
if|if
condition|(
operator|!
name|uri
operator|->
name|port
condition|)
name|uri
operator|->
name|port
operator|=
name|SVN_RA_SVN_PORT
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open a session to URL, returning it in *SESS_P, allocating it in POOL.    URI is a parsed version of URL.  CALLBACKS and CALLBACKS_BATON    are provided by the caller of ra_svn_open. If tunnel_argv is non-null,    it points to a program argument list to use when invoking the tunnel agent. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_session
parameter_list|(
name|svn_ra_svn__session_baton_t
modifier|*
modifier|*
name|sess_p
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|apr_uri_t
modifier|*
name|uri
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tunnel_argv
parameter_list|,
specifier|const
name|svn_ra_callbacks2_t
modifier|*
name|callbacks
parameter_list|,
name|void
modifier|*
name|callbacks_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
decl_stmt|;
name|apr_socket_t
modifier|*
name|sock
decl_stmt|;
name|apr_uint64_t
name|minver
decl_stmt|,
name|maxver
decl_stmt|;
name|apr_array_header_t
modifier|*
name|mechlist
decl_stmt|,
modifier|*
name|server_caplist
decl_stmt|,
modifier|*
name|repos_caplist
decl_stmt|;
specifier|const
name|char
modifier|*
name|client_string
init|=
name|NULL
decl_stmt|;
name|sess
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sess
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|sess
operator|->
name|is_tunneled
operator|=
operator|(
name|tunnel_argv
operator|!=
name|NULL
operator|)
expr_stmt|;
name|sess
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
name|sess
operator|->
name|user
operator|=
name|uri
operator|->
name|user
expr_stmt|;
name|sess
operator|->
name|hostname
operator|=
name|uri
operator|->
name|hostname
expr_stmt|;
name|sess
operator|->
name|realm_prefix
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"<svn://%s:%d>"
argument_list|,
name|uri
operator|->
name|hostname
argument_list|,
name|uri
operator|->
name|port
argument_list|)
expr_stmt|;
name|sess
operator|->
name|tunnel_argv
operator|=
name|tunnel_argv
expr_stmt|;
name|sess
operator|->
name|callbacks
operator|=
name|callbacks
expr_stmt|;
name|sess
operator|->
name|callbacks_baton
operator|=
name|callbacks_baton
expr_stmt|;
name|sess
operator|->
name|bytes_read
operator|=
name|sess
operator|->
name|bytes_written
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|tunnel_argv
condition|)
name|SVN_ERR
argument_list|(
name|make_tunnel
argument_list|(
name|tunnel_argv
argument_list|,
operator|&
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|make_connection
argument_list|(
name|uri
operator|->
name|hostname
argument_list|,
name|uri
operator|->
name|port
argument_list|,
operator|&
name|sock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|conn
operator|=
name|svn_ra_svn_create_conn3
argument_list|(
name|sock
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Build the useragent string, querying the client for any      customizations it wishes to note.  For historical reasons, we      still deliver the hard-coded client version info      (SVN_RA_SVN__DEFAULT_USERAGENT) and the customized client string      separately in the protocol/capabilities handshake below.  But the      commit logic wants the combined form for use with the      SVN_PROP_TXN_USER_AGENT ephemeral property because that's      consistent with our DAV approach.  */
if|if
condition|(
name|sess
operator|->
name|callbacks
operator|->
name|get_client_string
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|sess
operator|->
name|callbacks
operator|->
name|get_client_string
argument_list|(
name|sess
operator|->
name|callbacks_baton
argument_list|,
operator|&
name|client_string
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|client_string
condition|)
name|sess
operator|->
name|useragent
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|SVN_RA_SVN__DEFAULT_USERAGENT
literal|" "
argument_list|,
name|client_string
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|sess
operator|->
name|useragent
operator|=
name|SVN_RA_SVN__DEFAULT_USERAGENT
expr_stmt|;
comment|/* Make sure we set conn->session before reading from it,    * because the reader and writer functions expect a non-NULL value. */
name|sess
operator|->
name|conn
operator|=
name|conn
expr_stmt|;
name|conn
operator|->
name|session
operator|=
name|sess
expr_stmt|;
comment|/* Read server's greeting. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"nnll"
argument_list|,
operator|&
name|minver
argument_list|,
operator|&
name|maxver
argument_list|,
operator|&
name|mechlist
argument_list|,
operator|&
name|server_caplist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We support protocol version 2. */
if|if
condition|(
name|minver
operator|>
literal|2
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_SVN_BAD_VERSION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Server requires minimum version %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|minver
argument_list|)
return|;
if|if
condition|(
name|maxver
operator|<
literal|2
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_SVN_BAD_VERSION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Server only supports versions up to %d"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|maxver
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn_set_capabilities
argument_list|(
name|conn
argument_list|,
name|server_caplist
argument_list|)
argument_list|)
expr_stmt|;
comment|/* All released versions of Subversion support edit-pipeline,    * so we do not support servers that do not. */
if|if
condition|(
operator|!
name|svn_ra_svn_has_capability
argument_list|(
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_EDIT_PIPELINE
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_BAD_VERSION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Server does not support edit pipelining"
argument_list|)
argument_list|)
return|;
comment|/* In protocol version 2, we send back our protocol version, our    * capability list, and the URL, and subsequently there is an auth    * request. */
comment|/* Client-side capabilities list: */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"n(wwwwww)cc(?c)"
argument_list|,
operator|(
name|apr_uint64_t
operator|)
literal|2
argument_list|,
name|SVN_RA_SVN_CAP_EDIT_PIPELINE
argument_list|,
name|SVN_RA_SVN_CAP_SVNDIFF1
argument_list|,
name|SVN_RA_SVN_CAP_ABSENT_ENTRIES
argument_list|,
name|SVN_RA_SVN_CAP_DEPTH
argument_list|,
name|SVN_RA_SVN_CAP_MERGEINFO
argument_list|,
name|SVN_RA_SVN_CAP_LOG_REVPROPS
argument_list|,
name|url
argument_list|,
name|SVN_RA_SVN__DEFAULT_USERAGENT
argument_list|,
name|client_string
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This is where the security layer would go into effect if we    * supported security layers, which is a ways off. */
comment|/* Read the repository's uuid and root URL, and perhaps learn more      capabilities that weren't available before now. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"c?c?l"
argument_list|,
operator|&
name|conn
operator|->
name|uuid
argument_list|,
operator|&
name|conn
operator|->
name|repos_root
argument_list|,
operator|&
name|repos_caplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|repos_caplist
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn_set_capabilities
argument_list|(
name|conn
argument_list|,
name|repos_caplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|conn
operator|->
name|repos_root
condition|)
block|{
name|conn
operator|->
name|repos_root
operator|=
name|svn_uri_canonicalize
argument_list|(
name|conn
operator|->
name|repos_root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We should check that the returned string is a prefix of url, since          that's the API guarantee, but this isn't true for 1.0 servers.          Checking the length prevents client crashes. */
if|if
condition|(
name|strlen
argument_list|(
name|conn
operator|->
name|repos_root
argument_list|)
operator|>
name|strlen
argument_list|(
name|url
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Impossibly long repository root from "
literal|"server"
argument_list|)
argument_list|)
return|;
block|}
operator|*
name|sess_p
operator|=
name|sess
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
end_ifdef

begin_define
define|#
directive|define
name|RA_SVN_DESCRIPTION
define|\
value|N_("Module for accessing a repository using the svn network protocol.\n" \      "  - with Cyrus SASL authentication")
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|RA_SVN_DESCRIPTION
define|\
value|N_("Module for accessing a repository using the svn network protocol.")
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|ra_svn_get_description
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|_
argument_list|(
name|RA_SVN_DESCRIPTION
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
specifier|const
modifier|*
name|ra_svn_get_schemes
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|char
modifier|*
name|schemes
index|[]
init|=
block|{
literal|"svn"
block|,
name|NULL
block|}
decl_stmt|;
return|return
name|schemes
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_open
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|corrected_url
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
specifier|const
name|svn_ra_callbacks2_t
modifier|*
name|callbacks
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|config
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|sess_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
decl_stmt|;
specifier|const
name|char
modifier|*
name|tunnel
decl_stmt|,
modifier|*
modifier|*
name|tunnel_argv
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg
decl_stmt|,
modifier|*
name|cfg_client
decl_stmt|;
comment|/* We don't support server-prescribed redirections in ra-svn. */
if|if
condition|(
name|corrected_url
condition|)
operator|*
name|corrected_url
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_url
argument_list|(
name|url
argument_list|,
operator|&
name|uri
argument_list|,
name|sess_pool
argument_list|)
argument_list|)
expr_stmt|;
name|parse_tunnel
argument_list|(
name|url
argument_list|,
operator|&
name|tunnel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|tunnel
condition|)
name|SVN_ERR
argument_list|(
name|find_tunnel_agent
argument_list|(
name|tunnel
argument_list|,
name|uri
operator|.
name|hostinfo
argument_list|,
operator|&
name|tunnel_argv
argument_list|,
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|tunnel_argv
operator|=
name|NULL
expr_stmt|;
name|cfg_client
operator|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
else|:
name|NULL
expr_stmt|;
name|cfg
operator|=
name|config
condition|?
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_SERVERS
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_CATEGORY_CONFIG
argument_list|,
name|cfg_client
argument_list|)
expr_stmt|;
name|svn_auth_set_parameter
argument_list|(
name|callbacks
operator|->
name|auth_baton
argument_list|,
name|SVN_AUTH_PARAM_CONFIG_CATEGORY_SERVERS
argument_list|,
name|cfg
argument_list|)
expr_stmt|;
comment|/* We open the session in a subpool so we can get rid of it if we      reparent with a server that doesn't support reparenting. */
name|SVN_ERR
argument_list|(
name|open_session
argument_list|(
operator|&
name|sess
argument_list|,
name|url
argument_list|,
operator|&
name|uri
argument_list|,
name|tunnel_argv
argument_list|,
name|callbacks
argument_list|,
name|callback_baton
argument_list|,
name|sess_pool
argument_list|)
argument_list|)
expr_stmt|;
name|session
operator|->
name|priv
operator|=
name|sess
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_reparent
parameter_list|(
name|svn_ra_session_t
modifier|*
name|ra_session
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|ra_session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|sess_pool
decl_stmt|;
name|svn_ra_svn__session_baton_t
modifier|*
name|new_sess
decl_stmt|;
name|apr_uri_t
name|uri
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_reparent
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|url
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|sess
operator|->
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|sess
operator|->
name|pool
argument_list|,
name|url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|apr_err
operator|!=
name|SVN_ERR_RA_SVN_UNKNOWN_CMD
condition|)
return|return
name|err
return|;
comment|/* Servers before 1.4 doesn't support this command; try to reconnect      instead. */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Create a new subpool of the RA session pool. */
name|sess_pool
operator|=
name|svn_pool_create
argument_list|(
name|ra_session
operator|->
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|parse_url
argument_list|(
name|url
argument_list|,
operator|&
name|uri
argument_list|,
name|sess_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|open_session
argument_list|(
operator|&
name|new_sess
argument_list|,
name|url
argument_list|,
operator|&
name|uri
argument_list|,
name|sess
operator|->
name|tunnel_argv
argument_list|,
name|sess
operator|->
name|callbacks
argument_list|,
name|sess
operator|->
name|callbacks_baton
argument_list|,
name|sess_pool
argument_list|)
expr_stmt|;
comment|/* We destroy the new session pool on error, since it is allocated in      the main session pool. */
if|if
condition|(
name|err
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|sess_pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* We have a new connection, assign it and destroy the old. */
name|ra_session
operator|->
name|priv
operator|=
name|new_sess
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|sess
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_session_url
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
operator|*
name|url
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|sess
operator|->
name|url
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_latest_rev
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_latest_rev
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_dated_rev
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
name|apr_time_t
name|tm
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_dated_rev
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Forward declaration. */
end_comment

begin_function_decl
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_has_capability
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_boolean_t
modifier|*
name|has
parameter_list|,
specifier|const
name|char
modifier|*
name|capability
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_change_rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
specifier|const
modifier|*
name|old_value_p
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|svn_boolean_t
name|dont_care
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|old_value
decl_stmt|;
name|svn_boolean_t
name|has_atomic_revprops
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ra_svn_has_capability
argument_list|(
name|session
argument_list|,
operator|&
name|has_atomic_revprops
argument_list|,
name|SVN_RA_SVN_CAP_ATOMIC_REVPROPS
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|old_value_p
condition|)
block|{
comment|/* How did you get past the same check in svn_ra_change_rev_prop2()? */
name|SVN_ERR_ASSERT
argument_list|(
name|has_atomic_revprops
argument_list|)
expr_stmt|;
name|dont_care
operator|=
name|FALSE
expr_stmt|;
name|old_value
operator|=
operator|*
name|old_value_p
expr_stmt|;
block|}
else|else
block|{
name|dont_care
operator|=
name|TRUE
expr_stmt|;
name|old_value
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|has_atomic_revprops
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_change_rev_prop2
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|dont_care
argument_list|,
name|old_value
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_change_rev_prop
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_uuid
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|uuid
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
operator|*
name|uuid
operator|=
name|conn
operator|->
name|uuid
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_repos_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
if|if
condition|(
operator|!
name|conn
operator|->
name|repos_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_BAD_VERSION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Server did not send repository root"
argument_list|)
argument_list|)
return|;
operator|*
name|url
operator|=
name|conn
operator|->
name|repos_root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_rev_proplist
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|proplist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_rev_proplist
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"l"
argument_list|,
operator|&
name|proplist
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|proplist
argument_list|,
name|pool
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_rev_prop
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|svn_string_t
modifier|*
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_rev_prop
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"(?s)"
argument_list|,
name|value
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_end_commit
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|ra_svn_commit_callback_baton_t
modifier|*
name|ccb
init|=
name|baton
decl_stmt|;
name|svn_commit_info_t
modifier|*
name|commit_info
init|=
name|svn_create_commit_info
argument_list|(
name|ccb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|ccb
operator|->
name|sess_baton
argument_list|,
name|ccb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|ccb
operator|->
name|sess_baton
operator|->
name|conn
argument_list|,
name|ccb
operator|->
name|pool
argument_list|,
literal|"r(?c)(?c)?(?c)"
argument_list|,
operator|&
operator|(
name|commit_info
operator|->
name|revision
operator|)
argument_list|,
operator|&
operator|(
name|commit_info
operator|->
name|date
operator|)
argument_list|,
operator|&
operator|(
name|commit_info
operator|->
name|author
operator|)
argument_list|,
operator|&
operator|(
name|commit_info
operator|->
name|post_commit_err
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccb
operator|->
name|callback
condition|)
name|SVN_ERR
argument_list|(
name|ccb
operator|->
name|callback
argument_list|(
name|commit_info
argument_list|,
name|ccb
operator|->
name|callback_baton
argument_list|,
name|ccb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_commit
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
modifier|*
name|edit_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|revprop_table
parameter_list|,
name|svn_commit_callback2_t
name|callback
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|lock_tokens
parameter_list|,
name|svn_boolean_t
name|keep_locks
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|ra_svn_commit_callback_baton_t
modifier|*
name|ccb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|log_msg
init|=
name|svn_hash_gets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
decl_stmt|;
if|if
condition|(
name|log_msg
operator|==
name|NULL
operator|&&
operator|!
name|svn_ra_svn_has_capability
argument_list|(
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_COMMIT_REVPROPS
argument_list|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_PROPERTY_VALUE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"ra_svn does not support not specifying "
literal|"a log message with pre-1.5 servers; "
literal|"consider passing an empty one, or upgrading "
literal|"the server"
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|log_msg
operator|==
name|NULL
condition|)
comment|/* 1.5+ server.  Set LOG_MSG to something, since the 'logmsg' argument        to the 'commit' protocol command is non-optional; on the server side,        only REVPROP_TABLE will be used, and LOG_MSG will be ignored.  The         "svn:log" member of REVPROP_TABLE table is NULL, therefore the commit        will have a NULL log message (not just "", really NULL).         svnserve 1.5.x+ has always ignored LOG_MSG when REVPROP_TABLE was        present; this was elevated to a protocol promise in r1498550 (and        later documented in this comment) in order to fix the segmentation        fault bug described in the log message of r1498550.*/
name|log_msg
operator|=
name|svn_string_create
argument_list|(
literal|""
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we're sending revprops other than svn:log, make sure the server won't      silently ignore them. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|revprop_table
argument_list|)
operator|>
literal|1
operator|&&
operator|!
name|svn_ra_svn_has_capability
argument_list|(
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_COMMIT_REVPROPS
argument_list|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_IMPLEMENTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Server doesn't support setting arbitrary "
literal|"revision properties during commit"
argument_list|)
argument_list|)
return|;
comment|/* If the server supports ephemeral txnprops, add the one that      reports the client's version level string. */
if|if
condition|(
name|svn_ra_svn_has_capability
argument_list|(
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_COMMIT_REVPROPS
argument_list|)
operator|&&
name|svn_ra_svn_has_capability
argument_list|(
name|conn
argument_list|,
name|SVN_RA_SVN_CAP_EPHEMERAL_TXNPROPS
argument_list|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_TXN_CLIENT_COMPAT_VERSION
argument_list|,
name|svn_string_create
argument_list|(
name|SVN_VER_NUMBER
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|revprop_table
argument_list|,
name|SVN_PROP_TXN_USER_AGENT
argument_list|,
name|svn_string_create
argument_list|(
name|sess_baton
operator|->
name|useragent
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Tell the server we're starting the commit.      Send log message here for backwards compatibility with servers      before 1.5. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(c(!"
argument_list|,
literal|"commit"
argument_list|,
name|log_msg
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock_tokens
condition|)
block|{
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|lock_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|,
modifier|*
name|token
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
name|token
operator|=
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"cc"
argument_list|,
name|path
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)b(!"
argument_list|,
name|keep_locks
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_proplist
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|revprop_table
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remember a few arguments for when the commit is over. */
name|ccb
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ccb
argument_list|)
argument_list|)
expr_stmt|;
name|ccb
operator|->
name|sess_baton
operator|=
name|sess_baton
expr_stmt|;
name|ccb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ccb
operator|->
name|new_rev
operator|=
name|NULL
expr_stmt|;
name|ccb
operator|->
name|callback
operator|=
name|callback
expr_stmt|;
name|ccb
operator|->
name|callback_baton
operator|=
name|callback_baton
expr_stmt|;
comment|/* Fetch an editor for the caller to drive.  The editor will call    * ra_svn_end_commit() upon close_edit(), at which point we'll fill    * in the new_rev, committed_date, and committed_author values. */
name|svn_ra_svn_get_editor
argument_list|(
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|conn
argument_list|,
name|pool
argument_list|,
name|ra_svn_end_commit
argument_list|,
name|ccb
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse IPROPLIST, an array of svn_ra_svn_item_t structures, as a list of    const char * repos relative paths and properties for those paths, storing    the result as an array of svn_prop_inherited_item_t *items. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_iproplist
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|inherited_props
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|iproplist
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root_url
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
if|if
condition|(
name|iproplist
operator|==
name|NULL
condition|)
block|{
comment|/* If the server doesn't have the SVN_RA_CAPABILITY_INHERITED_PROPS          capability we shouldn't be asking for inherited props, but if we          did and the server sent back nothing then we'll want to handle          that. */
operator|*
name|inherited_props
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|ra_svn_get_repos_root
argument_list|(
name|session
argument_list|,
operator|&
name|repos_root_url
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|inherited_props
operator|=
name|apr_array_make
argument_list|(
name|result_pool
argument_list|,
name|iproplist
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_prop_inherited_item_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|iproplist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|apr_array_header_t
modifier|*
name|iprop_list
decl_stmt|;
name|char
modifier|*
name|parent_rel_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|iprops
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_prop_inherited_item_t
modifier|*
name|new_iprop
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_iprop
argument_list|)
argument_list|)
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|iproplist
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Inherited proplist element not a list"
argument_list|)
argument_list|)
return|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|iterpool
argument_list|,
literal|"cl"
argument_list|,
operator|&
name|parent_rel_path
argument_list|,
operator|&
name|iprop_list
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|iprop_list
argument_list|,
name|iterpool
argument_list|,
operator|&
name|iprops
argument_list|)
argument_list|)
expr_stmt|;
name|new_iprop
operator|->
name|path_or_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|repos_root_url
argument_list|,
name|parent_rel_path
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|new_iprop
operator|->
name|prop_hash
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|iprops
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|value
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|new_iprop
operator|->
name|prop_hash
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|inherited_props
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
operator|=
name|new_iprop
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_file
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|proplist
decl_stmt|;
specifier|const
name|char
modifier|*
name|expected_digest
decl_stmt|;
name|svn_checksum_t
modifier|*
name|expected_checksum
init|=
name|NULL
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|checksum_ctx
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_file
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
operator|(
name|props
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
name|stream
operator|!=
name|NULL
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"(?c)rl"
argument_list|,
operator|&
name|expected_digest
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|proplist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetched_rev
condition|)
operator|*
name|fetched_rev
operator|=
name|rev
expr_stmt|;
if|if
condition|(
name|props
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|proplist
argument_list|,
name|pool
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're done if the contents weren't wanted. */
if|if
condition|(
operator|!
name|stream
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|expected_digest
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_checksum_parse_hex
argument_list|(
operator|&
name|expected_checksum
argument_list|,
name|svn_checksum_md5
argument_list|,
name|expected_digest
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Read the file's contents. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|item
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
operator|&
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Non-string as part of file contents"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|len
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|expected_checksum
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|checksum_ctx
argument_list|,
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|data
argument_list|,
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|data
argument_list|,
operator|&
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|expected_checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|checksum
argument_list|,
name|checksum_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|checksum
argument_list|,
name|expected_checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|expected_checksum
argument_list|,
name|checksum
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Checksum mismatch for '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_dir
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|dirents
parameter_list|,
name|svn_revnum_t
modifier|*
name|fetched_rev
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_uint32_t
name|dirent_fields
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|proplist
decl_stmt|,
modifier|*
name|dirlist
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(c(?r)bb(!"
argument_list|,
literal|"get-dir"
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
operator|(
name|props
operator|!=
name|NULL
operator|)
argument_list|,
operator|(
name|dirents
operator|!=
name|NULL
operator|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_KIND
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|SVN_RA_SVN_DIRENT_KIND
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_SIZE
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|SVN_RA_SVN_DIRENT_SIZE
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_HAS_PROPS
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|SVN_RA_SVN_DIRENT_HAS_PROPS
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_CREATED_REV
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|SVN_RA_SVN_DIRENT_CREATED_REV
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_TIME
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|SVN_RA_SVN_DIRENT_TIME
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirent_fields
operator|&
name|SVN_DIRENT_LAST_AUTHOR
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_word
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|SVN_RA_SVN_DIRENT_LAST_AUTHOR
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"rll"
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|proplist
argument_list|,
operator|&
name|dirlist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetched_rev
condition|)
operator|*
name|fetched_rev
operator|=
name|rev
expr_stmt|;
if|if
condition|(
name|props
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|proplist
argument_list|,
name|pool
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We're done if dirents aren't wanted. */
if|if
condition|(
operator|!
name|dirents
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Interpret the directory list. */
operator|*
name|dirents
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dirlist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|kind
decl_stmt|,
modifier|*
name|cdate
decl_stmt|,
modifier|*
name|cauthor
decl_stmt|;
name|svn_boolean_t
name|has_props
decl_stmt|;
name|svn_dirent_t
modifier|*
name|dirent
decl_stmt|;
name|apr_uint64_t
name|size
decl_stmt|;
name|svn_revnum_t
name|crev
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|dirlist
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Dirlist element not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|pool
argument_list|,
literal|"cwnbr(?c)(?c)"
argument_list|,
operator|&
name|name
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|has_props
argument_list|,
operator|&
name|crev
argument_list|,
operator|&
name|cdate
argument_list|,
operator|&
name|cauthor
argument_list|)
argument_list|)
expr_stmt|;
name|name
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|name
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|dirent
operator|=
name|svn_dirent_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|kind
operator|=
name|svn_node_kind_from_word
argument_list|(
name|kind
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* FIXME: svn_filesize_t */
name|dirent
operator|->
name|has_props
operator|=
name|has_props
expr_stmt|;
name|dirent
operator|->
name|created_rev
operator|=
name|crev
expr_stmt|;
comment|/* NOTE: the tuple's format string says CDATE may be NULL. But this          function does not allow that. The server has always sent us some          random date, however, so this just happens to work. But let's          be wary of servers that are (improperly) fixed to send NULL.           Note: they should NOT be "fixed" to send NULL, as that would break          any older clients which received that NULL. But we may as well          be defensive against a malicous server.  */
if|if
condition|(
name|cdate
operator|==
name|NULL
condition|)
name|dirent
operator|->
name|time
operator|=
literal|0
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|dirent
operator|->
name|time
argument_list|,
name|cdate
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|dirent
operator|->
name|last_author
operator|=
name|cauthor
expr_stmt|;
name|svn_hash_sets
argument_list|(
operator|*
name|dirents
argument_list|,
name|name
argument_list|,
name|dirent
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Converts a apr_uint64_t with values TRUE, FALSE or    SVN_RA_SVN_UNSPECIFIED_NUMBER as provided by svn_ra_svn__parse_tuple    to a svn_tristate_t */
end_comment

begin_function
specifier|static
name|svn_tristate_t
name|optbool_to_tristate
parameter_list|(
name|apr_uint64_t
name|v
parameter_list|)
block|{
if|if
condition|(
name|v
operator|==
name|TRUE
condition|)
comment|/* not just non-zero but exactly equal to 'TRUE' */
return|return
name|svn_tristate_true
return|;
if|if
condition|(
name|v
operator|==
name|FALSE
condition|)
return|return
name|svn_tristate_false
return|;
return|return
name|svn_tristate_unknown
return|;
comment|/* Contains SVN_RA_SVN_UNSPECIFIED_NUMBER */
block|}
end_function

begin_comment
comment|/* If REVISION is SVN_INVALID_REVNUM, no value is sent to the    server, which defaults to youngest. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_mergeinfo
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|catalog
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|mergeinfo_tuple
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((!"
argument_list|,
literal|"get-mergeinfo"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cstring
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)(?r)wb)"
argument_list|,
name|revision
argument_list|,
name|svn_inheritance_to_word
argument_list|(
name|inherit
argument_list|)
argument_list|,
name|include_descendants
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"l"
argument_list|,
operator|&
name|mergeinfo_tuple
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|catalog
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|mergeinfo_tuple
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
operator|*
name|catalog
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mergeinfo_tuple
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_mergeinfo_t
name|for_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_parse
decl_stmt|;
name|elt
operator|=
operator|&
operator|(
operator|(
name|svn_ra_svn_item_t
operator|*
operator|)
name|mergeinfo_tuple
operator|->
name|elts
operator|)
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Mergeinfo element is not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|pool
argument_list|,
literal|"cc"
argument_list|,
operator|&
name|path
argument_list|,
operator|&
name|to_parse
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|for_path
argument_list|,
name|to_parse
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Correct for naughty servers that send "relative" paths              with leading slashes! */
name|svn_hash_sets
argument_list|(
operator|*
name|catalog
argument_list|,
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
name|path
operator|+
literal|1
else|:
name|path
argument_list|,
name|for_path
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_update
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|svn_boolean_t
name|recurse
init|=
name|DEPTH_TO_RECURSE
argument_list|(
name|depth
argument_list|)
decl_stmt|;
comment|/* Tell the server we want to start an update. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_update
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|,
name|target
argument_list|,
name|recurse
argument_list|,
name|depth
argument_list|,
name|send_copyfrom_args
argument_list|,
name|ignore_ancestry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch a reporter for the caller to drive.  The reporter will drive    * update_editor upon finish_report(). */
name|SVN_ERR
argument_list|(
name|ra_svn_get_reporter
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|target
argument_list|,
name|depth
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_switch
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|char
modifier|*
name|switch_url
parameter_list|,
name|svn_boolean_t
name|send_copyfrom_args
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|update_editor
parameter_list|,
name|void
modifier|*
name|update_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|result_pool
decl_stmt|;
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|svn_boolean_t
name|recurse
init|=
name|DEPTH_TO_RECURSE
argument_list|(
name|depth
argument_list|)
decl_stmt|;
comment|/* Tell the server we want to start a switch. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_switch
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|,
name|target
argument_list|,
name|recurse
argument_list|,
name|switch_url
argument_list|,
name|depth
argument_list|,
name|send_copyfrom_args
argument_list|,
name|ignore_ancestry
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch a reporter for the caller to drive.  The reporter will drive    * update_editor upon finish_report(). */
name|SVN_ERR
argument_list|(
name|ra_svn_get_reporter
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|,
name|update_editor
argument_list|,
name|update_baton
argument_list|,
name|target
argument_list|,
name|depth
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_status
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|status_editor
parameter_list|,
name|void
modifier|*
name|status_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|svn_boolean_t
name|recurse
init|=
name|DEPTH_TO_RECURSE
argument_list|(
name|depth
argument_list|)
decl_stmt|;
comment|/* Tell the server we want to start a status operation. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_status
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|target
argument_list|,
name|recurse
argument_list|,
name|rev
argument_list|,
name|depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch a reporter for the caller to drive.  The reporter will drive    * status_editor upon finish_report(). */
name|SVN_ERR
argument_list|(
name|ra_svn_get_reporter
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|,
name|status_editor
argument_list|,
name|status_baton
argument_list|,
name|target
argument_list|,
name|depth
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_diff
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|svn_ra_reporter3_t
modifier|*
modifier|*
name|reporter
parameter_list|,
name|void
modifier|*
modifier|*
name|report_baton
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_boolean_t
name|ignore_ancestry
parameter_list|,
name|svn_boolean_t
name|text_deltas
parameter_list|,
specifier|const
name|char
modifier|*
name|versus_url
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|diff_editor
parameter_list|,
name|void
modifier|*
name|diff_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|svn_boolean_t
name|recurse
init|=
name|DEPTH_TO_RECURSE
argument_list|(
name|depth
argument_list|)
decl_stmt|;
comment|/* Tell the server we want to start a diff. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_diff
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|rev
argument_list|,
name|target
argument_list|,
name|recurse
argument_list|,
name|ignore_ancestry
argument_list|,
name|versus_url
argument_list|,
name|text_deltas
argument_list|,
name|depth
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch a reporter for the caller to drive.  The reporter will drive    * diff_editor upon finish_report(). */
name|SVN_ERR
argument_list|(
name|ra_svn_get_reporter
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|,
name|diff_editor
argument_list|,
name|diff_baton
argument_list|,
name|target
argument_list|,
name|depth
argument_list|,
name|reporter
argument_list|,
name|report_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|perform_ra_svn_log
parameter_list|(
name|svn_error_t
modifier|*
modifier|*
name|outer_error
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|nest_level
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|svn_boolean_t
name|want_custom_revprops
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((!"
argument_list|,
literal|"log"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|paths
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cstring
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!)(?r)(?r)bbnb!"
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|limit
argument_list|,
name|include_merged_revisions
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|revprops
condition|)
block|{
name|want_custom_revprops
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!w(!"
argument_list|,
literal|"revprops"
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cstring
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|want_custom_revprops
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
operator|!=
literal|0
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
operator|!=
literal|0
condition|)
name|want_custom_revprops
operator|=
name|TRUE
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!w())"
argument_list|,
literal|"all-revprops"
argument_list|)
argument_list|)
expr_stmt|;
name|want_custom_revprops
operator|=
name|TRUE
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the log messages. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_uint64_t
name|has_children_param
decl_stmt|,
name|invalid_revnum_param
decl_stmt|;
name|apr_uint64_t
name|has_subtractive_merge_param
decl_stmt|;
name|svn_string_t
modifier|*
name|author
decl_stmt|,
modifier|*
name|date
decl_stmt|,
modifier|*
name|message
decl_stmt|;
name|apr_array_header_t
modifier|*
name|cplist
decl_stmt|,
modifier|*
name|rplist
decl_stmt|;
name|svn_log_entry_t
modifier|*
name|log_entry
decl_stmt|;
name|svn_boolean_t
name|has_children
decl_stmt|;
name|svn_boolean_t
name|subtractive_merge
init|=
name|FALSE
decl_stmt|;
name|apr_uint64_t
name|revprop_count
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|item
decl_stmt|;
name|apr_hash_t
modifier|*
name|cphash
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|int
name|nreceived
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
operator|&
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|==
name|SVN_RA_SVN_WORD
operator|&&
name|strcmp
argument_list|(
name|item
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Log entry not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
name|iterpool
argument_list|,
literal|"lr(?s)(?s)(?s)?BBnl?B"
argument_list|,
operator|&
name|cplist
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|author
argument_list|,
operator|&
name|date
argument_list|,
operator|&
name|message
argument_list|,
operator|&
name|has_children_param
argument_list|,
operator|&
name|invalid_revnum_param
argument_list|,
operator|&
name|revprop_count
argument_list|,
operator|&
name|rplist
argument_list|,
operator|&
name|has_subtractive_merge_param
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|want_custom_revprops
operator|&&
name|rplist
operator|==
name|NULL
condition|)
block|{
comment|/* Caller asked for custom revprops, but server is too old. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_IMPLEMENTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Server does not support custom revprops"
literal|" via log"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|has_children_param
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
condition|)
name|has_children
operator|=
name|FALSE
expr_stmt|;
else|else
name|has_children
operator|=
operator|(
name|svn_boolean_t
operator|)
name|has_children_param
expr_stmt|;
if|if
condition|(
name|has_subtractive_merge_param
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
condition|)
name|subtractive_merge
operator|=
name|FALSE
expr_stmt|;
else|else
name|subtractive_merge
operator|=
operator|(
name|svn_boolean_t
operator|)
name|has_subtractive_merge_param
expr_stmt|;
comment|/* Because the svn protocol won't let us send an invalid revnum, we have          to recover that fact using the extra parameter. */
if|if
condition|(
name|invalid_revnum_param
operator|!=
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
operator|&&
name|invalid_revnum_param
condition|)
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|cplist
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
comment|/* Interpret the changed-paths list. */
name|cphash
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cplist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_log_changed_path2_t
modifier|*
name|change
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|,
modifier|*
name|action
decl_stmt|,
modifier|*
name|cpath
decl_stmt|,
modifier|*
name|kind_str
decl_stmt|;
name|apr_uint64_t
name|text_mods
decl_stmt|,
name|prop_mods
decl_stmt|;
name|svn_revnum_t
name|copy_rev
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|cplist
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Changed-path entry not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|iterpool
argument_list|,
literal|"cw(?cr)?(?c?BB)"
argument_list|,
operator|&
name|cpath
argument_list|,
operator|&
name|action
argument_list|,
operator|&
name|copy_path
argument_list|,
operator|&
name|copy_rev
argument_list|,
operator|&
name|kind_str
argument_list|,
operator|&
name|text_mods
argument_list|,
operator|&
name|prop_mods
argument_list|)
argument_list|)
expr_stmt|;
name|cpath
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|cpath
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_path
condition|)
name|copy_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|copy_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|change
operator|=
name|svn_log_changed_path2_create
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|change
operator|->
name|action
operator|=
operator|*
name|action
expr_stmt|;
name|change
operator|->
name|copyfrom_path
operator|=
name|copy_path
expr_stmt|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|copy_rev
expr_stmt|;
name|change
operator|->
name|node_kind
operator|=
name|svn_node_kind_from_word
argument_list|(
name|kind_str
argument_list|)
expr_stmt|;
name|change
operator|->
name|text_modified
operator|=
name|optbool_to_tristate
argument_list|(
name|text_mods
argument_list|)
expr_stmt|;
name|change
operator|->
name|props_modified
operator|=
name|optbool_to_tristate
argument_list|(
name|prop_mods
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|cphash
argument_list|,
name|cpath
argument_list|,
name|change
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|cphash
operator|=
name|NULL
expr_stmt|;
name|nreceived
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|limit
operator|&&
operator|(
name|nest_level
operator|==
literal|0
operator|)
operator|&&
operator|(
operator|++
name|nreceived
operator|>
name|limit
operator|)
operator|)
operator|&&
operator|!
operator|*
name|outer_error
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|log_entry
operator|=
name|svn_log_entry_create
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|log_entry
operator|->
name|changed_paths
operator|=
name|cphash
expr_stmt|;
name|log_entry
operator|->
name|changed_paths2
operator|=
name|cphash
expr_stmt|;
name|log_entry
operator|->
name|revision
operator|=
name|rev
expr_stmt|;
name|log_entry
operator|->
name|has_children
operator|=
name|has_children
expr_stmt|;
name|log_entry
operator|->
name|subtractive_merge
operator|=
name|subtractive_merge
expr_stmt|;
if|if
condition|(
name|rplist
condition|)
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|rplist
argument_list|,
name|iterpool
argument_list|,
operator|&
name|log_entry
operator|->
name|revprops
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|revprops
operator|==
name|NULL
condition|)
name|log_entry
operator|->
name|revprops
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|revprops
operator|==
name|NULL
condition|)
block|{
comment|/* Caller requested all revprops; set author/date/log. */
if|if
condition|(
name|author
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Caller requested some; maybe set author/date/log. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|revprops
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|revprops
argument_list|,
name|i
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|author
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|)
operator|==
literal|0
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|author
argument_list|)
expr_stmt|;
if|if
condition|(
name|date
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
operator|==
literal|0
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|date
argument_list|)
expr_stmt|;
if|if
condition|(
name|message
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
operator|==
literal|0
condition|)
name|svn_hash_sets
argument_list|(
name|log_entry
operator|->
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
block|}
name|err
operator|=
name|receiver
argument_list|(
name|receiver_baton
argument_list|,
name|log_entry
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CEASE_INVOCATION
condition|)
block|{
operator|*
name|outer_error
operator|=
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
operator|*
name|outer_error
argument_list|,
name|err
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|log_entry
operator|->
name|has_children
condition|)
block|{
name|nest_level
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|log_entry
operator|->
name|revision
argument_list|)
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|nest_level
argument_list|)
expr_stmt|;
name|nest_level
operator|--
expr_stmt|;
block|}
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Read the response. */
return|return
name|svn_error_trace
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_log
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|int
name|limit
parameter_list|,
name|svn_boolean_t
name|discover_changed_paths
parameter_list|,
name|svn_boolean_t
name|strict_node_history
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revprops
parameter_list|,
name|svn_log_entry_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|outer_error
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_error_trace
argument_list|(
name|perform_ra_svn_log
argument_list|(
operator|&
name|outer_error
argument_list|,
name|session
argument_list|,
name|paths
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|limit
argument_list|,
name|discover_changed_paths
argument_list|,
name|strict_node_history
argument_list|,
name|include_merged_revisions
argument_list|,
name|revprops
argument_list|,
name|receiver
argument_list|,
name|receiver_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_error_compose_create
argument_list|(
name|outer_error
argument_list|,
name|err
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_check_path
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
specifier|const
name|char
modifier|*
name|kind_word
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_check_path
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w"
argument_list|,
operator|&
name|kind_word
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|kind
operator|=
name|svn_node_kind_from_word
argument_list|(
name|kind_word
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* If ERR is a command not supported error, wrap it in a    SVN_ERR_RA_NOT_IMPLEMENTED with error message MSG.  Else, return err. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|handle_unsupported_cmd
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_SVN_UNKNOWN_CMD
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_NOT_IMPLEMENTED
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
name|msg
argument_list|)
argument_list|)
return|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_stat
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|svn_dirent_t
modifier|*
modifier|*
name|dirent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
init|=
name|NULL
decl_stmt|;
name|svn_dirent_t
modifier|*
name|the_dirent
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_stat
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|rev
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"'stat' not implemented"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"(?l)"
argument_list|,
operator|&
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|list
condition|)
block|{
operator|*
name|dirent
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|kind
decl_stmt|,
modifier|*
name|cdate
decl_stmt|,
modifier|*
name|cauthor
decl_stmt|;
name|svn_boolean_t
name|has_props
decl_stmt|;
name|svn_revnum_t
name|crev
decl_stmt|;
name|apr_uint64_t
name|size
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|list
argument_list|,
name|pool
argument_list|,
literal|"wnbr(?c)(?c)"
argument_list|,
operator|&
name|kind
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|has_props
argument_list|,
operator|&
name|crev
argument_list|,
operator|&
name|cdate
argument_list|,
operator|&
name|cauthor
argument_list|)
argument_list|)
expr_stmt|;
name|the_dirent
operator|=
name|svn_dirent_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|the_dirent
operator|->
name|kind
operator|=
name|svn_node_kind_from_word
argument_list|(
name|kind
argument_list|)
expr_stmt|;
name|the_dirent
operator|->
name|size
operator|=
name|size
expr_stmt|;
comment|/* FIXME: svn_filesize_t */
name|the_dirent
operator|->
name|has_props
operator|=
name|has_props
expr_stmt|;
name|the_dirent
operator|->
name|created_rev
operator|=
name|crev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|the_dirent
operator|->
name|time
argument_list|,
name|cdate
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|the_dirent
operator|->
name|last_author
operator|=
name|cauthor
expr_stmt|;
operator|*
name|dirent
operator|=
name|the_dirent
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_locations
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locations
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|location_revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_boolean_t
name|is_done
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Transmit the parameters. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(cr(!"
argument_list|,
literal|"get-locations"
argument_list|,
name|path
argument_list|,
name|peg_revision
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|location_revisions
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|revision
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|location_revisions
argument_list|,
name|i
argument_list|,
name|svn_revnum_t
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!r!"
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.1 don't support this command. Check for this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"'get-locations' not implemented"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the hash items. */
name|is_done
operator|=
name|FALSE
expr_stmt|;
operator|*
name|locations
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|is_done
condition|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret_path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
operator|&
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|==
name|SVN_RA_SVN_WORD
operator|&&
name|strcmp
argument_list|(
name|item
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
condition|)
name|is_done
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Location entry not a list"
argument_list|)
argument_list|)
return|;
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
name|pool
argument_list|,
literal|"rc"
argument_list|,
operator|&
name|revision
argument_list|,
operator|&
name|ret_path
argument_list|)
argument_list|)
expr_stmt|;
name|ret_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|ret_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|apr_hash_set
argument_list|(
operator|*
name|locations
argument_list|,
name|apr_pmemdup
argument_list|(
name|pool
argument_list|,
operator|&
name|revision
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|revision
argument_list|)
argument_list|,
name|ret_path
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Read the response. This is so the server would have a chance to    * report an error. */
return|return
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_location_segments
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|start_rev
parameter_list|,
name|svn_revnum_t
name|end_rev
parameter_list|,
name|svn_location_segment_receiver_t
name|receiver
parameter_list|,
name|void
modifier|*
name|receiver_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|svn_boolean_t
name|is_done
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Transmit the parameters. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(c(?r)(?r)(?r))"
argument_list|,
literal|"get-location-segments"
argument_list|,
name|path
argument_list|,
name|peg_revision
argument_list|,
name|start_rev
argument_list|,
name|end_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.5 don't support this command. Check for this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"'get-location-segments'"
literal|" not implemented"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse the response. */
name|is_done
operator|=
name|FALSE
expr_stmt|;
while|while
condition|(
operator|!
name|is_done
condition|)
block|{
name|svn_revnum_t
name|range_start
decl_stmt|,
name|range_end
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|item
decl_stmt|;
specifier|const
name|char
modifier|*
name|ret_path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
operator|&
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|==
name|SVN_RA_SVN_WORD
operator|&&
name|strcmp
argument_list|(
name|item
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
condition|)
name|is_done
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Location segment entry not a list"
argument_list|)
argument_list|)
return|;
else|else
block|{
name|svn_location_segment_t
modifier|*
name|segment
init|=
name|apr_pcalloc
argument_list|(
name|iterpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|segment
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
name|iterpool
argument_list|,
literal|"rr(?c)"
argument_list|,
operator|&
name|range_start
argument_list|,
operator|&
name|range_end
argument_list|,
operator|&
name|ret_path
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|range_start
argument_list|)
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|range_end
argument_list|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected valid revision range"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|ret_path
condition|)
name|ret_path
operator|=
name|svn_relpath_canonicalize
argument_list|(
name|ret_path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|segment
operator|->
name|path
operator|=
name|ret_path
expr_stmt|;
name|segment
operator|->
name|range_start
operator|=
name|range_start
expr_stmt|;
name|segment
operator|->
name|range_end
operator|=
name|range_end
expr_stmt|;
name|SVN_ERR
argument_list|(
name|receiver
argument_list|(
name|segment
argument_list|,
name|receiver_baton
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Read the response. This is so the server would have a chance to    * report an error. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_file_revs
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_boolean_t
name|include_merged_revisions
parameter_list|,
name|svn_file_rev_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|rev_pool
decl_stmt|,
modifier|*
name|chunk_pool
decl_stmt|;
name|svn_boolean_t
name|has_txdelta
decl_stmt|;
name|svn_boolean_t
name|had_revision
init|=
name|FALSE
decl_stmt|;
comment|/* One sub-pool for each revision and one for each txdelta chunk.      Note that the rev_pool must live during the following txdelta. */
name|rev_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|chunk_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_file_revs
argument_list|(
name|sess_baton
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|start
argument_list|,
name|end
argument_list|,
name|include_merged_revisions
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.1 don't support this command.  Check for this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"'get-file-revs' not implemented"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_array_header_t
modifier|*
name|rev_proplist
decl_stmt|,
modifier|*
name|proplist
decl_stmt|;
name|apr_uint64_t
name|merged_rev_param
decl_stmt|;
name|apr_array_header_t
modifier|*
name|props
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|item
decl_stmt|;
name|apr_hash_t
modifier|*
name|rev_props
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
name|svn_boolean_t
name|merged_rev
decl_stmt|;
name|svn_txdelta_window_handler_t
name|d_handler
decl_stmt|;
name|void
modifier|*
name|d_baton
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|rev_pool
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|chunk_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|sess_baton
operator|->
name|conn
argument_list|,
name|rev_pool
argument_list|,
operator|&
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|==
name|SVN_RA_SVN_WORD
operator|&&
name|strcmp
argument_list|(
name|item
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
condition|)
break|break;
comment|/* Either we've got a correct revision or we will error out below. */
name|had_revision
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revision entry not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|item
operator|->
name|u
operator|.
name|list
argument_list|,
name|rev_pool
argument_list|,
literal|"crll?B"
argument_list|,
operator|&
name|p
argument_list|,
operator|&
name|rev
argument_list|,
operator|&
name|rev_proplist
argument_list|,
operator|&
name|proplist
argument_list|,
operator|&
name|merged_rev_param
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|p
argument_list|,
name|rev_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|rev_proplist
argument_list|,
name|rev_pool
argument_list|,
operator|&
name|rev_props
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_prop_diffs
argument_list|(
name|proplist
argument_list|,
name|rev_pool
argument_list|,
operator|&
name|props
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|merged_rev_param
operator|==
name|SVN_RA_SVN_UNSPECIFIED_NUMBER
condition|)
name|merged_rev
operator|=
name|FALSE
expr_stmt|;
else|else
name|merged_rev
operator|=
operator|(
name|svn_boolean_t
operator|)
name|merged_rev_param
expr_stmt|;
comment|/* Get the first delta chunk so we know if there is a delta. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|sess_baton
operator|->
name|conn
argument_list|,
name|chunk_pool
argument_list|,
operator|&
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Text delta chunk not a string"
argument_list|)
argument_list|)
return|;
name|has_txdelta
operator|=
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|len
operator|>
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handler
argument_list|(
name|handler_baton
argument_list|,
name|p
argument_list|,
name|rev
argument_list|,
name|rev_props
argument_list|,
name|merged_rev
argument_list|,
name|has_txdelta
condition|?
operator|&
name|d_handler
else|:
name|NULL
argument_list|,
operator|&
name|d_baton
argument_list|,
name|props
argument_list|,
name|rev_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the text delta if any. */
if|if
condition|(
name|has_txdelta
condition|)
block|{
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
if|if
condition|(
name|d_handler
condition|)
name|stream
operator|=
name|svn_txdelta_parse_svndiff
argument_list|(
name|d_handler
argument_list|,
name|d_baton
argument_list|,
name|TRUE
argument_list|,
name|rev_pool
argument_list|)
expr_stmt|;
else|else
name|stream
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|apr_size_t
name|size
decl_stmt|;
name|size
operator|=
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|len
expr_stmt|;
if|if
condition|(
name|stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|item
operator|->
name|u
operator|.
name|string
operator|->
name|data
argument_list|,
operator|&
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|chunk_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|sess_baton
operator|->
name|conn
argument_list|,
name|chunk_pool
argument_list|,
operator|&
name|item
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|item
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_STRING
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Text delta chunk not a string"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
name|stream
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|sess_baton
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return error if we didn't get any revisions. */
if|if
condition|(
operator|!
name|had_revision
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The get-file-revs command didn't return "
literal|"any revisions"
argument_list|)
argument_list|)
return|;
name|svn_pool_destroy
argument_list|(
name|chunk_pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|rev_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For each path in PATH_REVS, send a 'lock' command to the server.    Used with 1.2.x series servers which support locking, but of only    one path at a time.  ra_svn_lock(), which supports 'lock-many'    is now the default.  See svn_ra_lock() docstring for interface details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_lock_compat
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_revs
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_revs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_revnum_t
modifier|*
name|revnum
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|callback_err
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
name|revnum
operator|=
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_lock
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
name|path
argument_list|,
name|comment
argument_list|,
name|steal_lock
argument_list|,
operator|*
name|revnum
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.2 doesn't support locking.  Check this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Server doesn't support "
literal|"the lock command"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"l"
argument_list|,
operator|&
name|list
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|SVN_ERR
argument_list|(
name|parse_lock
argument_list|(
name|list
argument_list|,
name|iterpool
argument_list|,
operator|&
name|lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SVN_ERR_IS_LOCK_ERROR
argument_list|(
name|err
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|lock_func
condition|)
name|callback_err
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|err
condition|?
name|NULL
else|:
name|lock
argument_list|,
name|err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_err
condition|)
return|return
name|callback_err
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* For each path in PATH_TOKENS, send an 'unlock' command to the server.    Used with 1.2.x series servers which support unlocking, but of only    one path at a time.  ra_svn_unlock(), which supports 'unlock-many' is    now the default.  See svn_ra_unlock() docstring for interface details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_unlock_compat
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_tokens
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|,
modifier|*
name|callback_err
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
name|token
operator|=
name|val
expr_stmt|;
else|else
name|token
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_unlock
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
name|path
argument_list|,
name|token
argument_list|,
name|break_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.2 don't support locking.  Check this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Server doesn't support the unlock "
literal|"command"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|!
name|SVN_ERR_IS_UNLOCK_ERROR
argument_list|(
name|err
argument_list|)
condition|)
return|return
name|err
return|;
if|if
condition|(
name|lock_func
condition|)
name|callback_err
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_err
condition|)
return|return
name|callback_err
return|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Tell the server to lock all paths in PATH_REVS.    See svn_ra_lock() for interface details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_revs
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w((?c)b(!"
argument_list|,
literal|"lock-many"
argument_list|,
name|comment
argument_list|,
name|steal_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_revs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_revnum_t
modifier|*
name|revnum
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
name|revnum
operator|=
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"c(?r)"
argument_list|,
name|path
argument_list|,
operator|*
name|revnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Pre-1.3 servers don't support 'lock-many'. If that fails, fall back    * to 'lock'. */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_SVN_UNKNOWN_CMD
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|ra_svn_lock_compat
argument_list|(
name|session
argument_list|,
name|path_revs
argument_list|,
name|comment
argument_list|,
name|steal_lock
argument_list|,
name|lock_func
argument_list|,
name|lock_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Loop over responses to get lock information. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_revs
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_error_t
modifier|*
name|callback_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|status
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The server might have encountered some sort of fatal error in          the middle of the request list.  If this happens, it will          transmit "done" to end the lock-info early, and then the          overall command response will talk about the fatal error. */
if|if
condition|(
name|elt
operator|->
name|kind
operator|==
name|SVN_RA_SVN_WORD
operator|&&
name|strcmp
argument_list|(
name|elt
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Lock response not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|iterpool
argument_list|,
literal|"wl"
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|err
operator|=
name|svn_ra_svn__handle_failure_status
argument_list|(
name|list
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|parse_lock
argument_list|(
name|list
argument_list|,
name|iterpool
argument_list|,
operator|&
name|lock
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown status for lock command"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|lock_func
condition|)
name|callback_err
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|path
argument_list|,
name|TRUE
argument_list|,
name|err
condition|?
name|NULL
else|:
name|lock
argument_list|,
name|err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
else|else
name|callback_err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_err
condition|)
return|return
name|callback_err
return|;
block|}
comment|/* If we didn't break early above, and the whole hash was traversed,      read the final "done" from the server. */
if|if
condition|(
operator|!
name|hi
condition|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_WORD
operator|||
name|strcmp
argument_list|(
name|elt
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Didn't receive end marker for lock "
literal|"responses"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Tell the server to unlock all paths in PATH_TOKENS.    See svn_ra_unlock() for interface details. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_unlock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
name|path_tokens
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|svn_ra_lock_callback_t
name|lock_func
parameter_list|,
name|void
modifier|*
name|lock_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"w(b(!"
argument_list|,
literal|"unlock-many"
argument_list|,
name|break_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|val
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|val
argument_list|,
literal|""
argument_list|)
operator|!=
literal|0
condition|)
name|token
operator|=
name|val
expr_stmt|;
else|else
name|token
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"c(?c)"
argument_list|,
name|path
argument_list|,
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_tuple
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"!))"
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Pre-1.3 servers don't support 'unlock-many'. If unknown, fall back    * to 'unlock'.    */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_RA_SVN_UNKNOWN_CMD
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|ra_svn_unlock_compat
argument_list|(
name|session
argument_list|,
name|path_tokens
argument_list|,
name|break_lock
argument_list|,
name|lock_func
argument_list|,
name|lock_baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
if|if
condition|(
name|err
condition|)
return|return
name|err
return|;
comment|/* Loop over responses to unlock files. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|path_tokens
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|svn_error_t
modifier|*
name|callback_err
decl_stmt|;
specifier|const
name|char
modifier|*
name|status
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|iterpool
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The server might have encountered some sort of fatal error in          the middle of the request list.  If this happens, it will          transmit "done" to end the lock-info early, and then the          overall command response will talk about the fatal error. */
if|if
condition|(
name|elt
operator|->
name|kind
operator|==
name|SVN_RA_SVN_WORD
operator|&&
operator|(
name|strcmp
argument_list|(
name|elt
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|==
literal|0
operator|)
condition|)
break|break;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|path
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unlock response not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|iterpool
argument_list|,
literal|"wl"
argument_list|,
operator|&
name|status
argument_list|,
operator|&
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"failure"
argument_list|)
operator|==
literal|0
condition|)
name|err
operator|=
name|svn_ra_svn__handle_failure_status
argument_list|(
name|list
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|status
argument_list|,
literal|"success"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_tuple
argument_list|(
name|list
argument_list|,
name|iterpool
argument_list|,
literal|"c"
argument_list|,
operator|&
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unknown status for unlock command"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|lock_func
condition|)
name|callback_err
operator|=
name|lock_func
argument_list|(
name|lock_baton
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|err
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
else|else
name|callback_err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|callback_err
condition|)
return|return
name|callback_err
return|;
block|}
comment|/* If we didn't break early above, and the whole hash was traversed,      read the final "done" from the server. */
if|if
condition|(
operator|!
name|hi
condition|)
block|{
name|svn_ra_svn_item_t
modifier|*
name|elt
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_item
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
operator|&
name|elt
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_WORD
operator|||
name|strcmp
argument_list|(
name|elt
operator|->
name|u
operator|.
name|word
argument_list|,
literal|"done"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Didn't receive end marker for unlock "
literal|"responses"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_lock
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_lock
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.2 doesn't support locking.  Check this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Server doesn't support the get-lock "
literal|"command"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"(?l)"
argument_list|,
operator|&
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|list
condition|)
name|SVN_ERR
argument_list|(
name|parse_lock
argument_list|(
name|list
argument_list|,
name|pool
argument_list|,
name|lock
argument_list|)
argument_list|)
expr_stmt|;
else|else
operator|*
name|lock
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copied from svn_ra_get_path_relative_to_root() and de-vtable-ized    to prevent a dependency cycle. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|path_relative_to_root
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|rel_path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|root_url
decl_stmt|;
name|SVN_ERR
argument_list|(
name|ra_svn_get_repos_root
argument_list|(
name|session
argument_list|,
operator|&
name|root_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rel_path
operator|=
name|svn_uri_skip_ancestor
argument_list|(
name|root_url
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|rel_path
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_ILLEGAL_URL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' isn't a child of repository root "
literal|"URL '%s'"
argument_list|)
argument_list|,
name|url
argument_list|,
name|root_url
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_locks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_hash_t
modifier|*
modifier|*
name|locks
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_url
decl_stmt|,
modifier|*
name|abs_path
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Figure out the repository abspath from PATH. */
name|full_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|sess
operator|->
name|url
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|path_relative_to_root
argument_list|(
name|session
argument_list|,
operator|&
name|abs_path
argument_list|,
name|full_url
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|abs_path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|abs_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_locks
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|depth
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.2 doesn't support locking.  Check this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Server doesn't support the get-lock "
literal|"command"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"l"
argument_list|,
operator|&
name|list
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|locks
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|list
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|svn_ra_svn_item_t
modifier|*
name|elt
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|list
argument_list|,
name|i
argument_list|,
name|svn_ra_svn_item_t
argument_list|)
decl_stmt|;
if|if
condition|(
name|elt
operator|->
name|kind
operator|!=
name|SVN_RA_SVN_LIST
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Lock element not a list"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|parse_lock
argument_list|(
name|elt
operator|->
name|u
operator|.
name|list
argument_list|,
name|pool
argument_list|,
operator|&
name|lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Filter out unwanted paths.  Since Subversion only allows          locks on files, we can treat depth=immediates the same as          depth=files for filtering purposes.  Meaning, we'll keep          this lock if:           a) its path is the very path we queried, or          b) we've asked for a fully recursive answer, or          c) we've asked for depth=files or depth=immediates, and this             lock is on an immediate child of our query path.       */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|abs_path
argument_list|,
name|lock
operator|->
name|path
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|depth
operator|==
name|svn_depth_infinity
operator|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
operator|*
name|locks
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|depth
operator|==
name|svn_depth_files
operator|)
operator|||
operator|(
name|depth
operator|==
name|svn_depth_immediates
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|relpath
init|=
name|svn_fspath__skip_ancestor
argument_list|(
name|abs_path
argument_list|,
name|lock
operator|->
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
name|relpath
operator|&&
operator|(
name|svn_path_component_count
argument_list|(
name|relpath
argument_list|)
operator|==
literal|1
operator|)
condition|)
name|svn_hash_sets
argument_list|(
operator|*
name|locks
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|lock
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_replay
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_replay
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|revision
argument_list|,
name|low_water_mark
argument_list|,
name|send_deltas
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Server doesn't support the replay "
literal|"command"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn_drive_editor2
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_ra_svn__read_cmd_response
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_replay_range
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|start_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
name|low_water_mark
parameter_list|,
name|svn_boolean_t
name|send_deltas
parameter_list|,
name|svn_ra_replay_revstart_callback_t
name|revstart_func
parameter_list|,
name|svn_ra_replay_revfinish_callback_t
name|revfinish_func
parameter_list|,
name|void
modifier|*
name|replay_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
name|svn_boolean_t
name|drive_aborted
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_replay_range
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
name|start_revision
argument_list|,
name|end_revision
argument_list|,
name|low_water_mark
argument_list|,
name|send_deltas
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"Server doesn't support the "
literal|"replay-range command"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|rev
operator|=
name|start_revision
init|;
name|rev
operator|<=
name|end_revision
condition|;
name|rev
operator|++
control|)
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|apr_hash_t
modifier|*
name|rev_props
decl_stmt|;
specifier|const
name|char
modifier|*
name|word
decl_stmt|;
name|apr_array_header_t
modifier|*
name|list
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_tuple
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|iterpool
argument_list|,
literal|"wl"
argument_list|,
operator|&
name|word
argument_list|,
operator|&
name|list
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|word
argument_list|,
literal|"revprops"
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_RA_SVN_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected 'revprops', found '%s'"
argument_list|)
argument_list|,
name|word
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__parse_proplist
argument_list|(
name|list
argument_list|,
name|iterpool
argument_list|,
operator|&
name|rev_props
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|revstart_func
argument_list|(
name|rev
argument_list|,
name|replay_baton
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|rev_props
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn_drive_editor2
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|iterpool
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
operator|&
name|drive_aborted
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If drive_editor2() aborted the commit, do NOT try to call          revfinish_func and commit the transaction! */
if|if
condition|(
name|drive_aborted
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_RA_SVN_EDIT_ABORTED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error while replaying commit"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|revfinish_func
argument_list|(
name|rev
argument_list|,
name|replay_baton
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|rev_props
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_ra_svn__read_cmd_response
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|pool
argument_list|,
literal|""
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_has_capability
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_boolean_t
modifier|*
name|has
parameter_list|,
specifier|const
name|char
modifier|*
name|capability
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess
init|=
name|session
operator|->
name|priv
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|capabilities
index|[]
index|[
literal|2
index|]
init|=
block|{
comment|/* { ra capability string, svn:// wire capability string} */
block|{
name|SVN_RA_CAPABILITY_DEPTH
block|,
name|SVN_RA_SVN_CAP_DEPTH
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_MERGEINFO
block|,
name|SVN_RA_SVN_CAP_MERGEINFO
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_LOG_REVPROPS
block|,
name|SVN_RA_SVN_CAP_LOG_REVPROPS
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_PARTIAL_REPLAY
block|,
name|SVN_RA_SVN_CAP_PARTIAL_REPLAY
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_COMMIT_REVPROPS
block|,
name|SVN_RA_SVN_CAP_COMMIT_REVPROPS
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_ATOMIC_REVPROPS
block|,
name|SVN_RA_SVN_CAP_ATOMIC_REVPROPS
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_INHERITED_PROPS
block|,
name|SVN_RA_SVN_CAP_INHERITED_PROPS
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_EPHEMERAL_TXNPROPS
block|,
name|SVN_RA_SVN_CAP_EPHEMERAL_TXNPROPS
block|}
block|,
block|{
name|SVN_RA_CAPABILITY_GET_FILE_REVS_REVERSE
block|,
name|SVN_RA_SVN_CAP_GET_FILE_REVS_REVERSE
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
comment|/* End of list marker */
block|}
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|*
name|has
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|capabilities
index|[
name|i
index|]
index|[
literal|0
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|capability
argument_list|,
name|capabilities
index|[
name|i
index|]
index|[
literal|0
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|has
operator|=
name|svn_ra_svn_has_capability
argument_list|(
name|sess
operator|->
name|conn
argument_list|,
name|capabilities
index|[
name|i
index|]
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNKNOWN_CAPABILITY
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Don't know anything about capability '%s'"
argument_list|)
argument_list|,
name|capability
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_deleted_rev
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|peg_revision
parameter_list|,
name|svn_revnum_t
name|end_revision
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision_deleted
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
comment|/* Transmit the parameters. */
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_deleted_rev
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
name|path
argument_list|,
name|peg_revision
argument_list|,
name|end_revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Servers before 1.6 don't support this command.  Check for this here. */
name|SVN_ERR
argument_list|(
name|handle_unsupported_cmd
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|pool
argument_list|)
argument_list|,
name|N_
argument_list|(
literal|"'get-deleted-rev' not implemented"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|pool
argument_list|,
literal|"r"
argument_list|,
name|revision_deleted
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_register_editor_shim_callbacks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|conn
operator|->
name|shim_callbacks
operator|=
name|callbacks
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ra_svn_get_inherited_props
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|apr_array_header_t
modifier|*
modifier|*
name|iprops
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_ra_svn__session_baton_t
modifier|*
name|sess_baton
init|=
name|session
operator|->
name|priv
decl_stmt|;
name|svn_ra_svn_conn_t
modifier|*
name|conn
init|=
name|sess_baton
operator|->
name|conn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|iproplist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__write_cmd_get_iprops
argument_list|(
name|conn
argument_list|,
name|scratch_pool
argument_list|,
name|path
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handle_auth_request
argument_list|(
name|sess_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_svn__read_cmd_response
argument_list|(
name|conn
argument_list|,
name|scratch_pool
argument_list|,
literal|"l"
argument_list|,
operator|&
name|iproplist
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|parse_iproplist
argument_list|(
name|iprops
argument_list|,
name|iproplist
argument_list|,
name|session
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|svn_ra__vtable_t
name|ra_svn_vtable
init|=
block|{
name|svn_ra_svn_version
block|,
name|ra_svn_get_description
block|,
name|ra_svn_get_schemes
block|,
name|ra_svn_open
block|,
name|ra_svn_reparent
block|,
name|ra_svn_get_session_url
block|,
name|ra_svn_get_latest_rev
block|,
name|ra_svn_get_dated_rev
block|,
name|ra_svn_change_rev_prop
block|,
name|ra_svn_rev_proplist
block|,
name|ra_svn_rev_prop
block|,
name|ra_svn_commit
block|,
name|ra_svn_get_file
block|,
name|ra_svn_get_dir
block|,
name|ra_svn_get_mergeinfo
block|,
name|ra_svn_update
block|,
name|ra_svn_switch
block|,
name|ra_svn_status
block|,
name|ra_svn_diff
block|,
name|ra_svn_log
block|,
name|ra_svn_check_path
block|,
name|ra_svn_stat
block|,
name|ra_svn_get_uuid
block|,
name|ra_svn_get_repos_root
block|,
name|ra_svn_get_locations
block|,
name|ra_svn_get_location_segments
block|,
name|ra_svn_get_file_revs
block|,
name|ra_svn_lock
block|,
name|ra_svn_unlock
block|,
name|ra_svn_get_lock
block|,
name|ra_svn_get_locks
block|,
name|ra_svn_replay
block|,
name|ra_svn_has_capability
block|,
name|ra_svn_replay_range
block|,
name|ra_svn_get_deleted_rev
block|,
name|ra_svn_register_editor_shim_callbacks
block|,
name|ra_svn_get_inherited_props
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_ra_svn__init
parameter_list|(
specifier|const
name|svn_version_t
modifier|*
name|loader_version
parameter_list|,
specifier|const
name|svn_ra__vtable_t
modifier|*
modifier|*
name|vtable
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ver_check_list2
argument_list|(
name|svn_ra_svn_version
argument_list|()
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Simplified version check to make sure we can safely use the      VTABLE parameter. The RA loader does a more exhaustive check. */
if|if
condition|(
name|loader_version
operator|->
name|major
operator|!=
name|SVN_VER_MAJOR
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported RA loader version (%d) for ra_svn"
argument_list|)
argument_list|,
name|loader_version
operator|->
name|major
argument_list|)
return|;
block|}
operator|*
name|vtable
operator|=
operator|&
name|ra_svn_vtable
expr_stmt|;
ifdef|#
directive|ifdef
name|SVN_HAVE_SASL
name|SVN_ERR
argument_list|(
name|svn_ra_svn__sasl_init
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Compatibility wrapper for the 1.1 and before API. */
end_comment

begin_define
define|#
directive|define
name|NAME
value|"ra_svn"
end_define

begin_define
define|#
directive|define
name|DESCRIPTION
value|RA_SVN_DESCRIPTION
end_define

begin_define
define|#
directive|define
name|VTBL
value|ra_svn_vtable
end_define

begin_define
define|#
directive|define
name|INITFUNC
value|svn_ra_svn__init
end_define

begin_define
define|#
directive|define
name|COMPAT_INITFUNC
value|svn_ra_svn_init
end_define

begin_include
include|#
directive|include
file|"../libsvn_ra/wrapper_template.h"
end_include

end_unit

