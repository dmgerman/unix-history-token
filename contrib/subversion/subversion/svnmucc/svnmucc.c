begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnmucc.c: Subversion Multiple URL Client  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  *  */
end_comment

begin_comment
comment|/*  Multiple URL Command Client      Combine a list of mv, cp and rm commands on URLs into a single commit.      How it works: the command line arguments are parsed into an array of     action structures.  The action structures are interpreted to build a     tree of operation structures.  The tree of operation structures is     used to drive an RA commit editor to produce a single commit.      To build this client, type 'make svnmucc' from the root of your     Subversion source directory. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_client_mtcc.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_client"
block|,
name|svn_client_version
block|}
block|,
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_ra"
block|,
name|svn_ra_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_callback
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"r%ld committed by %s at %s\n"
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|,
operator|(
name|commit_info
operator|->
name|author
condition|?
name|commit_info
operator|->
name|author
else|:
literal|"(no author)"
operator|)
argument_list|,
name|commit_info
operator|->
name|date
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
name|action_code_t
block|{
name|ACTION_MV
block|,
name|ACTION_MKDIR
block|,
name|ACTION_CP
block|,
name|ACTION_PROPSET
block|,
name|ACTION_PROPSETF
block|,
name|ACTION_PROPDEL
block|,
name|ACTION_PUT
block|,
name|ACTION_RM
block|}
name|action_code_t
typedef|;
end_typedef

begin_comment
comment|/* Return the portion of URL that is relative to ANCHOR (URI-decoded). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|subtract_anchor
parameter_list|(
specifier|const
name|char
modifier|*
name|anchor
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_uri_skip_ancestor
argument_list|(
name|anchor
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|action
block|{
name|action_code_t
name|action
decl_stmt|;
comment|/* revision (copy-from-rev of path[0] for cp; base-rev for put) */
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* action  path[0]  path[1]    * ------  -------  -------    * mv      source   target    * mkdir   target   (null)    * cp      source   target    * put     target   source    * rm      target   (null)    * propset target   (null)    */
specifier|const
name|char
modifier|*
name|path
index|[
literal|2
index|]
decl_stmt|;
comment|/* property name/value */
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|prop_value
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|execute
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|actions
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor
parameter_list|,
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|svn_client_ctx_t
modifier|*
name|ctx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_client__mtcc_t
modifier|*
name|mtcc
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_create
argument_list|(
operator|&
name|mtcc
argument_list|,
name|anchor
argument_list|,
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|?
name|base_revision
else|:
name|SVN_INVALID_REVNUM
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actions
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|action
modifier|*
name|action
init|=
name|APR_ARRAY_IDX
argument_list|(
name|actions
argument_list|,
name|i
argument_list|,
expr|struct
name|action
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path1
decl_stmt|,
modifier|*
name|path2
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|action
operator|->
name|action
condition|)
block|{
case|case
name|ACTION_MV
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|path2
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|1
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_move
argument_list|(
name|path1
argument_list|,
name|path2
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_CP
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|path2
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|1
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_copy
argument_list|(
name|path1
argument_list|,
name|action
operator|->
name|rev
argument_list|,
name|path2
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RM
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_delete
argument_list|(
name|path1
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_MKDIR
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_mkdir
argument_list|(
name|path1
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_PUT
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|path1
argument_list|,
name|TRUE
argument_list|,
name|mtcc
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_delete
argument_list|(
name|path1
argument_list|,
name|mtcc
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|kind
operator|=
name|svn_node_none
expr_stmt|;
block|}
block|{
name|svn_stream_t
modifier|*
name|src
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|action
operator|->
name|path
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|src
argument_list|,
name|action
operator|->
name|path
index|[
literal|1
index|]
argument_list|,
name|pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdin
argument_list|(
operator|&
name|src
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_update_file
argument_list|(
name|path1
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_add_file
argument_list|(
name|path1
argument_list|,
name|src
argument_list|,
name|NULL
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ACTION_PROPSET
case|:
case|case
name|ACTION_PROPDEL
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_client__mtcc_add_propset
argument_list|(
name|path1
argument_list|,
name|action
operator|->
name|prop_name
argument_list|,
name|action
operator|->
name|prop_value
argument_list|,
name|FALSE
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_PROPSETF
case|:
default|default:
name|SVN_ERR_MALFUNCTION_NO_RETURN
argument_list|()
expr_stmt|;
block|}
block|}
name|err
operator|=
name|svn_client__mtcc_commit
argument_list|(
name|revprops
argument_list|,
name|commit_callback
argument_list|,
name|NULL
argument_list|,
name|mtcc
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_propvalue_file
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|value
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|value
argument_list|,
name|filename
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|svn_string_create_from_buf
argument_list|(
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform the typical suite of manipulations for user-provided URLs    on URL, returning the result (allocated from POOL): IRI-to-URI    conversion, auto-escaping, and canonicalization. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sanitize_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|url
operator|=
name|svn_path_uri_from_iri
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|url
operator|=
name|svn_path_uri_autoescape
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_uri_canonicalize
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Type 'svnmucc --help' for usage.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print a usage message on STREAM. */
end_comment

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"usage: svnmucc ACTION...\n"
literal|"Subversion multiple URL command client.\n"
literal|"Type 'svnmucc --version' to see the program version and RA modules.\n"
literal|"\n"
literal|"  Perform one or more Subversion repository URL-based ACTIONs, committing\n"
literal|"  the result as a (single) new revision.\n"
literal|"\n"
literal|"Actions:\n"
literal|"  cp REV SRC-URL DST-URL : copy SRC-URL@REV to DST-URL\n"
literal|"  mkdir URL              : create new directory URL\n"
literal|"  mv SRC-URL DST-URL     : move SRC-URL to DST-URL\n"
literal|"  rm URL                 : delete URL\n"
literal|"  put SRC-FILE URL       : add or modify file URL with contents copied from\n"
literal|"                           SRC-FILE (use \"-\" to read from standard input)\n"
literal|"  propset NAME VALUE URL : set property NAME on URL to VALUE\n"
literal|"  propsetf NAME FILE URL : set property NAME on URL to value read from FILE\n"
literal|"  propdel NAME URL       : delete property NAME from URL\n"
literal|"\n"
literal|"Valid options:\n"
literal|"  -h, -? [--help]        : display this text\n"
literal|"  -m [--message] ARG     : use ARG as a log message\n"
literal|"  -F [--file] ARG        : read log message from file ARG\n"
literal|"  -u [--username] ARG    : commit the changes as username ARG\n"
literal|"  -p [--password] ARG    : use ARG as the password\n"
literal|"  -U [--root-url] ARG    : interpret all action URLs relative to ARG\n"
literal|"  -r [--revision] ARG    : use revision ARG as baseline for changes\n"
literal|"  --with-revprop ARG     : set revision property in the following format:\n"
literal|"                               NAME[=VALUE]\n"
literal|"  --non-interactive      : do no interactive prompting (default is to\n"
literal|"                           prompt only if standard input is a terminal)\n"
literal|"  --force-interactive    : do interactive prompting even if standard\n"
literal|"                           input is not a terminal\n"
literal|"  --trust-server-cert    : deprecated;\n"
literal|"                           same as --trust-server-cert-failures=unknown-ca\n"
literal|"  --trust-server-cert-failures ARG\n"
literal|"                           with --non-interactive, accept SSL server\n"
literal|"                           certificates with failures; ARG is comma-separated\n"
literal|"                           list of 'unknown-ca' (Unknown Authority),\n"
literal|"                           'cn-mismatch' (Hostname mismatch), 'expired'\n"
literal|"                           (Expired certificate),'not-yet-valid' (Not yet\n"
literal|"                           valid certificate) and 'other' (all other not\n"
literal|"                           separately classified certificate errors).\n"
literal|"  -X [--extra-args] ARG  : append arguments from file ARG (one per line;\n"
literal|"                           use \"-\" to read from standard input)\n"
literal|"  --config-dir ARG       : use ARG to override the config directory\n"
literal|"  --config-option ARG    : use ARG to override a configuration option\n"
literal|"  --no-auth-cache        : do not cache authentication tokens\n"
literal|"  --version              : print version information\n"
argument_list|)
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|insufficient
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"insufficient arguments"
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|display_version
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ra_desc_start
init|=
literal|"The following repository access (RA) modules are available:\n\n"
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|version_footer
decl_stmt|;
name|version_footer
operator|=
name|svn_stringbuf_create
argument_list|(
name|ra_desc_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_print_help4
argument_list|(
name|NULL
argument_list|,
literal|"svnmucc"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return an error about the mutual exclusivity of the -m, -F, and    --with-revprop=svn:log command-line options. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mutually_exclusive_logs_error
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--message (-m), --file (-F), and "
literal|"--with-revprop=svn:log are mutually "
literal|"exclusive"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Obtain the log message from multiple sources, producing an error    if there are multiple sources. Store the result in *FINAL_MESSAGE.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sanitize_log_sources
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|final_message
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|filedata
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|msg
decl_stmt|;
operator|*
name|final_message
operator|=
name|NULL
expr_stmt|;
comment|/* If we already have a log message in the revprop hash, then just      make sure the user didn't try to also use -m or -F.  Otherwise,      we need to consult -m or -F to find a log message, if any. */
name|msg
operator|=
name|svn_hash_gets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
condition|)
block|{
if|if
condition|(
name|filedata
operator|||
name|message
condition|)
return|return
name|mutually_exclusive_logs_error
argument_list|()
return|;
operator|*
name|final_message
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|msg
operator|->
name|data
argument_list|)
expr_stmt|;
comment|/* Will be re-added by libsvn_client */
name|svn_hash_sets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filedata
condition|)
block|{
if|if
condition|(
name|message
condition|)
return|return
name|mutually_exclusive_logs_error
argument_list|()
return|;
operator|*
name|final_message
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|filedata
operator|->
name|data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message
condition|)
block|{
operator|*
name|final_message
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|message
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Baton for log_message_func */
end_comment

begin_struct
struct|struct
name|log_message_baton
block|{
name|svn_boolean_t
name|non_interactive
decl_stmt|;
specifier|const
name|char
modifier|*
name|log_message
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_client_get_commit_log3_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|log_message_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|log_msg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmp_file
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|commit_items
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|log_message_baton
modifier|*
name|lmb
init|=
name|baton
decl_stmt|;
operator|*
name|tmp_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lmb
operator|->
name|log_message
condition|)
block|{
name|svn_string_t
modifier|*
name|message
init|=
name|svn_string_create
argument_list|(
name|lmb
operator|->
name|log_message
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR_W
argument_list|(
name|svn_subst_translate_string2
argument_list|(
operator|&
name|message
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|message
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
name|_
argument_list|(
literal|"Error normalizing log message to internal format"
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|log_msg
operator|=
name|message
operator|->
name|data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|lmb
operator|->
name|non_interactive
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot invoke editor to get log message "
literal|"when non-interactive"
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|svn_string_t
modifier|*
name|msg
init|=
name|svn_string_create
argument_list|(
literal|""
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__edit_string_externally
argument_list|(
operator|&
name|msg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|,
name|msg
argument_list|,
literal|"svnmucc-commit"
argument_list|,
name|lmb
operator|->
name|ctx
operator|->
name|config
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|&&
name|msg
operator|->
name|data
condition|)
operator|*
name|log_msg
operator|=
name|msg
operator|->
name|data
expr_stmt|;
else|else
operator|*
name|log_msg
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * On success, leave *EXIT_CODE untouched and return SVN_NO_ERROR. On error,  * either return an error to be displayed, or set *EXIT_CODE to non-zero and  * return SVN_NO_ERROR.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sub_main
parameter_list|(
name|int
modifier|*
name|exit_code
parameter_list|,
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|actions
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|action
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|anchor
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_getopt_t
modifier|*
name|opts
decl_stmt|;
enum|enum
block|{
name|config_dir_opt
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|config_inline_opt
block|,
name|no_auth_cache_opt
block|,
name|version_opt
block|,
name|with_revprop_opt
block|,
name|non_interactive_opt
block|,
name|force_interactive_opt
block|,
name|trust_server_cert_opt
block|,
name|trust_server_cert_failures_opt
block|,   }
enum|;
specifier|static
specifier|const
name|apr_getopt_option_t
name|options
index|[]
init|=
block|{
block|{
literal|"message"
block|,
literal|'m'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"file"
block|,
literal|'F'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"username"
block|,
literal|'u'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"password"
block|,
literal|'p'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"root-url"
block|,
literal|'U'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"with-revprop"
block|,
name|with_revprop_opt
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"extra-args"
block|,
literal|'X'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"non-interactive"
block|,
name|non_interactive_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"force-interactive"
block|,
name|force_interactive_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"trust-server-cert"
block|,
name|trust_server_cert_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"trust-server-cert-failures"
block|,
name|trust_server_cert_failures_opt
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"config-dir"
block|,
name|config_dir_opt
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"config-option"
block|,
name|config_inline_opt
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-auth-cache"
block|,
name|no_auth_cache_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"version"
block|,
name|version_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|filedata
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|,
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_url
init|=
name|NULL
decl_stmt|,
modifier|*
name|extra_args_file
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_dir
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|config_options
decl_stmt|;
name|svn_boolean_t
name|non_interactive
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|force_interactive
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_unknown_ca
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_cn_mismatch
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_expired
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_not_yet_valid
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_other_failure
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|no_auth_cache
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|show_version
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|show_help
init|=
name|FALSE
decl_stmt|;
name|svn_revnum_t
name|base_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_array_header_t
modifier|*
name|action_args
decl_stmt|;
name|apr_hash_t
modifier|*
name|revprops
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|cfg_hash
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg_config
decl_stmt|;
name|svn_client_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|struct
name|log_message_baton
name|lmb
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Check library versions */
name|SVN_ERR
argument_list|(
name|check_lib_versions
argument_list|()
argument_list|)
expr_stmt|;
name|config_options
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|apr_getopt_init
argument_list|(
operator|&
name|opts
argument_list|,
name|pool
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|opts
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
name|apr_status_t
name|status
init|=
name|apr_getopt_long
argument_list|(
name|opts
argument_list|,
name|options
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
break|break;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
block|{
name|usage
argument_list|(
name|pool
argument_list|)
expr_stmt|;
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'m'
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|message
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
block|{
specifier|const
name|char
modifier|*
name|arg_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|arg_utf8
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|filedata
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|username
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|password
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|root_url
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|root_url
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a URL\n"
argument_list|,
name|root_url
argument_list|)
return|;
name|root_url
operator|=
name|sanitize_url
argument_list|(
name|root_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
block|{
specifier|const
name|char
modifier|*
name|saved_arg
init|=
name|arg
decl_stmt|;
name|char
modifier|*
name|digits_end
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|*
name|arg
operator|==
literal|'r'
condition|)
name|arg
operator|++
expr_stmt|;
name|base_revision
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|digits_end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|digits_end
operator|)
operator|||
operator|*
name|digits_end
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number '%s'"
argument_list|)
argument_list|,
name|saved_arg
argument_list|)
return|;
block|}
break|break;
case|case
name|with_revprop_opt
case|:
name|SVN_ERR
argument_list|(
name|svn_opt_parse_revprop
argument_list|(
operator|&
name|revprops
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|extra_args_file
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|non_interactive_opt
case|:
name|non_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|force_interactive_opt
case|:
name|force_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|trust_server_cert_opt
case|:
comment|/* backward compat */
name|trust_unknown_ca
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|trust_server_cert_failures_opt
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_trust_options
argument_list|(
operator|&
name|trust_unknown_ca
argument_list|,
operator|&
name|trust_cn_mismatch
argument_list|,
operator|&
name|trust_expired
argument_list|,
operator|&
name|trust_not_yet_valid
argument_list|,
operator|&
name|trust_other_failure
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|config_dir_opt
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|config_dir
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|config_inline_opt
case|:
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__parse_config_option
argument_list|(
name|config_options
argument_list|,
name|opt_arg
argument_list|,
literal|"svnmucc: "
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|no_auth_cache_opt
case|:
name|no_auth_cache
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|version_opt
case|:
name|show_version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|show_help
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|show_help
condition|)
block|{
name|help
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|show_version
condition|)
block|{
name|SVN_ERR
argument_list|(
name|display_version
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|non_interactive
operator|&&
name|force_interactive
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--non-interactive and --force-interactive "
literal|"are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
else|else
name|non_interactive
operator|=
operator|!
name|svn_cmdline__be_interactive
argument_list|(
name|non_interactive
argument_list|,
name|force_interactive
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|non_interactive
condition|)
block|{
if|if
condition|(
name|trust_unknown_ca
operator|||
name|trust_cn_mismatch
operator|||
name|trust_expired
operator|||
name|trust_not_yet_valid
operator|||
name|trust_other_failure
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--trust-server-cert-failures requires "
literal|"--non-interactive"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Copy the rest of our command-line arguments to an array,      UTF-8-ing them along the way. */
name|action_args
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|opts
operator|->
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|opts
operator|->
name|ind
operator|<
name|opts
operator|->
name|argc
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
name|opts
operator|->
name|argv
index|[
name|opts
operator|->
name|ind
operator|++
index|]
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|APR_ARRAY_PUSH
argument_list|(
name|action_args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If there are extra arguments in a supplementary file, tack those      on, too (again, in UTF8 form). */
if|if
condition|(
name|extra_args_file
condition|)
block|{
specifier|const
name|char
modifier|*
name|extra_args_file_utf8
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|contents
decl_stmt|,
modifier|*
name|contents_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|extra_args_file_utf8
argument_list|,
name|extra_args_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|contents
argument_list|,
name|extra_args_file_utf8
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_stringbuf_to_utf8
argument_list|(
operator|&
name|contents_utf8
argument_list|,
name|contents
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_cstring_split_append
argument_list|(
name|action_args
argument_list|,
name|contents_utf8
operator|->
name|data
argument_list|,
literal|"\n\r"
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Now initialize the client context */
name|err
operator|=
name|svn_config_get_config
argument_list|(
operator|&
name|cfg_hash
argument_list|,
name|config_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Fallback to default config if the config directory isn't readable          or is not a directory. */
if|if
condition|(
name|APR_STATUS_IS_EACCES
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|||
name|SVN__APR_STATUS_IS_ENOTDIR
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_handle_warning2
argument_list|(
name|stderr
argument_list|,
name|err
argument_list|,
literal|"svnmucc: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config__get_default_config
argument_list|(
operator|&
name|cfg_hash
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
return|return
name|err
return|;
block|}
if|if
condition|(
name|config_options
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline__apply_config_options
argument_list|(
name|cfg_hash
argument_list|,
name|config_options
argument_list|,
literal|"svnmucc: "
argument_list|,
literal|"--config-option"
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_client_create_context2
argument_list|(
operator|&
name|ctx
argument_list|,
name|cfg_hash
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_config
operator|=
name|svn_hash_gets
argument_list|(
name|cfg_hash
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_create_auth_baton2
argument_list|(
operator|&
name|ctx
operator|->
name|auth_baton
argument_list|,
name|non_interactive
argument_list|,
name|username
argument_list|,
name|password
argument_list|,
name|config_dir
argument_list|,
name|no_auth_cache
argument_list|,
name|trust_unknown_ca
argument_list|,
name|trust_cn_mismatch
argument_list|,
name|trust_expired
argument_list|,
name|trust_not_yet_valid
argument_list|,
name|trust_other_failure
argument_list|,
name|cfg_config
argument_list|,
name|ctx
operator|->
name|cancel_func
argument_list|,
name|ctx
operator|->
name|cancel_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lmb
operator|.
name|non_interactive
operator|=
name|non_interactive
expr_stmt|;
name|lmb
operator|.
name|ctx
operator|=
name|ctx
expr_stmt|;
comment|/* Make sure we have a log message to use. */
name|SVN_ERR
argument_list|(
name|sanitize_log_sources
argument_list|(
operator|&
name|lmb
operator|.
name|log_message
argument_list|,
name|message
argument_list|,
name|revprops
argument_list|,
name|filedata
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|log_msg_func3
operator|=
name|log_message_func
expr_stmt|;
name|ctx
operator|->
name|log_msg_baton3
operator|=
operator|&
name|lmb
expr_stmt|;
comment|/* Now, we iterate over the combined set of arguments -- our actions. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|action_args
operator|->
name|nelts
condition|;
control|)
block|{
name|int
name|j
decl_stmt|,
name|num_url_args
decl_stmt|;
specifier|const
name|char
modifier|*
name|action_string
init|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|struct
name|action
modifier|*
name|action
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|action
argument_list|)
argument_list|)
decl_stmt|;
comment|/* First, parse the action. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"mv"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_MV
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"cp"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_CP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"mkdir"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_MKDIR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"rm"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_RM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"put"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PUT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"propset"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PROPSET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"propsetf"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PROPSETF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"propdel"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PROPDEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"?"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"h"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"help"
argument_list|)
condition|)
block|{
name|help
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not an action\n"
argument_list|,
name|action_string
argument_list|)
return|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
return|return
name|insufficient
argument_list|()
return|;
comment|/* For copies, there should be a revision number next. */
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_CP
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev_str
init|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|rev_str
argument_list|,
literal|"head"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rev_str
argument_list|,
literal|"HEAD"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|end
decl_stmt|;
while|while
condition|(
operator|*
name|rev_str
operator|==
literal|'r'
condition|)
operator|++
name|rev_str
expr_stmt|;
name|action
operator|->
name|rev
operator|=
name|strtol
argument_list|(
name|rev_str
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a revision\n"
argument_list|,
name|rev_str
argument_list|)
return|;
block|}
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
return|return
name|insufficient
argument_list|()
return|;
block|}
else|else
block|{
name|action
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* For puts, there should be a local file next. */
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_PUT
condition|)
block|{
name|action
operator|->
name|path
index|[
literal|1
index|]
operator|=
name|svn_dirent_internal_style
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
return|return
name|insufficient
argument_list|()
return|;
block|}
comment|/* For propset, propsetf, and propdel, a property name (and          maybe a property value or file which contains one) comes next. */
if|if
condition|(
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSET
operator|)
operator|||
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSETF
operator|)
operator|||
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPDEL
operator|)
condition|)
block|{
name|action
operator|->
name|prop_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
return|return
name|insufficient
argument_list|()
return|;
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPDEL
condition|)
block|{
name|action
operator|->
name|prop_value
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSET
condition|)
block|{
name|action
operator|->
name|prop_value
operator|=
name|svn_string_create
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
return|return
name|insufficient
argument_list|()
return|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|propval_file
init|=
name|svn_dirent_internal_style
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
return|return
name|insufficient
argument_list|()
return|;
name|SVN_ERR
argument_list|(
name|read_propvalue_file
argument_list|(
operator|&
operator|(
name|action
operator|->
name|prop_value
operator|)
argument_list|,
name|propval_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|action
operator|->
name|action
operator|=
name|ACTION_PROPSET
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|->
name|prop_value
operator|&&
name|svn_prop_needs_translation
argument_list|(
name|action
operator|->
name|prop_name
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|translated_value
decl_stmt|;
name|SVN_ERR_W
argument_list|(
name|svn_subst_translate_string2
argument_list|(
operator|&
name|translated_value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|action
operator|->
name|prop_value
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|,
literal|"Error normalizing property value"
argument_list|)
expr_stmt|;
name|action
operator|->
name|prop_value
operator|=
name|translated_value
expr_stmt|;
block|}
block|}
comment|/* How many URLs does this action expect? */
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_RM
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_MKDIR
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PUT
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSET
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSETF
comment|/* shouldn't see this one */
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PROPDEL
condition|)
name|num_url_args
operator|=
literal|1
expr_stmt|;
else|else
name|num_url_args
operator|=
literal|2
expr_stmt|;
comment|/* Parse the required number of URLs. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_url_args
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* If there's a ROOT_URL, we expect URL to be a path              relative to ROOT_URL (and we build a full url from the              combination of the two).  Otherwise, it should be a full              url. */
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|url
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|root_url
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a URL, and "
literal|"--root-url (-U) not provided\n"
argument_list|,
name|url
argument_list|)
return|;
comment|/* ### These relpaths are already URI-encoded. */
name|url
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|root_url
argument_list|,
literal|"/"
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|SVN_VA_NULL
argument_list|)
expr_stmt|;
block|}
name|url
operator|=
name|sanitize_url
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|action
operator|->
name|path
index|[
name|j
index|]
operator|=
name|url
expr_stmt|;
comment|/* The first URL arguments to 'cp', 'pd', 'ps' could be the anchor,              but the other URLs should be children of the anchor. */
if|if
condition|(
operator|!
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_CP
operator|&&
name|j
operator|==
literal|0
operator|)
operator|&&
name|action
operator|->
name|action
operator|!=
name|ACTION_PROPDEL
operator|&&
name|action
operator|->
name|action
operator|!=
name|ACTION_PROPSET
operator|&&
name|action
operator|->
name|action
operator|!=
name|ACTION_PROPSETF
condition|)
name|url
operator|=
name|svn_uri_dirname
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
condition|)
name|anchor
operator|=
name|url
expr_stmt|;
else|else
block|{
name|anchor
operator|=
name|svn_uri_get_longest_ancestor
argument_list|(
name|anchor
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
operator|||
operator|!
name|anchor
index|[
literal|0
index|]
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"URLs in the action list do not "
literal|"share a common ancestor"
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
operator|)
operator|&&
operator|(
name|j
operator|+
literal|1
operator|<
name|num_url_args
operator|)
condition|)
return|return
name|insufficient
argument_list|()
return|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|actions
argument_list|,
expr|struct
name|action
operator|*
argument_list|)
operator|=
name|action
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|actions
operator|->
name|nelts
condition|)
block|{
operator|*
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|help
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|execute
argument_list|(
name|actions
argument_list|,
name|anchor
argument_list|,
name|revprops
argument_list|,
name|base_revision
argument_list|,
name|ctx
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_AUTHN_FAILED
operator|&&
name|non_interactive
condition|)
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Authentication failed and interactive"
literal|" prompting is disabled; see the"
literal|" --force-interactive option"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|int
name|exit_code
init|=
name|EXIT_SUCCESS
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnmucc"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|sub_main
argument_list|(
operator|&
name|exit_code
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Flush stdout and report if it fails. It would be flushed on exit anyway      but this makes sure that output is not silently lost if it fails. */
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|exit_code
operator|=
name|EXIT_FAILURE
expr_stmt|;
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|,
literal|"svnmucc: "
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

end_unit

