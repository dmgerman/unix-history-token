begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnmucc.c: Subversion Multiple URL Client  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  *  */
end_comment

begin_comment
comment|/*  Multiple URL Command Client      Combine a list of mv, cp and rm commands on URLs into a single commit.      How it works: the command line arguments are parsed into an array of     action structures.  The action structures are interpreted to build a     tree of operation structures.  The tree of operation structures is     used to drive an RA commit editor to produce a single commit.      To build this client, type 'make svnmucc' from the root of your     Subversion source directory. */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_lib.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_client.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_ra.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_ra_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_function
specifier|static
name|void
name|handle_error
parameter_list|(
name|svn_error_t
modifier|*
name|err
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|err
condition|)
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnmucc: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|pool
condition|)
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|apr_pool_t
modifier|*
name|init
parameter_list|(
specifier|const
name|char
modifier|*
name|application
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_client"
block|,
name|svn_client_version
block|}
block|,
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_ra"
block|,
name|svn_ra_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_cmdline_init
argument_list|(
name|application
argument_list|,
name|stderr
argument_list|)
condition|)
name|exit
argument_list|(
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_tmp_file
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
name|fp
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Open a unique file;  use APR_DELONCLOSE. */
return|return
name|svn_io_open_unique_file3
argument_list|(
name|fp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_close
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_ra_callbacks
parameter_list|(
name|svn_ra_callbacks2_t
modifier|*
modifier|*
name|callbacks
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
specifier|const
name|char
modifier|*
name|config_dir
parameter_list|,
name|svn_config_t
modifier|*
name|cfg_config
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|svn_boolean_t
name|trust_server_cert
parameter_list|,
name|svn_boolean_t
name|no_auth_cache
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_create_callbacks
argument_list|(
name|callbacks
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_create_auth_baton
argument_list|(
operator|&
operator|(
operator|*
name|callbacks
operator|)
operator|->
name|auth_baton
argument_list|,
name|non_interactive
argument_list|,
name|username
argument_list|,
name|password
argument_list|,
name|config_dir
argument_list|,
name|no_auth_cache
argument_list|,
name|trust_server_cert
argument_list|,
name|cfg_config
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|*
name|callbacks
operator|)
operator|->
name|open_tmp_file
operator|=
name|open_tmp_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_callback
parameter_list|(
specifier|const
name|svn_commit_info_t
modifier|*
name|commit_info
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"r%ld committed by %s at %s\n"
argument_list|,
name|commit_info
operator|->
name|revision
argument_list|,
operator|(
name|commit_info
operator|->
name|author
condition|?
name|commit_info
operator|->
name|author
else|:
literal|"(no author)"
operator|)
argument_list|,
name|commit_info
operator|->
name|date
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_typedef
typedef|typedef
enum|enum
name|action_code_t
block|{
name|ACTION_MV
block|,
name|ACTION_MKDIR
block|,
name|ACTION_CP
block|,
name|ACTION_PROPSET
block|,
name|ACTION_PROPSETF
block|,
name|ACTION_PROPDEL
block|,
name|ACTION_PUT
block|,
name|ACTION_RM
block|}
name|action_code_t
typedef|;
end_typedef

begin_struct
struct|struct
name|operation
block|{
enum|enum
block|{
name|OP_OPEN
block|,
name|OP_DELETE
block|,
name|OP_ADD
block|,
name|OP_REPLACE
block|,
name|OP_PROPSET
comment|/* only for files for which no other operation is                             occuring; directories are OP_OPEN with non-empty                             props */
block|}
name|operation
enum|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* to copy, mkdir, put or set revprops */
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* to copy, valid for add and replace */
specifier|const
name|char
modifier|*
name|url
decl_stmt|;
comment|/* to copy, valid for add and replace */
specifier|const
name|char
modifier|*
name|src_file
decl_stmt|;
comment|/* for put, the source file for contents */
name|apr_hash_t
modifier|*
name|children
decl_stmt|;
comment|/* const char *path -> struct operation * */
name|apr_hash_t
modifier|*
name|prop_mods
decl_stmt|;
comment|/* const char *prop_name ->                             const svn_string_t *prop_value */
name|apr_array_header_t
modifier|*
name|prop_dels
decl_stmt|;
comment|/* const char *prop_name deletions */
name|void
modifier|*
name|baton
decl_stmt|;
comment|/* as returned by the commit editor */
block|}
struct|;
end_struct

begin_comment
comment|/* An iterator (for use via apr_table_do) which sets node properties.    REC is a pointer to a struct driver_state. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|change_props
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|struct
name|operation
modifier|*
name|child
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|child
operator|->
name|prop_dels
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|child
operator|->
name|prop_dels
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|prop_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|child
operator|->
name|prop_dels
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|baton
argument_list|,
name|prop_name
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|baton
argument_list|,
name|prop_name
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|apr_hash_count
argument_list|(
name|child
operator|->
name|prop_mods
argument_list|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|child
operator|->
name|prop_mods
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|val
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_dir_prop
argument_list|(
name|baton
argument_list|,
name|propname
argument_list|,
name|val
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|change_file_prop
argument_list|(
name|baton
argument_list|,
name|propname
argument_list|,
name|val
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Drive EDITOR to affect the change represented by OPERATION.  HEAD    is the last-known youngest revision in the repository. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|drive
parameter_list|(
name|struct
name|operation
modifier|*
name|operation
parameter_list|,
name|svn_revnum_t
name|head
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|operation
operator|->
name|children
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|struct
name|operation
modifier|*
name|child
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|void
modifier|*
name|file_baton
init|=
name|NULL
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Deletes and replacements are simple -- delete something. */
if|if
condition|(
name|child
operator|->
name|operation
operator|==
name|OP_DELETE
operator|||
name|child
operator|->
name|operation
operator|==
name|OP_REPLACE
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|delete_entry
argument_list|(
name|key
argument_list|,
name|head
argument_list|,
name|operation
operator|->
name|baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Opens could be for directories or files. */
if|if
condition|(
name|child
operator|->
name|operation
operator|==
name|OP_OPEN
operator|||
name|child
operator|->
name|operation
operator|==
name|OP_PROPSET
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_directory
argument_list|(
name|key
argument_list|,
name|operation
operator|->
name|baton
argument_list|,
name|head
argument_list|,
name|subpool
argument_list|,
operator|&
name|child
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_file
argument_list|(
name|key
argument_list|,
name|operation
operator|->
name|baton
argument_list|,
name|head
argument_list|,
name|subpool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Adds and replacements could also be for directories or files. */
if|if
condition|(
name|child
operator|->
name|operation
operator|==
name|OP_ADD
operator|||
name|child
operator|->
name|operation
operator|==
name|OP_REPLACE
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_directory
argument_list|(
name|key
argument_list|,
name|operation
operator|->
name|baton
argument_list|,
name|child
operator|->
name|url
argument_list|,
name|child
operator|->
name|rev
argument_list|,
name|subpool
argument_list|,
operator|&
name|child
operator|->
name|baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|add_file
argument_list|(
name|key
argument_list|,
name|operation
operator|->
name|baton
argument_list|,
name|child
operator|->
name|url
argument_list|,
name|child
operator|->
name|rev
argument_list|,
name|subpool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If there's a source file and an open file baton, we get to          change textual contents. */
if|if
condition|(
operator|(
name|child
operator|->
name|src_file
operator|)
operator|&&
operator|(
name|file_baton
operator|)
condition|)
block|{
name|svn_txdelta_window_handler_t
name|handler
decl_stmt|;
name|void
modifier|*
name|handler_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|,
operator|&
name|handler
argument_list|,
operator|&
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|child
operator|->
name|src_file
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|contents
argument_list|,
name|child
operator|->
name|src_file
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdin
argument_list|(
operator|&
name|contents
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_stream
argument_list|(
name|contents
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we opened a file, we need to apply outstanding propmods,          then close it. */
if|if
condition|(
name|file_baton
condition|)
block|{
if|if
condition|(
name|child
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|change_props
argument_list|(
name|editor
argument_list|,
name|file_baton
argument_list|,
name|child
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we opened, added, or replaced a directory, we need to          recurse, apply outstanding propmods, and then close it. */
if|if
condition|(
operator|(
name|child
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
operator|&&
name|child
operator|->
name|operation
operator|!=
name|OP_DELETE
condition|)
block|{
name|SVN_ERR
argument_list|(
name|change_props
argument_list|(
name|editor
argument_list|,
name|child
operator|->
name|baton
argument_list|,
name|child
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|drive
argument_list|(
name|child
argument_list|,
name|head
argument_list|,
name|editor
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_directory
argument_list|(
name|child
operator|->
name|baton
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find the operation associated with PATH, which is a single-path    component representing a child of the path represented by    OPERATION.  If no such child operation exists, create a new one of    type OP_OPEN. */
end_comment

begin_function
specifier|static
name|struct
name|operation
modifier|*
name|get_operation
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|struct
name|operation
modifier|*
name|operation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|operation
modifier|*
name|child
init|=
name|svn_hash_gets
argument_list|(
name|operation
operator|->
name|children
argument_list|,
name|path
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|child
condition|)
block|{
name|child
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|child
argument_list|)
argument_list|)
expr_stmt|;
name|child
operator|->
name|children
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|child
operator|->
name|operation
operator|=
name|OP_OPEN
expr_stmt|;
name|child
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|child
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|child
operator|->
name|prop_mods
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|child
operator|->
name|prop_dels
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|operation
operator|->
name|children
argument_list|,
name|path
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
return|return
name|child
return|;
block|}
end_function

begin_comment
comment|/* Return the portion of URL that is relative to ANCHOR (URI-decoded). */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|subtract_anchor
parameter_list|(
specifier|const
name|char
modifier|*
name|anchor
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_uri_skip_ancestor
argument_list|(
name|anchor
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add PATH to the operations tree rooted at OPERATION, creating any    intermediate nodes that are required.  Here's what's expected for    each action type:        ACTION          URL    REV      SRC-FILE  PROPNAME       ------------    -----  -------  --------  --------       ACTION_MKDIR    NULL   invalid  NULL      NULL       ACTION_CP       valid  valid    NULL      NULL       ACTION_PUT      NULL   invalid  valid     NULL       ACTION_RM       NULL   invalid  NULL      NULL       ACTION_PROPSET  valid  invalid  NULL      valid       ACTION_PROPDEL  valid  invalid  NULL      valid     Node type information is obtained for any copy source (to determine    whether to create a file or directory) and for any deleted path (to    ensure it exists since svn_delta_editor_t->delete_entry doesn't    return an error on non-existent nodes). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|build
parameter_list|(
name|action_code_t
name|action
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|prop_value
parameter_list|,
specifier|const
name|char
modifier|*
name|src_file
parameter_list|,
name|svn_revnum_t
name|head
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor
parameter_list|,
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|struct
name|operation
modifier|*
name|operation
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|path_bits
init|=
name|svn_path_decompose
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_src
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|copy_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Look for any previous operations we've recognized for PATH.  If      any of PATH's ancestors have not yet been traversed, we'll be      creating OP_OPEN operations for them as we walk down PATH's path      components. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|path_bits
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|char
modifier|*
name|path_bit
init|=
name|APR_ARRAY_IDX
argument_list|(
name|path_bits
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|path_so_far
operator|=
name|svn_relpath_join
argument_list|(
name|path_so_far
argument_list|,
name|path_bit
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|operation
operator|=
name|get_operation
argument_list|(
name|path_so_far
argument_list|,
name|operation
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we cross a replace- or add-with-history, remember the       source of those things in case we need to lookup the node kind       of one of their children.  And if this isn't such a copy,       but we've already seen one in of our parent paths, we just need       to extend that copy source path by our current path       component. */
if|if
condition|(
name|operation
operator|->
name|url
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|operation
operator|->
name|rev
argument_list|)
operator|&&
operator|(
name|operation
operator|->
name|operation
operator|==
name|OP_REPLACE
operator|||
name|operation
operator|->
name|operation
operator|==
name|OP_ADD
operator|)
condition|)
block|{
name|copy_src
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|operation
operator|->
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|copy_rev
operator|=
name|operation
operator|->
name|rev
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|copy_src
condition|)
block|{
name|copy_src
operator|=
name|svn_relpath_join
argument_list|(
name|copy_src
argument_list|,
name|path_bit
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Handle property changes. */
if|if
condition|(
name|prop_name
condition|)
block|{
if|if
condition|(
name|operation
operator|->
name|operation
operator|==
name|OP_DELETE
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"cannot set properties on a location being"
literal|" deleted ('%s')"
argument_list|,
name|path
argument_list|)
return|;
comment|/* If we're not adding this thing ourselves, check for existence.  */
if|if
condition|(
operator|!
operator|(
operator|(
name|operation
operator|->
name|operation
operator|==
name|OP_ADD
operator|)
operator|||
operator|(
name|operation
operator|->
name|operation
operator|==
name|OP_REPLACE
operator|)
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|session
argument_list|,
name|copy_src
condition|?
name|copy_src
else|:
name|path
argument_list|,
name|copy_src
condition|?
name|copy_rev
else|:
name|head
argument_list|,
operator|&
name|operation
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|->
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"propset: '%s' not found"
argument_list|,
name|path
argument_list|)
return|;
elseif|else
if|if
condition|(
operator|(
name|operation
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
operator|(
name|operation
operator|->
name|operation
operator|==
name|OP_OPEN
operator|)
condition|)
name|operation
operator|->
name|operation
operator|=
name|OP_PROPSET
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|prop_value
condition|)
name|APR_ARRAY_PUSH
argument_list|(
name|operation
operator|->
name|prop_dels
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|prop_name
expr_stmt|;
else|else
name|svn_hash_sets
argument_list|(
name|operation
operator|->
name|prop_mods
argument_list|,
name|prop_name
argument_list|,
name|prop_value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|operation
operator|->
name|rev
condition|)
name|operation
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We won't fuss about multiple operations on the same path in the      following cases:         - the prior operation was, in fact, a no-op (open)        - the prior operation was a propset placeholder        - the prior operation was a deletion       Note: while the operation structure certainly supports the      ability to do a copy of a file followed by a put of new contents      for the file, we don't let that happen (yet).   */
if|if
condition|(
name|operation
operator|->
name|operation
operator|!=
name|OP_OPEN
operator|&&
name|operation
operator|->
name|operation
operator|!=
name|OP_PROPSET
operator|&&
name|operation
operator|->
name|operation
operator|!=
name|OP_DELETE
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"unsupported multiple operations on '%s'"
argument_list|,
name|path
argument_list|)
return|;
comment|/* For deletions, we validate that there's actually something to      delete.  If this is a deletion of the child of a copied      directory, we need to remember to look in the copy source tree to      verify that this thing actually exists. */
if|if
condition|(
name|action
operator|==
name|ACTION_RM
condition|)
block|{
name|operation
operator|->
name|operation
operator|=
name|OP_DELETE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|session
argument_list|,
name|copy_src
condition|?
name|copy_src
else|:
name|path
argument_list|,
name|copy_src
condition|?
name|copy_rev
else|:
name|head
argument_list|,
operator|&
name|operation
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|->
name|kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|copy_src
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|copy_src
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"'%s' (from '%s:%ld') not found"
argument_list|,
name|path
argument_list|,
name|copy_src
argument_list|,
name|copy_rev
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"'%s' not found"
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
comment|/* Handle copy operations (which can be adds or replacements). */
elseif|else
if|if
condition|(
name|action
operator|==
name|ACTION_CP
condition|)
block|{
if|if
condition|(
name|rev
operator|>
name|head
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
literal|"Copy source revision cannot be younger "
literal|"than base revision"
argument_list|)
return|;
name|operation
operator|->
name|operation
operator|=
name|operation
operator|->
name|operation
operator|==
name|OP_DELETE
condition|?
name|OP_REPLACE
else|:
name|OP_ADD
expr_stmt|;
if|if
condition|(
name|operation
operator|->
name|operation
operator|==
name|OP_ADD
condition|)
block|{
comment|/* There is a bug in the current version of mod_dav_svn              which incorrectly replaces existing directories.              Therefore we need to check if the target exists              and raise an error here. */
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|session
argument_list|,
name|copy_src
condition|?
name|copy_src
else|:
name|path
argument_list|,
name|copy_src
condition|?
name|copy_rev
else|:
name|head
argument_list|,
operator|&
name|operation
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|->
name|kind
operator|!=
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|copy_src
operator|&&
name|strcmp
argument_list|(
name|path
argument_list|,
name|copy_src
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"'%s' (from '%s:%ld') already exists"
argument_list|,
name|path
argument_list|,
name|copy_src
argument_list|,
name|copy_rev
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"'%s' already exists"
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|session
argument_list|,
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|rev
argument_list|,
operator|&
name|operation
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|->
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"'%s' not found"
argument_list|,
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
name|operation
operator|->
name|url
operator|=
name|url
expr_stmt|;
name|operation
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
block|}
comment|/* Handle mkdir operations (which can be adds or replacements). */
elseif|else
if|if
condition|(
name|action
operator|==
name|ACTION_MKDIR
condition|)
block|{
name|operation
operator|->
name|operation
operator|=
name|operation
operator|->
name|operation
operator|==
name|OP_DELETE
condition|?
name|OP_REPLACE
else|:
name|OP_ADD
expr_stmt|;
name|operation
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
block|}
comment|/* Handle put operations (which can be adds, replacements, or opens). */
elseif|else
if|if
condition|(
name|action
operator|==
name|ACTION_PUT
condition|)
block|{
if|if
condition|(
name|operation
operator|->
name|operation
operator|==
name|OP_DELETE
condition|)
block|{
name|operation
operator|->
name|operation
operator|=
name|OP_REPLACE
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|session
argument_list|,
name|copy_src
condition|?
name|copy_src
else|:
name|path
argument_list|,
name|copy_src
condition|?
name|copy_rev
else|:
name|head
argument_list|,
operator|&
name|operation
operator|->
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|operation
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
name|operation
operator|->
name|operation
operator|=
name|OP_OPEN
expr_stmt|;
elseif|else
if|if
condition|(
name|operation
operator|->
name|kind
operator|==
name|svn_node_none
condition|)
name|operation
operator|->
name|operation
operator|=
name|OP_ADD
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_BAD_URL
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a file"
argument_list|,
name|path
argument_list|)
return|;
block|}
name|operation
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|operation
operator|->
name|src_file
operator|=
name|src_file
expr_stmt|;
block|}
else|else
block|{
comment|/* We shouldn't get here. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|action
block|{
name|action_code_t
name|action
decl_stmt|;
comment|/* revision (copy-from-rev of path[0] for cp; base-rev for put) */
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* action  path[0]  path[1]    * ------  -------  -------    * mv      source   target    * mkdir   target   (null)    * cp      source   target    * put     target   source    * rm      target   (null)    * propset target   (null)    */
specifier|const
name|char
modifier|*
name|path
index|[
literal|2
index|]
decl_stmt|;
comment|/* property name/value */
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|prop_value
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|fetch_baton
block|{
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
name|svn_revnum_t
name|head
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_base_func
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|filename
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|fetch_baton
modifier|*
name|fb
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|fb
operator|->
name|head
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|fstream
argument_list|,
name|filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_ra_get_file
argument_list|(
name|fb
operator|->
name|session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|fstream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|filename
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|fstream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_props_func
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|props
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|fetch_baton
modifier|*
name|fb
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|node_kind
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|fb
operator|->
name|head
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|fb
operator|->
name|session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
operator|&
name|node_kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|node_kind
operator|==
name|svn_node_file
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_ra_get_file
argument_list|(
name|fb
operator|->
name|session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node_kind
operator|==
name|svn_node_dir
condition|)
block|{
name|apr_array_header_t
modifier|*
name|tmp_props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_dir2
argument_list|(
name|fb
operator|->
name|session
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
literal|0
comment|/* Dirent fields */
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_props
operator|=
name|svn_prop_hash_to_array
argument_list|(
operator|*
name|props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|tmp_props
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|props
operator|=
name|svn_prop_array_to_hash
argument_list|(
name|tmp_props
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|props
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fetch_kind_func
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|fetch_baton
modifier|*
name|fb
init|=
name|baton
decl_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
name|base_revision
operator|=
name|fb
operator|->
name|head
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|fb
operator|->
name|session
argument_list|,
name|path
argument_list|,
name|base_revision
argument_list|,
name|kind
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_delta_shim_callbacks_t
modifier|*
name|get_shim_callbacks
parameter_list|(
name|svn_ra_session_t
modifier|*
name|session
parameter_list|,
name|svn_revnum_t
name|head
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_delta_shim_callbacks_t
modifier|*
name|callbacks
init|=
name|svn_delta_shim_callbacks_default
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|struct
name|fetch_baton
modifier|*
name|fb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
name|fb
operator|->
name|session
operator|=
name|session
expr_stmt|;
name|fb
operator|->
name|head
operator|=
name|head
expr_stmt|;
name|callbacks
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|callbacks
operator|->
name|fetch_baton
operator|=
name|fb
expr_stmt|;
return|return
name|callbacks
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|execute
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|actions
parameter_list|,
specifier|const
name|char
modifier|*
name|anchor
parameter_list|,
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
specifier|const
name|char
modifier|*
name|username
parameter_list|,
specifier|const
name|char
modifier|*
name|password
parameter_list|,
specifier|const
name|char
modifier|*
name|config_dir
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|config_options
parameter_list|,
name|svn_boolean_t
name|non_interactive
parameter_list|,
name|svn_boolean_t
name|trust_server_cert
parameter_list|,
name|svn_boolean_t
name|no_auth_cache
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_ra_session_t
modifier|*
name|session
decl_stmt|;
name|svn_ra_session_t
modifier|*
name|aux_session
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
name|svn_revnum_t
name|head
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|svn_ra_callbacks2_t
modifier|*
name|ra_callbacks
decl_stmt|;
name|void
modifier|*
name|editor_baton
decl_stmt|;
name|struct
name|operation
name|root
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_hash_t
modifier|*
name|config
decl_stmt|;
name|svn_config_t
modifier|*
name|cfg_config
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_config_get_config
argument_list|(
operator|&
name|config
argument_list|,
name|config_dir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__apply_config_options
argument_list|(
name|config
argument_list|,
name|config_options
argument_list|,
literal|"svnmucc: "
argument_list|,
literal|"--config-option"
argument_list|)
argument_list|)
expr_stmt|;
name|cfg_config
operator|=
name|svn_hash_gets
argument_list|(
name|config
argument_list|,
name|SVN_CONFIG_CATEGORY_CONFIG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_hash_gets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|msg
init|=
name|svn_string_create
argument_list|(
literal|""
argument_list|,
name|pool
argument_list|)
decl_stmt|;
comment|/* If we can do so, try to pop up $EDITOR to fetch a log message. */
if|if
condition|(
name|non_interactive
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot invoke editor to get log message "
literal|"when non-interactive"
argument_list|)
argument_list|)
return|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline__edit_string_externally
argument_list|(
operator|&
name|msg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|""
argument_list|,
name|msg
argument_list|,
literal|"svnmucc-commit"
argument_list|,
name|config
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|apr_hash_pool_get
argument_list|(
name|revprops
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|create_ra_callbacks
argument_list|(
operator|&
name|ra_callbacks
argument_list|,
name|username
argument_list|,
name|password
argument_list|,
name|config_dir
argument_list|,
name|cfg_config
argument_list|,
name|non_interactive
argument_list|,
name|trust_server_cert
argument_list|,
name|no_auth_cache
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_open4
argument_list|(
operator|&
name|session
argument_list|,
name|NULL
argument_list|,
name|anchor
argument_list|,
name|NULL
argument_list|,
name|ra_callbacks
argument_list|,
name|NULL
argument_list|,
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open, then reparent to avoid AUTHZ errors when opening the reposroot */
name|SVN_ERR
argument_list|(
name|svn_ra_open4
argument_list|(
operator|&
name|aux_session
argument_list|,
name|NULL
argument_list|,
name|anchor
argument_list|,
name|NULL
argument_list|,
name|ra_callbacks
argument_list|,
name|NULL
argument_list|,
name|config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_repos_root2
argument_list|(
name|aux_session
argument_list|,
operator|&
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|aux_session
argument_list|,
name|repos_root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_latest_revnum
argument_list|(
name|session
argument_list|,
operator|&
name|head
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Reparent to ANCHOR's dir, if ANCHOR is not a directory. */
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_check_path
argument_list|(
name|aux_session
argument_list|,
name|svn_uri_skip_ancestor
argument_list|(
name|repos_root
argument_list|,
name|anchor
argument_list|,
name|pool
argument_list|)
argument_list|,
name|head
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_dir
condition|)
block|{
name|anchor
operator|=
name|svn_uri_dirname
argument_list|(
name|anchor
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_reparent
argument_list|(
name|session
argument_list|,
name|anchor
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
condition|)
block|{
if|if
condition|(
name|base_revision
operator|>
name|head
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
literal|"No such revision %ld (youngest is %ld)"
argument_list|,
name|base_revision
argument_list|,
name|head
argument_list|)
return|;
name|head
operator|=
name|base_revision
expr_stmt|;
block|}
name|memset
argument_list|(
operator|&
name|root
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|root
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|.
name|children
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|root
operator|.
name|operation
operator|=
name|OP_OPEN
expr_stmt|;
name|root
operator|.
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
comment|/* For setting properties */
name|root
operator|.
name|prop_mods
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|root
operator|.
name|prop_dels
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|actions
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
block|{
name|struct
name|action
modifier|*
name|action
init|=
name|APR_ARRAY_IDX
argument_list|(
name|actions
argument_list|,
name|i
argument_list|,
expr|struct
name|action
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path1
decl_stmt|,
modifier|*
name|path2
decl_stmt|;
switch|switch
condition|(
name|action
operator|->
name|action
condition|)
block|{
case|case
name|ACTION_MV
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|path2
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|1
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build
argument_list|(
name|ACTION_RM
argument_list|,
name|path1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|,
name|anchor
argument_list|,
name|session
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build
argument_list|(
name|ACTION_CP
argument_list|,
name|path2
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|head
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|,
name|anchor
argument_list|,
name|session
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_CP
case|:
name|path2
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|1
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|rev
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|action
operator|->
name|rev
operator|=
name|head
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build
argument_list|(
name|ACTION_CP
argument_list|,
name|path2
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|action
operator|->
name|rev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|,
name|anchor
argument_list|,
name|session
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_RM
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build
argument_list|(
name|ACTION_RM
argument_list|,
name|path1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|,
name|anchor
argument_list|,
name|session
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_MKDIR
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build
argument_list|(
name|ACTION_MKDIR
argument_list|,
name|path1
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|,
name|anchor
argument_list|,
name|session
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_PUT
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build
argument_list|(
name|ACTION_PUT
argument_list|,
name|path1
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|action
operator|->
name|path
index|[
literal|1
index|]
argument_list|,
name|head
argument_list|,
name|anchor
argument_list|,
name|session
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_PROPSET
case|:
case|case
name|ACTION_PROPDEL
case|:
name|path1
operator|=
name|subtract_anchor
argument_list|(
name|anchor
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|build
argument_list|(
name|action
operator|->
name|action
argument_list|,
name|path1
argument_list|,
name|action
operator|->
name|path
index|[
literal|0
index|]
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|action
operator|->
name|prop_name
argument_list|,
name|action
operator|->
name|prop_value
argument_list|,
name|NULL
argument_list|,
name|head
argument_list|,
name|anchor
argument_list|,
name|session
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ACTION_PROPSETF
case|:
default|default:
name|SVN_ERR_MALFUNCTION_NO_RETURN
argument_list|()
expr_stmt|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|svn_ra__register_editor_shim_callbacks
argument_list|(
name|session
argument_list|,
name|get_shim_callbacks
argument_list|(
name|aux_session
argument_list|,
name|head
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_get_commit_editor3
argument_list|(
name|session
argument_list|,
operator|&
name|editor
argument_list|,
operator|&
name|editor_baton
argument_list|,
name|revprops
argument_list|,
name|commit_callback
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|editor_baton
argument_list|,
name|head
argument_list|,
name|pool
argument_list|,
operator|&
name|root
operator|.
name|baton
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|change_props
argument_list|(
name|editor
argument_list|,
name|root
operator|.
name|baton
argument_list|,
operator|&
name|root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|drive
argument_list|(
operator|&
name|root
argument_list|,
name|head
argument_list|,
name|editor
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|editor
operator|->
name|close_directory
argument_list|(
name|root
operator|.
name|baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|editor
operator|->
name|close_edit
argument_list|(
name|editor_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|editor
operator|->
name|abort_edit
argument_list|(
name|editor_baton
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_propvalue_file
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stringbuf_t
modifier|*
name|value
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|value
argument_list|,
name|filename
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|svn_string_create_from_buf
argument_list|(
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Perform the typical suite of manipulations for user-provided URLs    on URL, returning the result (allocated from POOL): IRI-to-URI    conversion, auto-escaping, and canonicalization. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sanitize_url
parameter_list|(
specifier|const
name|char
modifier|*
name|url
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|url
operator|=
name|svn_path_uri_from_iri
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|url
operator|=
name|svn_path_uri_autoescape
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_uri_canonicalize
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|int
name|exit_val
parameter_list|)
block|{
name|FILE
modifier|*
name|stream
init|=
name|exit_val
operator|==
name|EXIT_SUCCESS
condition|?
name|stdout
else|:
name|stderr
decl_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"Subversion multiple URL command client\n"
literal|"usage: svnmucc ACTION...\n"
literal|"\n"
literal|"  Perform one or more Subversion repository URL-based ACTIONs, committing\n"
literal|"  the result as a (single) new revision.\n"
literal|"\n"
literal|"Actions:\n"
literal|"  cp REV SRC-URL DST-URL : copy SRC-URL@REV to DST-URL\n"
literal|"  mkdir URL              : create new directory URL\n"
literal|"  mv SRC-URL DST-URL     : move SRC-URL to DST-URL\n"
literal|"  rm URL                 : delete URL\n"
literal|"  put SRC-FILE URL       : add or modify file URL with contents copied from\n"
literal|"                           SRC-FILE (use \"-\" to read from standard input)\n"
literal|"  propset NAME VALUE URL : set property NAME on URL to VALUE\n"
literal|"  propsetf NAME FILE URL : set property NAME on URL to value read from FILE\n"
literal|"  propdel NAME URL       : delete property NAME from URL\n"
literal|"\n"
literal|"Valid options:\n"
literal|"  -h, -? [--help]        : display this text\n"
literal|"  -m [--message] ARG     : use ARG as a log message\n"
literal|"  -F [--file] ARG        : read log message from file ARG\n"
literal|"  -u [--username] ARG    : commit the changes as username ARG\n"
literal|"  -p [--password] ARG    : use ARG as the password\n"
literal|"  -U [--root-url] ARG    : interpret all action URLs relative to ARG\n"
literal|"  -r [--revision] ARG    : use revision ARG as baseline for changes\n"
literal|"  --with-revprop ARG     : set revision property in the following format:\n"
literal|"                               NAME[=VALUE]\n"
literal|"  --non-interactive      : do no interactive prompting (default is to\n"
literal|"                           prompt only if standard input is a terminal)\n"
literal|"  --force-interactive    : do interactive prompting even if standard\n"
literal|"                           input is not a terminal\n"
literal|"  --trust-server-cert    : accept SSL server certificates from unknown\n"
literal|"                           certificate authorities without prompting (but\n"
literal|"                           only with '--non-interactive')\n"
literal|"  -X [--extra-args] ARG  : append arguments from file ARG (one per line;\n"
literal|"                           use \"-\" to read from standard input)\n"
literal|"  --config-dir ARG       : use ARG to override the config directory\n"
literal|"  --config-option ARG    : use ARG to override a configuration option\n"
literal|"  --no-auth-cache        : do not cache authentication tokens\n"
literal|"  --version              : print version information\n"
argument_list|)
argument_list|,
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exit_val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|insufficient
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|handle_error
argument_list|(
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"insufficient arguments"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|display_version
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ra_desc_start
init|=
literal|"The following repository access (RA) modules are available:\n\n"
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|version_footer
decl_stmt|;
name|version_footer
operator|=
name|svn_stringbuf_create
argument_list|(
name|ra_desc_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_ra_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_print_help4
argument_list|(
name|os
argument_list|,
literal|"svnmucc"
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return an error about the mutual exclusivity of the -m, -F, and    --with-revprop=svn:log command-line options. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mutually_exclusive_logs_error
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--message (-m), --file (-F), and "
literal|"--with-revprop=svn:log are mutually "
literal|"exclusive"
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Ensure that the REVPROPS hash contains a command-line-provided log    message, if any, and that there was but one source of such a thing    provided on that command-line.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|sanitize_log_sources
parameter_list|(
name|apr_hash_t
modifier|*
name|revprops
parameter_list|,
specifier|const
name|char
modifier|*
name|message
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|filedata
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|hash_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|revprops
argument_list|)
decl_stmt|;
comment|/* If we already have a log message in the revprop hash, then just      make sure the user didn't try to also use -m or -F.  Otherwise,      we need to consult -m or -F to find a log message, if any. */
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|)
condition|)
block|{
if|if
condition|(
name|filedata
operator|||
name|message
condition|)
return|return
name|mutually_exclusive_logs_error
argument_list|()
return|;
block|}
elseif|else
if|if
condition|(
name|filedata
condition|)
block|{
if|if
condition|(
name|message
condition|)
return|return
name|mutually_exclusive_logs_error
argument_list|()
return|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|message
argument_list|,
name|filedata
operator|->
name|data
argument_list|,
name|hash_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|svn_stringbuf__morph_into_string
argument_list|(
name|filedata
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|message
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|revprops
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|svn_string_create
argument_list|(
name|message
argument_list|,
name|hash_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|init
argument_list|(
literal|"svnmucc"
argument_list|)
decl_stmt|;
name|apr_array_header_t
modifier|*
name|actions
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|action
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|anchor
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_getopt_t
modifier|*
name|opts
decl_stmt|;
enum|enum
block|{
name|config_dir_opt
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|config_inline_opt
block|,
name|no_auth_cache_opt
block|,
name|version_opt
block|,
name|with_revprop_opt
block|,
name|non_interactive_opt
block|,
name|force_interactive_opt
block|,
name|trust_server_cert_opt
block|}
enum|;
specifier|static
specifier|const
name|apr_getopt_option_t
name|options
index|[]
init|=
block|{
block|{
literal|"message"
block|,
literal|'m'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"file"
block|,
literal|'F'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"username"
block|,
literal|'u'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"password"
block|,
literal|'p'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"root-url"
block|,
literal|'U'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"with-revprop"
block|,
name|with_revprop_opt
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"extra-args"
block|,
literal|'X'
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"non-interactive"
block|,
name|non_interactive_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"force-interactive"
block|,
name|force_interactive_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"trust-server-cert"
block|,
name|trust_server_cert_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"config-dir"
block|,
name|config_dir_opt
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"config-option"
block|,
name|config_inline_opt
block|,
literal|1
block|,
literal|""
block|}
block|,
block|{
literal|"no-auth-cache"
block|,
name|no_auth_cache_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
literal|"version"
block|,
name|version_opt
block|,
literal|0
block|,
literal|""
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
specifier|const
name|char
modifier|*
name|message
init|=
name|NULL
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|filedata
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
init|=
name|NULL
decl_stmt|,
modifier|*
name|password
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|root_url
init|=
name|NULL
decl_stmt|,
modifier|*
name|extra_args_file
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_dir
init|=
name|NULL
decl_stmt|;
name|apr_array_header_t
modifier|*
name|config_options
decl_stmt|;
name|svn_boolean_t
name|non_interactive
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|force_interactive
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|trust_server_cert
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|no_auth_cache
init|=
name|FALSE
decl_stmt|;
name|svn_revnum_t
name|base_revision
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|apr_array_header_t
modifier|*
name|action_args
decl_stmt|;
name|apr_hash_t
modifier|*
name|revprops
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|config_options
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_cmdline__config_argument_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|apr_getopt_init
argument_list|(
operator|&
name|opts
argument_list|,
name|pool
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|opts
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|int
name|opt
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
name|apr_status_t
name|status
init|=
name|apr_getopt_long
argument_list|(
name|opts
argument_list|,
name|options
argument_list|,
operator|&
name|opt
argument_list|,
operator|&
name|arg
argument_list|)
decl_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|status
argument_list|)
condition|)
break|break;
if|if
condition|(
name|status
operator|!=
name|APR_SUCCESS
condition|)
name|handle_error
argument_list|(
name|svn_error_wrap_apr
argument_list|(
name|status
argument_list|,
literal|"getopt failure"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'m'
case|:
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|message
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
block|{
specifier|const
name|char
modifier|*
name|arg_utf8
decl_stmt|;
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|arg_utf8
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|filedata
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'u'
case|:
name|username
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|password
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|root_url
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|root_url
argument_list|)
condition|)
name|handle_error
argument_list|(
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a URL\n"
argument_list|,
name|root_url
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|root_url
operator|=
name|sanitize_url
argument_list|(
name|root_url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
block|{
name|char
modifier|*
name|digits_end
init|=
name|NULL
decl_stmt|;
name|base_revision
operator|=
name|strtol
argument_list|(
name|arg
argument_list|,
operator|&
name|digits_end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|base_revision
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|digits_end
operator|)
operator|||
operator|*
name|digits_end
condition|)
name|handle_error
argument_list|(
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
literal|"Invalid revision number"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|with_revprop_opt
case|:
name|err
operator|=
name|svn_opt_parse_revprop
argument_list|(
operator|&
name|revprops
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|SVN_NO_ERROR
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|extra_args_file
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|non_interactive_opt
case|:
name|non_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|force_interactive_opt
case|:
name|force_interactive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|trust_server_cert_opt
case|:
name|trust_server_cert
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|config_dir_opt
case|:
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|config_dir
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|config_inline_opt
case|:
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_arg
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_cmdline__parse_config_option
argument_list|(
name|config_options
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|no_auth_cache_opt
case|:
name|no_auth_cache
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|version_opt
case|:
name|SVN_INT_ERR
argument_list|(
name|display_version
argument_list|(
name|opts
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|usage
argument_list|(
name|pool
argument_list|,
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|non_interactive
operator|&&
name|force_interactive
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--non-interactive and --force-interactive "
literal|"are mutually exclusive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnmucc: "
argument_list|)
return|;
block|}
else|else
name|non_interactive
operator|=
operator|!
name|svn_cmdline__be_interactive
argument_list|(
name|non_interactive
argument_list|,
name|force_interactive
argument_list|)
expr_stmt|;
if|if
condition|(
name|trust_server_cert
operator|&&
operator|!
name|non_interactive
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--trust-server-cert requires "
literal|"--non-interactive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnmucc: "
argument_list|)
return|;
block|}
comment|/* Make sure we have a log message to use. */
name|err
operator|=
name|sanitize_log_sources
argument_list|(
name|revprops
argument_list|,
name|message
argument_list|,
name|filedata
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Copy the rest of our command-line arguments to an array,      UTF-8-ing them along the way. */
name|action_args
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|opts
operator|->
name|argc
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|opts
operator|->
name|ind
operator|<
name|opts
operator|->
name|argc
condition|)
block|{
specifier|const
name|char
modifier|*
name|arg
init|=
name|opts
operator|->
name|argv
index|[
name|opts
operator|->
name|ind
operator|++
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
operator|(
name|APR_ARRAY_PUSH
argument_list|(
name|action_args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|)
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If there are extra arguments in a supplementary file, tack those      on, too (again, in UTF8 form). */
if|if
condition|(
name|extra_args_file
condition|)
block|{
specifier|const
name|char
modifier|*
name|extra_args_file_utf8
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|contents
decl_stmt|,
modifier|*
name|contents_utf8
decl_stmt|;
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|extra_args_file_utf8
argument_list|,
name|extra_args_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|contents
argument_list|,
name|extra_args_file_utf8
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_utf_stringbuf_to_utf8
argument_list|(
operator|&
name|contents_utf8
argument_list|,
name|contents
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_cstring_split_append
argument_list|(
name|action_args
argument_list|,
name|contents_utf8
operator|->
name|data
argument_list|,
literal|"\n\r"
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Now, we iterate over the combined set of arguments -- our actions. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|action_args
operator|->
name|nelts
condition|;
control|)
block|{
name|int
name|j
decl_stmt|,
name|num_url_args
decl_stmt|;
specifier|const
name|char
modifier|*
name|action_string
init|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|struct
name|action
modifier|*
name|action
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|action
argument_list|)
argument_list|)
decl_stmt|;
comment|/* First, parse the action. */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"mv"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_MV
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"cp"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_CP
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"mkdir"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_MKDIR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"rm"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_RM
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"put"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PUT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"propset"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PROPSET
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"propsetf"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PROPSETF
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"propdel"
argument_list|)
condition|)
name|action
operator|->
name|action
operator|=
name|ACTION_PROPDEL
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"?"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"h"
argument_list|)
operator|||
operator|!
name|strcmp
argument_list|(
name|action_string
argument_list|,
literal|"help"
argument_list|)
condition|)
name|usage
argument_list|(
name|pool
argument_list|,
name|EXIT_SUCCESS
argument_list|)
expr_stmt|;
else|else
name|handle_error
argument_list|(
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not an action\n"
argument_list|,
name|action_string
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
name|insufficient
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* For copies, there should be a revision number next. */
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_CP
condition|)
block|{
specifier|const
name|char
modifier|*
name|rev_str
init|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|rev_str
argument_list|,
literal|"head"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|rev_str
argument_list|,
literal|"HEAD"
argument_list|)
operator|==
literal|0
condition|)
name|action
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|end
decl_stmt|;
while|while
condition|(
operator|*
name|rev_str
operator|==
literal|'r'
condition|)
operator|++
name|rev_str
expr_stmt|;
name|action
operator|->
name|rev
operator|=
name|strtol
argument_list|(
name|rev_str
argument_list|,
operator|&
name|end
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|end
condition|)
name|handle_error
argument_list|(
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a revision\n"
argument_list|,
name|rev_str
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
name|insufficient
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|action
operator|->
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
comment|/* For puts, there should be a local file next. */
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_PUT
condition|)
block|{
name|action
operator|->
name|path
index|[
literal|1
index|]
operator|=
name|svn_dirent_internal_style
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
name|insufficient
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* For propset, propsetf, and propdel, a property name (and          maybe a property value or file which contains one) comes next. */
if|if
condition|(
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSET
operator|)
operator|||
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSETF
operator|)
operator|||
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPDEL
operator|)
condition|)
block|{
name|action
operator|->
name|prop_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
name|insufficient
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPDEL
condition|)
block|{
name|action
operator|->
name|prop_value
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSET
condition|)
block|{
name|action
operator|->
name|prop_value
operator|=
name|svn_string_create
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
name|insufficient
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|propval_file
init|=
name|svn_dirent_internal_style
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
condition|)
name|insufficient
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|read_propvalue_file
argument_list|(
operator|&
operator|(
name|action
operator|->
name|prop_value
operator|)
argument_list|,
name|propval_file
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|action
operator|->
name|action
operator|=
name|ACTION_PROPSET
expr_stmt|;
block|}
if|if
condition|(
name|action
operator|->
name|prop_value
operator|&&
name|svn_prop_needs_translation
argument_list|(
name|action
operator|->
name|prop_name
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|translated_value
decl_stmt|;
name|err
operator|=
name|svn_subst_translate_string2
argument_list|(
operator|&
name|translated_value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|action
operator|->
name|prop_value
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|handle_error
argument_list|(
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
literal|"Error normalizing property value"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|action
operator|->
name|prop_value
operator|=
name|translated_value
expr_stmt|;
block|}
block|}
comment|/* How many URLs does this action expect? */
if|if
condition|(
name|action
operator|->
name|action
operator|==
name|ACTION_RM
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_MKDIR
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PUT
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSET
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PROPSETF
comment|/* shouldn't see this one */
operator|||
name|action
operator|->
name|action
operator|==
name|ACTION_PROPDEL
condition|)
name|num_url_args
operator|=
literal|1
expr_stmt|;
else|else
name|num_url_args
operator|=
literal|2
expr_stmt|;
comment|/* Parse the required number of URLs. */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|num_url_args
condition|;
operator|++
name|j
control|)
block|{
specifier|const
name|char
modifier|*
name|url
init|=
name|APR_ARRAY_IDX
argument_list|(
name|action_args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
comment|/* If there's a ROOT_URL, we expect URL to be a path              relative to ROOT_URL (and we build a full url from the              combination of the two).  Otherwise, it should be a full              url. */
if|if
condition|(
operator|!
name|svn_path_is_url
argument_list|(
name|url
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|root_url
condition|)
name|handle_error
argument_list|(
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"'%s' is not a URL, and "
literal|"--root-url (-U) not provided\n"
argument_list|,
name|url
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* ### These relpaths are already URI-encoded. */
name|url
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
name|root_url
argument_list|,
literal|"/"
argument_list|,
name|svn_relpath_canonicalize
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
name|url
operator|=
name|sanitize_url
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|action
operator|->
name|path
index|[
name|j
index|]
operator|=
name|url
expr_stmt|;
comment|/* The first URL arguments to 'cp', 'pd', 'ps' could be the anchor,              but the other URLs should be children of the anchor. */
if|if
condition|(
operator|!
operator|(
name|action
operator|->
name|action
operator|==
name|ACTION_CP
operator|&&
name|j
operator|==
literal|0
operator|)
operator|&&
name|action
operator|->
name|action
operator|!=
name|ACTION_PROPDEL
operator|&&
name|action
operator|->
name|action
operator|!=
name|ACTION_PROPSET
operator|&&
name|action
operator|->
name|action
operator|!=
name|ACTION_PROPSETF
condition|)
name|url
operator|=
name|svn_uri_dirname
argument_list|(
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
condition|)
name|anchor
operator|=
name|url
expr_stmt|;
else|else
block|{
name|anchor
operator|=
name|svn_uri_get_longest_ancestor
argument_list|(
name|anchor
argument_list|,
name|url
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|anchor
operator|||
operator|!
name|anchor
index|[
literal|0
index|]
condition|)
name|handle_error
argument_list|(
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
literal|"URLs in the action list do not "
literal|"share a common ancestor"
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|++
name|i
operator|==
name|action_args
operator|->
name|nelts
operator|)
operator|&&
operator|(
name|j
operator|+
literal|1
operator|<
name|num_url_args
operator|)
condition|)
name|insufficient
argument_list|(
name|pool
argument_list|)
expr_stmt|;
block|}
name|APR_ARRAY_PUSH
argument_list|(
name|actions
argument_list|,
expr|struct
name|action
operator|*
argument_list|)
operator|=
name|action
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|actions
operator|->
name|nelts
condition|)
name|usage
argument_list|(
name|pool
argument_list|,
name|EXIT_FAILURE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|execute
argument_list|(
name|actions
argument_list|,
name|anchor
argument_list|,
name|revprops
argument_list|,
name|username
argument_list|,
name|password
argument_list|,
name|config_dir
argument_list|,
name|config_options
argument_list|,
name|non_interactive
argument_list|,
name|trust_server_cert
argument_list|,
name|no_auth_cache
argument_list|,
name|base_revision
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_AUTHN_FAILED
operator|&&
name|non_interactive
condition|)
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Authentication failed and interactive"
literal|" prompting is disabled; see the"
literal|" --force-interactive option"
argument_list|)
argument_list|)
expr_stmt|;
name|handle_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Ensure that stdout is flushed, so the user will see all results. */
name|svn_error_clear
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
end_function

end_unit

