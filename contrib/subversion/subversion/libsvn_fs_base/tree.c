begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tree.c : tree-like filesystem, built on DAG filesystem  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_comment
comment|/* The job of this layer is to take a filesystem with lots of node    sharing going on --- the real DAG filesystem as it appears in the    database --- and make it look and act like an ordinary tree    filesystem, with no sharing.     We do just-in-time cloning: you can walk from some unfinished    transaction's root down into directories and files shared with    committed revisions; as soon as you try to change something, the    appropriate nodes get cloned (and parent directory entries updated)    invisibly, behind your back.  Any other references you have to    nodes that have been cloned by other changes, even made by other    processes, are automatically updated to point to the right clones.  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"trail.h"
end_include

begin_include
include|#
directive|include
file|"node-rev.h"
end_include

begin_include
include|#
directive|include
file|"key-gen.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"revs-txns.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"bdb/txn-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/rev-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/nodes-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/changes-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/copies-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/node-origins-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/miscellaneous-table.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_comment
comment|/* ### I believe this constant will become internal to reps-strings.c.    ### see the comment in window_consumer() for more information. */
end_comment

begin_comment
comment|/* ### the comment also seems to need tweaking: the log file stuff    ### is no longer an issue... */
end_comment

begin_comment
comment|/* Data written to the filesystem through the svn_fs_apply_textdelta()    interface is cached in memory until the end of the data stream, or    until a size trigger is hit.  Define that trigger here (in bytes).    Setting the value to 0 will result in no filesystem buffering at    all.  The value only really matters when dealing with file contents    bigger than the value itself.  Above that point, large values here    allow the filesystem to buffer more data in memory before flushing    to the database, which increases memory usage but greatly decreases    the amount of disk access (and log-file generation) in database.    Smaller values will limit your overall memory consumption, but can    drastically hurt throughput by necessitating more write operations    to the database (which also generates more log-files).  */
end_comment

begin_define
define|#
directive|define
name|WRITE_BUFFER_SIZE
value|512000
end_define

begin_comment
comment|/* The maximum number of cache items to maintain in the node cache. */
end_comment

begin_define
define|#
directive|define
name|NODE_CACHE_MAX_KEYS
value|32
end_define

begin_escape
end_escape

begin_comment
comment|/* The root structure.  */
end_comment

begin_comment
comment|/* Structure for svn_fs_root_t's node_cache hash values. */
end_comment

begin_struct
struct|struct
name|dag_node_cache_t
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* NODE to be cached. */
name|int
name|idx
decl_stmt|;
comment|/* Index into the keys array for this cache item's key. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Pool in which NODE is allocated. */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|base_root_data_t
block|{
comment|/* For revision roots, this is a dag node for the revision's root      directory.  For transaction roots, we open the root directory      afresh every time, since the root may have been cloned, or      the transaction may have disappeared altogether.  */
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|;
comment|/* Cache structures, for mapping const char * PATH to const      struct dag_node_cache_t * structures.       ### Currently this is only used for revision roots.  To be safe      for transaction roots, you must have the guarantee that there is      never more than a single transaction root per Subversion      transaction ever open at a given time -- having two roots open to      the same Subversion transaction would be a request for pain.      Also, you have to ensure that if a 'make_path_mutable()' fails for      any reason, you don't leave cached nodes for the portion of that      function that succeeded.  In other words, this cache must never,      ever, lie. */
name|apr_hash_t
modifier|*
name|node_cache
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_cache_keys
index|[
name|NODE_CACHE_MAX_KEYS
index|]
decl_stmt|;
name|int
name|node_cache_idx
decl_stmt|;
block|}
name|base_root_data_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|svn_fs_root_t
modifier|*
name|make_revision_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|root_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|svn_fs_root_t
modifier|*
name|make_txn_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn
parameter_list|,
name|svn_revnum_t
name|base_rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_escape
end_escape

begin_comment
comment|/*** Node Caching in the Roots. ***/
end_comment

begin_comment
comment|/* Return NODE for PATH from ROOT's node cache, or NULL if the node    isn't cached. */
end_comment

begin_function
specifier|static
name|dag_node_t
modifier|*
name|dag_node_cache_get
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_root_data_t
modifier|*
name|brd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
name|struct
name|dag_node_cache_t
modifier|*
name|cache_item
decl_stmt|;
comment|/* Assert valid input. */
name|assert
argument_list|(
operator|*
name|path
operator|==
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Only allow revision roots. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|NULL
return|;
comment|/* Look in the cache for our desired item. */
name|cache_item
operator|=
name|svn_hash_gets
argument_list|(
name|brd
operator|->
name|node_cache
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_item
condition|)
return|return
name|svn_fs_base__dag_dup
argument_list|(
name|cache_item
operator|->
name|node
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* Add the NODE for PATH to ROOT's node cache.  Callers should *NOT*    call this unless they are adding a currently un-cached item to the    cache, or are replacing the NODE for PATH with a new (different)    one. */
end_comment

begin_function
specifier|static
name|void
name|dag_node_cache_set
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|)
block|{
name|base_root_data_t
modifier|*
name|brd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|cache_path
decl_stmt|;
name|apr_pool_t
modifier|*
name|cache_pool
decl_stmt|;
name|struct
name|dag_node_cache_t
modifier|*
name|cache_item
decl_stmt|;
name|int
name|num_keys
init|=
name|apr_hash_count
argument_list|(
name|brd
operator|->
name|node_cache
argument_list|)
decl_stmt|;
comment|/* What?  No POOL passed to this function?       To ensure that our cache values live as long as the svn_fs_root_t      in which they are ultimately stored, and to allow us to free()      them individually without harming the rest, they are each      allocated from a subpool of ROOT's pool.  We'll keep one subpool      around for each cache slot -- as we start expiring stuff      to make room for more entries, we'll re-use the expired thing's      pool. */
comment|/* Assert valid input and state. */
name|assert
argument_list|(
operator|*
name|path
operator|==
literal|'/'
argument_list|)
expr_stmt|;
name|assert
argument_list|(
operator|(
name|brd
operator|->
name|node_cache_idx
operator|<=
name|num_keys
operator|)
operator|&&
operator|(
name|num_keys
operator|<=
name|NODE_CACHE_MAX_KEYS
operator|)
argument_list|)
expr_stmt|;
comment|/* Only allow revision roots. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return;
comment|/* Special case: the caller wants us to replace an existing cached      node with a new one.  If the callers aren't mindless, this should      only happen when a node is made mutable under a transaction      root, and that only happens once under that root.  So, we'll be a      little bit sloppy here, and count on callers doing the right      thing. */
name|cache_item
operator|=
name|svn_hash_gets
argument_list|(
name|brd
operator|->
name|node_cache
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|cache_item
condition|)
block|{
comment|/* ### This section is somehow broken.  I don't know how, but it          ### is.  And I don't want to spend any more time on it.  So,          ### callers, use only revision root and don't try to update          ### an already-cached thing.  -- cmpilato */
name|SVN_ERR_MALFUNCTION_NO_RETURN
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
block|int cache_index = cache_item->idx;       cache_path = brd->node_cache_keys[cache_index];       cache_pool = cache_item->pool;       cache_item->node = svn_fs_base__dag_dup(node, cache_pool);
comment|/* Now, move the cache key reference to the end of the keys in          the keys array (unless it's already at the end).  ### Yes,          it's a memmove(), but we're not talking about pages of memory          here. */
block|if (cache_index != (num_keys - 1))         {           int move_num = NODE_CACHE_MAX_KEYS - cache_index - 1;           memmove(brd->node_cache_keys + cache_index,                   brd->node_cache_keys + cache_index + 1,                   move_num * sizeof(const char *));           cache_index = num_keys - 1;           brd->node_cache_keys[cache_index] = cache_path;         }
comment|/* Advance the cache pointers. */
block|cache_item->idx = cache_index;       brd->node_cache_idx = (cache_index + 1) % NODE_CACHE_MAX_KEYS;       return;
endif|#
directive|endif
block|}
comment|/* We're adding a new cache item.  First, see if we have room for it      (otherwise, make some room). */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|brd
operator|->
name|node_cache
argument_list|)
operator|==
name|NODE_CACHE_MAX_KEYS
condition|)
block|{
comment|/* No room.  Expire the oldest thing. */
name|cache_path
operator|=
name|brd
operator|->
name|node_cache_keys
index|[
name|brd
operator|->
name|node_cache_idx
index|]
expr_stmt|;
name|cache_item
operator|=
name|svn_hash_gets
argument_list|(
name|brd
operator|->
name|node_cache
argument_list|,
name|cache_path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|brd
operator|->
name|node_cache
argument_list|,
name|cache_path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cache_pool
operator|=
name|cache_item
operator|->
name|pool
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|cache_pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cache_pool
operator|=
name|svn_pool_create
argument_list|(
name|root
operator|->
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Make the cache item, allocated in its own pool. */
name|cache_item
operator|=
name|apr_palloc
argument_list|(
name|cache_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cache_item
argument_list|)
argument_list|)
expr_stmt|;
name|cache_item
operator|->
name|node
operator|=
name|svn_fs_base__dag_dup
argument_list|(
name|node
argument_list|,
name|cache_pool
argument_list|)
expr_stmt|;
name|cache_item
operator|->
name|idx
operator|=
name|brd
operator|->
name|node_cache_idx
expr_stmt|;
name|cache_item
operator|->
name|pool
operator|=
name|cache_pool
expr_stmt|;
comment|/* Now add it to the cache. */
name|cache_path
operator|=
name|apr_pstrdup
argument_list|(
name|cache_pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|brd
operator|->
name|node_cache
argument_list|,
name|cache_path
argument_list|,
name|cache_item
argument_list|)
expr_stmt|;
name|brd
operator|->
name|node_cache_keys
index|[
name|brd
operator|->
name|node_cache_idx
index|]
operator|=
name|cache_path
expr_stmt|;
comment|/* Advance the cache pointer. */
name|brd
operator|->
name|node_cache_idx
operator|=
operator|(
name|brd
operator|->
name|node_cache_idx
operator|+
literal|1
operator|)
operator|%
name|NODE_CACHE_MAX_KEYS
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creating transaction and revision root nodes.  */
end_comment

begin_struct
struct|struct
name|txn_root_args
block|{
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_txn_root
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|txn_root_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
init|=
name|args
operator|->
name|root_p
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
init|=
name|args
operator|->
name|txn
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|svn_txn_id
init|=
name|txn
operator|->
name|id
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|root_id
decl_stmt|,
modifier|*
name|base_root_id
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_hash_t
modifier|*
name|txnprops
decl_stmt|;
name|apr_uint32_t
name|flags
init|=
literal|0
decl_stmt|;
comment|/* Verify that the transaction actually exists.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_txn_ids
argument_list|(
operator|&
name|root_id
argument_list|,
operator|&
name|base_root_id
argument_list|,
name|fs
argument_list|,
name|svn_txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Look for special txn props that represent the 'flags' behavior of      the transaction. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__txn_proplist_in_trail
argument_list|(
operator|&
name|txnprops
argument_list|,
name|svn_txn_id
argument_list|,
name|trail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_OOD
argument_list|)
condition|)
name|flags
operator||=
name|SVN_FS_TXN_CHECK_OOD
expr_stmt|;
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|txnprops
argument_list|,
name|SVN_FS__PROP_TXN_CHECK_LOCKS
argument_list|)
condition|)
name|flags
operator||=
name|SVN_FS_TXN_CHECK_LOCKS
expr_stmt|;
name|root
operator|=
name|make_txn_root
argument_list|(
name|fs
argument_list|,
name|svn_txn_id
argument_list|,
name|txn
operator|->
name|base_rev
argument_list|,
name|flags
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|root_p
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__txn_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|struct
name|txn_root_args
name|args
decl_stmt|;
name|args
operator|.
name|root_p
operator|=
operator|&
name|root
expr_stmt|;
name|args
operator|.
name|txn
operator|=
name|txn
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|txn
operator|->
name|fs
argument_list|,
name|txn_body_txn_root
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_p
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|revision_root_args
block|{
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
decl_stmt|;
name|svn_revnum_t
name|rev
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_revision_root
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|revision_root_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_revision_root
argument_list|(
operator|&
name|root_dir
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|rev
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|=
name|make_revision_root
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|rev
argument_list|,
name|root_dir
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
operator|*
name|args
operator|->
name|root_p
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__revision_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_root_args
name|args
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|root_p
operator|=
operator|&
name|root
expr_stmt|;
name|args
operator|.
name|rev
operator|=
name|rev
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_revision_root
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_p
operator|=
name|root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Getting dag nodes for roots.  */
end_comment

begin_comment
comment|/* Set *NODE_P to a freshly opened dag node referring to the root    directory of ROOT, as part of TRAIL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|root_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_root_data_t
modifier|*
name|brd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
block|{
comment|/* It's a revision root, so we already have its root directory          opened.  */
operator|*
name|node_p
operator|=
name|svn_fs_base__dag_dup
argument_list|(
name|brd
operator|->
name|root_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* It's a transaction root.  Open a fresh copy.  */
return|return
name|svn_fs_base__dag_txn_root
argument_list|(
name|node_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* Set *NODE_P to a mutable root directory for ROOT, cloning if    necessary, as part of TRAIL.  ROOT must be a transaction root.  Use    ERROR_PATH in error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|mutable_root_node
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|error_path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_fs_base__dag_clone_root
argument_list|(
name|node_p
argument_list|,
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|txn
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
else|else
comment|/* If it's not a transaction root, we can't change its contents.  */
return|return
name|SVN_FS__ERR_NOT_MUTABLE
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|error_path
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Traversing directory paths.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|copy_id_inherit_t
block|{
name|copy_id_inherit_unknown
init|=
literal|0
block|,
name|copy_id_inherit_self
block|,
name|copy_id_inherit_parent
block|,
name|copy_id_inherit_new
block|}
name|copy_id_inherit_t
typedef|;
end_typedef

begin_comment
comment|/* A linked list representing the path from a node up to a root    directory.  We use this for cloning, and for operations that need    to deal with both a node and its parent directory.  For example, a    `delete' operation needs to know that the node actually exists, but    also needs to change the parent directory.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|parent_path_t
block|{
comment|/* A node along the path.  This could be the final node, one of its      parents, or the root.  Every parent path ends with an element for      the root directory.  */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* The name NODE has in its parent directory.  This is zero for the      root directory, which (obviously) has no name in its parent.  */
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* The parent of NODE, or zero if NODE is the root directory.  */
name|struct
name|parent_path_t
modifier|*
name|parent
decl_stmt|;
comment|/* The copy ID inheritance style. */
name|copy_id_inherit_t
name|copy_inherit
decl_stmt|;
comment|/* If copy ID inheritance style is copy_id_inherit_new, this is the      path which should be implicitly copied; otherwise, this is NULL. */
specifier|const
name|char
modifier|*
name|copy_src_path
decl_stmt|;
block|}
name|parent_path_t
typedef|;
end_typedef

begin_comment
comment|/* Return the FS path for the parent path chain object PARENT_PATH,    allocated in POOL. */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parent_path_path
parameter_list|(
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|"/"
decl_stmt|;
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
name|path_so_far
operator|=
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|parent_path
operator|->
name|entry
condition|?
name|svn_fspath__join
argument_list|(
name|path_so_far
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|pool
argument_list|)
else|:
name|path_so_far
return|;
block|}
end_function

begin_comment
comment|/* Return the FS path for the parent path chain object CHILD relative    to its ANCESTOR in the same chain, allocated in POOL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|parent_path_relpath
parameter_list|(
name|parent_path_t
modifier|*
name|child
parameter_list|,
name|parent_path_t
modifier|*
name|ancestor
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|""
decl_stmt|;
name|parent_path_t
modifier|*
name|this_node
init|=
name|child
decl_stmt|;
while|while
condition|(
name|this_node
operator|!=
name|ancestor
condition|)
block|{
name|assert
argument_list|(
name|this_node
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|path_so_far
operator|=
name|svn_relpath_join
argument_list|(
name|this_node
operator|->
name|entry
argument_list|,
name|path_so_far
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|this_node
operator|=
name|this_node
operator|->
name|parent
expr_stmt|;
block|}
return|return
name|path_so_far
return|;
block|}
end_function

begin_comment
comment|/* Choose a copy ID inheritance method *INHERIT_P to be used in the    event that immutable node CHILD in FS needs to be made mutable.  If    the inheritance method is copy_id_inherit_new, also return a    *COPY_SRC_PATH on which to base the new copy ID (else return NULL    for that path).  CHILD must have a parent (it cannot be the root    node).  TXN_ID is the transaction in which these items might be    mutable.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_copy_inheritance
parameter_list|(
name|copy_id_inherit_t
modifier|*
name|inherit_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|copy_src_path
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|parent_path_t
modifier|*
name|child
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|child_id
decl_stmt|,
modifier|*
name|parent_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_copy_id
decl_stmt|,
modifier|*
name|parent_copy_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|id_path
init|=
name|NULL
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|child
operator|&&
name|child
operator|->
name|parent
operator|&&
name|txn_id
argument_list|)
expr_stmt|;
comment|/* Initialize our return variables (default: self-inheritance). */
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_self
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize some convenience variables. */
name|child_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|child
operator|->
name|node
argument_list|)
expr_stmt|;
name|parent_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|child
operator|->
name|parent
operator|->
name|node
argument_list|)
expr_stmt|;
name|child_copy_id
operator|=
name|svn_fs_base__id_copy_id
argument_list|(
name|child_id
argument_list|)
expr_stmt|;
name|parent_copy_id
operator|=
name|svn_fs_base__id_copy_id
argument_list|(
name|parent_id
argument_list|)
expr_stmt|;
comment|/* Easy out: if this child is already mutable, we have nothing to do. */
if|if
condition|(
name|svn_fs_base__key_compare
argument_list|(
name|svn_fs_base__id_txn_id
argument_list|(
name|child_id
argument_list|)
argument_list|,
name|txn_id
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the child and its parent are on the same branch, then the      child will inherit the copy ID of its parent when made mutable.      This is trivially detectable when the child and its parent have      the same copy ID.  But that's not the sole indicator of      same-branchness.  It might be the case that the parent was the      result of a copy, but the child has not yet been cloned for      mutability since that copy.  Detection of this latter case      basically means making sure the copy IDs don't differ for some      other reason, such as that the child was the direct target of the      copy whose ID it has.  There is a special case here, too -- if      the child's copy ID is the special ID "0", it can't have been the      target of any copy, and therefore must be on the same branch as      its parent.  */
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|child_copy_id
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|svn_fs_base__key_compare
argument_list|(
name|child_copy_id
argument_list|,
name|parent_copy_id
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_parent
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
name|copy_t
modifier|*
name|copy
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_copy
argument_list|(
operator|&
name|copy
argument_list|,
name|fs
argument_list|,
name|child_copy_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_fs_base__id_compare
argument_list|(
name|copy
operator|->
name|dst_noderev_id
argument_list|,
name|child_id
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_parent
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* If we get here, the child and its parent are not on speaking      terms -- there will be no parental inheritance handed down in      *this* generation. */
comment|/* If the child was created at a different path than the one we are      expecting its clone to live, one of its parents must have been      created via a copy since the child was created.  The child isn't      on the same branch as its parent (we caught those cases early);      it can't keep its current copy ID because there's been an      affecting copy (its clone won't be on the same branch as the      child is).  That leaves only one course of action -- to assign      the child a brand new "soft" copy ID. */
name|id_path
operator|=
name|svn_fs_base__dag_get_created_path
argument_list|(
name|child
operator|->
name|node
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|id_path
argument_list|,
name|parent_path_path
argument_list|(
name|child
argument_list|,
name|pool
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
operator|*
name|inherit_p
operator|=
name|copy_id_inherit_new
expr_stmt|;
operator|*
name|copy_src_path
operator|=
name|id_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* The node gets to keep its own ID. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Allocate a new parent_path_t node from POOL, referring to NODE,    ENTRY, PARENT, and COPY_ID.  */
end_comment

begin_function
specifier|static
name|parent_path_t
modifier|*
name|make_parent_path
parameter_list|(
name|dag_node_t
modifier|*
name|node
parameter_list|,
name|char
modifier|*
name|entry
parameter_list|,
name|parent_path_t
modifier|*
name|parent
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|parent_path
argument_list|)
argument_list|)
decl_stmt|;
name|parent_path
operator|->
name|node
operator|=
name|node
expr_stmt|;
name|parent_path
operator|->
name|entry
operator|=
name|entry
expr_stmt|;
name|parent_path
operator|->
name|parent
operator|=
name|parent
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|copy_id_inherit_unknown
expr_stmt|;
name|parent_path
operator|->
name|copy_src_path
operator|=
name|NULL
expr_stmt|;
return|return
name|parent_path
return|;
block|}
end_function

begin_comment
comment|/* Flags for open_path.  */
end_comment

begin_typedef
typedef|typedef
enum|enum
name|open_path_flags_t
block|{
comment|/* The last component of the PATH need not exist.  (All parent      directories must exist, as usual.)  If the last component doesn't      exist, simply leave the `node' member of the bottom parent_path      component zero.  */
name|open_path_last_optional
init|=
literal|1
block|}
name|open_path_flags_t
typedef|;
end_typedef

begin_comment
comment|/* Open the node identified by PATH in ROOT, as part of TRAIL.  Set    *PARENT_PATH_P to a path from the node up to ROOT, allocated in    TRAIL->pool.  The resulting *PARENT_PATH_P value is guaranteed to    contain at least one element, for the root directory.     If resulting *PARENT_PATH_P will eventually be made mutable and    modified, or if copy ID inheritance information is otherwise    needed, TXN_ID should be the ID of the mutability transaction.  If    TXN_ID is NULL, no copy ID in heritance information will be    calculated for the *PARENT_PATH_P chain.     If FLAGS& open_path_last_optional is zero, return the error    SVN_ERR_FS_NOT_FOUND if the node PATH refers to does not exist.  If    non-zero, require all the parent directories to exist as normal,    but if the final path component doesn't exist, simply return a path    whose bottom `node' member is zero.  This option is useful for    callers that create new nodes --- we find the parent directory for    them, and tell them whether the entry exists already.     NOTE: Public interfaces which only *read* from the filesystem    should not call this function directly, but should instead use    get_dag(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_path
parameter_list|(
name|parent_path_t
modifier|*
modifier|*
name|parent_path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|int
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|dag_node_t
modifier|*
name|here
decl_stmt|;
comment|/* The directory we're currently looking at.  */
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
comment|/* The path from HERE up to the root.  */
specifier|const
name|char
modifier|*
name|rest
decl_stmt|;
comment|/* The portion of PATH we haven't traversed yet.  */
specifier|const
name|char
modifier|*
name|canon_path
init|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_so_far
init|=
literal|"/"
decl_stmt|;
comment|/* Make a parent_path item for the root node, using its own current      copy id.  */
name|SVN_ERR
argument_list|(
name|root_node
argument_list|(
operator|&
name|here
argument_list|,
name|root
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|here
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|copy_id_inherit_self
expr_stmt|;
name|rest
operator|=
name|canon_path
operator|+
literal|1
expr_stmt|;
comment|/* skip the leading '/', it saves in iteration */
comment|/* Whenever we are at the top of this loop:      - HERE is our current directory,      - ID is the node revision ID of HERE,      - REST is the path we're going to find in HERE, and      - PARENT_PATH includes HERE and all its parents.  */
for|for
control|(
init|;
condition|;
control|)
block|{
specifier|const
name|char
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|entry
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
comment|/* Parse out the next entry from the path.  */
name|entry
operator|=
name|svn_fs__next_entry_name
argument_list|(
operator|&
name|next
argument_list|,
name|rest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Calculate the path traversed thus far. */
name|path_so_far
operator|=
name|svn_fspath__join
argument_list|(
name|path_so_far
argument_list|,
name|entry
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|entry
operator|==
literal|'\0'
condition|)
block|{
comment|/* Given the behavior of svn_fs__next_entry_name(), this              happens when the path either starts or ends with a slash.              In either case, we stay put: the current directory stays              the same, and we add nothing to the parent path. */
name|child
operator|=
name|here
expr_stmt|;
block|}
else|else
block|{
name|copy_id_inherit_t
name|inherit
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_path
init|=
name|NULL
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|dag_node_t
modifier|*
name|cached_node
decl_stmt|;
comment|/* If we found a directory entry, follow it.  First, we              check our node cache, and, failing that, we hit the DAG              layer. */
name|cached_node
operator|=
name|dag_node_cache_get
argument_list|(
name|root
argument_list|,
name|path_so_far
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|cached_node
condition|)
name|child
operator|=
name|cached_node
expr_stmt|;
else|else
name|err
operator|=
name|svn_fs_base__dag_open
argument_list|(
operator|&
name|child
argument_list|,
name|here
argument_list|,
name|entry
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* "file not found" requires special handling.  */
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
condition|)
block|{
comment|/* If this was the last path component, and the caller                  said it was optional, then don't return an error;                  just put a NULL node pointer in the path.  */
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|open_path_last_optional
operator|)
operator|&&
operator|(
operator|!
name|next
operator|||
operator|*
name|next
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|NULL
argument_list|,
name|entry
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* Build a better error message than svn_fs_base__dag_open                      can provide, giving the root and full path name.  */
return|return
name|SVN_FS__NOT_FOUND
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
block|}
block|}
comment|/* Other errors we return normally.  */
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Now, make a parent_path item for CHILD. */
name|parent_path
operator|=
name|make_parent_path
argument_list|(
name|child
argument_list|,
name|entry
argument_list|,
name|parent_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|txn_id
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_copy_inheritance
argument_list|(
operator|&
name|inherit
argument_list|,
operator|&
name|copy_path
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|parent_path
operator|->
name|copy_inherit
operator|=
name|inherit
expr_stmt|;
name|parent_path
operator|->
name|copy_src_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|copy_path
argument_list|)
expr_stmt|;
block|}
comment|/* Cache the node we found (if it wasn't already cached). */
if|if
condition|(
operator|!
name|cached_node
condition|)
name|dag_node_cache_set
argument_list|(
name|root
argument_list|,
name|path_so_far
argument_list|,
name|child
argument_list|)
expr_stmt|;
block|}
comment|/* Are we finished traversing the path?  */
if|if
condition|(
operator|!
name|next
condition|)
break|break;
comment|/* The path isn't finished yet; we'd better be in a directory.  */
if|if
condition|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|child
argument_list|)
operator|!=
name|svn_node_dir
condition|)
name|SVN_ERR_W
argument_list|(
name|SVN_FS__ERR_NOT_DIRECTORY
argument_list|(
name|fs
argument_list|,
name|path_so_far
argument_list|)
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Failure opening '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|rest
operator|=
name|next
expr_stmt|;
name|here
operator|=
name|child
expr_stmt|;
block|}
operator|*
name|parent_path_p
operator|=
name|parent_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Make the node referred to by PARENT_PATH mutable, if it isn't    already, as part of TRAIL.  ROOT must be the root from which    PARENT_PATH descends.  Clone any parent directories as needed.    Adjust the dag nodes in PARENT_PATH to refer to the clones.  Use    ERROR_PATH in error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|make_path_mutable
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
specifier|const
name|char
modifier|*
name|error_path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|cloned_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
comment|/* Is the node mutable already?  */
if|if
condition|(
name|svn_fs_base__dag_check_mutable
argument_list|(
name|parent_path
operator|->
name|node
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Are we trying to clone the root, or somebody's child node?  */
if|if
condition|(
name|parent_path
operator|->
name|parent
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|parent_id
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
init|=
name|svn_fs_base__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_id
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_src_path
init|=
name|parent_path
operator|->
name|copy_src_path
decl_stmt|;
name|copy_id_inherit_t
name|inherit
init|=
name|parent_path
operator|->
name|copy_inherit
decl_stmt|;
specifier|const
name|char
modifier|*
name|clone_path
decl_stmt|;
comment|/* We're trying to clone somebody's child.  Make sure our parent          is mutable.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|error_path
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|inherit
condition|)
block|{
case|case
name|copy_id_inherit_parent
case|:
name|parent_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|)
expr_stmt|;
name|copy_id
operator|=
name|svn_fs_base__id_copy_id
argument_list|(
name|parent_id
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_new
case|:
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__reserve_copy_id
argument_list|(
operator|&
name|copy_id
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_self
case|:
name|copy_id
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|copy_id_inherit_unknown
case|:
default|default:
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* uh-oh -- somebody didn't calculate copy-ID                       inheritance data. */
block|}
comment|/* Now make this node mutable.  */
name|clone_path
operator|=
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_clone_child
argument_list|(
operator|&
name|cloned_node
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|clone_path
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|copy_id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we just created a brand new copy ID, we need to store a          `copies' table entry for it, as well as a notation in the          transaction that should this transaction be terminated, our          new copy needs to be removed. */
if|if
condition|(
name|inherit
operator|==
name|copy_id_inherit_new
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|new_node_id
init|=
name|svn_fs_base__dag_get_id
argument_list|(
name|cloned_node
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__create_copy
argument_list|(
name|fs
argument_list|,
name|copy_id
argument_list|,
name|copy_src_path
argument_list|,
name|svn_fs_base__id_txn_id
argument_list|(
name|node_id
argument_list|)
argument_list|,
name|new_node_id
argument_list|,
name|copy_kind_soft
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__add_txn_copy
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|copy_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* We're trying to clone the root directory.  */
name|SVN_ERR
argument_list|(
name|mutable_root_node
argument_list|(
operator|&
name|cloned_node
argument_list|,
name|root
argument_list|,
name|error_path
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Update the PARENT_PATH link to refer to the clone.  */
name|parent_path
operator|->
name|node
operator|=
name|cloned_node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Walk up PARENT_PATH to the root of the tree, adjusting each node's    mergeinfo count by COUNT_DELTA as part of Subversion transaction    TXN_ID and TRAIL.  Use POOL for allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|adjust_parent_mergeinfo_counts
parameter_list|(
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
name|apr_int64_t
name|count_delta
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|parent_path_t
modifier|*
name|pp
init|=
name|parent_path
decl_stmt|;
if|if
condition|(
name|count_delta
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|pp
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_adjust_mergeinfo_count
argument_list|(
name|pp
operator|->
name|node
argument_list|,
name|count_delta
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pp
operator|->
name|parent
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Open the node identified by PATH in ROOT, as part of TRAIL.  Set    *DAG_NODE_P to the node we find, allocated in TRAIL->pool.  Return    the error SVN_ERR_FS_NOT_FOUND if this node doesn't exist. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_dag
parameter_list|(
name|dag_node_t
modifier|*
modifier|*
name|dag_node_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
comment|/* Canonicalize the input PATH. */
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If ROOT is a revision root, we'll look for the DAG in our cache. */
name|node
operator|=
name|dag_node_cache_get
argument_list|(
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
block|{
comment|/* Call open_path with no flags, as we want this to return an error          if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
comment|/* No need to cache our find -- open_path() will do that for us. */
block|}
operator|*
name|dag_node_p
operator|=
name|node
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Populating the `changes' table. */
end_comment

begin_comment
comment|/* Add a change to the changes table in FS, keyed on transaction id    TXN_ID, and indicated that a change of kind CHANGE_KIND occurred on    PATH (whose node revision id is--or was, in the case of a    deletion--NODEREV_ID), and optionally that TEXT_MODs or PROP_MODs    occurred.  Do all this as part of TRAIL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_change
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|noderev_id
parameter_list|,
name|svn_fs_path_change_kind_t
name|change_kind
parameter_list|,
name|svn_boolean_t
name|text_mod
parameter_list|,
name|svn_boolean_t
name|prop_mod
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|change_t
name|change
decl_stmt|;
name|change
operator|.
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|change
operator|.
name|noderev_id
operator|=
name|noderev_id
expr_stmt|;
name|change
operator|.
name|kind
operator|=
name|change_kind
expr_stmt|;
name|change
operator|.
name|text_mod
operator|=
name|text_mod
expr_stmt|;
name|change
operator|.
name|prop_mod
operator|=
name|prop_mod
expr_stmt|;
return|return
name|svn_fs_bdb__changes_add
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
operator|&
name|change
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic node operations.  */
end_comment

begin_struct
struct|struct
name|node_id_args
block|{
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_node_id
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|node_id_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|args
operator|->
name|id_p
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_node_id
parameter_list|(
specifier|const
name|svn_fs_id_t
modifier|*
modifier|*
name|id_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_root_data_t
modifier|*
name|brd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
operator|&&
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|||
operator|(
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|path
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Optimize the case where we don't need any db access at all.          The root directory ("" or "/") node is stored in the          svn_fs_root_t object, and never changes when it's a revision          root, so we can just reach in and grab it directly. */
operator|*
name|id_p
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|brd
operator|->
name|root_dir
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|struct
name|node_id_args
name|args
decl_stmt|;
name|args
operator|.
name|id_p
operator|=
operator|&
name|id
expr_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_node_id
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|id_p
operator|=
name|id
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|node_created_rev_args
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_node_created_rev
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|node_created_rev_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__dag_get_revision
argument_list|(
operator|&
operator|(
name|args
operator|->
name|revision
operator|)
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_node_created_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_created_rev_args
name|args
decl_stmt|;
name|args
operator|.
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_node_created_rev
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|revision
operator|=
name|args
operator|.
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|node_created_path_args
block|{
specifier|const
name|char
modifier|*
modifier|*
name|created_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_node_created_path
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|node_created_path_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|args
operator|->
name|created_path
operator|=
name|svn_fs_base__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_node_created_path
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|created_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_created_path_args
name|args
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|args
operator|.
name|created_path
operator|=
name|created_path
expr_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_node_created_path
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|created_path
condition|)
operator|*
name|created_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
operator|*
name|created_path
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|node_kind_args
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* OUT parameter */
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_node_kind
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|node_kind_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|kind
operator|=
name|svn_fs_base__dag_node_kind
argument_list|(
name|node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|node_kind
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_kind_args
name|args
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
comment|/* Get the node id. */
name|SVN_ERR
argument_list|(
name|base_node_id
argument_list|(
operator|&
name|node_id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use the node id to get the real kind. */
name|args
operator|.
name|id
operator|=
name|node_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_node_kind
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|kind_p
operator|=
name|args
operator|.
name|kind
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_check_path
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|node_kind
argument_list|(
name|kind_p
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
operator|*
name|kind_p
operator|=
name|svn_node_none
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|node_prop_args
block|{
name|svn_string_t
modifier|*
modifier|*
name|value_p
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_node_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|node_prop_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|value_p
operator|)
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|proplist
condition|)
operator|*
operator|(
name|args
operator|->
name|value_p
operator|)
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|args
operator|->
name|propname
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_node_prop
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|value_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|node_prop_args
name|args
decl_stmt|;
name|svn_string_t
modifier|*
name|value
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|args
operator|.
name|value_p
operator|=
operator|&
name|value
expr_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|args
operator|.
name|propname
operator|=
name|propname
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_node_prop
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|value_p
operator|=
name|value
condition|?
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|node_proplist_args
block|{
name|apr_hash_t
modifier|*
modifier|*
name|table_p
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_node_proplist
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|node_proplist_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|args
operator|->
name|table_p
operator|=
name|proplist
condition|?
name|proplist
else|:
name|apr_hash_make
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_node_proplist
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|struct
name|node_proplist_args
name|args
decl_stmt|;
name|args
operator|.
name|table_p
operator|=
operator|&
name|table
expr_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_node_proplist
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|table_p
operator|=
name|table
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|change_node_prop_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|value
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_change_node_prop
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|change_node_prop_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|args
operator|->
name|root
operator|->
name|txn
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|trail
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if path is locked; if so, check that we can use it.      Notice that we're doing this non-recursively, regardless of node kind. */
if|if
condition|(
name|args
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|args
operator|->
name|path
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|args
operator|->
name|root
argument_list|,
name|parent_path
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|parent_path
operator|->
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's no proplist, but we're just deleting a property, exit now. */
if|if
condition|(
operator|(
operator|!
name|proplist
operator|)
operator|&&
operator|(
operator|!
name|args
operator|->
name|value
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Now, if there's no proplist, we know we need to make one. */
if|if
condition|(
operator|!
name|proplist
condition|)
name|proplist
operator|=
name|apr_hash_make
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* Set the property. */
name|svn_hash_sets
argument_list|(
name|proplist
argument_list|,
name|args
operator|->
name|name
argument_list|,
name|args
operator|->
name|value
argument_list|)
expr_stmt|;
comment|/* Overwrite the node's proplist. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_set_proplist
argument_list|(
name|parent_path
operator|->
name|node
argument_list|,
name|proplist
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this was a change to the mergeinfo property, and our version      of the filesystem cares, we have some extra recording to do.       ### If the format *doesn't* support mergeinfo recording, should      ### we fuss about attempts to change the svn:mergeinfo property      ### in any way save to delete it?  */
if|if
condition|(
operator|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|args
operator|->
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|svn_boolean_t
name|had_mergeinfo
decl_stmt|,
name|has_mergeinfo
init|=
name|args
operator|->
name|value
operator|!=
name|NULL
decl_stmt|;
comment|/* First, note on our node that it has mergeinfo. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_set_has_mergeinfo
argument_list|(
name|parent_path
operator|->
name|node
argument_list|,
name|has_mergeinfo
argument_list|,
operator|&
name|had_mergeinfo
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a change from the old state, we need to update our          node's parents' mergeinfo counts by a factor of 1. */
if|if
condition|(
name|parent_path
operator|->
name|parent
operator|&&
operator|(
operator|(
operator|!
name|had_mergeinfo
operator|)
operator|!=
operator|(
operator|!
name|has_mergeinfo
operator|)
operator|)
condition|)
name|SVN_ERR
argument_list|(
name|adjust_parent_mergeinfo_counts
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|has_mergeinfo
condition|?
literal|1
else|:
operator|-
literal|1
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|args
operator|->
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_change_node_prop
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|change_node_prop_args
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|root
argument_list|)
return|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|args
operator|.
name|name
operator|=
name|name
expr_stmt|;
name|args
operator|.
name|value
operator|=
name|value
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_change_node_prop
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|things_changed_args
block|{
name|svn_boolean_t
modifier|*
name|changed_p
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root1
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root2
decl_stmt|;
specifier|const
name|char
modifier|*
name|path1
decl_stmt|;
specifier|const
name|char
modifier|*
name|path2
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_props_changed
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|things_changed_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node1
argument_list|,
name|args
operator|->
name|root1
argument_list|,
name|args
operator|->
name|path1
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node2
argument_list|,
name|args
operator|->
name|root2
argument_list|,
name|args
operator|->
name|path2
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__things_different
argument_list|(
name|args
operator|->
name|changed_p
argument_list|,
name|NULL
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_props_changed
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|things_changed_args
name|args
decl_stmt|;
comment|/* Check that roots are in the same fs. */
if|if
condition|(
name|root1
operator|->
name|fs
operator|!=
name|root2
operator|->
name|fs
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot compare property value between two different filesystems"
argument_list|)
argument_list|)
return|;
name|args
operator|.
name|root1
operator|=
name|root1
expr_stmt|;
name|args
operator|.
name|root2
operator|=
name|root2
expr_stmt|;
name|args
operator|.
name|path1
operator|=
name|path1
expr_stmt|;
name|args
operator|.
name|path2
operator|=
name|path2
expr_stmt|;
name|args
operator|.
name|changed_p
operator|=
name|changed_p
expr_stmt|;
name|args
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|root1
operator|->
name|fs
argument_list|,
name|txn_body_props_changed
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Miscellaneous table handling */
end_comment

begin_struct
struct|struct
name|miscellaneous_set_args
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_miscellaneous_set
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|miscellaneous_set_args
modifier|*
name|msa
init|=
name|baton
decl_stmt|;
return|return
name|svn_fs_bdb__miscellaneous_set
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|msa
operator|->
name|key
argument_list|,
name|msa
operator|->
name|val
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__miscellaneous_set
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|miscellaneous_set_args
name|msa
decl_stmt|;
name|msa
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|msa
operator|.
name|val
operator|=
name|val
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_miscellaneous_set
argument_list|,
operator|&
name|msa
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|miscellaneous_get_args
block|{
specifier|const
name|char
modifier|*
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|val
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_miscellaneous_get
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|miscellaneous_get_args
modifier|*
name|mga
init|=
name|baton
decl_stmt|;
return|return
name|svn_fs_bdb__miscellaneous_get
argument_list|(
name|mga
operator|->
name|val
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|mga
operator|->
name|key
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__miscellaneous_get
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|val
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|miscellaneous_get_args
name|mga
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|mga
operator|.
name|key
operator|=
name|key
expr_stmt|;
name|mga
operator|.
name|val
operator|=
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_miscellaneous_get
argument_list|,
operator|&
name|mga
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|val
condition|)
operator|*
name|val
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
operator|*
name|val
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Getting a directory's entries */
end_comment

begin_struct
struct|struct
name|dir_entries_args
block|{
name|apr_hash_t
modifier|*
modifier|*
name|table_p
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* *(BATON->table_p) will never be NULL on successful return */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_dir_entries
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|dir_entries_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the entries for PARENT_PATH. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Potentially initialize the return value to an empty hash. */
operator|*
name|args
operator|->
name|table_p
operator|=
name|entries
condition|?
name|entries
else|:
name|apr_hash_make
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_dir_entries
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|table_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|dir_entries_args
name|args
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|apr_hash_t
modifier|*
name|table
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|args
operator|.
name|table_p
operator|=
operator|&
name|table
expr_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_dir_entries
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Add in the kind data. */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|table
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|entry
decl_stmt|;
name|struct
name|node_kind_args
name|nk_args
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* KEY will be the entry name in ancestor (about which we          simply don't care), VAL the dirent. */
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|entry
operator|=
name|val
expr_stmt|;
name|nk_args
operator|.
name|id
operator|=
name|entry
operator|->
name|id
expr_stmt|;
comment|/* We don't need to have the retry function destroy the trail          pool because we're already doing that via the use of an          iteration pool. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_node_kind
argument_list|,
operator|&
name|nk_args
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|entry
operator|->
name|kind
operator|=
name|nk_args
operator|.
name|kind
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|table_p
operator|=
name|table
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Merges and commits. */
end_comment

begin_struct
struct|struct
name|deltify_committed_args
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* the filesystem */
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* revision just committed */
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
comment|/* transaction just committed */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|txn_deltify_args
block|{
comment|/* The transaction ID whose nodes are being deltified. */
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
comment|/* The target is what we're deltifying. */
specifier|const
name|svn_fs_id_t
modifier|*
name|tgt_id
decl_stmt|;
comment|/* The base is what we're deltifying against.  It's not necessarily      the "next" revision of the node; skip deltas mean we sometimes      deltify against a successor many generations away.  This may be      NULL, in which case we'll avoid deltification and simply index      TGT_ID's data checksum. */
specifier|const
name|svn_fs_id_t
modifier|*
name|base_id
decl_stmt|;
comment|/* We only deltify props for directories.      ### Didn't we try removing this horrid little optimization once?      ### What was the result?  I would have thought that skip deltas      ### mean directory undeltification is cheap enough now. */
name|svn_boolean_t
name|is_dir
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_txn_deltify
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|txn_deltify_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|tgt_node
decl_stmt|,
modifier|*
name|base_node
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|trail
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|tgt_node
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|tgt_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have something to deltify against, do so. */
if|if
condition|(
name|args
operator|->
name|base_id
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|base_node
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|base_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_deltify
argument_list|(
name|tgt_node
argument_list|,
name|base_node
argument_list|,
name|args
operator|->
name|is_dir
argument_list|,
name|args
operator|->
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If we support rep sharing, and this isn't a directory, record a      mapping of TGT_NODE's data checksum to its representation key. */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_REP_SHARING_FORMAT
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_index_checksums
argument_list|(
name|tgt_node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|txn_pred_count_args
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|int
name|pred_count
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_pred_count
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|struct
name|txn_pred_count_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|->
name|pred_count
operator|=
name|noderev
operator|->
name|predecessor_count
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|txn_pred_id_args
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
comment|/* The node id whose predecessor we want. */
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
comment|/* The returned predecessor id. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The pool in which to allocate pred_id. */
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_pred_id
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|nr
decl_stmt|;
name|struct
name|txn_pred_id_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|nr
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|->
name|predecessor_id
condition|)
name|args
operator|->
name|pred_id
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|nr
operator|->
name|predecessor_id
argument_list|,
name|args
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|args
operator|->
name|pred_id
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Deltify PATH in ROOT's predecessor iff PATH is mutable under TXN_ID    in FS.  If PATH is a mutable directory, recurse.     NODE_ID is the node revision ID for PATH in ROOT, or NULL if that    value isn't known.  KIND is the node kind for PATH in ROOT, or    svn_node_unknown is the kind isn't known.     Use POOL for necessary allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|deltify_mutable
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
init|=
name|node_id
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
name|struct
name|txn_deltify_args
name|td_args
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Get the ID for PATH under ROOT if it wasn't provided. */
if|if
condition|(
operator|!
name|node_id
condition|)
name|SVN_ERR
argument_list|(
name|base_node_id
argument_list|(
operator|&
name|id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check for mutability.  Not mutable?  Go no further.  This is safe      to do because for items in the tree to be mutable, their parent      dirs must also be mutable.  Therefore, if a directory is not      mutable under TXN_ID, its children cannot be.  */
if|if
condition|(
name|strcmp
argument_list|(
name|svn_fs_base__id_txn_id
argument_list|(
name|id
argument_list|)
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Is this a directory?  */
if|if
condition|(
name|kind
operator|==
name|svn_node_unknown
condition|)
name|SVN_ERR
argument_list|(
name|base_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a directory, read its entries.  */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|base_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there are entries, recurse on 'em.  */
if|if
condition|(
name|entries
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
comment|/* KEY will be the entry name, VAL the dirent */
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|entry
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|entry
operator|=
name|val
expr_stmt|;
name|SVN_ERR
argument_list|(
name|deltify_mutable
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
name|svn_fspath__join
argument_list|(
name|path
argument_list|,
name|key
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|entry
operator|->
name|id
argument_list|,
name|entry
operator|->
name|kind
argument_list|,
name|txn_id
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Index ID's data checksum. */
name|td_args
operator|.
name|txn_id
operator|=
name|txn_id
expr_stmt|;
name|td_args
operator|.
name|tgt_id
operator|=
name|id
expr_stmt|;
name|td_args
operator|.
name|base_id
operator|=
name|NULL
expr_stmt|;
name|td_args
operator|.
name|is_dir
operator|=
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_txn_deltify
argument_list|,
operator|&
name|td_args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, deltify old data against this node. */
block|{
comment|/* Prior to 1.6, we use the following algorithm to deltify nodes:         Redeltify predecessor node-revisions of the one we added.  The        idea is to require at most 2*lg(N) deltas to be applied to get        to any node-revision in a chain of N predecessors.  We do this        using a technique derived from skip lists:            - Always redeltify the immediate parent            - If the number of predecessors is divisible by 2,               redeltify the revision two predecessors back            - If the number of predecessors is divisible by 4,               redeltify the revision four predecessors back         ... and so on.         That's the theory, anyway.  Unfortunately, if we strictly        follow that theory we get a bunch of overhead up front and no        great benefit until the number of predecessors gets large.  So,        stop at redeltifying the parent if the number of predecessors        is less than 32, and also skip the second level (redeltifying        two predecessors back), since that doesn't help much.  Also,        don't redeltify the oldest node-revision; it's potentially        expensive and doesn't help retrieve any other revision.        (Retrieving the oldest node-revision will still be fast, just        not as blindingly so.)         For 1.6 and beyond, we just deltify the current node against its        predecessors, using skip deltas similar to the way FSFS does.  */
name|int
name|pred_count
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
name|struct
name|txn_pred_count_args
name|tpc_args
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpools
index|[
literal|2
index|]
decl_stmt|;
name|int
name|active_subpool
init|=
literal|0
decl_stmt|;
name|svn_revnum_t
name|forward_delta_rev
init|=
literal|0
decl_stmt|;
name|tpc_args
operator|.
name|id
operator|=
name|id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_pred_count
argument_list|,
operator|&
name|tpc_args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|pred_count
operator|=
name|tpc_args
operator|.
name|pred_count
expr_stmt|;
comment|/* If nothing to deltify, then we're done. */
if|if
condition|(
name|pred_count
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|subpools
index|[
literal|0
index|]
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|subpools
index|[
literal|1
index|]
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* If we support the 'miscellaneous' table, check it to see if        there is a point in time before which we don't want to do        deltification. */
comment|/* ### FIXME:  I think this is an unnecessary restriction.  We        ### should be able to do something meaningful for most        ### deltification requests -- what that is depends on the        ### directory of the deltas for that revision, though. */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_MISCELLANY_FORMAT
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__miscellaneous_get
argument_list|(
operator|&
name|val
argument_list|,
name|fs
argument_list|,
name|SVN_FS_BASE__MISC_FORWARD_DELTA_UPGRADE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|SVN_ERR
argument_list|(
name|svn_revnum_parse
argument_list|(
operator|&
name|forward_delta_rev
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_FORWARD_DELTAS_FORMAT
operator|&&
name|forward_delta_rev
operator|<=
name|root
operator|->
name|rev
condition|)
block|{
comment|/**** FORWARD DELTA STORAGE ****/
comment|/* Decide which predecessor to deltify against.  Flip the rightmost '1'            bit of the predecessor count to determine which file rev (counting            from 0) we want to use.  (To see why count& (count - 1) unsets the            rightmost set bit, think about how you decrement a binary number. */
name|pred_count
operator|=
name|pred_count
operator|&
operator|(
name|pred_count
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Walk back a number of predecessors equal to the difference between            pred_count and the original predecessor count.  (For example, if            the node has ten predecessors and we want the eighth node, walk back            two predecessors. */
name|pred_id
operator|=
name|id
expr_stmt|;
comment|/* We need to use two alternating pools because the id used in the            call to txn_body_pred_id is allocated by the previous inner            loop iteration.  If we would clear the pool each iteration we            would free the previous result.  */
while|while
condition|(
operator|(
name|pred_count
operator|++
operator|)
operator|<
name|tpc_args
operator|.
name|pred_count
condition|)
block|{
name|struct
name|txn_pred_id_args
name|tpi_args
decl_stmt|;
name|active_subpool
operator|=
operator|!
name|active_subpool
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpools
index|[
name|active_subpool
index|]
argument_list|)
expr_stmt|;
name|tpi_args
operator|.
name|id
operator|=
name|pred_id
expr_stmt|;
name|tpi_args
operator|.
name|pool
operator|=
name|subpools
index|[
name|active_subpool
index|]
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_pred_id
argument_list|,
operator|&
name|tpi_args
argument_list|,
name|FALSE
argument_list|,
name|subpools
index|[
name|active_subpool
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|pred_id
operator|=
name|tpi_args
operator|.
name|pred_id
expr_stmt|;
if|if
condition|(
name|pred_id
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Corrupt DB: faulty predecessor count"
argument_list|)
argument_list|)
return|;
block|}
comment|/* Finally, do the deltification. */
name|td_args
operator|.
name|txn_id
operator|=
name|txn_id
expr_stmt|;
name|td_args
operator|.
name|tgt_id
operator|=
name|id
expr_stmt|;
name|td_args
operator|.
name|base_id
operator|=
name|pred_id
expr_stmt|;
name|td_args
operator|.
name|is_dir
operator|=
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_txn_deltify
argument_list|,
operator|&
name|td_args
argument_list|,
name|TRUE
argument_list|,
name|subpools
index|[
name|active_subpool
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|nlevels
decl_stmt|,
name|lev
decl_stmt|,
name|count
decl_stmt|;
comment|/**** REVERSE DELTA STORAGE ****/
comment|/* Decide how many predecessors to redeltify.  To save overhead,            don't redeltify anything but the immediate predecessor if there            are less than 32 predecessors. */
name|nlevels
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|pred_count
operator|>=
literal|32
condition|)
block|{
while|while
condition|(
name|pred_count
operator|%
literal|2
operator|==
literal|0
condition|)
block|{
name|pred_count
operator|/=
literal|2
expr_stmt|;
name|nlevels
operator|++
expr_stmt|;
block|}
comment|/* Don't redeltify the oldest revision. */
if|if
condition|(
literal|1
operator|<<
operator|(
name|nlevels
operator|-
literal|1
operator|)
operator|==
name|pred_count
condition|)
name|nlevels
operator|--
expr_stmt|;
block|}
comment|/* Redeltify the desired number of predecessors. */
name|count
operator|=
literal|0
expr_stmt|;
name|pred_id
operator|=
name|id
expr_stmt|;
comment|/* We need to use two alternating pools because the id used in the            call to txn_body_pred_id is allocated by the previous inner            loop iteration.  If we would clear the pool each iteration we            would free the previous result.  */
for|for
control|(
name|lev
operator|=
literal|0
init|;
name|lev
operator|<
name|nlevels
condition|;
name|lev
operator|++
control|)
block|{
comment|/* To save overhead, skip the second level (that is, never                redeltify the node-revision two predecessors back). */
if|if
condition|(
name|lev
operator|==
literal|1
condition|)
continue|continue;
comment|/* Note that COUNT is not reset between levels, and neither is                PREDNODE; we just keep counting from where we were up to                where we're supposed to get. */
while|while
condition|(
name|count
operator|<
operator|(
literal|1
operator|<<
name|lev
operator|)
condition|)
block|{
name|struct
name|txn_pred_id_args
name|tpi_args
decl_stmt|;
name|active_subpool
operator|=
operator|!
name|active_subpool
expr_stmt|;
name|svn_pool_clear
argument_list|(
name|subpools
index|[
name|active_subpool
index|]
argument_list|)
expr_stmt|;
name|tpi_args
operator|.
name|id
operator|=
name|pred_id
expr_stmt|;
name|tpi_args
operator|.
name|pool
operator|=
name|subpools
index|[
name|active_subpool
index|]
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_pred_id
argument_list|,
operator|&
name|tpi_args
argument_list|,
name|FALSE
argument_list|,
name|subpools
index|[
name|active_subpool
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|pred_id
operator|=
name|tpi_args
operator|.
name|pred_id
expr_stmt|;
if|if
condition|(
name|pred_id
operator|==
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Corrupt DB: faulty predecessor count"
argument_list|)
argument_list|)
return|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Finally, do the deltification. */
name|td_args
operator|.
name|txn_id
operator|=
name|NULL
expr_stmt|;
comment|/* Don't require mutable reps */
name|td_args
operator|.
name|tgt_id
operator|=
name|pred_id
expr_stmt|;
name|td_args
operator|.
name|base_id
operator|=
name|id
expr_stmt|;
name|td_args
operator|.
name|is_dir
operator|=
operator|(
name|kind
operator|==
name|svn_node_dir
operator|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_txn_deltify
argument_list|,
operator|&
name|td_args
argument_list|,
name|TRUE
argument_list|,
name|subpools
index|[
name|active_subpool
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpools
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpools
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|get_root_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Set ARGS->node to the root node of ARGS->root.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_root
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|get_root_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
return|return
name|get_dag
argument_list|(
operator|&
operator|(
name|args
operator|->
name|node
operator|)
argument_list|,
name|args
operator|->
name|root
argument_list|,
literal|""
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|update_ancestry
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|source_id
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|target_id
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|int
name|source_pred_count
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
comment|/* Set target's predecessor-id to source_id.  */
if|if
condition|(
name|strcmp
argument_list|(
name|svn_fs_base__id_txn_id
argument_list|(
name|target_id
argument_list|)
argument_list|,
name|txn_id
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_MUTABLE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected immutable node at '%s'"
argument_list|)
argument_list|,
name|target_path
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|noderev
argument_list|,
name|fs
argument_list|,
name|target_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|predecessor_id
operator|=
name|source_id
expr_stmt|;
name|noderev
operator|->
name|predecessor_count
operator|=
name|source_pred_count
expr_stmt|;
if|if
condition|(
name|noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
name|noderev
operator|->
name|predecessor_count
operator|++
expr_stmt|;
return|return
name|svn_fs_bdb__put_node_revision
argument_list|(
name|fs
argument_list|,
name|target_id
argument_list|,
name|noderev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Set the contents of CONFLICT_PATH to PATH, and return an    SVN_ERR_FS_CONFLICT error that indicates that there was a conflict    at PATH.  Perform all allocations in POOL (except the allocation of    CONFLICT_PATH, which should be handled outside this function).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|conflict_err
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|conflict_path
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|svn_stringbuf_set
argument_list|(
name|conflict_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CONFLICT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Conflict at '%s'"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Merge changes between ANCESTOR and SOURCE into TARGET as part of  * TRAIL.  ANCESTOR and TARGET must be distinct node revisions.  * TARGET_PATH should correspond to TARGET's full path in its  * filesystem, and is used for reporting conflict location.  *  * SOURCE, TARGET, and ANCESTOR are generally directories; this  * function recursively merges the directories' contents.  If any are  * files, this function simply returns an error whenever SOURCE,  * TARGET, and ANCESTOR are all distinct node revisions.  *  * If there are differences between ANCESTOR and SOURCE that conflict  * with changes between ANCESTOR and TARGET, this function returns an  * SVN_ERR_FS_CONFLICT error, and updates CONFLICT_P to the name of the  * conflicting node in TARGET, with TARGET_PATH prepended as a path.  *  * If there are no conflicting differences, CONFLICT_P is updated to  * the empty string.  *  * CONFLICT_P must point to a valid svn_stringbuf_t.  *  * Do any necessary temporary allocation in POOL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|merge
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|conflict_p
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|dag_node_t
modifier|*
name|target
parameter_list|,
name|dag_node_t
modifier|*
name|source
parameter_list|,
name|dag_node_t
modifier|*
name|ancestor
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_id
parameter_list|,
name|apr_int64_t
modifier|*
name|mergeinfo_increment_out
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|source_id
decl_stmt|,
modifier|*
name|target_id
decl_stmt|,
modifier|*
name|ancestor_id
decl_stmt|;
name|apr_hash_t
modifier|*
name|s_entries
decl_stmt|,
modifier|*
name|t_entries
decl_stmt|,
modifier|*
name|a_entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|int
name|pred_count
decl_stmt|;
name|apr_int64_t
name|mergeinfo_increment
init|=
literal|0
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|trail
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* Make sure everyone comes from the same filesystem. */
name|fs
operator|=
name|svn_fs_base__dag_get_fs
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fs
operator|!=
name|svn_fs_base__dag_get_fs
argument_list|(
name|source
argument_list|)
operator|)
operator|||
operator|(
name|fs
operator|!=
name|svn_fs_base__dag_get_fs
argument_list|(
name|target
argument_list|)
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; ancestor, source, and target not all in same fs"
argument_list|)
argument_list|)
return|;
block|}
comment|/* We have the same fs, now check it. */
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|source_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|source
argument_list|)
expr_stmt|;
name|target_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|target
argument_list|)
expr_stmt|;
name|ancestor_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|ancestor
argument_list|)
expr_stmt|;
comment|/* It's improper to call this function with ancestor == target. */
if|if
condition|(
name|svn_fs_base__id_eq
argument_list|(
name|ancestor_id
argument_list|,
name|target_id
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_base__id_unparse
argument_list|(
name|target_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; target '%s' has id '%s', same as ancestor"
argument_list|)
argument_list|,
name|target_path
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
name|svn_stringbuf_setempty
argument_list|(
name|conflict_p
argument_list|)
expr_stmt|;
comment|/* Base cases:    * Either no change made in source, or same change as made in target.    * Both mean nothing to merge here.    */
if|if
condition|(
name|svn_fs_base__id_eq
argument_list|(
name|ancestor_id
argument_list|,
name|source_id
argument_list|)
operator|||
operator|(
name|svn_fs_base__id_eq
argument_list|(
name|source_id
argument_list|,
name|target_id
argument_list|)
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Else proceed, knowing all three are distinct node revisions.    *    * How to merge from this point:    *    * if (not all 3 are directories)    *   {    *     early exit with conflict;    *   }    *    * // Property changes may only be made to up-to-date    * // directories, because once the client commits the prop    * // change, it bumps the directory's revision, and therefore    * // must be able to depend on there being no other changes to    * // that directory in the repository.    * if (target's property list differs from ancestor's)    *    conflict;    *    * For each entry NAME in the directory ANCESTOR:    *    *   Let ANCESTOR-ENTRY, SOURCE-ENTRY, and TARGET-ENTRY be the IDs of    *   the name within ANCESTOR, SOURCE, and TARGET respectively.    *   (Possibly null if NAME does not exist in SOURCE or TARGET.)    *    *   If ANCESTOR-ENTRY == SOURCE-ENTRY, then:    *     No changes were made to this entry while the transaction was in    *     progress, so do nothing to the target.    *    *   Else if ANCESTOR-ENTRY == TARGET-ENTRY, then:    *     A change was made to this entry while the transaction was in    *     process, but the transaction did not touch this entry.  Replace    *     TARGET-ENTRY with SOURCE-ENTRY.    *    *   Else:    *     Changes were made to this entry both within the transaction and    *     to the repository while the transaction was in progress.  They    *     must be merged or declared to be in conflict.    *    *     If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a    *     double delete; flag a conflict.    *    *     If any of the three entries is of type file, declare a conflict.    *    *     If either SOURCE-ENTRY or TARGET-ENTRY is not a direct    *     modification of ANCESTOR-ENTRY (determine by comparing the    *     node-id fields), declare a conflict.  A replacement is    *     incompatible with a modification or other replacement--even    *     an identical replacement.    *    *     Direct modifications were made to the directory ANCESTOR-ENTRY    *     in both SOURCE and TARGET.  Recursively merge these    *     modifications.    *    * For each leftover entry NAME in the directory SOURCE:    *    *   If NAME exists in TARGET, declare a conflict.  Even if SOURCE and    *   TARGET are adding exactly the same thing, two additions are not    *   auto-mergeable with each other.    *    *   Add NAME to TARGET with the entry from SOURCE.    *    * Now that we are done merging the changes from SOURCE into the    * directory TARGET, update TARGET's predecessor to be SOURCE.    */
if|if
condition|(
operator|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|source
argument_list|)
operator|!=
name|svn_node_dir
operator|)
operator|||
operator|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|target
argument_list|)
operator|!=
name|svn_node_dir
operator|)
operator|||
operator|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|ancestor
argument_list|)
operator|!=
name|svn_node_dir
operator|)
condition|)
block|{
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
block|}
comment|/* Possible early merge failure: if target and ancestor have      different property lists, then the merge should fail.      Propchanges can *only* be committed on an up-to-date directory.      ### TODO: see issue #418 about the inelegance of this.       Another possible, similar, early merge failure: if source and      ancestor have different property lists (meaning someone else      changed directory properties while our commit transaction was      happening), the merge should fail.  See issue #2751.   */
block|{
name|node_revision_t
modifier|*
name|tgt_nr
decl_stmt|,
modifier|*
name|anc_nr
decl_stmt|,
modifier|*
name|src_nr
decl_stmt|;
comment|/* Get node revisions for our id's. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|tgt_nr
argument_list|,
name|fs
argument_list|,
name|target_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|anc_nr
argument_list|,
name|fs
argument_list|,
name|ancestor_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_node_revision
argument_list|(
operator|&
name|src_nr
argument_list|,
name|fs
argument_list|,
name|source_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now compare the prop-keys of the skels.  Note that just because        the keys are different -doesn't- mean the proplists have        different contents.  But merge() isn't concerned with contents;        it doesn't do a brute-force comparison on textual contents, so        it won't do that here either.  Checking to see if the propkey        atoms are `equal' is enough. */
if|if
condition|(
operator|!
name|svn_fs_base__same_keys
argument_list|(
name|tgt_nr
operator|->
name|prop_key
argument_list|,
name|anc_nr
operator|->
name|prop_key
argument_list|)
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
if|if
condition|(
operator|!
name|svn_fs_base__same_keys
argument_list|(
name|src_nr
operator|->
name|prop_key
argument_list|,
name|anc_nr
operator|->
name|prop_key
argument_list|)
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|target_path
argument_list|)
return|;
block|}
comment|/* ### todo: it would be more efficient to simply check for a NULL      entries hash where necessary below than to allocate an empty hash      here, but another day, another day... */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_dir_entries
argument_list|(
operator|&
name|s_entries
argument_list|,
name|source
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|s_entries
condition|)
name|s_entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_dir_entries
argument_list|(
operator|&
name|t_entries
argument_list|,
name|target
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|t_entries
condition|)
name|t_entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_dir_entries
argument_list|(
operator|&
name|a_entries
argument_list|,
name|ancestor
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|a_entries
condition|)
name|a_entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* for each entry E in a_entries... */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|a_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|,
modifier|*
name|a_entry
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* KEY will be the entry name in ancestor, VAL the dirent */
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|a_entry
operator|=
name|val
expr_stmt|;
name|s_entry
operator|=
name|apr_hash_get
argument_list|(
name|s_entries
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
name|t_entry
operator|=
name|apr_hash_get
argument_list|(
name|t_entries
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
comment|/* No changes were made to this entry while the transaction was          in progress, so do nothing to the target. */
if|if
condition|(
name|s_entry
operator|&&
name|svn_fs_base__id_eq
argument_list|(
name|a_entry
operator|->
name|id
argument_list|,
name|s_entry
operator|->
name|id
argument_list|)
condition|)
goto|goto
name|end
goto|;
comment|/* A change was made to this entry while the transaction was in          process, but the transaction did not touch this entry. */
elseif|else
if|if
condition|(
name|t_entry
operator|&&
name|svn_fs_base__id_eq
argument_list|(
name|a_entry
operator|->
name|id
argument_list|,
name|t_entry
operator|->
name|id
argument_list|)
condition|)
block|{
name|dag_node_t
modifier|*
name|t_ent_node
decl_stmt|;
name|apr_int64_t
name|mergeinfo_start
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|t_ent_node
argument_list|,
name|fs
argument_list|,
name|t_entry
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
name|NULL
argument_list|,
operator|&
name|mergeinfo_start
argument_list|,
name|t_ent_node
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|-=
name|mergeinfo_start
expr_stmt|;
if|if
condition|(
name|s_entry
condition|)
block|{
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|;
name|apr_int64_t
name|mergeinfo_end
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
name|NULL
argument_list|,
operator|&
name|mergeinfo_end
argument_list|,
name|s_ent_node
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|+=
name|mergeinfo_end
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_set_entry
argument_list|(
name|target
argument_list|,
name|key
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_delete
argument_list|(
name|target
argument_list|,
name|key
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Changes were made to this entry both within the transaction          and to the repository while the transaction was in progress.          They must be merged or declared to be in conflict. */
else|else
block|{
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|,
modifier|*
name|t_ent_node
decl_stmt|,
modifier|*
name|a_ent_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_tpath
decl_stmt|;
name|apr_int64_t
name|sub_mergeinfo_increment
decl_stmt|;
comment|/* If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a              double delete; if one of them is null, that's a delete versus              a modification. In any of these cases, flag a conflict. */
if|if
condition|(
name|s_entry
operator|==
name|NULL
operator|||
name|t_entry
operator|==
name|NULL
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* If either SOURCE-ENTRY or TARGET-ENTRY is not a direct              modification of ANCESTOR-ENTRY, declare a conflict. */
if|if
condition|(
name|strcmp
argument_list|(
name|svn_fs_base__id_node_id
argument_list|(
name|s_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_base__id_node_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|svn_fs_base__id_copy_id
argument_list|(
name|s_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_base__id_copy_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|svn_fs_base__id_node_id
argument_list|(
name|t_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_base__id_node_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
operator|||
name|strcmp
argument_list|(
name|svn_fs_base__id_copy_id
argument_list|(
name|t_entry
operator|->
name|id
argument_list|)
argument_list|,
name|svn_fs_base__id_copy_id
argument_list|(
name|a_entry
operator|->
name|id
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* Fetch the nodes for our entries. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|t_ent_node
argument_list|,
name|fs
argument_list|,
name|t_entry
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|a_ent_node
argument_list|,
name|fs
argument_list|,
name|a_entry
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If any of the three entries is of type file, flag a conflict. */
if|if
condition|(
operator|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|s_ent_node
argument_list|)
operator|==
name|svn_node_file
operator|)
operator|||
operator|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|t_ent_node
argument_list|)
operator|==
name|svn_node_file
operator|)
operator|||
operator|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|a_ent_node
argument_list|)
operator|==
name|svn_node_file
operator|)
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|a_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
comment|/* Direct modifications were made to the directory              ANCESTOR-ENTRY in both SOURCE and TARGET.  Recursively              merge these modifications. */
name|new_tpath
operator|=
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|merge
argument_list|(
name|conflict_p
argument_list|,
name|new_tpath
argument_list|,
name|t_ent_node
argument_list|,
name|s_ent_node
argument_list|,
name|a_ent_node
argument_list|,
name|txn_id
argument_list|,
operator|&
name|sub_mergeinfo_increment
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|+=
name|sub_mergeinfo_increment
expr_stmt|;
block|}
comment|/* We've taken care of any possible implications E could have.          Remove it from source_entries, so it's easy later to loop          over all the source entries that didn't exist in          ancestor_entries. */
name|end
label|:
name|apr_hash_set
argument_list|(
name|s_entries
argument_list|,
name|key
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* For each entry E in source but not in ancestor */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|s_entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|svn_fs_dirent_t
modifier|*
name|s_entry
decl_stmt|,
modifier|*
name|t_entry
decl_stmt|;
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|dag_node_t
modifier|*
name|s_ent_node
decl_stmt|;
name|apr_int64_t
name|mergeinfo_s
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|s_entry
operator|=
name|val
expr_stmt|;
name|t_entry
operator|=
name|apr_hash_get
argument_list|(
name|t_entries
argument_list|,
name|key
argument_list|,
name|klen
argument_list|)
expr_stmt|;
comment|/* If NAME exists in TARGET, declare a conflict. */
if|if
condition|(
name|t_entry
condition|)
return|return
name|conflict_err
argument_list|(
name|conflict_p
argument_list|,
name|svn_fspath__join
argument_list|(
name|target_path
argument_list|,
name|t_entry
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|s_ent_node
argument_list|,
name|fs
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
name|NULL
argument_list|,
operator|&
name|mergeinfo_s
argument_list|,
name|s_ent_node
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_increment
operator|+=
name|mergeinfo_s
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_set_entry
argument_list|(
name|target
argument_list|,
name|s_entry
operator|->
name|name
argument_list|,
name|s_entry
operator|->
name|id
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Now that TARGET has absorbed all of the history between ANCESTOR      and SOURCE, we can update its predecessor to point to SOURCE.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_predecessor_count
argument_list|(
operator|&
name|pred_count
argument_list|,
name|source
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|update_ancestry
argument_list|(
name|fs
argument_list|,
name|source_id
argument_list|,
name|target_id
argument_list|,
name|txn_id
argument_list|,
name|target_path
argument_list|,
name|pred_count
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tweak mergeinfo data if our format supports it. */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_adjust_mergeinfo_count
argument_list|(
name|target
argument_list|,
name|mergeinfo_increment
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mergeinfo_increment_out
condition|)
operator|*
name|mergeinfo_increment_out
operator|=
name|mergeinfo_increment
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|merge_args
block|{
comment|/* The ancestor for the merge.  If this is null, then TXN's base is      used as the ancestor for the merge. */
name|dag_node_t
modifier|*
name|ancestor_node
decl_stmt|;
comment|/* This is the SOURCE node for the merge.  It may not be null. */
name|dag_node_t
modifier|*
name|source_node
decl_stmt|;
comment|/* This is the TARGET of the merge.  It may not be null.  If      ancestor_node above is null, then this txn's base is used as the      ancestor for the merge. */
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
comment|/* If a conflict results, this is updated to the path in the txn that      conflicted.  It must point to a valid svn_stringbuf_t before calling      svn_fs_base__retry_txn, as this determines the pool used to allocate any      required memory. */
name|svn_stringbuf_t
modifier|*
name|conflict
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Merge changes between an ancestor and BATON->source_node into    BATON->txn.  The ancestor is either BATON->ancestor_node, or if    that is null, BATON->txn's base node.     If the merge is successful, BATON->txn's base will become    BATON->source_node, and its root node will have a new ID, a    successor of BATON->source_node. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_merge
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|merge_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|source_node
decl_stmt|,
modifier|*
name|txn_root_node
decl_stmt|,
modifier|*
name|ancestor_node
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|source_id
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|args
operator|->
name|txn
operator|->
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|args
operator|->
name|txn
operator|->
name|id
decl_stmt|;
name|source_node
operator|=
name|args
operator|->
name|source_node
expr_stmt|;
name|ancestor_node
operator|=
name|args
operator|->
name|ancestor_node
expr_stmt|;
name|source_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|source_node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_txn_root
argument_list|(
operator|&
name|txn_root_node
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ancestor_node
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_txn_base_root
argument_list|(
operator|&
name|ancestor_node
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|svn_fs_base__id_eq
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|ancestor_node
argument_list|)
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|txn_root_node
argument_list|)
argument_list|)
condition|)
block|{
comment|/* If no changes have been made in TXN since its current base,          then it can't conflict with any changes since that base.  So          we just set *both* its base and root to source, making TXN          in effect a repeat of source. */
comment|/* ### kff todo: this would, of course, be a mighty silly thing          for the caller to do, and we might want to consider whether          this response is really appropriate. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__set_txn_base
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|source_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__set_txn_root
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|source_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|pred_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|merge
argument_list|(
name|args
operator|->
name|conflict
argument_list|,
literal|"/"
argument_list|,
name|txn_root_node
argument_list|,
name|source_node
argument_list|,
name|ancestor_node
argument_list|,
name|txn_id
argument_list|,
name|NULL
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_predecessor_count
argument_list|(
operator|&
name|pred_count
argument_list|,
name|source_node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* After the merge, txn's new "ancestor" is now really the node          at source_id, so record that fact.  Think of this as          ratcheting the txn forward in time, so it can't backslide and          forget the merging work that's already been done. */
name|SVN_ERR
argument_list|(
name|update_ancestry
argument_list|(
name|fs
argument_list|,
name|source_id
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|txn_root_node
argument_list|)
argument_list|,
name|txn_id
argument_list|,
literal|"/"
argument_list|,
name|pred_count
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__set_txn_base
argument_list|(
name|fs
argument_list|,
name|txn_id
argument_list|,
name|source_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Verify that there are registered with TRAIL->fs all the locks    necessary to permit all the changes associated with TXN_NAME. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_locks
parameter_list|(
specifier|const
name|char
modifier|*
name|txn_name
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|changes
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changed_paths
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|last_recursed
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Fetch the changes for this transaction. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__changes_fetch
argument_list|(
operator|&
name|changes
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|txn_name
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make an array of the changed paths, and sort them depth-first-ily.  */
name|changed_paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|apr_hash_count
argument_list|(
name|changes
argument_list|)
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|changed_paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|key
expr_stmt|;
block|}
name|qsort
argument_list|(
name|changed_paths
operator|->
name|elts
argument_list|,
name|changed_paths
operator|->
name|nelts
argument_list|,
name|changed_paths
operator|->
name|elt_size
argument_list|,
name|svn_sort_compare_paths
argument_list|)
expr_stmt|;
comment|/* Now, traverse the array of changed paths, verify locks.  Note      that if we need to do a recursive verification a path, we'll skip      over children of that path when we get to them. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|changed_paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|change
decl_stmt|;
name|svn_boolean_t
name|recurse
init|=
name|TRUE
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|changed_paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* If this path has already been verified as part of a recursive          check of one of its parents, no need to do it again.  */
if|if
condition|(
name|last_recursed
operator|&&
name|svn_fspath__skip_ancestor
argument_list|(
name|last_recursed
operator|->
name|data
argument_list|,
name|path
argument_list|)
condition|)
continue|continue;
comment|/* Fetch the change associated with our path.  */
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|changes
argument_list|,
name|path
argument_list|)
expr_stmt|;
comment|/* What does it mean to succeed at lock verification for a given          path?  For an existing file or directory getting modified          (text, props), it means we hold the lock on the file or          directory.  For paths being added or removed, we need to hold          the locks for that path and any children of that path.           WHEW!  We have no reliable way to determine the node kind of          deleted items, but fortunately we are going to do a recursive          check on deleted paths regardless of their kind.  */
if|if
condition|(
name|change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_modify
condition|)
name|recurse
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|recurse
argument_list|,
name|trail
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we just did a recursive check, remember the path we          checked (so children can be skipped).  */
if|if
condition|(
name|recurse
condition|)
block|{
if|if
condition|(
operator|!
name|last_recursed
condition|)
name|last_recursed
operator|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_stringbuf_set
argument_list|(
name|last_recursed
argument_list|,
name|path
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|commit_args
block|{
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_revnum_t
name|new_rev
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Commit ARGS->txn, setting ARGS->new_rev to the resulting new  * revision, if ARGS->txn is up-to-date with respect to the repository.  *  * Up-to-date means that ARGS->txn's base root is the same as the root  * of the youngest revision.  If ARGS->txn is not up-to-date, the  * error SVN_ERR_FS_TXN_OUT_OF_DATE is returned, and the commit fails: no  * new revision is created, and ARGS->new_rev is not touched.  *  * If the commit succeeds, ARGS->txn is destroyed.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_commit
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|commit_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
init|=
name|args
operator|->
name|txn
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_name
init|=
name|txn
operator|->
name|id
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|y_rev_root_id
decl_stmt|;
name|dag_node_t
modifier|*
name|txn_base_root_node
decl_stmt|;
comment|/* Getting the youngest revision locks the revisions table until      this trail is done. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the root of the youngest revision is the same as txn's base,      then no further merging is necessary and we can commit. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rev_get_root
argument_list|(
operator|&
name|y_rev_root_id
argument_list|,
name|fs
argument_list|,
name|youngest_rev
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_txn_base_root
argument_list|(
operator|&
name|txn_base_root_node
argument_list|,
name|fs
argument_list|,
name|txn_name
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### kff todo: it seems weird to grab the ID for one, and the node      for the other.  We can certainly do the comparison we need, but      it would be nice to grab the same type of information from the      start, instead of having to transform one of them. */
if|if
condition|(
operator|!
name|svn_fs_base__id_eq
argument_list|(
name|y_rev_root_id
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|txn_base_root_node
argument_list|)
argument_list|)
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_base__id_unparse
argument_list|(
name|y_rev_root_id
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_TXN_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Transaction '%s' out-of-date with respect to revision '%s'"
argument_list|)
argument_list|,
name|txn_name
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Locks may have been added (or stolen) between the calling of      previous svn_fs.h functions and svn_fs_commit_txn(), so we need      to re-examine every changed-path in the txn and re-verify all      discovered locks. */
name|SVN_ERR
argument_list|(
name|verify_locks
argument_list|(
name|txn_name
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Else, commit the txn. */
return|return
name|svn_fs_base__dag_commit_txn
argument_list|(
operator|&
operator|(
name|args
operator|->
name|new_rev
operator|)
argument_list|,
name|txn
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Note:  it is acceptable for this function to call back into    top-level FS interfaces because it does not itself use trails.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__commit_txn
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_revnum_t
modifier|*
name|new_rev
parameter_list|,
name|svn_fs_txn_t
modifier|*
name|txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* How do commits work in Subversion?    *    * When you're ready to commit, here's what you have:    *    *    1. A transaction, with a mutable tree hanging off it.    *    2. A base revision, against which TXN_TREE was made.    *    3. A latest revision, which may be newer than the base rev.    *    * The problem is that if latest != base, then one can't simply    * attach the txn root as the root of the new revision, because that    * would lose all the changes between base and latest.  It is also    * not acceptable to insist that base == latest; in a busy    * repository, commits happen too fast to insist that everyone keep    * their entire tree up-to-date at all times.  Non-overlapping    * changes should not interfere with each other.    *    * The solution is to merge the changes between base and latest into    * the txn tree [see the function merge()].  The txn tree is the    * only one of the three trees that is mutable, so it has to be the    * one to adjust.    *    * You might have to adjust it more than once, if a new latest    * revision gets committed while you were merging in the previous    * one.  For example:    *    *    1. Jane starts txn T, based at revision 6.    *    2. Someone commits (or already committed) revision 7.    *    3. Jane's starts merging the changes between 6 and 7 into T.    *    4. Meanwhile, someone commits revision 8.    *    5. Jane finishes the 6-->7 merge.  T could now be committed    *       against a latest revision of 7, if only that were still the    *       latest.  Unfortunately, 8 is now the latest, so...    *    6. Jane starts merging the changes between 7 and 8 into T.    *    7. Meanwhile, no one commits any new revisions.  Whew.    *    8. Jane commits T, creating revision 9, whose tree is exactly    *       T's tree, except immutable now.    *    * Lather, rinse, repeat.    */
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|txn
operator|->
name|fs
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Initialize output params. */
operator|*
name|new_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
if|if
condition|(
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
literal|1729
condition|)
block|{
name|struct
name|get_root_args
name|get_root_args
decl_stmt|;
name|struct
name|merge_args
name|merge_args
decl_stmt|;
name|struct
name|commit_args
name|commit_args
decl_stmt|;
name|svn_revnum_t
name|youngish_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|youngish_root
decl_stmt|;
name|dag_node_t
modifier|*
name|youngish_root_node
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* Get the *current* youngest revision, in one short-lived          Berkeley transaction.  (We don't want the revisions table          locked while we do the main merge.)  We call it "youngish"          because new revisions might get committed after we've          obtained it. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__youngest_rev
argument_list|(
operator|&
name|youngish_rev
argument_list|,
name|fs
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__revision_root
argument_list|(
operator|&
name|youngish_root
argument_list|,
name|fs
argument_list|,
name|youngish_rev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the dag node for the youngest revision, also in one          Berkeley transaction.  Later we'll use it as the SOURCE          argument to a merge, and if the merge succeeds, this youngest          root node will become the new base root for the svn txn that          was the target of the merge (but note that the youngest rev          may have changed by then -- that's why we're careful to get          this root in its own bdb txn here). */
name|get_root_args
operator|.
name|root
operator|=
name|youngish_root
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_get_root
argument_list|,
operator|&
name|get_root_args
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|youngish_root_node
operator|=
name|get_root_args
operator|.
name|node
expr_stmt|;
comment|/* Try to merge.  If the merge succeeds, the base root node of          TARGET's txn will become the same as youngish_root_node, so          any future merges will only be between that node and whatever          the root node of the youngest rev is by then. */
name|merge_args
operator|.
name|ancestor_node
operator|=
name|NULL
expr_stmt|;
name|merge_args
operator|.
name|source_node
operator|=
name|youngish_root_node
expr_stmt|;
name|merge_args
operator|.
name|txn
operator|=
name|txn
expr_stmt|;
name|merge_args
operator|.
name|conflict
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* use pool */
name|err
operator|=
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_merge
argument_list|,
operator|&
name|merge_args
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CONFLICT
operator|)
operator|&&
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|merge_args
operator|.
name|conflict
operator|->
name|data
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* Try to commit. */
name|commit_args
operator|.
name|txn
operator|=
name|txn
expr_stmt|;
name|err
operator|=
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_commit
argument_list|,
operator|&
name|commit_args
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_TXN_OUT_OF_DATE
operator|)
condition|)
block|{
comment|/* Did someone else finish committing a new revision while we              were in mid-merge or mid-commit?  If so, we'll need to              loop again to merge the new changes in, then try to              commit again.  Or if that's not what happened, then just              return the error. */
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
init|=
name|svn_fs_base__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err2
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err2
argument_list|)
return|;
comment|/* err2 is bad,                                                  it should not occur */
block|}
elseif|else
if|if
condition|(
name|youngest_rev
operator|==
name|youngish_rev
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
else|else
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Set the return value -- our brand spankin' new revision! */
operator|*
name|new_rev
operator|=
name|commit_args
operator|.
name|new_rev
expr_stmt|;
break|break;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Note:  it is acceptable for this function to call back into    public FS API interfaces because it does not itself use trails.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_merge
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|conflict_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|ancestor_root
parameter_list|,
specifier|const
name|char
modifier|*
name|ancestor_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|dag_node_t
modifier|*
name|source
decl_stmt|,
modifier|*
name|ancestor
decl_stmt|;
name|struct
name|get_root_args
name|get_root_args
decl_stmt|;
name|struct
name|merge_args
name|merge_args
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
if|if
condition|(
operator|!
name|target_root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|target_root
argument_list|)
return|;
comment|/* Paranoia. */
name|fs
operator|=
name|ancestor_root
operator|->
name|fs
expr_stmt|;
if|if
condition|(
operator|(
name|source_root
operator|->
name|fs
operator|!=
name|fs
operator|)
operator|||
operator|(
name|target_root
operator|->
name|fs
operator|!=
name|fs
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Bad merge; ancestor, source, and target not all in same fs"
argument_list|)
argument_list|)
return|;
block|}
comment|/* ### kff todo: is there any compelling reason to get the nodes in      one db transaction?  Right now we don't; txn_body_get_root() gets      one node at a time.  This will probably need to change:       Jim Blandy<jimb@zwingli.cygnus.com> writes:> svn_fs_merge needs to be a single transaction, to protect it against> people deleting parents of nodes it's working on, etc.   */
comment|/* Get the ancestor node. */
name|get_root_args
operator|.
name|root
operator|=
name|ancestor_root
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_get_root
argument_list|,
operator|&
name|get_root_args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|ancestor
operator|=
name|get_root_args
operator|.
name|node
expr_stmt|;
comment|/* Get the source node. */
name|get_root_args
operator|.
name|root
operator|=
name|source_root
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_get_root
argument_list|,
operator|&
name|get_root_args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|source
operator|=
name|get_root_args
operator|.
name|node
expr_stmt|;
comment|/* Open a txn for the txn root into which we're merging. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|target_root
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Merge changes between ANCESTOR and SOURCE into TXN. */
name|merge_args
operator|.
name|source_node
operator|=
name|source
expr_stmt|;
name|merge_args
operator|.
name|ancestor_node
operator|=
name|ancestor
expr_stmt|;
name|merge_args
operator|.
name|txn
operator|=
name|txn
expr_stmt|;
name|merge_args
operator|.
name|conflict
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_merge
argument_list|,
operator|&
name|merge_args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_CONFLICT
operator|)
operator|&&
name|conflict_p
condition|)
operator|*
name|conflict_p
operator|=
name|merge_args
operator|.
name|conflict
operator|->
name|data
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|rev_get_txn_id_args
block|{
specifier|const
name|char
modifier|*
modifier|*
name|txn_id
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_rev_get_txn_id
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|rev_get_txn_id_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
return|return
name|svn_fs_base__rev_get_txn_id
argument_list|(
name|args
operator|->
name|txn_id
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|revision
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__deltify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
name|struct
name|rev_get_txn_id_args
name|args
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_MISCELLANY_FORMAT
condition|)
block|{
specifier|const
name|char
modifier|*
name|val
decl_stmt|;
name|svn_revnum_t
name|forward_delta_rev
init|=
literal|0
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__miscellaneous_get
argument_list|(
operator|&
name|val
argument_list|,
name|fs
argument_list|,
name|SVN_FS_BASE__MISC_FORWARD_DELTA_UPGRADE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
name|SVN_ERR
argument_list|(
name|svn_revnum_parse
argument_list|(
operator|&
name|forward_delta_rev
argument_list|,
name|val
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### FIXME:  Unnecessarily harsh requirement? (cmpilato). */
if|if
condition|(
name|revision
operator|<=
name|forward_delta_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot deltify revisions prior to r%ld"
argument_list|)
argument_list|,
name|forward_delta_rev
operator|+
literal|1
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_fs_base__revision_root
argument_list|(
operator|&
name|root
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|txn_id
operator|=
operator|&
name|txn_id
expr_stmt|;
name|args
operator|.
name|revision
operator|=
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_rev_get_txn_id
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|deltify_mutable
argument_list|(
name|fs
argument_list|,
name|root
argument_list|,
literal|"/"
argument_list|,
name|NULL
argument_list|,
name|svn_node_dir
argument_list|,
name|txn_id
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Modifying directories */
end_comment

begin_struct
struct|struct
name|make_dir_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_make_dir
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|make_dir_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
init|=
name|args
operator|->
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|args
operator|->
name|path
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|sub_dir
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_last_optional
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's already a sub-directory by that name, complain.  This      also catches the case of trying to make a subdirectory named `/'.  */
if|if
condition|(
name|parent_path
operator|->
name|node
condition|)
return|return
name|SVN_FS__ALREADY_EXISTS
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Check to see if some lock is 'reserving' a file-path or dir-path      at that location, or even some child-path;  if so, check that we      can use it. */
if|if
condition|(
name|args
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create the subdirectory.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_make_dir
argument_list|(
operator|&
name|sub_dir
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|sub_dir
argument_list|)
argument_list|,
name|svn_fs_path_change_add
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_make_dir
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|make_dir_args
name|args
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|root
argument_list|)
return|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_make_dir
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|delete_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If this returns SVN_ERR_FS_NO_SUCH_ENTRY, it means that the    basename of PATH is missing from its parent, that is, the final    target of the deletion is missing.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_delete
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|delete_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
init|=
name|args
operator|->
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|args
operator|->
name|path
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|trail
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|!
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|root
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't remove the root of the filesystem.  */
if|if
condition|(
operator|!
name|parent_path
operator|->
name|parent
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_ROOT_DIR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The root directory cannot be deleted"
argument_list|)
argument_list|)
return|;
comment|/* Check to see if path (or any child thereof) is locked; if so,      check that we can use the existing lock(s). */
if|if
condition|(
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make the parent directory mutable. */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Decrement mergeinfo counts on the parents of this node by the      count it previously carried, if our format supports it. */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
condition|)
block|{
name|apr_int64_t
name|mergeinfo_count
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
name|NULL
argument_list|,
operator|&
name|mergeinfo_count
argument_list|,
name|parent_path
operator|->
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|adjust_parent_mergeinfo_counts
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
operator|-
name|mergeinfo_count
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do the deletion. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_delete
argument_list|(
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_delete
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_delete_node
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|delete_args
name|args
decl_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_delete
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|copy_args
block|{
name|svn_fs_root_t
modifier|*
name|from_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|to_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_path
decl_stmt|;
name|svn_boolean_t
name|preserve_history
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_copy
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|copy_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|from_root
init|=
name|args
operator|->
name|from_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|from_path
init|=
name|args
operator|->
name|from_path
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|to_root
init|=
name|args
operator|->
name|to_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|to_path
init|=
name|args
operator|->
name|to_path
decl_stmt|;
name|dag_node_t
modifier|*
name|from_node
decl_stmt|;
name|parent_path_t
modifier|*
name|to_parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|to_root
operator|->
name|txn
decl_stmt|;
comment|/* Get the NODE for FROM_PATH in FROM_ROOT.*/
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|from_node
argument_list|,
name|from_root
argument_list|,
name|from_path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Build up the parent path from TO_PATH in TO_ROOT.  If the last      component does not exist, it's not that big a deal.  We'll just      make one there. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|to_parent_path
argument_list|,
name|to_root
argument_list|,
name|to_path
argument_list|,
name|open_path_last_optional
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if to-path (or any child thereof) is locked, or at      least 'reserved', whether it exists or not; if so, check that we      can use the existing lock(s). */
if|if
condition|(
name|to_root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|to_path
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* If the destination node already exists as the same node as the      source (in other words, this operation would result in nothing      happening at all), just do nothing an return successfully,      proud that you saved yourself from a tiresome task. */
if|if
condition|(
operator|(
name|to_parent_path
operator|->
name|node
operator|)
operator|&&
operator|(
name|svn_fs_base__id_compare
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|from_node
argument_list|)
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|to_parent_path
operator|->
name|node
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|from_root
operator|->
name|is_txn_root
condition|)
block|{
name|svn_fs_path_change_kind_t
name|kind
decl_stmt|;
name|dag_node_t
modifier|*
name|new_node
decl_stmt|;
name|apr_int64_t
name|old_mergeinfo_count
init|=
literal|0
decl_stmt|,
name|mergeinfo_count
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|trail
operator|->
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* If TO_PATH already existed prior to the copy, note that this          operation is a replacement, not an addition. */
if|if
condition|(
name|to_parent_path
operator|->
name|node
condition|)
name|kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
else|else
name|kind
operator|=
name|svn_fs_path_change_add
expr_stmt|;
comment|/* Make sure the target node's parents are mutable.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|to_root
argument_list|,
name|to_parent_path
operator|->
name|parent
argument_list|,
name|to_path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If this is a replacement operation, we need to know the old          node's mergeinfo count. */
if|if
condition|(
name|to_parent_path
operator|->
name|node
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
name|NULL
argument_list|,
operator|&
name|old_mergeinfo_count
argument_list|,
name|to_parent_path
operator|->
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the copy. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_copy
argument_list|(
name|to_parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|to_parent_path
operator|->
name|entry
argument_list|,
name|from_node
argument_list|,
name|args
operator|->
name|preserve_history
argument_list|,
name|from_root
operator|->
name|rev
argument_list|,
name|from_path
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Adjust the mergeinfo counts of the destination's parents if          our format supports it. */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
name|NULL
argument_list|,
operator|&
name|mergeinfo_count
argument_list|,
name|from_node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|adjust_parent_mergeinfo_counts
argument_list|(
name|to_parent_path
operator|->
name|parent
argument_list|,
name|mergeinfo_count
operator|-
name|old_mergeinfo_count
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Make a record of this modification in the changes table. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|new_node
argument_list|,
name|to_root
argument_list|,
name|to_path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_change
argument_list|(
name|to_root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|to_path
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|new_node
argument_list|)
argument_list|,
name|kind
argument_list|,
name|FALSE
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* See IZ Issue #436 */
comment|/* Copying from transaction roots not currently available.           ### cmpilato todo someday: make this not so. :-) Note that          when copying from mutable trees, you have to make sure that          you aren't creating a cyclic graph filesystem, and a simple          referencing operation won't cut it.  Currently, we should not          be able to reach this clause, and the interface reports that          this only works from immutable trees anyway, but JimB has          stated that this requirement need not be necessary in the          future. */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *SAME_P to TRUE if FS1 and FS2 have the same UUID, else set to FALSE.    Use POOL for temporary allocation only.    Note: this code is duplicated between libsvn_fs_fs and libsvn_fs_base. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fs_same_p
parameter_list|(
name|svn_boolean_t
modifier|*
name|same_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs1
parameter_list|,
name|svn_fs_t
modifier|*
name|fs2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
operator|*
name|same_p
operator|=
operator|!
name|strcmp
argument_list|(
name|fs1
operator|->
name|uuid
argument_list|,
name|fs2
operator|->
name|uuid
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy the node at FROM_PATH under FROM_ROOT to TO_PATH under    TO_ROOT.  If PRESERVE_HISTORY is set, then the copy is recorded in    the copies table.  Perform temporary allocations in POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_helper
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|svn_boolean_t
name|preserve_history
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|copy_args
name|args
decl_stmt|;
name|svn_boolean_t
name|same_p
decl_stmt|;
comment|/* Use an error check, not an assert, because even the caller cannot      guarantee that a filesystem's UUID has not changed "on the fly". */
name|SVN_ERR
argument_list|(
name|fs_same_p
argument_list|(
operator|&
name|same_p
argument_list|,
name|from_root
operator|->
name|fs
argument_list|,
name|to_root
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|same_p
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot copy between two different filesystems ('%s' and '%s')"
argument_list|)
argument_list|,
name|from_root
operator|->
name|fs
operator|->
name|path
argument_list|,
name|to_root
operator|->
name|fs
operator|->
name|path
argument_list|)
return|;
if|if
condition|(
operator|!
name|to_root
operator|->
name|is_txn_root
condition|)
return|return
name|SVN_FS__NOT_TXN
argument_list|(
name|to_root
argument_list|)
return|;
if|if
condition|(
name|from_root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Copy from mutable tree not currently supported"
argument_list|)
argument_list|)
return|;
name|args
operator|.
name|from_root
operator|=
name|from_root
expr_stmt|;
name|args
operator|.
name|from_path
operator|=
name|from_path
expr_stmt|;
name|args
operator|.
name|to_root
operator|=
name|to_root
expr_stmt|;
name|args
operator|.
name|to_path
operator|=
name|to_path
expr_stmt|;
name|args
operator|.
name|preserve_history
operator|=
name|preserve_history
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|to_root
operator|->
name|fs
argument_list|,
name|txn_body_copy
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_copy
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
specifier|const
name|char
modifier|*
name|from_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|to_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|copy_helper
argument_list|(
name|from_root
argument_list|,
name|from_path
argument_list|,
name|to_root
argument_list|,
name|to_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_revision_link
parameter_list|(
name|svn_fs_root_t
modifier|*
name|from_root
parameter_list|,
name|svn_fs_root_t
modifier|*
name|to_root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|copy_helper
argument_list|(
name|from_root
argument_list|,
name|path
argument_list|,
name|to_root
argument_list|,
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|copied_from_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
comment|/* Root for the node whose ancestry we seek. */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Path for the node whose ancestry we seek. */
name|svn_revnum_t
name|result_rev
decl_stmt|;
comment|/* Revision, if any, of the ancestor. */
specifier|const
name|char
modifier|*
name|result_path
decl_stmt|;
comment|/* Path, if any, of the ancestor. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Allocate `result_path' here. */
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_copied_from
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|copied_from_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|,
modifier|*
name|pred_id
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|args
operator|->
name|root
operator|->
name|fs
decl_stmt|;
comment|/* Clear the return variables. */
name|args
operator|->
name|result_path
operator|=
name|NULL
expr_stmt|;
name|args
operator|->
name|result_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Fetch the NODE in question. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
expr_stmt|;
comment|/* Check the node's predecessor-ID.  If it doesn't have one, it      isn't a copy. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pred_id
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If NODE's copy-ID is the same as that of its predecessor... */
if|if
condition|(
name|svn_fs_base__key_compare
argument_list|(
name|svn_fs_base__id_copy_id
argument_list|(
name|node_id
argument_list|)
argument_list|,
name|svn_fs_base__id_copy_id
argument_list|(
name|pred_id
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* ... then NODE was either the target of a copy operation,          a copied subtree item.  We examine the actual copy record          to determine which is the case.  */
name|copy_t
modifier|*
name|copy
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_copy
argument_list|(
operator|&
name|copy
argument_list|,
name|fs
argument_list|,
name|svn_fs_base__id_copy_id
argument_list|(
name|node_id
argument_list|)
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|copy
operator|->
name|kind
operator|==
name|copy_kind_real
operator|)
operator|&&
name|svn_fs_base__id_eq
argument_list|(
name|copy
operator|->
name|dst_noderev_id
argument_list|,
name|node_id
argument_list|)
condition|)
block|{
name|args
operator|->
name|result_path
operator|=
name|copy
operator|->
name|src_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__txn_get_revision
argument_list|(
operator|&
operator|(
name|args
operator|->
name|result_rev
operator|)
argument_list|,
name|fs
argument_list|,
name|copy
operator|->
name|src_txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_copied_from
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|copied_from_args
name|args
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|args
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_copied_from
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rev_p
operator|=
name|args
operator|.
name|result_rev
expr_stmt|;
operator|*
name|path_p
operator|=
name|args
operator|.
name|result_path
condition|?
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|args
operator|.
name|result_path
argument_list|)
else|:
name|NULL
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Files.  */
end_comment

begin_struct
struct|struct
name|make_file_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_make_file
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|make_file_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
init|=
name|args
operator|->
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|args
operator|->
name|path
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|child
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|root
operator|->
name|txn
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|open_path_last_optional
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If there's already a file by that name, complain.      This also catches the case of trying to make a file named `/'.  */
if|if
condition|(
name|parent_path
operator|->
name|node
condition|)
return|return
name|SVN_FS__ALREADY_EXISTS
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Check to see if some lock is 'reserving' a file-path or dir-path      at that location, or even some child-path;  if so, check that we      can use it. */
if|if
condition|(
name|args
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|path
argument_list|,
name|TRUE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Create the file.  */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|root
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_make_file
argument_list|(
operator|&
name|child
argument_list|,
name|parent_path
operator|->
name|parent
operator|->
name|node
argument_list|,
name|parent_path_path
argument_list|(
name|parent_path
operator|->
name|parent
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|,
name|parent_path
operator|->
name|entry
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_id
argument_list|,
name|path
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|child
argument_list|)
argument_list|,
name|svn_fs_path_change_add
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_make_file
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|make_file_args
name|args
decl_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_make_file
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|file_length_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_filesize_t
name|length
decl_stmt|;
comment|/* OUT parameter */
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_file_length
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|file_length_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|file
decl_stmt|;
comment|/* First create a dag_node_t from the root/path pair. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|file
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now fetch its length */
return|return
name|svn_fs_base__dag_file_length
argument_list|(
operator|&
name|args
operator|->
name|length
argument_list|,
name|file
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_file_length
parameter_list|(
name|svn_filesize_t
modifier|*
name|length_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_length_args
name|args
decl_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_file_length
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|length_p
operator|=
name|args
operator|.
name|length
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|file_checksum_args
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_checksum_kind_t
name|kind
decl_stmt|;
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
decl_stmt|;
comment|/* OUT parameter */
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_file_checksum
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|file_checksum_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|file
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|file
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__dag_file_checksum
argument_list|(
name|args
operator|->
name|checksum
argument_list|,
name|args
operator|->
name|kind
argument_list|,
name|file
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_file_checksum
parameter_list|(
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_checksum_kind_t
name|kind
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_checksum_args
name|args
decl_stmt|;
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|args
operator|.
name|kind
operator|=
name|kind
expr_stmt|;
name|args
operator|.
name|checksum
operator|=
name|checksum
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_file_checksum
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
operator|*
name|checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- Machinery for svn_fs_file_contents() ---  */
end_comment

begin_comment
comment|/* Local baton type for txn_body_get_file_contents. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|file_contents_baton_t
block|{
comment|/* The file we want to read. */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The dag_node that will be made from the above. */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* The pool in which `file_stream' (below) is allocated. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The readable file stream that will be made from the      dag_node. (And returned to the caller.) */
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
block|}
name|file_contents_baton_t
typedef|;
end_typedef

begin_comment
comment|/* Main body of svn_fs_file_contents;  converts a root/path pair into    a readable file stream (in the context of a db txn). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_file_contents
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|file_contents_baton_t
modifier|*
name|fb
init|=
operator|(
name|file_contents_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
comment|/* First create a dag_node_t from the root/path pair. */
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
operator|(
name|fb
operator|->
name|node
operator|)
argument_list|,
name|fb
operator|->
name|root
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Then create a readable stream from the dag_node_t. */
return|return
name|svn_fs_base__dag_get_contents
argument_list|(
operator|&
operator|(
name|fb
operator|->
name|file_stream
operator|)
argument_list|,
name|fb
operator|->
name|node
argument_list|,
name|trail
argument_list|,
name|fb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_file_contents
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|file_contents_baton_t
modifier|*
name|fb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
name|fb
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|fb
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|fb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Create the readable stream in the context of a db txn.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_get_file_contents
argument_list|,
name|fb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents
operator|=
name|fb
operator|->
name|file_stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_file_contents() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_apply_textdelta() ---  */
end_comment

begin_comment
comment|/* Local baton type for all the helper functions below. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|txdelta_baton_t
block|{
comment|/* This is the custom-built window consumer given to us by the delta      library;  it uniquely knows how to read data from our designated      "source" stream, interpret the window, and write data to our      designated "target" stream (in this case, our repos file.) */
name|svn_txdelta_window_handler_t
name|interpreter
decl_stmt|;
name|void
modifier|*
name|interpreter_baton
decl_stmt|;
comment|/* The original file info */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Derived from the file info */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_stream_t
modifier|*
name|source_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|target_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|string_stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|target_string
decl_stmt|;
comment|/* Checksums for the base text against which a delta is to be      applied, and for the resultant fulltext, respectively.  Either or      both may be null, in which case ignored. */
name|svn_checksum_t
modifier|*
name|base_checksum
decl_stmt|;
name|svn_checksum_t
modifier|*
name|result_checksum
decl_stmt|;
comment|/* Pool used by db txns */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|txdelta_baton_t
typedef|;
end_typedef

begin_comment
comment|/* A trail-ready wrapper around svn_fs_base__dag_finalize_edits.  * This closes BATON->target_stream.  *  * Note: If you're confused about how this function relates to another  * of similar name, think of it this way:  *  * svn_fs_apply_textdelta() ==> ... ==> txn_body_txdelta_finalize_edits()  * svn_fs_apply_text()      ==> ... ==> txn_body_fulltext_finalize_edits()  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_txdelta_finalize_edits
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_finalize_edits
argument_list|(
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|result_checksum
argument_list|,
name|tb
operator|->
name|root
operator|->
name|txn
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|tb
operator|->
name|root
operator|->
name|txn
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|tb
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ### see comment in window_consumer() regarding this function. */
end_comment

begin_comment
comment|/* Helper function of generic type `svn_write_fn_t'.  Implements a    writable stream which appends to an svn_stringbuf_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_to_string
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|tb
operator|->
name|target_string
argument_list|,
name|data
argument_list|,
operator|*
name|len
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* The main window handler returned by svn_fs_apply_textdelta. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_consumer
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
comment|/* Send the window right through to the custom window interpreter.      In theory, the interpreter will then write more data to      cb->target_string. */
name|SVN_ERR
argument_list|(
name|tb
operator|->
name|interpreter
argument_list|(
name|window
argument_list|,
name|tb
operator|->
name|interpreter_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### the write_to_string() callback for the txdelta's output stream      ### should be doing all the flush determination logic, not here.      ### in a drastic case, a window could generate a LOT more than the      ### maximum buffer size. we want to flush to the underlying target      ### stream much sooner (e.g. also in a streamy fashion). also, by      ### moving this logic inside the stream, the stream becomes nice      ### and encapsulated: it holds all the logic about buffering and      ### flushing.      ###      ### further: I believe the buffering should be removed from tree.c      ### the buffering should go into the target_stream itself, which      ### is defined by reps-string.c. Specifically, I think the      ### rep_write_contents() function will handle the buffering and      ### the spill to the underlying DB. by locating it there, then      ### anybody who gets a writable stream for FS content can take      ### advantage of the buffering capability. this will be important      ### when we export an FS API function for writing a fulltext into      ### the FS, rather than forcing that fulltext thru apply_textdelta.   */
comment|/* Check to see if we need to purge the portion of the contents that      have been written thus far. */
if|if
condition|(
operator|(
operator|!
name|window
operator|)
operator|||
operator|(
name|tb
operator|->
name|target_string
operator|->
name|len
operator|>
name|WRITE_BUFFER_SIZE
operator|)
condition|)
block|{
name|apr_size_t
name|len
init|=
name|tb
operator|->
name|target_string
operator|->
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|tb
operator|->
name|target_stream
argument_list|,
name|tb
operator|->
name|target_string
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_setempty
argument_list|(
name|tb
operator|->
name|target_string
argument_list|)
expr_stmt|;
block|}
comment|/* Is the window NULL?  If so, we're done. */
if|if
condition|(
operator|!
name|window
condition|)
block|{
comment|/* Close the internal-use stream.  ### This used to be inside of          txn_body_fulltext_finalize_edits(), but that invoked a nested          Berkeley DB transaction -- scandalous! */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|tb
operator|->
name|target_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Tell the dag subsystem that we're finished with our edits. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|txn_body_txdelta_finalize_edits
argument_list|,
name|tb
argument_list|,
name|FALSE
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_apply_textdelta
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
operator|(
name|txdelta_baton_t
operator|*
operator|)
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|tb
operator|->
name|root
operator|->
name|txn
decl_stmt|;
comment|/* Call open_path with no flags, as we want this to return an error      if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|tb
operator|->
name|root
argument_list|,
name|tb
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if path is locked;  if so, check that we can use it. */
if|if
condition|(
name|tb
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|tb
operator|->
name|path
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, make sure this path is mutable. */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|tb
operator|->
name|root
argument_list|,
name|parent_path
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|base_checksum
condition|)
block|{
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
comment|/* Until we finalize the node, its data_key points to the old          contents, in other words, the base text. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_file_checksum
argument_list|(
operator|&
name|checksum
argument_list|,
name|tb
operator|->
name|base_checksum
operator|->
name|kind
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* TODO: This only compares checksums if they are the same kind, but          we're calculating both SHA1 and MD5 checksums somewhere in          reps-strings.c.  Could we keep them both around somehow so this          check could be more comprehensive? */
if|if
condition|(
operator|!
name|svn_checksum_match
argument_list|(
name|tb
operator|->
name|base_checksum
argument_list|,
name|checksum
argument_list|)
condition|)
return|return
name|svn_checksum_mismatch_err
argument_list|(
name|tb
operator|->
name|base_checksum
argument_list|,
name|checksum
argument_list|,
name|trail
operator|->
name|pool
argument_list|,
name|_
argument_list|(
literal|"Base checksum mismatch on '%s'"
argument_list|)
argument_list|,
name|tb
operator|->
name|path
argument_list|)
return|;
block|}
comment|/* Make a readable "source" stream out of the current contents of      ROOT/PATH; obviously, this must done in the context of a db_txn.      The stream is returned in tb->source_stream. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_contents
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|source_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|trail
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a writable "target" stream */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_edit_stream
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|target_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a writable "string" stream which writes data to      tb->target_string. */
name|tb
operator|->
name|target_string
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|string_stream
operator|=
name|svn_stream_create
argument_list|(
name|tb
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|tb
operator|->
name|string_stream
argument_list|,
name|write_to_string
argument_list|)
expr_stmt|;
comment|/* Now, create a custom window handler that uses our two streams. */
name|svn_txdelta_apply
argument_list|(
name|tb
operator|->
name|source_stream
argument_list|,
name|tb
operator|->
name|string_stream
argument_list|,
name|NULL
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|tb
operator|->
name|pool
argument_list|,
operator|&
operator|(
name|tb
operator|->
name|interpreter
operator|)
argument_list|,
operator|&
operator|(
name|tb
operator|->
name|interpreter_baton
operator|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_apply_textdelta
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|contents_p
parameter_list|,
name|void
modifier|*
modifier|*
name|contents_baton_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_checksum_t
modifier|*
name|base_checksum
parameter_list|,
name|svn_checksum_t
modifier|*
name|result_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|txdelta_baton_t
modifier|*
name|tb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
decl_stmt|;
name|tb
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|tb
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|tb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|tb
operator|->
name|base_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|base_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tb
operator|->
name|result_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|result_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_apply_textdelta
argument_list|,
name|tb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|window_consumer
expr_stmt|;
operator|*
name|contents_baton_p
operator|=
name|tb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_apply_textdelta() ---  */
end_comment

begin_comment
comment|/* --- Machinery for svn_fs_apply_text() ---  */
end_comment

begin_comment
comment|/* Baton for svn_fs_apply_text(). */
end_comment

begin_struct
struct|struct
name|text_baton_t
block|{
comment|/* The original file info */
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* Derived from the file info */
name|dag_node_t
modifier|*
name|node
decl_stmt|;
comment|/* The returned stream that will accept the file's new contents. */
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* The actual fs stream that the returned stream will write to. */
name|svn_stream_t
modifier|*
name|file_stream
decl_stmt|;
comment|/* Checksum for the final fulltext written to the file.  May      be null, in which case ignored. */
name|svn_checksum_t
modifier|*
name|result_checksum
decl_stmt|;
comment|/* Pool used by db txns */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A trail-ready wrapper around svn_fs_base__dag_finalize_edits, but for  * fulltext data, not text deltas.  Closes BATON->file_stream.  *  * Note: If you're confused about how this function relates to another  * of similar name, think of it this way:  *  * svn_fs_apply_textdelta() ==> ... ==> txn_body_txdelta_finalize_edits()  * svn_fs_apply_text()      ==> ... ==> txn_body_fulltext_finalize_edits()  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_fulltext_finalize_edits
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_finalize_edits
argument_list|(
name|tb
operator|->
name|node
argument_list|,
name|tb
operator|->
name|result_checksum
argument_list|,
name|tb
operator|->
name|root
operator|->
name|txn
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a record of this modification in the changes table. */
return|return
name|add_change
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|tb
operator|->
name|root
operator|->
name|txn
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|tb
operator|->
name|node
argument_list|)
argument_list|,
name|svn_fs_path_change_modify
argument_list|,
name|TRUE
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Write function for the publically returned stream. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|text_stream_writer
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
comment|/* Psst, here's some data.  Pass it on to the -real- file stream. */
return|return
name|svn_stream_write
argument_list|(
name|tb
operator|->
name|file_stream
argument_list|,
name|data
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Close function for the publically returned stream. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|text_stream_closer
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
comment|/* Close the internal-use stream.  ### This used to be inside of      txn_body_fulltext_finalize_edits(), but that invoked a nested      Berkeley DB transaction -- scandalous! */
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|tb
operator|->
name|file_stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Need to tell fs that we're done sending text */
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|tb
operator|->
name|root
operator|->
name|fs
argument_list|,
name|txn_body_fulltext_finalize_edits
argument_list|,
name|tb
argument_list|,
name|FALSE
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_apply_text
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
init|=
name|tb
operator|->
name|root
operator|->
name|txn
decl_stmt|;
comment|/* Call open_path with no flags, as we want this to return an error      if the node for which we are searching doesn't exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|tb
operator|->
name|root
argument_list|,
name|tb
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check to see if path is locked;  if so, check that we can use it. */
if|if
condition|(
name|tb
operator|->
name|root
operator|->
name|txn_flags
operator|&
name|SVN_FS_TXN_CHECK_LOCKS
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__allow_locked_operation
argument_list|(
name|tb
operator|->
name|path
argument_list|,
name|FALSE
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, make sure this path is mutable. */
name|SVN_ERR
argument_list|(
name|make_path_mutable
argument_list|(
name|tb
operator|->
name|root
argument_list|,
name|parent_path
argument_list|,
name|tb
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
comment|/* Make a writable stream for replacing the file's text. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_edit_stream
argument_list|(
operator|&
operator|(
name|tb
operator|->
name|file_stream
operator|)
argument_list|,
name|tb
operator|->
name|node
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a 'returnable' stream which writes to the file_stream. */
name|tb
operator|->
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|tb
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|tb
operator|->
name|stream
argument_list|,
name|text_stream_writer
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|tb
operator|->
name|stream
argument_list|,
name|text_stream_closer
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_apply_text
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|contents_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_checksum_t
modifier|*
name|result_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|text_baton_t
modifier|*
name|tb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
decl_stmt|;
name|tb
operator|->
name|root
operator|=
name|root
expr_stmt|;
name|tb
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|tb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|tb
operator|->
name|result_checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|result_checksum
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_apply_text
argument_list|,
name|tb
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|contents_p
operator|=
name|tb
operator|->
name|stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* --- End machinery for svn_fs_apply_text() ---  */
end_comment

begin_comment
comment|/* Note: we're sharing the `things_changed_args' struct with    svn_fs_props_changed(). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_contents_changed
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|things_changed_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node1
decl_stmt|,
modifier|*
name|node2
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node1
argument_list|,
name|args
operator|->
name|root1
argument_list|,
name|args
operator|->
name|path1
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
name|node2
argument_list|,
name|args
operator|->
name|root2
argument_list|,
name|args
operator|->
name|path2
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__things_different
argument_list|(
name|NULL
argument_list|,
name|args
operator|->
name|changed_p
argument_list|,
name|node1
argument_list|,
name|node2
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Note:  it is acceptable for this function to call back into    top-level interfaces because it does not itself use trails.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_contents_changed
parameter_list|(
name|svn_boolean_t
modifier|*
name|changed_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|things_changed_args
name|args
decl_stmt|;
comment|/* Check that roots are in the same fs. */
if|if
condition|(
name|root1
operator|->
name|fs
operator|!=
name|root2
operator|->
name|fs
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot compare file contents between two different filesystems"
argument_list|)
argument_list|)
return|;
comment|/* Check that both paths are files. */
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
name|SVN_ERR
argument_list|(
name|base_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|path1
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|base_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is not a file"
argument_list|)
argument_list|,
name|path2
argument_list|)
return|;
block|}
name|args
operator|.
name|root1
operator|=
name|root1
expr_stmt|;
name|args
operator|.
name|root2
operator|=
name|root2
expr_stmt|;
name|args
operator|.
name|path1
operator|=
name|path1
expr_stmt|;
name|args
operator|.
name|path2
operator|=
name|path2
expr_stmt|;
name|args
operator|.
name|changed_p
operator|=
name|changed_p
expr_stmt|;
name|args
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|root1
operator|->
name|fs
argument_list|,
name|txn_body_contents_changed
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Public interface to computing file text deltas.  */
end_comment

begin_comment
comment|/* Note:  it is acceptable for this function to call back into    public FS API interfaces because it does not itself use trails.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_get_file_delta_stream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|source_root
parameter_list|,
specifier|const
name|char
modifier|*
name|source_path
parameter_list|,
name|svn_fs_root_t
modifier|*
name|target_root
parameter_list|,
specifier|const
name|char
modifier|*
name|target_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|source
decl_stmt|,
modifier|*
name|target
decl_stmt|;
name|svn_txdelta_stream_t
modifier|*
name|delta_stream
decl_stmt|;
comment|/* Get read functions for the source file contents.  */
if|if
condition|(
name|source_root
operator|&&
name|source_path
condition|)
name|SVN_ERR
argument_list|(
name|base_file_contents
argument_list|(
operator|&
name|source
argument_list|,
name|source_root
argument_list|,
name|source_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|source
operator|=
name|svn_stream_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Get read functions for the target file contents.  */
name|SVN_ERR
argument_list|(
name|base_file_contents
argument_list|(
operator|&
name|target
argument_list|,
name|target_root
argument_list|,
name|target_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create a delta stream that turns the ancestor into the target.  */
name|svn_txdelta2
argument_list|(
operator|&
name|delta_stream
argument_list|,
name|source
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|stream_p
operator|=
name|delta_stream
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Finding Changes */
end_comment

begin_struct
struct|struct
name|paths_changed_args
block|{
name|apr_hash_t
modifier|*
name|changes
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_paths_changed
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
comment|/* WARNING: This is called *without* the protection of a Berkeley DB      transaction.  If you modify this function, keep that in mind. */
name|struct
name|paths_changed_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|args
operator|->
name|root
operator|->
name|fs
decl_stmt|;
comment|/* Get the transaction ID from ROOT. */
if|if
condition|(
operator|!
name|args
operator|->
name|root
operator|->
name|is_txn_root
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__rev_get_txn_id
argument_list|(
operator|&
name|txn_id
argument_list|,
name|fs
argument_list|,
name|args
operator|->
name|root
operator|->
name|rev
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|txn_id
operator|=
name|args
operator|->
name|root
operator|->
name|txn
expr_stmt|;
return|return
name|svn_fs_bdb__changes_fetch
argument_list|(
operator|&
operator|(
name|args
operator|->
name|changes
operator|)
argument_list|,
name|fs
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_paths_changed
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changed_paths_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|paths_changed_args
name|args
decl_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|changes
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_paths_changed
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|changed_paths_p
operator|=
name|args
operator|.
name|changes
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Our coolio opaque history object. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|base_history_data_t
block|{
comment|/* filesystem object */
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
comment|/* path and revision of historical location */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|revision
decl_stmt|;
comment|/* internal-use hints about where to resume the history search. */
specifier|const
name|char
modifier|*
name|path_hint
decl_stmt|;
name|svn_revnum_t
name|rev_hint
decl_stmt|;
comment|/* FALSE until the first call to svn_fs_history_prev(). */
name|svn_boolean_t
name|is_interesting
decl_stmt|;
block|}
name|base_history_data_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|svn_fs_history_t
modifier|*
name|assemble_history
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|is_interesting
parameter_list|,
specifier|const
name|char
modifier|*
name|path_hint
parameter_list|,
name|svn_revnum_t
name|rev_hint
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_node_history
parameter_list|(
name|svn_fs_history_t
modifier|*
modifier|*
name|history_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* We require a revision root. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_REVISION_ROOT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* And we require that the path exist in the root. */
name|SVN_ERR
argument_list|(
name|base_check_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
return|return
name|SVN_FS__NOT_FOUND
argument_list|(
name|root
argument_list|,
name|path
argument_list|)
return|;
comment|/* Okay, all seems well.  Build our history object and return it. */
operator|*
name|history_p
operator|=
name|assemble_history
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Examine the PARENT_PATH structure chain to determine how copy IDs    would be doled out in the event that PARENT_PATH was made mutable.    Return the ID of the copy that last affected PARENT_PATH (and the    COPY itself, if we've already fetched it). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|examine_copy_inheritance
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|copy_id
parameter_list|,
name|copy_t
modifier|*
modifier|*
name|copy
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|parent_path_t
modifier|*
name|parent_path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* The default response -- our current copy ID, and no fetched COPY. */
operator|*
name|copy_id
operator|=
name|svn_fs_base__id_copy_id
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|copy
operator|=
name|NULL
expr_stmt|;
comment|/* If we have no parent (we are looking at the root node), or if      this node is supposed to inherit from itself, return that fact. */
if|if
condition|(
operator|!
name|parent_path
operator|->
name|parent
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We could be a branch destination (which would answer our question      altogether)!  But then, again, we might just have been modified      in this revision, so all bets are off. */
if|if
condition|(
name|parent_path
operator|->
name|copy_inherit
operator|==
name|copy_id_inherit_self
condition|)
block|{
comment|/* A copy ID of "0" means we've never been branched.  Therefore,          there are no copies relevant to our history. */
if|if
condition|(
operator|(
operator|(
operator|*
name|copy_id
operator|)
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
operator|*
name|copy_id
operator|)
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Get the COPY record.  If it was a real copy (not an implicit          one), we have our answer.  Otherwise, we fall through to the          recursive case. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_copy
argument_list|(
name|copy
argument_list|,
name|fs
argument_list|,
operator|*
name|copy_id
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|copy
operator|)
operator|->
name|kind
operator|!=
name|copy_kind_soft
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Otherwise, our answer is dependent upon our parent. */
return|return
name|examine_copy_inheritance
argument_list|(
name|copy_id
argument_list|,
name|copy
argument_list|,
name|fs
argument_list|,
name|parent_path
operator|->
name|parent
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|history_prev_args
block|{
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history_p
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|history
decl_stmt|;
name|svn_boolean_t
name|cross_copies
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_history_prev
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|history_prev_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history
init|=
name|args
operator|->
name|prev_history_p
decl_stmt|;
name|svn_fs_history_t
modifier|*
name|history
init|=
name|args
operator|->
name|history
decl_stmt|;
name|base_history_data_t
modifier|*
name|bhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
specifier|const
name|char
modifier|*
name|commit_path
decl_stmt|,
modifier|*
name|src_path
decl_stmt|,
modifier|*
name|path
init|=
name|bhd
operator|->
name|path
decl_stmt|;
name|svn_revnum_t
name|commit_rev
decl_stmt|,
name|src_rev
decl_stmt|,
name|dst_rev
decl_stmt|,
name|revision
init|=
name|bhd
operator|->
name|revision
decl_stmt|;
name|apr_pool_t
modifier|*
name|retpool
init|=
name|args
operator|->
name|pool
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|bhd
operator|->
name|fs
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|end_copy_id
init|=
name|NULL
decl_stmt|;
name|struct
name|revision_root_args
name|rr_args
decl_stmt|;
name|svn_boolean_t
name|reported
init|=
name|bhd
operator|->
name|is_interesting
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
name|copy_t
modifier|*
name|copy
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|retry
init|=
name|FALSE
decl_stmt|;
comment|/* Initialize our return value. */
operator|*
name|prev_history
operator|=
name|NULL
expr_stmt|;
comment|/* If our last history report left us hints about where to pickup      the chase, then our last report was on the destination of a      copy.  If we are crossing copies, start from those locations,      otherwise, we're all done here.  */
if|if
condition|(
name|bhd
operator|->
name|path_hint
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|bhd
operator|->
name|rev_hint
argument_list|)
condition|)
block|{
name|reported
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|cross_copies
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|path
operator|=
name|bhd
operator|->
name|path_hint
expr_stmt|;
name|revision
operator|=
name|bhd
operator|->
name|rev_hint
expr_stmt|;
block|}
comment|/* Construct a ROOT for the current revision. */
name|rr_args
operator|.
name|root_p
operator|=
operator|&
name|root
expr_stmt|;
name|rr_args
operator|.
name|rev
operator|=
name|revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|txn_body_revision_root
argument_list|(
operator|&
name|rr_args
argument_list|,
name|trail
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open PATH/REVISION, and get its node and a bunch of other      goodies.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__rev_get_txn_id
argument_list|(
operator|&
name|txn_id
argument_list|,
name|fs
argument_list|,
name|revision
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|parent_path
operator|->
name|node
expr_stmt|;
name|node_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|commit_path
operator|=
name|svn_fs_base__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_revision
argument_list|(
operator|&
name|commit_rev
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The Subversion filesystem is written in such a way that a given      line of history may have at most one interesting history point      per filesystem revision.  Either that node was edited (and      possibly copied), or it was copied but not edited.  And a copy      source cannot be from the same revision as its destination.  So,      if our history revision matches its node's commit revision, we      know that ... */
if|if
condition|(
name|revision
operator|==
name|commit_rev
condition|)
block|{
if|if
condition|(
operator|!
name|reported
condition|)
block|{
comment|/* ... we either have not yet reported on this revision (and              need now to do so) ... */
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|apr_pstrdup
argument_list|(
name|retpool
argument_list|,
name|commit_path
argument_list|)
argument_list|,
name|commit_rev
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|retpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
block|{
comment|/* ... or we *have* reported on this revision, and must now              progress toward this node's predecessor (unless there is              no predecessor, in which case we're all done!). */
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pred_id
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Replace NODE and friends with the information from its              predecessor. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|fs
argument_list|,
name|pred_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|commit_path
operator|=
name|svn_fs_base__dag_get_created_path
argument_list|(
name|node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_revision
argument_list|(
operator|&
name|commit_rev
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Calculate a possibly relevant copy ID. */
name|SVN_ERR
argument_list|(
name|examine_copy_inheritance
argument_list|(
operator|&
name|end_copy_id
argument_list|,
operator|&
name|copy
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize some state variables. */
name|src_path
operator|=
name|NULL
expr_stmt|;
name|src_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|dst_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* If our current copy ID (which is either the real copy ID of our      node, or the last copy ID which would affect our node if it were      to be made mutable) diffs at all from that of its predecessor      (which is either a real predecessor, or is the node itself      playing the predecessor role to an imaginary mutable successor),      then we need to report a copy.  */
if|if
condition|(
name|svn_fs_base__key_compare
argument_list|(
name|svn_fs_base__id_copy_id
argument_list|(
name|node_id
argument_list|)
argument_list|,
name|end_copy_id
argument_list|)
operator|!=
literal|0
condition|)
block|{
specifier|const
name|char
modifier|*
name|remainder
decl_stmt|;
name|dag_node_t
modifier|*
name|dst_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_dst
decl_stmt|;
comment|/* Get the COPY record if we haven't already fetched it. */
if|if
condition|(
operator|!
name|copy
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_copy
argument_list|(
operator|&
name|copy
argument_list|,
name|fs
argument_list|,
name|end_copy_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Figure out the destination path of the copy operation. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|dst_node
argument_list|,
name|fs
argument_list|,
name|copy
operator|->
name|dst_noderev_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copy_dst
operator|=
name|svn_fs_base__dag_get_created_path
argument_list|(
name|dst_node
argument_list|)
expr_stmt|;
comment|/* If our current path was the very destination of the copy,          then our new current path will be the copy source.  If our          current path was instead the *child* of the destination of          the copy, then figure out its previous location by taking its          path relative to the copy destination and appending that to          the copy source.  Finally, if our current path doesn't meet          one of these other criteria ... ### for now just fallback to          the old copy hunt algorithm. */
name|remainder
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|copy_dst
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|remainder
condition|)
block|{
comment|/* If we get here, then our current path is the destination              of, or the child of the destination of, a copy.  Fill              in the return values and get outta here.  */
name|SVN_ERR
argument_list|(
name|svn_fs_base__txn_get_revision
argument_list|(
operator|&
name|src_rev
argument_list|,
name|fs
argument_list|,
name|copy
operator|->
name|src_txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__txn_get_revision
argument_list|(
operator|&
name|dst_rev
argument_list|,
name|fs
argument_list|,
name|svn_fs_base__id_txn_id
argument_list|(
name|copy
operator|->
name|dst_noderev_id
argument_list|)
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|src_path
operator|=
name|svn_fspath__join
argument_list|(
name|copy
operator|->
name|src_path
argument_list|,
name|remainder
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy
operator|->
name|kind
operator|==
name|copy_kind_soft
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
comment|/* If we calculated a copy source path and revision, and the      copy source revision doesn't pre-date a revision in which we      *know* our node was modified, we'll make a 'copy-style' history      object. */
if|if
condition|(
name|src_path
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|src_rev
argument_list|)
operator|&&
operator|(
name|src_rev
operator|>=
name|commit_rev
operator|)
condition|)
block|{
comment|/* It's possible for us to find a copy location that is the same          as the history point we've just reported.  If that happens,          we simply need to take another trip through this history          search. */
if|if
condition|(
operator|(
name|dst_rev
operator|==
name|revision
operator|)
operator|&&
name|reported
condition|)
name|retry
operator|=
name|TRUE
expr_stmt|;
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|apr_pstrdup
argument_list|(
name|retpool
argument_list|,
name|path
argument_list|)
argument_list|,
name|dst_rev
argument_list|,
operator|!
name|retry
argument_list|,
name|src_path
argument_list|,
name|src_rev
argument_list|,
name|retpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
name|apr_pstrdup
argument_list|(
name|retpool
argument_list|,
name|commit_path
argument_list|)
argument_list|,
name|commit_rev
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|retpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_history_prev
parameter_list|(
name|svn_fs_history_t
modifier|*
modifier|*
name|prev_history_p
parameter_list|,
name|svn_fs_history_t
modifier|*
name|history
parameter_list|,
name|svn_boolean_t
name|cross_copies
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_history_t
modifier|*
name|prev_history
init|=
name|NULL
decl_stmt|;
name|base_history_data_t
modifier|*
name|bhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|bhd
operator|->
name|fs
decl_stmt|;
comment|/* Special case: the root directory changes in every single      revision, no exceptions.  And, the root can't be the target (or      child of a target -- duh) of a copy.  So, if that's our path,      then we need only decrement our revision by 1, and there you go. */
if|if
condition|(
name|strcmp
argument_list|(
name|bhd
operator|->
name|path
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|bhd
operator|->
name|is_interesting
condition|)
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
literal|"/"
argument_list|,
name|bhd
operator|->
name|revision
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bhd
operator|->
name|revision
operator|>
literal|0
condition|)
name|prev_history
operator|=
name|assemble_history
argument_list|(
name|fs
argument_list|,
literal|"/"
argument_list|,
name|bhd
operator|->
name|revision
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|history_prev_args
name|args
decl_stmt|;
name|prev_history
operator|=
name|history
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Get a trail, and get to work. */
name|args
operator|.
name|prev_history_p
operator|=
operator|&
name|prev_history
expr_stmt|;
name|args
operator|.
name|history
operator|=
name|prev_history
expr_stmt|;
name|args
operator|.
name|cross_copies
operator|=
name|cross_copies
expr_stmt|;
name|args
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_history_prev
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|prev_history
condition|)
break|break;
name|bhd
operator|=
name|prev_history
operator|->
name|fsap_data
expr_stmt|;
if|if
condition|(
name|bhd
operator|->
name|is_interesting
condition|)
break|break;
block|}
block|}
operator|*
name|prev_history_p
operator|=
name|prev_history
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_history_location
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_history_t
modifier|*
name|history
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_history_data_t
modifier|*
name|bhd
init|=
name|history
operator|->
name|fsap_data
decl_stmt|;
operator|*
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|bhd
operator|->
name|path
argument_list|)
expr_stmt|;
operator|*
name|revision
operator|=
name|bhd
operator|->
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|history_vtable_t
name|history_vtable
init|=
block|{
name|base_history_prev
block|,
name|base_history_location
block|}
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|closest_copy_args
block|{
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|path_p
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_closest_copy
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|closest_copy_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
init|=
name|args
operator|->
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|args
operator|->
name|path
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|,
modifier|*
name|copy_id
decl_stmt|;
name|copy_t
modifier|*
name|copy
init|=
name|NULL
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copy_dst_root
decl_stmt|;
name|dag_node_t
modifier|*
name|path_node_in_copy_dst
decl_stmt|,
modifier|*
name|copy_dst_node
decl_stmt|,
modifier|*
name|copy_dst_root_node
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy_dst_path
decl_stmt|;
name|svn_revnum_t
name|copy_dst_rev
decl_stmt|,
name|created_rev
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
operator|*
operator|(
name|args
operator|->
name|path_p
operator|)
operator|=
name|NULL
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|root_p
operator|)
operator|=
name|NULL
expr_stmt|;
comment|/* Get the transaction ID associated with our root. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
name|txn_id
operator|=
name|root
operator|->
name|txn
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_base__rev_get_txn_id
argument_list|(
operator|&
name|txn_id
argument_list|,
name|fs
argument_list|,
name|root
operator|->
name|rev
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open PATH in ROOT -- it must exist. */
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
literal|0
argument_list|,
name|txn_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|node_id
operator|=
name|svn_fs_base__dag_get_id
argument_list|(
name|parent_path
operator|->
name|node
argument_list|)
expr_stmt|;
comment|/* Now, examine the copy inheritance rules in play should our path      be made mutable in the future (if it isn't already).  This will      tell us about the youngest affecting copy.  */
name|SVN_ERR
argument_list|(
name|examine_copy_inheritance
argument_list|(
operator|&
name|copy_id
argument_list|,
operator|&
name|copy
argument_list|,
name|fs
argument_list|,
name|parent_path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Easy out:  if the copy ID is 0, there's nothing of interest here. */
if|if
condition|(
operator|(
operator|(
name|copy_id
operator|)
index|[
literal|0
index|]
operator|==
literal|'0'
operator|)
operator|&&
operator|(
operator|(
name|copy_id
operator|)
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Fetch our copy if examine_copy_inheritance() didn't do it for us. */
if|if
condition|(
operator|!
name|copy
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__get_copy
argument_list|(
operator|&
name|copy
argument_list|,
name|fs
argument_list|,
name|copy_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Figure out the destination path and revision of the copy operation. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|copy_dst_node
argument_list|,
name|fs
argument_list|,
name|copy
operator|->
name|dst_noderev_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copy_dst_path
operator|=
name|svn_fs_base__dag_get_created_path
argument_list|(
name|copy_dst_node
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_revision
argument_list|(
operator|&
name|copy_dst_rev
argument_list|,
name|copy_dst_node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Turn that revision into a revision root. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_revision_root
argument_list|(
operator|&
name|copy_dst_root_node
argument_list|,
name|fs
argument_list|,
name|copy_dst_rev
argument_list|,
name|trail
argument_list|,
name|args
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|copy_dst_root
operator|=
name|make_revision_root
argument_list|(
name|fs
argument_list|,
name|copy_dst_rev
argument_list|,
name|copy_dst_root_node
argument_list|,
name|args
operator|->
name|pool
argument_list|)
expr_stmt|;
comment|/* It is possible that this node was created from scratch at some      revision between COPY_DST_REV and the transaction associated with      our ROOT.  Make sure that PATH exists as of COPY_DST_REV and is      related to this node-rev. */
name|err
operator|=
name|get_dag
argument_list|(
operator|&
name|path_node_in_copy_dst
argument_list|,
name|copy_dst_root
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_DIRECTORY
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|path_node_in_copy_dst
argument_list|)
operator|==
name|svn_node_none
operator|)
operator|||
operator|(
operator|!
operator|(
name|svn_fs_base__id_check_related
argument_list|(
name|node_id
argument_list|,
name|svn_fs_base__dag_get_id
argument_list|(
name|path_node_in_copy_dst
argument_list|)
argument_list|)
operator|)
operator|)
condition|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* One final check must be done here.  If you copy a directory and      create a new entity somewhere beneath that directory in the same      txn, then we can't claim that the copy affected the new entity.      For example, if you do:          copy dir1 dir2         create dir2/new-thing         commit       then dir2/new-thing was not affected by the copy of dir1 to dir2.      We detect this situation by asking if PATH@COPY_DST_REV's      created-rev is COPY_DST_REV, and that node-revision has no      predecessors, then there is no relevant closest copy.   */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_revision
argument_list|(
operator|&
name|created_rev
argument_list|,
name|path_node_in_copy_dst
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|created_rev
operator|==
name|copy_dst_rev
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_predecessor_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|path_node_in_copy_dst
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pred_id
condition|)
return|return
name|SVN_NO_ERROR
return|;
block|}
operator|*
operator|(
name|args
operator|->
name|path_p
operator|)
operator|=
name|apr_pstrdup
argument_list|(
name|args
operator|->
name|pool
argument_list|,
name|copy_dst_path
argument_list|)
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|root_p
operator|)
operator|=
name|copy_dst_root
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_closest_copy
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root_p
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|path_p
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|closest_copy_args
name|args
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|closest_root
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|closest_path
init|=
name|NULL
decl_stmt|;
name|args
operator|.
name|root_p
operator|=
operator|&
name|closest_root
expr_stmt|;
name|args
operator|.
name|path_p
operator|=
operator|&
name|closest_path
expr_stmt|;
name|args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|args
operator|.
name|pool
operator|=
name|pool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_closest_copy
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|root_p
operator|=
name|closest_root
expr_stmt|;
operator|*
name|path_p
operator|=
name|closest_path
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a new history object (marked as "interesting") for PATH and    REVISION, allocated in POOL, and with its members set to the values    of the parameters provided.  Note that PATH and PATH_HINT are not    duped into POOL -- it is the responsibility of the caller to ensure    that this happens. */
end_comment

begin_function
specifier|static
name|svn_fs_history_t
modifier|*
name|assemble_history
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|svn_boolean_t
name|is_interesting
parameter_list|,
specifier|const
name|char
modifier|*
name|path_hint
parameter_list|,
name|svn_revnum_t
name|rev_hint
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_history_t
modifier|*
name|history
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|history
argument_list|)
argument_list|)
decl_stmt|;
name|base_history_data_t
modifier|*
name|bhd
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bhd
argument_list|)
argument_list|)
decl_stmt|;
name|bhd
operator|->
name|path
operator|=
name|path
expr_stmt|;
name|bhd
operator|->
name|revision
operator|=
name|revision
expr_stmt|;
name|bhd
operator|->
name|is_interesting
operator|=
name|is_interesting
expr_stmt|;
name|bhd
operator|->
name|path_hint
operator|=
name|path_hint
expr_stmt|;
name|bhd
operator|->
name|rev_hint
operator|=
name|rev_hint
expr_stmt|;
name|bhd
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|history
operator|->
name|vtable
operator|=
operator|&
name|history_vtable
expr_stmt|;
name|history
operator|->
name|fsap_data
operator|=
name|bhd
expr_stmt|;
return|return
name|history
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__get_path_kind
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|head_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|,
modifier|*
name|path_node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Get HEAD revision, */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__youngest_rev
argument_list|(
operator|&
name|head_rev
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Then convert it into a root_t, */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_revision_root
argument_list|(
operator|&
name|root_dir
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|head_rev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|=
name|make_revision_root
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|head_rev
argument_list|,
name|root_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* And get the dag_node for path in the root_t. */
name|err
operator|=
name|get_dag
argument_list|(
operator|&
name|path_node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|kind
operator|=
name|svn_node_none
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
operator|*
name|kind
operator|=
name|svn_fs_base__dag_node_kind
argument_list|(
name|path_node
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__get_path_created_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|rev
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|head_rev
decl_stmt|,
name|created_rev
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|dag_node_t
modifier|*
name|root_dir
decl_stmt|,
modifier|*
name|path_node
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Get HEAD revision, */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__youngest_rev
argument_list|(
operator|&
name|head_rev
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Then convert it into a root_t, */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_revision_root
argument_list|(
operator|&
name|root_dir
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|head_rev
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|root
operator|=
name|make_revision_root
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|head_rev
argument_list|,
name|root_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* And get the dag_node for path in the root_t. */
name|err
operator|=
name|get_dag
argument_list|(
operator|&
name|path_node
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NOT_FOUND
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* Find the created_rev of the dag_node. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_revision
argument_list|(
operator|&
name|created_rev
argument_list|,
name|path_node
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rev
operator|=
name|created_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Finding the Origin of a Line of History ***/
end_comment

begin_comment
comment|/* Set *PREV_PATH and *PREV_REV to the path and revision which    represent the location at which PATH in FS was located immediately    prior to REVISION iff there was a copy operation (to PATH or one of    its parent directories) between that previous location and    PATH@REVISION.     If there was no such copy operation in that portion of PATH's    history, set *PREV_PATH to NULL and *PREV_REV to SVN_INVALID_REVNUM.     WARNING:  Do *not* call this from inside a trail. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prev_location
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|prev_path
parameter_list|,
name|svn_revnum_t
modifier|*
name|prev_rev
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|copy_path
decl_stmt|,
modifier|*
name|copy_src_path
decl_stmt|,
modifier|*
name|remainder
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|copy_root
decl_stmt|;
name|svn_revnum_t
name|copy_src_rev
decl_stmt|;
comment|/* Ask about the most recent copy which affected PATH@REVISION.  If      there was no such copy, we're done.  */
name|SVN_ERR
argument_list|(
name|base_closest_copy
argument_list|(
operator|&
name|copy_root
argument_list|,
operator|&
name|copy_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|copy_root
condition|)
block|{
operator|*
name|prev_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
operator|*
name|prev_path
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Ultimately, it's not the path of the closest copy's source that      we care about -- it's our own path's location in the copy source      revision.  So we'll tack the relative path that expresses the      difference between the copy destination and our path in the copy      revision onto the copy source path to determine this information.       In other words, if our path is "/branches/my-branch/foo/bar", and      we know that the closest relevant copy was a copy of "/trunk" to      "/branches/my-branch", then that relative path under the copy      destination is "/foo/bar".  Tacking that onto the copy source      path tells us that our path was located at "/trunk/foo/bar"      before the copy.   */
name|SVN_ERR
argument_list|(
name|base_copied_from
argument_list|(
operator|&
name|copy_src_rev
argument_list|,
operator|&
name|copy_src_path
argument_list|,
name|copy_root
argument_list|,
name|copy_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|remainder
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|copy_path
argument_list|,
name|path
argument_list|)
expr_stmt|;
operator|*
name|prev_path
operator|=
name|svn_fspath__join
argument_list|(
name|copy_src_path
argument_list|,
name|remainder
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|prev_rev
operator|=
name|copy_src_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|id_created_rev_args
block|{
name|svn_revnum_t
name|revision
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_id_created_rev
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|id_created_rev_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|node
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__dag_get_revision
argument_list|(
operator|&
operator|(
name|args
operator|->
name|revision
operator|)
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|get_set_node_origin_args
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|origin_id
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_id
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_node_origin
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|get_set_node_origin_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
return|return
name|svn_fs_bdb__get_node_origin
argument_list|(
operator|&
operator|(
name|args
operator|->
name|origin_id
operator|)
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|node_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_set_node_origin
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|get_set_node_origin_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
return|return
name|svn_fs_bdb__set_node_origin
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|node_id
argument_list|,
name|args
operator|->
name|origin_id
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_node_origin_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|revision
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|root
operator|->
name|fs
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|struct
name|get_set_node_origin_args
name|args
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|origin_id
init|=
name|NULL
decl_stmt|;
name|struct
name|id_created_rev_args
name|icr_args
decl_stmt|;
comment|/* Canonicalize the input path so that the path-math that      prev_location() does below will work. */
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Special-case the root node (for performance reasons) */
if|if
condition|(
name|strcmp
argument_list|(
name|path
argument_list|,
literal|"/"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|revision
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we have support for the node-origins table, we'll try to use      it. */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_NODE_ORIGINS_FORMAT
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|base_node_id
argument_list|(
operator|&
name|id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|node_id
operator|=
name|svn_fs_base__id_node_id
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_get_node_origin
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If we got a value for the origin node-revision-ID, that's          great.  If we didn't, that's sad but non-fatal -- we'll just          figure it out the hard way, then record it so we don't have          suffer again the next time. */
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|origin_id
operator|=
name|args
operator|.
name|origin_id
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_NODE_ORIGIN
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
comment|/* If we haven't yet found a node origin ID, we'll go spelunking for one. */
if|if
condition|(
operator|!
name|origin_id
condition|)
block|{
name|svn_fs_root_t
modifier|*
name|curroot
init|=
name|root
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|predidpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|lastpath
init|=
name|svn_stringbuf_create
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|lastrev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|pred_id
decl_stmt|;
comment|/* Walk the closest-copy chain back to the first copy in our history.           NOTE: We merely *assume* that this is faster than walking the          predecessor chain, because we *assume* that copies of parent          directories happen less often than modifications to a given item. */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_revnum_t
name|currev
decl_stmt|;
specifier|const
name|char
modifier|*
name|curpath
init|=
name|lastpath
operator|->
name|data
decl_stmt|;
comment|/* Get a root pointing to LASTREV.  (The first time around,              LASTREV is invalid, but that's cool because CURROOT is              already initialized.)  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|lastrev
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__revision_root
argument_list|(
operator|&
name|curroot
argument_list|,
name|fs
argument_list|,
name|lastrev
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the previous location using the closest-copy shortcut. */
name|SVN_ERR
argument_list|(
name|prev_location
argument_list|(
operator|&
name|curpath
argument_list|,
operator|&
name|currev
argument_list|,
name|fs
argument_list|,
name|curroot
argument_list|,
name|curpath
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curpath
condition|)
break|break;
comment|/* Update our LASTPATH and LASTREV variables (which survive              SUBPOOL). */
name|svn_stringbuf_set
argument_list|(
name|lastpath
argument_list|,
name|curpath
argument_list|)
expr_stmt|;
name|lastrev
operator|=
name|currev
expr_stmt|;
block|}
comment|/* Walk the predecessor links back to origin. */
name|SVN_ERR
argument_list|(
name|base_node_id
argument_list|(
operator|&
name|pred_id
argument_list|,
name|curroot
argument_list|,
name|lastpath
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|struct
name|txn_pred_id_args
name|pid_args
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|pid_args
operator|.
name|id
operator|=
name|pred_id
expr_stmt|;
name|pid_args
operator|.
name|pred_id
operator|=
name|NULL
expr_stmt|;
name|pid_args
operator|.
name|pool
operator|=
name|subpool
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_pred_id
argument_list|,
operator|&
name|pid_args
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pid_args
operator|.
name|pred_id
condition|)
break|break;
name|svn_pool_clear
argument_list|(
name|predidpool
argument_list|)
expr_stmt|;
name|pred_id
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|pid_args
operator|.
name|pred_id
argument_list|,
name|predidpool
argument_list|)
expr_stmt|;
block|}
comment|/* Okay.  PRED_ID should hold our origin ID now.  */
name|origin_id
operator|=
name|svn_fs_base__id_copy
argument_list|(
name|pred_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* If our filesystem version supports it, let's remember this          value from now on.  */
if|if
condition|(
name|bfd
operator|->
name|format
operator|>=
name|SVN_FS_BASE__MIN_NODE_ORIGINS_FORMAT
condition|)
block|{
name|args
operator|.
name|origin_id
operator|=
name|origin_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_set_node_origin
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|predidpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Okay.  We have an origin node-revision-ID.  Let's get a created      revision from it. */
name|icr_args
operator|.
name|id
operator|=
name|origin_id
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_id_created_rev
argument_list|,
operator|&
name|icr_args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|revision
operator|=
name|icr_args
operator|.
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Mergeinfo Queries */
end_comment

begin_comment
comment|/* Examine directory NODE's immediately children for mergeinfo.     For those which have explicit mergeinfo, add their mergeinfo to    RESULT_CATALOG (allocated in RESULT_CATALOG's pool).     For those which don't, but sit atop trees which contain mergeinfo    somewhere deeper, add them to *CHILDREN_ATOP_MERGEINFO_TREES, a    hash mapping dirent names to dag_node_t * objects, allocated    from that hash's pool.     For those which neither have explicit mergeinfo nor sit atop trees    which contain mergeinfo, ignore them.     Use TRAIL->pool for temporary allocations. */
end_comment

begin_struct
struct|struct
name|get_mergeinfo_data_and_entries_baton
block|{
name|svn_mergeinfo_catalog_t
name|result_catalog
decl_stmt|;
name|apr_hash_t
modifier|*
name|children_atop_mergeinfo_trees
decl_stmt|;
name|dag_node_t
modifier|*
name|node
decl_stmt|;
specifier|const
name|char
modifier|*
name|node_path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_mergeinfo_data_and_entries
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|get_mergeinfo_data_and_entries_baton
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|dag_node_t
modifier|*
name|node
init|=
name|args
operator|->
name|node
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|result_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|args
operator|->
name|result_catalog
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|children_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|args
operator|->
name|children_atop_mergeinfo_trees
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|node
argument_list|)
operator|==
name|svn_node_dir
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|trail
operator|->
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
name|void
modifier|*
name|val
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|dirent
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|child_id
decl_stmt|;
name|dag_node_t
modifier|*
name|child_node
decl_stmt|;
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|;
name|apr_int64_t
name|kid_count
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|dirent
operator|=
name|val
expr_stmt|;
name|child_id
operator|=
name|dirent
operator|->
name|id
expr_stmt|;
comment|/* Get the node for this child. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_node
argument_list|(
operator|&
name|child_node
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|child_id
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Query the child node's mergeinfo stats. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
operator|&
name|kid_count
argument_list|,
name|child_node
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the child has mergeinfo, add it to the result catalog. */
if|if
condition|(
name|has_mergeinfo
condition|)
block|{
name|apr_hash_t
modifier|*
name|plist
decl_stmt|;
name|svn_mergeinfo_t
name|child_mergeinfo
decl_stmt|;
name|svn_string_t
modifier|*
name|pval
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_proplist
argument_list|(
operator|&
name|plist
argument_list|,
name|child_node
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|pval
operator|=
name|svn_hash_gets
argument_list|(
name|plist
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|pval
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_base__id_unparse
argument_list|(
name|child_id
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node-revision '%s' claims to have "
literal|"mergeinfo but doesn't"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Issue #3896: If syntactically invalid mergeinfo is present on              CHILD_NODE then treat it as if no mergeinfo is present rather              than raising a parse error. */
name|err
operator|=
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|child_mergeinfo
argument_list|,
name|pval
operator|->
name|data
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
name|svn_hash_sets
argument_list|(
name|args
operator|->
name|result_catalog
argument_list|,
name|svn_fspath__join
argument_list|(
name|args
operator|->
name|node_path
argument_list|,
name|dirent
operator|->
name|name
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|child_mergeinfo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If the child has descendants with mergeinfo -- that is, if          the count of descendants beneath it carrying mergeinfo, not          including itself, is non-zero -- then add it to the          children_atop_mergeinfo_trees hash to be crawled later. */
if|if
condition|(
operator|(
name|kid_count
operator|-
operator|(
name|has_mergeinfo
condition|?
literal|1
else|:
literal|0
operator|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|child_node
argument_list|)
operator|!=
name|svn_node_dir
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_base__id_unparse
argument_list|(
name|child_id
argument_list|,
name|iterpool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node-revision '%s' claims to sit "
literal|"atop a tree containing mergeinfo "
literal|"but is not a directory"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
name|svn_hash_sets
argument_list|(
name|args
operator|->
name|children_atop_mergeinfo_trees
argument_list|,
name|apr_pstrdup
argument_list|(
name|children_pool
argument_list|,
name|dirent
operator|->
name|name
argument_list|)
argument_list|,
name|svn_fs_base__dag_dup
argument_list|(
name|child_node
argument_list|,
name|children_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|crawl_directory_for_mergeinfo
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|dag_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|node_path
parameter_list|,
name|svn_mergeinfo_catalog_t
name|result_catalog
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|get_mergeinfo_data_and_entries_baton
name|gmdae_args
decl_stmt|;
name|apr_hash_t
modifier|*
name|children_atop_mergeinfo_trees
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
comment|/* Add mergeinfo for immediate children that have it, and fetch      immediate children that *don't* have it but sit atop trees that do. */
name|gmdae_args
operator|.
name|result_catalog
operator|=
name|result_catalog
expr_stmt|;
name|gmdae_args
operator|.
name|children_atop_mergeinfo_trees
operator|=
name|children_atop_mergeinfo_trees
expr_stmt|;
name|gmdae_args
operator|.
name|node
operator|=
name|node
expr_stmt|;
name|gmdae_args
operator|.
name|node_path
operator|=
name|node_path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_get_mergeinfo_data_and_entries
argument_list|,
operator|&
name|gmdae_args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If no children sit atop trees with mergeinfo, we're done.      Otherwise, recurse on those children. */
if|if
condition|(
name|apr_hash_count
argument_list|(
name|children_atop_mergeinfo_trees
argument_list|)
operator|==
literal|0
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|children_atop_mergeinfo_trees
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|crawl_directory_for_mergeinfo
argument_list|(
name|fs
argument_list|,
name|val
argument_list|,
name|svn_fspath__join
argument_list|(
name|node_path
argument_list|,
name|key
argument_list|,
name|iterpool
argument_list|)
argument_list|,
name|result_catalog
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Calculate the mergeinfo for PATH under revision ROOT using    inheritance type INHERIT.  Set *MERGEINFO to the mergeinfo, or to    NULL if there is none.  Results are allocated in POOL; TRAIL->pool    is used for temporary allocations.  */
end_comment

begin_struct
struct|struct
name|get_mergeinfo_for_path_baton
block|{
name|svn_mergeinfo_t
modifier|*
name|mergeinfo
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_mergeinfo_inheritance_t
name|inherit
decl_stmt|;
name|svn_boolean_t
name|adjust_inherited_mergeinfo
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_mergeinfo_for_path
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|get_mergeinfo_for_path_baton
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|parent_path_t
modifier|*
name|parent_path
decl_stmt|,
modifier|*
name|nearest_ancestor
decl_stmt|;
name|apr_hash_t
modifier|*
name|proplist
decl_stmt|;
name|svn_string_t
modifier|*
name|mergeinfo_string
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|dag_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
operator|*
operator|(
name|args
operator|->
name|mergeinfo
operator|)
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_path
argument_list|(
operator|&
name|parent_path
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Init the nearest ancestor. */
name|nearest_ancestor
operator|=
name|parent_path
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|inherit
operator|==
name|svn_mergeinfo_nearest_ancestor
condition|)
block|{
if|if
condition|(
operator|!
name|parent_path
operator|->
name|parent
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|nearest_ancestor
operator|=
name|parent_path
operator|->
name|parent
expr_stmt|;
block|}
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|;
name|apr_int64_t
name|count
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|node
operator|=
name|nearest_ancestor
operator|->
name|node
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
operator|&
name|has_mergeinfo
argument_list|,
operator|&
name|count
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_mergeinfo
condition|)
break|break;
comment|/* No need to loop if we're looking for explicit mergeinfo. */
if|if
condition|(
name|args
operator|->
name|inherit
operator|==
name|svn_mergeinfo_explicit
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|nearest_ancestor
operator|=
name|nearest_ancestor
operator|->
name|parent
expr_stmt|;
comment|/* Run out?  There's no mergeinfo. */
if|if
condition|(
operator|!
name|nearest_ancestor
condition|)
block|{
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__dag_get_proplist
argument_list|(
operator|&
name|proplist
argument_list|,
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|mergeinfo_string
operator|=
name|svn_hash_gets
argument_list|(
name|proplist
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|mergeinfo_string
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_base__id_unparse
argument_list|(
name|svn_fs_base__dag_get_id
argument_list|(
name|node
argument_list|)
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
decl_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Node-revision '%s' claims to have "
literal|"mergeinfo but doesn't"
argument_list|)
argument_list|,
name|id_str
operator|->
name|data
argument_list|)
return|;
block|}
comment|/* Parse the mergeinfo; store the result in ARGS->MERGEINFO. */
block|{
comment|/* Issue #3896: If a node has syntactically invalid mergeinfo, then        treat it as if no mergeinfo is present rather than raising a parse        error. */
name|svn_error_t
modifier|*
name|err
init|=
name|svn_mergeinfo_parse
argument_list|(
name|args
operator|->
name|mergeinfo
argument_list|,
name|mergeinfo_string
operator|->
name|data
argument_list|,
name|args
operator|->
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_MERGEINFO_PARSE_ERROR
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|NULL
expr_stmt|;
name|args
operator|->
name|mergeinfo
operator|=
name|NULL
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
comment|/* If our nearest ancestor is the very path we inquired about, we      can return the mergeinfo results directly.  Otherwise, we're      inheriting the mergeinfo, so we need to a) remove non-inheritable      ranges and b) telescope the merged-from paths. */
if|if
condition|(
name|args
operator|->
name|adjust_inherited_mergeinfo
operator|&&
operator|(
name|nearest_ancestor
operator|!=
name|parent_path
operator|)
condition|)
block|{
name|svn_mergeinfo_t
name|tmp_mergeinfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_inheritable2
argument_list|(
operator|&
name|tmp_mergeinfo
argument_list|,
operator|*
name|args
operator|->
name|mergeinfo
argument_list|,
name|NULL
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|TRUE
argument_list|,
name|trail
operator|->
name|pool
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__append_to_merged_froms
argument_list|(
name|args
operator|->
name|mergeinfo
argument_list|,
name|tmp_mergeinfo
argument_list|,
name|parent_path_relpath
argument_list|(
name|parent_path
argument_list|,
name|nearest_ancestor
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|,
name|args
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set **NODE to the dag node for PATH in ROOT (allocated in POOL),    and query its mergeinfo stats, setting HAS_MERGEINFO and    CHILD_MERGEINFO_COUNT appropriately. */
end_comment

begin_struct
struct|struct
name|get_node_mergeinfo_stats_baton
block|{
name|dag_node_t
modifier|*
name|node
decl_stmt|;
name|svn_boolean_t
name|has_mergeinfo
decl_stmt|;
name|apr_int64_t
name|child_mergeinfo_count
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_node_mergeinfo_stats
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|get_node_mergeinfo_stats_baton
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_dag
argument_list|(
operator|&
operator|(
name|args
operator|->
name|node
operator|)
argument_list|,
name|args
operator|->
name|root
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_base__dag_get_mergeinfo_stats
argument_list|(
operator|&
operator|(
name|args
operator|->
name|has_mergeinfo
operator|)
argument_list|,
operator|&
operator|(
name|args
operator|->
name|child_mergeinfo_count
operator|)
argument_list|,
name|args
operator|->
name|node
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get the mergeinfo for a set of paths, returned in    *MERGEINFO_CATALOG.  Returned values are allocated in POOL, while    temporary values are allocated in a sub-pool. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_mergeinfos_for_paths
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_mergeinfo_catalog_t
modifier|*
name|mergeinfo_catalog
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_mergeinfo_catalog_t
name|result_catalog
init|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_mergeinfo_t
name|path_mergeinfo
decl_stmt|;
name|struct
name|get_mergeinfo_for_path_baton
name|gmfp_args
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the mergeinfo for PATH itself. */
name|gmfp_args
operator|.
name|mergeinfo
operator|=
operator|&
name|path_mergeinfo
expr_stmt|;
name|gmfp_args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|gmfp_args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|gmfp_args
operator|.
name|inherit
operator|=
name|inherit
expr_stmt|;
name|gmfp_args
operator|.
name|pool
operator|=
name|result_pool
expr_stmt|;
name|gmfp_args
operator|.
name|adjust_inherited_mergeinfo
operator|=
name|adjust_inherited_mergeinfo
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_get_mergeinfo_for_path
argument_list|,
operator|&
name|gmfp_args
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_mergeinfo
condition|)
name|svn_hash_sets
argument_list|(
name|result_catalog
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|path
argument_list|)
argument_list|,
name|path_mergeinfo
argument_list|)
expr_stmt|;
comment|/* If we're including descendants, do so. */
if|if
condition|(
name|include_descendants
condition|)
block|{
name|svn_boolean_t
name|do_crawl
decl_stmt|;
name|struct
name|get_node_mergeinfo_stats_baton
name|gnms_args
decl_stmt|;
comment|/* Query the node and its mergeinfo stats. */
name|gnms_args
operator|.
name|root
operator|=
name|root
expr_stmt|;
name|gnms_args
operator|.
name|path
operator|=
name|path
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|txn_body_get_node_mergeinfo_stats
argument_list|,
operator|&
name|gnms_args
argument_list|,
name|FALSE
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Determine if there's anything worth crawling here. */
if|if
condition|(
name|svn_fs_base__dag_node_kind
argument_list|(
name|gnms_args
operator|.
name|node
argument_list|)
operator|!=
name|svn_node_dir
condition|)
name|do_crawl
operator|=
name|FALSE
expr_stmt|;
else|else
name|do_crawl
operator|=
operator|(
operator|(
name|gnms_args
operator|.
name|child_mergeinfo_count
operator|>
literal|1
operator|)
operator|||
operator|(
operator|(
name|gnms_args
operator|.
name|child_mergeinfo_count
operator|==
literal|1
operator|)
operator|&&
operator|(
operator|!
name|gnms_args
operator|.
name|has_mergeinfo
operator|)
operator|)
operator|)
expr_stmt|;
comment|/* If it's worth crawling, crawl. */
if|if
condition|(
name|do_crawl
condition|)
name|SVN_ERR
argument_list|(
name|crawl_directory_for_mergeinfo
argument_list|(
name|root
operator|->
name|fs
argument_list|,
name|gnms_args
operator|.
name|node
argument_list|,
name|path
argument_list|,
name|result_catalog
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
operator|*
name|mergeinfo_catalog
operator|=
name|result_catalog
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implements svn_fs_get_mergeinfo. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_get_mergeinfo
parameter_list|(
name|svn_mergeinfo_catalog_t
modifier|*
name|catalog
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_mergeinfo_inheritance_t
name|inherit
parameter_list|,
name|svn_boolean_t
name|include_descendants
parameter_list|,
name|svn_boolean_t
name|adjust_inherited_mergeinfo
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Verify that our filesystem version supports mergeinfo stuff. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__test_required_feature_format
argument_list|(
name|root
operator|->
name|fs
argument_list|,
literal|"mergeinfo"
argument_list|,
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We require a revision root. */
if|if
condition|(
name|root
operator|->
name|is_txn_root
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_NOT_REVISION_ROOT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Retrieve a path -> mergeinfo mapping. */
return|return
name|get_mergeinfos_for_paths
argument_list|(
name|root
argument_list|,
name|catalog
argument_list|,
name|paths
argument_list|,
name|inherit
argument_list|,
name|include_descendants
argument_list|,
name|adjust_inherited_mergeinfo
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creating root objects.  */
end_comment

begin_decl_stmt
specifier|static
name|root_vtable_t
name|root_vtable
init|=
block|{
name|base_paths_changed
block|,
name|base_check_path
block|,
name|base_node_history
block|,
name|base_node_id
block|,
name|base_node_created_rev
block|,
name|base_node_origin_rev
block|,
name|base_node_created_path
block|,
name|base_delete_node
block|,
name|base_copied_from
block|,
name|base_closest_copy
block|,
name|base_node_prop
block|,
name|base_node_proplist
block|,
name|base_change_node_prop
block|,
name|base_props_changed
block|,
name|base_dir_entries
block|,
name|base_make_dir
block|,
name|base_copy
block|,
name|base_revision_link
block|,
name|base_file_length
block|,
name|base_file_checksum
block|,
name|base_file_contents
block|,
name|NULL
block|,
name|base_make_file
block|,
name|base_apply_textdelta
block|,
name|base_apply_text
block|,
name|base_contents_changed
block|,
name|base_get_file_delta_stream
block|,
name|base_merge
block|,
name|base_get_mergeinfo
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Construct a new root object in FS, allocated from POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_root_t
modifier|*
name|make_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|root
argument_list|)
argument_list|)
decl_stmt|;
name|base_root_data_t
modifier|*
name|brd
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|brd
argument_list|)
argument_list|)
decl_stmt|;
name|root
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
name|root
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
comment|/* Init the node ID cache. */
name|brd
operator|->
name|node_cache
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|brd
operator|->
name|node_cache_idx
operator|=
literal|0
expr_stmt|;
name|root
operator|->
name|vtable
operator|=
operator|&
name|root_vtable
expr_stmt|;
name|root
operator|->
name|fsap_data
operator|=
name|brd
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

begin_comment
comment|/* Construct a root object referring to the root of REVISION in FS,    whose root directory is ROOT_DIR.  Create the new root in POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_root_t
modifier|*
name|make_revision_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|dag_node_t
modifier|*
name|root_dir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|make_root
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|base_root_data_t
modifier|*
name|brd
init|=
name|root
operator|->
name|fsap_data
decl_stmt|;
name|root
operator|->
name|is_txn_root
operator|=
name|FALSE
expr_stmt|;
name|root
operator|->
name|rev
operator|=
name|rev
expr_stmt|;
name|brd
operator|->
name|root_dir
operator|=
name|root_dir
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

begin_comment
comment|/* Construct a root object referring to the root of the transaction    named TXN and based on revision BASE_REV in FS.  FLAGS represents    the behavior of the transaction.  Create the new root in POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_root_t
modifier|*
name|make_txn_root
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|txn
parameter_list|,
name|svn_revnum_t
name|base_rev
parameter_list|,
name|apr_uint32_t
name|flags
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
init|=
name|make_root
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|root
operator|->
name|is_txn_root
operator|=
name|TRUE
expr_stmt|;
name|root
operator|->
name|txn
operator|=
name|apr_pstrdup
argument_list|(
name|root
operator|->
name|pool
argument_list|,
name|txn
argument_list|)
expr_stmt|;
name|root
operator|->
name|txn_flags
operator|=
name|flags
expr_stmt|;
name|root
operator|->
name|rev
operator|=
name|base_rev
expr_stmt|;
return|return
name|root
return|;
block|}
end_function

end_unit

