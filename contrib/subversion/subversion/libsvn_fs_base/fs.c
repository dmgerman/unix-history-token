begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs.c --- creating, opening and closing filesystems  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"dag.h"
end_include

begin_include
include|#
directive|include
file|"revs-txns.h"
end_include

begin_include
include|#
directive|include
file|"uuid.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"id.h"
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_define
define|#
directive|define
name|SVN_WANT_BDB
end_define

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"bdb/bdb-err.h"
end_include

begin_include
include|#
directive|include
file|"bdb/bdb_compat.h"
end_include

begin_include
include|#
directive|include
file|"bdb/env.h"
end_include

begin_include
include|#
directive|include
file|"bdb/nodes-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/rev-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/txn-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/copies-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/changes-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/reps-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/strings-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/uuids-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/locks-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/lock-tokens-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/node-origins-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/miscellaneous-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/checksum-reps-table.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Checking for return values, and reporting errors.  */
end_comment

begin_comment
comment|/* Check that we're using the right Berkeley DB version. */
end_comment

begin_comment
comment|/* FIXME: This check should be abstracted into the DB back-end layer. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_bdb_version
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|major
decl_stmt|,
name|minor
decl_stmt|,
name|patch
decl_stmt|;
name|db_version
argument_list|(
operator|&
name|major
argument_list|,
operator|&
name|minor
argument_list|,
operator|&
name|patch
argument_list|)
expr_stmt|;
comment|/* First, check that we're using a reasonably correct of Berkeley DB. */
if|if
condition|(
operator|(
name|major
operator|<
name|SVN_FS_WANT_DB_MAJOR
operator|)
operator|||
operator|(
name|major
operator|==
name|SVN_FS_WANT_DB_MAJOR
operator|&&
name|minor
operator|<
name|SVN_FS_WANT_DB_MINOR
operator|)
operator|||
operator|(
name|major
operator|==
name|SVN_FS_WANT_DB_MAJOR
operator|&&
name|minor
operator|==
name|SVN_FS_WANT_DB_MINOR
operator|&&
name|patch
operator|<
name|SVN_FS_WANT_DB_PATCH
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Bad database version: got %d.%d.%d,"
literal|" should be at least %d.%d.%d"
argument_list|)
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|patch
argument_list|,
name|SVN_FS_WANT_DB_MAJOR
argument_list|,
name|SVN_FS_WANT_DB_MINOR
argument_list|,
name|SVN_FS_WANT_DB_PATCH
argument_list|)
return|;
comment|/* Now, check that the version we're running against is the same as      the one we compiled with. */
if|if
condition|(
name|major
operator|!=
name|DB_VERSION_MAJOR
operator|||
name|minor
operator|!=
name|DB_VERSION_MINOR
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_GENERAL
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Bad database version:"
literal|" compiled with %d.%d.%d,"
literal|" running against %d.%d.%d"
argument_list|)
argument_list|,
name|DB_VERSION_MAJOR
argument_list|,
name|DB_VERSION_MINOR
argument_list|,
name|DB_VERSION_PATCH
argument_list|,
name|major
argument_list|,
name|minor
argument_list|,
name|patch
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Cleanup functions.  */
end_comment

begin_comment
comment|/* Close a database in the filesystem FS.    DB_PTR is a pointer to the DB pointer in *FS to close.    NAME is the name of the database, for use in error messages.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cleanup_fs_db
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|DB
modifier|*
modifier|*
name|db_ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
comment|/* If the BDB environment is panicked, don't do anything, since      attempting to close the database will fail anyway. */
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
operator|*
name|db_ptr
operator|&&
operator|!
name|svn_fs_bdb__get_panic
argument_list|(
name|bfd
operator|->
name|bdb
argument_list|)
condition|)
block|{
name|DB
modifier|*
name|db
init|=
operator|*
name|db_ptr
decl_stmt|;
name|char
modifier|*
name|msg
init|=
name|apr_psprintf
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
literal|"closing '%s' database"
argument_list|,
name|name
argument_list|)
decl_stmt|;
name|int
name|db_err
decl_stmt|;
operator|*
name|db_ptr
operator|=
literal|0
expr_stmt|;
name|db_err
operator|=
name|db
operator|->
name|close
argument_list|(
name|db
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
operator|==
name|DB_RUNRECOVERY
condition|)
block|{
comment|/* We can ignore DB_RUNRECOVERY errors from DB->close, but              must set the panic flag in the environment baton.  The              error will be propagated appropriately from              svn_fs_bdb__close. */
name|svn_fs_bdb__set_panic
argument_list|(
name|bfd
operator|->
name|bdb
argument_list|)
expr_stmt|;
name|db_err
operator|=
literal|0
expr_stmt|;
block|}
if|#
directive|if
name|SVN_BDB_HAS_DB_INCOMPLETE
comment|/* We can ignore DB_INCOMPLETE on db->close and db->sync; it        * just means someone else was using the db at the same time        * we were.  See the Berkeley documentation at:        * http://www.sleepycat.com/docs/ref/program/errorret.html#DB_INCOMPLETE        * http://www.sleepycat.com/docs/api_c/db_close.html        */
if|if
condition|(
name|db_err
operator|==
name|DB_INCOMPLETE
condition|)
name|db_err
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* SVN_BDB_HAS_DB_INCOMPLETE */
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|msg
argument_list|,
name|db_err
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Close whatever Berkeley DB resources are allocated to FS.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|cleanup_fs
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|bdb_env_baton_t
modifier|*
name|bdb
init|=
operator|(
name|bfd
condition|?
name|bfd
operator|->
name|bdb
else|:
name|NULL
operator|)
decl_stmt|;
if|if
condition|(
operator|!
name|bdb
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Close the databases.  */
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|nodes
argument_list|,
literal|"nodes"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|revisions
argument_list|,
literal|"revisions"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|transactions
argument_list|,
literal|"transactions"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|copies
argument_list|,
literal|"copies"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|changes
argument_list|,
literal|"changes"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|representations
argument_list|,
literal|"representations"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|strings
argument_list|,
literal|"strings"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|uuids
argument_list|,
literal|"uuids"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|locks
argument_list|,
literal|"locks"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|lock_tokens
argument_list|,
literal|"lock-tokens"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|node_origins
argument_list|,
literal|"node-origins"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|checksum_reps
argument_list|,
literal|"checksum-reps"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|cleanup_fs_db
argument_list|(
name|fs
argument_list|,
operator|&
name|bfd
operator|->
name|miscellaneous
argument_list|,
literal|"miscellaneous"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, close the environment.  */
name|bfd
operator|->
name|bdb
operator|=
literal|0
expr_stmt|;
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_bdb__close
argument_list|(
name|bdb
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Berkeley DB error for filesystem '%s'"
literal|" while closing environment:\n"
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Set to 1 for instrumenting. */
end_comment

begin_comment
unit|static void print_fs_stats(svn_fs_t *fs) {   base_fs_data_t *bfd = fs->fsap_data;   DB_TXN_STAT *t;   DB_LOCK_STAT *l;   int db_err;
comment|/* Print transaction statistics for this DB env. */
end_comment

begin_comment
unit|if ((db_err = bfd->bdb->env->txn_stat(bfd->bdb->env,&t, 0)) != 0)     fprintf(stderr, "Error running bfd->bdb->env->txn_stat(): %s",             db_strerror(db_err));   else     {       printf("*** DB transaction stats, right before closing env:\n");       printf("   Number of transactions currently active: %d\n",              t->st_nactive);       printf("   Max number of active transactions at any one time: %d\n",              t->st_maxnactive);       printf("   Number of transactions that have begun: %d\n",              t->st_nbegins);       printf("   Number of transactions that have aborted: %d\n",              t->st_naborts);       printf("   Number of transactions that have committed: %d\n",              t->st_ncommits);       printf("   Number of times a thread was forced to wait: %d\n",              t->st_region_wait);       printf("   Number of times a thread didn't need to wait: %d\n",              t->st_region_nowait);       printf("*** End DB transaction stats.\n\n");     }
comment|/* Print transaction statistics for this DB env. */
end_comment

begin_else
unit|if ((db_err = bfd->bdb->env->lock_stat(bfd->bdb->env,&l, 0)) != 0)     fprintf(stderr, "Error running bfd->bdb->env->lock_stat(): %s",             db_strerror(db_err));   else     {       printf("*** DB lock stats, right before closing env:\n");       printf("   The number of current locks: %d\n",              l->st_nlocks);       printf("   Max number of locks at any one time: %d\n",              l->st_maxnlocks);       printf("   Number of current lockers: %d\n",              l->st_nlockers);       printf("   Max number of lockers at any one time: %d\n",              l->st_maxnlockers);       printf("   Number of current objects: %d\n",              l->st_nobjects);       printf("   Max number of objects at any one time: %d\n",              l->st_maxnobjects);       printf("   Total number of locks requested: %d\n",              l->st_nrequests);       printf("   Total number of locks released: %d\n",              l->st_nreleases);       printf("   Total number of lock reqs failed because "              "DB_LOCK_NOWAIT was set: %d\n", l->st_nnowaits);       printf("   Total number of locks not immediately available "              "due to conflicts: %d\n", l->st_nconflicts);       printf("   Number of deadlocks detected: %d\n", l->st_ndeadlocks);       printf("   Number of times a thread waited before "              "obtaining the region lock: %d\n", l->st_region_wait);       printf("   Number of times a thread didn't have to wait: %d\n",              l->st_region_nowait);       printf("*** End DB lock stats.\n\n");     }  }
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print_fs_stats
parameter_list|(
name|fs
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0/1 */
end_comment

begin_comment
comment|/* An APR pool cleanup function for a filesystem.  DATA must be a    pointer to the filesystem to clean up.     When the filesystem object's pool is freed, we want the resources    held by Berkeley DB to go away, just like everything else.  So we    register this cleanup function with the filesystem's pool, and let    it take care of closing the databases, the environment, and any    other DB objects we might be using.  APR calls this function before    actually freeing the pool's memory.     It's a pity that we can't return an svn_error_t object from an APR    cleanup function.  For now, we return the rather generic    SVN_ERR_FS_CLEANUP, and pass the real svn_error_t to the registered    warning callback.  */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cleanup_fs_apr
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|data
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|print_fs_stats
argument_list|(
name|fs
argument_list|)
expr_stmt|;
name|err
operator|=
name|cleanup_fs
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
return|return
name|APR_SUCCESS
return|;
comment|/* Darn. An error during cleanup. Call the warning handler to      try and do something "right" with this error. Note that      the default will simply abort().  */
call|(
modifier|*
name|fs
operator|->
name|warning
call|)
argument_list|(
name|fs
operator|->
name|warning_baton
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_ERR_FS_CLEANUP
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_bdb_set_errcall
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|void
function_decl|(
modifier|*
name|db_errcall_fcn
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
name|errpfx
parameter_list|,
name|char
modifier|*
name|msg
parameter_list|)
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|bfd
operator|->
name|bdb
operator|->
name|error_info
operator|->
name|user_callback
operator|=
name|db_errcall_fcn
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write the DB_CONFIG file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bdb_write_config
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dbconfig_file_name
init|=
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|BDB_CONFIG_FILE
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|dbconfig_file
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
specifier|const
name|char
name|dbconfig_contents
index|[]
init|=
literal|"# This is the configuration file for the Berkeley DB environment\n"
literal|"# used by your Subversion repository.\n"
literal|"# You must run 'svnadmin recover' whenever you modify this file,\n"
literal|"# for your changes to take effect.\n"
literal|"\n"
literal|"### Lock subsystem\n"
literal|"#\n"
literal|"# Make sure you read the documentation at:\n"
literal|"#\n"
literal|"#   http://docs.oracle.com/cd/E17076_02/html/programmer_reference/lock_max.html\n"
literal|"#\n"
literal|"# before tweaking these values.\n"
literal|"#\n"
literal|"set_lk_max_locks   2000\n"
literal|"set_lk_max_lockers 2000\n"
literal|"set_lk_max_objects 2000\n"
literal|"\n"
literal|"### Log file subsystem\n"
literal|"#\n"
literal|"# Make sure you read the documentation at:\n"
literal|"#\n"
literal|"#   http://docs.oracle.com/cd/E17076_02/html/api_reference/C/envset_lg_bsize.html\n"
literal|"#   http://docs.oracle.com/cd/E17076_02/html/api_reference/C/envset_lg_max.html\n"
literal|"#   http://docs.oracle.com/cd/E17076_02/html/programmer_reference/log_limits.html\n"
literal|"#\n"
literal|"# Increase the size of the in-memory log buffer from the default\n"
literal|"# of 32 Kbytes to 256 Kbytes.  Decrease the log file size from\n"
literal|"# 10 Mbytes to 1 Mbyte.  This will help reduce the amount of disk\n"
literal|"# space required for hot backups.  The size of the log file must be\n"
literal|"# at least four times the size of the in-memory log buffer.\n"
literal|"#\n"
literal|"# Note: Decreasing the in-memory buffer size below 256 Kbytes will hurt\n"
literal|"# hurt commit performance. For details, see:\n"
literal|"#\n"
literal|"#   http://svn.haxx.se/dev/archive-2002-02/0141.shtml\n"
literal|"#\n"
literal|"set_lg_bsize     262144\n"
literal|"set_lg_max      1048576\n"
literal|"#\n"
literal|"# If you see \"log region out of memory\" errors, bump lg_regionmax.\n"
literal|"# For more information, see:\n"
literal|"#\n"
literal|"#   http://docs.oracle.com/cd/E17076_02/html/programmer_reference/log_config.html\n"
literal|"#   http://svn.haxx.se/users/archive-2004-10/1000.shtml\n"
literal|"#\n"
literal|"set_lg_regionmax 131072\n"
literal|"#\n"
comment|/* ### Configure this with "svnadmin create --bdb-cache-size" */
literal|"# The default cache size in BDB is only 256k. As explained in\n"
literal|"# http://svn.haxx.se/dev/archive-2004-12/0368.shtml, this is too\n"
literal|"# small for most applications. Bump this number if \"db_stat -m\"\n"
literal|"# shows too many cache misses.\n"
literal|"#\n"
literal|"set_cachesize    0 1048576 1\n"
decl_stmt|;
comment|/* Run-time configurable options.      Each option set consists of a minimum required BDB version, a      config hash key, a header, an inactive form and an active      form. We always write the header; then, depending on the      run-time configuration and the BDB version we're compiling      against, we write either the active or inactive form of the      value. */
specifier|static
specifier|const
struct|struct
block|{
name|int
name|bdb_major
decl_stmt|;
name|int
name|bdb_minor
decl_stmt|;
specifier|const
name|char
modifier|*
name|config_key
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
decl_stmt|;
specifier|const
name|char
modifier|*
name|inactive
decl_stmt|;
specifier|const
name|char
modifier|*
name|active
decl_stmt|;
block|}
name|dbconfig_options
index|[]
init|=
block|{
comment|/* Controlled by "svnadmin create --bdb-txn-nosync" */
block|{
literal|4
block|,
literal|0
block|,
name|SVN_FS_CONFIG_BDB_TXN_NOSYNC
block|,
comment|/* header */
literal|"#\n"
literal|"# Disable fsync of log files on transaction commit. Read the\n"
literal|"# documentation about DB_TXN_NOSYNC at:\n"
literal|"#\n"
literal|"#   http://docs.oracle.com/cd/E17076_02/html/programmer_reference/log_config.html\n"
literal|"#\n"
literal|"# [requires Berkeley DB 4.0]\n"
literal|"#\n"
block|,
comment|/* inactive */
literal|"#set_flags DB_TXN_NOSYNC\n"
block|,
comment|/* active */
literal|"set_flags DB_TXN_NOSYNC\n"
block|}
block|,
comment|/* Controlled by "svnadmin create --bdb-log-keep" */
block|{
literal|4
block|,
literal|2
block|,
name|SVN_FS_CONFIG_BDB_LOG_AUTOREMOVE
block|,
comment|/* header */
literal|"#\n"
literal|"# Enable automatic removal of unused transaction log files.\n"
literal|"# Read the documentation about DB_LOG_AUTOREMOVE at:\n"
literal|"#\n"
literal|"#   http://docs.oracle.com/cd/E17076_02/html/programmer_reference/log_config.html\n"
literal|"#\n"
literal|"# [requires Berkeley DB 4.2]\n"
literal|"#\n"
block|,
comment|/* inactive */
literal|"#set_flags DB_LOG_AUTOREMOVE\n"
block|,
comment|/* active */
literal|"set_flags DB_LOG_AUTOREMOVE\n"
block|}
block|,   }
struct|;
specifier|static
specifier|const
name|int
name|dbconfig_options_length
init|=
sizeof|sizeof
argument_list|(
name|dbconfig_options
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|dbconfig_options
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|dbconfig_file
argument_list|,
name|dbconfig_file_name
argument_list|,
name|APR_WRITE
operator||
name|APR_CREATE
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dbconfig_file
argument_list|,
name|dbconfig_contents
argument_list|,
sizeof|sizeof
argument_list|(
name|dbconfig_contents
argument_list|)
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Write the variable DB_CONFIG flags. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dbconfig_options_length
condition|;
operator|++
name|i
control|)
block|{
name|void
modifier|*
name|value
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|choice
decl_stmt|;
if|if
condition|(
name|fs
operator|->
name|config
condition|)
block|{
name|value
operator|=
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|config_key
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dbconfig_file
argument_list|,
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|header
argument_list|,
name|strlen
argument_list|(
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|header
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|DB_VERSION_MAJOR
operator|==
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|bdb_major
operator|&&
name|DB_VERSION_MINOR
operator|>=
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|bdb_minor
operator|)
operator|||
name|DB_VERSION_MAJOR
operator|>
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|bdb_major
operator|)
operator|&&
name|value
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|value
argument_list|,
literal|"0"
argument_list|)
operator|!=
literal|0
condition|)
name|choice
operator|=
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|active
expr_stmt|;
else|else
name|choice
operator|=
name|dbconfig_options
index|[
name|i
index|]
operator|.
name|inactive
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_write_full
argument_list|(
name|dbconfig_file
argument_list|,
name|choice
argument_list|,
name|strlen
argument_list|(
name|choice
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_io_file_close
argument_list|(
name|dbconfig_file
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_bdb_verify_root
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* Verifying is currently a no op for BDB. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_bdb_freeze
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_fs_freeze_func_t
name|freeze_func
parameter_list|,
name|void
modifier|*
name|freeze_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN__NOT_IMPLEMENTED
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Creating a new filesystem */
end_comment

begin_decl_stmt
specifier|static
name|fs_vtable_t
name|fs_vtable
init|=
block|{
name|svn_fs_base__youngest_rev
block|,
name|svn_fs_base__revision_prop
block|,
name|svn_fs_base__revision_proplist
block|,
name|svn_fs_base__change_rev_prop
block|,
name|svn_fs_base__set_uuid
block|,
name|svn_fs_base__revision_root
block|,
name|svn_fs_base__begin_txn
block|,
name|svn_fs_base__open_txn
block|,
name|svn_fs_base__purge_txn
block|,
name|svn_fs_base__list_transactions
block|,
name|svn_fs_base__deltify
block|,
name|svn_fs_base__lock
block|,
name|svn_fs_base__generate_lock_token
block|,
name|svn_fs_base__unlock
block|,
name|svn_fs_base__get_lock
block|,
name|svn_fs_base__get_locks
block|,
name|base_bdb_verify_root
block|,
name|base_bdb_freeze
block|,
name|base_bdb_set_errcall
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Where the format number is stored. */
end_comment

begin_define
define|#
directive|define
name|FORMAT_FILE
value|"format"
end_define

begin_comment
comment|/* Depending on CREATE, create or open the environment and databases    for filesystem FS in PATH. Use POOL for temporary allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_databases
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|create
parameter_list|,
name|int
name|format
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|bfd
operator|=
name|apr_pcalloc
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bfd
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|->
name|vtable
operator|=
operator|&
name|fs_vtable
expr_stmt|;
name|fs
operator|->
name|fsap_data
operator|=
name|bfd
expr_stmt|;
comment|/* Initialize the fs's path. */
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
condition|)
name|SVN_ERR
argument_list|(
name|bdb_write_config
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Create the Berkeley DB environment.  */
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_bdb__open
argument_list|(
operator|&
operator|(
name|bfd
operator|->
name|bdb
operator|)
argument_list|,
name|path
argument_list|,
name|SVN_BDB_STANDARD_ENV_FLAGS
argument_list|,
literal|0666
argument_list|,
name|fs
operator|->
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|create
condition|)
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Berkeley DB error for filesystem '%s'"
literal|" while creating environment:\n"
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|err
operator|->
name|apr_err
argument_list|,
name|err
argument_list|,
name|_
argument_list|(
literal|"Berkeley DB error for filesystem '%s'"
literal|" while opening environment:\n"
argument_list|)
argument_list|,
name|fs
operator|->
name|path
argument_list|)
return|;
block|}
block|}
comment|/* We must register the FS cleanup function *after* opening the      environment, so that it's run before the environment baton      cleanup. */
name|apr_pool_cleanup_register
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|fs
argument_list|,
name|cleanup_fs_apr
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
comment|/* Create the databases in the environment.  */
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'nodes' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'nodes' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_nodes_table
argument_list|(
operator|&
name|bfd
operator|->
name|nodes
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'revisions' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'revisions' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_revisions_table
argument_list|(
operator|&
name|bfd
operator|->
name|revisions
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'transactions' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'transactions' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_transactions_table
argument_list|(
operator|&
name|bfd
operator|->
name|transactions
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'copies' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'copies' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_copies_table
argument_list|(
operator|&
name|bfd
operator|->
name|copies
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'changes' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'changes' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_changes_table
argument_list|(
operator|&
name|bfd
operator|->
name|changes
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'representations' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'representations' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_reps_table
argument_list|(
operator|&
name|bfd
operator|->
name|representations
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'strings' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'strings' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_strings_table
argument_list|(
operator|&
name|bfd
operator|->
name|strings
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'uuids' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'uuids' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_uuids_table
argument_list|(
operator|&
name|bfd
operator|->
name|uuids
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'locks' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'locks' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_locks_table
argument_list|(
operator|&
name|bfd
operator|->
name|locks
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'lock-tokens' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'lock-tokens' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_lock_tokens_table
argument_list|(
operator|&
name|bfd
operator|->
name|lock_tokens
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|format
operator|>=
name|SVN_FS_BASE__MIN_NODE_ORIGINS_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'node-origins' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'node-origins' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_node_origins_table
argument_list|(
operator|&
name|bfd
operator|->
name|node_origins
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|>=
name|SVN_FS_BASE__MIN_MISCELLANY_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'miscellaneous' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'miscellaneous' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_miscellaneous_table
argument_list|(
operator|&
name|bfd
operator|->
name|miscellaneous
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|format
operator|>=
name|SVN_FS_BASE__MIN_REP_SHARING_FORMAT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
operator|(
name|create
condition|?
name|N_
argument_list|(
literal|"creating 'checksum-reps' table"
argument_list|)
else|:
name|N_
argument_list|(
literal|"opening 'checksum-reps' table"
argument_list|)
operator|)
argument_list|,
name|svn_fs_bdb__open_checksum_reps_table
argument_list|(
operator|&
name|bfd
operator|->
name|checksum_reps
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
name|create
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Called by functions that initialize an svn_fs_t struct, after that    initialization is done, to populate svn_fs_t->uuid. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|populate_opened_fs
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_base__populate_uuid
argument_list|(
name|fs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_create
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|int
name|format
init|=
name|SVN_FS_BASE__FORMAT_NUMBER
decl_stmt|;
name|svn_error_t
modifier|*
name|svn_err
decl_stmt|;
comment|/* See if compatibility with older versions was explicitly requested. */
if|if
condition|(
name|fs
operator|->
name|config
condition|)
block|{
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_4_COMPATIBLE
argument_list|)
condition|)
name|format
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_5_COMPATIBLE
argument_list|)
condition|)
name|format
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_6_COMPATIBLE
argument_list|)
condition|)
name|format
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Create the environment and databases. */
name|svn_err
operator|=
name|open_databases
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|,
name|format
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|error
goto|;
comment|/* Initialize the DAG subsystem. */
name|svn_err
operator|=
name|svn_fs_base__dag_init_fs
argument_list|(
name|fs
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|error
goto|;
comment|/* This filesystem is ready.  Stamp it with a format number. */
name|svn_err
operator|=
name|svn_io_write_version_file
argument_list|(
name|svn_dirent_join
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|FORMAT_FILE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|format
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|error
goto|;
operator|(
operator|(
name|base_fs_data_t
operator|*
operator|)
name|fs
operator|->
name|fsap_data
operator|)
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|SVN_ERR
argument_list|(
name|populate_opened_fs
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
empty_stmt|;
name|error
label|:
name|svn_error_clear
argument_list|(
name|cleanup_fs
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Gaining access to an existing Berkeley DB-based filesystem.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__test_required_feature_format
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|int
name|requires
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|bfd
operator|->
name|format
operator|<
name|requires
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The '%s' feature requires version %d of the filesystem schema; "
literal|"filesystem '%s' uses only version %d"
argument_list|)
argument_list|,
name|feature
argument_list|,
name|requires
argument_list|,
name|fs
operator|->
name|path
argument_list|,
name|bfd
operator|->
name|format
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return the error SVN_ERR_FS_UNSUPPORTED_FORMAT if FS's format    number is not the same as the format number supported by this    Subversion. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_format
parameter_list|(
name|int
name|format
parameter_list|)
block|{
comment|/* We currently support any format less than the compiled format number      simultaneously.  */
if|if
condition|(
name|format
operator|<=
name|SVN_FS_BASE__FORMAT_NUMBER
condition|)
return|return
name|SVN_NO_ERROR
return|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_UNSUPPORTED_FORMAT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Expected FS format '%d'; found format '%d'"
argument_list|)
argument_list|,
name|SVN_FS_BASE__FORMAT_NUMBER
argument_list|,
name|format
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_open
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
name|int
name|format
decl_stmt|;
name|svn_error_t
modifier|*
name|svn_err
decl_stmt|;
name|svn_boolean_t
name|write_format_file
init|=
name|FALSE
decl_stmt|;
comment|/* Read the FS format number. */
name|svn_err
operator|=
name|svn_io_read_version_file
argument_list|(
operator|&
name|format
argument_list|,
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|FORMAT_FILE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|svn_err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* Pre-1.2 filesystems did not have a format file (you could say          they were format "0"), so they get upgraded on the fly.          However, we stopped "upgrading on the fly" in 1.5, so older          filesystems should only be bumped to 1.3, which is format "1". */
name|svn_error_clear
argument_list|(
name|svn_err
argument_list|)
expr_stmt|;
name|svn_err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
name|format
operator|=
literal|1
expr_stmt|;
name|write_format_file
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|error
goto|;
comment|/* Create the environment and databases. */
name|svn_err
operator|=
name|open_databases
argument_list|(
name|fs
argument_list|,
name|FALSE
argument_list|,
name|format
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|error
goto|;
operator|(
operator|(
name|base_fs_data_t
operator|*
operator|)
name|fs
operator|->
name|fsap_data
operator|)
operator|->
name|format
operator|=
name|format
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_format
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we lack a format file, write one. */
if|if
condition|(
name|write_format_file
condition|)
block|{
name|svn_err
operator|=
name|svn_io_write_version_file
argument_list|(
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|FORMAT_FILE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|format
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_err
condition|)
goto|goto
name|error
goto|;
block|}
name|SVN_ERR
argument_list|(
name|populate_opened_fs
argument_list|(
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
name|error
label|:
name|svn_error_clear
argument_list|(
name|cleanup_fs
argument_list|(
name|fs
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_err
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Running recovery on a Berkeley DB-based filesystem.  */
end_comment

begin_comment
comment|/* Recover a database at PATH. Perform catastrophic recovery if FATAL    is TRUE. Use POOL for temporary allocation. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bdb_recover
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|fatal
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|bdb_env_baton_t
modifier|*
name|bdb
decl_stmt|;
comment|/* Here's the comment copied from db_recover.c:       Initialize the environment -- we don't actually do anything      else, that all that's needed to run recovery.       Note that we specify a private environment, as we're about to      create a region, and we don't want to leave it around.  If we      leave the region around, the application that should create it      will simply join it instead, and will then be running with      incorrectly sized (and probably terribly small) caches.  */
comment|/* Note that since we're using a private environment, we shoudl      /not/ initialize locking. We want the environment files to go      away. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__open
argument_list|(
operator|&
name|bdb
argument_list|,
name|path
argument_list|,
operator|(
operator|(
name|fatal
condition|?
name|DB_RECOVER_FATAL
else|:
name|DB_RECOVER
operator|)
operator||
name|SVN_BDB_PRIVATE_ENV_FLAGS
operator|)
argument_list|,
literal|0666
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_bdb__close
argument_list|(
name|bdb
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_open_for_recovery
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
comment|/* Just stash the path in the fs pointer - it's all we really need. */
name|fs
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|fs
operator|->
name|pool
argument_list|,
name|path
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_upgrade
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|version_file_path
decl_stmt|;
name|int
name|old_format_number
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|version_file_path
operator|=
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|FORMAT_FILE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Read the old number so we've got it on hand later on. */
name|err
operator|=
name|svn_io_read_version_file
argument_list|(
operator|&
name|old_format_number
argument_list|,
name|version_file_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
comment|/* Pre-1.2 filesystems do not have a 'format' file. */
name|old_format_number
operator|=
literal|0
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Bump the format file's stored version number. */
name|SVN_ERR
argument_list|(
name|svn_io_write_version_file
argument_list|(
name|version_file_path
argument_list|,
name|SVN_FS_BASE__FORMAT_NUMBER
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check and see if we need to record the "bump" revision. */
if|if
condition|(
name|old_format_number
operator|<
name|SVN_FS_BASE__MIN_FORWARD_DELTAS_FORMAT
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|value
decl_stmt|;
comment|/* Open the filesystem in a subpool (so we can control its          closure) and do our fiddling.           NOTE: By using base_open() here instead of open_databases(),          we will end up re-reading the format file that we just wrote.          But it's better to use the existing encapsulation of "opening          the filesystem" rather than duplicating (or worse, partially          duplicating) that logic here.  */
name|SVN_ERR
argument_list|(
name|base_open
argument_list|(
name|fs
argument_list|,
name|path
argument_list|,
name|subpool
argument_list|,
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the youngest rev, and record it */
name|SVN_ERR
argument_list|(
name|svn_fs_base__youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|fs
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|apr_psprintf
argument_list|(
name|subpool
argument_list|,
literal|"%ld"
argument_list|,
name|youngest_rev
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__miscellaneous_set
argument_list|(
name|fs
argument_list|,
name|SVN_FS_BASE__MISC_FORWARD_DELTA_UPGRADE
argument_list|,
name|value
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_verify
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|start
parameter_list|,
name|svn_revnum_t
name|end
parameter_list|,
name|svn_fs_progress_notify_func_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
comment|/* Verifying is currently a no op for BDB. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_bdb_recover
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* The fs pointer is a fake created in base_open_for_recovery above.      We only care about the path. */
return|return
name|bdb_recover
argument_list|(
name|fs
operator|->
name|path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_bdb_pack
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_fs_pack_notify_t
name|notify_func
parameter_list|,
name|void
modifier|*
name|notify_baton
parameter_list|,
name|svn_cancel_func_t
name|cancel
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
comment|/* Packing is currently a no op for BDB. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Running the 'archive' command on a Berkeley DB-based filesystem.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_bdb_logfiles
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|logfiles
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|only_unused
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|bdb_env_baton_t
modifier|*
name|bdb
decl_stmt|;
name|char
modifier|*
modifier|*
name|filelist
decl_stmt|;
name|char
modifier|*
modifier|*
name|filename
decl_stmt|;
name|u_int32_t
name|flags
init|=
name|only_unused
condition|?
literal|0
else|:
name|DB_ARCH_LOG
decl_stmt|;
operator|*
name|logfiles
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__open
argument_list|(
operator|&
name|bdb
argument_list|,
name|path
argument_list|,
name|SVN_BDB_STANDARD_ENV_FLAGS
argument_list|,
literal|0666
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_BDB_ERR
argument_list|(
name|bdb
argument_list|,
name|bdb
operator|->
name|env
operator|->
name|log_archive
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
operator|&
name|filelist
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|filelist
operator|==
name|NULL
condition|)
return|return
name|svn_fs_bdb__close
argument_list|(
name|bdb
argument_list|)
return|;
for|for
control|(
name|filename
operator|=
name|filelist
init|;
operator|*
name|filename
operator|!=
name|NULL
condition|;
operator|++
name|filename
control|)
block|{
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|logfiles
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
operator|*
name|filename
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|filelist
argument_list|)
expr_stmt|;
return|return
name|svn_fs_bdb__close
argument_list|(
name|bdb
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copying a live Berkeley DB-base filesystem.  */
end_comment

begin_comment
comment|/**  * Delete all unused log files from DBD enviroment at @a live_path that exist  * in @a backup_path.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_fs_base__clean_logs
parameter_list|(
specifier|const
name|char
modifier|*
name|live_path
parameter_list|,
specifier|const
name|char
modifier|*
name|backup_path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|logfiles
decl_stmt|;
name|SVN_ERR
argument_list|(
name|base_bdb_logfiles
argument_list|(
operator|&
name|logfiles
argument_list|,
name|live_path
argument_list|,
name|TRUE
argument_list|,
comment|/* Only unused logs */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
comment|/* Process unused logs from live area */
name|int
name|idx
decl_stmt|;
name|apr_pool_t
modifier|*
name|sub_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Process log files. */
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|logfiles
operator|->
name|nelts
condition|;
name|idx
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|log_file
init|=
name|APR_ARRAY_IDX
argument_list|(
name|logfiles
argument_list|,
name|idx
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|live_log_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|backup_log_path
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|sub_pool
argument_list|)
expr_stmt|;
name|live_log_path
operator|=
name|svn_dirent_join
argument_list|(
name|live_path
argument_list|,
name|log_file
argument_list|,
name|sub_pool
argument_list|)
expr_stmt|;
name|backup_log_path
operator|=
name|svn_dirent_join
argument_list|(
name|backup_path
argument_list|,
name|log_file
argument_list|,
name|sub_pool
argument_list|)
expr_stmt|;
block|{
comment|/* Compare files. No point in using MD5 and wasting CPU cycles as we              got full copies of both logs */
name|svn_boolean_t
name|files_match
init|=
name|FALSE
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* Check to see if there is a corresponding log file in the backup              directory */
name|SVN_ERR
argument_list|(
name|svn_io_check_path
argument_list|(
name|backup_log_path
argument_list|,
operator|&
name|kind
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the copy of the log exists, compare them */
if|if
condition|(
name|kind
operator|==
name|svn_node_file
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_files_contents_same_p
argument_list|(
operator|&
name|files_match
argument_list|,
name|live_log_path
argument_list|,
name|backup_log_path
argument_list|,
name|sub_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If log files do not match, go to the next log file. */
if|if
condition|(
operator|!
name|files_match
condition|)
continue|continue;
block|}
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|live_log_path
argument_list|,
name|FALSE
argument_list|,
name|sub_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|sub_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* DB_ENV->get_flags() and DB->get_pagesize() don't exist prior to    Berkeley DB 4.2. */
end_comment

begin_if
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|2
argument_list|)
end_if

begin_comment
comment|/* Open the BDB environment at PATH and compare its configuration    flags with FLAGS.  If every flag in FLAGS is set in the    environment, then set *MATCH to true.  Else set *MATCH to false. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_env_flags
parameter_list|(
name|svn_boolean_t
modifier|*
name|match
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|bdb_env_baton_t
modifier|*
name|bdb
decl_stmt|;
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|7
argument_list|)
name|int
name|flag_state
decl_stmt|;
else|#
directive|else
name|u_int32_t
name|envflags
decl_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__open
argument_list|(
operator|&
name|bdb
argument_list|,
name|path
argument_list|,
name|SVN_BDB_STANDARD_ENV_FLAGS
argument_list|,
literal|0666
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|7
argument_list|)
name|SVN_BDB_ERR
argument_list|(
name|bdb
argument_list|,
name|bdb
operator|->
name|env
operator|->
name|log_get_config
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
name|flags
argument_list|,
operator|&
name|flag_state
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|SVN_BDB_ERR
argument_list|(
name|bdb
argument_list|,
name|bdb
operator|->
name|env
operator|->
name|get_flags
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
operator|&
name|envflags
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__close
argument_list|(
name|bdb
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|7
argument_list|)
if|if
condition|(
name|flag_state
operator|==
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|flags
operator|&
name|envflags
condition|)
endif|#
directive|endif
operator|*
name|match
operator|=
name|TRUE
expr_stmt|;
else|else
operator|*
name|match
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *PAGESIZE to the size of pages used to hold items in the    database environment located at PATH. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_db_pagesize
parameter_list|(
name|u_int32_t
modifier|*
name|pagesize
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|bdb_env_baton_t
modifier|*
name|bdb
decl_stmt|;
name|DB
modifier|*
name|nodes_table
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__open
argument_list|(
operator|&
name|bdb
argument_list|,
name|path
argument_list|,
name|SVN_BDB_STANDARD_ENV_FLAGS
argument_list|,
literal|0666
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### We're only asking for the pagesize on the 'nodes' table.          Is this enough?  We never call DB->set_pagesize() on any of          our tables, so presumably BDB is using the same default          pagesize for all our databases, right? */
name|SVN_BDB_ERR
argument_list|(
name|bdb
argument_list|,
name|svn_fs_bdb__open_nodes_table
argument_list|(
operator|&
name|nodes_table
argument_list|,
name|bdb
operator|->
name|env
argument_list|,
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_BDB_ERR
argument_list|(
name|bdb
argument_list|,
name|nodes_table
operator|->
name|get_pagesize
argument_list|(
name|nodes_table
argument_list|,
name|pagesize
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_BDB_ERR
argument_list|(
name|bdb
argument_list|,
name|nodes_table
operator|->
name|close
argument_list|(
name|nodes_table
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_bdb__close
argument_list|(
name|bdb
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SVN_BDB_VERSION_AT_LEAST(4, 2) */
end_comment

begin_comment
comment|/* Copy FILENAME from SRC_DIR to DST_DIR in byte increments of size    CHUNKSIZE.  The read/write buffer of size CHUNKSIZE will be    allocated in POOL.  If ALLOW_MISSING is set, we won't make a fuss    if FILENAME isn't found in SRC_DIR; otherwise, we will.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_db_file_safely
parameter_list|(
specifier|const
name|char
modifier|*
name|src_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_dir
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|u_int32_t
name|chunksize
parameter_list|,
name|svn_boolean_t
name|allow_missing
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|s
init|=
name|NULL
decl_stmt|,
modifier|*
name|d
init|=
name|NULL
decl_stmt|;
comment|/* init to null important for APR */
specifier|const
name|char
modifier|*
name|file_src_path
init|=
name|svn_dirent_join
argument_list|(
name|src_dir
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|file_dst_path
init|=
name|svn_dirent_join
argument_list|(
name|dst_dir
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Open source file.  If it's missing and that's allowed, there's      nothing more to do here. */
name|err
operator|=
name|svn_io_file_open
argument_list|(
operator|&
name|s
argument_list|,
name|file_src_path
argument_list|,
operator|(
name|APR_READ
operator||
name|APR_LARGEFILE
operator|)
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|APR_STATUS_IS_ENOENT
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
operator|&&
name|allow_missing
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Open destination file. */
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|d
argument_list|,
name|file_dst_path
argument_list|,
operator|(
name|APR_WRITE
operator||
name|APR_CREATE
operator||
name|APR_LARGEFILE
operator|)
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate our read/write buffer. */
name|buf
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|chunksize
argument_list|)
expr_stmt|;
comment|/* Copy bytes till the cows come home. */
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|bytes_this_time
init|=
name|chunksize
decl_stmt|;
name|svn_error_t
modifier|*
name|read_err
decl_stmt|,
modifier|*
name|write_err
decl_stmt|;
comment|/* Read 'em. */
if|if
condition|(
operator|(
name|read_err
operator|=
name|svn_io_file_read
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
operator|&
name|bytes_this_time
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|read_err
operator|->
name|apr_err
argument_list|)
condition|)
name|svn_error_clear
argument_list|(
name|read_err
argument_list|)
expr_stmt|;
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_io_file_close
argument_list|(
name|s
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_file_close
argument_list|(
name|d
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|read_err
return|;
block|}
block|}
comment|/* Write 'em. */
if|if
condition|(
operator|(
name|write_err
operator|=
name|svn_io_file_write_full
argument_list|(
name|d
argument_list|,
name|buf
argument_list|,
name|bytes_this_time
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_io_file_close
argument_list|(
name|s
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_io_file_close
argument_list|(
name|d
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|write_err
return|;
block|}
comment|/* read_err is either NULL, or a dangling pointer - but it is only a          dangling pointer if it used to be an EOF error. */
if|if
condition|(
name|read_err
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|s
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|d
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* got EOF on read, all files closed, all done. */
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_hotcopy
parameter_list|(
name|svn_fs_t
modifier|*
name|src_fs
parameter_list|,
name|svn_fs_t
modifier|*
name|dst_fs
parameter_list|,
specifier|const
name|char
modifier|*
name|src_path
parameter_list|,
specifier|const
name|char
modifier|*
name|dest_path
parameter_list|,
name|svn_boolean_t
name|clean_logs
parameter_list|,
name|svn_boolean_t
name|incremental
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|u_int32_t
name|pagesize
decl_stmt|;
name|svn_boolean_t
name|log_autoremove
init|=
name|FALSE
decl_stmt|;
name|int
name|format
decl_stmt|;
if|if
condition|(
name|incremental
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"BDB repositories do not support incremental "
literal|"hotcopy"
argument_list|)
argument_list|)
return|;
comment|/* Check the FS format number to be certain that we know how to      hotcopy this FS.  Pre-1.2 filesystems did not have a format file (you      could say they were format "0"), so we will error here.  This is not      optimal, but since this has been the case since 1.2.0, and no one has      complained, it apparently isn't much of a concern.  (We did not check      the 'format' file in 1.2.x, but we did blindly try to copy 'locks',      which would have errored just the same.)  */
name|SVN_ERR
argument_list|(
name|svn_io_read_version_file
argument_list|(
operator|&
name|format
argument_list|,
name|svn_dirent_join
argument_list|(
name|src_path
argument_list|,
name|FORMAT_FILE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_format
argument_list|(
name|format
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If using Berkeley DB 4.2 or later, note whether the DB_LOG_AUTO_REMOVE      feature is on.  If it is, we have a potential race condition:      another process might delete a logfile while we're in the middle      of copying all the logfiles.  (This is not a huge deal; at worst,      the hotcopy fails with a file-not-found error.) */
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|2
argument_list|)
name|err
operator|=
name|check_env_flags
argument_list|(
operator|&
name|log_autoremove
argument_list|,
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|7
argument_list|)
name|DB_LOG_AUTO_REMOVE
argument_list|,
comment|/* DB_LOG_AUTO_REMOVE was named DB_LOG_AUTOREMOVE before Berkeley DB 4.7. */
else|#
directive|else
name|DB_LOG_AUTOREMOVE
argument_list|,
endif|#
directive|endif
name|src_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Copy the DB_CONFIG file. */
name|SVN_ERR
argument_list|(
name|svn_io_dir_file_copy
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"DB_CONFIG"
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* In order to copy the database files safely and atomically, we      must copy them in chunks which are multiples of the page-size      used by BDB.  See sleepycat docs for details, or svn issue #1818. */
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|2
argument_list|)
name|SVN_ERR
argument_list|(
name|get_db_pagesize
argument_list|(
operator|&
name|pagesize
argument_list|,
name|src_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pagesize
operator|<
name|SVN__STREAM_CHUNK_SIZE
condition|)
block|{
comment|/* use the largest multiple of BDB pagesize we can. */
name|int
name|multiple
init|=
name|SVN__STREAM_CHUNK_SIZE
operator|/
name|pagesize
decl_stmt|;
name|pagesize
operator|*=
name|multiple
expr_stmt|;
block|}
else|#
directive|else
comment|/* default to 128K chunks, which should be safe.      BDB almost certainly uses a power-of-2 pagesize. */
name|pagesize
operator|=
operator|(
literal|4096
operator|*
literal|32
operator|)
expr_stmt|;
endif|#
directive|endif
comment|/* Copy the databases.  */
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"nodes"
argument_list|,
name|pagesize
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"transactions"
argument_list|,
name|pagesize
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"revisions"
argument_list|,
name|pagesize
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"copies"
argument_list|,
name|pagesize
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"changes"
argument_list|,
name|pagesize
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"representations"
argument_list|,
name|pagesize
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"strings"
argument_list|,
name|pagesize
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"uuids"
argument_list|,
name|pagesize
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"locks"
argument_list|,
name|pagesize
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"lock-tokens"
argument_list|,
name|pagesize
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"node-origins"
argument_list|,
name|pagesize
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"checksum-reps"
argument_list|,
name|pagesize
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|copy_db_file_safely
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
literal|"miscellaneous"
argument_list|,
name|pagesize
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|{
name|apr_array_header_t
modifier|*
name|logfiles
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|base_bdb_logfiles
argument_list|(
operator|&
name|logfiles
argument_list|,
name|src_path
argument_list|,
name|FALSE
argument_list|,
comment|/* All logs */
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process log files. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|idx
operator|=
literal|0
init|;
name|idx
operator|<
name|logfiles
operator|->
name|nelts
condition|;
name|idx
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_io_dir_file_copy
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|logfiles
argument_list|,
name|idx
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|log_autoremove
condition|)
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Error copying logfile;  the DB_LOG_AUTOREMOVE feature\n"
literal|"may be interfering with the hotcopy algorithm.  If\n"
literal|"the problem persists, try deactivating this feature\n"
literal|"in DB_CONFIG"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* Since this is a copy we will have exclusive access to the repository. */
name|err
operator|=
name|bdb_recover
argument_list|(
name|dest_path
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|log_autoremove
condition|)
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Error running catastrophic recovery on hotcopy;  the\n"
literal|"DB_LOG_AUTOREMOVE feature may be interfering with the\n"
literal|"hotcopy algorithm.  If the problem persists, try deactivating\n"
literal|"this feature in DB_CONFIG"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* Only now that the hotcopied filesystem is complete,      stamp it with a format file. */
name|SVN_ERR
argument_list|(
name|svn_io_write_version_file
argument_list|(
name|svn_dirent_join
argument_list|(
name|dest_path
argument_list|,
name|FORMAT_FILE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|format
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clean_logs
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_base__clean_logs
argument_list|(
name|src_path
argument_list|,
name|dest_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Deleting a Berkeley DB-based filesystem.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_delete_fs
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* First, use the Berkeley DB library function to remove any shared      memory segments.  */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__remove
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Remove the environment directory. */
return|return
name|svn_io_remove_dir2
argument_list|(
name|path
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|svn_version_t
modifier|*
name|base_version
parameter_list|(
name|void
parameter_list|)
block|{
name|SVN_VERSION_BODY
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|base_get_description
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|_
argument_list|(
literal|"Module for working with a Berkeley DB repository."
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|base_set_svn_fs_open
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|svn_fs_open_
function_decl|)
parameter_list|(
name|svn_fs_t
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|apr_hash_t
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Base FS library vtable, used by the FS loader library. */
end_comment

begin_decl_stmt
specifier|static
name|fs_library_vtable_t
name|library_vtable
init|=
block|{
name|base_version
block|,
name|base_create
block|,
name|base_open
block|,
name|base_open_for_recovery
block|,
name|base_upgrade
block|,
name|base_verify
block|,
name|base_delete_fs
block|,
name|base_hotcopy
block|,
name|base_get_description
block|,
name|base_bdb_recover
block|,
name|base_bdb_pack
block|,
name|base_bdb_logfiles
block|,
name|svn_fs_base__id_parse
block|,
name|base_set_svn_fs_open
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__init
parameter_list|(
specifier|const
name|svn_version_t
modifier|*
name|loader_version
parameter_list|,
name|fs_library_vtable_t
modifier|*
modifier|*
name|vtable
parameter_list|,
name|apr_pool_t
modifier|*
name|common_pool
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
comment|/* Simplified version check to make sure we can safely use the      VTABLE parameter. The FS loader does a more exhaustive check. */
if|if
condition|(
name|loader_version
operator|->
name|major
operator|!=
name|SVN_VER_MAJOR
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_VERSION_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unsupported FS loader version (%d) for bdb"
argument_list|)
argument_list|,
name|loader_version
operator|->
name|major
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_ver_check_list2
argument_list|(
name|base_version
argument_list|()
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_bdb_version
argument_list|()
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__init
argument_list|(
name|common_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|vtable
operator|=
operator|&
name|library_vtable
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

