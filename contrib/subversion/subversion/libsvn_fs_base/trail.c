begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* trail.c : backing out of aborted Berkeley DB transactions  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_define
define|#
directive|define
name|SVN_WANT_BDB
end_define

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"fs.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"bdb/bdb-err.h"
end_include

begin_include
include|#
directive|include
file|"bdb/bdb_compat.h"
end_include

begin_include
include|#
directive|include
file|"trail.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SVN_FS__TRAIL_DEBUG
argument_list|)
end_if

begin_struct
struct|struct
name|trail_debug_t
block|{
name|struct
name|trail_debug_t
modifier|*
name|prev
decl_stmt|;
specifier|const
name|char
modifier|*
name|table
decl_stmt|;
specifier|const
name|char
modifier|*
name|op
decl_stmt|;
block|}
struct|;
end_struct

begin_function
name|void
name|svn_fs_base__trail_debug
parameter_list|(
name|trail_t
modifier|*
name|trail
parameter_list|,
specifier|const
name|char
modifier|*
name|table
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|)
block|{
name|struct
name|trail_debug_t
modifier|*
name|trail_debug
decl_stmt|;
name|trail_debug
operator|=
name|apr_palloc
argument_list|(
name|trail
operator|->
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|trail_debug
argument_list|)
argument_list|)
expr_stmt|;
name|trail_debug
operator|->
name|prev
operator|=
name|trail
operator|->
name|trail_debug
expr_stmt|;
name|trail_debug
operator|->
name|table
operator|=
name|table
expr_stmt|;
name|trail_debug
operator|->
name|op
operator|=
name|op
expr_stmt|;
name|trail
operator|->
name|trail_debug
operator|=
name|trail_debug
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_trail_debug
parameter_list|(
name|trail_t
modifier|*
name|trail
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_body_fn_name
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|struct
name|trail_debug_t
modifier|*
name|trail_debug
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%s, %s, %u, %u): "
argument_list|,
name|txn_body_fn_name
argument_list|,
name|filename
argument_list|,
name|line
argument_list|,
name|trail
operator|->
name|db_txn
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|trail_debug
operator|=
name|trail
operator|->
name|trail_debug
expr_stmt|;
while|while
condition|(
name|trail_debug
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(%s, %s) "
argument_list|,
name|trail_debug
operator|->
name|table
argument_list|,
name|trail_debug
operator|->
name|op
argument_list|)
expr_stmt|;
name|trail_debug
operator|=
name|trail_debug
operator|->
name|prev
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|print_trail_debug
parameter_list|(
name|trail
parameter_list|,
name|txn_body_fn_name
parameter_list|,
name|filename
parameter_list|,
name|line
parameter_list|)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* defined(SVN_FS__TRAIL_DEBUG) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|begin_trail
parameter_list|(
name|trail_t
modifier|*
modifier|*
name|trail_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_boolean_t
name|use_txn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|trail_t
modifier|*
name|trail
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|trail
argument_list|)
argument_list|)
decl_stmt|;
name|trail
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|trail
operator|->
name|fs
operator|=
name|fs
expr_stmt|;
if|if
condition|(
name|use_txn
condition|)
block|{
comment|/* [*]          If we're already inside a trail operation, abort() -- this is          a coding problem (and will likely hang the repository anyway). */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|bfd
operator|->
name|in_txn_trail
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"beginning Berkeley DB transaction"
argument_list|)
argument_list|,
name|bfd
operator|->
name|bdb
operator|->
name|env
operator|->
name|txn_begin
argument_list|(
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
literal|0
argument_list|,
operator|&
name|trail
operator|->
name|db_txn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|bfd
operator|->
name|in_txn_trail
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|trail
operator|->
name|db_txn
operator|=
name|NULL
expr_stmt|;
block|}
operator|*
name|trail_p
operator|=
name|trail
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_trail
parameter_list|(
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|trail
operator|->
name|fs
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
if|if
condition|(
name|trail
operator|->
name|db_txn
condition|)
block|{
comment|/* [**]          We have to reset the in_txn_trail flag *before* calling          DB_TXN->abort().  If we did it the other way around, the next          call to begin_trail() (e.g., as part of a txn retry) would          cause an abort, even though there's strictly speaking no          programming error involved (see comment [*] above).           In any case, if aborting the txn fails, restarting it will          most likely fail for the same reason, and so it's better to          see the returned error than to abort.  An obvious example is          when DB_TXN->abort() returns DB_RUNRECOVERY. */
name|bfd
operator|->
name|in_txn_trail
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"aborting Berkeley DB transaction"
argument_list|)
argument_list|,
name|trail
operator|->
name|db_txn
operator|->
name|abort
argument_list|(
name|trail
operator|->
name|db_txn
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|commit_trail
parameter_list|(
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|int
name|db_err
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|trail
operator|->
name|fs
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
comment|/* According to the example in the Berkeley DB manual, txn_commit      doesn't return DB_LOCK_DEADLOCK --- all deadlocks are reported      earlier.  */
if|if
condition|(
name|trail
operator|->
name|db_txn
condition|)
block|{
comment|/* See comment [**] in abort_trail() above.          An error during txn commit will abort the transaction anyway. */
name|bfd
operator|->
name|in_txn_trail
operator|=
name|FALSE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"committing Berkeley DB transaction"
argument_list|)
argument_list|,
name|trail
operator|->
name|db_txn
operator|->
name|commit
argument_list|(
name|trail
operator|->
name|db_txn
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Do a checkpoint here, if enough has gone on.      The checkpoint parameters below are pretty arbitrary.  Perhaps      there should be an svn_fs_berkeley_mumble function to set them.  */
name|db_err
operator|=
name|bfd
operator|->
name|bdb
operator|->
name|env
operator|->
name|txn_checkpoint
argument_list|(
name|bfd
operator|->
name|bdb
operator|->
name|env
argument_list|,
literal|1024
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Pre-4.1 Berkeley documentation says:          The DB_ENV->txn_checkpoint function returns a non-zero error         value on failure, 0 on success, and returns DB_INCOMPLETE if         there were pages that needed to be written to complete the         checkpoint but that DB_ENV->memp_sync was unable to write         immediately.       It's safe to ignore DB_INCOMPLETE if we get it while      checkpointing.  (Post-4.1 Berkeley doesn't have DB_INCOMPLETE      anymore, so it's not an issue there.)  */
if|if
condition|(
name|db_err
condition|)
block|{
if|#
directive|if
name|SVN_BDB_HAS_DB_INCOMPLETE
if|if
condition|(
name|db_err
operator|!=
name|DB_INCOMPLETE
condition|)
endif|#
directive|endif
comment|/* SVN_BDB_HAS_DB_INCOMPLETE */
block|{
return|return
name|svn_fs_bdb__wrap_db
argument_list|(
name|fs
argument_list|,
literal|"checkpointing after Berkeley DB transaction"
argument_list|,
name|db_err
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_retry
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|txn_body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
name|use_txn
parameter_list|,
name|svn_boolean_t
name|destroy_trail_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_body_fn_name
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|trail_t
modifier|*
name|trail
decl_stmt|;
name|svn_error_t
modifier|*
name|svn_err
decl_stmt|,
modifier|*
name|err
decl_stmt|;
name|svn_boolean_t
name|deadlocked
init|=
name|FALSE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|begin_trail
argument_list|(
operator|&
name|trail
argument_list|,
name|fs
argument_list|,
name|use_txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Do the body of the transaction.  */
name|svn_err
operator|=
call|(
modifier|*
name|txn_body
call|)
argument_list|(
name|baton
argument_list|,
name|trail
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_err
condition|)
block|{
comment|/* The transaction succeeded!  Commit it.  */
name|SVN_ERR
argument_list|(
name|commit_trail
argument_list|(
name|trail
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_txn
condition|)
name|print_trail_debug
argument_list|(
name|trail
argument_list|,
name|txn_body_fn_name
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
expr_stmt|;
comment|/* If our caller doesn't want us to keep trail memory              around, destroy our subpool. */
if|if
condition|(
name|destroy_trail_pool
condition|)
name|svn_pool_destroy
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* Search for a deadlock error on the stack. */
for|for
control|(
name|err
operator|=
name|svn_err
init|;
name|err
condition|;
name|err
operator|=
name|err
operator|->
name|child
control|)
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_BERKELEY_DB_DEADLOCK
condition|)
name|deadlocked
operator|=
name|TRUE
expr_stmt|;
comment|/* Is this a real error, or do we just need to retry?  */
if|if
condition|(
operator|!
name|deadlocked
condition|)
block|{
comment|/* Ignore any error returns.  The first error is more valuable.  */
name|svn_error_clear
argument_list|(
name|abort_trail
argument_list|(
name|trail
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_err
return|;
block|}
name|svn_error_clear
argument_list|(
name|svn_err
argument_list|)
expr_stmt|;
comment|/* We deadlocked.  Abort the transaction, and try again.  */
name|SVN_ERR
argument_list|(
name|abort_trail
argument_list|(
name|trail
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__retry_debug
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|txn_body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
name|destroy_trail_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
specifier|const
name|char
modifier|*
name|txn_body_fn_name
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|int
name|line
parameter_list|)
block|{
return|return
name|do_retry
argument_list|(
name|fs
argument_list|,
name|txn_body
argument_list|,
name|baton
argument_list|,
name|TRUE
argument_list|,
name|destroy_trail_pool
argument_list|,
name|pool
argument_list|,
name|txn_body_fn_name
argument_list|,
name|filename
argument_list|,
name|line
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|SVN_FS__TRAIL_DEBUG
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|svn_fs_base__retry_txn
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__retry_txn
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|txn_body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
name|destroy_trail_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_retry
argument_list|(
name|fs
argument_list|,
name|txn_body
argument_list|,
name|baton
argument_list|,
name|TRUE
argument_list|,
name|destroy_trail_pool
argument_list|,
name|pool
argument_list|,
literal|"unknown"
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__retry
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_error_t
modifier|*
function_decl|(
modifier|*
name|txn_body
function_decl|)
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
name|destroy_trail_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_retry
argument_list|(
name|fs
argument_list|,
name|txn_body
argument_list|,
name|baton
argument_list|,
name|FALSE
argument_list|,
name|destroy_trail_pool
argument_list|,
name|pool
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

end_unit

