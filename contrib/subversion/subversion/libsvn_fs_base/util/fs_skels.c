begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* fs_skels.c --- conversion between fs native types and skeletons  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_include
include|#
directive|include
file|<apr_sha1.h>
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_skel.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"fs_skels.h"
end_include

begin_include
include|#
directive|include
file|"../id.h"
end_include

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|skel_err
parameter_list|(
specifier|const
name|char
modifier|*
name|skel_type
parameter_list|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_MALFORMED_SKEL
argument_list|,
name|NULL
argument_list|,
literal|"Malformed%s%s skeleton"
argument_list|,
name|skel_type
condition|?
literal|" "
else|:
literal|""
argument_list|,
name|skel_type
condition|?
name|skel_type
else|:
literal|""
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Validity Checking ***/
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_checksum_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"md5"
argument_list|)
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"sha1"
argument_list|)
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_revision_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
name|len
operator|==
literal|2
operator|)
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"revision"
argument_list|)
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_transaction_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|transaction_kind_t
modifier|*
name|kind
parameter_list|)
block|{
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|!=
literal|5
condition|)
return|return
name|FALSE
return|;
comment|/* Determine (and verify) the kind. */
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"transaction"
argument_list|)
condition|)
operator|*
name|kind
operator|=
name|transaction_kind_normal
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"committed"
argument_list|)
condition|)
operator|*
name|kind
operator|=
name|transaction_kind_committed
expr_stmt|;
elseif|else
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"dead"
argument_list|)
condition|)
operator|*
name|kind
operator|=
name|transaction_kind_dead
expr_stmt|;
else|else
return|return
name|FALSE
return|;
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
operator|(
operator|!
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
operator|&&
operator|(
operator|!
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_rep_delta_chunk_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|int
name|len
decl_stmt|;
name|svn_skel_t
modifier|*
name|window
decl_stmt|;
name|svn_skel_t
modifier|*
name|diff
decl_stmt|;
comment|/* check the delta skel. */
if|if
condition|(
operator|(
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
operator|!=
literal|2
operator|)
operator|||
operator|(
operator|!
name|skel
operator|->
name|children
operator|->
name|is_atom
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* check the window. */
name|window
operator|=
name|skel
operator|->
name|children
operator|->
name|next
expr_stmt|;
name|len
operator|=
name|svn_skel__list_length
argument_list|(
name|window
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|len
operator|<
literal|3
operator|)
operator|||
operator|(
name|len
operator|>
literal|4
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|!
name|window
operator|->
name|children
operator|->
name|is_atom
operator|)
operator|&&
operator|(
name|window
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|)
operator|&&
operator|(
name|window
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|(
name|len
operator|==
literal|4
operator|)
operator|&&
operator|(
operator|!
name|window
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* check the diff. ### currently we support only svndiff version      0 delta data. */
name|diff
operator|=
name|window
operator|->
name|children
expr_stmt|;
if|if
condition|(
operator|(
name|svn_skel__list_length
argument_list|(
name|diff
argument_list|)
operator|==
literal|3
operator|)
operator|&&
operator|(
name|svn_skel__matches_atom
argument_list|(
name|diff
operator|->
name|children
argument_list|,
literal|"svndiff"
argument_list|)
operator|)
operator|&&
operator|(
operator|(
name|svn_skel__matches_atom
argument_list|(
name|diff
operator|->
name|children
operator|->
name|next
argument_list|,
literal|"0"
argument_list|)
operator|)
operator|||
operator|(
name|svn_skel__matches_atom
argument_list|(
name|diff
operator|->
name|children
operator|->
name|next
argument_list|,
literal|"1"
argument_list|)
operator|)
operator|)
operator|&&
operator|(
name|diff
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_representation_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|header
decl_stmt|;
name|int
name|header_len
decl_stmt|;
comment|/* the rep has at least two items in it, a HEADER list, and at least      one piece of kind-specific data. */
if|if
condition|(
name|len
operator|<
literal|2
condition|)
return|return
name|FALSE
return|;
comment|/* check the header.  it must have KIND and TXN atoms, and      optionally 1 or 2 checksums (which is a list form). */
name|header
operator|=
name|skel
operator|->
name|children
expr_stmt|;
name|header_len
operator|=
name|svn_skel__list_length
argument_list|(
name|header
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
operator|(
name|header_len
operator|==
literal|2
operator|)
comment|/* 2 means old repository, checksum absent */
operator|&&
operator|(
name|header
operator|->
name|children
operator|->
name|is_atom
operator|)
operator|&&
operator|(
name|header
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|)
operator|)
operator|||
operator|(
operator|(
name|header_len
operator|==
literal|3
operator|)
comment|/* 3 means md5 checksum present */
operator|&&
operator|(
name|header
operator|->
name|children
operator|->
name|is_atom
operator|)
operator|&&
operator|(
name|header
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|)
operator|&&
operator|(
name|is_valid_checksum_skel
argument_list|(
name|header
operator|->
name|children
operator|->
name|next
operator|->
name|next
argument_list|)
operator|)
operator|)
operator|||
operator|(
operator|(
name|header_len
operator|==
literal|4
operator|)
comment|/* 3 means md5 and sha1 checksums present */
operator|&&
operator|(
name|header
operator|->
name|children
operator|->
name|is_atom
operator|)
operator|&&
operator|(
name|header
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|)
operator|&&
operator|(
name|is_valid_checksum_skel
argument_list|(
name|header
operator|->
name|children
operator|->
name|next
operator|->
name|next
argument_list|)
operator|)
operator|&&
operator|(
name|is_valid_checksum_skel
argument_list|(
name|header
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
argument_list|)
operator|)
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* check for fulltext rep. */
if|if
condition|(
operator|(
name|len
operator|==
literal|2
operator|)
operator|&&
operator|(
name|svn_skel__matches_atom
argument_list|(
name|header
operator|->
name|children
argument_list|,
literal|"fulltext"
argument_list|)
operator|)
condition|)
return|return
name|TRUE
return|;
comment|/* check for delta rep. */
if|if
condition|(
operator|(
name|len
operator|>=
literal|2
operator|)
operator|&&
operator|(
name|svn_skel__matches_atom
argument_list|(
name|header
operator|->
name|children
argument_list|,
literal|"delta"
argument_list|)
operator|)
condition|)
block|{
comment|/* it's a delta rep.  check the validity.  */
name|svn_skel_t
modifier|*
name|chunk
init|=
name|skel
operator|->
name|children
operator|->
name|next
decl_stmt|;
comment|/* loop over chunks, checking each one. */
while|while
condition|(
name|chunk
condition|)
block|{
if|if
condition|(
operator|!
name|is_valid_rep_delta_chunk_skel
argument_list|(
name|chunk
argument_list|)
condition|)
return|return
name|FALSE
return|;
name|chunk
operator|=
name|chunk
operator|->
name|next
expr_stmt|;
block|}
comment|/* all good on this delta rep. */
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_node_revision_header_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|svn_skel_t
modifier|*
modifier|*
name|kind_p
parameter_list|)
block|{
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|2
condition|)
return|return
name|FALSE
return|;
comment|/* set the *KIND_P pointer. */
operator|*
name|kind_p
operator|=
name|skel
operator|->
name|children
expr_stmt|;
comment|/* check for valid lengths. */
if|if
condition|(
operator|!
operator|(
operator|(
name|len
operator|==
literal|2
operator|)
operator|||
operator|(
name|len
operator|==
literal|3
operator|)
operator|||
operator|(
name|len
operator|==
literal|4
operator|)
operator|||
operator|(
name|len
operator|==
literal|6
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* got mergeinfo stuff? */
if|if
condition|(
operator|(
name|len
operator|>
literal|4
operator|)
operator|&&
operator|(
operator|!
operator|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* got predecessor count? */
if|if
condition|(
operator|(
name|len
operator|>
literal|3
operator|)
operator|&&
operator|(
operator|!
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* got predecessor? */
if|if
condition|(
operator|(
name|len
operator|>
literal|2
operator|)
operator|&&
operator|(
operator|!
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
condition|)
return|return
name|FALSE
return|;
comment|/* got the basics? */
if|if
condition|(
operator|!
operator|(
name|skel
operator|->
name|children
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|&&
operator|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
operator|)
condition|)
return|return
name|FALSE
return|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_node_revision_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|header
init|=
name|skel
operator|->
name|children
decl_stmt|;
name|svn_skel_t
modifier|*
name|kind
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|1
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|is_valid_node_revision_header_skel
argument_list|(
name|header
argument_list|,
operator|&
name|kind
argument_list|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|kind
argument_list|,
literal|"dir"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|len
operator|==
literal|3
operator|)
operator|&&
name|header
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|header
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|kind
argument_list|,
literal|"file"
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
operator|<
literal|3
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
operator|!
name|header
operator|->
name|next
operator|->
name|is_atom
condition|)
return|return
name|FALSE
return|;
comment|/* As of SVN_FS_BASE__MIN_REP_SHARING_FORMAT version, the          DATA-KEY slot can be a 2-tuple. */
if|if
condition|(
operator|!
name|header
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
condition|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|svn_skel__list_length
argument_list|(
name|header
operator|->
name|next
operator|->
name|next
argument_list|)
operator|==
literal|2
operator|)
operator|&&
name|header
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|is_atom
operator|&&
name|header
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|len
operator|&&
name|header
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|header
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|next
operator|->
name|len
operator|)
condition|)
return|return
name|FALSE
return|;
block|}
if|if
condition|(
operator|(
name|len
operator|>
literal|3
operator|)
operator|&&
operator|(
operator|!
name|header
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
condition|)
return|return
name|FALSE
return|;
if|if
condition|(
name|len
operator|>
literal|4
condition|)
return|return
name|FALSE
return|;
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_copy_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
return|return
operator|(
operator|(
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
operator|==
literal|4
operator|)
operator|&&
operator|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"copy"
argument_list|)
operator|||
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"soft-copy"
argument_list|)
operator|)
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_change_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|svn_fs_path_change_kind_t
modifier|*
name|kind
parameter_list|)
block|{
if|if
condition|(
operator|(
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
operator|==
literal|6
operator|)
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"change"
argument_list|)
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
condition|)
block|{
name|svn_skel_t
modifier|*
name|kind_skel
init|=
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
decl_stmt|;
comment|/* check the kind (and return it) */
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|kind_skel
argument_list|,
literal|"reset"
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_fs_path_change_reset
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|kind_skel
argument_list|,
literal|"add"
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_fs_path_change_add
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|kind_skel
argument_list|,
literal|"delete"
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_fs_path_change_delete
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|kind_skel
argument_list|,
literal|"replace"
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
return|return
name|TRUE
return|;
block|}
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|kind_skel
argument_list|,
literal|"modify"
argument_list|)
condition|)
block|{
if|if
condition|(
name|kind
condition|)
operator|*
name|kind
operator|=
name|svn_fs_path_change_modify
expr_stmt|;
return|return
name|TRUE
return|;
block|}
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_function
specifier|static
name|svn_boolean_t
name|is_valid_lock_skel
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|)
block|{
if|if
condition|(
operator|(
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
operator|==
literal|8
operator|)
operator|&&
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"lock"
argument_list|)
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
condition|)
return|return
name|TRUE
return|;
return|return
name|FALSE
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Parsing (conversion from skeleton to native FS type) ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_revision_skel
parameter_list|(
name|revision_t
modifier|*
modifier|*
name|revision_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|revision_t
modifier|*
name|revision
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_revision_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"revision"
argument_list|)
return|;
comment|/* Create the returned structure */
name|revision
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|revision
operator|->
name|txn_id
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Return the structure. */
operator|*
name|revision_p
operator|=
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_transaction_skel
parameter_list|(
name|transaction_t
modifier|*
modifier|*
name|transaction_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|transaction_t
modifier|*
name|transaction
decl_stmt|;
name|transaction_kind_t
name|kind
decl_stmt|;
name|svn_skel_t
modifier|*
name|root_id
decl_stmt|,
modifier|*
name|base_id_or_rev
decl_stmt|,
modifier|*
name|proplist
decl_stmt|,
modifier|*
name|copies
decl_stmt|;
name|int
name|len
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_transaction_skel
argument_list|(
name|skel
argument_list|,
operator|&
name|kind
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
name|root_id
operator|=
name|skel
operator|->
name|children
operator|->
name|next
expr_stmt|;
name|base_id_or_rev
operator|=
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|proplist
operator|=
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|copies
operator|=
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
expr_stmt|;
comment|/* Create the returned structure */
name|transaction
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|transaction
argument_list|)
argument_list|)
expr_stmt|;
comment|/* KIND */
name|transaction
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
comment|/* REVISION or BASE-ID */
if|if
condition|(
name|kind
operator|==
name|transaction_kind_committed
condition|)
block|{
comment|/* Committed transactions have a revision number... */
name|transaction
operator|->
name|base_id
operator|=
name|NULL
expr_stmt|;
name|transaction
operator|->
name|revision
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|base_id_or_rev
operator|->
name|data
argument_list|,
name|base_id_or_rev
operator|->
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|transaction
operator|->
name|revision
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
block|}
else|else
block|{
comment|/* ...where unfinished transactions have a base node-revision-id. */
name|transaction
operator|->
name|revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|transaction
operator|->
name|base_id
operator|=
name|svn_fs_base__id_parse
argument_list|(
name|base_id_or_rev
operator|->
name|data
argument_list|,
name|base_id_or_rev
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* ROOT-ID */
name|transaction
operator|->
name|root_id
operator|=
name|svn_fs_base__id_parse
argument_list|(
name|root_id
operator|->
name|data
argument_list|,
name|root_id
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* PROPLIST */
name|SVN_ERR
argument_list|(
name|svn_skel__parse_proplist
argument_list|(
operator|&
operator|(
name|transaction
operator|->
name|proplist
operator|)
argument_list|,
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* COPIES */
if|if
condition|(
operator|(
name|len
operator|=
name|svn_skel__list_length
argument_list|(
name|copies
argument_list|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|copy_id
decl_stmt|;
name|apr_array_header_t
modifier|*
name|txncopies
decl_stmt|;
name|svn_skel_t
modifier|*
name|cpy
init|=
name|copies
operator|->
name|children
decl_stmt|;
name|txncopies
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|copy_id
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|cpy
condition|)
block|{
name|copy_id
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|cpy
operator|->
name|data
argument_list|,
name|cpy
operator|->
name|len
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|txncopies
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|copy_id
expr_stmt|;
name|cpy
operator|=
name|cpy
operator|->
name|next
expr_stmt|;
block|}
name|transaction
operator|->
name|copies
operator|=
name|txncopies
expr_stmt|;
block|}
comment|/* Return the structure. */
operator|*
name|transaction_p
operator|=
name|transaction
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_representation_skel
parameter_list|(
name|representation_t
modifier|*
modifier|*
name|rep_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|representation_t
modifier|*
name|rep
decl_stmt|;
name|svn_skel_t
modifier|*
name|header_skel
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_representation_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"representation"
argument_list|)
return|;
name|header_skel
operator|=
name|skel
operator|->
name|children
expr_stmt|;
comment|/* Create the returned structure */
name|rep
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rep
argument_list|)
argument_list|)
expr_stmt|;
comment|/* KIND */
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|header_skel
operator|->
name|children
argument_list|,
literal|"fulltext"
argument_list|)
condition|)
name|rep
operator|->
name|kind
operator|=
name|rep_kind_fulltext
expr_stmt|;
else|else
name|rep
operator|->
name|kind
operator|=
name|rep_kind_delta
expr_stmt|;
comment|/* TXN */
name|rep
operator|->
name|txn_id
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* MD5 */
if|if
condition|(
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
condition|)
block|{
name|svn_skel_t
modifier|*
name|checksum_skel
init|=
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
decl_stmt|;
name|rep
operator|->
name|md5_checksum
operator|=
name|svn_checksum__from_digest_md5
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|checksum_skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
operator|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* SHA1 */
if|if
condition|(
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
condition|)
block|{
name|checksum_skel
operator|=
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
expr_stmt|;
name|rep
operator|->
name|sha1_checksum
operator|=
name|svn_checksum__from_digest_sha1
argument_list|(
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
operator|(
name|checksum_skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
operator|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* KIND-SPECIFIC stuff */
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
condition|)
block|{
comment|/* "fulltext"-specific. */
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "delta"-specific. */
name|svn_skel_t
modifier|*
name|chunk_skel
init|=
name|skel
operator|->
name|children
operator|->
name|next
decl_stmt|;
name|rep_delta_chunk_t
modifier|*
name|chunk
decl_stmt|;
name|apr_array_header_t
modifier|*
name|chunks
decl_stmt|;
comment|/* Alloc the chunk array. */
name|chunks
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
operator|-
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|chunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process the chunks. */
while|while
condition|(
name|chunk_skel
condition|)
block|{
name|svn_skel_t
modifier|*
name|window_skel
init|=
name|chunk_skel
operator|->
name|children
operator|->
name|next
decl_stmt|;
name|svn_skel_t
modifier|*
name|diff_skel
init|=
name|window_skel
operator|->
name|children
decl_stmt|;
name|apr_int64_t
name|val
decl_stmt|;
name|apr_uint64_t
name|uval
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
comment|/* Allocate a chunk and its window */
name|chunk
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|chunk
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Populate the window */
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|diff_skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|diff_skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|uval
argument_list|,
name|str
argument_list|,
literal|0
argument_list|,
literal|255
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|version
operator|=
operator|(
name|apr_byte_t
operator|)
name|uval
expr_stmt|;
name|chunk
operator|->
name|string_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|diff_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|diff_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|window_skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|window_skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|uval
argument_list|,
name|str
argument_list|,
literal|0
argument_list|,
name|APR_SIZE_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|size
operator|=
operator|(
name|apr_size_t
operator|)
name|uval
expr_stmt|;
name|chunk
operator|->
name|rep_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|window_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|window_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|chunk_skel
operator|->
name|children
operator|->
name|data
argument_list|,
name|chunk_skel
operator|->
name|children
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_strtoi64
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|,
literal|0
argument_list|,
name|APR_INT64_MAX
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|chunk
operator|->
name|offset
operator|=
operator|(
name|svn_filesize_t
operator|)
name|val
expr_stmt|;
comment|/* Add this chunk to the array. */
name|APR_ARRAY_PUSH
argument_list|(
name|chunks
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
operator|=
name|chunk
expr_stmt|;
comment|/* Next... */
name|chunk_skel
operator|=
name|chunk_skel
operator|->
name|next
expr_stmt|;
block|}
comment|/* Add the chunks array to the representation. */
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
operator|=
name|chunks
expr_stmt|;
block|}
comment|/* Return the structure. */
operator|*
name|rep_p
operator|=
name|rep
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_node_revision_skel
parameter_list|(
name|node_revision_t
modifier|*
modifier|*
name|noderev_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|node_revision_t
modifier|*
name|noderev
decl_stmt|;
name|svn_skel_t
modifier|*
name|header_skel
decl_stmt|,
modifier|*
name|cur_skel
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_node_revision_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"node-revision"
argument_list|)
return|;
name|header_skel
operator|=
name|skel
operator|->
name|children
expr_stmt|;
comment|/* Create the returned structure */
name|noderev
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|noderev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* KIND */
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|header_skel
operator|->
name|children
argument_list|,
literal|"dir"
argument_list|)
condition|)
name|noderev
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
else|else
name|noderev
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
comment|/* CREATED-PATH */
name|noderev
operator|->
name|created_path
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* PREDECESSOR-ID */
if|if
condition|(
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
condition|)
block|{
name|cur_skel
operator|=
name|header_skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cur_skel
operator|->
name|len
condition|)
name|noderev
operator|->
name|predecessor_id
operator|=
name|svn_fs_base__id_parse
argument_list|(
name|cur_skel
operator|->
name|data
argument_list|,
name|cur_skel
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* PREDECESSOR-COUNT */
name|noderev
operator|->
name|predecessor_count
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|cur_skel
operator|->
name|next
condition|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|cur_skel
operator|=
name|cur_skel
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|cur_skel
operator|->
name|len
condition|)
block|{
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|cur_skel
operator|->
name|data
argument_list|,
name|cur_skel
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
operator|&
name|noderev
operator|->
name|predecessor_count
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* HAS-MERGEINFO and MERGEINFO-COUNT */
if|if
condition|(
name|cur_skel
operator|->
name|next
condition|)
block|{
name|int
name|val
decl_stmt|;
name|cur_skel
operator|=
name|cur_skel
operator|->
name|next
expr_stmt|;
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|cur_skel
operator|->
name|data
argument_list|,
name|cur_skel
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi
argument_list|(
operator|&
name|val
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|has_mergeinfo
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
name|str
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|cur_skel
operator|->
name|next
operator|->
name|data
argument_list|,
name|cur_skel
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cstring_atoi64
argument_list|(
operator|&
name|noderev
operator|->
name|mergeinfo_count
argument_list|,
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* PROP-KEY */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
condition|)
name|noderev
operator|->
name|prop_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* DATA-KEY */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|is_atom
condition|)
block|{
comment|/* This is a real data rep key. */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
condition|)
name|noderev
operator|->
name|data_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|data_key_uniquifier
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a 2-tuple with a data rep key and a uniquifier. */
name|noderev
operator|->
name|data_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|len
argument_list|)
expr_stmt|;
name|noderev
operator|->
name|data_key_uniquifier
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* EDIT-DATA-KEY (optional, files only) */
if|if
condition|(
operator|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|&&
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
condition|)
name|noderev
operator|->
name|edit_key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Return the structure. */
operator|*
name|noderev_p
operator|=
name|noderev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_copy_skel
parameter_list|(
name|copy_t
modifier|*
modifier|*
name|copy_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|copy_t
modifier|*
name|copy
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_copy_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"copy"
argument_list|)
return|;
comment|/* Create the returned structure */
name|copy
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|copy
argument_list|)
argument_list|)
expr_stmt|;
comment|/* KIND */
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
argument_list|,
literal|"soft-copy"
argument_list|)
condition|)
name|copy
operator|->
name|kind
operator|=
name|copy_kind_soft
expr_stmt|;
else|else
name|copy
operator|->
name|kind
operator|=
name|copy_kind_real
expr_stmt|;
comment|/* SRC-PATH */
name|copy
operator|->
name|src_path
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* SRC-TXN-ID */
name|copy
operator|->
name|src_txn_id
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* DST-NODE-ID */
name|copy
operator|->
name|dst_noderev_id
operator|=
name|svn_fs_base__id_parse
argument_list|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Return the structure. */
operator|*
name|copy_p
operator|=
name|copy
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_entries_skel
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|entries_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|entries
init|=
name|NULL
decl_stmt|;
name|int
name|len
init|=
name|svn_skel__list_length
argument_list|(
name|skel
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|elt
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|len
operator|>=
literal|0
operator|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"entries"
argument_list|)
return|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* Else, allocate a hash and populate it. */
name|entries
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Check entries are well-formed as we go along. */
for|for
control|(
name|elt
operator|=
name|skel
operator|->
name|children
init|;
name|elt
condition|;
name|elt
operator|=
name|elt
operator|->
name|next
control|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
comment|/* ENTRY must be a list of two elements. */
if|if
condition|(
name|svn_skel__list_length
argument_list|(
name|elt
argument_list|)
operator|!=
literal|2
condition|)
return|return
name|skel_err
argument_list|(
literal|"entries"
argument_list|)
return|;
comment|/* Get the entry's name and ID. */
name|name
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|elt
operator|->
name|children
operator|->
name|data
argument_list|,
name|elt
operator|->
name|children
operator|->
name|len
argument_list|)
expr_stmt|;
name|id
operator|=
name|svn_fs_base__id_parse
argument_list|(
name|elt
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|elt
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Add the entry to the hash. */
name|apr_hash_set
argument_list|(
name|entries
argument_list|,
name|name
argument_list|,
name|elt
operator|->
name|children
operator|->
name|len
argument_list|,
name|id
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the structure. */
operator|*
name|entries_p
operator|=
name|entries
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_change_skel
parameter_list|(
name|change_t
modifier|*
modifier|*
name|change_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|change_t
modifier|*
name|change
decl_stmt|;
name|svn_fs_path_change_kind_t
name|kind
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_change_skel
argument_list|(
name|skel
argument_list|,
operator|&
name|kind
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"change"
argument_list|)
return|;
comment|/* Create the returned structure */
name|change
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|change
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PATH */
name|change
operator|->
name|path
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* NODE-REV-ID */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
condition|)
name|change
operator|->
name|noderev_id
operator|=
name|svn_fs_base__id_parse
argument_list|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* KIND */
name|change
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
comment|/* TEXT-MOD */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
condition|)
name|change
operator|->
name|text_mod
operator|=
name|TRUE
expr_stmt|;
comment|/* PROP-MOD */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
condition|)
name|change
operator|->
name|prop_mod
operator|=
name|TRUE
expr_stmt|;
comment|/* Return the structure. */
operator|*
name|change_p
operator|=
name|change
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__parse_lock_skel
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
specifier|const
name|char
modifier|*
name|timestr
decl_stmt|;
comment|/* Validate the skel. */
if|if
condition|(
operator|!
name|is_valid_lock_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"lock"
argument_list|)
return|;
comment|/* Create the returned structure */
name|lock
operator|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* PATH */
name|lock
operator|->
name|path
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* LOCK-TOKEN */
name|lock
operator|->
name|token
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* OWNER */
name|lock
operator|->
name|owner
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* COMMENT  (could be just an empty atom) */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
condition|)
name|lock
operator|->
name|comment
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* XML_P */
if|if
condition|(
name|svn_skel__matches_atom
argument_list|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
argument_list|,
literal|"1"
argument_list|)
condition|)
name|lock
operator|->
name|is_dav_comment
operator|=
name|TRUE
expr_stmt|;
else|else
name|lock
operator|->
name|is_dav_comment
operator|=
name|FALSE
expr_stmt|;
comment|/* CREATION-DATE */
name|timestr
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|creation_date
operator|)
argument_list|,
name|timestr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* EXPIRATION-DATE  (could be just an empty atom) */
if|if
condition|(
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
condition|)
block|{
name|timestr
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|data
argument_list|,
name|skel
operator|->
name|children
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|next
operator|->
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|expiration_date
operator|)
argument_list|,
name|timestr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return the structure. */
operator|*
name|lock_p
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Unparsing (conversion from native FS type to skeleton) ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_revision_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|revision_t
modifier|*
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
comment|/* Create the skel. */
name|skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* TXN_ID */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|revision
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* "revision" */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"revision"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_revision_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"revision"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_transaction_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|transaction_t
modifier|*
name|transaction
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|svn_skel_t
modifier|*
name|proplist_skel
decl_stmt|,
modifier|*
name|copies_skel
decl_stmt|,
modifier|*
name|header_skel
decl_stmt|;
name|svn_string_t
modifier|*
name|id_str
decl_stmt|;
name|transaction_kind_t
name|kind
decl_stmt|;
comment|/* Create the skel. */
name|skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|transaction
operator|->
name|kind
condition|)
block|{
case|case
name|transaction_kind_committed
case|:
name|header_skel
operator|=
name|svn_skel__str_atom
argument_list|(
literal|"committed"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|transaction
operator|->
name|base_id
operator|)
operator|||
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|transaction
operator|->
name|revision
argument_list|)
operator|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
break|break;
case|case
name|transaction_kind_dead
case|:
name|header_skel
operator|=
name|svn_skel__str_atom
argument_list|(
literal|"dead"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|transaction
operator|->
name|base_id
operator|)
operator|||
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|transaction
operator|->
name|revision
argument_list|)
operator|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
break|break;
case|case
name|transaction_kind_normal
case|:
name|header_skel
operator|=
name|svn_skel__str_atom
argument_list|(
literal|"transaction"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|transaction
operator|->
name|base_id
operator|)
operator|||
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|transaction
operator|->
name|revision
argument_list|)
operator|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
break|break;
default|default:
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
block|}
comment|/* COPIES */
name|copies_skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|transaction
operator|->
name|copies
operator|&&
name|transaction
operator|->
name|copies
operator|->
name|nelts
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|transaction
operator|->
name|copies
operator|->
name|nelts
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|APR_ARRAY_IDX
argument_list|(
name|transaction
operator|->
name|copies
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|,
name|copies_skel
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_skel__prepend
argument_list|(
name|copies_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* PROPLIST */
name|SVN_ERR
argument_list|(
name|svn_skel__unparse_proplist
argument_list|(
operator|&
name|proplist_skel
argument_list|,
name|transaction
operator|->
name|proplist
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|proplist_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* REVISION or BASE-ID */
if|if
condition|(
name|transaction
operator|->
name|kind
operator|==
name|transaction_kind_committed
condition|)
block|{
comment|/* Committed transactions have a revision number... */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|transaction
operator|->
name|revision
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* ...where other transactions have a base node revision ID. */
name|id_str
operator|=
name|svn_fs_base__id_unparse
argument_list|(
name|transaction
operator|->
name|base_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|id_str
operator|->
name|data
argument_list|,
name|id_str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
comment|/* ROOT-ID */
name|id_str
operator|=
name|svn_fs_base__id_unparse
argument_list|(
name|transaction
operator|->
name|root_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|id_str
operator|->
name|data
argument_list|,
name|id_str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* KIND (see above) */
name|svn_skel__prepend
argument_list|(
name|header_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_transaction_skel
argument_list|(
name|skel
argument_list|,
operator|&
name|kind
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
if|if
condition|(
name|kind
operator|!=
name|transaction
operator|->
name|kind
condition|)
return|return
name|skel_err
argument_list|(
literal|"transaction"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Construct a skel representing CHECKSUM, allocated in POOL, and prepend  * it onto the existing skel SKEL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prepend_checksum
parameter_list|(
name|svn_skel_t
modifier|*
name|skel
parameter_list|,
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|checksum_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|checksum
operator|->
name|kind
condition|)
block|{
case|case
name|svn_checksum_md5
case|:
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|checksum
operator|->
name|digest
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|checksum_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"md5"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|checksum_skel
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_checksum_sha1
case|:
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|checksum
operator|->
name|digest
argument_list|,
name|APR_SHA1_DIGESTSIZE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|checksum_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"sha1"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|checksum_skel
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
name|skel_err
argument_list|(
literal|"checksum"
argument_list|)
return|;
block|}
name|svn_skel__prepend
argument_list|(
name|checksum_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_representation_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|representation_t
modifier|*
name|rep
parameter_list|,
name|int
name|format
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|header_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/** Some parts of the header are common to all representations; do       those parts first. **/
comment|/* SHA1 */
if|if
condition|(
operator|(
name|format
operator|>=
name|SVN_FS_BASE__MIN_REP_SHARING_FORMAT
operator|)
operator|&&
name|rep
operator|->
name|sha1_checksum
condition|)
name|SVN_ERR
argument_list|(
name|prepend_checksum
argument_list|(
name|header_skel
argument_list|,
name|rep
operator|->
name|sha1_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* MD5 */
block|{
name|svn_checksum_t
modifier|*
name|md5_checksum
init|=
name|rep
operator|->
name|md5_checksum
decl_stmt|;
if|if
condition|(
operator|!
name|md5_checksum
condition|)
name|md5_checksum
operator|=
name|svn_checksum_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prepend_checksum
argument_list|(
name|header_skel
argument_list|,
name|md5_checksum
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* TXN */
if|if
condition|(
name|rep
operator|->
name|txn_id
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|rep
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
comment|/** Do the kind-specific stuff. **/
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_fulltext
condition|)
block|{
comment|/*** Fulltext Representation. ***/
comment|/* STRING-KEY */
if|if
condition|(
operator|(
operator|!
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
operator|)
operator|||
operator|(
operator|!
operator|*
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|rep
operator|->
name|contents
operator|.
name|fulltext
operator|.
name|string_key
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* "fulltext" */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"fulltext"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
comment|/* header */
name|svn_skel__prepend
argument_list|(
name|header_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rep
operator|->
name|kind
operator|==
name|rep_kind_delta
condition|)
block|{
comment|/*** Delta Representation. ***/
name|int
name|i
decl_stmt|;
name|apr_array_header_t
modifier|*
name|chunks
init|=
name|rep
operator|->
name|contents
operator|.
name|delta
operator|.
name|chunks
decl_stmt|;
comment|/* Loop backwards through the windows, creating and prepending skels. */
for|for
control|(
name|i
operator|=
name|chunks
operator|->
name|nelts
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|svn_skel_t
modifier|*
name|window_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|chunk_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_skel_t
modifier|*
name|diff_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|size_str
decl_stmt|,
modifier|*
name|offset_str
decl_stmt|,
modifier|*
name|version_str
decl_stmt|;
name|rep_delta_chunk_t
modifier|*
name|chunk
init|=
name|APR_ARRAY_IDX
argument_list|(
name|chunks
argument_list|,
name|i
operator|-
literal|1
argument_list|,
name|rep_delta_chunk_t
operator|*
argument_list|)
decl_stmt|;
comment|/* OFFSET */
name|offset_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|SVN_FILESIZE_T_FMT
argument_list|,
name|chunk
operator|->
name|offset
argument_list|)
expr_stmt|;
comment|/* SIZE */
name|size_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|chunk
operator|->
name|size
argument_list|)
expr_stmt|;
comment|/* VERSION */
name|version_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%d"
argument_list|,
name|chunk
operator|->
name|version
argument_list|)
expr_stmt|;
comment|/* DIFF */
if|if
condition|(
operator|(
operator|!
name|chunk
operator|->
name|string_key
operator|)
operator|||
operator|(
operator|!
operator|*
name|chunk
operator|->
name|string_key
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|diff_skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|chunk
operator|->
name|string_key
argument_list|,
name|pool
argument_list|)
argument_list|,
name|diff_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|version_str
argument_list|,
name|pool
argument_list|)
argument_list|,
name|diff_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"svndiff"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|diff_skel
argument_list|)
expr_stmt|;
comment|/* REP-KEY */
if|if
condition|(
operator|(
operator|!
name|chunk
operator|->
name|rep_key
operator|)
operator|||
operator|(
operator|!
operator|*
operator|(
name|chunk
operator|->
name|rep_key
operator|)
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|window_skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|chunk
operator|->
name|rep_key
argument_list|,
name|pool
argument_list|)
argument_list|,
name|window_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|size_str
argument_list|,
name|pool
argument_list|)
argument_list|,
name|window_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|diff_skel
argument_list|,
name|window_skel
argument_list|)
expr_stmt|;
comment|/* window header. */
name|svn_skel__prepend
argument_list|(
name|window_skel
argument_list|,
name|chunk_skel
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|offset_str
argument_list|,
name|pool
argument_list|)
argument_list|,
name|chunk_skel
argument_list|)
expr_stmt|;
comment|/* Add this window item to the main skel. */
name|svn_skel__prepend
argument_list|(
name|chunk_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
comment|/* "delta" */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"delta"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
comment|/* header */
name|svn_skel__prepend
argument_list|(
name|header_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* unknown kind */
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_representation_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"representation"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_node_revision_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|node_revision_t
modifier|*
name|noderev
parameter_list|,
name|int
name|format
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|svn_skel_t
modifier|*
name|header_skel
decl_stmt|;
specifier|const
name|char
modifier|*
name|num_str
decl_stmt|;
comment|/* Create the skel. */
name|skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|header_skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Store mergeinfo stuffs only if the schema level supports it. */
if|if
condition|(
name|format
operator|>=
name|SVN_FS_BASE__MIN_MERGEINFO_FORMAT
condition|)
block|{
comment|/* MERGEINFO-COUNT */
name|num_str
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|noderev
operator|->
name|mergeinfo_count
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|num_str
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
comment|/* HAS-MERGEINFO */
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|noderev
operator|->
name|has_mergeinfo
condition|?
literal|"1"
else|:
literal|"0"
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
comment|/* PREDECESSOR-COUNT padding (only if we *don't* have a valid          value; if we do, we'll pick that up below) */
if|if
condition|(
name|noderev
operator|->
name|predecessor_count
operator|==
operator|-
literal|1
condition|)
block|{
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* PREDECESSOR-COUNT */
if|if
condition|(
name|noderev
operator|->
name|predecessor_count
operator|!=
operator|-
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|count_str
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%d"
argument_list|,
name|noderev
operator|->
name|predecessor_count
argument_list|)
decl_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|count_str
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
block|}
comment|/* PREDECESSOR-ID */
if|if
condition|(
name|noderev
operator|->
name|predecessor_id
condition|)
block|{
name|svn_string_t
modifier|*
name|id_str
init|=
name|svn_fs_base__id_unparse
argument_list|(
name|noderev
operator|->
name|predecessor_id
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|id_str
operator|->
name|data
argument_list|,
name|id_str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
block|}
comment|/* CREATED-PATH */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|noderev
operator|->
name|created_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
comment|/* KIND */
if|if
condition|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"file"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|noderev
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"dir"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|header_skel
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* ### do we really need to check *node->FOO_key ? if a key doesn't      ### exist, then the field should be NULL ...  */
comment|/* EDIT-DATA-KEY (optional) */
if|if
condition|(
operator|(
name|noderev
operator|->
name|edit_key
operator|)
operator|&&
operator|(
operator|*
name|noderev
operator|->
name|edit_key
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|noderev
operator|->
name|edit_key
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* DATA-KEY | (DATA-KEY DATA-KEY-UNIQID) */
if|if
condition|(
operator|(
name|noderev
operator|->
name|data_key_uniquifier
operator|)
operator|&&
operator|(
operator|*
name|noderev
operator|->
name|data_key_uniquifier
operator|)
condition|)
block|{
comment|/* Build a 2-tuple with a rep key and uniquifier. */
name|svn_skel_t
modifier|*
name|data_key_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* DATA-KEY-UNIQID */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|noderev
operator|->
name|data_key_uniquifier
argument_list|,
name|pool
argument_list|)
argument_list|,
name|data_key_skel
argument_list|)
expr_stmt|;
comment|/* DATA-KEY */
if|if
condition|(
operator|(
name|noderev
operator|->
name|data_key
operator|)
operator|&&
operator|(
operator|*
name|noderev
operator|->
name|data_key
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|noderev
operator|->
name|data_key
argument_list|,
name|pool
argument_list|)
argument_list|,
name|data_key_skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|data_key_skel
argument_list|)
expr_stmt|;
comment|/* Add our 2-tuple to the main skel. */
name|svn_skel__prepend
argument_list|(
name|data_key_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Just store the rep key (or empty placeholder) in the main skel. */
if|if
condition|(
operator|(
name|noderev
operator|->
name|data_key
operator|)
operator|&&
operator|(
operator|*
name|noderev
operator|->
name|data_key
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|noderev
operator|->
name|data_key
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
comment|/* PROP-KEY */
if|if
condition|(
operator|(
name|noderev
operator|->
name|prop_key
operator|)
operator|&&
operator|(
operator|*
name|noderev
operator|->
name|prop_key
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|noderev
operator|->
name|prop_key
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* HEADER */
name|svn_skel__prepend
argument_list|(
name|header_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_node_revision_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"node-revision"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_copy_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|copy_t
modifier|*
name|copy
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|svn_string_t
modifier|*
name|tmp_str
decl_stmt|;
comment|/* Create the skel. */
name|skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* DST-NODE-ID */
name|tmp_str
operator|=
name|svn_fs_base__id_unparse
argument_list|(
name|copy
operator|->
name|dst_noderev_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|tmp_str
operator|->
name|data
argument_list|,
name|tmp_str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* SRC-TXN-ID */
if|if
condition|(
operator|(
name|copy
operator|->
name|src_txn_id
operator|)
operator|&&
operator|(
operator|*
name|copy
operator|->
name|src_txn_id
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|copy
operator|->
name|src_txn_id
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* SRC-PATH */
if|if
condition|(
operator|(
name|copy
operator|->
name|src_path
operator|)
operator|&&
operator|(
operator|*
name|copy
operator|->
name|src_path
operator|)
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|copy
operator|->
name|src_path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* "copy" */
if|if
condition|(
name|copy
operator|->
name|kind
operator|==
name|copy_kind_real
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"copy"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"soft-copy"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_copy_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"copy"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_entries_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
name|apr_hash_t
modifier|*
name|entries
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
comment|/* Create the skel. */
if|if
condition|(
name|entries
condition|)
block|{
comment|/* Loop over hash entries */
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|entries
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|void
modifier|*
name|key
decl_stmt|;
name|void
modifier|*
name|val
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
name|svn_fs_id_t
modifier|*
name|value
decl_stmt|;
name|svn_string_t
modifier|*
name|id_str
decl_stmt|;
name|svn_skel_t
modifier|*
name|entry_skel
init|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|key
argument_list|,
operator|&
name|klen
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|value
operator|=
name|val
expr_stmt|;
comment|/* VALUE */
name|id_str
operator|=
name|svn_fs_base__id_unparse
argument_list|(
name|value
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|id_str
operator|->
name|data
argument_list|,
name|id_str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|,
name|entry_skel
argument_list|)
expr_stmt|;
comment|/* NAME */
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|key
argument_list|,
name|klen
argument_list|,
name|pool
argument_list|)
argument_list|,
name|entry_skel
argument_list|)
expr_stmt|;
comment|/* Add entry to the entries skel. */
name|svn_skel__prepend
argument_list|(
name|entry_skel
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return the skel. */
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_change_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|change_t
modifier|*
name|change
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
name|svn_string_t
modifier|*
name|tmp_str
decl_stmt|;
name|svn_fs_path_change_kind_t
name|kind
decl_stmt|;
comment|/* Create the skel. */
name|skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* PROP-MOD */
if|if
condition|(
name|change
operator|->
name|prop_mod
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"1"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* TEXT-MOD */
if|if
condition|(
name|change
operator|->
name|text_mod
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"1"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* KIND */
switch|switch
condition|(
name|change
operator|->
name|kind
condition|)
block|{
case|case
name|svn_fs_path_change_reset
case|:
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"reset"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_add
case|:
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"add"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"delete"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_replace
case|:
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"replace"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_modify
case|:
default|default:
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"modify"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* NODE-REV-ID */
if|if
condition|(
name|change
operator|->
name|noderev_id
condition|)
block|{
name|tmp_str
operator|=
name|svn_fs_base__id_unparse
argument_list|(
name|change
operator|->
name|noderev_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|tmp_str
operator|->
name|data
argument_list|,
name|tmp_str
operator|->
name|len
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
block|}
comment|/* PATH */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|change
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* "change" */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"change"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_change_skel
argument_list|(
name|skel
argument_list|,
operator|&
name|kind
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"change"
argument_list|)
return|;
if|if
condition|(
name|kind
operator|!=
name|change
operator|->
name|kind
condition|)
return|return
name|skel_err
argument_list|(
literal|"change"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unparse_lock_skel
parameter_list|(
name|svn_skel_t
modifier|*
modifier|*
name|skel_p
parameter_list|,
specifier|const
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
comment|/* Create the skel. */
name|skel
operator|=
name|svn_skel__make_empty_list
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* EXP-DATE is optional.  If not present, just use an empty atom. */
if|if
condition|(
name|lock
operator|->
name|expiration_date
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|expiration_date
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* CREATION-DATE */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|svn_time_to_cstring
argument_list|(
name|lock
operator|->
name|creation_date
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* XML_P */
if|if
condition|(
name|lock
operator|->
name|is_dav_comment
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"1"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"0"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* COMMENT */
if|if
condition|(
name|lock
operator|->
name|comment
condition|)
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|lock
operator|->
name|comment
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
else|else
name|svn_skel__prepend
argument_list|(
name|svn_skel__mem_atom
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* OWNER */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|lock
operator|->
name|owner
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* LOCK-TOKEN */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|lock
operator|->
name|token
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* PATH */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
name|lock
operator|->
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* "lock" */
name|svn_skel__prepend
argument_list|(
name|svn_skel__str_atom
argument_list|(
literal|"lock"
argument_list|,
name|pool
argument_list|)
argument_list|,
name|skel
argument_list|)
expr_stmt|;
comment|/* Validate and return the skel. */
if|if
condition|(
operator|!
name|is_valid_lock_skel
argument_list|(
name|skel
argument_list|)
condition|)
return|return
name|skel_err
argument_list|(
literal|"lock"
argument_list|)
return|;
operator|*
name|skel_p
operator|=
name|skel
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

