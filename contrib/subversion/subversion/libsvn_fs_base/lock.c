begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* lock.c :  functions for manipulating filesystem locks.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|<apr_uuid.h>
end_include

begin_include
include|#
directive|include
file|"lock.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"err.h"
end_include

begin_include
include|#
directive|include
file|"bdb/locks-table.h"
end_include

begin_include
include|#
directive|include
file|"bdb/lock-tokens-table.h"
end_include

begin_include
include|#
directive|include
file|"util/fs_skels.h"
end_include

begin_include
include|#
directive|include
file|"../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_comment
comment|/* Add LOCK and its associated LOCK_TOKEN (associated with PATH) as    part of TRAIL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_lock_and_token
parameter_list|(
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__lock_add
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|lock_token
argument_list|,
name|lock
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_bdb__lock_token_add
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|lock_token
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Delete LOCK_TOKEN and its corresponding lock (associated with PATH,    whose KIND is supplied), as part of TRAIL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_lock_and_token
parameter_list|(
specifier|const
name|char
modifier|*
name|lock_token
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__lock_delete
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|lock_token
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_fs_bdb__lock_token_delete
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|lock_args
block|{
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment
decl_stmt|;
name|svn_boolean_t
name|is_dav_comment
decl_stmt|;
name|svn_boolean_t
name|steal_lock
decl_stmt|;
name|apr_time_t
name|expiration_date
decl_stmt|;
name|svn_revnum_t
name|current_rev
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_lock
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|lock_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
name|svn_node_kind_t
name|kind
init|=
name|svn_node_file
decl_stmt|;
name|svn_lock_t
modifier|*
name|existing_lock
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_path_kind
argument_list|(
operator|&
name|kind
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Until we implement directory locks someday, we only allow locks      on files or non-existent paths. */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
return|return
name|SVN_FS__ERR_NOT_FILE
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|path
argument_list|)
return|;
comment|/* While our locking implementation easily supports the locking of      nonexistent paths, we deliberately choose not to allow such madness. */
if|if
condition|(
name|kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|args
operator|->
name|current_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|args
operator|->
name|path
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|)
argument_list|,
name|args
operator|->
name|path
argument_list|)
return|;
block|}
comment|/* There better be a username attached to the fs. */
if|if
condition|(
operator|!
name|trail
operator|->
name|fs
operator|->
name|access_ctx
operator|||
operator|!
name|trail
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
condition|)
return|return
name|SVN_FS__ERR_NO_USER
argument_list|(
name|trail
operator|->
name|fs
argument_list|)
return|;
comment|/* Is the caller attempting to lock an out-of-date working file? */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|args
operator|->
name|current_rev
argument_list|)
condition|)
block|{
name|svn_revnum_t
name|created_rev
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_path_created_rev
argument_list|(
operator|&
name|created_rev
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* SVN_INVALID_REVNUM means the path doesn't exist.  So          apparently somebody is trying to lock something in their          working copy, but somebody else has deleted the thing          from HEAD.  That counts as being 'out of date'. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|created_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
literal|"Path '%s' doesn't exist in HEAD revision"
argument_list|,
name|args
operator|->
name|path
argument_list|)
return|;
if|if
condition|(
name|args
operator|->
name|current_rev
operator|<
name|created_rev
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_OUT_OF_DATE
argument_list|,
name|NULL
argument_list|,
literal|"Lock failed: newer version of '%s' exists"
argument_list|,
name|args
operator|->
name|path
argument_list|)
return|;
block|}
comment|/* If the caller provided a TOKEN, we *really* need to see      if a lock already exists with that token, and if so, verify that      the lock's path matches PATH.  Otherwise we run the risk of      breaking the 1-to-1 mapping of lock tokens to locked paths. */
if|if
condition|(
name|args
operator|->
name|token
condition|)
block|{
name|svn_lock_t
modifier|*
name|lock_from_token
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|svn_fs_bdb__lock_get
argument_list|(
operator|&
name|lock_from_token
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|token
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_LOCK_EXPIRED
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_BAD_LOCK_TOKEN
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|lock_from_token
operator|->
name|path
argument_list|,
name|args
operator|->
name|path
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_BAD_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
literal|"Lock failed: token refers to existing "
literal|"lock with non-matching path."
argument_list|)
return|;
block|}
block|}
comment|/* Is the path already locked?       Note that this next function call will automatically ignore any      errors about {the path not existing as a key, the path's token      not existing as a key, the lock just having been expired}.  And      that's totally fine.  Any of these three errors are perfectly      acceptable to ignore; it means that the path is now free and      clear for locking, because the bdb funcs just cleared out both      of the tables for us.   */
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_lock_helper
argument_list|(
operator|&
name|existing_lock
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|existing_lock
condition|)
block|{
if|if
condition|(
operator|!
name|args
operator|->
name|steal_lock
condition|)
block|{
comment|/* Sorry, the path is already locked. */
return|return
name|SVN_FS__ERR_PATH_ALREADY_LOCKED
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|existing_lock
argument_list|)
return|;
block|}
else|else
block|{
comment|/* ARGS->steal_lock is set, so fs_username is "stealing" the              lock from lock->owner.  Destroy the existing lock. */
name|SVN_ERR
argument_list|(
name|delete_lock_and_token
argument_list|(
name|existing_lock
operator|->
name|token
argument_list|,
name|existing_lock
operator|->
name|path
argument_list|,
name|trail
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Create a new lock, and add it to the tables. */
name|lock
operator|=
name|svn_lock_create
argument_list|(
name|trail
operator|->
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|token
condition|)
name|lock
operator|->
name|token
operator|=
name|apr_pstrdup
argument_list|(
name|trail
operator|->
name|pool
argument_list|,
name|args
operator|->
name|token
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_base__generate_lock_token
argument_list|(
operator|&
operator|(
name|lock
operator|->
name|token
operator|)
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|trail
operator|->
name|pool
argument_list|,
name|args
operator|->
name|path
argument_list|)
expr_stmt|;
name|lock
operator|->
name|owner
operator|=
name|apr_pstrdup
argument_list|(
name|trail
operator|->
name|pool
argument_list|,
name|trail
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|)
expr_stmt|;
name|lock
operator|->
name|comment
operator|=
name|apr_pstrdup
argument_list|(
name|trail
operator|->
name|pool
argument_list|,
name|args
operator|->
name|comment
argument_list|)
expr_stmt|;
name|lock
operator|->
name|is_dav_comment
operator|=
name|args
operator|->
name|is_dav_comment
expr_stmt|;
name|lock
operator|->
name|creation_date
operator|=
name|apr_time_now
argument_list|()
expr_stmt|;
name|lock
operator|->
name|expiration_date
operator|=
name|args
operator|->
name|expiration_date
expr_stmt|;
name|SVN_ERR
argument_list|(
name|add_lock_and_token
argument_list|(
name|lock
argument_list|,
name|lock
operator|->
name|token
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|)
argument_list|)
expr_stmt|;
operator|*
operator|(
name|args
operator|->
name|lock_p
operator|)
operator|=
name|lock
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
specifier|const
name|char
modifier|*
name|comment
parameter_list|,
name|svn_boolean_t
name|is_dav_comment
parameter_list|,
name|apr_time_t
name|expiration_date
parameter_list|,
name|svn_revnum_t
name|current_rev
parameter_list|,
name|svn_boolean_t
name|steal_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|lock_args
name|args
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|lock_p
operator|=
name|lock
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
operator|.
name|token
operator|=
name|token
expr_stmt|;
name|args
operator|.
name|comment
operator|=
name|comment
expr_stmt|;
name|args
operator|.
name|is_dav_comment
operator|=
name|is_dav_comment
expr_stmt|;
name|args
operator|.
name|steal_lock
operator|=
name|steal_lock
expr_stmt|;
name|args
operator|.
name|expiration_date
operator|=
name|expiration_date
expr_stmt|;
name|args
operator|.
name|current_rev
operator|=
name|current_rev
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_lock
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__generate_lock_token
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|token
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Notice that 'fs' is currently unused.  But perhaps someday, we'll      want to use the fs UUID + some incremented number?  For now, we      generate a URI that matches the DAV RFC.  We could change this to      some other URI scheme someday, if we wish. */
operator|*
name|token
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"opaquelocktoken:"
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|unlock_args
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
specifier|const
name|char
modifier|*
name|token
decl_stmt|;
name|svn_boolean_t
name|break_lock
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_unlock
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|unlock_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_token
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
comment|/* This could return SVN_ERR_FS_BAD_LOCK_TOKEN or SVN_ERR_FS_LOCK_EXPIRED. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__lock_token_get
argument_list|(
operator|&
name|lock_token
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If not breaking the lock, we need to do some more checking. */
if|if
condition|(
operator|!
name|args
operator|->
name|break_lock
condition|)
block|{
comment|/* Sanity check: The lock token must exist, and must match. */
if|if
condition|(
name|args
operator|->
name|token
operator|==
name|NULL
condition|)
return|return
name|svn_fs_base__err_no_lock_token
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|path
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|lock_token
argument_list|,
name|args
operator|->
name|token
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SVN_FS__ERR_NO_SUCH_LOCK
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|path
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__lock_get
argument_list|(
operator|&
name|lock
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|lock_token
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* There better be a username attached to the fs. */
if|if
condition|(
operator|!
name|trail
operator|->
name|fs
operator|->
name|access_ctx
operator|||
operator|!
name|trail
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
condition|)
return|return
name|SVN_FS__ERR_NO_USER
argument_list|(
name|trail
operator|->
name|fs
argument_list|)
return|;
comment|/* And that username better be the same as the lock's owner. */
if|if
condition|(
name|strcmp
argument_list|(
name|trail
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|SVN_FS__ERR_LOCK_OWNER_MISMATCH
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|trail
operator|->
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
return|;
block|}
comment|/* Remove a row from each of the locking tables. */
return|return
name|delete_lock_and_token
argument_list|(
name|lock_token
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__unlock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|token
parameter_list|,
name|svn_boolean_t
name|break_lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|unlock_args
name|args
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
operator|.
name|token
operator|=
name|token
expr_stmt|;
name|args
operator|.
name|break_lock
operator|=
name|break_lock
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_unlock
argument_list|,
operator|&
name|args
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__get_lock_helper
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|lock_token
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|svn_fs_bdb__lock_token_get
argument_list|(
operator|&
name|lock_token
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* We've deliberately decided that this function doesn't tell the      caller *why* the lock is unavailable.  */
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_NO_SUCH_LOCK
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_LOCK_EXPIRED
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_BAD_LOCK_TOKEN
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Same situation here.  */
name|err
operator|=
name|svn_fs_bdb__lock_get
argument_list|(
name|lock_p
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|lock_token
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
operator|(
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_LOCK_EXPIRED
operator|)
operator|||
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_BAD_LOCK_TOKEN
operator|)
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
operator|*
name|lock_p
operator|=
name|NULL
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|lock_token_get_args
block|{
name|svn_lock_t
modifier|*
modifier|*
name|lock_p
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_lock
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|lock_token_get_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
return|return
name|svn_fs_base__get_lock_helper
argument_list|(
name|args
operator|->
name|lock_p
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__get_lock
parameter_list|(
name|svn_lock_t
modifier|*
modifier|*
name|lock
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|lock_token_get_args
name|args
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
operator|.
name|lock_p
operator|=
name|lock
expr_stmt|;
return|return
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_get_lock
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Implements `svn_fs_get_locks_callback_t', spooling lock information    to a stream as the filesystem provides it.  BATON is an 'svn_stream_t *'    object pointing to the stream.  We'll write the spool stream with a    format like so:        SKEL1_LEN "\n" SKEL1 "\n" SKEL2_LEN "\n" SKEL2 "\n" ...     where each skel is a lock skel (the same format we use to store    locks in the `locks' table). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|spool_locks_info
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_skel_t
modifier|*
name|lock_skel
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|skel_len
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|skel_buf
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__unparse_lock_skel
argument_list|(
operator|&
name|lock_skel
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|skel_buf
operator|=
name|svn_skel__unparse
argument_list|(
name|lock_skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|skel_len
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
literal|"\n"
argument_list|,
name|skel_buf
operator|->
name|len
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|skel_len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|skel_len
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|skel_buf
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|skel_buf
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
literal|1
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|len
argument_list|)
return|;
block|}
end_function

begin_struct
struct|struct
name|locks_get_args
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_depth_t
name|depth
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txn_body_get_locks
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|)
block|{
name|struct
name|locks_get_args
modifier|*
name|args
init|=
name|baton
decl_stmt|;
return|return
name|svn_fs_bdb__locks_get
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|args
operator|->
name|path
argument_list|,
name|args
operator|->
name|depth
argument_list|,
name|spool_locks_info
argument_list|,
name|args
operator|->
name|stream
argument_list|,
name|trail
argument_list|,
name|trail
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__get_locks
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_depth_t
name|depth
parameter_list|,
name|svn_fs_get_locks_callback_t
name|get_locks_func
parameter_list|,
name|void
modifier|*
name|get_locks_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|locks_get_args
name|args
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|buf
decl_stmt|;
name|svn_boolean_t
name|eof
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs__check_fs
argument_list|(
name|fs
argument_list|,
name|TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|args
operator|.
name|path
operator|=
name|svn_fs__canonicalize_abspath
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|args
operator|.
name|depth
operator|=
name|depth
expr_stmt|;
comment|/* Enough for 100+ locks if the comments are small. */
name|args
operator|.
name|stream
operator|=
name|svn_stream__from_spillbuf
argument_list|(
literal|4
operator|*
literal|1024
comment|/* blocksize */
argument_list|,
literal|64
operator|*
literal|1024
comment|/* maxsize */
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__retry_txn
argument_list|(
name|fs
argument_list|,
name|txn_body_get_locks
argument_list|,
operator|&
name|args
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the stream calling GET_LOCKS_FUNC(). */
name|stream
operator|=
name|args
operator|.
name|stream
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|len
decl_stmt|,
name|skel_len
decl_stmt|;
name|char
name|c
decl_stmt|,
modifier|*
name|skel_buf
decl_stmt|;
name|svn_skel_t
modifier|*
name|lock_skel
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|apr_uint64_t
name|ui64
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Read a skel length line and parse it for the skel's length.  */
name|SVN_ERR
argument_list|(
name|svn_stream_readline
argument_list|(
name|stream
argument_list|,
operator|&
name|buf
argument_list|,
literal|"\n"
argument_list|,
operator|&
name|eof
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|eof
condition|)
break|break;
name|err
operator|=
name|svn_cstring_strtoui64
argument_list|(
operator|&
name|ui64
argument_list|,
name|buf
operator|->
name|data
argument_list|,
literal|0
argument_list|,
name|APR_SIZE_MAX
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|err
argument_list|,
name|NULL
argument_list|)
return|;
name|skel_len
operator|=
operator|(
name|apr_size_t
operator|)
name|ui64
expr_stmt|;
comment|/* Now read that much into a buffer. */
name|skel_buf
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|skel_len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|skel_buf
argument_list|,
operator|&
name|skel_len
argument_list|)
argument_list|)
expr_stmt|;
name|skel_buf
index|[
name|skel_len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Read the extra newline that follows the skel. */
name|len
operator|=
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_MALFORMED_FILE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
comment|/* Parse the skel into a lock, and notify the caller. */
name|lock_skel
operator|=
name|svn_skel__parse
argument_list|(
name|skel_buf
argument_list|,
name|skel_len
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_base__parse_lock_skel
argument_list|(
operator|&
name|lock
argument_list|,
name|lock_skel
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_locks_func
argument_list|(
name|get_locks_baton
argument_list|,
name|lock
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Utility function:  verify that a lock can be used.     If no username is attached to the FS, return SVN_ERR_FS_NO_USER.     If the FS username doesn't match LOCK's owner, return    SVN_ERR_FS_LOCK_OWNER_MISMATCH.     If FS hasn't been supplied with a matching lock-token for LOCK,    return SVN_ERR_FS_BAD_LOCK_TOKEN.     Otherwise return SVN_NO_ERROR.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_lock
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
operator|(
operator|!
name|fs
operator|->
name|access_ctx
operator|)
operator|||
operator|(
operator|!
name|fs
operator|->
name|access_ctx
operator|->
name|username
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_USER
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot verify lock on path '%s'; no username available"
argument_list|)
argument_list|,
name|lock
operator|->
name|path
argument_list|)
return|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
operator|!=
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_LOCK_OWNER_MISMATCH
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"User '%s' does not own lock on path '%s' (currently locked by '%s')"
argument_list|)
argument_list|,
name|fs
operator|->
name|access_ctx
operator|->
name|username
argument_list|,
name|lock
operator|->
name|path
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
return|;
elseif|else
if|if
condition|(
name|svn_hash_gets
argument_list|(
name|fs
operator|->
name|access_ctx
operator|->
name|lock_tokens
argument_list|,
name|lock
operator|->
name|token
argument_list|)
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_BAD_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot verify lock on path '%s'; no matching lock-token available"
argument_list|)
argument_list|,
name|lock
operator|->
name|path
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements the svn_fs_get_locks_callback_t interface, where    BATON is just an svn_fs_t object. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_locks_callback
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_lock_t
modifier|*
name|lock
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|verify_lock
argument_list|(
name|baton
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* The main routine for lock enforcement, used throughout libsvn_fs_base. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_base__allow_locked_operation
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|recurse
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|recurse
condition|)
block|{
comment|/* Discover all locks at or below the path. */
name|SVN_ERR
argument_list|(
name|svn_fs_bdb__locks_get
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|svn_depth_infinity
argument_list|,
name|get_locks_callback
argument_list|,
name|trail
operator|->
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
comment|/* Discover any lock attached to the path. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__get_lock_helper
argument_list|(
operator|&
name|lock
argument_list|,
name|path
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
name|SVN_ERR
argument_list|(
name|verify_lock
argument_list|(
name|trail
operator|->
name|fs
argument_list|,
name|lock
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

