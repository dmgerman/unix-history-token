begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* env.h : managing the BDB environment  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr.h>
end_include

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_include
include|#
directive|include
file|<apr_thread_proc.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_atomic.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mutex.h"
end_include

begin_include
include|#
directive|include
file|"bdb-err.h"
end_include

begin_include
include|#
directive|include
file|"bdb_compat.h"
end_include

begin_include
include|#
directive|include
file|"env.h"
end_include

begin_comment
comment|/* A note about the BDB environment descriptor cache.     With the advent of DB_REGISTER in BDB-4.4, a process may only open    an environment handle once.  This means that we must maintain a    cache of open environment handles, with reference counts.  We    allocate each environment descriptor (a bdb_env_t) from its own    pool.  The cache itself (and the cache pool) are shared between    threads, so all direct or indirect access to the pool is serialized    with a global mutex.     Because several threads can now use the same DB_ENV handle, we must    use the DB_THREAD flag when opening the environments, otherwise the    env handles (and all of libsvn_fs_base) won't be thread-safe.     If we use DB_THREAD, however, all of the code that reads data from    the database without a cursor must use either DB_DBT_MALLOC,    DB_DBT_REALLOC, or DB_DBT_USERMEM, as described in the BDB    documentation.     (Oh, yes -- using DB_THREAD might not work on some systems. But    then, it's quite probable that threading is seriously broken on    those systems anyway, so we'll rely on APR_HAS_THREADS.) */
end_comment

begin_comment
comment|/* The cache key for a Berkeley DB environment descriptor.  This is a    combination of the device ID and INODE number of the Berkeley DB    config file.     XXX FIXME: Although the dev+inode combination is supposed do be    unique, apparently that's not always the case with some remote    filesystems.  We /should/ be safe using this as a unique hash key,    because the database must be on a local filesystem.  We can hope,    anyway. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|bdb_env_key_t
block|{
name|apr_dev_t
name|device
decl_stmt|;
name|apr_ino_t
name|inode
decl_stmt|;
block|}
name|bdb_env_key_t
typedef|;
end_typedef

begin_comment
comment|/* The cached Berkeley DB environment descriptor. */
end_comment

begin_struct
struct|struct
name|bdb_env_t
block|{
comment|/**************************************************************************/
comment|/* Error Reporting */
comment|/* A (char *) casted pointer to this structure is passed to BDB's      set_errpfx(), which treats it as a NUL-terminated character      string to prefix all BDB error messages.  However, svn also      registers bdb_error_gatherer() as an error handler with      set_errcall() which turns off BDB's default printing of errors to      stderr and anytime thereafter when BDB reports an error and      before the BDB function returns, it calls bdb_error_gatherer()      and passes the same error prefix (char *) pointer given to      set_errpfx().  The bdb_error_gatherer() callback casts the      (char *) it back to a (bdb_env_t *).       To avoid problems should BDB ever try to interpret our baton as a      string, the first field in the structure is a char      errpfx_string[].  Initializers of this structure must strcpy the      value of BDB_ERRPFX_STRING into this array.  */
name|char
name|errpfx_string
index|[
sizeof|sizeof
argument_list|(
name|BDB_ERRPFX_STRING
argument_list|)
index|]
decl_stmt|;
comment|/* Extended error information. */
if|#
directive|if
name|APR_HAS_THREADS
name|apr_threadkey_t
modifier|*
name|error_info
decl_stmt|;
comment|/* Points to a bdb_error_info_t. */
else|#
directive|else
name|bdb_error_info_t
name|error_info
decl_stmt|;
endif|#
directive|endif
comment|/**************************************************************************/
comment|/* BDB Environment Cache */
comment|/* The Berkeley DB environment. */
name|DB_ENV
modifier|*
name|env
decl_stmt|;
comment|/* The flags with which this environment was opened.  Reopening the      environment with a different set of flags is not allowed.  Trying      to change the state of the DB_PRIVATE flag is an especially bad      idea, so svn_fs_bdb__open() forbids any flag changes. */
name|u_int32_t
name|flags
decl_stmt|;
comment|/* The home path of this environment; a canonical SVN path encoded in      UTF-8 and allocated from this decriptor's pool. */
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
comment|/* The home path of this environment, in the form expected by BDB. */
specifier|const
name|char
modifier|*
name|path_bdb
decl_stmt|;
comment|/* The reference count for this environment handle; this is      essentially the difference between the number of calls to      svn_fs_bdb__open and svn_fs_bdb__close. */
name|unsigned
name|refcount
decl_stmt|;
comment|/* If this flag is TRUE, someone has detected that the environment      descriptor is in a panicked state and should be removed from the      cache.       Note 1: Once this flag is set, it must not be cleared again.       Note 2: Unlike other fields in this structure, this field is not              protected by the cache mutex on threaded platforms, and              should only be accesses via the svn_atomic functions. */
specifier|volatile
name|svn_atomic_t
name|panic
decl_stmt|;
comment|/* The key for the environment descriptor cache. */
name|bdb_env_key_t
name|key
decl_stmt|;
comment|/* The handle of the open DB_CONFIG file.       We keep the DB_CONFIG file open in this process as long as the      environment handle itself is open.  On Windows, this guarantees      that the cache key remains unique; here's what the Windows SDK      docs have to say about the file index (interpreted as the INODE      number by APR):          "This value is useful only while the file is open by at least         one process.  If no processes have it open, the index may         change the next time the file is opened."       Now, we certainly don't want a unique key to change while it's      being used, do we... */
name|apr_file_t
modifier|*
name|dbconfig_file
decl_stmt|;
comment|/* The pool associated with this environment descriptor.       Because the descriptor has a life of its own, the structure and      any data associated with it are allocated from their own global      pool. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_comment
comment|/* Get the thread-specific error info from a bdb_env_t. */
end_comment

begin_function
specifier|static
name|bdb_error_info_t
modifier|*
name|get_error_info
parameter_list|(
specifier|const
name|bdb_env_t
modifier|*
name|bdb
parameter_list|)
block|{
name|void
modifier|*
name|priv
decl_stmt|;
name|apr_threadkey_private_get
argument_list|(
operator|&
name|priv
argument_list|,
name|bdb
operator|->
name|error_info
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|priv
condition|)
block|{
name|priv
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|bdb_error_info_t
argument_list|)
argument_list|)
expr_stmt|;
name|apr_threadkey_private_set
argument_list|(
name|priv
argument_list|,
name|bdb
operator|->
name|error_info
argument_list|)
expr_stmt|;
block|}
return|return
name|priv
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|get_error_info
parameter_list|(
name|bdb
parameter_list|)
value|(&(bdb)->error_info)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_THREADS */
end_comment

begin_comment
comment|/* Convert a BDB error to a Subversion error. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|convert_bdb_error
parameter_list|(
name|bdb_env_t
modifier|*
name|bdb
parameter_list|,
name|int
name|db_err
parameter_list|)
block|{
if|if
condition|(
name|db_err
condition|)
block|{
name|bdb_env_baton_t
name|bdb_baton
decl_stmt|;
name|bdb_baton
operator|.
name|env
operator|=
name|bdb
operator|->
name|env
expr_stmt|;
name|bdb_baton
operator|.
name|bdb
operator|=
name|bdb
expr_stmt|;
name|bdb_baton
operator|.
name|error_info
operator|=
name|get_error_info
argument_list|(
name|bdb
argument_list|)
expr_stmt|;
name|SVN_BDB_ERR
argument_list|(
operator|&
name|bdb_baton
argument_list|,
name|db_err
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Allocating an appropriate Berkeley DB environment object.  */
end_comment

begin_comment
comment|/* BDB error callback.  See bdb_error_info_t in env.h for more info.    Note: bdb_error_gatherer is a macro with BDB< 4.3, so be careful how    you use it! */
end_comment

begin_function
specifier|static
name|void
name|bdb_error_gatherer
parameter_list|(
specifier|const
name|DB_ENV
modifier|*
name|dbenv
parameter_list|,
specifier|const
name|char
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|/* See the documentation at bdb_env_t's definition why the      (bdb_env_t *) cast is safe and why it is done. */
name|bdb_error_info_t
modifier|*
name|error_info
init|=
name|get_error_info
argument_list|(
operator|(
specifier|const
name|bdb_env_t
operator|*
operator|)
name|baton
argument_list|)
decl_stmt|;
name|svn_error_t
modifier|*
name|new_err
decl_stmt|;
name|SVN_BDB_ERROR_GATHERER_IGNORE
argument_list|(
name|dbenv
argument_list|)
expr_stmt|;
name|new_err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_BERKELEY_DB
argument_list|,
name|NULL
argument_list|,
literal|"bdb: %s"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_info
operator|->
name|pending_errors
condition|)
name|svn_error_compose
argument_list|(
name|error_info
operator|->
name|pending_errors
argument_list|,
name|new_err
argument_list|)
expr_stmt|;
else|else
name|error_info
operator|->
name|pending_errors
operator|=
name|new_err
expr_stmt|;
if|if
condition|(
name|error_info
operator|->
name|user_callback
condition|)
name|error_info
operator|->
name|user_callback
argument_list|(
name|NULL
argument_list|,
operator|(
name|char
operator|*
operator|)
name|msg
argument_list|)
expr_stmt|;
comment|/* ### I hate this cast... */
block|}
end_function

begin_comment
comment|/* Pool cleanup for the cached environment descriptor. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cleanup_env
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bdb_env_t
modifier|*
name|bdb
init|=
name|data
decl_stmt|;
name|bdb
operator|->
name|pool
operator|=
name|NULL
expr_stmt|;
name|bdb
operator|->
name|dbconfig_file
operator|=
name|NULL
expr_stmt|;
comment|/* will be closed during pool destruction */
if|#
directive|if
name|APR_HAS_THREADS
name|apr_threadkey_private_delete
argument_list|(
name|bdb
operator|->
name|error_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
comment|/* If there are no references to this descriptor, free its memory here,      so that we don't leak it if create_env returns an error.      See bdb_close, which takes care of freeing this memory if the      environment is still open when the cache is destroyed. */
if|if
condition|(
operator|!
name|bdb
operator|->
name|refcount
condition|)
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_if
if|#
directive|if
name|APR_HAS_THREADS
end_if

begin_comment
comment|/* This cleanup is the fall back plan.  If the thread exits and the    environment hasn't been closed it's responsible for cleanup of the    thread local error info variable, which would otherwise be leaked.    Normally it will not be called, because svn_fs_bdb__close will    set the thread's error info to NULL after cleaning it up. */
end_comment

begin_function
specifier|static
name|void
name|cleanup_error_info
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|bdb_error_info_t
modifier|*
name|error_info
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|error_info
condition|)
name|svn_error_clear
argument_list|(
name|error_info
operator|->
name|pending_errors
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|error_info
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* APR_HAS_THREADS */
end_comment

begin_comment
comment|/* Create a Berkeley DB environment. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_env
parameter_list|(
name|bdb_env_t
modifier|*
modifier|*
name|bdbp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|db_err
decl_stmt|;
name|bdb_env_t
modifier|*
name|bdb
decl_stmt|;
specifier|const
name|char
modifier|*
name|path_bdb
decl_stmt|;
name|char
modifier|*
name|tmp_path
decl_stmt|,
modifier|*
name|tmp_path_bdb
decl_stmt|;
name|apr_size_t
name|path_size
decl_stmt|,
name|path_bdb_size
decl_stmt|;
if|#
directive|if
name|SVN_BDB_PATH_UTF8
name|path_bdb
operator|=
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|#
directive|else
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_from_utf8
argument_list|(
operator|&
name|path_bdb
argument_list|,
name|svn_dirent_local_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Allocate the whole structure, including strings, from the heap,      because it must survive the cache pool cleanup. */
name|path_size
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
literal|1
expr_stmt|;
name|path_bdb_size
operator|=
name|strlen
argument_list|(
name|path_bdb
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* Using calloc() to ensure the padding bytes in bdb->key (which is used as    * a hash key) are zeroed. */
name|bdb
operator|=
name|calloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bdb
argument_list|)
operator|+
name|path_size
operator|+
name|path_bdb_size
argument_list|)
expr_stmt|;
comment|/* We must initialize this now, as our callers may assume their bdb      pointer is valid when checking for errors.  */
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
name|bdb
argument_list|,
name|cleanup_env
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|bdb
operator|->
name|errpfx_string
argument_list|,
name|BDB_ERRPFX_STRING
argument_list|,
sizeof|sizeof
argument_list|(
name|bdb
operator|->
name|errpfx_string
argument_list|)
argument_list|)
expr_stmt|;
name|bdb
operator|->
name|path
operator|=
name|tmp_path
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|bdb
operator|+
literal|1
operator|)
expr_stmt|;
name|bdb
operator|->
name|path_bdb
operator|=
name|tmp_path_bdb
operator|=
name|tmp_path
operator|+
name|path_size
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|tmp_path
argument_list|,
name|path
argument_list|,
name|path_size
argument_list|)
expr_stmt|;
name|apr_cpystrn
argument_list|(
name|tmp_path_bdb
argument_list|,
name|path_bdb
argument_list|,
name|path_bdb_size
argument_list|)
expr_stmt|;
name|bdb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
operator|*
name|bdbp
operator|=
name|bdb
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
block|{
name|apr_status_t
name|apr_err
init|=
name|apr_threadkey_private_create
argument_list|(
operator|&
name|bdb
operator|->
name|error_info
argument_list|,
name|cleanup_error_info
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_create
argument_list|(
name|apr_err
argument_list|,
name|NULL
argument_list|,
literal|"Can't allocate thread-specific storage"
literal|" for the Berkeley DB environment descriptor"
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* APR_HAS_THREADS */
name|db_err
operator|=
name|db_env_create
argument_list|(
operator|&
operator|(
name|bdb
operator|->
name|env
operator|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_err
condition|)
block|{
comment|/* See the documentation at bdb_env_t's definition why the          (char *) cast is safe and why it is done. */
name|bdb
operator|->
name|env
operator|->
name|set_errpfx
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
operator|(
name|char
operator|*
operator|)
name|bdb
argument_list|)
expr_stmt|;
comment|/* bdb_error_gatherer is in parens to stop macro expansion. */
name|bdb
operator|->
name|env
operator|->
name|set_errcall
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
operator|(
name|bdb_error_gatherer
operator|)
argument_list|)
expr_stmt|;
comment|/* Needed on Windows in case Subversion and Berkeley DB are using          different C runtime libraries  */
name|db_err
operator|=
name|bdb
operator|->
name|env
operator|->
name|set_alloc
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
name|malloc
argument_list|,
name|realloc
argument_list|,
name|free
argument_list|)
expr_stmt|;
comment|/* If we detect a deadlock, select a transaction to abort at          random from those participating in the deadlock.  */
if|if
condition|(
operator|!
name|db_err
condition|)
name|db_err
operator|=
name|bdb
operator|->
name|env
operator|->
name|set_lk_detect
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
name|DB_LOCK_RANDOM
argument_list|)
expr_stmt|;
block|}
return|return
name|convert_bdb_error
argument_list|(
name|bdb
argument_list|,
name|db_err
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The environment descriptor cache. */
end_comment

begin_comment
comment|/* The global pool used for this cache. */
end_comment

begin_decl_stmt
specifier|static
name|apr_pool_t
modifier|*
name|bdb_cache_pool
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The cache.  The items are bdb_env_t structures. */
end_comment

begin_decl_stmt
specifier|static
name|apr_hash_t
modifier|*
name|bdb_cache
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The mutex that protects bdb_cache. */
end_comment

begin_decl_stmt
specifier|static
name|svn_mutex__t
modifier|*
name|bdb_cache_lock
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Cleanup callback to NULL out the cache, so we don't try to use it after    the pool has been cleared during global shutdown. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|clear_cache
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bdb_cache
operator|=
name|NULL
expr_stmt|;
name|bdb_cache_lock
operator|=
name|NULL
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|volatile
name|svn_atomic_t
name|bdb_cache_state
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bdb_init_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|bdb_cache_pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|bdb_cache
operator|=
name|apr_hash_make
argument_list|(
name|bdb_cache_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mutex__init
argument_list|(
operator|&
name|bdb_cache_lock
argument_list|,
name|TRUE
argument_list|,
name|bdb_cache_pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|bdb_cache_pool
argument_list|,
name|NULL
argument_list|,
name|clear_cache
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__init
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_atomic__init_once
argument_list|(
operator|&
name|bdb_cache_state
argument_list|,
name|bdb_init_cb
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Construct a cache key for the BDB environment at PATH in *KEYP.    if DBCONFIG_FILE is not NULL, return the opened file handle.    Allocate from POOL. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bdb_cache_key
parameter_list|(
name|bdb_env_key_t
modifier|*
name|keyp
parameter_list|,
name|apr_file_t
modifier|*
modifier|*
name|dbconfig_file
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|dbcfg_file_name
init|=
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|BDB_CONFIG_FILE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|apr_file_t
modifier|*
name|dbcfg_file
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_finfo_t
name|finfo
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_file_open
argument_list|(
operator|&
name|dbcfg_file
argument_list|,
name|dbcfg_file_name
argument_list|,
name|APR_READ
argument_list|,
name|APR_OS_DEFAULT
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|apr_err
operator|=
name|apr_file_info_get
argument_list|(
operator|&
name|finfo
argument_list|,
name|APR_FINFO_DEV
operator||
name|APR_FINFO_INODE
argument_list|,
name|dbcfg_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't create BDB environment cache key"
argument_list|)
return|;
comment|/* Make sure that any padding in the key is always cleared, so that      the key's hash deterministic. */
name|memset
argument_list|(
name|keyp
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
expr|*
name|keyp
argument_list|)
expr_stmt|;
name|keyp
operator|->
name|device
operator|=
name|finfo
operator|.
name|device
expr_stmt|;
name|keyp
operator|->
name|inode
operator|=
name|finfo
operator|.
name|inode
expr_stmt|;
if|if
condition|(
name|dbconfig_file
condition|)
operator|*
name|dbconfig_file
operator|=
name|dbcfg_file
expr_stmt|;
else|else
name|apr_file_close
argument_list|(
name|dbcfg_file
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find a BDB environment in the cache.    Return the environment's panic state in *PANICP.     Note: You MUST acquire the cache mutex before calling this function. */
end_comment

begin_function
specifier|static
name|bdb_env_t
modifier|*
name|bdb_cache_get
parameter_list|(
specifier|const
name|bdb_env_key_t
modifier|*
name|keyp
parameter_list|,
name|svn_boolean_t
modifier|*
name|panicp
parameter_list|)
block|{
name|bdb_env_t
modifier|*
name|bdb
init|=
name|apr_hash_get
argument_list|(
name|bdb_cache
argument_list|,
name|keyp
argument_list|,
sizeof|sizeof
expr|*
name|keyp
argument_list|)
decl_stmt|;
if|if
condition|(
name|bdb
operator|&&
name|bdb
operator|->
name|env
condition|)
block|{
operator|*
name|panicp
operator|=
operator|!
operator|!
name|svn_atomic_read
argument_list|(
operator|&
name|bdb
operator|->
name|panic
argument_list|)
expr_stmt|;
if|#
directive|if
name|SVN_BDB_VERSION_AT_LEAST
argument_list|(
literal|4
operator|,
literal|2
argument_list|)
if|if
condition|(
operator|!
operator|*
name|panicp
condition|)
block|{
name|u_int32_t
name|flags
decl_stmt|;
if|if
condition|(
name|bdb
operator|->
name|env
operator|->
name|get_flags
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
operator|&
name|flags
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|DB_PANIC_ENVIRONMENT
operator|)
condition|)
block|{
comment|/* Something is wrong with the environment. */
name|svn_atomic_set
argument_list|(
operator|&
name|bdb
operator|->
name|panic
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|panicp
operator|=
name|TRUE
expr_stmt|;
name|bdb
operator|=
name|NULL
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* at least bdb-4.2 */
block|}
else|else
block|{
operator|*
name|panicp
operator|=
name|FALSE
expr_stmt|;
block|}
return|return
name|bdb
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Close and destroy a BDB environment descriptor. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bdb_close
parameter_list|(
name|bdb_env_t
modifier|*
name|bdb
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
comment|/* This bit is delcate; we must propagate the error from      DB_ENV->close to the caller, and always destroy the pool. */
name|int
name|db_err
init|=
name|bdb
operator|->
name|env
operator|->
name|close
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
literal|0
argument_list|)
decl_stmt|;
comment|/* If automatic database recovery is enabled, ignore DB_RUNRECOVERY      errors, since they're dealt with eventually by BDB itself. */
if|if
condition|(
name|db_err
operator|&&
operator|(
operator|!
name|SVN_BDB_AUTO_RECOVER
operator|||
name|db_err
operator|!=
name|DB_RUNRECOVERY
operator|)
condition|)
name|err
operator|=
name|convert_bdb_error
argument_list|(
name|bdb
argument_list|,
name|db_err
argument_list|)
expr_stmt|;
comment|/* Free the environment descriptor. The pool cleanup will do this unless      the cache has already been destroyed. */
if|if
condition|(
name|bdb
operator|->
name|pool
condition|)
name|svn_pool_destroy
argument_list|(
name|bdb
operator|->
name|pool
argument_list|)
expr_stmt|;
else|else
name|free
argument_list|(
name|bdb
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_fs_bdb__close_internal
parameter_list|(
name|bdb_env_t
modifier|*
name|bdb
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
if|if
condition|(
operator|--
name|bdb
operator|->
name|refcount
operator|!=
literal|0
condition|)
block|{
comment|/* If the environment is panicked and automatic recovery is not          enabled, return an appropriate error. */
if|#
directive|if
operator|!
name|SVN_BDB_AUTO_RECOVER
if|if
condition|(
name|svn_atomic_read
argument_list|(
operator|&
name|bdb
operator|->
name|panic
argument_list|)
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_BERKELEY_DB
argument_list|,
name|NULL
argument_list|,
name|db_strerror
argument_list|(
name|DB_RUNRECOVERY
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
comment|/* If the bdb cache has been set to NULL that means we are          shutting down, and the pool that holds the bdb cache has          already been destroyed, so accessing it here would be a Bad          Thing (tm) */
if|if
condition|(
name|bdb_cache
condition|)
name|apr_hash_set
argument_list|(
name|bdb_cache
argument_list|,
operator|&
name|bdb
operator|->
name|key
argument_list|,
sizeof|sizeof
name|bdb
operator|->
name|key
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|bdb_close
argument_list|(
name|bdb
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__close
parameter_list|(
name|bdb_env_baton_t
modifier|*
name|bdb_baton
parameter_list|)
block|{
name|bdb_env_t
modifier|*
name|bdb
init|=
name|bdb_baton
operator|->
name|bdb
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|bdb_baton
operator|->
name|env
operator|==
name|bdb_baton
operator|->
name|bdb
operator|->
name|env
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|bdb_baton
operator|->
name|error_info
operator|->
name|refcount
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* Neutralize bdb_baton's pool cleanup to prevent double-close. See      cleanup_env_baton(). */
name|bdb_baton
operator|->
name|bdb
operator|=
name|NULL
expr_stmt|;
comment|/* Note that we only bother with this cleanup if the pool is non-NULL, to      guard against potential races between this and the cleanup_env cleanup      callback.  It's not clear if that can actually happen, but better safe      than sorry. */
if|if
condition|(
literal|0
operator|==
operator|--
name|bdb_baton
operator|->
name|error_info
operator|->
name|refcount
operator|&&
name|bdb
operator|->
name|pool
condition|)
block|{
name|svn_error_clear
argument_list|(
name|bdb_baton
operator|->
name|error_info
operator|->
name|pending_errors
argument_list|)
expr_stmt|;
if|#
directive|if
name|APR_HAS_THREADS
name|free
argument_list|(
name|bdb_baton
operator|->
name|error_info
argument_list|)
expr_stmt|;
name|apr_threadkey_private_set
argument_list|(
name|NULL
argument_list|,
name|bdb
operator|->
name|error_info
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* This may run during final pool cleanup when the lock is NULL. */
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|bdb_cache_lock
argument_list|,
name|svn_fs_bdb__close_internal
argument_list|(
name|bdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Open and initialize a BDB environment. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|bdb_open
parameter_list|(
name|bdb_env_t
modifier|*
name|bdb
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
if|#
directive|if
name|APR_HAS_THREADS
name|flags
operator||=
name|DB_THREAD
expr_stmt|;
endif|#
directive|endif
name|SVN_ERR
argument_list|(
name|convert_bdb_error
argument_list|(
name|bdb
argument_list|,
call|(
name|bdb
operator|->
name|env
operator|->
name|open
call|)
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
name|bdb
operator|->
name|path_bdb
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|SVN_BDB_AUTO_COMMIT
comment|/* Assert the BDB_AUTO_COMMIT flag on the opened environment. This      will force all operations on the environment (and handles that      are opened within the environment) to be transactional. */
name|SVN_ERR
argument_list|(
name|convert_bdb_error
argument_list|(
name|bdb
argument_list|,
name|bdb
operator|->
name|env
operator|->
name|set_flags
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
name|SVN_BDB_AUTO_COMMIT
argument_list|,
literal|1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|bdb_cache_key
argument_list|(
operator|&
name|bdb
operator|->
name|key
argument_list|,
operator|&
name|bdb
operator|->
name|dbconfig_file
argument_list|,
name|bdb
operator|->
name|path
argument_list|,
name|bdb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Pool cleanup for the environment baton. */
end_comment

begin_function
specifier|static
name|apr_status_t
name|cleanup_env_baton
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|bdb_env_baton_t
modifier|*
name|bdb_baton
init|=
name|data
decl_stmt|;
if|if
condition|(
name|bdb_baton
operator|->
name|bdb
condition|)
name|svn_error_clear
argument_list|(
name|svn_fs_bdb__close
argument_list|(
name|bdb_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|APR_SUCCESS
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|svn_fs_bdb__open_internal
parameter_list|(
name|bdb_env_baton_t
modifier|*
modifier|*
name|bdb_batonp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|bdb_env_key_t
name|key
decl_stmt|;
name|bdb_env_t
modifier|*
name|bdb
decl_stmt|;
name|svn_boolean_t
name|panic
decl_stmt|;
comment|/* We can safely discard the open DB_CONFIG file handle.  If the      environment descriptor is in the cache, the key's immutability is      guaranteed.  If it's not, we don't care if the key changes,      between here and the actual insertion of the newly-created      environment into the cache, because no other thread can touch the      cache in the meantime. */
name|SVN_ERR
argument_list|(
name|bdb_cache_key
argument_list|(
operator|&
name|key
argument_list|,
name|NULL
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|bdb
operator|=
name|bdb_cache_get
argument_list|(
operator|&
name|key
argument_list|,
operator|&
name|panic
argument_list|)
expr_stmt|;
if|if
condition|(
name|panic
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_BERKELEY_DB
argument_list|,
name|NULL
argument_list|,
name|db_strerror
argument_list|(
name|DB_RUNRECOVERY
argument_list|)
argument_list|)
return|;
comment|/* Make sure that the environment's open flags haven't changed. */
if|if
condition|(
name|bdb
operator|&&
name|bdb
operator|->
name|flags
operator|!=
name|flags
condition|)
block|{
comment|/* Handle changes to the DB_PRIVATE flag specially */
if|if
condition|(
operator|(
name|flags
operator|^
name|bdb
operator|->
name|flags
operator|)
operator|&
name|DB_PRIVATE
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|DB_PRIVATE
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_BERKELEY_DB
argument_list|,
name|NULL
argument_list|,
literal|"Reopening a public Berkeley DB"
literal|" environment with private attributes"
argument_list|)
return|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_BERKELEY_DB
argument_list|,
name|NULL
argument_list|,
literal|"Reopening a private Berkeley DB"
literal|" environment with public attributes"
argument_list|)
return|;
block|}
comment|/* Otherwise return a generic "flags-mismatch" error. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_BERKELEY_DB
argument_list|,
name|NULL
argument_list|,
literal|"Reopening a Berkeley DB environment"
literal|" with different attributes"
argument_list|)
return|;
block|}
if|if
condition|(
operator|!
name|bdb
condition|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|SVN_ERR
argument_list|(
name|create_env
argument_list|(
operator|&
name|bdb
argument_list|,
name|path
argument_list|,
name|svn_pool_create
argument_list|(
name|bdb_cache_pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|bdb_open
argument_list|(
name|bdb
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* Clean up, and we can't do anything about returned errors. */
name|svn_error_clear
argument_list|(
name|bdb_close
argument_list|(
name|bdb
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
name|apr_hash_set
argument_list|(
name|bdb_cache
argument_list|,
operator|&
name|bdb
operator|->
name|key
argument_list|,
sizeof|sizeof
name|bdb
operator|->
name|key
argument_list|,
name|bdb
argument_list|)
expr_stmt|;
name|bdb
operator|->
name|flags
operator|=
name|flags
expr_stmt|;
name|bdb
operator|->
name|refcount
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|++
name|bdb
operator|->
name|refcount
expr_stmt|;
block|}
operator|*
name|bdb_batonp
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
expr|*
operator|*
name|bdb_batonp
argument_list|)
expr_stmt|;
operator|(
operator|*
name|bdb_batonp
operator|)
operator|->
name|env
operator|=
name|bdb
operator|->
name|env
expr_stmt|;
operator|(
operator|*
name|bdb_batonp
operator|)
operator|->
name|bdb
operator|=
name|bdb
expr_stmt|;
operator|(
operator|*
name|bdb_batonp
operator|)
operator|->
name|error_info
operator|=
name|get_error_info
argument_list|(
name|bdb
argument_list|)
expr_stmt|;
operator|++
operator|(
operator|*
name|bdb_batonp
operator|)
operator|->
name|error_info
operator|->
name|refcount
expr_stmt|;
name|apr_pool_cleanup_register
argument_list|(
name|pool
argument_list|,
operator|*
name|bdb_batonp
argument_list|,
name|cleanup_env_baton
argument_list|,
name|apr_pool_cleanup_null
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__open
parameter_list|(
name|bdb_env_baton_t
modifier|*
modifier|*
name|bdb_batonp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|u_int32_t
name|flags
parameter_list|,
name|int
name|mode
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_MUTEX__WITH_LOCK
argument_list|(
name|bdb_cache_lock
argument_list|,
name|svn_fs_bdb__open_internal
argument_list|(
name|bdb_batonp
argument_list|,
name|path
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|svn_boolean_t
name|svn_fs_bdb__get_panic
parameter_list|(
name|bdb_env_baton_t
modifier|*
name|bdb_baton
parameter_list|)
block|{
comment|/* An invalid baton is equivalent to a panicked environment; in both      cases, database cleanups should be skipped. */
if|if
condition|(
operator|!
name|bdb_baton
operator|->
name|bdb
condition|)
return|return
name|TRUE
return|;
name|assert
argument_list|(
name|bdb_baton
operator|->
name|env
operator|==
name|bdb_baton
operator|->
name|bdb
operator|->
name|env
argument_list|)
expr_stmt|;
return|return
operator|!
operator|!
name|svn_atomic_read
argument_list|(
operator|&
name|bdb_baton
operator|->
name|bdb
operator|->
name|panic
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_fs_bdb__set_panic
parameter_list|(
name|bdb_env_baton_t
modifier|*
name|bdb_baton
parameter_list|)
block|{
if|if
condition|(
operator|!
name|bdb_baton
operator|->
name|bdb
condition|)
return|return;
name|assert
argument_list|(
name|bdb_baton
operator|->
name|env
operator|==
name|bdb_baton
operator|->
name|bdb
operator|->
name|env
argument_list|)
expr_stmt|;
name|svn_atomic_set
argument_list|(
operator|&
name|bdb_baton
operator|->
name|bdb
operator|->
name|panic
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This function doesn't actually open the environment, so it doesn't    have to look in the cache.  Callers are supposed to own an    exclusive lock on the filesystem anyway. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__remove
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|bdb_env_t
modifier|*
name|bdb
decl_stmt|;
name|SVN_ERR
argument_list|(
name|create_env
argument_list|(
operator|&
name|bdb
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|convert_bdb_error
argument_list|(
name|bdb
argument_list|,
name|bdb
operator|->
name|env
operator|->
name|remove
argument_list|(
name|bdb
operator|->
name|env
argument_list|,
name|bdb
operator|->
name|path_bdb
argument_list|,
name|DB_FORCE
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

