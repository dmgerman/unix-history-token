begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* strings-table.c : operations on the `strings' table  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"bdb_compat.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"../fs.h"
end_include

begin_include
include|#
directive|include
file|"../err.h"
end_include

begin_include
include|#
directive|include
file|"dbt.h"
end_include

begin_include
include|#
directive|include
file|"../trail.h"
end_include

begin_include
include|#
directive|include
file|"../key-gen.h"
end_include

begin_include
include|#
directive|include
file|"../../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"bdb-err.h"
end_include

begin_include
include|#
directive|include
file|"strings-table.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Creating and opening the strings table. ***/
end_comment

begin_function
name|int
name|svn_fs_bdb__open_strings_table
parameter_list|(
name|DB
modifier|*
modifier|*
name|strings_p
parameter_list|,
name|DB_ENV
modifier|*
name|env
parameter_list|,
name|svn_boolean_t
name|create
parameter_list|)
block|{
specifier|const
name|u_int32_t
name|open_flags
init|=
operator|(
name|create
condition|?
operator|(
name|DB_CREATE
operator||
name|DB_EXCL
operator|)
else|:
literal|0
operator|)
decl_stmt|;
name|DB
modifier|*
name|strings
decl_stmt|;
name|BDB_ERR
argument_list|(
name|svn_fs_bdb__check_version
argument_list|()
argument_list|)
expr_stmt|;
name|BDB_ERR
argument_list|(
name|db_create
argument_list|(
operator|&
name|strings
argument_list|,
name|env
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable duplicate keys. This allows the data to be spread out across      multiple records. Note: this must occur before ->open().  */
name|BDB_ERR
argument_list|(
name|strings
operator|->
name|set_flags
argument_list|(
name|strings
argument_list|,
name|DB_DUP
argument_list|)
argument_list|)
expr_stmt|;
name|BDB_ERR
argument_list|(
call|(
name|strings
operator|->
name|open
call|)
argument_list|(
name|SVN_BDB_OPEN_PARAMS
argument_list|(
name|strings
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"strings"
argument_list|,
literal|0
argument_list|,
name|DB_BTREE
argument_list|,
name|open_flags
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|create
condition|)
block|{
name|DBT
name|key
decl_stmt|,
name|value
decl_stmt|;
comment|/* Create the `next-key' table entry.  */
name|BDB_ERR
argument_list|(
name|strings
operator|->
name|put
argument_list|(
name|strings
argument_list|,
literal|0
argument_list|,
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|key
argument_list|,
name|NEXT_KEY_KEY
argument_list|)
argument_list|,
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|value
argument_list|,
literal|"0"
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|strings_p
operator|=
name|strings
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Storing and retrieving strings.  ***/
end_comment

begin_comment
comment|/* Allocate *CURSOR and advance it to first row in the set of rows    whose key is defined by QUERY.  Set *LENGTH to the size of that    first row.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|locate_key
parameter_list|(
name|apr_size_t
modifier|*
name|length
parameter_list|,
name|DBC
modifier|*
modifier|*
name|cursor
parameter_list|,
name|DBT
modifier|*
name|query
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|db_err
decl_stmt|;
name|DBT
name|result
decl_stmt|;
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"cursor"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"creating cursor for reading a string"
argument_list|)
argument_list|,
name|bfd
operator|->
name|strings
operator|->
name|cursor
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
name|cursor
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Set up the DBT for reading the length of the record. */
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|ulen
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|flags
operator||=
name|DB_DBT_USERMEM
expr_stmt|;
comment|/* Advance the cursor to the key that we're looking for. */
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
operator|*
name|cursor
argument_list|,
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_SET
argument_list|)
expr_stmt|;
comment|/* We don't need to svn_fs_base__track_dbt() the result, because nothing      was allocated in it. */
comment|/* If there's no such node, return an appropriately specific error.  */
if|if
condition|(
name|db_err
operator|==
name|DB_NOTFOUND
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
operator|*
name|cursor
argument_list|)
expr_stmt|;
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_STRING
argument_list|,
literal|0
argument_list|,
literal|"No such string '%s'"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|query
operator|->
name|data
argument_list|)
return|;
block|}
if|if
condition|(
name|db_err
condition|)
block|{
name|DBT
name|rerun
decl_stmt|;
if|if
condition|(
name|db_err
operator|!=
name|SVN_BDB_DB_BUFFER_SMALL
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
operator|*
name|cursor
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"moving cursor"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
comment|/* We got an SVN_BDB_DB_BUFFER_SMALL (typical since we have a          zero length buf), so we need to re-run the operation to make          it happen. */
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|rerun
argument_list|)
expr_stmt|;
name|rerun
operator|.
name|flags
operator||=
name|DB_DBT_USERMEM
operator||
name|DB_DBT_PARTIAL
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
operator|*
name|cursor
argument_list|,
name|query
argument_list|,
operator|&
name|rerun
argument_list|,
name|DB_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
operator|*
name|cursor
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"rerunning cursor move"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
block|}
comment|/* ### this cast might not be safe? */
operator|*
name|length
operator|=
operator|(
name|apr_size_t
operator|)
name|result
operator|.
name|size
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Advance CURSOR by a single row in the set of rows whose keys match    CURSOR's current location.  Set *LENGTH to the size of that next    row.  If any error occurs, CURSOR will be destroyed.  */
end_comment

begin_function
specifier|static
name|int
name|get_next_length
parameter_list|(
name|apr_size_t
modifier|*
name|length
parameter_list|,
name|DBC
modifier|*
name|cursor
parameter_list|,
name|DBT
modifier|*
name|query
parameter_list|)
block|{
name|DBT
name|result
decl_stmt|;
name|int
name|db_err
decl_stmt|;
comment|/* Set up the DBT for reading the length of the record. */
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|ulen
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|flags
operator||=
name|DB_DBT_USERMEM
expr_stmt|;
comment|/* Note: this may change the QUERY DBT, but that's okay: we're going      to be sticking with the same key anyways.  */
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_NEXT_DUP
argument_list|)
expr_stmt|;
comment|/* Note that we exit on DB_NOTFOUND. The caller uses that to end a loop. */
if|if
condition|(
name|db_err
condition|)
block|{
name|DBT
name|rerun
decl_stmt|;
if|if
condition|(
name|db_err
operator|!=
name|SVN_BDB_DB_BUFFER_SMALL
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return
name|db_err
return|;
block|}
comment|/* We got an SVN_BDB_DB_BUFFER_SMALL (typical since we have a          zero length buf), so we need to re-run the operation to make          it happen. */
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|rerun
argument_list|)
expr_stmt|;
name|rerun
operator|.
name|flags
operator||=
name|DB_DBT_USERMEM
operator||
name|DB_DBT_PARTIAL
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
name|query
argument_list|,
operator|&
name|rerun
argument_list|,
name|DB_NEXT_DUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
condition|)
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
block|}
comment|/* ### this cast might not be safe? */
operator|*
name|length
operator|=
operator|(
name|apr_size_t
operator|)
name|result
operator|.
name|size
expr_stmt|;
return|return
name|db_err
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__string_read
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|svn_filesize_t
name|offset
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|db_err
decl_stmt|;
name|DBT
name|query
decl_stmt|,
name|result
decl_stmt|;
name|DBC
modifier|*
name|cursor
decl_stmt|;
name|apr_size_t
name|length
decl_stmt|,
name|bytes_read
init|=
literal|0
decl_stmt|;
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|locate_key
argument_list|(
operator|&
name|length
argument_list|,
operator|&
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Seek through the records for this key, trying to find the record that      includes OFFSET. Note that we don't require reading from more than      one record since we're allowed to return partial reads.  */
while|while
condition|(
name|length
operator|<=
name|offset
condition|)
block|{
name|offset
operator|-=
name|length
expr_stmt|;
comment|/* Remember, if any error happens, our cursor has been closed          for us. */
name|db_err
operator|=
name|get_next_length
argument_list|(
operator|&
name|length
argument_list|,
name|cursor
argument_list|,
operator|&
name|query
argument_list|)
expr_stmt|;
comment|/* No more records? They tried to read past the end. */
if|if
condition|(
name|db_err
operator|==
name|DB_NOTFOUND
condition|)
block|{
operator|*
name|len
operator|=
literal|0
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|db_err
condition|)
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"reading string"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
comment|/* The current record contains OFFSET. Fetch the contents now. Note that      OFFSET has been moved to be relative to this record. The length could      quite easily extend past this record, so we use DB_DBT_PARTIAL and      read successive records until we've filled the request.  */
while|while
condition|(
literal|1
condition|)
block|{
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|data
operator|=
name|buf
operator|+
name|bytes_read
expr_stmt|;
name|result
operator|.
name|ulen
operator|=
call|(
name|u_int32_t
call|)
argument_list|(
operator|*
name|len
operator|-
name|bytes_read
argument_list|)
expr_stmt|;
name|result
operator|.
name|doff
operator|=
operator|(
name|u_int32_t
operator|)
name|offset
expr_stmt|;
name|result
operator|.
name|dlen
operator|=
name|result
operator|.
name|ulen
expr_stmt|;
name|result
operator|.
name|flags
operator||=
operator|(
name|DB_DBT_USERMEM
operator||
name|DB_DBT_PARTIAL
operator|)
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"reading string"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
name|bytes_read
operator|+=
name|result
operator|.
name|size
expr_stmt|;
if|if
condition|(
name|bytes_read
operator|==
operator|*
name|len
condition|)
block|{
comment|/* Done with the cursor. */
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"closing string-reading cursor"
argument_list|)
argument_list|,
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Remember, if any error happens, our cursor has been closed          for us. */
name|db_err
operator|=
name|get_next_length
argument_list|(
operator|&
name|length
argument_list|,
name|cursor
argument_list|,
operator|&
name|query
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
operator|==
name|DB_NOTFOUND
condition|)
break|break;
if|if
condition|(
name|db_err
condition|)
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"reading string"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
comment|/* We'll be reading from the beginning of the next record */
name|offset
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|len
operator|=
name|bytes_read
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Get the current 'next-key' value and bump the record. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_key_and_bump
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|DBC
modifier|*
name|cursor
decl_stmt|;
name|char
name|next_key
index|[
name|MAX_KEY_SIZE
index|]
decl_stmt|;
name|apr_size_t
name|key_len
decl_stmt|;
name|int
name|db_err
decl_stmt|;
name|DBT
name|query
decl_stmt|;
name|DBT
name|result
decl_stmt|;
comment|/* ### todo: see issue #409 for why bumping the key as part of this      trail is problematic. */
comment|/* Open a cursor and move it to the 'next-key' value. We can then fetch      the contents and use the cursor to overwrite those contents. Since      this database allows duplicates, we can't do an arbitrary 'put' to      write the new value -- that would append, not overwrite.  */
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"cursor"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"creating cursor for reading a string"
argument_list|)
argument_list|,
name|bfd
operator|->
name|strings
operator|->
name|cursor
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|cursor
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Advance the cursor to 'next-key' and read it. */
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|NEXT_KEY_KEY
argument_list|)
argument_list|,
name|svn_fs_base__result_dbt
argument_list|(
operator|&
name|result
argument_list|)
argument_list|,
name|DB_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"getting next-key value"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
name|svn_fs_base__track_dbt
argument_list|(
operator|&
name|result
argument_list|,
name|pool
argument_list|)
expr_stmt|;
operator|*
name|key
operator|=
name|apr_pstrmemdup
argument_list|(
name|pool
argument_list|,
name|result
operator|.
name|data
argument_list|,
name|result
operator|.
name|size
argument_list|)
expr_stmt|;
comment|/* Bump to future key. */
name|key_len
operator|=
name|result
operator|.
name|size
expr_stmt|;
name|svn_fs_base__next_key
argument_list|(
name|result
operator|.
name|data
argument_list|,
operator|&
name|key_len
argument_list|,
name|next_key
argument_list|)
expr_stmt|;
comment|/* Shove the new key back into the database, at the cursor position. */
name|db_err
operator|=
name|svn_bdb_dbc_put
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|result
argument_list|,
name|next_key
argument_list|)
argument_list|,
name|DB_CURRENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
comment|/* ignore the error, the original is                                     more important. */
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"bumping next string key"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"closing string-reading cursor"
argument_list|)
argument_list|,
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__string_append
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|key
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
specifier|const
name|char
modifier|*
name|buf
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|DBT
name|query
decl_stmt|,
name|result
decl_stmt|;
comment|/* If the passed-in key is NULL, we graciously generate a new string      using the value of the `next-key' record in the strings table. */
if|if
condition|(
operator|*
name|key
operator|==
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|get_key_and_bump
argument_list|(
name|fs
argument_list|,
name|key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Store a new record into the database. */
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"put"
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"appending string"
argument_list|)
argument_list|,
name|bfd
operator|->
name|strings
operator|->
name|put
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
operator|*
name|key
argument_list|)
argument_list|,
name|svn_fs_base__set_dbt
argument_list|(
operator|&
name|result
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__string_clear
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|db_err
decl_stmt|;
name|DBT
name|query
decl_stmt|,
name|result
decl_stmt|;
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* Torch the prior contents */
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"del"
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|bfd
operator|->
name|strings
operator|->
name|del
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|query
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there's no such node, return an appropriately specific error.  */
if|if
condition|(
name|db_err
operator|==
name|DB_NOTFOUND
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_STRING
argument_list|,
literal|0
argument_list|,
literal|"No such string '%s'"
argument_list|,
name|key
argument_list|)
return|;
comment|/* Handle any other error conditions.  */
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"clearing string"
argument_list|)
argument_list|,
name|db_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Shove empty data back in for this key. */
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|result
operator|.
name|data
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|size
operator|=
literal|0
expr_stmt|;
name|result
operator|.
name|flags
operator||=
name|DB_DBT_USERMEM
expr_stmt|;
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"put"
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"storing empty contents"
argument_list|)
argument_list|,
name|bfd
operator|->
name|strings
operator|->
name|put
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__string_size
parameter_list|(
name|svn_filesize_t
modifier|*
name|size
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|db_err
decl_stmt|;
name|DBT
name|query
decl_stmt|;
name|DBC
modifier|*
name|cursor
decl_stmt|;
name|apr_size_t
name|length
decl_stmt|;
name|svn_filesize_t
name|total
decl_stmt|;
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|locate_key
argument_list|(
operator|&
name|length
argument_list|,
operator|&
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
name|fs
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|total
operator|=
name|length
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Remember, if any error happens, our cursor has been closed          for us. */
name|db_err
operator|=
name|get_next_length
argument_list|(
operator|&
name|length
argument_list|,
name|cursor
argument_list|,
operator|&
name|query
argument_list|)
expr_stmt|;
comment|/* No more records? Then return the total length. */
if|if
condition|(
name|db_err
operator|==
name|DB_NOTFOUND
condition|)
block|{
operator|*
name|size
operator|=
name|total
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|db_err
condition|)
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"fetching string length"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
name|total
operator|+=
name|length
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__string_delete
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|int
name|db_err
decl_stmt|;
name|DBT
name|query
decl_stmt|;
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"del"
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|bfd
operator|->
name|strings
operator|->
name|del
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there's no such node, return an appropriately specific error.  */
if|if
condition|(
name|db_err
operator|==
name|DB_NOTFOUND
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_STRING
argument_list|,
literal|0
argument_list|,
literal|"No such string '%s'"
argument_list|,
name|key
argument_list|)
return|;
comment|/* Handle any other error conditions.  */
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"deleting string"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__string_copy
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|new_key
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|DBT
name|query
decl_stmt|;
name|DBT
name|result
decl_stmt|;
name|DBT
name|copykey
decl_stmt|;
name|DBC
modifier|*
name|cursor
decl_stmt|;
name|int
name|db_err
decl_stmt|;
comment|/* Copy off the old key in case the caller is sharing storage      between the old and new keys. */
specifier|const
name|char
modifier|*
name|old_key
init|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_key_and_bump
argument_list|(
name|fs
argument_list|,
name|new_key
argument_list|,
name|trail
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"cursor"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"creating cursor for reading a string"
argument_list|)
argument_list|,
name|bfd
operator|->
name|strings
operator|->
name|cursor
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|cursor
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|old_key
argument_list|)
expr_stmt|;
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|copykey
argument_list|,
operator|*
name|new_key
argument_list|)
expr_stmt|;
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
comment|/* Move to the first record and fetch its data (under BDB's mem mgmt). */
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_SET
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"getting next-key value"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
comment|/* ### can we pass a BDB-provided buffer to another BDB function?          ### they are supposed to have a duration up to certain points          ### of calling back into BDB, but I'm not sure what the exact          ### rules are. it is definitely nicer to use BDB buffers here          ### to simplify things and reduce copies, but... hrm.       */
comment|/* Write the data to the database */
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"strings"
argument_list|,
literal|"put"
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|bfd
operator|->
name|strings
operator|->
name|put
argument_list|(
name|bfd
operator|->
name|strings
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|copykey
argument_list|,
operator|&
name|result
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"writing copied data"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
comment|/* Read the next chunk. Terminate loop if we're done. */
name|svn_fs_base__clear_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_NEXT_DUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|db_err
operator|==
name|DB_NOTFOUND
condition|)
break|break;
if|if
condition|(
name|db_err
condition|)
block|{
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"fetching string data for a copy"
argument_list|)
argument_list|,
name|db_err
argument_list|)
return|;
block|}
block|}
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"closing string-reading cursor"
argument_list|)
argument_list|,
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

