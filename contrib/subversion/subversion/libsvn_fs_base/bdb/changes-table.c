begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* changes-table.c : operations on the `changes' table  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|"bdb_compat.h"
end_include

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|<apr_tables.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"../fs.h"
end_include

begin_include
include|#
directive|include
file|"../err.h"
end_include

begin_include
include|#
directive|include
file|"../trail.h"
end_include

begin_include
include|#
directive|include
file|"../id.h"
end_include

begin_include
include|#
directive|include
file|"../util/fs_skels.h"
end_include

begin_include
include|#
directive|include
file|"../../libsvn_fs/fs-loader.h"
end_include

begin_include
include|#
directive|include
file|"bdb-err.h"
end_include

begin_include
include|#
directive|include
file|"dbt.h"
end_include

begin_include
include|#
directive|include
file|"changes-table.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fs_util.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Creating and opening the changes table. ***/
end_comment

begin_function
name|int
name|svn_fs_bdb__open_changes_table
parameter_list|(
name|DB
modifier|*
modifier|*
name|changes_p
parameter_list|,
name|DB_ENV
modifier|*
name|env
parameter_list|,
name|svn_boolean_t
name|create
parameter_list|)
block|{
specifier|const
name|u_int32_t
name|open_flags
init|=
operator|(
name|create
condition|?
operator|(
name|DB_CREATE
operator||
name|DB_EXCL
operator|)
else|:
literal|0
operator|)
decl_stmt|;
name|DB
modifier|*
name|changes
decl_stmt|;
name|BDB_ERR
argument_list|(
name|svn_fs_bdb__check_version
argument_list|()
argument_list|)
expr_stmt|;
name|BDB_ERR
argument_list|(
name|db_create
argument_list|(
operator|&
name|changes
argument_list|,
name|env
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Enable duplicate keys. This allows us to store the changes      one-per-row.  Note: this must occur before ->open().  */
name|BDB_ERR
argument_list|(
name|changes
operator|->
name|set_flags
argument_list|(
name|changes
argument_list|,
name|DB_DUP
argument_list|)
argument_list|)
expr_stmt|;
name|BDB_ERR
argument_list|(
call|(
name|changes
operator|->
name|open
call|)
argument_list|(
name|SVN_BDB_OPEN_PARAMS
argument_list|(
name|changes
argument_list|,
name|NULL
argument_list|)
argument_list|,
literal|"changes"
argument_list|,
literal|0
argument_list|,
name|DB_BTREE
argument_list|,
name|open_flags
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|changes_p
operator|=
name|changes
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Storing and retrieving changes.  ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__changes_add
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|change_t
modifier|*
name|change
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|DBT
name|query
decl_stmt|,
name|value
decl_stmt|;
name|svn_skel_t
modifier|*
name|skel
decl_stmt|;
comment|/* Convert native type to skel. */
name|SVN_ERR
argument_list|(
name|svn_fs_base__unparse_change_skel
argument_list|(
operator|&
name|skel
argument_list|,
name|change
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Store a new record into the database. */
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|svn_fs_base__skel_to_dbt
argument_list|(
operator|&
name|value
argument_list|,
name|skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"changes"
argument_list|,
literal|"put"
argument_list|)
expr_stmt|;
return|return
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"creating change"
argument_list|)
argument_list|,
name|bfd
operator|->
name|changes
operator|->
name|put
argument_list|(
name|bfd
operator|->
name|changes
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|value
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__changes_delete
parameter_list|(
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|db_err
decl_stmt|;
name|DBT
name|query
decl_stmt|;
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"changes"
argument_list|,
literal|"del"
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|bfd
operator|->
name|changes
operator|->
name|del
argument_list|(
name|bfd
operator|->
name|changes
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* If there're no changes for KEY, that is acceptable.  Any other      error should be propagated to the caller, though.  */
if|if
condition|(
operator|(
name|db_err
operator|)
operator|&&
operator|(
name|db_err
operator|!=
name|DB_NOTFOUND
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"deleting changes"
argument_list|)
argument_list|,
name|db_err
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a deep FS API type copy of SOURCE in internal format and allocate  * the result in RESULT_POOL.  */
end_comment

begin_function
specifier|static
name|svn_fs_path_change2_t
modifier|*
name|change_to_fs_change
parameter_list|(
specifier|const
name|change_t
modifier|*
name|change
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_fs_path_change2_t
modifier|*
name|result
init|=
name|svn_fs__path_change_create_internal
argument_list|(
name|svn_fs_base__id_copy
argument_list|(
name|change
operator|->
name|noderev_id
argument_list|,
name|result_pool
argument_list|)
argument_list|,
name|change
operator|->
name|kind
argument_list|,
name|result_pool
argument_list|)
decl_stmt|;
name|result
operator|->
name|text_mod
operator|=
name|change
operator|->
name|text_mod
expr_stmt|;
name|result
operator|->
name|prop_mod
operator|=
name|change
operator|->
name|prop_mod
expr_stmt|;
name|result
operator|->
name|node_kind
operator|=
name|svn_node_unknown
expr_stmt|;
name|result
operator|->
name|copyfrom_known
operator|=
name|FALSE
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Merge the internal-use-only CHANGE into a hash of public-FS    svn_fs_path_change2_t CHANGES, collapsing multiple changes into a    single succinct change per path. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|fold_change
parameter_list|(
name|apr_hash_t
modifier|*
name|changes
parameter_list|,
name|apr_hash_t
modifier|*
name|deletions
parameter_list|,
specifier|const
name|change_t
modifier|*
name|change
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
init|=
name|apr_hash_pool_get
argument_list|(
name|changes
argument_list|)
decl_stmt|;
name|svn_fs_path_change2_t
modifier|*
name|old_change
decl_stmt|,
modifier|*
name|new_change
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
if|if
condition|(
operator|(
name|old_change
operator|=
name|svn_hash_gets
argument_list|(
name|changes
argument_list|,
name|change
operator|->
name|path
argument_list|)
operator|)
condition|)
block|{
comment|/* This path already exists in the hash, so we have to merge          this change into the already existing one. */
comment|/* Since the path already exists in the hash, we don't have to          dup the allocation for the path itself. */
name|path
operator|=
name|change
operator|->
name|path
expr_stmt|;
comment|/* Sanity check:  only allow NULL node revision ID in the          `reset' case. */
if|if
condition|(
operator|(
operator|!
name|change
operator|->
name|noderev_id
operator|)
operator|&&
operator|(
name|change
operator|->
name|kind
operator|!=
name|svn_fs_path_change_reset
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing required node revision ID"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check:  we should be talking about the same node          revision ID as our last change except where the last change          was a deletion. */
if|if
condition|(
name|change
operator|->
name|noderev_id
operator|&&
operator|(
operator|!
name|svn_fs_base__id_eq
argument_list|(
name|old_change
operator|->
name|node_rev_id
argument_list|,
name|change
operator|->
name|noderev_id
argument_list|)
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_delete
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: new node revision ID without delete"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: an add, replacement, or reset must be the first          thing to follow a deletion. */
if|if
condition|(
operator|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_delete
operator|)
operator|&&
operator|(
operator|!
operator|(
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_replace
operator|)
operator|||
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_reset
operator|)
operator|||
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_add
operator|)
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: non-add change on deleted path"
argument_list|)
argument_list|)
return|;
comment|/* Sanity check: an add can't follow anything except          a delete or reset.  */
if|if
condition|(
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_add
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_delete
operator|)
operator|&&
operator|(
name|old_change
operator|->
name|change_kind
operator|!=
name|svn_fs_path_change_reset
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid change ordering: add change on preexisting path"
argument_list|)
argument_list|)
return|;
comment|/* Now, merge that change in. */
switch|switch
condition|(
name|change
operator|->
name|kind
condition|)
block|{
case|case
name|svn_fs_path_change_reset
case|:
comment|/* A reset here will simply remove the path change from the              hash. */
name|new_change
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_delete
case|:
if|if
condition|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_add
condition|)
block|{
comment|/* If the path was introduced in this transaction via an                  add, and we are deleting it, just remove the path                  altogether. */
name|new_change
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|old_change
operator|->
name|change_kind
operator|==
name|svn_fs_path_change_replace
condition|)
block|{
comment|/* A deleting a 'replace' restore the original deletion. */
name|new_change
operator|=
name|svn_hash_gets
argument_list|(
name|deletions
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|new_change
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* A deletion overrules all previous changes. */
name|new_change
operator|=
name|old_change
expr_stmt|;
name|new_change
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_delete
expr_stmt|;
name|new_change
operator|->
name|text_mod
operator|=
name|change
operator|->
name|text_mod
expr_stmt|;
name|new_change
operator|->
name|prop_mod
operator|=
name|change
operator|->
name|prop_mod
expr_stmt|;
block|}
break|break;
case|case
name|svn_fs_path_change_add
case|:
case|case
name|svn_fs_path_change_replace
case|:
comment|/* An add at this point must be following a previous delete,              so treat it just like a replace. */
name|new_change
operator|=
name|change_to_fs_change
argument_list|(
name|change
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_change
operator|->
name|change_kind
operator|=
name|svn_fs_path_change_replace
expr_stmt|;
comment|/* Remember the original deletion.            * Make sure to allocate the hash key in a durable pool. */
name|svn_hash_sets
argument_list|(
name|deletions
argument_list|,
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|deletions
argument_list|)
argument_list|,
name|path
argument_list|)
argument_list|,
name|old_change
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_fs_path_change_modify
case|:
default|default:
name|new_change
operator|=
name|old_change
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|text_mod
condition|)
name|new_change
operator|->
name|text_mod
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|prop_mod
condition|)
name|new_change
operator|->
name|prop_mod
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* This change is new to the hash, so make a new public change          structure from the internal one (in the hash's pool), and dup          the path into the hash's pool, too. */
name|new_change
operator|=
name|change_to_fs_change
argument_list|(
name|change
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|change
operator|->
name|path
argument_list|)
expr_stmt|;
block|}
comment|/* Add (or update) this path. */
name|svn_hash_sets
argument_list|(
name|changes
argument_list|,
name|path
argument_list|,
name|new_change
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__changes_fetch
parameter_list|(
name|apr_hash_t
modifier|*
modifier|*
name|changes_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|DBC
modifier|*
name|cursor
decl_stmt|;
name|DBT
name|query
decl_stmt|,
name|result
decl_stmt|;
name|int
name|db_err
init|=
literal|0
decl_stmt|,
name|db_c_err
init|=
literal|0
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|apr_hash_t
modifier|*
name|changes
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|deletions
init|=
name|apr_hash_make
argument_list|(
name|subpool
argument_list|)
decl_stmt|;
comment|/* Get a cursor on the first record matching KEY, and then loop over      the records, adding them to the return array. */
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"changes"
argument_list|,
literal|"cursor"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"creating cursor for reading changes"
argument_list|)
argument_list|,
name|bfd
operator|->
name|changes
operator|->
name|cursor
argument_list|(
name|bfd
operator|->
name|changes
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|cursor
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Advance the cursor to the key that we're looking for. */
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|svn_fs_base__result_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_err
condition|)
name|svn_fs_base__track_dbt
argument_list|(
operator|&
name|result
argument_list|,
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|db_err
condition|)
block|{
name|change_t
modifier|*
name|change
decl_stmt|;
name|svn_skel_t
modifier|*
name|result_skel
decl_stmt|;
comment|/* Clear the per-iteration subpool. */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* RESULT now contains a change record associated with KEY.  We          need to parse that skel into an change_t structure ...  */
name|result_skel
operator|=
name|svn_skel__parse
argument_list|(
name|result
operator|.
name|data
argument_list|,
name|result
operator|.
name|size
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result_skel
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error reading changes for key '%s'"
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|err
operator|=
name|svn_fs_base__parse_change_skel
argument_list|(
operator|&
name|change
argument_list|,
name|result_skel
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* ... and merge it with our return hash.  */
name|err
operator|=
name|fold_change
argument_list|(
name|changes
argument_list|,
name|deletions
argument_list|,
name|change
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* Now, if our change was a deletion or replacement, we have to          blow away any changes thus far on paths that are (or, were)          children of this path.          ### i won't bother with another iteration pool here -- at              most we talking about a few extra dups of paths into what              is already a temporary subpool.       */
if|if
condition|(
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_delete
operator|)
operator|||
operator|(
name|change
operator|->
name|kind
operator|==
name|svn_fs_path_change_replace
operator|)
condition|)
block|{
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|iterpool
argument_list|,
name|changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
comment|/* KEY is the path. */
specifier|const
name|void
modifier|*
name|hashkey
decl_stmt|;
name|apr_ssize_t
name|klen
decl_stmt|;
specifier|const
name|char
modifier|*
name|child_relpath
decl_stmt|;
name|apr_hash_this
argument_list|(
name|hi
argument_list|,
operator|&
name|hashkey
argument_list|,
operator|&
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* If we come across our own path, ignore it.                  If we come across a child of our path, remove it. */
name|child_relpath
operator|=
name|svn_fspath__skip_ancestor
argument_list|(
name|change
operator|->
name|path
argument_list|,
name|hashkey
argument_list|)
expr_stmt|;
if|if
condition|(
name|child_relpath
operator|&&
operator|*
name|child_relpath
condition|)
name|apr_hash_set
argument_list|(
name|changes
argument_list|,
name|hashkey
argument_list|,
name|klen
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Advance the cursor to the next record with this same KEY, and          fetch that record. */
name|svn_fs_base__result_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_NEXT_DUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_err
condition|)
name|svn_fs_base__track_dbt
argument_list|(
operator|&
name|result
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Destroy the per-iteration subpool. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
comment|/* If there are no (more) change records for this KEY, we're      finished.  Just return the (possibly empty) array.  Any other      error, however, needs to get handled appropriately.  */
if|if
condition|(
name|db_err
operator|&&
operator|(
name|db_err
operator|!=
name|DB_NOTFOUND
operator|)
condition|)
name|err
operator|=
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"fetching changes"
argument_list|)
argument_list|,
name|db_err
argument_list|)
expr_stmt|;
name|cleanup
label|:
comment|/* Close the cursor. */
name|db_c_err
operator|=
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
comment|/* If we had an error prior to closing the cursor, return the error. */
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* If our only error thus far was when we closed the cursor, return      that error. */
if|if
condition|(
name|db_c_err
condition|)
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"closing changes cursor"
argument_list|)
argument_list|,
name|db_c_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, set our return variable and get outta here. */
operator|*
name|changes_p
operator|=
name|changes
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_fs_bdb__changes_fetch_raw
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|changes_p
parameter_list|,
name|svn_fs_t
modifier|*
name|fs
parameter_list|,
specifier|const
name|char
modifier|*
name|key
parameter_list|,
name|trail_t
modifier|*
name|trail
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|base_fs_data_t
modifier|*
name|bfd
init|=
name|fs
operator|->
name|fsap_data
decl_stmt|;
name|DBC
modifier|*
name|cursor
decl_stmt|;
name|DBT
name|query
decl_stmt|,
name|result
decl_stmt|;
name|int
name|db_err
init|=
literal|0
decl_stmt|,
name|db_c_err
init|=
literal|0
decl_stmt|;
name|svn_error_t
modifier|*
name|err
init|=
name|SVN_NO_ERROR
decl_stmt|;
name|change_t
modifier|*
name|change
decl_stmt|;
name|apr_array_header_t
modifier|*
name|changes
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|change
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Get a cursor on the first record matching KEY, and then loop over      the records, adding them to the return array. */
name|svn_fs_base__trail_debug
argument_list|(
name|trail
argument_list|,
literal|"changes"
argument_list|,
literal|"cursor"
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"creating cursor for reading changes"
argument_list|)
argument_list|,
name|bfd
operator|->
name|changes
operator|->
name|cursor
argument_list|(
name|bfd
operator|->
name|changes
argument_list|,
name|trail
operator|->
name|db_txn
argument_list|,
operator|&
name|cursor
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Advance the cursor to the key that we're looking for. */
name|svn_fs_base__str_to_dbt
argument_list|(
operator|&
name|query
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|svn_fs_base__result_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_SET
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_err
condition|)
name|svn_fs_base__track_dbt
argument_list|(
operator|&
name|result
argument_list|,
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|db_err
condition|)
block|{
name|svn_skel_t
modifier|*
name|result_skel
decl_stmt|;
comment|/* RESULT now contains a change record associated with KEY.  We          need to parse that skel into an change_t structure ...  */
name|result_skel
operator|=
name|svn_skel__parse
argument_list|(
name|result
operator|.
name|data
argument_list|,
name|result
operator|.
name|size
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|result_skel
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_CORRUPT
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Error reading changes for key '%s'"
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|err
operator|=
name|svn_fs_base__parse_change_skel
argument_list|(
operator|&
name|change
argument_list|,
name|result_skel
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|cleanup
goto|;
comment|/* ... and add it to our return array.  */
name|APR_ARRAY_PUSH
argument_list|(
name|changes
argument_list|,
name|change_t
operator|*
argument_list|)
operator|=
name|change
expr_stmt|;
comment|/* Advance the cursor to the next record with this same KEY, and          fetch that record. */
name|svn_fs_base__result_dbt
argument_list|(
operator|&
name|result
argument_list|)
expr_stmt|;
name|db_err
operator|=
name|svn_bdb_dbc_get
argument_list|(
name|cursor
argument_list|,
operator|&
name|query
argument_list|,
operator|&
name|result
argument_list|,
name|DB_NEXT_DUP
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|db_err
condition|)
name|svn_fs_base__track_dbt
argument_list|(
operator|&
name|result
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* If there are no (more) change records for this KEY, we're      finished.  Just return the (possibly empty) array.  Any other      error, however, needs to get handled appropriately.  */
if|if
condition|(
name|db_err
operator|&&
operator|(
name|db_err
operator|!=
name|DB_NOTFOUND
operator|)
condition|)
name|err
operator|=
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"fetching changes"
argument_list|)
argument_list|,
name|db_err
argument_list|)
expr_stmt|;
name|cleanup
label|:
comment|/* Close the cursor. */
name|db_c_err
operator|=
name|svn_bdb_dbc_close
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
comment|/* If we had an error prior to closing the cursor, return the error. */
if|if
condition|(
name|err
condition|)
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
comment|/* If our only error thus far was when we closed the cursor, return      that error. */
if|if
condition|(
name|db_c_err
condition|)
name|SVN_ERR
argument_list|(
name|BDB_WRAP
argument_list|(
name|fs
argument_list|,
name|N_
argument_list|(
literal|"closing changes cursor"
argument_list|)
argument_list|,
name|db_c_err
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Finally, set our return variable and get outta here. */
operator|*
name|changes_p
operator|=
name|changes
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

