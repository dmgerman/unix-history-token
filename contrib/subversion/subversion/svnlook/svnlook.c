begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnlook.c: Subversion server inspection tool main file.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_time.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_define
define|#
directive|define
name|APR_WANT_STDIO
end_define

begin_define
define|#
directive|define
name|APR_WANT_STRFUNC
end_define

begin_include
include|#
directive|include
file|<apr_want.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_error_codes.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_diff.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_diff_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_io_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Some convenience macros and types. ***/
end_comment

begin_escape
end_escape

begin_comment
comment|/* Option handling. */
end_comment

begin_decl_stmt
specifier|static
name|svn_opt_subcommand_t
name|subcommand_author
decl_stmt|,
name|subcommand_cat
decl_stmt|,
name|subcommand_changed
decl_stmt|,
name|subcommand_date
decl_stmt|,
name|subcommand_diff
decl_stmt|,
name|subcommand_dirschanged
decl_stmt|,
name|subcommand_filesize
decl_stmt|,
name|subcommand_help
decl_stmt|,
name|subcommand_history
decl_stmt|,
name|subcommand_info
decl_stmt|,
name|subcommand_lock
decl_stmt|,
name|subcommand_log
decl_stmt|,
name|subcommand_pget
decl_stmt|,
name|subcommand_plist
decl_stmt|,
name|subcommand_tree
decl_stmt|,
name|subcommand_uuid
decl_stmt|,
name|subcommand_youngest
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Option codes and descriptions. */
end_comment

begin_enum
enum|enum
block|{
name|svnlook__version
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|svnlook__show_ids
block|,
name|svnlook__no_diff_deleted
block|,
name|svnlook__no_diff_added
block|,
name|svnlook__diff_copy_from
block|,
name|svnlook__revprop_opt
block|,
name|svnlook__full_paths
block|,
name|svnlook__copy_info
block|,
name|svnlook__xml_opt
block|,
name|svnlook__ignore_properties
block|,
name|svnlook__properties_only
block|,
name|svnlook__diff_cmd
block|,
name|svnlook__show_inherited_props
block|}
enum|;
end_enum

begin_comment
comment|/*  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|options_table
index|[]
init|=
block|{
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
literal|"copy-info"
block|,
name|svnlook__copy_info
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show details for copies"
argument_list|)
block|}
block|,
block|{
literal|"diff-copy-from"
block|,
name|svnlook__diff_copy_from
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"print differences against the copy source"
argument_list|)
block|}
block|,
block|{
literal|"full-paths"
block|,
name|svnlook__full_paths
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show full paths instead of indenting them"
argument_list|)
block|}
block|,
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
literal|"limit"
block|,
literal|'l'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"maximum number of history entries"
argument_list|)
block|}
block|,
block|{
literal|"no-diff-added"
block|,
name|svnlook__no_diff_added
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do not print differences for added files"
argument_list|)
block|}
block|,
block|{
literal|"no-diff-deleted"
block|,
name|svnlook__no_diff_deleted
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"do not print differences for deleted files"
argument_list|)
block|}
block|,
block|{
literal|"diff-cmd"
block|,
name|svnlook__diff_cmd
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"use ARG as diff command"
argument_list|)
block|}
block|,
block|{
literal|"ignore-properties"
block|,
name|svnlook__ignore_properties
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"ignore properties during the operation"
argument_list|)
block|}
block|,
block|{
literal|"properties-only"
block|,
name|svnlook__properties_only
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show only properties during the operation"
argument_list|)
block|}
block|,
block|{
literal|"non-recursive"
block|,
literal|'N'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"operate on single directory only"
argument_list|)
block|}
block|,
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify revision number ARG"
argument_list|)
block|}
block|,
block|{
literal|"revprop"
block|,
name|svnlook__revprop_opt
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"operate on a revision property (use with -r or -t)"
argument_list|)
block|}
block|,
block|{
literal|"show-ids"
block|,
name|svnlook__show_ids
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show node revision ids for each path"
argument_list|)
block|}
block|,
block|{
literal|"show-inherited-props"
block|,
name|svnlook__show_inherited_props
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show path's inherited properties"
argument_list|)
block|}
block|,
block|{
literal|"transaction"
block|,
literal|'t'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify transaction name ARG"
argument_list|)
block|}
block|,
block|{
literal|"verbose"
block|,
literal|'v'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"be verbose"
argument_list|)
block|}
block|,
block|{
literal|"version"
block|,
name|svnlook__version
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
block|,
block|{
literal|"xml"
block|,
name|svnlook__xml_opt
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"output in XML"
argument_list|)
block|}
block|,
block|{
literal|"extensions"
block|,
literal|'x'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Specify differencing options for external diff or\n"
literal|"                             "
literal|"internal diff. Default: '-u'. Options are\n"
literal|"                             "
literal|"separated by spaces. Internal diff takes:\n"
literal|"                             "
literal|"  -u, --unified: Show 3 lines of unified context\n"
literal|"                             "
literal|"  -b, --ignore-space-change: Ignore changes in\n"
literal|"                             "
literal|"    amount of white space\n"
literal|"                             "
literal|"  -w, --ignore-all-space: Ignore all white space\n"
literal|"                             "
literal|"  --ignore-eol-style: Ignore changes in EOL style\n"
literal|"                             "
literal|"  -p, --show-c-function: Show C function name"
argument_list|)
block|}
block|,
block|{
literal|"quiet"
block|,
literal|'q'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"no progress (only errors) to stderr"
argument_list|)
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of available subcommands.  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|cmd_table
index|[]
init|=
block|{
block|{
literal|"author"
block|,
name|subcommand_author
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook author REPOS_PATH\n\n"
literal|"Print the author.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|}
block|}
block|,
block|{
literal|"cat"
block|,
name|subcommand_cat
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook cat REPOS_PATH FILE_PATH\n\n"
literal|"Print the contents of a file.  Leading '/' on FILE_PATH is optional.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|}
block|}
block|,
block|{
literal|"changed"
block|,
name|subcommand_changed
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook changed REPOS_PATH\n\n"
literal|"Print the paths that were changed.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|,
name|svnlook__copy_info
block|}
block|}
block|,
block|{
literal|"date"
block|,
name|subcommand_date
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook date REPOS_PATH\n\n"
literal|"Print the datestamp.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|}
block|}
block|,
block|{
literal|"diff"
block|,
name|subcommand_diff
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook diff REPOS_PATH\n\n"
literal|"Print GNU-style diffs of changed files and properties.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|,
name|svnlook__no_diff_deleted
block|,
name|svnlook__no_diff_added
block|,
name|svnlook__diff_copy_from
block|,
name|svnlook__diff_cmd
block|,
literal|'x'
block|,
name|svnlook__ignore_properties
block|,
name|svnlook__properties_only
block|}
block|}
block|,
block|{
literal|"dirs-changed"
block|,
name|subcommand_dirschanged
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook dirs-changed REPOS_PATH\n\n"
literal|"Print the directories that were themselves changed (property edits)\n"
literal|"or whose file children were changed.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|}
block|}
block|,
block|{
literal|"filesize"
block|,
name|subcommand_filesize
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook filesize REPOS_PATH PATH_IN_REPOS\n\n"
literal|"Print the size (in bytes) of the file located at PATH_IN_REPOS as\n"
literal|"it is represented in the repository.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|}
block|}
block|,
block|{
literal|"help"
block|,
name|subcommand_help
block|,
block|{
literal|"?"
block|,
literal|"h"
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook help [SUBCOMMAND...]\n\n"
literal|"Describe the usage of this program or its subcommands.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"history"
block|,
name|subcommand_history
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook history REPOS_PATH [PATH_IN_REPOS]\n\n"
literal|"Print information about the history of a path in the repository (or\n"
literal|"the root directory if no path is supplied).\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
name|svnlook__show_ids
block|,
literal|'l'
block|}
block|}
block|,
block|{
literal|"info"
block|,
name|subcommand_info
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook info REPOS_PATH\n\n"
literal|"Print the author, datestamp, log message size, and log message.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|}
block|}
block|,
block|{
literal|"lock"
block|,
name|subcommand_lock
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook lock REPOS_PATH PATH_IN_REPOS\n\n"
literal|"If a lock exists on a path in the repository, describe it.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"log"
block|,
name|subcommand_log
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook log REPOS_PATH\n\n"
literal|"Print the log message.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|}
block|}
block|,
block|{
literal|"propget"
block|,
name|subcommand_pget
block|,
block|{
literal|"pget"
block|,
literal|"pg"
block|}
block|,
name|N_
argument_list|(
literal|"usage: 1. svnlook propget REPOS_PATH PROPNAME PATH_IN_REPOS\n"
literal|"                    "
comment|/* The line above is actually needed, so do NOT delete it! */
literal|"       2. svnlook propget --revprop REPOS_PATH PROPNAME\n\n"
literal|"Print the raw value of a property on a path in the repository.\n"
literal|"With --revprop, print the raw value of a revision property.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|,
literal|'v'
block|,
name|svnlook__revprop_opt
block|,
name|svnlook__show_inherited_props
block|}
block|}
block|,
block|{
literal|"proplist"
block|,
name|subcommand_plist
block|,
block|{
literal|"plist"
block|,
literal|"pl"
block|}
block|,
name|N_
argument_list|(
literal|"usage: 1. svnlook proplist REPOS_PATH PATH_IN_REPOS\n"
literal|"                      "
comment|/* The line above is actually needed, so do NOT delete it! */
literal|"       2. svnlook proplist --revprop REPOS_PATH\n\n"
literal|"List the properties of a path in the repository, or\n"
literal|"with the --revprop option, revision properties.\n"
literal|"With -v, show the property values too.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|,
literal|'v'
block|,
name|svnlook__revprop_opt
block|,
name|svnlook__xml_opt
block|,
name|svnlook__show_inherited_props
block|}
block|}
block|,
block|{
literal|"tree"
block|,
name|subcommand_tree
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook tree REPOS_PATH [PATH_IN_REPOS]\n\n"
literal|"Print the tree, starting at PATH_IN_REPOS (if supplied, at the root\n"
literal|"of the tree otherwise), optionally showing node revision ids.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'t'
block|,
literal|'N'
block|,
name|svnlook__show_ids
block|,
name|svnlook__full_paths
block|}
block|}
block|,
block|{
literal|"uuid"
block|,
name|subcommand_uuid
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook uuid REPOS_PATH\n\n"
literal|"Print the repository's UUID.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"youngest"
block|,
name|subcommand_youngest
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnlook youngest REPOS_PATH\n\n"
literal|"Print the youngest revision number.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baton for passing option/argument state to a subcommand function. */
end_comment

begin_struct
struct|struct
name|svnlook_opt_state
block|{
specifier|const
name|char
modifier|*
name|repos_path
decl_stmt|;
comment|/* 'arg0' is always the path to the repository. */
specifier|const
name|char
modifier|*
name|arg1
decl_stmt|;
comment|/* Usually an fs path, a propname, or NULL. */
specifier|const
name|char
modifier|*
name|arg2
decl_stmt|;
comment|/* Usually an fs path or NULL. */
name|svn_revnum_t
name|rev
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn
decl_stmt|;
name|svn_boolean_t
name|version
decl_stmt|;
comment|/* --version */
name|svn_boolean_t
name|show_ids
decl_stmt|;
comment|/* --show-ids */
name|apr_size_t
name|limit
decl_stmt|;
comment|/* --limit */
name|svn_boolean_t
name|help
decl_stmt|;
comment|/* --help */
name|svn_boolean_t
name|no_diff_deleted
decl_stmt|;
comment|/* --no-diff-deleted */
name|svn_boolean_t
name|no_diff_added
decl_stmt|;
comment|/* --no-diff-added */
name|svn_boolean_t
name|diff_copy_from
decl_stmt|;
comment|/* --diff-copy-from */
name|svn_boolean_t
name|verbose
decl_stmt|;
comment|/* --verbose */
name|svn_boolean_t
name|revprop
decl_stmt|;
comment|/* --revprop */
name|svn_boolean_t
name|full_paths
decl_stmt|;
comment|/* --full-paths */
name|svn_boolean_t
name|copy_info
decl_stmt|;
comment|/* --copy-info */
name|svn_boolean_t
name|non_recursive
decl_stmt|;
comment|/* --non-recursive */
name|svn_boolean_t
name|xml
decl_stmt|;
comment|/* --xml */
specifier|const
name|char
modifier|*
name|extensions
decl_stmt|;
comment|/* diff extension args (UTF-8!) */
name|svn_boolean_t
name|quiet
decl_stmt|;
comment|/* --quiet */
name|svn_boolean_t
name|ignore_properties
decl_stmt|;
comment|/* --ignore_properties */
name|svn_boolean_t
name|properties_only
decl_stmt|;
comment|/* --properties-only */
specifier|const
name|char
modifier|*
name|diff_cmd
decl_stmt|;
comment|/* --diff-cmd */
name|svn_boolean_t
name|show_inherited_props
decl_stmt|;
comment|/*  --show-inherited-props */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|svnlook_ctxt_t
block|{
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_boolean_t
name|is_revision
decl_stmt|;
name|svn_boolean_t
name|show_ids
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
name|svn_boolean_t
name|no_diff_deleted
decl_stmt|;
name|svn_boolean_t
name|no_diff_added
decl_stmt|;
name|svn_boolean_t
name|diff_copy_from
decl_stmt|;
name|svn_boolean_t
name|full_paths
decl_stmt|;
name|svn_boolean_t
name|copy_info
decl_stmt|;
name|svn_revnum_t
name|rev_id
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_name
comment|/* UTF-8! */
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|diff_options
decl_stmt|;
name|svn_boolean_t
name|ignore_properties
decl_stmt|;
name|svn_boolean_t
name|properties_only
decl_stmt|;
specifier|const
name|char
modifier|*
name|diff_cmd
decl_stmt|;
block|}
name|svnlook_ctxt_t
typedef|;
end_typedef

begin_comment
comment|/* A flag to see if we've been cancelled by the client or not. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|cancelled
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/*** Helper functions. ***/
end_comment

begin_comment
comment|/* A signal handler to support cancellation. */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|signum
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cancelled
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Our cancellation callback. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_cancel
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
if|if
condition|(
name|cancelled
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Caught signal"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_repos"
block|,
name|svn_repos_version
block|}
block|,
block|{
literal|"svn_fs"
block|,
name|svn_fs_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
literal|"svn_diff"
block|,
name|svn_diff_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Get revision or transaction property PROP_NAME for the revision or    transaction specified in C, allocating in in POOL and placing it in    *PROP_VALUE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_property
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|prop_value
parameter_list|,
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|raw_value
decl_stmt|;
comment|/* Fetch transaction property... */
if|if
condition|(
operator|!
name|c
operator|->
name|is_revision
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_txn_prop
argument_list|(
operator|&
name|raw_value
argument_list|,
name|c
operator|->
name|txn
argument_list|,
name|prop_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ...or revision property -- it's your call. */
else|else
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
operator|&
name|raw_value
argument_list|,
name|c
operator|->
name|fs
argument_list|,
name|c
operator|->
name|rev_id
argument_list|,
name|prop_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|prop_value
operator|=
name|raw_value
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_root
parameter_list|(
name|svn_fs_root_t
modifier|*
modifier|*
name|root
parameter_list|,
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Open up the appropriate root (revision or transaction). */
if|if
condition|(
name|c
operator|->
name|is_revision
condition|)
block|{
comment|/* If we didn't get a valid revision number, we'll look at the          youngest revision. */
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|c
operator|->
name|rev_id
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
operator|(
name|c
operator|->
name|rev_id
operator|)
argument_list|,
name|c
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
name|root
argument_list|,
name|c
operator|->
name|fs
argument_list|,
name|c
operator|->
name|rev_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_txn_root
argument_list|(
name|root
argument_list|,
name|c
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Tree Routines ***/
end_comment

begin_comment
comment|/* Generate a generic delta tree. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|generate_delta_tree
parameter_list|(
name|svn_repos_node_t
modifier|*
modifier|*
name|tree
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_revnum_t
name|base_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|base_root
decl_stmt|;
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
decl_stmt|;
name|void
modifier|*
name|edit_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|edit_pool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
decl_stmt|;
comment|/* Get the base root. */
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|base_root
argument_list|,
name|fs
argument_list|,
name|base_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Request our editor. */
name|SVN_ERR
argument_list|(
name|svn_repos_node_editor
argument_list|(
operator|&
name|editor
argument_list|,
operator|&
name|edit_baton
argument_list|,
name|repos
argument_list|,
name|base_root
argument_list|,
name|root
argument_list|,
name|pool
argument_list|,
name|edit_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Drive our editor. */
name|SVN_ERR
argument_list|(
name|svn_repos_replay2
argument_list|(
name|root
argument_list|,
literal|""
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|TRUE
argument_list|,
name|editor
argument_list|,
name|edit_baton
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|edit_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return the tree we just built. */
operator|*
name|tree
operator|=
name|svn_repos_node_from_baton
argument_list|(
name|edit_baton
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|edit_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Tree Printing Routines ***/
end_comment

begin_comment
comment|/* Recursively print only directory nodes that either a) have property    mods, or b) contains files that have changed, or c) has added or deleted    children.  NODE is the root node of the tree delta, so every node in it    is either changed or is a directory with a changed node somewhere in the    subtree below it.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_dirs_changed_tree
parameter_list|(
name|svn_repos_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|path
comment|/* UTF-8! */
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_node_t
modifier|*
name|tmp_node
decl_stmt|;
name|svn_boolean_t
name|print_me
init|=
name|FALSE
decl_stmt|;
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Not a directory?  We're not interested. */
if|if
condition|(
name|node
operator|->
name|kind
operator|!=
name|svn_node_dir
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Got prop mods?  Excellent. */
if|if
condition|(
name|node
operator|->
name|prop_mod
condition|)
name|print_me
operator|=
name|TRUE
expr_stmt|;
comment|/* Fly through the list of children, checking for modified files. */
name|tmp_node
operator|=
name|node
operator|->
name|child
expr_stmt|;
while|while
condition|(
name|tmp_node
operator|&&
operator|(
operator|!
name|print_me
operator|)
condition|)
block|{
if|if
condition|(
operator|(
name|tmp_node
operator|->
name|kind
operator|==
name|svn_node_file
operator|)
operator|||
operator|(
name|tmp_node
operator|->
name|action
operator|==
literal|'A'
operator|)
operator|||
operator|(
name|tmp_node
operator|->
name|action
operator|==
literal|'D'
operator|)
condition|)
block|{
name|print_me
operator|=
name|TRUE
expr_stmt|;
block|}
name|tmp_node
operator|=
name|tmp_node
operator|->
name|sibling
expr_stmt|;
block|}
comment|/* Print the node if it qualifies. */
if|if
condition|(
name|print_me
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s/\n"
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return here if the node has no children. */
name|tmp_node
operator|=
name|node
operator|->
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|tmp_node
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Recursively handle the node's children. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|tmp_node
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|tmp_node
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|print_dirs_changed_tree
argument_list|(
name|tmp_node
argument_list|,
name|full_path
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|tmp_node
operator|=
name|tmp_node
operator|->
name|sibling
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Recursively print all nodes in the tree that have been modified    (do not include directories affected only by "bubble-up"). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_changed_tree
parameter_list|(
name|svn_repos_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|path
comment|/* UTF-8! */
parameter_list|,
name|svn_boolean_t
name|copy_info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|full_path
decl_stmt|;
name|char
name|status
index|[
literal|4
index|]
init|=
literal|"_  "
decl_stmt|;
name|svn_boolean_t
name|print_me
init|=
name|TRUE
decl_stmt|;
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Print the node. */
if|if
condition|(
name|node
operator|->
name|action
operator|==
literal|'A'
condition|)
block|{
name|status
index|[
literal|0
index|]
operator|=
literal|'A'
expr_stmt|;
if|if
condition|(
name|copy_info
operator|&&
name|node
operator|->
name|copyfrom_path
condition|)
name|status
index|[
literal|2
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|node
operator|->
name|action
operator|==
literal|'D'
condition|)
name|status
index|[
literal|0
index|]
operator|=
literal|'D'
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|action
operator|==
literal|'R'
condition|)
block|{
if|if
condition|(
operator|(
operator|!
name|node
operator|->
name|text_mod
operator|)
operator|&&
operator|(
operator|!
name|node
operator|->
name|prop_mod
operator|)
condition|)
name|print_me
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|text_mod
condition|)
name|status
index|[
literal|0
index|]
operator|=
literal|'U'
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|prop_mod
condition|)
name|status
index|[
literal|1
index|]
operator|=
literal|'U'
expr_stmt|;
block|}
else|else
name|print_me
operator|=
name|FALSE
expr_stmt|;
comment|/* Print this node unless told to skip it. */
if|if
condition|(
name|print_me
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s %s%s\n"
argument_list|,
name|status
argument_list|,
name|path
argument_list|,
name|node
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
literal|"/"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|copy_info
operator|&&
name|node
operator|->
name|copyfrom_path
condition|)
comment|/* Remove the leading slash from the copyfrom path for consistency            with the rest of the output. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"    (from %s%s:r%ld)\n"
argument_list|,
operator|(
name|node
operator|->
name|copyfrom_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
name|node
operator|->
name|copyfrom_path
operator|+
literal|1
else|:
name|node
operator|->
name|copyfrom_path
operator|)
argument_list|,
operator|(
name|node
operator|->
name|kind
operator|==
name|svn_node_dir
condition|?
literal|"/"
else|:
literal|""
operator|)
argument_list|,
name|node
operator|->
name|copyfrom_rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Return here if the node has no children. */
name|node
operator|=
name|node
operator|->
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Recursively handle the node's children. */
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|full_path
operator|=
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|print_changed_tree
argument_list|(
name|node
argument_list|,
name|full_path
argument_list|,
name|copy_info
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|sibling
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|dump_contents
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
comment|/* UTF-8! */
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|root
operator|==
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
comment|/* leave an empty file */
else|else
block|{
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
comment|/* Grab the contents and copy them into the given stream. */
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|contents
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Prepare temporary files *TMPFILE1 and *TMPFILE2 for diffing    PATH1@ROOT1 versus PATH2@ROOT2.  If either ROOT1 or ROOT2 is NULL,    the temporary file for its path/root will be an empty one.    Otherwise, its temporary file will contain the contents of that    path/root in the repository.     An exception to this is when either path/root has an svn:mime-type    property set on it which indicates that the file contains    non-textual data -- in this case, the *IS_BINARY flag is set and no    temporary files are created.     Use POOL for all that allocation goodness. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|prepare_tmpfiles
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|tmpfile1
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|tmpfile2
parameter_list|,
name|svn_boolean_t
modifier|*
name|is_binary
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root1
parameter_list|,
specifier|const
name|char
modifier|*
name|path1
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root2
parameter_list|,
specifier|const
name|char
modifier|*
name|path2
parameter_list|,
specifier|const
name|char
modifier|*
name|tmpdir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|mimetype
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Init the return values. */
operator|*
name|tmpfile1
operator|=
name|NULL
expr_stmt|;
operator|*
name|tmpfile2
operator|=
name|NULL
expr_stmt|;
operator|*
name|is_binary
operator|=
name|FALSE
expr_stmt|;
name|assert
argument_list|(
name|path1
operator|&&
name|path2
argument_list|)
expr_stmt|;
comment|/* Check for binary mimetypes.  If either file has a binary      mimetype, get outta here.  */
if|if
condition|(
name|root1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_node_prop
argument_list|(
operator|&
name|mimetype
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mimetype
operator|&&
name|svn_mime_type_is_binary
argument_list|(
name|mimetype
operator|->
name|data
argument_list|)
condition|)
block|{
operator|*
name|is_binary
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|if
condition|(
name|root2
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_node_prop
argument_list|(
operator|&
name|mimetype
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|SVN_PROP_MIME_TYPE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mimetype
operator|&&
name|svn_mime_type_is_binary
argument_list|(
name|mimetype
operator|->
name|data
argument_list|)
condition|)
block|{
operator|*
name|is_binary
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
comment|/* Now, prepare the two temporary files, each of which will either      be empty, or will have real contents.  */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmpfile1
argument_list|,
name|tmpdir
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_contents
argument_list|(
name|stream
argument_list|,
name|root1
argument_list|,
name|path1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|stream
argument_list|,
name|tmpfile2
argument_list|,
name|tmpdir
argument_list|,
name|svn_io_file_del_none
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|dump_contents
argument_list|(
name|stream
argument_list|,
name|root2
argument_list|,
name|path2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Generate a diff label for PATH in ROOT, allocating in POOL.    ROOT may be NULL, in which case revision 0 is used. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|generate_label
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|label
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|date
decl_stmt|;
specifier|const
name|char
modifier|*
name|datestr
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
if|if
condition|(
name|root
condition|)
block|{
name|svn_fs_t
modifier|*
name|fs
init|=
name|svn_fs_root_fs
argument_list|(
name|root
argument_list|)
decl_stmt|;
if|if
condition|(
name|svn_fs_is_revision_root
argument_list|(
name|root
argument_list|)
condition|)
block|{
name|rev
operator|=
name|svn_fs_revision_root_revision
argument_list|(
name|root
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_prop
argument_list|(
operator|&
name|date
argument_list|,
name|fs
argument_list|,
name|rev
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|name
operator|=
name|svn_fs_txn_root_name
argument_list|(
name|root
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_txn_prop
argument_list|(
operator|&
name|date
argument_list|,
name|txn
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|rev
operator|=
literal|0
expr_stmt|;
name|date
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|date
condition|)
name|datestr
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%.10s %.8s UTC"
argument_list|,
name|date
operator|->
name|data
argument_list|,
name|date
operator|->
name|data
operator|+
literal|11
argument_list|)
expr_stmt|;
else|else
name|datestr
operator|=
literal|"                       "
expr_stmt|;
if|if
condition|(
name|name
condition|)
operator|*
name|label
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\t%s (txn %s)"
argument_list|,
name|path
argument_list|,
name|datestr
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|*
name|label
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\t%s (rev %ld)"
argument_list|,
name|path
argument_list|,
name|datestr
argument_list|,
name|rev
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Helper function to display differences in properties of a file */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|display_prop_diffs
parameter_list|(
name|svn_stream_t
modifier|*
name|outstream
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|propchanges
parameter_list|,
name|apr_hash_t
modifier|*
name|original_props
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|outstream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"%sProperty changes on: %s%s"
argument_list|)
argument_list|,
name|APR_EOL_STR
argument_list|,
name|path
argument_list|,
name|APR_EOL_STR
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
argument|outstream
argument_list|,
argument|encoding
argument_list|,
argument|pool
argument_list|,
argument|SVN_DIFF__UNDER_STRING APR_EOL_STR
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff__display_prop_diffs
argument_list|(
name|outstream
argument_list|,
name|encoding
argument_list|,
name|propchanges
argument_list|,
name|original_props
argument_list|,
name|FALSE
comment|/* pretty_print_mergeinfo */
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Recursively print all nodes in the tree that have been modified    (do not include directories affected only by "bubble-up"). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_diff_tree
parameter_list|(
name|svn_stream_t
modifier|*
name|out_stream
parameter_list|,
specifier|const
name|char
modifier|*
name|encoding
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
name|svn_fs_root_t
modifier|*
name|base_root
parameter_list|,
name|svn_repos_node_t
modifier|*
name|node
parameter_list|,
specifier|const
name|char
modifier|*
name|path
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|char
modifier|*
name|base_path
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|tmpdir
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|orig_path
init|=
name|NULL
decl_stmt|,
modifier|*
name|new_path
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|do_diff
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|orig_empty
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|is_copy
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|binary
init|=
name|FALSE
decl_stmt|;
name|svn_boolean_t
name|diff_header_printed
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|header
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|header
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Print copyfrom history for the top node of a copied tree. */
if|if
condition|(
operator|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|node
operator|->
name|copyfrom_rev
argument_list|)
operator|)
operator|&&
operator|(
name|node
operator|->
name|copyfrom_path
operator|!=
name|NULL
operator|)
condition|)
block|{
comment|/* This is ... a copy. */
name|is_copy
operator|=
name|TRUE
expr_stmt|;
comment|/* Propagate the new base.  Copyfrom paths usually start with a          slash; we remove it for consistency with the target path.          ### Yes, it would be *much* better for something in the path              library to be taking care of this! */
if|if
condition|(
name|node
operator|->
name|copyfrom_path
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|base_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|node
operator|->
name|copyfrom_path
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
name|base_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|node
operator|->
name|copyfrom_path
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|header
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Copied: %s (from rev %ld, %s)\n"
argument_list|)
argument_list|,
name|path
argument_list|,
name|node
operator|->
name|copyfrom_rev
argument_list|,
name|base_path
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|base_root
argument_list|,
name|svn_fs_root_fs
argument_list|(
name|base_root
argument_list|)
argument_list|,
name|node
operator|->
name|copyfrom_rev
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/*** First, we'll just print file content diffs. ***/
if|if
condition|(
name|node
operator|->
name|kind
operator|==
name|svn_node_file
condition|)
block|{
comment|/* Here's the generalized way we do our diffs:           - First, we'll check for svn:mime-type properties on the old            and new files.  If either has such a property, and it            represents a binary type, we won't actually be doing a real            diff.           - Second, dump the contents of the new version of the file            into the temporary directory.           - Then, dump the contents of the old version of the file into            the temporary directory.           - Next, we run 'diff', passing the repository paths as the            labels.           - Finally, we delete the temporary files.  */
if|if
condition|(
name|node
operator|->
name|action
operator|==
literal|'R'
operator|&&
name|node
operator|->
name|text_mod
condition|)
block|{
name|do_diff
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prepare_tmpfiles
argument_list|(
operator|&
name|orig_path
argument_list|,
operator|&
name|new_path
argument_list|,
operator|&
name|binary
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|tmpdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|diff_copy_from
operator|&&
name|node
operator|->
name|action
operator|==
literal|'A'
operator|&&
name|is_copy
condition|)
block|{
if|if
condition|(
name|node
operator|->
name|text_mod
condition|)
block|{
name|do_diff
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prepare_tmpfiles
argument_list|(
operator|&
name|orig_path
argument_list|,
operator|&
name|new_path
argument_list|,
operator|&
name|binary
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|tmpdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|c
operator|->
name|no_diff_added
operator|&&
name|node
operator|->
name|action
operator|==
literal|'A'
condition|)
block|{
name|do_diff
operator|=
name|TRUE
expr_stmt|;
name|orig_empty
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prepare_tmpfiles
argument_list|(
operator|&
name|orig_path
argument_list|,
operator|&
name|new_path
argument_list|,
operator|&
name|binary
argument_list|,
name|NULL
argument_list|,
name|base_path
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|tmpdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|c
operator|->
name|no_diff_deleted
operator|&&
name|node
operator|->
name|action
operator|==
literal|'D'
condition|)
block|{
name|do_diff
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|prepare_tmpfiles
argument_list|(
operator|&
name|orig_path
argument_list|,
operator|&
name|new_path
argument_list|,
operator|&
name|binary
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|NULL
argument_list|,
name|path
argument_list|,
name|tmpdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* The header for the copy case has already been created, and we don't          want a header here for files with only property modifications. */
if|if
condition|(
name|header
operator|->
name|len
operator|==
literal|0
operator|&&
operator|(
name|node
operator|->
name|action
operator|!=
literal|'R'
operator|||
name|node
operator|->
name|text_mod
operator|)
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|header
argument_list|,
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
operator|(
operator|(
name|node
operator|->
name|action
operator|==
literal|'A'
operator|)
condition|?
name|_
argument_list|(
literal|"Added"
argument_list|)
else|:
operator|(
operator|(
name|node
operator|->
name|action
operator|==
literal|'D'
operator|)
condition|?
name|_
argument_list|(
literal|"Deleted"
argument_list|)
else|:
operator|(
operator|(
name|node
operator|->
name|action
operator|==
literal|'R'
operator|)
condition|?
name|_
argument_list|(
literal|"Modified"
argument_list|)
else|:
name|_
argument_list|(
literal|"Index"
argument_list|)
operator|)
operator|)
operator|)
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|do_diff
operator|&&
operator|(
operator|!
name|c
operator|->
name|properties_only
operator|)
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|header
argument_list|,
name|SVN_DIFF__EQUAL_STRING
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|binary
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|header
argument_list|,
name|_
argument_list|(
literal|"(Binary files differ)\n\n"
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|header
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|->
name|diff_cmd
condition|)
block|{
name|apr_file_t
modifier|*
name|outfile
decl_stmt|;
name|apr_file_t
modifier|*
name|errfile
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
specifier|const
name|char
modifier|*
name|errfilename
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|err_stream
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|diff_cmd_argv
decl_stmt|;
name|int
name|diff_cmd_argc
decl_stmt|;
name|int
name|exitcode
decl_stmt|;
specifier|const
name|char
modifier|*
name|orig_label
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_label
decl_stmt|;
name|diff_cmd_argv
operator|=
name|NULL
expr_stmt|;
name|diff_cmd_argc
operator|=
name|c
operator|->
name|diff_options
operator|->
name|nelts
expr_stmt|;
if|if
condition|(
name|diff_cmd_argc
condition|)
block|{
name|int
name|i
decl_stmt|;
name|diff_cmd_argv
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|diff_cmd_argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|diff_cmd_argc
condition|;
name|i
operator|++
control|)
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|diff_cmd_argv
index|[
name|i
index|]
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|c
operator|->
name|diff_options
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Print diff header. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|header
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_empty
condition|)
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|orig_label
argument_list|,
name|NULL
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|orig_label
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|new_label
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We deal in streams, but svn_io_run_diff2() deals in file                  handles, so we may need to make temporary files and then                  copy the contents to our stream. */
name|outfile
operator|=
name|svn_stream__aprfile
argument_list|(
name|out_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|outfile
condition|)
name|outfilename
operator|=
name|NULL
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|outfile
argument_list|,
operator|&
name|outfilename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stderr
argument_list|(
operator|&
name|err_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|errfile
operator|=
name|svn_stream__aprfile
argument_list|(
name|err_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|errfile
condition|)
name|errfilename
operator|=
name|NULL
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_io_open_unique_file3
argument_list|(
operator|&
name|errfile
argument_list|,
operator|&
name|errfilename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_run_diff2
argument_list|(
literal|"."
argument_list|,
name|diff_cmd_argv
argument_list|,
name|diff_cmd_argc
argument_list|,
name|orig_label
argument_list|,
name|new_label
argument_list|,
name|orig_path
argument_list|,
name|new_path
argument_list|,
operator|&
name|exitcode
argument_list|,
name|outfile
argument_list|,
name|errfile
argument_list|,
name|c
operator|->
name|diff_cmd
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now, open and copy our files to our output streams. */
if|if
condition|(
name|outfilename
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|outfile
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|outfilename
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|stream
argument_list|,
name|svn_stream_disown
argument_list|(
name|out_stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errfilename
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_io_file_close
argument_list|(
name|errfile
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|stream
argument_list|,
name|errfilename
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|stream
argument_list|,
name|svn_stream_disown
argument_list|(
name|err_stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|diff_header_printed
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|svn_diff_t
modifier|*
name|diff
decl_stmt|;
name|svn_diff_file_options_t
modifier|*
name|opts
init|=
name|svn_diff_file_options_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|diff_options
condition|)
name|SVN_ERR
argument_list|(
name|svn_diff_file_options_parse
argument_list|(
name|opts
argument_list|,
name|c
operator|->
name|diff_options
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_diff_2
argument_list|(
operator|&
name|diff
argument_list|,
name|orig_path
argument_list|,
name|new_path
argument_list|,
name|opts
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_diff_contains_diffs
argument_list|(
name|diff
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|orig_label
decl_stmt|,
modifier|*
name|new_label
decl_stmt|;
comment|/* Print diff header. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|header
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|orig_empty
condition|)
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|orig_label
argument_list|,
name|NULL
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|orig_label
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|new_label
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_diff_file_output_unified3
argument_list|(
name|out_stream
argument_list|,
name|diff
argument_list|,
name|orig_path
argument_list|,
name|new_path
argument_list|,
name|orig_label
argument_list|,
name|new_label
argument_list|,
name|svn_cmdline_output_encoding
argument_list|(
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|opts
operator|->
name|show_c_function
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|diff_header_printed
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|node
operator|->
name|prop_mod
operator|&&
operator|(
operator|(
operator|!
name|c
operator|->
name|no_diff_added
operator|&&
name|node
operator|->
name|action
operator|==
literal|'A'
operator|)
operator|||
operator|(
operator|!
name|c
operator|->
name|no_diff_deleted
operator|&&
name|node
operator|->
name|action
operator|==
literal|'D'
operator|)
operator|)
condition|)
block|{
comment|/* There was an empty file added or deleted in this revision.                    * We can't print a diff, but we can at least print                    * a diff header since we know what happened to this file. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|header
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* Make sure we delete any temporary files. */
if|if
condition|(
name|orig_path
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|orig_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_path
condition|)
name|SVN_ERR
argument_list|(
name|svn_io_remove_file2
argument_list|(
name|new_path
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/*** Now handle property diffs ***/
if|if
condition|(
operator|(
name|node
operator|->
name|prop_mod
operator|)
operator|&&
operator|(
name|node
operator|->
name|action
operator|!=
literal|'D'
operator|)
operator|&&
operator|(
operator|!
name|c
operator|->
name|ignore_properties
operator|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|local_proptable
decl_stmt|;
name|apr_hash_t
modifier|*
name|base_proptable
decl_stmt|;
name|apr_array_header_t
modifier|*
name|propchanges
decl_stmt|,
modifier|*
name|props
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|local_proptable
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|diff_copy_from
operator|&&
name|node
operator|->
name|action
operator|==
literal|'A'
operator|&&
name|is_copy
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|base_proptable
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|node
operator|->
name|action
operator|==
literal|'A'
condition|)
name|base_proptable
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
else|else
comment|/* node->action == 'R' */
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|base_proptable
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|propchanges
argument_list|,
name|local_proptable
argument_list|,
name|base_proptable
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_categorize_props
argument_list|(
name|propchanges
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|->
name|nelts
operator|>
literal|0
condition|)
block|{
comment|/* We print a diff header for the case when we only have property            * mods. */
if|if
condition|(
operator|!
name|diff_header_printed
condition|)
block|{
specifier|const
name|char
modifier|*
name|orig_label
decl_stmt|,
modifier|*
name|new_label
decl_stmt|;
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|orig_label
argument_list|,
name|base_root
argument_list|,
name|base_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|generate_label
argument_list|(
operator|&
name|new_label
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
literal|"Index: %s\n"
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf_from_utf8
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|pool
argument_list|,
name|SVN_DIFF__EQUAL_STRING
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ---<label1>                * +++<label2> */
name|SVN_ERR
argument_list|(
name|svn_diff__unidiff_write_header
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|orig_label
argument_list|,
name|new_label
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|display_prop_diffs
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|props
argument_list|,
name|base_proptable
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Return here if the node has no children. */
name|node
operator|=
name|node
operator|->
name|child
expr_stmt|;
if|if
condition|(
operator|!
name|node
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Recursively handle the node's children. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|print_diff_tree
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|root
argument_list|,
name|base_root
argument_list|,
name|node
argument_list|,
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|svn_dirent_join
argument_list|(
name|base_path
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|c
argument_list|,
name|tmpdir
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|node
operator|->
name|sibling
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|sibling
expr_stmt|;
name|SVN_ERR
argument_list|(
name|print_diff_tree
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|root
argument_list|,
name|base_root
argument_list|,
name|node
argument_list|,
name|svn_dirent_join
argument_list|(
name|path
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|svn_dirent_join
argument_list|(
name|base_path
argument_list|,
name|node
operator|->
name|name
argument_list|,
name|subpool
argument_list|)
argument_list|,
name|c
argument_list|,
name|tmpdir
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print a repository directory, maybe recursively, possibly showing    the node revision ids, and optionally using full paths.     ROOT is the revision or transaction root used to build that tree.    PATH and ID are the current path and node revision id being    printed, and INDENTATION the number of spaces to prepent to that    path's printed output.  ID may be NULL if SHOW_IDS is FALSE (in    which case, ids won't be printed at all).  If RECURSE is TRUE,    then print the tree recursively; otherwise, we'll stop after the    first level (and use INDENTATION to keep track of how deep we are).     Use POOL for all allocations.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_tree
parameter_list|(
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
comment|/* UTF-8! */
parameter_list|,
specifier|const
name|svn_fs_id_t
modifier|*
name|id
parameter_list|,
name|svn_boolean_t
name|is_dir
parameter_list|,
name|int
name|indentation
parameter_list|,
name|svn_boolean_t
name|show_ids
parameter_list|,
name|svn_boolean_t
name|full_paths
parameter_list|,
name|svn_boolean_t
name|recurse
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
name|apr_hash_t
modifier|*
name|entries
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Print the indentation. */
if|if
condition|(
operator|!
name|full_paths
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|indentation
condition|;
name|i
operator|++
control|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|" "
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* ### The path format is inconsistent.. needs fix */
if|if
condition|(
name|full_paths
condition|)
name|name
operator|=
name|path
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|name
operator|=
name|svn_fspath__basename
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|name
operator|=
name|svn_relpath_basename
argument_list|(
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|name
argument_list|)
condition|)
name|name
operator|=
literal|"/"
expr_stmt|;
comment|/* basename of '/' is "" */
comment|/* Print the node. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s%s"
argument_list|,
name|name
argument_list|,
name|is_dir
operator|&&
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"/"
argument_list|)
condition|?
literal|"/"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_ids
condition|)
block|{
name|svn_string_t
modifier|*
name|unparsed_id
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|id
condition|)
name|unparsed_id
operator|=
name|svn_fs_unparse_id
argument_list|(
name|id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"<%s>"
argument_list|,
name|unparsed_id
condition|?
name|unparsed_id
operator|->
name|data
else|:
name|_
argument_list|(
literal|"unknown"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Return here if PATH is not a directory. */
if|if
condition|(
operator|!
name|is_dir
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Recursively handle the node's children. */
if|if
condition|(
name|recurse
operator|||
operator|(
name|indentation
operator|==
literal|0
operator|)
condition|)
block|{
name|apr_array_header_t
modifier|*
name|sorted_entries
decl_stmt|;
name|int
name|i
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_dir_entries
argument_list|(
operator|&
name|entries
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|sorted_entries
operator|=
name|svn_sort__hash
argument_list|(
name|entries
argument_list|,
name|svn_sort_compare_items_lexically
argument_list|,
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sorted_entries
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_sort__item_t
name|item
init|=
name|APR_ARRAY_IDX
argument_list|(
name|sorted_entries
argument_list|,
name|i
argument_list|,
name|svn_sort__item_t
argument_list|)
decl_stmt|;
name|svn_fs_dirent_t
modifier|*
name|entry
init|=
name|item
operator|.
name|value
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|print_tree
argument_list|(
name|root
argument_list|,
operator|(
operator|*
name|path
operator|==
literal|'/'
operator|)
condition|?
name|svn_fspath__join
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|pool
argument_list|)
else|:
name|svn_relpath_join
argument_list|(
name|path
argument_list|,
name|entry
operator|->
name|name
argument_list|,
name|pool
argument_list|)
argument_list|,
name|entry
operator|->
name|id
argument_list|,
operator|(
name|entry
operator|->
name|kind
operator|==
name|svn_node_dir
operator|)
argument_list|,
name|indentation
operator|+
literal|1
argument_list|,
name|show_ids
argument_list|,
name|full_paths
argument_list|,
name|recurse
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *BASE_REV to the revision on which the target root specified in    C is based, or to SVN_INVALID_REVNUM when C represents "revision    0" (because that revision isn't based on another revision). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_base_rev
parameter_list|(
name|svn_revnum_t
modifier|*
name|base_rev
parameter_list|,
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|c
operator|->
name|is_revision
condition|)
block|{
operator|*
name|base_rev
operator|=
name|c
operator|->
name|rev_id
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|*
name|base_rev
operator|=
name|svn_fs_txn_base_revision
argument_list|(
name|c
operator|->
name|txn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|base_rev
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NO_SUCH_REVISION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Transaction '%s' is not based on a revision; how odd"
argument_list|)
argument_list|,
name|c
operator|->
name|txn_name
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Subcommand handlers. ***/
end_comment

begin_comment
comment|/* Print the revision's log message to stdout, followed by a newline. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_log
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|svn_boolean_t
name|print_size
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|prop_value
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_value_eol
decl_stmt|,
modifier|*
name|prop_value_native
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_property
argument_list|(
operator|&
name|prop_value
argument_list|,
name|c
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|prop_value
operator|&&
name|prop_value
operator|->
name|data
operator|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|print_size
condition|?
literal|"0"
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* We immitate what svn_cmdline_printf does here, since we need the byte      size of what we are going to print. */
name|SVN_ERR
argument_list|(
name|svn_subst_translate_cstring2
argument_list|(
name|prop_value
operator|->
name|data
argument_list|,
operator|&
name|prop_value_eol
argument_list|,
name|APR_EOL_STR
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|prop_value_native
argument_list|,
name|prop_value_eol
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|prop_value_native
operator|=
name|svn_cmdline_cstring_from_utf8_fuzzy
argument_list|(
name|prop_value_eol
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|prop_value_native
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_size
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
literal|"\n"
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Use a stream to bypass all stdio translations. */
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stream
argument_list|,
name|prop_value_native
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print the timestamp of the commit (in the revision case) or the    empty string (in the transaction case) to stdout, followed by a    newline. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_date
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|prop_value
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_property
argument_list|(
operator|&
name|prop_value
argument_list|,
name|c
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_value
operator|&&
name|prop_value
operator|->
name|data
condition|)
block|{
comment|/* Convert the date for humans. */
name|apr_time_t
name|aprtime
decl_stmt|;
specifier|const
name|char
modifier|*
name|time_utf8
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_time_from_cstring
argument_list|(
operator|&
name|aprtime
argument_list|,
name|prop_value
operator|->
name|data
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|time_utf8
operator|=
name|svn_time_to_human_cstring
argument_list|(
name|aprtime
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|time_utf8
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print the author of the commit to stdout, followed by a newline. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_author
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
modifier|*
name|prop_value
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_property
argument_list|(
operator|&
name|prop_value
argument_list|,
name|c
argument_list|,
name|SVN_PROP_REVISION_AUTHOR
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prop_value
operator|&&
name|prop_value
operator|->
name|data
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s"
argument_list|,
name|prop_value
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"\n"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print a list of all directories in which files, or directory    properties, have been modified. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_dirs_changed
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|base_rev_id
decl_stmt|;
name|svn_repos_node_t
modifier|*
name|tree
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_base_rev
argument_list|(
operator|&
name|base_rev_id
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_rev_id
operator|==
name|SVN_INVALID_REVNUM
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|generate_delta_tree
argument_list|(
operator|&
name|tree
argument_list|,
name|c
operator|->
name|repos
argument_list|,
name|root
argument_list|,
name|base_rev_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
condition|)
name|SVN_ERR
argument_list|(
name|print_dirs_changed_tree
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *KIND to PATH's kind, if PATH exists.  *  * If PATH does not exist, then error; the text of the error depends  * on whether PATH looks like a URL or not.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|verify_path
parameter_list|(
name|svn_node_kind_t
modifier|*
name|kind
parameter_list|,
name|svn_fs_root_t
modifier|*
name|root
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_check_path
argument_list|(
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|kind
operator|==
name|svn_node_none
condition|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
comment|/* check for a common mistake. */
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is a URL, probably should be a path"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' does not exist"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print the size (in bytes) of a file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_filesize
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_filesize_t
name|length
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a file"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
comment|/* Else. */
name|SVN_ERR
argument_list|(
name|svn_fs_file_length
argument_list|(
operator|&
name|length
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%"
name|SVN_FILESIZE_T_FMT
literal|"\n"
argument_list|,
name|length
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print the contents of the file at PATH in the repository.    Error with SVN_ERR_FS_NOT_FOUND if PATH does not exist, or with    SVN_ERR_FS_NOT_FILE if PATH exists but is not a file. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_cat
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_stream_t
modifier|*
name|fstream
decl_stmt|,
modifier|*
name|stdout_stream
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|!=
name|svn_node_file
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_FS_NOT_FILE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Path '%s' is not a file"
argument_list|)
argument_list|,
name|path
argument_list|)
return|;
comment|/* Else. */
name|SVN_ERR
argument_list|(
name|svn_fs_file_contents
argument_list|(
operator|&
name|fstream
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_stream_copy3
argument_list|(
name|fstream
argument_list|,
name|svn_stream_disown
argument_list|(
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Print a list of all paths modified in a format compatible with `svn    update'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_changed
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_revnum_t
name|base_rev_id
decl_stmt|;
name|svn_repos_node_t
modifier|*
name|tree
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_base_rev
argument_list|(
operator|&
name|base_rev_id
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_rev_id
operator|==
name|SVN_INVALID_REVNUM
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|generate_delta_tree
argument_list|(
operator|&
name|tree
argument_list|,
name|c
operator|->
name|repos
argument_list|,
name|root
argument_list|,
name|base_rev_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
condition|)
name|SVN_ERR
argument_list|(
name|print_changed_tree
argument_list|(
name|tree
argument_list|,
literal|""
argument_list|,
name|c
operator|->
name|copy_info
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print some diff-y stuff in a TBD way. :-) */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_diff
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|,
modifier|*
name|base_root
decl_stmt|;
name|svn_revnum_t
name|base_rev_id
decl_stmt|;
name|svn_repos_node_t
modifier|*
name|tree
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_base_rev
argument_list|(
operator|&
name|base_rev_id
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|base_rev_id
operator|==
name|SVN_INVALID_REVNUM
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|generate_delta_tree
argument_list|(
operator|&
name|tree
argument_list|,
name|c
operator|->
name|repos
argument_list|,
name|root
argument_list|,
name|base_rev_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tree
condition|)
block|{
specifier|const
name|char
modifier|*
name|tmpdir
decl_stmt|;
name|svn_stream_t
modifier|*
name|out_stream
decl_stmt|;
specifier|const
name|char
modifier|*
name|encoding
init|=
name|svn_cmdline_output_encoding
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|base_root
argument_list|,
name|c
operator|->
name|fs
argument_list|,
name|base_rev_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_io_temp_dir
argument_list|(
operator|&
name|tmpdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* This fflush() might seem odd, but it was added to deal          with this bug report:           http://subversion.tigris.org/servlets/ReadMsg?\          list=dev&msgNo=140782           From: "Steve Hay"<SteveHay{_AT_}planit.com>          To:<dev@subversion.tigris.org>          Subject: svnlook diff output in wrong order when redirected          Date: Fri, 4 Jul 2008 16:34:15 +0100          Message-ID:<1B32FF956ABF414C9BCE5E487A1497E702014F62@\                      ukmail02.planit.group>           Adding the fflush() fixed the bug (not everyone could          reproduce it, but those who could confirmed the fix).          Later in the thread, Daniel Shahaf speculated as to          why the fix works:           "Because svn_cmdline_printf() uses the standard          'FILE *stdout' to write to stdout, while          svn_stream_for_stdout() uses (through          apr_file_open_stdout()) Windows API's to get a          handle for stdout?" */
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|out_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|print_diff_tree
argument_list|(
name|out_stream
argument_list|,
name|encoding
argument_list|,
name|root
argument_list|,
name|base_root
argument_list|,
name|tree
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|c
argument_list|,
name|tmpdir
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Callback baton for print_history() (and do_history()). */
end_comment

begin_struct
struct|struct
name|print_history_baton
block|{
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_boolean_t
name|show_ids
decl_stmt|;
comment|/* whether to show node IDs */
name|apr_size_t
name|limit
decl_stmt|;
comment|/* max number of history items */
name|apr_size_t
name|count
decl_stmt|;
comment|/* number of history items processed */
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_repos_history_func_t interface.  Print the history    that's reported through this callback, possibly finding and    displaying node-rev-ids. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|print_history
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|print_history_baton
modifier|*
name|phb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|phb
operator|->
name|show_ids
condition|)
block|{
specifier|const
name|svn_fs_id_t
modifier|*
name|node_id
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|rev_root
decl_stmt|;
name|svn_string_t
modifier|*
name|id_string
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_revision_root
argument_list|(
operator|&
name|rev_root
argument_list|,
name|phb
operator|->
name|fs
argument_list|,
name|revision
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_id
argument_list|(
operator|&
name|node_id
argument_list|,
name|rev_root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|id_string
operator|=
name|svn_fs_unparse_id
argument_list|(
name|node_id
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%8ld   %s<%s>\n"
argument_list|,
name|revision
argument_list|,
name|path
argument_list|,
name|id_string
operator|->
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%8ld   %s\n"
argument_list|,
name|revision
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|phb
operator|->
name|limit
operator|>
literal|0
condition|)
block|{
name|phb
operator|->
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|phb
operator|->
name|count
operator|>=
name|phb
operator|->
name|limit
condition|)
comment|/* Not L10N'd, since this error is supressed by the caller. */
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CEASE_INVOCATION
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"History item limit reached"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print a tabular display of history location points for PATH in    revision C->rev_id.  Optionally, SHOW_IDS.  Use POOL for    allocations. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_history
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|print_history_baton
name|args
decl_stmt|;
if|if
condition|(
name|c
operator|->
name|show_ids
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"REVISION   PATH<ID>\n"
literal|"--------   ---------\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"REVISION   PATH\n"
literal|"--------   ----\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Call our history crawler.  We want the whole lifetime of the path      (prior to the user-supplied revision, of course), across all      copies. */
name|args
operator|.
name|fs
operator|=
name|c
operator|->
name|fs
expr_stmt|;
name|args
operator|.
name|show_ids
operator|=
name|c
operator|->
name|show_ids
expr_stmt|;
name|args
operator|.
name|limit
operator|=
name|c
operator|->
name|limit
expr_stmt|;
name|args
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_history2
argument_list|(
name|c
operator|->
name|fs
argument_list|,
name|path
argument_list|,
name|print_history
argument_list|,
operator|&
name|args
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|c
operator|->
name|rev_id
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print the value of property PROPNAME on PATH in the repository.     If VERBOSE, print their values too.  If SHOW_INHERITED_PROPS, print    PATH's inherited props too.     Error with SVN_ERR_FS_NOT_FOUND if PATH does not exist. If    SHOW_INHERITED_PROPS is FALSE,then error with SVN_ERR_PROPERTY_NOT_FOUND    if there is no such property on PATH.  If SHOW_INHERITED_PROPS is TRUE,    then error with SVN_ERR_PROPERTY_NOT_FOUND only if there is no such    property on PATH nor inherited by path.     If PATH is NULL, operate on a revision property. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_pget
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|propname
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|verbose
parameter_list|,
name|svn_boolean_t
name|show_inherited_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|svn_string_t
modifier|*
name|prop
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdout_stream
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
init|=
name|NULL
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_prop
argument_list|(
operator|&
name|prop
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|propname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_inherited_props
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_repos_fs_get_inherited_props
argument_list|(
operator|&
name|inherited_props
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|propname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
comment|/* --revprop */
block|{
name|SVN_ERR
argument_list|(
name|get_property
argument_list|(
operator|&
name|prop
argument_list|,
name|c
argument_list|,
name|propname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Did we find nothing? */
if|if
condition|(
name|prop
operator|==
name|NULL
operator|&&
operator|(
operator|!
name|show_inherited_props
operator|||
name|inherited_props
operator|->
name|nelts
operator|==
literal|0
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|err_msg
decl_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
condition|)
block|{
comment|/* We're operating on a revprop (e.g. c->is_revision). */
name|err_msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Property '%s' not found on revision %ld"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|c
operator|->
name|rev_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|c
operator|->
name|rev_id
argument_list|)
condition|)
block|{
if|if
condition|(
name|show_inherited_props
condition|)
name|err_msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Property '%s' not found on path '%s' "
literal|"or inherited from a parent "
literal|"in revision %ld"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|path
argument_list|,
name|c
operator|->
name|rev_id
argument_list|)
expr_stmt|;
else|else
name|err_msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Property '%s' not found on path '%s' "
literal|"in revision %ld"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|path
argument_list|,
name|c
operator|->
name|rev_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|show_inherited_props
condition|)
name|err_msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Property '%s' not found on path '%s' "
literal|"or inherited from a parent "
literal|"in transaction %s"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|path
argument_list|,
name|c
operator|->
name|txn_name
argument_list|)
expr_stmt|;
else|else
name|err_msg
operator|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Property '%s' not found on path '%s' "
literal|"in transaction %s"
argument_list|)
argument_list|,
name|propname
argument_list|,
name|path
argument_list|,
name|c
operator|->
name|txn_name
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_PROPERTY_NOT_FOUND
argument_list|,
name|NULL
argument_list|,
name|err_msg
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|||
name|show_inherited_props
condition|)
block|{
if|if
condition|(
name|inherited_props
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stdout_stream
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Inherited properties on '%s',\nfrom '%s':\n"
argument_list|)
argument_list|,
name|path
argument_list|,
name|svn_fspath__canonicalize
argument_list|(
name|elt
operator|->
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__print_prop_hash
argument_list|(
name|stdout_stream
argument_list|,
name|elt
operator|->
name|prop_hash
argument_list|,
operator|!
name|verbose
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_string_t
modifier|*
name|propval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|elt
operator|->
name|prop_hash
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stdout_stream
argument_list|,
name|pool
argument_list|,
literal|"%s - "
argument_list|,
name|svn_fspath__canonicalize
argument_list|(
name|elt
operator|->
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|propval
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stdout_stream
argument_list|,
name|propval
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we have more than one property to write, then add a newline*/
if|if
condition|(
name|inherited_props
operator|->
name|nelts
operator|>
literal|1
operator|||
name|prop
condition|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|APR_EOL_STR
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stdout_stream
argument_list|,
name|APR_EOL_STR
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|prop
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
block|{
name|apr_hash_t
modifier|*
name|hash
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|hash
argument_list|,
name|propname
argument_list|,
name|prop
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stdout_stream
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Properties on '%s':\n"
argument_list|)
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__print_prop_hash
argument_list|(
name|stdout_stream
argument_list|,
name|hash
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|stdout_stream
argument_list|,
name|pool
argument_list|,
literal|"%s - "
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|prop
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stdout_stream
argument_list|,
name|prop
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
comment|/* Raw single prop output, i.e. non-verbose output with no           inherited props. */
block|{
comment|/* Unlike the command line client, we don't translate the property          value or print a trailing newline here.  We just output the raw          bytes of whatever's in the repository, as svnlook is more likely          to be used for automated inspections. */
name|len
operator|=
name|prop
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|stdout_stream
argument_list|,
name|prop
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Print the property names of all properties on PATH in the repository.     If VERBOSE, print their values too.  If XML, print as XML rather than as    plain text.  If SHOW_INHERITED_PROPS, print PATH's inherited props too.     Error with SVN_ERR_FS_NOT_FOUND if PATH does not exist.     If PATH is NULL, operate on a revision properties. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_plist
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|verbose
parameter_list|,
name|svn_boolean_t
name|xml
parameter_list|,
name|svn_boolean_t
name|show_inherited_props
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|sb
init|=
name|NULL
decl_stmt|;
name|svn_boolean_t
name|revprop
init|=
name|FALSE
decl_stmt|;
name|apr_array_header_t
modifier|*
name|inherited_props
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|path
operator|!=
name|NULL
condition|)
block|{
comment|/* PATH might be the root of the repsository and we accept both          "" and "/".  But to avoid the somewhat cryptic output like this:>svnlook pl repos-path ""            Properties on '':              svn:auto-props              svn:global-ignores           We canonicalize PATH so that is has a leading slash. */
name|path
operator|=
name|svn_fspath__canonicalize
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|verify_path
argument_list|(
operator|&
name|kind
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|show_inherited_props
condition|)
name|SVN_ERR
argument_list|(
name|svn_repos_fs_get_inherited_props
argument_list|(
operator|&
name|inherited_props
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|is_revision
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_revision_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|c
operator|->
name|fs
argument_list|,
name|c
operator|->
name|rev_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|revprop
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_fs_txn_proplist
argument_list|(
operator|&
name|props
argument_list|,
name|c
operator|->
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|revprop
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|xml
condition|)
block|{
comment|/*<?xml version="1.0" encoding="UTF-8"?> */
name|svn_xml_make_header2
argument_list|(
operator|&
name|sb
argument_list|,
literal|"UTF-8"
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* "<properties>" */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"properties"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|inherited_props
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|inherited_props
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_prop_inherited_item_t
modifier|*
name|elt
init|=
name|APR_ARRAY_IDX
argument_list|(
name|inherited_props
argument_list|,
name|i
argument_list|,
name|svn_prop_inherited_item_t
operator|*
argument_list|)
decl_stmt|;
comment|/* Canonicalize the inherited parent paths for consistency              with PATH. */
if|if
condition|(
name|xml
condition|)
block|{
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"target"
argument_list|,
literal|"path"
argument_list|,
name|svn_fspath__canonicalize
argument_list|(
name|elt
operator|->
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__print_xml_prop_hash
argument_list|(
operator|&
name|sb
argument_list|,
name|elt
operator|->
name|prop_hash
argument_list|,
operator|!
name|verbose
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Inherited properties on '%s',\nfrom '%s':\n"
argument_list|)
argument_list|,
name|path
argument_list|,
name|svn_fspath__canonicalize
argument_list|(
name|elt
operator|->
name|path_or_url
argument_list|,
name|pool
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline__print_prop_hash
argument_list|(
name|NULL
argument_list|,
name|elt
operator|->
name|prop_hash
argument_list|,
operator|!
name|verbose
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|xml
condition|)
block|{
if|if
condition|(
name|revprop
condition|)
block|{
comment|/* "<revprops ...>" */
if|if
condition|(
name|c
operator|->
name|is_revision
condition|)
block|{
name|char
modifier|*
name|revstr
init|=
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%ld"
argument_list|,
name|c
operator|->
name|rev_id
argument_list|)
decl_stmt|;
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"revprops"
argument_list|,
literal|"rev"
argument_list|,
name|revstr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"revprops"
argument_list|,
literal|"txn"
argument_list|,
name|c
operator|->
name|txn_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* "<target ...>" */
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_normal
argument_list|,
literal|"target"
argument_list|,
literal|"path"
argument_list|,
name|path
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|xml
operator|&&
name|path
comment|/* Not a --revprop */
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Properties on '%s':\n"
argument_list|)
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|pname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_string_t
modifier|*
name|propval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since we're already adding a trailing newline (and possible a          colon and some spaces) anyway, just mimic the output of the          command line client proplist.   Compare to 'svnlook propget',          which sends the raw bytes to stdout, untranslated. */
comment|/* We leave printf calls here, since we don't always know the encoding          of the prop value. */
if|if
condition|(
name|svn_prop_needs_translation
argument_list|(
name|pname
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|svn_subst_detranslate_string
argument_list|(
operator|&
name|propval
argument_list|,
name|propval
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
if|if
condition|(
name|xml
condition|)
name|svn_cmdline__print_xml_prop
argument_list|(
operator|&
name|sb
argument_list|,
name|pname
argument_list|,
name|propval
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
block|{
specifier|const
name|char
modifier|*
name|pname_stdout
decl_stmt|;
specifier|const
name|char
modifier|*
name|indented_newval
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_cstring_from_utf8
argument_list|(
operator|&
name|pname_stdout
argument_list|,
name|pname
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|pname_stdout
argument_list|)
expr_stmt|;
comment|/* Add an extra newline to the value before indenting, so that                  every line of output has the indentation whether the value                  already ended in a newline or not. */
name|indented_newval
operator|=
name|svn_cmdline__indent_string
argument_list|(
name|apr_psprintf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|propval
operator|->
name|data
argument_list|)
argument_list|,
literal|"    "
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|indented_newval
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|xml
condition|)
name|svn_xml_make_open_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
name|svn_xml_self_closing
argument_list|,
literal|"property"
argument_list|,
literal|"name"
argument_list|,
name|pname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"  %s\n"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xml
condition|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|revprop
condition|)
block|{
comment|/* "</revprops>" */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"revprops"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* "</target>" */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"target"
argument_list|)
expr_stmt|;
block|}
comment|/* "</properties>" */
name|svn_xml_make_close_tag
argument_list|(
operator|&
name|sb
argument_list|,
name|pool
argument_list|,
literal|"properties"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|sb
operator|->
name|data
argument_list|,
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|errno
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|errno
argument_list|,
name|_
argument_list|(
literal|"Write error"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_IO_WRITE_ERROR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_tree
parameter_list|(
name|svnlook_ctxt_t
modifier|*
name|c
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_boolean_t
name|show_ids
parameter_list|,
name|svn_boolean_t
name|full_paths
parameter_list|,
name|svn_boolean_t
name|recurse
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
specifier|const
name|svn_fs_id_t
modifier|*
name|id
decl_stmt|;
name|svn_boolean_t
name|is_dir
decl_stmt|;
name|SVN_ERR
argument_list|(
name|get_root
argument_list|(
operator|&
name|root
argument_list|,
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_node_id
argument_list|(
operator|&
name|id
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_is_dir
argument_list|(
operator|&
name|is_dir
argument_list|,
name|root
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|print_tree
argument_list|(
name|root
argument_list|,
name|path
argument_list|,
name|id
argument_list|,
name|is_dir
argument_list|,
literal|0
argument_list|,
name|show_ids
argument_list|,
name|full_paths
argument_list|,
name|recurse
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Custom filesystem warning function. */
end_comment

begin_function
specifier|static
name|void
name|warning_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|err
condition|)
return|return;
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnlook: "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return an error if the number of arguments (excluding the repository  * argument) is not NUM_ARGS.  NUM_ARGS must be 0 or 1.  The arguments  * are assumed to be found in OPT_STATE->arg1 and OPT_STATE->arg2. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_number_of_args
parameter_list|(
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
parameter_list|,
name|int
name|num_args
parameter_list|)
block|{
if|if
condition|(
operator|(
name|num_args
operator|==
literal|0
operator|&&
name|opt_state
operator|->
name|arg1
operator|!=
name|NULL
operator|)
operator|||
operator|(
name|num_args
operator|==
literal|1
operator|&&
name|opt_state
operator|->
name|arg2
operator|!=
name|NULL
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Too many arguments given"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|(
name|num_args
operator|==
literal|1
operator|&&
name|opt_state
operator|->
name|arg1
operator|==
name|NULL
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing repository path argument"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Factory function for the context baton. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_ctxt_baton
parameter_list|(
name|svnlook_ctxt_t
modifier|*
modifier|*
name|baton_p
parameter_list|,
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svnlook_ctxt_t
modifier|*
name|baton
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_open2
argument_list|(
operator|&
operator|(
name|baton
operator|->
name|repos
operator|)
argument_list|,
name|opt_state
operator|->
name|repos_path
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|baton
operator|->
name|repos
argument_list|)
expr_stmt|;
name|svn_fs_set_warning_func
argument_list|(
name|baton
operator|->
name|fs
argument_list|,
name|warning_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|baton
operator|->
name|show_ids
operator|=
name|opt_state
operator|->
name|show_ids
expr_stmt|;
name|baton
operator|->
name|limit
operator|=
name|opt_state
operator|->
name|limit
expr_stmt|;
name|baton
operator|->
name|no_diff_deleted
operator|=
name|opt_state
operator|->
name|no_diff_deleted
expr_stmt|;
name|baton
operator|->
name|no_diff_added
operator|=
name|opt_state
operator|->
name|no_diff_added
expr_stmt|;
name|baton
operator|->
name|diff_copy_from
operator|=
name|opt_state
operator|->
name|diff_copy_from
expr_stmt|;
name|baton
operator|->
name|full_paths
operator|=
name|opt_state
operator|->
name|full_paths
expr_stmt|;
name|baton
operator|->
name|copy_info
operator|=
name|opt_state
operator|->
name|copy_info
expr_stmt|;
name|baton
operator|->
name|is_revision
operator|=
name|opt_state
operator|->
name|txn
operator|==
name|NULL
expr_stmt|;
name|baton
operator|->
name|rev_id
operator|=
name|opt_state
operator|->
name|rev
expr_stmt|;
name|baton
operator|->
name|txn_name
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|opt_state
operator|->
name|txn
argument_list|)
expr_stmt|;
name|baton
operator|->
name|diff_options
operator|=
name|svn_cstring_split
argument_list|(
name|opt_state
operator|->
name|extensions
condition|?
name|opt_state
operator|->
name|extensions
else|:
literal|""
argument_list|,
literal|" \t\n\r"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|ignore_properties
operator|=
name|opt_state
operator|->
name|ignore_properties
expr_stmt|;
name|baton
operator|->
name|properties_only
operator|=
name|opt_state
operator|->
name|properties_only
expr_stmt|;
name|baton
operator|->
name|diff_cmd
operator|=
name|opt_state
operator|->
name|diff_cmd
expr_stmt|;
if|if
condition|(
name|baton
operator|->
name|txn_name
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_open_txn
argument_list|(
operator|&
operator|(
name|baton
operator|->
name|txn
operator|)
argument_list|,
name|baton
operator|->
name|fs
argument_list|,
name|baton
operator|->
name|txn_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|baton
operator|->
name|rev_id
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
operator|(
name|baton
operator|->
name|rev_id
operator|)
argument_list|,
name|baton
operator|->
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|baton_p
operator|=
name|baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Subcommands. ***/
end_comment

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_author
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_author
argument_list|(
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_cat
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_cat
argument_list|(
name|c
argument_list|,
name|opt_state
operator|->
name|arg1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_changed
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_changed
argument_list|(
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_date
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_date
argument_list|(
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_diff
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_diff
argument_list|(
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_dirschanged
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_dirs_changed
argument_list|(
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_filesize
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_filesize
argument_list|(
name|c
argument_list|,
name|opt_state
operator|->
name|arg1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_help
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
init|=
name|_
argument_list|(
literal|"general usage: svnlook SUBCOMMAND REPOS_PATH [ARGS& OPTIONS ...]\n"
literal|"Note: any subcommand which takes the '--revision' and '--transaction'\n"
literal|"      options will, if invoked without one of those options, act on\n"
literal|"      the repository's youngest revision.\n"
literal|"Type 'svnlook help<subcommand>' for help on a specific subcommand.\n"
literal|"Type 'svnlook --version' to see the program version and FS modules.\n"
literal|"\n"
literal|"Available subcommands:\n"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_desc_start
init|=
name|_
argument_list|(
literal|"The following repository back-end (FS) modules are available:\n\n"
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|version_footer
decl_stmt|;
name|version_footer
operator|=
name|svn_stringbuf_create
argument_list|(
name|fs_desc_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_print_help4
argument_list|(
name|os
argument_list|,
literal|"svnlook"
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|version
else|:
name|FALSE
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|quiet
else|:
name|FALSE
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|verbose
else|:
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|header
argument_list|,
name|cmd_table
argument_list|,
name|options_table
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_history
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
operator|(
name|opt_state
operator|->
name|arg1
condition|?
name|opt_state
operator|->
name|arg1
else|:
literal|"/"
operator|)
decl_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|arg2
operator|!=
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Too many arguments given"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_history
argument_list|(
name|c
argument_list|,
name|path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_lock
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|c
operator|->
name|fs
argument_list|,
name|opt_state
operator|->
name|arg1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
condition|)
block|{
specifier|const
name|char
modifier|*
name|cr_date
decl_stmt|,
modifier|*
name|exp_date
init|=
literal|""
decl_stmt|;
name|int
name|comment_lines
init|=
literal|0
decl_stmt|;
name|cr_date
operator|=
name|svn_time_to_human_cstring
argument_list|(
name|lock
operator|->
name|creation_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|expiration_date
condition|)
name|exp_date
operator|=
name|svn_time_to_human_cstring
argument_list|(
name|lock
operator|->
name|expiration_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|comment
condition|)
name|comment_lines
operator|=
name|svn_cstring_count_newlines
argument_list|(
name|lock
operator|->
name|comment
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"UUID Token: %s\n"
argument_list|)
argument_list|,
name|lock
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Owner: %s\n"
argument_list|)
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Created: %s\n"
argument_list|)
argument_list|,
name|cr_date
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Expires: %s\n"
argument_list|)
argument_list|,
name|exp_date
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|Q_
argument_list|(
literal|"Comment (%i line):\n%s\n"
argument_list|,
literal|"Comment (%i lines):\n%s\n"
argument_list|,
name|comment_lines
argument_list|)
argument_list|,
name|comment_lines
argument_list|,
name|lock
operator|->
name|comment
condition|?
name|lock
operator|->
name|comment
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_info
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_author
argument_list|(
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_date
argument_list|(
name|c
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_log
argument_list|(
name|c
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_log
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_log
argument_list|(
name|c
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_pget
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|arg1
operator|==
name|NULL
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
name|NULL
argument_list|,
name|opt_state
operator|->
name|revprop
condition|?
name|_
argument_list|(
literal|"Missing propname argument"
argument_list|)
else|:
name|_
argument_list|(
literal|"Missing propname and repository path arguments"
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|opt_state
operator|->
name|revprop
operator|&&
name|opt_state
operator|->
name|arg2
operator|==
name|NULL
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing propname or repository path argument"
argument_list|)
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|opt_state
operator|->
name|revprop
operator|&&
name|opt_state
operator|->
name|arg2
operator|!=
name|NULL
operator|)
operator|||
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Too many arguments given"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_pget
argument_list|(
name|c
argument_list|,
name|opt_state
operator|->
name|arg1
argument_list|,
name|opt_state
operator|->
name|revprop
condition|?
name|NULL
else|:
name|opt_state
operator|->
name|arg2
argument_list|,
name|opt_state
operator|->
name|verbose
argument_list|,
name|opt_state
operator|->
name|show_inherited_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_plist
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
name|opt_state
operator|->
name|revprop
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_plist
argument_list|(
name|c
argument_list|,
name|opt_state
operator|->
name|revprop
condition|?
name|NULL
else|:
name|opt_state
operator|->
name|arg1
argument_list|,
name|opt_state
operator|->
name|verbose
argument_list|,
name|opt_state
operator|->
name|xml
argument_list|,
name|opt_state
operator|->
name|show_inherited_props
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_tree
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|arg2
operator|!=
name|NULL
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Too many arguments given"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|do_tree
argument_list|(
name|c
argument_list|,
name|opt_state
operator|->
name|arg1
condition|?
name|opt_state
operator|->
name|arg1
else|:
literal|""
argument_list|,
name|opt_state
operator|->
name|show_ids
argument_list|,
name|opt_state
operator|->
name|full_paths
argument_list|,
operator|!
name|opt_state
operator|->
name|non_recursive
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_youngest
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%ld\n"
argument_list|,
name|c
operator|->
name|rev_id
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_uuid
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnlook_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svnlook_ctxt_t
modifier|*
name|c
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
decl_stmt|;
name|SVN_ERR
argument_list|(
name|check_number_of_args
argument_list|(
name|opt_state
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_ctxt_baton
argument_list|(
operator|&
name|c
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_get_uuid
argument_list|(
name|c
operator|->
name|fs
argument_list|,
operator|&
name|uuid
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Main. ***/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|subcommand
init|=
name|NULL
decl_stmt|;
name|struct
name|svnlook_opt_state
name|opt_state
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|int
name|opt_id
decl_stmt|;
name|apr_array_header_t
modifier|*
name|received_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnlook"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|received_opts
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|SVN_OPT_MAX_OPTIONS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check library versions */
name|err
operator|=
name|check_lib_versions
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnlook: "
argument_list|)
return|;
comment|/* Initialize the FS library. */
name|err
operator|=
name|svn_fs_initialize
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnlook: "
argument_list|)
return|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Initialize opt_state. */
name|memset
argument_list|(
operator|&
name|opt_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt_state
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|.
name|rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
comment|/* Parse options. */
name|err
operator|=
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnlook: "
argument_list|)
return|;
name|os
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
comment|/* Parse the next option. */
name|apr_err
operator|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|options_table
argument_list|,
operator|&
name|opt_id
argument_list|,
operator|&
name|opt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|apr_err
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Stash the option code in an array before parsing it. */
name|APR_ARRAY_PUSH
argument_list|(
name|received_opts
argument_list|,
name|int
argument_list|)
operator|=
name|opt_id
expr_stmt|;
switch|switch
condition|(
name|opt_id
condition|)
block|{
case|case
literal|'r'
case|:
block|{
name|char
modifier|*
name|digits_end
init|=
name|NULL
decl_stmt|;
name|opt_state
operator|.
name|rev
operator|=
name|strtol
argument_list|(
name|opt_arg
argument_list|,
operator|&
name|digits_end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|opt_state
operator|.
name|rev
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|digits_end
operator|)
operator|||
operator|*
name|digits_end
condition|)
name|SVN_INT_ERR
argument_list|(
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number supplied"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
name|opt_state
operator|.
name|txn
operator|=
name|opt_arg
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|opt_state
operator|.
name|non_recursive
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|opt_state
operator|.
name|verbose
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|opt_state
operator|.
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|opt_state
operator|.
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__revprop_opt
case|:
name|opt_state
operator|.
name|revprop
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__xml_opt
case|:
name|opt_state
operator|.
name|xml
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__version
case|:
name|opt_state
operator|.
name|version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__show_ids
case|:
name|opt_state
operator|.
name|show_ids
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
block|{
name|char
modifier|*
name|end
decl_stmt|;
name|opt_state
operator|.
name|limit
operator|=
name|strtol
argument_list|(
name|opt_arg
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|opt_arg
operator|||
operator|*
name|end
operator|!=
literal|'\0'
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Non-numeric limit argument given"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnlook: "
argument_list|)
return|;
block|}
if|if
condition|(
name|opt_state
operator|.
name|limit
operator|<=
literal|0
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_INCORRECT_PARAMS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Argument to --limit must be positive"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnlook: "
argument_list|)
return|;
block|}
block|}
break|break;
case|case
name|svnlook__no_diff_deleted
case|:
name|opt_state
operator|.
name|no_diff_deleted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__no_diff_added
case|:
name|opt_state
operator|.
name|no_diff_added
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__diff_copy_from
case|:
name|opt_state
operator|.
name|diff_copy_from
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__full_paths
case|:
name|opt_state
operator|.
name|full_paths
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__copy_info
case|:
name|opt_state
operator|.
name|copy_info
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|opt_state
operator|.
name|extensions
operator|=
name|opt_arg
expr_stmt|;
break|break;
case|case
name|svnlook__ignore_properties
case|:
name|opt_state
operator|.
name|ignore_properties
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__properties_only
case|:
name|opt_state
operator|.
name|properties_only
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnlook__diff_cmd
case|:
name|opt_state
operator|.
name|diff_cmd
operator|=
name|opt_arg
expr_stmt|;
break|break;
case|case
name|svnlook__show_inherited_props
case|:
name|opt_state
operator|.
name|show_inherited_props
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
comment|/* The --transaction and --revision options may not co-exist. */
if|if
condition|(
operator|(
name|opt_state
operator|.
name|rev
operator|!=
name|SVN_INVALID_REVNUM
operator|)
operator|&&
name|opt_state
operator|.
name|txn
condition|)
name|SVN_INT_ERR
argument_list|(
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"The '--transaction' (-t) and '--revision' (-r) arguments "
literal|"cannot co-exist"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The --show-inherited-props and --revprop options may not co-exist. */
if|if
condition|(
name|opt_state
operator|.
name|show_inherited_props
operator|&&
name|opt_state
operator|.
name|revprop
condition|)
name|SVN_INT_ERR
argument_list|(
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot use the '--show-inherited-props' option with the "
literal|"'--revprop' option"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the user asked for help, then the rest of the arguments are      the names of subcommands to get help on (if any), or else they're      just typos/mistakes.  Whatever the case, the subcommand to      actually run is subcommand_help(). */
if|if
condition|(
name|opt_state
operator|.
name|help
condition|)
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
comment|/* If we're not running the `help' subcommand, then look for a      subcommand in the first argument. */
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|version
condition|)
block|{
comment|/* Use the "help" subcommand to handle the "--version" option. */
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|pseudo_cmd
init|=
block|{
literal|"--version"
block|,
name|subcommand_help
block|,
block|{
literal|0
block|}
block|,
literal|""
block|,
block|{
name|svnlook__version
block|,
comment|/* must accept its own option */
literal|'q'
block|,
literal|'v'
block|,                   }
block|}
decl_stmt|;
name|subcommand
operator|=
operator|&
name|pseudo_cmd
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand argument required\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|first_arg
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
decl_stmt|;
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|first_arg_utf8
decl_stmt|;
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|first_arg_utf8
argument_list|,
name|first_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnlook: "
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unknown subcommand: '%s'\n"
argument_list|)
argument_list|,
name|first_arg_utf8
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Be kind to people who try 'svnlook verify'. */
if|if
condition|(
name|strcmp
argument_list|(
name|first_arg_utf8
argument_list|,
literal|"verify"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Try 'svnadmin verify' instead.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
block|}
comment|/* If there's a second argument, it's the repository.  There may be      more arguments following the repository; usually the next one is      a path within the repository, or it's a propname and the one      after that is the path.  Since we don't know, we just call them      arg1 and arg2, meaning the first and second arguments following      the repository. */
if|if
condition|(
name|subcommand
operator|->
name|cmd_func
operator|!=
name|subcommand_help
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_path
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|arg1
init|=
name|NULL
decl_stmt|,
modifier|*
name|arg2
init|=
name|NULL
decl_stmt|;
comment|/* Get the repository. */
if|if
condition|(
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|repos_path
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|repos_path
operator|=
name|svn_dirent_internal_style
argument_list|(
name|repos_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|repos_path
operator|==
name|NULL
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Repository argument required\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
elseif|else
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|repos_path
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"'%s' is a URL when it should be a path\n"
argument_list|)
argument_list|,
name|repos_path
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
name|opt_state
operator|.
name|repos_path
operator|=
name|repos_path
expr_stmt|;
comment|/* Get next arg (arg1), if any. */
if|if
condition|(
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|arg1
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|arg1
operator|=
name|svn_dirent_internal_style
argument_list|(
name|arg1
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|opt_state
operator|.
name|arg1
operator|=
name|arg1
expr_stmt|;
comment|/* Get next arg (arg2), if any. */
if|if
condition|(
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|arg2
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|arg2
operator|=
name|svn_dirent_internal_style
argument_list|(
name|arg2
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|opt_state
operator|.
name|arg2
operator|=
name|arg2
expr_stmt|;
block|}
comment|/* Check that the subcommand wasn't passed any inappropriate options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|received_opts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|opt_id
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|received_opts
argument_list|,
name|i
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* All commands implicitly accept --help, so just skip over this          when we see it. Note that we don't want to include this option          in their "accepted options" list because it would be awfully          redundant to display it in every commands' help text. */
if|if
condition|(
name|opt_id
operator|==
literal|'h'
operator|||
name|opt_id
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|svn_opt_subcommand_takes_option3
argument_list|(
name|subcommand
argument_list|,
name|opt_id
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|badopt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|opt_id
argument_list|,
name|options_table
argument_list|,
name|subcommand
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|badopt
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand '%s' doesn't accept option '%s'\n"
literal|"Type 'svnlook help %s' for usage.\n"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|,
name|optstr
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
comment|/* Set up our cancellation support. */
name|apr_signal
argument_list|(
name|SIGINT
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBREAK
comment|/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */
name|apr_signal
argument_list|(
name|SIGBREAK
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|apr_signal
argument_list|(
name|SIGHUP
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|apr_signal
argument_list|(
name|SIGTERM
argument_list|,
name|signal_handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it, otherwise    * working with large files when compiled against an APR that doesn't have    * large file support will crash the program, which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Run the subcommand. */
name|err
operator|=
call|(
modifier|*
name|subcommand
operator|->
name|cmd_func
call|)
argument_list|(
name|os
argument_list|,
operator|&
name|opt_state
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* For argument-related problems, suggest using the 'help'          subcommand. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_INSUFFICIENT_ARGS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_ARG_PARSING_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Try 'svnlook help' for more info"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svnlook: "
argument_list|)
return|;
block|}
else|else
block|{
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Ensure everything is printed on stdout, so the user sees any          print errors. */
name|SVN_INT_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
block|}
end_function

end_unit

