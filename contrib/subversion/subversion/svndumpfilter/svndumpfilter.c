begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svndumpfilter.c: Subversion dump stream filtering tool main file.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_string.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_fs.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_mergeinfo.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_mergeinfo_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_WIN32
end_ifdef

begin_typedef
typedef|typedef
name|apr_status_t
function_decl|(
name|__stdcall
modifier|*
name|open_fn_t
function_decl|)
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_typedef
typedef|typedef
name|apr_status_t
function_decl|(
modifier|*
name|open_fn_t
function_decl|)
parameter_list|(
name|apr_file_t
modifier|*
modifier|*
parameter_list|,
name|apr_pool_t
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* Helper to open stdio streams */
end_comment

begin_comment
comment|/* NOTE: we used to call svn_stream_from_stdio(), which wraps a stream    around a standard stdio.h FILE pointer.  The problem is that these    pointers operate through C Run Time (CRT) on Win32, which does all    sorts of translation on them: LF's become CRLF's, and ctrl-Z's    embedded in Word documents are interpreted as premature EOF's.     So instead, we use apr_file_open_std*, which bypass the CRT and    directly wrap the OS's file-handles, which don't know or care about    translation.  Thus dump/load works correctly on Win32. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|create_stdio_stream
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|open_fn_t
name|open_fn
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_file_t
modifier|*
name|stdio_file
decl_stmt|;
name|apr_status_t
name|apr_err
init|=
name|open_fn
argument_list|(
operator|&
name|stdio_file
argument_list|,
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
name|_
argument_list|(
literal|"Can't open stdio file"
argument_list|)
argument_list|)
return|;
operator|*
name|stream
operator|=
name|svn_stream_from_aprfile2
argument_list|(
name|stdio_file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Writes a property in dumpfile format to given stringbuf. */
end_comment

begin_function
specifier|static
name|void
name|write_prop_to_stringbuf
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|strbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|int
name|bytes_used
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|char
name|buf
index|[
name|SVN_KEYLINE_MAXLEN
index|]
decl_stmt|;
comment|/* Output name length, then name. */
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|strbuf
argument_list|,
literal|"K "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|strbuf
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|strbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|strbuf
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|strbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* Output value length, then value. */
name|svn_stringbuf_appendbytes
argument_list|(
name|strbuf
argument_list|,
literal|"V "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|value
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|strbuf
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|strbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|strbuf
argument_list|,
name|value
operator|->
name|data
argument_list|,
name|value
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|strbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Writes a property deletion in dumpfile format to given stringbuf. */
end_comment

begin_function
specifier|static
name|void
name|write_propdel_to_stringbuf
parameter_list|(
name|svn_stringbuf_t
modifier|*
modifier|*
name|strbuf
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|bytes_used
decl_stmt|;
name|size_t
name|namelen
decl_stmt|;
name|char
name|buf
index|[
name|SVN_KEYLINE_MAXLEN
index|]
decl_stmt|;
comment|/* Output name length, then name. */
name|namelen
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
operator|*
name|strbuf
argument_list|,
literal|"D "
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|"%"
name|APR_SIZE_T_FMT
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
operator|*
name|strbuf
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
operator|*
name|strbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
operator|*
name|strbuf
argument_list|,
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
operator|*
name|strbuf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compare the node-path PATH with the (const char *) prefixes in PFXLIST.  * Return TRUE if any prefix is a prefix of PATH (matching whole path  * components); FALSE otherwise.  * PATH starts with a '/', as do the (const char *) paths in PREFIXES. */
end_comment

begin_function
specifier|static
name|svn_boolean_t
name|ary_prefix_match
parameter_list|(
specifier|const
name|apr_array_header_t
modifier|*
name|pfxlist
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|size_t
name|path_len
init|=
name|strlen
argument_list|(
name|path
argument_list|)
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pfxlist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|pfx
init|=
name|APR_ARRAY_IDX
argument_list|(
name|pfxlist
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|size_t
name|pfx_len
init|=
name|strlen
argument_list|(
name|pfx
argument_list|)
decl_stmt|;
if|if
condition|(
name|path_len
operator|<
name|pfx_len
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|path
argument_list|,
name|pfx
argument_list|,
name|pfx_len
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|pfx_len
operator|==
literal|1
operator|||
name|path
index|[
name|pfx_len
index|]
operator|==
literal|'\0'
operator|||
name|path
index|[
name|pfx_len
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_function

begin_comment
comment|/* Check whether we need to skip this PATH based on its presence in    the PREFIXES list, and the DO_EXCLUDE option.    PATH starts with a '/', as do the (const char *) paths in PREFIXES. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_boolean_t
name|skip_path
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|prefixes
parameter_list|,
name|svn_boolean_t
name|do_exclude
parameter_list|,
name|svn_boolean_t
name|glob
parameter_list|)
block|{
specifier|const
name|svn_boolean_t
name|matches
init|=
operator|(
name|glob
condition|?
name|svn_cstring_match_glob_list
argument_list|(
name|path
argument_list|,
name|prefixes
argument_list|)
else|:
name|ary_prefix_match
argument_list|(
name|prefixes
argument_list|,
name|path
argument_list|)
operator|)
decl_stmt|;
comment|/* NXOR */
return|return
operator|(
name|matches
condition|?
name|do_exclude
else|:
operator|!
name|do_exclude
operator|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Note: the input stream parser calls us with events.    Output of the filtered dump occurs for the most part streamily with the    event callbacks, to avoid caching large quantities of data in memory.    The exceptions this are:    - All revision data (headers and props) must be cached until a non-skipped      node within the revision is found, or the revision is closed.    - Node headers and props must be cached until all props have been received      (to allow the Prop-content-length to be found). This is signalled either      by the node text arriving, or the node being closed.    The writing_begun members of the associated object batons track the state.    output_revision() and output_node() are called to cause this flushing of    cached data to occur. */
end_comment

begin_comment
comment|/* Filtering batons */
end_comment

begin_struct
struct|struct
name|revmap_t
block|{
name|svn_revnum_t
name|rev
decl_stmt|;
comment|/* Last non-dropped revision to which this maps. */
name|svn_boolean_t
name|was_dropped
decl_stmt|;
comment|/* Was this revision dropped? */
block|}
struct|;
end_struct

begin_struct
struct|struct
name|parse_baton_t
block|{
comment|/* Command-line options values. */
name|svn_boolean_t
name|do_exclude
decl_stmt|;
name|svn_boolean_t
name|quiet
decl_stmt|;
name|svn_boolean_t
name|glob
decl_stmt|;
name|svn_boolean_t
name|drop_empty_revs
decl_stmt|;
name|svn_boolean_t
name|drop_all_empty_revs
decl_stmt|;
name|svn_boolean_t
name|do_renumber_revs
decl_stmt|;
name|svn_boolean_t
name|preserve_revprops
decl_stmt|;
name|svn_boolean_t
name|skip_missing_merge_sources
decl_stmt|;
name|svn_boolean_t
name|allow_deltas
decl_stmt|;
name|apr_array_header_t
modifier|*
name|prefixes
decl_stmt|;
comment|/* Input and output streams. */
name|svn_stream_t
modifier|*
name|in_stream
decl_stmt|;
name|svn_stream_t
modifier|*
name|out_stream
decl_stmt|;
comment|/* State for the filtering process. */
name|apr_int32_t
name|rev_drop_count
decl_stmt|;
name|apr_hash_t
modifier|*
name|dropped_nodes
decl_stmt|;
name|apr_hash_t
modifier|*
name|renumber_history
decl_stmt|;
comment|/* svn_revnum_t -> struct revmap_t */
name|svn_revnum_t
name|last_live_revision
decl_stmt|;
comment|/* The oldest original revision, greater than r0, in the input      stream which was not filtered. */
name|svn_revnum_t
name|oldest_original_rev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|revision_baton_t
block|{
comment|/* Reference to the global parse baton. */
name|struct
name|parse_baton_t
modifier|*
name|pb
decl_stmt|;
comment|/* Does this revision have node or prop changes? */
name|svn_boolean_t
name|has_nodes
decl_stmt|;
name|svn_boolean_t
name|has_props
decl_stmt|;
comment|/* Did we drop any nodes? */
name|svn_boolean_t
name|had_dropped_nodes
decl_stmt|;
comment|/* Written to output stream? */
name|svn_boolean_t
name|writing_begun
decl_stmt|;
comment|/* The original and new (re-mapped) revision numbers. */
name|svn_revnum_t
name|rev_orig
decl_stmt|;
name|svn_revnum_t
name|rev_actual
decl_stmt|;
comment|/* Pointers to dumpfile data. */
name|svn_stringbuf_t
modifier|*
name|header
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|node_baton_t
block|{
comment|/* Reference to the current revision baton. */
name|struct
name|revision_baton_t
modifier|*
name|rb
decl_stmt|;
comment|/* Are we skipping this node? */
name|svn_boolean_t
name|do_skip
decl_stmt|;
comment|/* Have we been instructed to change or remove props on, or change      the text of, this node? */
name|svn_boolean_t
name|has_props
decl_stmt|;
name|svn_boolean_t
name|has_text
decl_stmt|;
comment|/* Written to output stream? */
name|svn_boolean_t
name|writing_begun
decl_stmt|;
comment|/* The text content length according to the dumpfile headers, because we      need the length before we have the actual text. */
name|svn_filesize_t
name|tcl
decl_stmt|;
comment|/* Pointers to dumpfile data. */
name|svn_stringbuf_t
modifier|*
name|header
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|props
decl_stmt|;
comment|/* Expect deltas? */
name|svn_boolean_t
name|has_prop_delta
decl_stmt|;
name|svn_boolean_t
name|has_text_delta
decl_stmt|;
comment|/* We might need the node path in a parse error message. */
name|char
modifier|*
name|node_path
decl_stmt|;
block|}
struct|;
end_struct

begin_escape
end_escape

begin_comment
comment|/* Filtering vtable members */
end_comment

begin_comment
comment|/* File-format stamp. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|magic_header_record
parameter_list|(
name|int
name|version
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton_t
modifier|*
name|pb
init|=
name|parse_baton
decl_stmt|;
if|if
condition|(
name|version
operator|>=
name|SVN_REPOS_DUMPFILE_FORMAT_VERSION_DELTAS
condition|)
name|pb
operator|->
name|allow_deltas
operator|=
name|TRUE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|pb
operator|->
name|out_stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_MAGIC_HEADER
literal|": %d\n\n"
argument_list|,
name|version
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* New revision: set up revision_baton, decide if we skip it. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_revision_record
parameter_list|(
name|void
modifier|*
modifier|*
name|revision_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|revision_baton_t
modifier|*
name|rb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|rev_orig
decl_stmt|;
name|svn_stream_t
modifier|*
name|header_stream
decl_stmt|;
operator|*
name|revision_baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|revision_baton_t
argument_list|)
argument_list|)
expr_stmt|;
name|rb
operator|=
operator|*
name|revision_baton
expr_stmt|;
name|rb
operator|->
name|pb
operator|=
name|parse_baton
expr_stmt|;
name|rb
operator|->
name|has_nodes
operator|=
name|FALSE
expr_stmt|;
name|rb
operator|->
name|has_props
operator|=
name|FALSE
expr_stmt|;
name|rb
operator|->
name|had_dropped_nodes
operator|=
name|FALSE
expr_stmt|;
name|rb
operator|->
name|writing_begun
operator|=
name|FALSE
expr_stmt|;
name|rb
operator|->
name|header
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|rb
operator|->
name|props
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|header_stream
operator|=
name|svn_stream_from_stringbuf
argument_list|(
name|rb
operator|->
name|header
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|rev_orig
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
argument_list|)
expr_stmt|;
name|rb
operator|->
name|rev_orig
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|rev_orig
argument_list|)
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|do_renumber_revs
condition|)
name|rb
operator|->
name|rev_actual
operator|=
name|rb
operator|->
name|rev_orig
operator|-
name|rb
operator|->
name|pb
operator|->
name|rev_drop_count
expr_stmt|;
else|else
name|rb
operator|->
name|rev_actual
operator|=
name|rb
operator|->
name|rev_orig
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|header_stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
literal|": %ld\n"
argument_list|,
name|rb
operator|->
name|rev_actual
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|headers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_REVISION_NUMBER
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* passthru: put header into header stringbuf. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|header_stream
argument_list|,
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|header_stream
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Output revision to dumpstream    This may be called by new_node_record(), iff rb->has_nodes has been set    to TRUE, or by close_revision() otherwise. This must only be called    if rb->writing_begun is FALSE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_revision
parameter_list|(
name|struct
name|revision_baton_t
modifier|*
name|rb
parameter_list|)
block|{
name|int
name|bytes_used
decl_stmt|;
name|char
name|buf
index|[
name|SVN_KEYLINE_MAXLEN
index|]
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|svn_boolean_t
name|write_out_rev
init|=
name|FALSE
decl_stmt|;
name|apr_pool_t
modifier|*
name|hash_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|rb
operator|->
name|props
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|props
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|hash_pool
argument_list|)
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|hash_pool
argument_list|)
decl_stmt|;
name|rb
operator|->
name|writing_begun
operator|=
name|TRUE
expr_stmt|;
comment|/* If this revision has no nodes left because the ones it had were      dropped, and we are not dropping empty revisions, and we were not      told to preserve revision props, then we want to fixup the      revision props to only contain:        - the date        - a log message that reports that this revision is just stuffing. */
if|if
condition|(
operator|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|preserve_revprops
operator|)
operator|&&
operator|(
operator|!
name|rb
operator|->
name|has_nodes
operator|)
operator|&&
name|rb
operator|->
name|had_dropped_nodes
operator|&&
operator|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|drop_empty_revs
operator|)
operator|&&
operator|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|drop_all_empty_revs
operator|)
condition|)
block|{
name|apr_hash_t
modifier|*
name|old_props
init|=
name|rb
operator|->
name|props
decl_stmt|;
name|rb
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
name|rb
operator|->
name|props
operator|=
name|apr_hash_make
argument_list|(
name|hash_pool
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|,
name|svn_hash_gets
argument_list|(
name|old_props
argument_list|,
name|SVN_PROP_REVISION_DATE
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|props
argument_list|,
name|SVN_PROP_REVISION_LOG
argument_list|,
name|svn_string_create
argument_list|(
name|_
argument_list|(
literal|"This is an empty revision for "
literal|"padding."
argument_list|)
argument_list|,
name|hash_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Now, "rasterize" the props to a string, and append the property      information to the header string.  */
if|if
condition|(
name|rb
operator|->
name|has_props
condition|)
block|{
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|rb
operator|->
name|props
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|pname
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|pval
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|write_prop_to_stringbuf
argument_list|(
name|props
argument_list|,
name|pname
argument_list|,
name|pval
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendcstr
argument_list|(
name|props
argument_list|,
literal|"PROPS-END\n"
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendcstr
argument_list|(
name|rb
operator|->
name|header
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": %"
name|APR_SIZE_T_FMT
argument_list|,
name|props
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|rb
operator|->
name|header
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|rb
operator|->
name|header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendcstr
argument_list|(
name|rb
operator|->
name|header
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": %"
name|APR_SIZE_T_FMT
argument_list|,
name|props
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|rb
operator|->
name|header
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|rb
operator|->
name|header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* put an end to headers */
name|svn_stringbuf_appendbyte
argument_list|(
name|rb
operator|->
name|header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* put an end to revision */
name|svn_stringbuf_appendbyte
argument_list|(
name|props
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* write out the revision */
comment|/* Revision is written out in the following cases:      1. If the revision has nodes or      it is revision 0 (Special case: To preserve the props on r0).      2. --drop-empty-revs has been supplied,      but revision has not all nodes dropped.      3. If no --drop-empty-revs or --drop-all-empty-revs have been supplied,      write out the revision which has no nodes to begin with.   */
if|if
condition|(
name|rb
operator|->
name|has_nodes
operator|||
operator|(
name|rb
operator|->
name|rev_orig
operator|==
literal|0
operator|)
condition|)
name|write_out_rev
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|drop_empty_revs
condition|)
name|write_out_rev
operator|=
operator|!
name|rb
operator|->
name|had_dropped_nodes
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|drop_all_empty_revs
condition|)
name|write_out_rev
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|write_out_rev
condition|)
block|{
comment|/* This revision is a keeper. */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|rb
operator|->
name|header
operator|->
name|data
argument_list|,
operator|&
operator|(
name|rb
operator|->
name|header
operator|->
name|len
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|props
operator|->
name|data
argument_list|,
operator|&
operator|(
name|props
operator|->
name|len
operator|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Stash the oldest original rev not dropped. */
if|if
condition|(
name|rb
operator|->
name|rev_orig
operator|>
literal|0
operator|&&
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|oldest_original_rev
argument_list|)
condition|)
name|rb
operator|->
name|pb
operator|->
name|oldest_original_rev
operator|=
name|rb
operator|->
name|rev_orig
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|do_renumber_revs
condition|)
block|{
name|svn_revnum_t
modifier|*
name|rr_key
decl_stmt|;
name|struct
name|revmap_t
modifier|*
name|rr_val
decl_stmt|;
name|apr_pool_t
modifier|*
name|rr_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|renumber_history
argument_list|)
decl_stmt|;
name|rr_key
operator|=
name|apr_palloc
argument_list|(
name|rr_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr_key
argument_list|)
argument_list|)
expr_stmt|;
name|rr_val
operator|=
name|apr_palloc
argument_list|(
name|rr_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr_val
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rr_key
operator|=
name|rb
operator|->
name|rev_orig
expr_stmt|;
name|rr_val
operator|->
name|rev
operator|=
name|rb
operator|->
name|rev_actual
expr_stmt|;
name|rr_val
operator|->
name|was_dropped
operator|=
name|FALSE
expr_stmt|;
name|apr_hash_set
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|renumber_history
argument_list|,
name|rr_key
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr_key
argument_list|)
argument_list|,
name|rr_val
argument_list|)
expr_stmt|;
name|rb
operator|->
name|pb
operator|->
name|last_live_revision
operator|=
name|rb
operator|->
name|rev_actual
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
name|_
argument_list|(
literal|"Revision %ld committed as %ld.\n"
argument_list|)
argument_list|,
name|rb
operator|->
name|rev_orig
argument_list|,
name|rb
operator|->
name|rev_actual
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* We're dropping this revision. */
name|rb
operator|->
name|pb
operator|->
name|rev_drop_count
operator|++
expr_stmt|;
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|do_renumber_revs
condition|)
block|{
name|svn_revnum_t
modifier|*
name|rr_key
decl_stmt|;
name|struct
name|revmap_t
modifier|*
name|rr_val
decl_stmt|;
name|apr_pool_t
modifier|*
name|rr_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|renumber_history
argument_list|)
decl_stmt|;
name|rr_key
operator|=
name|apr_palloc
argument_list|(
name|rr_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr_key
argument_list|)
argument_list|)
expr_stmt|;
name|rr_val
operator|=
name|apr_palloc
argument_list|(
name|rr_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr_val
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|rr_key
operator|=
name|rb
operator|->
name|rev_orig
expr_stmt|;
name|rr_val
operator|->
name|rev
operator|=
name|rb
operator|->
name|pb
operator|->
name|last_live_revision
expr_stmt|;
name|rr_val
operator|->
name|was_dropped
operator|=
name|TRUE
expr_stmt|;
name|apr_hash_set
argument_list|(
name|rb
operator|->
name|pb
operator|->
name|renumber_history
argument_list|,
name|rr_key
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|rr_key
argument_list|)
argument_list|,
name|rr_val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|rb
operator|->
name|pb
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
name|_
argument_list|(
literal|"Revision %ld skipped.\n"
argument_list|)
argument_list|,
name|rb
operator|->
name|rev_orig
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* UUID record here: dump it, as we do not filter them. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|uuid_record
parameter_list|(
specifier|const
name|char
modifier|*
name|uuid
parameter_list|,
name|void
modifier|*
name|parse_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton_t
modifier|*
name|pb
init|=
name|parse_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|pb
operator|->
name|out_stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_UUID
literal|": %s\n\n"
argument_list|,
name|uuid
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* New node here. Set up node_baton by copying headers. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|new_node_record
parameter_list|(
name|void
modifier|*
modifier|*
name|node_baton
parameter_list|,
name|apr_hash_t
modifier|*
name|headers
parameter_list|,
name|void
modifier|*
name|rev_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton_t
modifier|*
name|pb
decl_stmt|;
name|struct
name|node_baton_t
modifier|*
name|nb
decl_stmt|;
name|char
modifier|*
name|node_path
decl_stmt|,
modifier|*
name|copyfrom_path
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
specifier|const
name|char
modifier|*
name|tcl
decl_stmt|;
operator|*
name|node_baton
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|node_baton_t
argument_list|)
argument_list|)
expr_stmt|;
name|nb
operator|=
operator|*
name|node_baton
expr_stmt|;
name|nb
operator|->
name|rb
operator|=
name|rev_baton
expr_stmt|;
name|pb
operator|=
name|nb
operator|->
name|rb
operator|->
name|pb
expr_stmt|;
name|node_path
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|)
expr_stmt|;
name|copyfrom_path
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
argument_list|)
expr_stmt|;
comment|/* Ensure that paths start with a leading '/'. */
if|if
condition|(
name|node_path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|node_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|node_path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyfrom_path
operator|&&
name|copyfrom_path
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|copyfrom_path
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|copyfrom_path
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|nb
operator|->
name|do_skip
operator|=
name|skip_path
argument_list|(
name|node_path
argument_list|,
name|pb
operator|->
name|prefixes
argument_list|,
name|pb
operator|->
name|do_exclude
argument_list|,
name|pb
operator|->
name|glob
argument_list|)
expr_stmt|;
comment|/* If we're skipping the node, take note of path, discarding the      rest.  */
if|if
condition|(
name|nb
operator|->
name|do_skip
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|pb
operator|->
name|dropped_nodes
argument_list|,
name|apr_pstrdup
argument_list|(
name|apr_hash_pool_get
argument_list|(
name|pb
operator|->
name|dropped_nodes
argument_list|)
argument_list|,
name|node_path
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
literal|1
argument_list|)
expr_stmt|;
name|nb
operator|->
name|rb
operator|->
name|had_dropped_nodes
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|kind
decl_stmt|;
specifier|const
name|char
modifier|*
name|action
decl_stmt|;
name|tcl
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
argument_list|)
expr_stmt|;
comment|/* Test if this node was copied from dropped source. */
if|if
condition|(
name|copyfrom_path
operator|&&
name|skip_path
argument_list|(
name|copyfrom_path
argument_list|,
name|pb
operator|->
name|prefixes
argument_list|,
name|pb
operator|->
name|do_exclude
argument_list|,
name|pb
operator|->
name|glob
argument_list|)
condition|)
block|{
comment|/* This node was copied from a dropped source.              We have a problem, since we did not want to drop this node too.               However, there is one special case we'll handle.  If the node is              a file, and this was a copy-and-modify operation, then the              dumpfile should contain the new contents of the file.  In this              scenario, we'll just do an add without history using the new              contents.  */
name|kind
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|)
expr_stmt|;
comment|/* If there is a Text-content-length header, and the kind is              "file", we just fallback to an add without history. */
if|if
condition|(
name|tcl
operator|&&
operator|(
name|strcmp
argument_list|(
name|kind
argument_list|,
literal|"file"
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|svn_hash_sets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|copyfrom_path
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* Else, this is either a directory or a file whose contents we              don't have readily available.  */
else|else
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Invalid copy source path '%s'"
argument_list|)
argument_list|,
name|copyfrom_path
argument_list|)
return|;
block|}
block|}
name|nb
operator|->
name|has_props
operator|=
name|FALSE
expr_stmt|;
name|nb
operator|->
name|has_text
operator|=
name|FALSE
expr_stmt|;
name|nb
operator|->
name|has_prop_delta
operator|=
name|FALSE
expr_stmt|;
name|nb
operator|->
name|has_text_delta
operator|=
name|FALSE
expr_stmt|;
name|nb
operator|->
name|writing_begun
operator|=
name|FALSE
expr_stmt|;
name|nb
operator|->
name|tcl
operator|=
name|tcl
condition|?
name|svn__atoui64
argument_list|(
name|tcl
argument_list|)
else|:
literal|0
expr_stmt|;
name|nb
operator|->
name|header
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|nb
operator|->
name|props
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|nb
operator|->
name|node_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|node_path
argument_list|)
expr_stmt|;
comment|/* Now we know for sure that we have a node that will not be          skipped, flush the revision if it has not already been done. */
name|nb
operator|->
name|rb
operator|->
name|has_nodes
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|nb
operator|->
name|rb
operator|->
name|writing_begun
condition|)
name|SVN_ERR
argument_list|(
name|output_revision
argument_list|(
name|nb
operator|->
name|rb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* A node record is required to begin with 'Node-path', skip the          leading '/' to match the form used by 'svnadmin dump'. */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|,
name|node_path
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Node-kind is next and is optional. */
name|kind
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|,
name|kind
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Node-action is next and required. */
name|action
operator|=
name|svn_hash_gets
argument_list|(
name|headers
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|)
expr_stmt|;
if|if
condition|(
name|action
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|,
name|action
argument_list|)
argument_list|)
expr_stmt|;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Missing Node-action for path '%s'"
argument_list|)
argument_list|,
name|node_path
argument_list|)
return|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|headers
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|key
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|val
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_DELTA
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|)
condition|)
name|nb
operator|->
name|has_prop_delta
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_DELTA
argument_list|)
operator|)
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|val
argument_list|,
literal|"true"
argument_list|)
operator|)
condition|)
name|nb
operator|->
name|has_text_delta
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_PATH
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_KIND
argument_list|)
operator|)
operator|||
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_ACTION
argument_list|)
operator|)
condition|)
continue|continue;
comment|/* Rewrite Node-Copyfrom-Rev if we are renumbering revisions.              The number points to some revision in the past. We keep track              of revision renumbering in an apr_hash, which maps original              revisions to new ones. Dropped revision are mapped to -1.              This should never happen here.           */
if|if
condition|(
name|pb
operator|->
name|do_renumber_revs
operator|&&
operator|(
operator|!
name|strcmp
argument_list|(
name|key
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
argument_list|)
operator|)
condition|)
block|{
name|svn_revnum_t
name|cf_orig_rev
decl_stmt|;
name|struct
name|revmap_t
modifier|*
name|cf_renum_val
decl_stmt|;
name|cf_orig_rev
operator|=
name|SVN_STR_TO_REV
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|cf_renum_val
operator|=
name|apr_hash_get
argument_list|(
name|pb
operator|->
name|renumber_history
argument_list|,
operator|&
name|cf_orig_rev
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|cf_renum_val
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|cf_renum_val
operator|->
name|rev
argument_list|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No valid copyfrom revision in filtered stream"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|pool
argument_list|,
name|SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV
literal|": %ld\n"
argument_list|,
name|cf_renum_val
operator|->
name|rev
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* passthru: put header straight to output */
name|SVN_ERR
argument_list|(
name|svn_stream_printf
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|pool
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|key
argument_list|,
name|val
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Output node header and props to dumpstream    This will be called by set_fulltext() after setting nb->has_text to TRUE,    if the node has any text, or by close_node() otherwise. This must only    be called if nb->writing_begun is FALSE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|output_node
parameter_list|(
name|struct
name|node_baton_t
modifier|*
name|nb
parameter_list|)
block|{
name|int
name|bytes_used
decl_stmt|;
name|char
name|buf
index|[
name|SVN_KEYLINE_MAXLEN
index|]
decl_stmt|;
name|nb
operator|->
name|writing_begun
operator|=
name|TRUE
expr_stmt|;
comment|/* when there are no props nb->props->len would be zero and won't mess up      Content-Length. */
if|if
condition|(
name|nb
operator|->
name|has_props
condition|)
name|svn_stringbuf_appendcstr
argument_list|(
name|nb
operator|->
name|props
argument_list|,
literal|"PROPS-END\n"
argument_list|)
expr_stmt|;
comment|/* 1. recalculate& check text-md5 if present. Passed through right now. */
comment|/* 2. recalculate and add content-lengths */
if|if
condition|(
name|nb
operator|->
name|has_props
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|nb
operator|->
name|header
argument_list|,
name|SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": %"
name|APR_SIZE_T_FMT
argument_list|,
name|nb
operator|->
name|props
operator|->
name|len
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|nb
operator|->
name|header
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|nb
operator|->
name|header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nb
operator|->
name|has_text
condition|)
block|{
name|svn_stringbuf_appendcstr
argument_list|(
name|nb
operator|->
name|header
argument_list|,
name|SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": %"
name|SVN_FILESIZE_T_FMT
argument_list|,
name|nb
operator|->
name|tcl
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|nb
operator|->
name|header
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|nb
operator|->
name|header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|svn_stringbuf_appendcstr
argument_list|(
name|nb
operator|->
name|header
argument_list|,
name|SVN_REPOS_DUMPFILE_CONTENT_LENGTH
argument_list|)
expr_stmt|;
name|bytes_used
operator|=
name|apr_snprintf
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|": %"
name|SVN_FILESIZE_T_FMT
argument_list|,
call|(
name|svn_filesize_t
call|)
argument_list|(
name|nb
operator|->
name|props
operator|->
name|len
operator|+
name|nb
operator|->
name|tcl
argument_list|)
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|nb
operator|->
name|header
argument_list|,
name|buf
argument_list|,
name|bytes_used
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbyte
argument_list|(
name|nb
operator|->
name|header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* put an end to headers */
name|svn_stringbuf_appendbyte
argument_list|(
name|nb
operator|->
name|header
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* 3. output all the stuff */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|nb
operator|->
name|header
operator|->
name|data
argument_list|,
operator|&
operator|(
name|nb
operator|->
name|header
operator|->
name|len
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
name|nb
operator|->
name|props
operator|->
name|data
argument_list|,
operator|&
operator|(
name|nb
operator|->
name|props
operator|->
name|len
operator|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Examine the mergeinfo in INITIAL_VAL, omitting missing merge    sources or renumbering revisions in rangelists as appropriate, and    return the (possibly new) mergeinfo in *FINAL_VAL (allocated from    POOL). */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|adjust_mergeinfo
parameter_list|(
name|svn_string_t
modifier|*
modifier|*
name|final_val
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|initial_val
parameter_list|,
name|struct
name|revision_baton_t
modifier|*
name|rb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|mergeinfo
decl_stmt|;
name|apr_hash_t
modifier|*
name|final_mergeinfo
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_parse
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|initial_val
operator|->
name|data
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Issue #3020: If we are skipping missing merge sources, then also      filter mergeinfo ranges as old or older than the oldest revision in the      dump stream.  Those older than the oldest obviously refer to history      outside of the dump stream.  The oldest rev itself is present in the      dump, but cannot be a valid merge source revision since it is the      start of all history.  E.g. if we dump -r100:400 then dumpfilter the      result with --skip-missing-merge-sources, any mergeinfo with revision      100 implies a change of -r99:100, but r99 is part of the history we      want filtered.  This is analogous to how r1 is always meaningless as      a merge source revision.       If the oldest rev is r0 then there is nothing to filter. */
if|if
condition|(
name|rb
operator|->
name|pb
operator|->
name|skip_missing_merge_sources
operator|&&
name|rb
operator|->
name|pb
operator|->
name|oldest_original_rev
operator|>
literal|0
condition|)
name|SVN_ERR
argument_list|(
name|svn_mergeinfo__filter_mergeinfo_by_ranges
argument_list|(
operator|&
name|mergeinfo
argument_list|,
name|mergeinfo
argument_list|,
name|rb
operator|->
name|pb
operator|->
name|oldest_original_rev
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|,
name|subpool
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|subpool
argument_list|,
name|mergeinfo
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|merge_source
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_rangelist_t
modifier|*
name|rangelist
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|struct
name|parse_baton_t
modifier|*
name|pb
init|=
name|rb
operator|->
name|pb
decl_stmt|;
comment|/* Determine whether the merge_source is a part of the prefix. */
if|if
condition|(
name|skip_path
argument_list|(
name|merge_source
argument_list|,
name|pb
operator|->
name|prefixes
argument_list|,
name|pb
operator|->
name|do_exclude
argument_list|,
name|pb
operator|->
name|glob
argument_list|)
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|skip_missing_merge_sources
condition|)
continue|continue;
else|else
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Missing merge source path '%s'; try "
literal|"with --skip-missing-merge-sources"
argument_list|)
argument_list|,
name|merge_source
argument_list|)
return|;
block|}
comment|/* Possibly renumber revisions in merge source's rangelist. */
if|if
condition|(
name|pb
operator|->
name|do_renumber_revs
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rangelist
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|revmap_t
modifier|*
name|revmap_start
decl_stmt|;
name|struct
name|revmap_t
modifier|*
name|revmap_end
decl_stmt|;
name|svn_merge_range_t
modifier|*
name|range
init|=
name|APR_ARRAY_IDX
argument_list|(
name|rangelist
argument_list|,
name|i
argument_list|,
name|svn_merge_range_t
operator|*
argument_list|)
decl_stmt|;
name|revmap_start
operator|=
name|apr_hash_get
argument_list|(
name|pb
operator|->
name|renumber_history
argument_list|,
operator|&
name|range
operator|->
name|start
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|revmap_start
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revmap_start
operator|->
name|rev
argument_list|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No valid revision range 'start' in filtered stream"
argument_list|)
argument_list|)
return|;
name|revmap_end
operator|=
name|apr_hash_get
argument_list|(
name|pb
operator|->
name|renumber_history
argument_list|,
operator|&
name|range
operator|->
name|end
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|revmap_end
operator|&&
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revmap_end
operator|->
name|rev
argument_list|)
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_NODE_UNEXPECTED_KIND
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"No valid revision range 'end' in filtered stream"
argument_list|)
argument_list|)
return|;
name|range
operator|->
name|start
operator|=
name|revmap_start
operator|->
name|rev
expr_stmt|;
name|range
operator|->
name|end
operator|=
name|revmap_end
operator|->
name|rev
expr_stmt|;
block|}
block|}
name|svn_hash_sets
argument_list|(
name|final_mergeinfo
argument_list|,
name|merge_source
argument_list|,
name|rangelist
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_sort
argument_list|(
name|final_mergeinfo
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_mergeinfo_to_string
argument_list|(
name|final_val
argument_list|,
name|final_mergeinfo
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_revision_property
parameter_list|(
name|void
modifier|*
name|revision_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|revision_baton_t
modifier|*
name|rb
init|=
name|revision_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|hash_pool
init|=
name|apr_hash_pool_get
argument_list|(
name|rb
operator|->
name|props
argument_list|)
decl_stmt|;
name|rb
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|rb
operator|->
name|props
argument_list|,
name|apr_pstrdup
argument_list|(
name|hash_pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|hash_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_node_property
parameter_list|(
name|void
modifier|*
name|node_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|node_baton_t
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
name|struct
name|revision_baton_t
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
if|if
condition|(
name|nb
operator|->
name|do_skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
operator|(
name|nb
operator|->
name|has_props
operator|||
name|nb
operator|->
name|has_prop_delta
operator|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Delta property block detected, but deltas "
literal|"are not enabled for node '%s' in original "
literal|"revision %ld"
argument_list|)
argument_list|,
name|nb
operator|->
name|node_path
argument_list|,
name|rb
operator|->
name|rev_orig
argument_list|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
operator|==
literal|0
condition|)
block|{
name|svn_string_t
modifier|*
name|filtered_mergeinfo
decl_stmt|;
comment|/* Avoid compiler warning. */
name|apr_pool_t
modifier|*
name|pool
init|=
name|apr_hash_pool_get
argument_list|(
name|rb
operator|->
name|props
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|adjust_mergeinfo
argument_list|(
operator|&
name|filtered_mergeinfo
argument_list|,
name|value
argument_list|,
name|rb
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|value
operator|=
name|filtered_mergeinfo
expr_stmt|;
block|}
name|nb
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
name|write_prop_to_stringbuf
argument_list|(
name|nb
operator|->
name|props
argument_list|,
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_node_property
parameter_list|(
name|void
modifier|*
name|node_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|struct
name|node_baton_t
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
name|struct
name|revision_baton_t
modifier|*
name|rb
init|=
name|nb
operator|->
name|rb
decl_stmt|;
if|if
condition|(
name|nb
operator|->
name|do_skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
operator|!
name|nb
operator|->
name|has_prop_delta
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_STREAM_MALFORMED_DATA
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Delta property block detected, but deltas "
literal|"are not enabled for node '%s' in original "
literal|"revision %ld"
argument_list|)
argument_list|,
name|nb
operator|->
name|node_path
argument_list|,
name|rb
operator|->
name|rev_orig
argument_list|)
return|;
name|nb
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
name|write_propdel_to_stringbuf
argument_list|(
operator|&
operator|(
name|nb
operator|->
name|props
operator|)
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|remove_node_props
parameter_list|(
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton_t
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
comment|/* In this case, not actually indicating that the node *has* props,      rather that we know about all the props that it has, since it now      has none. */
name|nb
operator|->
name|has_props
operator|=
name|TRUE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_fulltext
parameter_list|(
name|svn_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton_t
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
if|if
condition|(
operator|!
name|nb
operator|->
name|do_skip
condition|)
block|{
name|nb
operator|->
name|has_text
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|nb
operator|->
name|writing_begun
condition|)
name|SVN_ERR
argument_list|(
name|output_node
argument_list|(
name|nb
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|stream
operator|=
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Finalize node */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_node
parameter_list|(
name|void
modifier|*
name|node_baton
parameter_list|)
block|{
name|struct
name|node_baton_t
modifier|*
name|nb
init|=
name|node_baton
decl_stmt|;
name|apr_size_t
name|len
init|=
literal|2
decl_stmt|;
comment|/* Get out of here if we can. */
if|if
condition|(
name|nb
operator|->
name|do_skip
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* If the node was not flushed already to output its text, do it now. */
if|if
condition|(
operator|!
name|nb
operator|->
name|writing_begun
condition|)
name|SVN_ERR
argument_list|(
name|output_node
argument_list|(
name|nb
argument_list|)
argument_list|)
expr_stmt|;
comment|/* put an end to node. */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|nb
operator|->
name|rb
operator|->
name|pb
operator|->
name|out_stream
argument_list|,
literal|"\n\n"
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Finalize revision */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_revision
parameter_list|(
name|void
modifier|*
name|revision_baton
parameter_list|)
block|{
name|struct
name|revision_baton_t
modifier|*
name|rb
init|=
name|revision_baton
decl_stmt|;
comment|/* If no node has yet flushed the revision, do it now. */
if|if
condition|(
operator|!
name|rb
operator|->
name|writing_begun
condition|)
return|return
name|output_revision
argument_list|(
name|rb
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Filtering vtable */
end_comment

begin_decl_stmt
name|svn_repos_parse_fns3_t
name|filtering_vtable
init|=
block|{
name|magic_header_record
block|,
name|uuid_record
block|,
name|new_revision_record
block|,
name|new_node_record
block|,
name|set_revision_property
block|,
name|set_node_property
block|,
name|delete_node_property
block|,
name|remove_node_props
block|,
name|set_fulltext
block|,
name|NULL
block|,
name|close_node
block|,
name|close_revision
block|}
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/** Subcommands. **/
end_comment

begin_decl_stmt
specifier|static
name|svn_opt_subcommand_t
name|subcommand_help
decl_stmt|,
name|subcommand_exclude
decl_stmt|,
name|subcommand_include
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
block|{
name|svndumpfilter__drop_empty_revs
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|svndumpfilter__drop_all_empty_revs
block|,
name|svndumpfilter__renumber_revs
block|,
name|svndumpfilter__preserve_revprops
block|,
name|svndumpfilter__skip_missing_merge_sources
block|,
name|svndumpfilter__targets
block|,
name|svndumpfilter__quiet
block|,
name|svndumpfilter__glob
block|,
name|svndumpfilter__version
block|}
enum|;
end_enum

begin_comment
comment|/* Option codes and descriptions.  *  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|options_table
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
literal|"version"
block|,
name|svndumpfilter__version
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
block|,
block|{
literal|"quiet"
block|,
name|svndumpfilter__quiet
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Do not display filtering statistics."
argument_list|)
block|}
block|,
block|{
literal|"pattern"
block|,
name|svndumpfilter__glob
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Treat the path prefixes as file glob patterns."
argument_list|)
block|}
block|,
block|{
literal|"drop-empty-revs"
block|,
name|svndumpfilter__drop_empty_revs
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Remove revisions emptied by filtering."
argument_list|)
block|}
block|,
block|{
literal|"drop-all-empty-revs"
block|,
name|svndumpfilter__drop_all_empty_revs
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Remove all empty revisions found in dumpstream\n"
literal|"                             except revision 0."
argument_list|)
block|}
block|,
block|{
literal|"renumber-revs"
block|,
name|svndumpfilter__renumber_revs
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Renumber revisions left after filtering."
argument_list|)
block|}
block|,
block|{
literal|"skip-missing-merge-sources"
block|,
name|svndumpfilter__skip_missing_merge_sources
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Skip missing merge sources."
argument_list|)
block|}
block|,
block|{
literal|"preserve-revprops"
block|,
name|svndumpfilter__preserve_revprops
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"Don't filter revision properties."
argument_list|)
block|}
block|,
block|{
literal|"targets"
block|,
name|svndumpfilter__targets
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"Read additional prefixes, one per line, from\n"
literal|"                             file ARG."
argument_list|)
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of available subcommands.  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|cmd_table
index|[]
init|=
block|{
block|{
literal|"exclude"
block|,
name|subcommand_exclude
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"Filter out nodes with given prefixes from dumpstream.\n"
literal|"usage: svndumpfilter exclude PATH_PREFIX...\n"
argument_list|)
block|,
block|{
name|svndumpfilter__drop_empty_revs
block|,
name|svndumpfilter__drop_all_empty_revs
block|,
name|svndumpfilter__renumber_revs
block|,
name|svndumpfilter__skip_missing_merge_sources
block|,
name|svndumpfilter__targets
block|,
name|svndumpfilter__preserve_revprops
block|,
name|svndumpfilter__quiet
block|,
name|svndumpfilter__glob
block|}
block|}
block|,
block|{
literal|"include"
block|,
name|subcommand_include
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"Filter out nodes without given prefixes from dumpstream.\n"
literal|"usage: svndumpfilter include PATH_PREFIX...\n"
argument_list|)
block|,
block|{
name|svndumpfilter__drop_empty_revs
block|,
name|svndumpfilter__drop_all_empty_revs
block|,
name|svndumpfilter__renumber_revs
block|,
name|svndumpfilter__skip_missing_merge_sources
block|,
name|svndumpfilter__targets
block|,
name|svndumpfilter__preserve_revprops
block|,
name|svndumpfilter__quiet
block|,
name|svndumpfilter__glob
block|}
block|}
block|,
block|{
literal|"help"
block|,
name|subcommand_help
block|,
block|{
literal|"?"
block|,
literal|"h"
block|}
block|,
name|N_
argument_list|(
literal|"Describe the usage of this program or its subcommands.\n"
literal|"usage: svndumpfilter help [SUBCOMMAND...]\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baton for passing option/argument state to a subcommand function. */
end_comment

begin_struct
struct|struct
name|svndumpfilter_opt_state
block|{
name|svn_opt_revision_t
name|start_revision
decl_stmt|;
comment|/* -r X[:Y] is         */
name|svn_opt_revision_t
name|end_revision
decl_stmt|;
comment|/* not implemented.    */
name|svn_boolean_t
name|quiet
decl_stmt|;
comment|/* --quiet             */
name|svn_boolean_t
name|glob
decl_stmt|;
comment|/* --pattern           */
name|svn_boolean_t
name|version
decl_stmt|;
comment|/* --version           */
name|svn_boolean_t
name|drop_empty_revs
decl_stmt|;
comment|/* --drop-empty-revs   */
name|svn_boolean_t
name|drop_all_empty_revs
decl_stmt|;
comment|/* --drop-all-empty-revs */
name|svn_boolean_t
name|help
decl_stmt|;
comment|/* --help or -?        */
name|svn_boolean_t
name|renumber_revs
decl_stmt|;
comment|/* --renumber-revs     */
name|svn_boolean_t
name|preserve_revprops
decl_stmt|;
comment|/* --preserve-revprops */
name|svn_boolean_t
name|skip_missing_merge_sources
decl_stmt|;
comment|/* --skip-missing-merge-sources */
specifier|const
name|char
modifier|*
name|targets_file
decl_stmt|;
comment|/* --targets-file       */
name|apr_array_header_t
modifier|*
name|prefixes
decl_stmt|;
comment|/* mainargs.           */
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_baton_initialize
parameter_list|(
name|struct
name|parse_baton_t
modifier|*
modifier|*
name|pb
parameter_list|,
name|struct
name|svndumpfilter_opt_state
modifier|*
name|opt_state
parameter_list|,
name|svn_boolean_t
name|do_exclude
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|parse_baton_t
modifier|*
name|baton
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|baton
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Read the stream from STDIN.  Users can redirect a file. */
name|SVN_ERR
argument_list|(
name|create_stdio_stream
argument_list|(
operator|&
operator|(
name|baton
operator|->
name|in_stream
operator|)
argument_list|,
name|apr_file_open_stdin
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Have the parser dump results to STDOUT. Users can redirect a file. */
name|SVN_ERR
argument_list|(
name|create_stdio_stream
argument_list|(
operator|&
operator|(
name|baton
operator|->
name|out_stream
operator|)
argument_list|,
name|apr_file_open_stdout
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|baton
operator|->
name|do_exclude
operator|=
name|do_exclude
expr_stmt|;
comment|/* Ignore --renumber-revs if there can't possibly be      anything to renumber. */
name|baton
operator|->
name|do_renumber_revs
operator|=
operator|(
name|opt_state
operator|->
name|renumber_revs
operator|&&
operator|(
name|opt_state
operator|->
name|drop_empty_revs
operator|||
name|opt_state
operator|->
name|drop_all_empty_revs
operator|)
operator|)
expr_stmt|;
name|baton
operator|->
name|drop_empty_revs
operator|=
name|opt_state
operator|->
name|drop_empty_revs
expr_stmt|;
name|baton
operator|->
name|drop_all_empty_revs
operator|=
name|opt_state
operator|->
name|drop_all_empty_revs
expr_stmt|;
name|baton
operator|->
name|preserve_revprops
operator|=
name|opt_state
operator|->
name|preserve_revprops
expr_stmt|;
name|baton
operator|->
name|quiet
operator|=
name|opt_state
operator|->
name|quiet
expr_stmt|;
name|baton
operator|->
name|glob
operator|=
name|opt_state
operator|->
name|glob
expr_stmt|;
name|baton
operator|->
name|prefixes
operator|=
name|opt_state
operator|->
name|prefixes
expr_stmt|;
name|baton
operator|->
name|skip_missing_merge_sources
operator|=
name|opt_state
operator|->
name|skip_missing_merge_sources
expr_stmt|;
name|baton
operator|->
name|rev_drop_count
operator|=
literal|0
expr_stmt|;
comment|/* used to shift revnums while filtering */
name|baton
operator|->
name|dropped_nodes
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|renumber_history
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|baton
operator|->
name|last_live_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|baton
operator|->
name|oldest_original_rev
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|baton
operator|->
name|allow_deltas
operator|=
name|FALSE
expr_stmt|;
operator|*
name|pb
operator|=
name|baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `help` subcommand. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_help
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svndumpfilter_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
init|=
name|_
argument_list|(
literal|"general usage: svndumpfilter SUBCOMMAND [ARGS& OPTIONS ...]\n"
literal|"Type 'svndumpfilter help<subcommand>' for help on a "
literal|"specific subcommand.\n"
literal|"Type 'svndumpfilter --version' to see the program version.\n"
literal|"\n"
literal|"Available subcommands:\n"
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_print_help4
argument_list|(
name|os
argument_list|,
literal|"svndumpfilter"
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|version
else|:
name|FALSE
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|quiet
else|:
name|FALSE
argument_list|,
comment|/*###opt_state ? opt_state->verbose :*/
name|FALSE
argument_list|,
name|NULL
argument_list|,
name|header
argument_list|,
name|cmd_table
argument_list|,
name|options_table
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_repos"
block|,
name|svn_repos_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Do the real work of filtering. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_filter
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
name|do_exclude
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svndumpfilter_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|struct
name|parse_baton_t
modifier|*
name|pb
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|apr_array_header_t
modifier|*
name|keys
decl_stmt|;
name|int
name|i
decl_stmt|,
name|num_keys
decl_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|glob
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
name|do_exclude
condition|?
operator|(
name|opt_state
operator|->
name|drop_empty_revs
operator|||
name|opt_state
operator|->
name|drop_all_empty_revs
operator|)
condition|?
name|_
argument_list|(
literal|"Excluding (and dropping empty "
literal|"revisions for) prefix patterns:\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"Excluding prefix patterns:\n"
argument_list|)
else|:
operator|(
name|opt_state
operator|->
name|drop_empty_revs
operator|||
name|opt_state
operator|->
name|drop_all_empty_revs
operator|)
condition|?
name|_
argument_list|(
literal|"Including (and dropping empty "
literal|"revisions for) prefix patterns:\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"Including prefix patterns:\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
name|do_exclude
condition|?
operator|(
name|opt_state
operator|->
name|drop_empty_revs
operator|||
name|opt_state
operator|->
name|drop_all_empty_revs
operator|)
condition|?
name|_
argument_list|(
literal|"Excluding (and dropping empty "
literal|"revisions for) prefixes:\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"Excluding prefixes:\n"
argument_list|)
else|:
operator|(
name|opt_state
operator|->
name|drop_empty_revs
operator|||
name|opt_state
operator|->
name|drop_all_empty_revs
operator|)
condition|?
name|_
argument_list|(
literal|"Including (and dropping empty "
literal|"revisions for) prefixes:\n"
argument_list|)
else|:
name|_
argument_list|(
literal|"Including prefixes:\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|opt_state
operator|->
name|prefixes
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
literal|"   '%s'\n"
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|opt_state
operator|->
name|prefixes
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|parse_baton_initialize
argument_list|(
operator|&
name|pb
argument_list|,
name|opt_state
argument_list|,
name|do_exclude
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_parse_dumpstream3
argument_list|(
name|pb
operator|->
name|in_stream
argument_list|,
operator|&
name|filtering_vtable
argument_list|,
name|pb
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* The rest of this is just reporting.  If we aren't reporting, get      outta here. */
if|if
condition|(
name|opt_state
operator|->
name|quiet
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|rev_drop_count
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|Q_
argument_list|(
literal|"Dropped %d revision.\n\n"
argument_list|,
literal|"Dropped %d revisions.\n\n"
argument_list|,
name|pb
operator|->
name|rev_drop_count
argument_list|)
argument_list|,
name|pb
operator|->
name|rev_drop_count
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|do_renumber_revs
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
name|_
argument_list|(
literal|"Revisions renumbered as follows:\n"
argument_list|)
argument_list|,
name|stderr
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the keys of the hash, sort them, then print the hash keys          and values, sorted by keys. */
name|num_keys
operator|=
name|apr_hash_count
argument_list|(
name|pb
operator|->
name|renumber_history
argument_list|)
expr_stmt|;
name|keys
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|num_keys
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|svn_revnum_t
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|pb
operator|->
name|renumber_history
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|svn_revnum_t
modifier|*
name|revnum
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|keys
argument_list|,
name|svn_revnum_t
argument_list|)
operator|=
operator|*
name|revnum
expr_stmt|;
block|}
name|qsort
argument_list|(
name|keys
operator|->
name|elts
argument_list|,
name|keys
operator|->
name|nelts
argument_list|,
name|keys
operator|->
name|elt_size
argument_list|,
name|svn_sort_compare_revisions
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keys
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_revnum_t
name|this_key
decl_stmt|;
name|struct
name|revmap_t
modifier|*
name|this_val
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|this_key
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|keys
argument_list|,
name|i
argument_list|,
name|svn_revnum_t
argument_list|)
expr_stmt|;
name|this_val
operator|=
name|apr_hash_get
argument_list|(
name|pb
operator|->
name|renumber_history
argument_list|,
operator|&
name|this_key
argument_list|,
sizeof|sizeof
argument_list|(
name|this_key
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|this_val
operator|->
name|was_dropped
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
name|_
argument_list|(
literal|"   %ld => (dropped)\n"
argument_list|)
argument_list|,
name|this_key
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
literal|"   %ld => %ld\n"
argument_list|,
name|this_key
argument_list|,
name|this_val
operator|->
name|rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|num_keys
operator|=
name|apr_hash_count
argument_list|(
name|pb
operator|->
name|dropped_nodes
argument_list|)
operator|)
condition|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
name|Q_
argument_list|(
literal|"Dropped %d node:\n"
argument_list|,
literal|"Dropped %d nodes:\n"
argument_list|,
name|num_keys
argument_list|)
argument_list|,
name|num_keys
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Get the keys of the hash, sort them, then print the hash keys          and values, sorted by keys. */
name|keys
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|num_keys
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|pb
operator|->
name|dropped_nodes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|keys
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|path
expr_stmt|;
block|}
name|qsort
argument_list|(
name|keys
operator|->
name|elts
argument_list|,
name|keys
operator|->
name|nelts
argument_list|,
name|keys
operator|->
name|elt_size
argument_list|,
name|svn_sort_compare_paths
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|keys
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|subpool
argument_list|,
literal|"   '%s'\n"
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|APR_ARRAY_IDX
argument_list|(
name|keys
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_fputs
argument_list|(
literal|"\n"
argument_list|,
name|stderr
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `exclude' subcommand. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_exclude
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_filter
argument_list|(
name|os
argument_list|,
name|baton
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements `include` subcommand. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_include
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|do_filter
argument_list|(
name|os
argument_list|,
name|baton
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Main. **/
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|subcommand
init|=
name|NULL
decl_stmt|;
name|struct
name|svndumpfilter_opt_state
name|opt_state
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|int
name|opt_id
decl_stmt|;
name|apr_array_header_t
modifier|*
name|received_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svndumpfilter"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check library versions */
name|err
operator|=
name|check_lib_versions
argument_list|()
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svndumpfilter: "
argument_list|)
return|;
name|received_opts
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|SVN_OPT_MAX_OPTIONS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Initialize the FS library. */
name|err
operator|=
name|svn_fs_initialize
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svndumpfilter: "
argument_list|)
return|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Initialize opt_state. */
name|memset
argument_list|(
operator|&
name|opt_state
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|opt_state
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|.
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_state
operator|.
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
comment|/* Parse options. */
name|err
operator|=
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svndumpfilter: "
argument_list|)
return|;
name|os
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
comment|/* Parse the next option. */
name|apr_err
operator|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|options_table
argument_list|,
operator|&
name|opt_id
argument_list|,
operator|&
name|opt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|apr_err
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Stash the option code in an array before parsing it. */
name|APR_ARRAY_PUSH
argument_list|(
name|received_opts
argument_list|,
name|int
argument_list|)
operator|=
name|opt_id
expr_stmt|;
switch|switch
condition|(
name|opt_id
condition|)
block|{
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|opt_state
operator|.
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__version
case|:
name|opt_state
operator|.
name|version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__quiet
case|:
name|opt_state
operator|.
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__glob
case|:
name|opt_state
operator|.
name|glob
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__drop_empty_revs
case|:
name|opt_state
operator|.
name|drop_empty_revs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__drop_all_empty_revs
case|:
name|opt_state
operator|.
name|drop_all_empty_revs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__renumber_revs
case|:
name|opt_state
operator|.
name|renumber_revs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__preserve_revprops
case|:
name|opt_state
operator|.
name|preserve_revprops
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__skip_missing_merge_sources
case|:
name|opt_state
operator|.
name|skip_missing_merge_sources
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svndumpfilter__targets
case|:
name|opt_state
operator|.
name|targets_file
operator|=
name|opt_arg
expr_stmt|;
break|break;
default|default:
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
comment|/* close `switch' */
block|}
comment|/* close `while' */
comment|/* Disallow simultaneous use of both --drop-empty-revs and      --drop-all-empty-revs. */
if|if
condition|(
name|opt_state
operator|.
name|drop_empty_revs
operator|&&
name|opt_state
operator|.
name|drop_all_empty_revs
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_MUTUALLY_EXCLUSIVE_ARGS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--drop-empty-revs cannot be used with "
literal|"--drop-all-empty-revs"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svndumpfilter: "
argument_list|)
return|;
block|}
comment|/* If the user asked for help, then the rest of the arguments are      the names of subcommands to get help on (if any), or else they're      just typos/mistakes.  Whatever the case, the subcommand to      actually run is subcommand_help(). */
if|if
condition|(
name|opt_state
operator|.
name|help
condition|)
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
comment|/* If we're not running the `help' subcommand, then look for a      subcommand in the first argument. */
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|version
condition|)
block|{
comment|/* Use the "help" subcommand to handle the "--version" option. */
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|pseudo_cmd
init|=
block|{
literal|"--version"
block|,
name|subcommand_help
block|,
block|{
literal|0
block|}
block|,
literal|""
block|,
block|{
name|svndumpfilter__version
block|,
comment|/* must accept its own option */
name|svndumpfilter__quiet
block|,                   }
block|}
decl_stmt|;
name|subcommand
operator|=
operator|&
name|pseudo_cmd
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand argument required\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|first_arg
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
decl_stmt|;
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|first_arg_utf8
decl_stmt|;
if|if
condition|(
operator|(
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|first_arg_utf8
argument_list|,
name|first_arg
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svndumpfilter: "
argument_list|)
return|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unknown subcommand: '%s'\n"
argument_list|)
argument_list|,
name|first_arg_utf8
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
block|}
comment|/* If there's a second argument, it's probably [one of] prefixes.      Every subcommand except `help' requires at least one, so we parse      them out here and store in opt_state. */
if|if
condition|(
name|subcommand
operator|->
name|cmd_func
operator|!=
name|subcommand_help
condition|)
block|{
name|opt_state
operator|.
name|prefixes
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|os
operator|->
name|argc
operator|-
name|os
operator|->
name|ind
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|os
operator|->
name|ind
init|;
name|i
operator|<
name|os
operator|->
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* Ensure that each prefix is UTF8-encoded, in internal              style, and absolute. */
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|prefix
argument_list|,
name|os
operator|->
name|argv
index|[
name|i
index|]
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|svn_relpath__internal_style
argument_list|(
name|prefix
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|prefix
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|prefix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|opt_state
operator|.
name|prefixes
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|prefix
expr_stmt|;
block|}
if|if
condition|(
name|opt_state
operator|.
name|targets_file
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|,
modifier|*
name|buffer_utf8
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8_targets_file
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
comment|/* We need to convert to UTF-8 now, even before we divide              the targets into an array, because otherwise we wouldn't              know what delimiter to use for svn_cstring_split().  */
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_targets_file
argument_list|,
name|opt_state
operator|.
name|targets_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|buffer
argument_list|,
name|utf8_targets_file
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_utf_stringbuf_to_utf8
argument_list|(
operator|&
name|buffer_utf8
argument_list|,
name|buffer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|targets
operator|=
name|apr_array_append
argument_list|(
name|pool
argument_list|,
name|svn_cstring_split
argument_list|(
name|buffer_utf8
operator|->
name|data
argument_list|,
literal|"\n\r"
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|,
name|targets
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|targets
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|prefix
init|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|prefix
operator|=
name|apr_pstrcat
argument_list|(
name|pool
argument_list|,
literal|"/"
argument_list|,
name|prefix
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|opt_state
operator|.
name|prefixes
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|prefix
expr_stmt|;
block|}
block|}
if|if
condition|(
name|apr_is_empty_array
argument_list|(
name|opt_state
operator|.
name|prefixes
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"\nError: no prefixes supplied.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
comment|/* Check that the subcommand wasn't passed any inappropriate options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|received_opts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|opt_id
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|received_opts
argument_list|,
name|i
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* All commands implicitly accept --help, so just skip over this          when we see it. Note that we don't want to include this option          in their "accepted options" list because it would be awfully          redundant to display it in every commands' help text. */
if|if
condition|(
name|opt_id
operator|==
literal|'h'
operator|||
name|opt_id
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|svn_opt_subcommand_takes_option3
argument_list|(
name|subcommand
argument_list|,
name|opt_id
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|badopt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|opt_id
argument_list|,
name|options_table
argument_list|,
name|subcommand
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|badopt
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand '%s' doesn't accept option '%s'\n"
literal|"Type 'svndumpfilter help %s' for usage.\n"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|,
name|optstr
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
comment|/* Run the subcommand. */
name|err
operator|=
call|(
modifier|*
name|subcommand
operator|->
name|cmd_func
call|)
argument_list|(
name|os
argument_list|,
operator|&
name|opt_state
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* For argument-related problems, suggest using the 'help'          subcommand. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_INSUFFICIENT_ARGS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_ARG_PARSING_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Try 'svndumpfilter help' for more "
literal|"info"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|svn_cmdline_handle_exit_error
argument_list|(
name|err
argument_list|,
name|pool
argument_list|,
literal|"svndumpfilter: "
argument_list|)
return|;
block|}
else|else
block|{
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Flush stdout, making sure the user will see any print errors. */
name|SVN_INT_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_SUCCESS
return|;
block|}
block|}
end_function

end_unit

