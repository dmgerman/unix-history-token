begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * text-delta.c -- Internal text delta representation  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* for APR_INLINE */
end_comment

begin_include
include|#
directive|include
file|<apr_md5.h>
end_include

begin_comment
comment|/* for, um...MD5 stuff */
end_comment

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_checksum.h"
end_include

begin_include
include|#
directive|include
file|"delta.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* Text delta stream descriptor. */
end_comment

begin_struct
struct|struct
name|svn_txdelta_stream_t
block|{
comment|/* Copied from parameters to svn_txdelta_stream_create. */
name|void
modifier|*
name|baton
decl_stmt|;
name|svn_txdelta_next_window_fn_t
name|next_window
decl_stmt|;
name|svn_txdelta_md5_digest_fn_t
name|md5_digest
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Delta stream baton. */
end_comment

begin_struct
struct|struct
name|txdelta_baton
block|{
comment|/* These are copied from parameters passed to svn_txdelta. */
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|svn_stream_t
modifier|*
name|target
decl_stmt|;
comment|/* Private data */
name|svn_boolean_t
name|more_source
decl_stmt|;
comment|/* FALSE if source stream hit EOF. */
name|svn_boolean_t
name|more
decl_stmt|;
comment|/* TRUE if there are more data in the pool. */
name|svn_filesize_t
name|pos
decl_stmt|;
comment|/* Offset of next read in source file. */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* Buffer for input data. */
name|svn_checksum_ctx_t
modifier|*
name|context
decl_stmt|;
comment|/* If not NULL, the context for computing                                    the checksum. */
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
comment|/* If non-NULL, the checksum of TARGET. */
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
comment|/* For results (e.g. checksum) */
block|}
struct|;
end_struct

begin_comment
comment|/* Target-push stream descriptor. */
end_comment

begin_struct
struct|struct
name|tpush_baton
block|{
comment|/* These are copied from parameters passed to svn_txdelta_target_push. */
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|svn_txdelta_window_handler_t
name|wh
decl_stmt|;
name|void
modifier|*
name|whb
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Private data */
name|char
modifier|*
name|buf
decl_stmt|;
name|svn_filesize_t
name|source_offset
decl_stmt|;
name|apr_size_t
name|source_len
decl_stmt|;
name|svn_boolean_t
name|source_done
decl_stmt|;
name|apr_size_t
name|target_len
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Text delta applicator.  */
end_comment

begin_struct
struct|struct
name|apply_baton
block|{
comment|/* These are copied from parameters passed to svn_txdelta_apply.  */
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|svn_stream_t
modifier|*
name|target
decl_stmt|;
comment|/* Private data.  Between calls, SBUF contains the data from the    * last window's source view, as specified by SBUF_OFFSET and    * SBUF_LEN.  The contents of TBUF are not interesting between    * calls.  */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* Pool to allocate data from */
name|char
modifier|*
name|sbuf
decl_stmt|;
comment|/* Source buffer */
name|apr_size_t
name|sbuf_size
decl_stmt|;
comment|/* Allocated source buffer space */
name|svn_filesize_t
name|sbuf_offset
decl_stmt|;
comment|/* Offset of SBUF data in source stream */
name|apr_size_t
name|sbuf_len
decl_stmt|;
comment|/* Length of SBUF data */
name|char
modifier|*
name|tbuf
decl_stmt|;
comment|/* Target buffer */
name|apr_size_t
name|tbuf_size
decl_stmt|;
comment|/* Allocated target buffer space */
name|apr_md5_ctx_t
name|md5_context
decl_stmt|;
comment|/* Leads to result_digest below. */
name|unsigned
name|char
modifier|*
name|result_digest
decl_stmt|;
comment|/* MD5 digest of resultant fulltext;                                    must point to at least APR_MD5_DIGESTSIZE                                    bytes of storage. */
specifier|const
name|char
modifier|*
name|error_info
decl_stmt|;
comment|/* Optional extra info for error returns. */
block|}
struct|;
end_struct

begin_escape
end_escape

begin_function
name|svn_txdelta_window_t
modifier|*
name|svn_txdelta__make_window
parameter_list|(
specifier|const
name|svn_txdelta__ops_baton_t
modifier|*
name|build_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|svn_string_t
modifier|*
name|new_data
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_data
argument_list|)
argument_list|)
decl_stmt|;
name|window
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|window
argument_list|)
argument_list|)
expr_stmt|;
name|window
operator|->
name|sview_offset
operator|=
literal|0
expr_stmt|;
name|window
operator|->
name|sview_len
operator|=
literal|0
expr_stmt|;
name|window
operator|->
name|tview_len
operator|=
literal|0
expr_stmt|;
name|window
operator|->
name|num_ops
operator|=
name|build_baton
operator|->
name|num_ops
expr_stmt|;
name|window
operator|->
name|src_ops
operator|=
name|build_baton
operator|->
name|src_ops
expr_stmt|;
name|window
operator|->
name|ops
operator|=
name|build_baton
operator|->
name|ops
expr_stmt|;
comment|/* just copy the fields over, rather than alloc/copying into a whole new      svn_string_t structure. */
comment|/* ### would be much nicer if window->new_data were not a ptr... */
name|new_data
operator|->
name|data
operator|=
name|build_baton
operator|->
name|new_data
operator|->
name|data
expr_stmt|;
name|new_data
operator|->
name|len
operator|=
name|build_baton
operator|->
name|new_data
operator|->
name|len
expr_stmt|;
name|window
operator|->
name|new_data
operator|=
name|new_data
expr_stmt|;
return|return
name|window
return|;
block|}
end_function

begin_comment
comment|/* Compute and return a delta window using the xdelta algorithm on    DATA, which contains SOURCE_LEN bytes of source data and TARGET_LEN    bytes of target data.  SOURCE_OFFSET gives the offset of the source    data, and is simply copied into the window's sview_offset field. */
end_comment

begin_function
specifier|static
name|svn_txdelta_window_t
modifier|*
name|compute_window
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|source_len
parameter_list|,
name|apr_size_t
name|target_len
parameter_list|,
name|svn_filesize_t
name|source_offset
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta__ops_baton_t
name|build_baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
comment|/* Compute the delta operations. */
name|build_baton
operator|.
name|new_data
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|source_len
operator|==
literal|0
condition|)
name|svn_txdelta__insert_op
argument_list|(
operator|&
name|build_baton
argument_list|,
name|svn_txdelta_new
argument_list|,
literal|0
argument_list|,
name|target_len
argument_list|,
name|data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|svn_txdelta__xdelta
argument_list|(
operator|&
name|build_baton
argument_list|,
name|data
argument_list|,
name|source_len
argument_list|,
name|target_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Create and return the delta window. */
name|window
operator|=
name|svn_txdelta__make_window
argument_list|(
operator|&
name|build_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|window
operator|->
name|sview_offset
operator|=
name|source_offset
expr_stmt|;
name|window
operator|->
name|sview_len
operator|=
name|source_len
expr_stmt|;
name|window
operator|->
name|tview_len
operator|=
name|target_len
expr_stmt|;
return|return
name|window
return|;
block|}
end_function

begin_escape
end_escape

begin_function
name|svn_txdelta_window_t
modifier|*
name|svn_txdelta_window_dup
parameter_list|(
specifier|const
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta__ops_baton_t
name|build_baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|new_window
decl_stmt|;
specifier|const
name|apr_size_t
name|ops_size
init|=
operator|(
name|window
operator|->
name|num_ops
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|build_baton
operator|.
name|ops
argument_list|)
operator|)
decl_stmt|;
name|build_baton
operator|.
name|num_ops
operator|=
name|window
operator|->
name|num_ops
expr_stmt|;
name|build_baton
operator|.
name|src_ops
operator|=
name|window
operator|->
name|src_ops
expr_stmt|;
name|build_baton
operator|.
name|ops_size
operator|=
name|window
operator|->
name|num_ops
expr_stmt|;
name|build_baton
operator|.
name|ops
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|ops_size
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|build_baton
operator|.
name|ops
argument_list|,
name|window
operator|->
name|ops
argument_list|,
name|ops_size
argument_list|)
expr_stmt|;
name|build_baton
operator|.
name|new_data
operator|=
name|svn_stringbuf_create_from_string
argument_list|(
name|window
operator|->
name|new_data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_window
operator|=
name|svn_txdelta__make_window
argument_list|(
operator|&
name|build_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|new_window
operator|->
name|sview_offset
operator|=
name|window
operator|->
name|sview_offset
expr_stmt|;
name|new_window
operator|->
name|sview_len
operator|=
name|window
operator|->
name|sview_len
expr_stmt|;
name|new_window
operator|->
name|tview_len
operator|=
name|window
operator|->
name|tview_len
expr_stmt|;
return|return
name|new_window
return|;
block|}
end_function

begin_comment
comment|/* This is a private interlibrary compatibility wrapper. */
end_comment

begin_function_decl
name|svn_txdelta_window_t
modifier|*
name|svn_txdelta__copy_window
parameter_list|(
specifier|const
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|svn_txdelta_window_t
modifier|*
name|svn_txdelta__copy_window
parameter_list|(
specifier|const
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|svn_txdelta_window_dup
argument_list|(
name|window
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Insert a delta op into a delta window. */
end_comment

begin_function
name|void
name|svn_txdelta__insert_op
parameter_list|(
name|svn_txdelta__ops_baton_t
modifier|*
name|build_baton
parameter_list|,
name|enum
name|svn_delta_action
name|opcode
parameter_list|,
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
name|length
parameter_list|,
specifier|const
name|char
modifier|*
name|new_data
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_op_t
modifier|*
name|op
decl_stmt|;
comment|/* Check if this op can be merged with the previous op. The delta      combiner sometimes generates such ops, and this is the obvious      place to make the check. */
if|if
condition|(
name|build_baton
operator|->
name|num_ops
operator|>
literal|0
condition|)
block|{
name|op
operator|=
operator|&
name|build_baton
operator|->
name|ops
index|[
name|build_baton
operator|->
name|num_ops
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|action_code
operator|==
name|opcode
operator|&&
operator|(
name|opcode
operator|==
name|svn_txdelta_new
operator|||
name|op
operator|->
name|offset
operator|+
name|op
operator|->
name|length
operator|==
name|offset
operator|)
condition|)
block|{
name|op
operator|->
name|length
operator|+=
name|length
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|svn_txdelta_new
condition|)
name|svn_stringbuf_appendbytes
argument_list|(
name|build_baton
operator|->
name|new_data
argument_list|,
name|new_data
argument_list|,
name|length
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* Create space for the new op. */
if|if
condition|(
name|build_baton
operator|->
name|num_ops
operator|==
name|build_baton
operator|->
name|ops_size
condition|)
block|{
name|svn_txdelta_op_t
modifier|*
specifier|const
name|old_ops
init|=
name|build_baton
operator|->
name|ops
decl_stmt|;
name|int
specifier|const
name|new_ops_size
init|=
operator|(
name|build_baton
operator|->
name|ops_size
operator|==
literal|0
condition|?
literal|16
else|:
literal|2
operator|*
name|build_baton
operator|->
name|ops_size
operator|)
decl_stmt|;
name|build_baton
operator|->
name|ops
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|new_ops_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|build_baton
operator|->
name|ops
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Copy any existing ops into the new array */
if|if
condition|(
name|old_ops
condition|)
name|memcpy
argument_list|(
name|build_baton
operator|->
name|ops
argument_list|,
name|old_ops
argument_list|,
name|build_baton
operator|->
name|ops_size
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|build_baton
operator|->
name|ops
argument_list|)
argument_list|)
expr_stmt|;
name|build_baton
operator|->
name|ops_size
operator|=
name|new_ops_size
expr_stmt|;
block|}
comment|/* Insert the op. svn_delta_source and svn_delta_target are      just inserted. For svn_delta_new, the new data must be      copied into the window. */
name|op
operator|=
operator|&
name|build_baton
operator|->
name|ops
index|[
name|build_baton
operator|->
name|num_ops
index|]
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|svn_txdelta_source
case|:
operator|++
name|build_baton
operator|->
name|src_ops
expr_stmt|;
comment|/*** FALLTHRU ***/
case|case
name|svn_txdelta_target
case|:
name|op
operator|->
name|action_code
operator|=
name|opcode
expr_stmt|;
name|op
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|op
operator|->
name|length
operator|=
name|length
expr_stmt|;
break|break;
case|case
name|svn_txdelta_new
case|:
name|op
operator|->
name|action_code
operator|=
name|opcode
expr_stmt|;
name|op
operator|->
name|offset
operator|=
name|build_baton
operator|->
name|new_data
operator|->
name|len
expr_stmt|;
name|op
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|build_baton
operator|->
name|new_data
argument_list|,
name|new_data
argument_list|,
name|length
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
operator|!
literal|"unknown delta op."
argument_list|)
expr_stmt|;
block|}
operator|++
name|build_baton
operator|->
name|num_ops
expr_stmt|;
block|}
end_function

begin_function
name|apr_size_t
name|svn_txdelta__remove_copy
parameter_list|(
name|svn_txdelta__ops_baton_t
modifier|*
name|build_baton
parameter_list|,
name|apr_size_t
name|max_len
parameter_list|)
block|{
name|svn_txdelta_op_t
modifier|*
name|op
decl_stmt|;
name|apr_size_t
name|len
init|=
literal|0
decl_stmt|;
comment|/* remove ops back to front */
while|while
condition|(
name|build_baton
operator|->
name|num_ops
operator|>
literal|0
condition|)
block|{
name|op
operator|=
operator|&
name|build_baton
operator|->
name|ops
index|[
name|build_baton
operator|->
name|num_ops
operator|-
literal|1
index|]
expr_stmt|;
comment|/*  we can't modify svn_txdelta_target ops -> stop there */
if|if
condition|(
name|op
operator|->
name|action_code
operator|==
name|svn_txdelta_target
condition|)
break|break;
comment|/*  handle the case that we cannot remove the op entirely */
if|if
condition|(
name|op
operator|->
name|length
operator|+
name|len
operator|>
name|max_len
condition|)
block|{
comment|/* truncate only insertions. Copies don't benefit              from being truncated. */
if|if
condition|(
name|op
operator|->
name|action_code
operator|==
name|svn_txdelta_new
condition|)
block|{
name|build_baton
operator|->
name|new_data
operator|->
name|len
operator|-=
name|max_len
operator|-
name|len
expr_stmt|;
name|op
operator|->
name|length
operator|-=
name|max_len
operator|-
name|len
expr_stmt|;
name|len
operator|=
name|max_len
expr_stmt|;
block|}
break|break;
block|}
comment|/* drop the op entirely */
if|if
condition|(
name|op
operator|->
name|action_code
operator|==
name|svn_txdelta_new
condition|)
name|build_baton
operator|->
name|new_data
operator|->
name|len
operator|-=
name|op
operator|->
name|length
expr_stmt|;
name|len
operator|+=
name|op
operator|->
name|length
expr_stmt|;
operator|--
name|build_baton
operator|->
name|num_ops
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Generic delta stream functions. */
end_comment

begin_function
name|svn_txdelta_stream_t
modifier|*
name|svn_txdelta_stream_create
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_txdelta_next_window_fn_t
name|next_window
parameter_list|,
name|svn_txdelta_md5_digest_fn_t
name|md5_digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_stream_t
modifier|*
name|stream
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|stream
argument_list|)
argument_list|)
decl_stmt|;
name|stream
operator|->
name|baton
operator|=
name|baton
expr_stmt|;
name|stream
operator|->
name|next_window
operator|=
name|next_window
expr_stmt|;
name|stream
operator|->
name|md5_digest
operator|=
name|md5_digest
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_next_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window
parameter_list|,
name|svn_txdelta_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
return|return
name|stream
operator|->
name|next_window
argument_list|(
name|window
argument_list|,
name|stream
operator|->
name|baton
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
specifier|const
name|unsigned
name|char
modifier|*
name|svn_txdelta_md5_digest
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
name|stream
parameter_list|)
block|{
return|return
name|stream
operator|->
name|md5_digest
argument_list|(
name|stream
operator|->
name|baton
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|svn_error_t
modifier|*
name|txdelta_next_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|txdelta_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|source_len
init|=
name|SVN_DELTA_WINDOW_SIZE
decl_stmt|;
name|apr_size_t
name|target_len
init|=
name|SVN_DELTA_WINDOW_SIZE
decl_stmt|;
comment|/* Read the source stream. */
if|if
condition|(
name|b
operator|->
name|more_source
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|b
operator|->
name|source
argument_list|,
name|b
operator|->
name|buf
argument_list|,
operator|&
name|source_len
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|more_source
operator|=
operator|(
name|source_len
operator|==
name|SVN_DELTA_WINDOW_SIZE
operator|)
expr_stmt|;
block|}
else|else
name|source_len
operator|=
literal|0
expr_stmt|;
comment|/* Read the target stream. */
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|b
operator|->
name|target
argument_list|,
name|b
operator|->
name|buf
operator|+
name|source_len
argument_list|,
operator|&
name|target_len
argument_list|)
argument_list|)
expr_stmt|;
name|b
operator|->
name|pos
operator|+=
name|source_len
expr_stmt|;
if|if
condition|(
name|target_len
operator|==
literal|0
condition|)
block|{
comment|/* No target data?  We're done; return the final window. */
if|if
condition|(
name|b
operator|->
name|context
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|b
operator|->
name|checksum
argument_list|,
name|b
operator|->
name|context
argument_list|,
name|b
operator|->
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|window
operator|=
name|NULL
expr_stmt|;
name|b
operator|->
name|more
operator|=
name|FALSE
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
elseif|else
if|if
condition|(
name|b
operator|->
name|context
operator|!=
name|NULL
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|b
operator|->
name|context
argument_list|,
name|b
operator|->
name|buf
operator|+
name|source_len
argument_list|,
name|target_len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|window
operator|=
name|compute_window
argument_list|(
name|b
operator|->
name|buf
argument_list|,
name|source_len
argument_list|,
name|target_len
argument_list|,
name|b
operator|->
name|pos
operator|-
name|source_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* That's it. */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|txdelta_md5_digest
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|txdelta_baton
modifier|*
name|b
init|=
name|baton
decl_stmt|;
comment|/* If there are more windows for this stream, the digest has not yet      been calculated.  */
if|if
condition|(
name|b
operator|->
name|more
condition|)
return|return
name|NULL
return|;
comment|/* If checksumming has not been activated, there will be no digest. */
if|if
condition|(
name|b
operator|->
name|context
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* The checksum should be there. */
return|return
name|b
operator|->
name|checksum
operator|->
name|digest
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_run
parameter_list|(
name|svn_stream_t
modifier|*
name|source
parameter_list|,
name|svn_stream_t
modifier|*
name|target
parameter_list|,
name|svn_txdelta_window_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|svn_checksum_kind_t
name|checksum_kind
parameter_list|,
name|svn_checksum_t
modifier|*
modifier|*
name|checksum
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|struct
name|txdelta_baton
name|tb
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
name|tb
operator|.
name|source
operator|=
name|source
expr_stmt|;
name|tb
operator|.
name|target
operator|=
name|target
expr_stmt|;
name|tb
operator|.
name|more_source
operator|=
name|TRUE
expr_stmt|;
name|tb
operator|.
name|more
operator|=
name|TRUE
expr_stmt|;
name|tb
operator|.
name|pos
operator|=
literal|0
expr_stmt|;
name|tb
operator|.
name|buf
operator|=
name|apr_palloc
argument_list|(
name|scratch_pool
argument_list|,
literal|2
operator|*
name|SVN_DELTA_WINDOW_SIZE
argument_list|)
expr_stmt|;
name|tb
operator|.
name|result_pool
operator|=
name|result_pool
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|NULL
condition|)
name|tb
operator|.
name|context
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|checksum_kind
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* free the window (if any) */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* read in a single delta window */
name|SVN_ERR
argument_list|(
name|txdelta_next_window
argument_list|(
operator|&
name|window
argument_list|,
operator|&
name|tb
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* shove it at the handler */
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|handler
call|)
argument_list|(
name|window
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cancel_func
condition|)
name|SVN_ERR
argument_list|(
name|cancel_func
argument_list|(
name|cancel_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|window
operator|!=
name|NULL
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|checksum
operator|!=
name|NULL
condition|)
operator|*
name|checksum
operator|=
name|tb
operator|.
name|checksum
expr_stmt|;
comment|/* should be there! */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_txdelta2
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_stream_t
modifier|*
name|source
parameter_list|,
name|svn_stream_t
modifier|*
name|target
parameter_list|,
name|svn_boolean_t
name|calculate_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|txdelta_baton
modifier|*
name|b
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|b
argument_list|)
argument_list|)
decl_stmt|;
name|b
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|b
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|b
operator|->
name|more_source
operator|=
name|TRUE
expr_stmt|;
name|b
operator|->
name|more
operator|=
name|TRUE
expr_stmt|;
name|b
operator|->
name|buf
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
literal|2
operator|*
name|SVN_DELTA_WINDOW_SIZE
argument_list|)
expr_stmt|;
name|b
operator|->
name|context
operator|=
name|calculate_checksum
condition|?
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
else|:
name|NULL
expr_stmt|;
name|b
operator|->
name|result_pool
operator|=
name|pool
expr_stmt|;
operator|*
name|stream
operator|=
name|svn_txdelta_stream_create
argument_list|(
name|b
argument_list|,
name|txdelta_next_window
argument_list|,
name|txdelta_md5_digest
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_txdelta
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
modifier|*
name|stream
parameter_list|,
name|svn_stream_t
modifier|*
name|source
parameter_list|,
name|svn_stream_t
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta2
argument_list|(
name|stream
argument_list|,
name|source
argument_list|,
name|target
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for implementing a "target push" delta. */
end_comment

begin_comment
comment|/* This is the write handler for a target-push delta stream.  It reads  * source data, buffers target data, and fires off delta windows when  * the target data buffer is full. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tpush_write_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|tpush_baton
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|chunk_len
decl_stmt|,
name|data_len
init|=
operator|*
name|len
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
init|=
name|svn_pool_create
argument_list|(
name|tb
operator|->
name|pool
argument_list|)
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
while|while
condition|(
name|data_len
operator|>
literal|0
condition|)
block|{
name|svn_pool_clear
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Make sure we're all full up on source data, if possible. */
if|if
condition|(
name|tb
operator|->
name|source_len
operator|==
literal|0
operator|&&
operator|!
name|tb
operator|->
name|source_done
condition|)
block|{
name|tb
operator|->
name|source_len
operator|=
name|SVN_DELTA_WINDOW_SIZE
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|tb
operator|->
name|source
argument_list|,
name|tb
operator|->
name|buf
argument_list|,
operator|&
name|tb
operator|->
name|source_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tb
operator|->
name|source_len
operator|<
name|SVN_DELTA_WINDOW_SIZE
condition|)
name|tb
operator|->
name|source_done
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* Copy in the target data, up to SVN_DELTA_WINDOW_SIZE. */
name|chunk_len
operator|=
name|SVN_DELTA_WINDOW_SIZE
operator|-
name|tb
operator|->
name|target_len
expr_stmt|;
if|if
condition|(
name|chunk_len
operator|>
name|data_len
condition|)
name|chunk_len
operator|=
name|data_len
expr_stmt|;
name|memcpy
argument_list|(
name|tb
operator|->
name|buf
operator|+
name|tb
operator|->
name|source_len
operator|+
name|tb
operator|->
name|target_len
argument_list|,
name|data
argument_list|,
name|chunk_len
argument_list|)
expr_stmt|;
name|data
operator|+=
name|chunk_len
expr_stmt|;
name|data_len
operator|-=
name|chunk_len
expr_stmt|;
name|tb
operator|->
name|target_len
operator|+=
name|chunk_len
expr_stmt|;
comment|/* If we're full of target data, compute and fire off a window. */
if|if
condition|(
name|tb
operator|->
name|target_len
operator|==
name|SVN_DELTA_WINDOW_SIZE
condition|)
block|{
name|window
operator|=
name|compute_window
argument_list|(
name|tb
operator|->
name|buf
argument_list|,
name|tb
operator|->
name|source_len
argument_list|,
name|tb
operator|->
name|target_len
argument_list|,
name|tb
operator|->
name|source_offset
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|tb
operator|->
name|wh
argument_list|(
name|window
argument_list|,
name|tb
operator|->
name|whb
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|source_offset
operator|+=
name|tb
operator|->
name|source_len
expr_stmt|;
name|tb
operator|->
name|source_len
operator|=
literal|0
expr_stmt|;
name|tb
operator|->
name|target_len
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This is the close handler for a target-push delta stream.  It sends  * a final window if there is any buffered target data, and then sends  * a NULL window signifying the end of the window stream. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|tpush_close_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|tpush_baton
modifier|*
name|tb
init|=
name|baton
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
comment|/* Send a final window if we have any residual target data. */
if|if
condition|(
name|tb
operator|->
name|target_len
operator|>
literal|0
condition|)
block|{
name|window
operator|=
name|compute_window
argument_list|(
name|tb
operator|->
name|buf
argument_list|,
name|tb
operator|->
name|source_len
argument_list|,
name|tb
operator|->
name|target_len
argument_list|,
name|tb
operator|->
name|source_offset
argument_list|,
name|tb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|tb
operator|->
name|wh
argument_list|(
name|window
argument_list|,
name|tb
operator|->
name|whb
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Send a final NULL window signifying the end. */
return|return
name|tb
operator|->
name|wh
argument_list|(
name|NULL
argument_list|,
name|tb
operator|->
name|whb
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_txdelta_target_push
parameter_list|(
name|svn_txdelta_window_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|svn_stream_t
modifier|*
name|source
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|tpush_baton
modifier|*
name|tb
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
comment|/* Initialize baton. */
name|tb
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tb
argument_list|)
argument_list|)
expr_stmt|;
name|tb
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|tb
operator|->
name|wh
operator|=
name|handler
expr_stmt|;
name|tb
operator|->
name|whb
operator|=
name|handler_baton
expr_stmt|;
name|tb
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|tb
operator|->
name|buf
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
literal|2
operator|*
name|SVN_DELTA_WINDOW_SIZE
argument_list|)
expr_stmt|;
name|tb
operator|->
name|source_offset
operator|=
literal|0
expr_stmt|;
name|tb
operator|->
name|source_len
operator|=
literal|0
expr_stmt|;
name|tb
operator|->
name|source_done
operator|=
name|FALSE
expr_stmt|;
name|tb
operator|->
name|target_len
operator|=
literal|0
expr_stmt|;
comment|/* Create and return writable stream. */
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|tb
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|tpush_write_handler
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|tpush_close_handler
argument_list|)
expr_stmt|;
return|return
name|stream
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Functions for applying deltas.  */
end_comment

begin_comment
comment|/* Ensure that BUF has enough space for VIEW_LEN bytes.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|svn_error_t
modifier|*
name|size_buffer
parameter_list|(
name|char
modifier|*
modifier|*
name|buf
parameter_list|,
name|apr_size_t
modifier|*
name|buf_size
parameter_list|,
name|apr_size_t
name|view_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|view_len
operator|>
operator|*
name|buf_size
condition|)
block|{
operator|*
name|buf_size
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|buf_size
operator|<
name|view_len
condition|)
operator|*
name|buf_size
operator|=
name|view_len
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|APR_ALIGN_DEFAULT
argument_list|(
operator|*
name|buf_size
argument_list|)
operator|>=
operator|*
name|buf_size
argument_list|)
expr_stmt|;
operator|*
name|buf
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
operator|*
name|buf_size
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from SOURCE to TARGET, optimizing for the case where LEN  * is often very small.  Return a pointer to the first byte after the copied  * target range, unlike standard memcpy(), as a potential further  * optimization for the caller.  *  * memcpy() is hard to tune for a wide range of buffer lengths.  Therefore,  * it is often tuned for high throughput on large buffers and relatively  * low latency for mid-sized buffers (tens of bytes).  However, the overhead  * for very small buffers (<10 bytes) is still high.  Even passing the  * parameters, for instance, may take as long as copying 3 bytes.  *  * Because short copy sequences seem to be a common case, at least in  * "format 2" FSFS repositories, we copy them directly.  Larger buffer sizes  * aren't hurt measurably by the exta 'if' clause.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|char
modifier|*
name|fast_memcpy
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
if|if
condition|(
name|len
operator|>
literal|7
condition|)
block|{
name|memcpy
argument_list|(
name|target
argument_list|,
name|source
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|target
operator|+=
name|len
expr_stmt|;
block|}
else|else
block|{
comment|/* memcpy is not exactly fast for small block sizes.        * Since they are common, let's run optimized code for them. */
specifier|const
name|char
modifier|*
name|end
init|=
name|source
operator|+
name|len
decl_stmt|;
for|for
control|(
init|;
name|source
operator|!=
name|end
condition|;
name|source
operator|++
control|)
operator|*
operator|(
name|target
operator|++
operator|)
operator|=
operator|*
name|source
expr_stmt|;
block|}
return|return
name|target
return|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes from SOURCE to TARGET.  Unlike memmove() or memcpy(),  * create repeating patterns if the source and target ranges overlap.  * Return a pointer to the first byte after the copied target range.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|char
modifier|*
name|patterning_copy
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
specifier|const
name|char
modifier|*
name|source
parameter_list|,
name|apr_size_t
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|end
init|=
name|source
operator|+
name|len
decl_stmt|;
comment|/* On many machines, we can do "chunky" copies. */
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
if|if
condition|(
name|end
operator|+
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
operator|<=
name|target
condition|)
block|{
comment|/* Source and target are at least 4 bytes apart, so we can copy in        * 4-byte chunks.  */
for|for
control|(
init|;
name|source
operator|+
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
operator|<=
name|end
condition|;
name|source
operator|+=
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
operator|,
name|target
operator|+=
sizeof|sizeof
argument_list|(
name|apr_uint32_t
argument_list|)
control|)
operator|*
operator|(
name|apr_uint32_t
operator|*
operator|)
operator|(
name|target
operator|)
operator|=
operator|*
operator|(
name|apr_uint32_t
operator|*
operator|)
operator|(
name|source
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* fall through to byte-wise copy (either for the below-chunk-size tail    * or the whole copy) */
for|for
control|(
init|;
name|source
operator|!=
name|end
condition|;
name|source
operator|++
control|)
operator|*
operator|(
name|target
operator|++
operator|)
operator|=
operator|*
name|source
expr_stmt|;
return|return
name|target
return|;
block|}
end_function

begin_function
name|void
name|svn_txdelta_apply_instructions
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
specifier|const
name|char
modifier|*
name|sbuf
parameter_list|,
name|char
modifier|*
name|tbuf
parameter_list|,
name|apr_size_t
modifier|*
name|tlen
parameter_list|)
block|{
specifier|const
name|svn_txdelta_op_t
modifier|*
name|op
decl_stmt|;
name|apr_size_t
name|tpos
init|=
literal|0
decl_stmt|;
for|for
control|(
name|op
operator|=
name|window
operator|->
name|ops
init|;
name|op
operator|<
name|window
operator|->
name|ops
operator|+
name|window
operator|->
name|num_ops
condition|;
name|op
operator|++
control|)
block|{
specifier|const
name|apr_size_t
name|buf_len
init|=
operator|(
name|op
operator|->
name|length
operator|<
operator|*
name|tlen
operator|-
name|tpos
condition|?
name|op
operator|->
name|length
else|:
operator|*
name|tlen
operator|-
name|tpos
operator|)
decl_stmt|;
comment|/* Check some invariants common to all instructions.  */
name|assert
argument_list|(
name|tpos
operator|+
name|op
operator|->
name|length
operator|<=
name|window
operator|->
name|tview_len
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|action_code
condition|)
block|{
case|case
name|svn_txdelta_source
case|:
comment|/* Copy from source area.  */
name|assert
argument_list|(
name|sbuf
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|op
operator|->
name|offset
operator|+
name|op
operator|->
name|length
operator|<=
name|window
operator|->
name|sview_len
argument_list|)
expr_stmt|;
name|fast_memcpy
argument_list|(
name|tbuf
operator|+
name|tpos
argument_list|,
name|sbuf
operator|+
name|op
operator|->
name|offset
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_txdelta_target
case|:
comment|/* Copy from target area.  We can't use memcpy() or the like            * since we need a specific semantics for overlapping copies:            * they must result in repeating patterns.            * Note that most copies won't have overlapping source and            * target ranges (they are just a result of self-compressed            * data) but a small percentage will.  */
name|assert
argument_list|(
name|op
operator|->
name|offset
operator|<
name|tpos
argument_list|)
expr_stmt|;
name|patterning_copy
argument_list|(
name|tbuf
operator|+
name|tpos
argument_list|,
name|tbuf
operator|+
name|op
operator|->
name|offset
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_txdelta_new
case|:
comment|/* Copy from window new area.  */
name|assert
argument_list|(
name|op
operator|->
name|offset
operator|+
name|op
operator|->
name|length
operator|<=
name|window
operator|->
name|new_data
operator|->
name|len
argument_list|)
expr_stmt|;
name|fast_memcpy
argument_list|(
name|tbuf
operator|+
name|tpos
argument_list|,
name|window
operator|->
name|new_data
operator|->
name|data
operator|+
name|op
operator|->
name|offset
argument_list|,
name|buf_len
argument_list|)
expr_stmt|;
break|break;
default|default:
name|assert
argument_list|(
operator|!
literal|"Invalid delta instruction code"
argument_list|)
expr_stmt|;
block|}
name|tpos
operator|+=
name|op
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|tpos
operator|>=
operator|*
name|tlen
condition|)
return|return;
comment|/* The buffer is full. */
block|}
comment|/* Check that we produced the right amount of data.  */
name|assert
argument_list|(
name|tpos
operator|==
name|window
operator|->
name|tview_len
argument_list|)
expr_stmt|;
operator|*
name|tlen
operator|=
name|tpos
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This is a private interlibrary compatibility wrapper. */
end_comment

begin_function_decl
name|void
name|svn_txdelta__apply_instructions
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
specifier|const
name|char
modifier|*
name|sbuf
parameter_list|,
name|char
modifier|*
name|tbuf
parameter_list|,
name|apr_size_t
modifier|*
name|tlen
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|svn_txdelta__apply_instructions
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
specifier|const
name|char
modifier|*
name|sbuf
parameter_list|,
name|char
modifier|*
name|tbuf
parameter_list|,
name|apr_size_t
modifier|*
name|tlen
parameter_list|)
block|{
name|svn_txdelta_apply_instructions
argument_list|(
name|window
argument_list|,
name|sbuf
argument_list|,
name|tbuf
argument_list|,
name|tlen
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Apply WINDOW to the streams given by APPL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|apply_baton
modifier|*
name|ab
init|=
operator|(
expr|struct
name|apply_baton
operator|*
operator|)
name|baton
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
if|if
condition|(
name|window
operator|==
name|NULL
condition|)
block|{
comment|/* We're done; just clean up.  */
if|if
condition|(
name|ab
operator|->
name|result_digest
condition|)
name|apr_md5_final
argument_list|(
name|ab
operator|->
name|result_digest
argument_list|,
operator|&
operator|(
name|ab
operator|->
name|md5_context
operator|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_stream_close
argument_list|(
name|ab
operator|->
name|target
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|ab
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
comment|/* Make sure the source view didn't slide backwards.  */
name|SVN_ERR_ASSERT
argument_list|(
name|window
operator|->
name|sview_len
operator|==
literal|0
operator|||
operator|(
name|window
operator|->
name|sview_offset
operator|>=
name|ab
operator|->
name|sbuf_offset
operator|&&
operator|(
name|window
operator|->
name|sview_offset
operator|+
name|window
operator|->
name|sview_len
operator|>=
name|ab
operator|->
name|sbuf_offset
operator|+
name|ab
operator|->
name|sbuf_len
operator|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Make sure there's enough room in the target buffer.  */
name|SVN_ERR
argument_list|(
name|size_buffer
argument_list|(
operator|&
name|ab
operator|->
name|tbuf
argument_list|,
operator|&
name|ab
operator|->
name|tbuf_size
argument_list|,
name|window
operator|->
name|tview_len
argument_list|,
name|ab
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Prepare the source buffer for reading from the input stream.  */
if|if
condition|(
name|window
operator|->
name|sview_offset
operator|!=
name|ab
operator|->
name|sbuf_offset
operator|||
name|window
operator|->
name|sview_len
operator|>
name|ab
operator|->
name|sbuf_size
condition|)
block|{
name|char
modifier|*
name|old_sbuf
init|=
name|ab
operator|->
name|sbuf
decl_stmt|;
comment|/* Make sure there's enough room.  */
name|SVN_ERR
argument_list|(
name|size_buffer
argument_list|(
operator|&
name|ab
operator|->
name|sbuf
argument_list|,
operator|&
name|ab
operator|->
name|sbuf_size
argument_list|,
name|window
operator|->
name|sview_len
argument_list|,
name|ab
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the existing view overlaps with the new view, copy the        * overlap to the beginning of the new buffer.  */
if|if
condition|(
operator|(
name|apr_size_t
operator|)
name|ab
operator|->
name|sbuf_offset
operator|+
name|ab
operator|->
name|sbuf_len
operator|>
operator|(
name|apr_size_t
operator|)
name|window
operator|->
name|sview_offset
condition|)
block|{
name|apr_size_t
name|start
init|=
call|(
name|apr_size_t
call|)
argument_list|(
name|window
operator|->
name|sview_offset
operator|-
name|ab
operator|->
name|sbuf_offset
argument_list|)
decl_stmt|;
name|memmove
argument_list|(
name|ab
operator|->
name|sbuf
argument_list|,
name|old_sbuf
operator|+
name|start
argument_list|,
name|ab
operator|->
name|sbuf_len
operator|-
name|start
argument_list|)
expr_stmt|;
name|ab
operator|->
name|sbuf_len
operator|-=
name|start
expr_stmt|;
block|}
else|else
name|ab
operator|->
name|sbuf_len
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|sbuf_offset
operator|=
name|window
operator|->
name|sview_offset
expr_stmt|;
block|}
comment|/* Read the remainder of the source view into the buffer.  */
if|if
condition|(
name|ab
operator|->
name|sbuf_len
operator|<
name|window
operator|->
name|sview_len
condition|)
block|{
name|len
operator|=
name|window
operator|->
name|sview_len
operator|-
name|ab
operator|->
name|sbuf_len
expr_stmt|;
name|err
operator|=
name|svn_stream_read
argument_list|(
name|ab
operator|->
name|source
argument_list|,
name|ab
operator|->
name|sbuf
operator|+
name|ab
operator|->
name|sbuf_len
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|SVN_NO_ERROR
operator|&&
name|len
operator|!=
name|window
operator|->
name|sview_len
operator|-
name|ab
operator|->
name|sbuf_len
condition|)
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_INCOMPLETE_DATA
argument_list|,
name|NULL
argument_list|,
literal|"Delta source ended unexpectedly"
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
name|SVN_NO_ERROR
condition|)
return|return
name|err
return|;
name|ab
operator|->
name|sbuf_len
operator|=
name|window
operator|->
name|sview_len
expr_stmt|;
block|}
comment|/* Apply the window instructions to the source view to generate      the target view.  */
name|len
operator|=
name|window
operator|->
name|tview_len
expr_stmt|;
name|svn_txdelta_apply_instructions
argument_list|(
name|window
argument_list|,
name|ab
operator|->
name|sbuf
argument_list|,
name|ab
operator|->
name|tbuf
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|len
operator|==
name|window
operator|->
name|tview_len
argument_list|)
expr_stmt|;
comment|/* Write out the output. */
comment|/* ### We've also considered just adding two (optionally null)      arguments to svn_stream_create(): read_checksum and      write_checksum.  Then instead of every caller updating an md5      context when it calls svn_stream_write() or svn_stream_read(),      streams would do it automatically, and verify the checksum in      svn_stream_closed().  But this might be overkill for issue #689;      so for now we just update the context here. */
if|if
condition|(
name|ab
operator|->
name|result_digest
condition|)
name|apr_md5_update
argument_list|(
operator|&
operator|(
name|ab
operator|->
name|md5_context
operator|)
argument_list|,
name|ab
operator|->
name|tbuf
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|svn_stream_write
argument_list|(
name|ab
operator|->
name|target
argument_list|,
name|ab
operator|->
name|tbuf
argument_list|,
operator|&
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|svn_txdelta_apply
parameter_list|(
name|svn_stream_t
modifier|*
name|source
parameter_list|,
name|svn_stream_t
modifier|*
name|target
parameter_list|,
name|unsigned
name|char
modifier|*
name|result_digest
parameter_list|,
specifier|const
name|char
modifier|*
name|error_info
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|struct
name|apply_baton
modifier|*
name|ab
decl_stmt|;
name|ab
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ab
argument_list|)
argument_list|)
expr_stmt|;
name|ab
operator|->
name|source
operator|=
name|source
expr_stmt|;
name|ab
operator|->
name|target
operator|=
name|target
expr_stmt|;
name|ab
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|ab
operator|->
name|sbuf
operator|=
name|NULL
expr_stmt|;
name|ab
operator|->
name|sbuf_size
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|sbuf_offset
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|sbuf_len
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|tbuf
operator|=
name|NULL
expr_stmt|;
name|ab
operator|->
name|tbuf_size
operator|=
literal|0
expr_stmt|;
name|ab
operator|->
name|result_digest
operator|=
name|result_digest
expr_stmt|;
if|if
condition|(
name|result_digest
condition|)
name|apr_md5_init
argument_list|(
operator|&
operator|(
name|ab
operator|->
name|md5_context
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error_info
condition|)
name|ab
operator|->
name|error_info
operator|=
name|apr_pstrdup
argument_list|(
name|subpool
argument_list|,
name|error_info
argument_list|)
expr_stmt|;
else|else
name|ab
operator|->
name|error_info
operator|=
name|NULL
expr_stmt|;
operator|*
name|handler
operator|=
name|apply_window
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|ab
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Convenience routines */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_send_string
parameter_list|(
specifier|const
name|svn_string_t
modifier|*
name|string
parameter_list|,
name|svn_txdelta_window_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_window_t
name|window
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_op_t
name|op
decl_stmt|;
comment|/* Build a single `new' op */
name|op
operator|.
name|action_code
operator|=
name|svn_txdelta_new
expr_stmt|;
name|op
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|op
operator|.
name|length
operator|=
name|string
operator|->
name|len
expr_stmt|;
comment|/* Build a single window containing a ptr to the string. */
name|window
operator|.
name|tview_len
operator|=
name|string
operator|->
name|len
expr_stmt|;
name|window
operator|.
name|num_ops
operator|=
literal|1
expr_stmt|;
name|window
operator|.
name|ops
operator|=
operator|&
name|op
expr_stmt|;
name|window
operator|.
name|new_data
operator|=
name|string
expr_stmt|;
comment|/* Push the one window at the handler. */
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|handler
call|)
argument_list|(
operator|&
name|window
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Push a NULL at the handler, because we're done. */
return|return
call|(
modifier|*
name|handler
call|)
argument_list|(
name|NULL
argument_list|,
name|handler_baton
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_send_stream
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_txdelta_window_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|unsigned
name|char
modifier|*
name|digest
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_window_t
name|delta_window
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_op_t
name|delta_op
decl_stmt|;
name|svn_string_t
name|window_data
decl_stmt|;
name|char
name|read_buf
index|[
name|SVN__STREAM_CHUNK_SIZE
operator|+
literal|1
index|]
decl_stmt|;
name|svn_checksum_ctx_t
modifier|*
name|md5_checksum_ctx
decl_stmt|;
if|if
condition|(
name|digest
condition|)
name|md5_checksum_ctx
operator|=
name|svn_checksum_ctx_create
argument_list|(
name|svn_checksum_md5
argument_list|,
name|pool
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|apr_size_t
name|read_len
init|=
name|SVN__STREAM_CHUNK_SIZE
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read
argument_list|(
name|stream
argument_list|,
name|read_buf
argument_list|,
operator|&
name|read_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_len
operator|==
literal|0
condition|)
break|break;
name|window_data
operator|.
name|data
operator|=
name|read_buf
expr_stmt|;
name|window_data
operator|.
name|len
operator|=
name|read_len
expr_stmt|;
name|delta_op
operator|.
name|action_code
operator|=
name|svn_txdelta_new
expr_stmt|;
name|delta_op
operator|.
name|offset
operator|=
literal|0
expr_stmt|;
name|delta_op
operator|.
name|length
operator|=
name|read_len
expr_stmt|;
name|delta_window
operator|.
name|tview_len
operator|=
name|read_len
expr_stmt|;
name|delta_window
operator|.
name|num_ops
operator|=
literal|1
expr_stmt|;
name|delta_window
operator|.
name|ops
operator|=
operator|&
name|delta_op
expr_stmt|;
name|delta_window
operator|.
name|new_data
operator|=
operator|&
name|window_data
expr_stmt|;
name|SVN_ERR
argument_list|(
name|handler
argument_list|(
operator|&
name|delta_window
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest
condition|)
name|SVN_ERR
argument_list|(
name|svn_checksum_update
argument_list|(
name|md5_checksum_ctx
argument_list|,
name|read_buf
argument_list|,
name|read_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read_len
operator|<
name|SVN__STREAM_CHUNK_SIZE
condition|)
break|break;
block|}
name|SVN_ERR
argument_list|(
name|handler
argument_list|(
name|NULL
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|digest
condition|)
block|{
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_checksum_final
argument_list|(
operator|&
name|md5_checksum
argument_list|,
name|md5_checksum_ctx
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|digest
argument_list|,
name|md5_checksum
operator|->
name|digest
argument_list|,
name|APR_MD5_DIGESTSIZE
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_send_txstream
parameter_list|(
name|svn_txdelta_stream_t
modifier|*
name|txstream
parameter_list|,
name|svn_txdelta_window_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_window_t
modifier|*
name|window
decl_stmt|;
comment|/* create a pool just for the windows */
name|apr_pool_t
modifier|*
name|wpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
do|do
block|{
comment|/* free the window (if any) */
name|svn_pool_clear
argument_list|(
name|wpool
argument_list|)
expr_stmt|;
comment|/* read in a single delta window */
name|SVN_ERR
argument_list|(
name|svn_txdelta_next_window
argument_list|(
operator|&
name|window
argument_list|,
name|txstream
argument_list|,
name|wpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* shove it at the handler */
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|handler
call|)
argument_list|(
name|window
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|window
operator|!=
name|NULL
condition|)
do|;
name|svn_pool_destroy
argument_list|(
name|wpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_send_contents
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|contents
parameter_list|,
name|apr_size_t
name|len
parameter_list|,
name|svn_txdelta_window_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_string_t
name|new_data
decl_stmt|;
name|svn_txdelta_op_t
name|op
init|=
block|{
name|svn_txdelta_new
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|svn_txdelta_window_t
name|window
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|}
decl_stmt|;
name|window
operator|.
name|ops
operator|=
operator|&
name|op
expr_stmt|;
name|window
operator|.
name|new_data
operator|=
operator|&
name|new_data
expr_stmt|;
comment|/* send CONTENT as a series of max-sized windows */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* stuff next chunk into the window */
name|window
operator|.
name|tview_len
operator|=
name|len
operator|<
name|SVN_DELTA_WINDOW_SIZE
condition|?
name|len
else|:
name|SVN_DELTA_WINDOW_SIZE
expr_stmt|;
name|op
operator|.
name|length
operator|=
name|window
operator|.
name|tview_len
expr_stmt|;
name|new_data
operator|.
name|len
operator|=
name|window
operator|.
name|tview_len
expr_stmt|;
name|new_data
operator|.
name|data
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|contents
expr_stmt|;
comment|/* update remaining */
name|contents
operator|+=
name|window
operator|.
name|tview_len
expr_stmt|;
name|len
operator|-=
name|window
operator|.
name|tview_len
expr_stmt|;
comment|/* shove it at the handler */
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|handler
call|)
argument_list|(
operator|&
name|window
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* indicate end of stream */
name|SVN_ERR
argument_list|(
call|(
modifier|*
name|handler
call|)
argument_list|(
name|NULL
argument_list|,
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

