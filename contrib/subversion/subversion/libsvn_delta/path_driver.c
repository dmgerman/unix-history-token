begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * path_driver.c -- drive an editor across a set of paths  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_pools.h>
end_include

begin_include
include|#
directive|include
file|<apr_strings.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_fspath.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_sorts_private.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Helper functions. ***/
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dir_stack_t
block|{
name|void
modifier|*
name|dir_baton
decl_stmt|;
comment|/* the dir baton. */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* the pool associated with the dir baton. */
block|}
name|dir_stack_t
typedef|;
end_typedef

begin_comment
comment|/* Call EDITOR's open_directory() function with the PATH argument, then  * add the resulting dir baton to the dir baton stack.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_dir
parameter_list|(
name|apr_array_header_t
modifier|*
name|db_stack
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|void
modifier|*
name|parent_db
decl_stmt|,
modifier|*
name|db
decl_stmt|;
name|dir_stack_t
modifier|*
name|item
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
comment|/* Assert that we are in a stable state. */
name|SVN_ERR_ASSERT
argument_list|(
name|db_stack
operator|&&
name|db_stack
operator|->
name|nelts
argument_list|)
expr_stmt|;
comment|/* Get the parent dir baton. */
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|db_stack
argument_list|,
name|db_stack
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|parent_db
operator|=
name|item
operator|->
name|dir_baton
expr_stmt|;
comment|/* Call the EDITOR's open_directory function to get a new directory      baton. */
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_directory
argument_list|(
name|path
argument_list|,
name|parent_db
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|subpool
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now add the dir baton to the stack. */
name|item
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|dir_baton
operator|=
name|db
expr_stmt|;
name|item
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|db_stack
argument_list|,
name|dir_stack_t
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Pop a directory from the dir baton stack and update the stack  * pointer.  *  * This function calls the EDITOR's close_directory() function.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|pop_stack
parameter_list|(
name|apr_array_header_t
modifier|*
name|db_stack
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|)
block|{
name|dir_stack_t
modifier|*
name|item
decl_stmt|;
comment|/* Assert that we are in a stable state. */
name|SVN_ERR_ASSERT
argument_list|(
name|db_stack
operator|&&
name|db_stack
operator|->
name|nelts
argument_list|)
expr_stmt|;
comment|/* Close the most recent directory pushed to the stack. */
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|db_stack
argument_list|,
name|db_stack
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|dir_stack_t
operator|*
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|apr_array_pop
argument_list|(
name|db_stack
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|close_directory
argument_list|(
name|item
operator|->
name|dir_baton
argument_list|,
name|item
operator|->
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|item
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Count the number of path components in PATH. */
end_comment

begin_function
specifier|static
name|int
name|count_components
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|instance
init|=
name|path
decl_stmt|;
if|if
condition|(
operator|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|==
literal|1
operator|)
operator|&&
operator|(
name|path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
literal|0
return|;
do|do
block|{
name|instance
operator|++
expr_stmt|;
name|instance
operator|=
name|strchr
argument_list|(
name|instance
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|instance
condition|)
name|count
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|instance
condition|)
do|;
return|return
name|count
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*** Public interfaces ***/
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_delta_path_driver2
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
name|editor
parameter_list|,
name|void
modifier|*
name|edit_baton
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|paths
parameter_list|,
name|svn_boolean_t
name|sort_paths
parameter_list|,
name|svn_delta_path_driver_cb_func_t
name|callback_func
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|db_stack
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|4
argument_list|,
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|last_path
init|=
name|NULL
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
name|void
modifier|*
name|parent_db
init|=
name|NULL
decl_stmt|,
modifier|*
name|db
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|,
modifier|*
name|iterpool
decl_stmt|;
name|dir_stack_t
modifier|*
name|item
decl_stmt|;
comment|/* Do nothing if there are no paths. */
if|if
condition|(
operator|!
name|paths
operator|->
name|nelts
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* sort paths if necessary */
if|if
condition|(
name|sort_paths
operator|&&
name|paths
operator|->
name|nelts
operator|>
literal|1
condition|)
block|{
name|apr_array_header_t
modifier|*
name|sorted
init|=
name|apr_array_copy
argument_list|(
name|subpool
argument_list|,
name|paths
argument_list|)
decl_stmt|;
name|svn_sort__array
argument_list|(
name|sorted
argument_list|,
name|svn_sort_compare_paths
argument_list|)
expr_stmt|;
name|paths
operator|=
name|sorted
expr_stmt|;
block|}
name|item
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If the root of the edit is also a target path, we want to call      the callback function to let the user open the root directory and      do what needs to be done.  Otherwise, we'll do the open_root()      ourselves. */
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_empty
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|callback_func
argument_list|(
operator|&
name|db
argument_list|,
name|NULL
argument_list|,
name|callback_baton
argument_list|,
name|path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
name|last_path
operator|=
name|path
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|editor
operator|->
name|open_root
argument_list|(
name|edit_baton
argument_list|,
name|SVN_INVALID_REVNUM
argument_list|,
name|subpool
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|item
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|item
operator|->
name|dir_baton
operator|=
name|db
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|db_stack
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
comment|/* Now, loop over the commit items, traversing the URL tree and      driving the editor. */
for|for
control|(
init|;
name|i
operator|<
name|paths
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|pdir
decl_stmt|;
specifier|const
name|char
modifier|*
name|common
init|=
literal|""
decl_stmt|;
name|size_t
name|common_len
decl_stmt|;
comment|/* Clear the iteration pool. */
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Get the next path. */
name|path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/*** Step A - Find the common ancestor of the last path and the            current one.  For the first iteration, this is just the            empty string. ***/
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|common
operator|=
operator|(
name|last_path
index|[
literal|0
index|]
operator|==
literal|'/'
operator|)
condition|?
name|svn_fspath__get_longest_ancestor
argument_list|(
name|last_path
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
else|:
name|svn_relpath_get_longest_ancestor
argument_list|(
name|last_path
argument_list|,
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
name|common_len
operator|=
name|strlen
argument_list|(
name|common
argument_list|)
expr_stmt|;
comment|/*** Step B - Close any directories between the last path and            the new common ancestor, if any need to be closed.            Sometimes there is nothing to do here (like, for the first            iteration, or when the last path was an ancestor of the            current one). ***/
if|if
condition|(
operator|(
name|i
operator|>
literal|0
operator|)
operator|&&
operator|(
name|strlen
argument_list|(
name|last_path
argument_list|)
operator|>
name|common_len
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|rel
init|=
name|last_path
operator|+
operator|(
name|common_len
condition|?
operator|(
name|common_len
operator|+
literal|1
operator|)
else|:
literal|0
operator|)
decl_stmt|;
name|int
name|count
init|=
name|count_components
argument_list|(
name|rel
argument_list|)
decl_stmt|;
while|while
condition|(
name|count
operator|--
condition|)
block|{
name|SVN_ERR
argument_list|(
name|pop_stack
argument_list|(
name|db_stack
argument_list|,
name|editor
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/*** Step C - Open any directories between the common ancestor            and the parent of the current path. ***/
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
name|pdir
operator|=
name|svn_fspath__dirname
argument_list|(
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
else|else
name|pdir
operator|=
name|svn_relpath_dirname
argument_list|(
name|path
argument_list|,
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|pdir
argument_list|)
operator|>
name|common_len
condition|)
block|{
specifier|const
name|char
modifier|*
name|piece
init|=
name|pdir
operator|+
name|common_len
operator|+
literal|1
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|rel
init|=
name|pdir
decl_stmt|;
comment|/* Find the first separator. */
name|piece
operator|=
name|strchr
argument_list|(
name|piece
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Calculate REL as the portion of PDIR up to (but not                  including) the location to which PIECE is pointing. */
if|if
condition|(
name|piece
condition|)
name|rel
operator|=
name|apr_pstrmemdup
argument_list|(
name|iterpool
argument_list|,
name|pdir
argument_list|,
name|piece
operator|-
name|pdir
argument_list|)
expr_stmt|;
comment|/* Open the subdirectory. */
name|SVN_ERR
argument_list|(
name|open_dir
argument_list|(
name|db_stack
argument_list|,
name|editor
argument_list|,
name|rel
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we found a '/', advance our PIECE pointer to                  character just after that '/'.  Otherwise, we're                  done.  */
if|if
condition|(
name|piece
condition|)
name|piece
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
comment|/*** Step D - Tell our caller to handle the current path. ***/
name|item
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|db_stack
argument_list|,
name|db_stack
operator|->
name|nelts
operator|-
literal|1
argument_list|,
name|void
operator|*
argument_list|)
expr_stmt|;
name|parent_db
operator|=
name|item
operator|->
name|dir_baton
expr_stmt|;
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|callback_func
argument_list|(
operator|&
name|db
argument_list|,
name|parent_db
argument_list|,
name|callback_baton
argument_list|,
name|path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
condition|)
block|{
name|item
operator|=
name|apr_pcalloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|item
argument_list|)
argument_list|)
expr_stmt|;
name|item
operator|->
name|dir_baton
operator|=
name|db
expr_stmt|;
name|item
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|db_stack
argument_list|,
name|void
operator|*
argument_list|)
operator|=
name|item
expr_stmt|;
block|}
else|else
block|{
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/*** Step E - Save our state for the next iteration.  If our            caller opened or added PATH as a directory, that becomes            our LAST_PATH.  Otherwise, we use PATH's parent            directory. ***/
comment|/* NOTE:  The variable LAST_PATH needs to outlive the loop. */
if|if
condition|(
name|db
condition|)
name|last_path
operator|=
name|path
expr_stmt|;
comment|/* lives in a pool outside our control. */
else|else
name|last_path
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|pdir
argument_list|)
expr_stmt|;
comment|/* duping into POOL. */
block|}
comment|/* Destroy the iteration subpool. */
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
comment|/* Close down any remaining open directory batons. */
while|while
condition|(
name|db_stack
operator|->
name|nelts
condition|)
block|{
name|SVN_ERR
argument_list|(
name|pop_stack
argument_list|(
name|db_stack
argument_list|,
name|editor
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

