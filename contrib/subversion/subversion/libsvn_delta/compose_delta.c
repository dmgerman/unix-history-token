begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * compose_delta.c:  Delta window composition.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* For APR_INLINE */
end_comment

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"delta.h"
end_include

begin_comment
comment|/* Define a MIN macro if this platform doesn't already have one. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MIN
end_ifndef

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/* Support for efficient small-block allocation from pools. */
end_comment

begin_comment
comment|/* The following structs will be allocated and freed often: */
end_comment

begin_comment
comment|/* A node in the range index tree. */
end_comment

begin_typedef
typedef|typedef
name|struct
name|range_index_node_t
name|range_index_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|range_index_node_t
block|{
comment|/* 'offset' and 'limit' define the range in the source window. */
name|apr_size_t
name|offset
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
comment|/* 'target_offset' is where that range is represented in the target. */
name|apr_size_t
name|target_offset
decl_stmt|;
comment|/* 'left' and 'right' link the node into a splay tree. */
name|range_index_node_t
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
comment|/* 'prev' and 'next' link it into an ordered, doubly-linked list. */
name|range_index_node_t
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A node in a list of ranges for source and target op copies. */
end_comment

begin_enum
enum|enum
name|range_kind
block|{
name|range_from_source
block|,
name|range_from_target
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|struct
name|range_list_node_t
name|range_list_node_t
typedef|;
end_typedef

begin_struct
struct|struct
name|range_list_node_t
block|{
comment|/* Where does the range come from?      'offset' and 'limit' always refer to the "virtual" source data      for the second delta window. For a target range, the actual      offset to use for generating the target op is 'target_offset';      that field isn't used by source ranges. */
name|enum
name|range_kind
name|kind
decl_stmt|;
comment|/* 'offset' and 'limit' define the range. */
name|apr_size_t
name|offset
decl_stmt|;
name|apr_size_t
name|limit
decl_stmt|;
comment|/* 'target_offset' is the start of the range in the target. */
name|apr_size_t
name|target_offset
decl_stmt|;
comment|/* 'prev' and 'next' link the node into an ordered, doubly-linked list. */
name|range_list_node_t
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is what will be allocated: */
end_comment

begin_typedef
typedef|typedef
name|union
name|alloc_block_t
name|alloc_block_t
typedef|;
end_typedef

begin_union
union|union
name|alloc_block_t
block|{
name|range_index_node_t
name|index_node
decl_stmt|;
name|range_list_node_t
name|list_node
decl_stmt|;
comment|/* Links free blocks into a freelist. */
name|alloc_block_t
modifier|*
name|next_free
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* Allocate a block. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
modifier|*
name|alloc_block
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|alloc_block_t
modifier|*
modifier|*
name|free_list
parameter_list|)
block|{
name|alloc_block_t
modifier|*
name|block
decl_stmt|;
if|if
condition|(
operator|*
name|free_list
operator|==
name|NULL
condition|)
name|block
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|block
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|block
operator|=
operator|*
name|free_list
expr_stmt|;
operator|*
name|free_list
operator|=
name|block
operator|->
name|next_free
expr_stmt|;
block|}
return|return
name|block
return|;
block|}
end_function

begin_comment
comment|/* Return the block back to the free list. */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|void
name|free_block
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|alloc_block_t
modifier|*
modifier|*
name|free_list
parameter_list|)
block|{
comment|/* Wrapper functions take care of type safety. */
name|alloc_block_t
modifier|*
specifier|const
name|block
init|=
name|ptr
decl_stmt|;
name|block
operator|->
name|next_free
operator|=
operator|*
name|free_list
expr_stmt|;
operator|*
name|free_list
operator|=
name|block
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/* Mapping offsets in the target streem to txdelta ops. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|offset_index_t
block|{
name|int
name|length
decl_stmt|;
name|apr_size_t
modifier|*
name|offs
decl_stmt|;
block|}
name|offset_index_t
typedef|;
end_typedef

begin_comment
comment|/* Create an index mapping target stream offsets to delta ops in    WINDOW. Allocate from POOL. */
end_comment

begin_function
specifier|static
name|offset_index_t
modifier|*
name|create_offset_index
parameter_list|(
specifier|const
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|offset_index_t
modifier|*
name|ndx
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndx
argument_list|)
argument_list|)
decl_stmt|;
name|apr_size_t
name|offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ndx
operator|->
name|length
operator|=
name|window
operator|->
name|num_ops
expr_stmt|;
name|ndx
operator|->
name|offs
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
operator|(
name|ndx
operator|->
name|length
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ndx
operator|->
name|offs
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndx
operator|->
name|length
condition|;
operator|++
name|i
control|)
block|{
name|ndx
operator|->
name|offs
index|[
name|i
index|]
operator|=
name|offset
expr_stmt|;
name|offset
operator|+=
name|window
operator|->
name|ops
index|[
name|i
index|]
operator|.
name|length
expr_stmt|;
block|}
name|ndx
operator|->
name|offs
index|[
name|ndx
operator|->
name|length
index|]
operator|=
name|offset
expr_stmt|;
return|return
name|ndx
return|;
block|}
end_function

begin_comment
comment|/* Find the index of the delta op thet defines that data at OFFSET in    NDX. HINT is an arbitrary positin within NDX and doesn't even need    to be valid. To effectively speed up the search, use the last result    as hint because most lookups come as a sequence of decreasing values    for OFFSET and they concentrate on the lower end of the array. */
end_comment

begin_function
specifier|static
name|apr_size_t
name|search_offset_index
parameter_list|(
specifier|const
name|offset_index_t
modifier|*
name|ndx
parameter_list|,
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
name|hint
parameter_list|)
block|{
name|apr_size_t
name|lo
decl_stmt|,
name|hi
decl_stmt|,
name|op
decl_stmt|;
name|assert
argument_list|(
name|offset
operator|<
name|ndx
operator|->
name|offs
index|[
name|ndx
operator|->
name|length
index|]
argument_list|)
expr_stmt|;
name|lo
operator|=
literal|0
expr_stmt|;
name|hi
operator|=
name|ndx
operator|->
name|length
expr_stmt|;
comment|/* If we got a valid hint, use it to reduce the range to cover.      Note that this will only be useful if either the hint is a      hit (i.e. equals the desired result) or narrows the range      length by a factor larger than 2. */
if|if
condition|(
name|hint
operator|<
name|hi
condition|)
block|{
if|if
condition|(
name|offset
operator|<
name|ndx
operator|->
name|offs
index|[
name|hint
index|]
condition|)
name|hi
operator|=
name|hint
expr_stmt|;
elseif|else
if|if
condition|(
name|offset
operator|<
name|ndx
operator|->
name|offs
index|[
name|hint
operator|+
literal|1
index|]
condition|)
return|return
name|hint
return|;
else|else
name|lo
operator|=
name|hint
operator|+
literal|1
expr_stmt|;
block|}
comment|/* ordinary binary search */
for|for
control|(
name|op
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
init|;
name|lo
operator|!=
name|hi
condition|;
name|op
operator|=
operator|(
name|lo
operator|+
name|hi
operator|)
operator|/
literal|2
control|)
block|{
if|if
condition|(
name|offset
operator|<
name|ndx
operator|->
name|offs
index|[
name|op
index|]
condition|)
name|hi
operator|=
name|op
expr_stmt|;
else|else
name|lo
operator|=
operator|++
name|op
expr_stmt|;
block|}
operator|--
name|lo
expr_stmt|;
name|assert
argument_list|(
name|ndx
operator|->
name|offs
index|[
name|lo
index|]
operator|<=
name|offset
operator|&&
name|offset
operator|<
name|ndx
operator|->
name|offs
index|[
name|lo
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|lo
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/* Mapping ranges in the source stream to ranges in the composed delta. */
end_comment

begin_comment
comment|/* The range index tree. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|range_index_t
block|{
name|range_index_node_t
modifier|*
name|tree
decl_stmt|;
name|alloc_block_t
modifier|*
name|free_list
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
name|range_index_t
typedef|;
end_typedef

begin_comment
comment|/* Create a range index tree. Allocate from POOL. */
end_comment

begin_function
specifier|static
name|range_index_t
modifier|*
name|create_range_index
parameter_list|(
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|range_index_t
modifier|*
name|ndx
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ndx
argument_list|)
argument_list|)
decl_stmt|;
name|ndx
operator|->
name|tree
operator|=
name|NULL
expr_stmt|;
name|ndx
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|ndx
operator|->
name|free_list
operator|=
name|NULL
expr_stmt|;
return|return
name|ndx
return|;
block|}
end_function

begin_comment
comment|/* Allocate a node for the range index tree. */
end_comment

begin_function
specifier|static
name|range_index_node_t
modifier|*
name|alloc_range_index_node
parameter_list|(
name|range_index_t
modifier|*
name|ndx
parameter_list|,
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
name|limit
parameter_list|,
name|apr_size_t
name|target_offset
parameter_list|)
block|{
name|range_index_node_t
modifier|*
specifier|const
name|node
init|=
name|alloc_block
argument_list|(
name|ndx
operator|->
name|pool
argument_list|,
operator|&
name|ndx
operator|->
name|free_list
argument_list|)
decl_stmt|;
name|node
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|node
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|node
operator|->
name|target_offset
operator|=
name|target_offset
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|node
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|prev
operator|=
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|node
return|;
block|}
end_function

begin_comment
comment|/* Free a node from the range index tree. */
end_comment

begin_function
specifier|static
name|void
name|free_range_index_node
parameter_list|(
name|range_index_t
modifier|*
name|ndx
parameter_list|,
name|range_index_node_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|->
name|next
condition|)
name|node
operator|->
name|next
operator|->
name|prev
operator|=
name|node
operator|->
name|prev
expr_stmt|;
if|if
condition|(
name|node
operator|->
name|prev
condition|)
name|node
operator|->
name|prev
operator|->
name|next
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|free_block
argument_list|(
name|node
argument_list|,
operator|&
name|ndx
operator|->
name|free_list
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Splay the index tree, using OFFSET as the key. */
end_comment

begin_function
specifier|static
name|void
name|splay_range_index
parameter_list|(
name|apr_size_t
name|offset
parameter_list|,
name|range_index_t
modifier|*
name|ndx
parameter_list|)
block|{
name|range_index_node_t
modifier|*
name|tree
init|=
name|ndx
operator|->
name|tree
decl_stmt|;
name|range_index_node_t
name|scratch_node
decl_stmt|;
name|range_index_node_t
modifier|*
name|left
decl_stmt|,
modifier|*
name|right
decl_stmt|;
if|if
condition|(
name|tree
operator|==
name|NULL
condition|)
return|return;
name|scratch_node
operator|.
name|left
operator|=
name|scratch_node
operator|.
name|right
operator|=
name|NULL
expr_stmt|;
name|left
operator|=
name|right
operator|=
operator|&
name|scratch_node
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|offset
operator|<
name|tree
operator|->
name|offset
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|left
operator|!=
name|NULL
operator|&&
name|offset
operator|<
name|tree
operator|->
name|left
operator|->
name|offset
condition|)
block|{
comment|/* Right rotation */
name|range_index_node_t
modifier|*
specifier|const
name|node
init|=
name|tree
operator|->
name|left
decl_stmt|;
name|tree
operator|->
name|left
operator|=
name|node
operator|->
name|right
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|tree
expr_stmt|;
name|tree
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|left
operator|==
name|NULL
condition|)
break|break;
comment|/* Remember the right subtree */
name|right
operator|->
name|left
operator|=
name|tree
expr_stmt|;
name|right
operator|=
name|tree
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|left
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
name|tree
operator|->
name|offset
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|right
operator|!=
name|NULL
operator|&&
name|offset
operator|>
name|tree
operator|->
name|right
operator|->
name|offset
condition|)
block|{
comment|/* Left rotation */
name|range_index_node_t
modifier|*
specifier|const
name|node
init|=
name|tree
operator|->
name|right
decl_stmt|;
name|tree
operator|->
name|right
operator|=
name|node
operator|->
name|left
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|tree
expr_stmt|;
name|tree
operator|=
name|node
expr_stmt|;
block|}
if|if
condition|(
name|tree
operator|->
name|right
operator|==
name|NULL
condition|)
break|break;
comment|/* Remember the left subtree */
name|left
operator|->
name|right
operator|=
name|tree
expr_stmt|;
name|left
operator|=
name|tree
expr_stmt|;
name|tree
operator|=
name|tree
operator|->
name|right
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Link in the left and right subtrees */
name|left
operator|->
name|right
operator|=
name|tree
operator|->
name|left
expr_stmt|;
name|right
operator|->
name|left
operator|=
name|tree
operator|->
name|right
expr_stmt|;
name|tree
operator|->
name|left
operator|=
name|scratch_node
operator|.
name|right
expr_stmt|;
name|tree
operator|->
name|right
operator|=
name|scratch_node
operator|.
name|left
expr_stmt|;
comment|/* The basic top-down splay is finished, but we may still need to      turn the tree around. What we want is to put the node with the      largest offset where node->offset<= offset at the top of the      tree, so that we can insert the new data (or search for existing      ranges) to the right of the root. This makes cleaning up the      tree after an insert much simpler, and -- incidentally -- makes      the whole range index magic work. */
if|if
condition|(
name|offset
operator|<
name|tree
operator|->
name|offset
operator|&&
name|tree
operator|->
name|left
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|tree
operator|->
name|left
operator|->
name|right
operator|==
name|NULL
condition|)
block|{
comment|/* A single right rotation is enough. */
name|range_index_node_t
modifier|*
specifier|const
name|node
init|=
name|tree
operator|->
name|left
decl_stmt|;
name|tree
operator|->
name|left
operator|=
name|node
operator|->
name|right
expr_stmt|;
comment|/* Which is always NULL. */
name|node
operator|->
name|right
operator|=
name|tree
expr_stmt|;
name|tree
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
comment|/* Slide down to the rightmost node in the left subtree. */
name|range_index_node_t
modifier|*
modifier|*
name|nodep
init|=
operator|&
name|tree
operator|->
name|left
decl_stmt|;
while|while
condition|(
operator|(
operator|*
name|nodep
operator|)
operator|->
name|right
operator|!=
name|NULL
condition|)
name|nodep
operator|=
operator|&
operator|(
operator|*
name|nodep
operator|)
operator|->
name|right
expr_stmt|;
comment|/* Now move this node to root in one giant promotion. */
name|right
operator|=
name|tree
expr_stmt|;
name|left
operator|=
name|tree
operator|->
name|left
expr_stmt|;
name|tree
operator|=
operator|*
name|nodep
expr_stmt|;
operator|*
name|nodep
operator|=
name|tree
operator|->
name|left
expr_stmt|;
name|right
operator|->
name|left
operator|=
name|tree
operator|->
name|right
expr_stmt|;
comment|/* Which is always NULL, too. */
name|tree
operator|->
name|left
operator|=
name|left
expr_stmt|;
name|tree
operator|->
name|right
operator|=
name|right
expr_stmt|;
block|}
block|}
comment|/* Sanity check ... */
name|assert
argument_list|(
operator|(
name|offset
operator|>=
name|tree
operator|->
name|offset
operator|)
operator|||
operator|(
operator|(
name|tree
operator|->
name|left
operator|==
name|NULL
operator|)
operator|&&
operator|(
name|tree
operator|->
name|prev
operator|==
name|NULL
operator|)
operator|)
argument_list|)
expr_stmt|;
name|ndx
operator|->
name|tree
operator|=
name|tree
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Remove all ranges from NDX that fall into the root's range.  To    keep the range index as small as possible, we must also remove    nodes that don't fall into the new range, but have become redundant    because the new range overlaps the beginning of the next range.    Like this:         new-range: |-----------------|          range-1:         |-----------------|          range-2:                |--------------------|     Before new-range was inserted, range-1 and range-2 were both    necessary. Now the union of new-range and range-2 completely covers    range-1, which has become redundant now.     FIXME: But, of course, there's a catch. range-1 must still remain    in the tree if we want to optimize the number of target copy ops in    the case were a copy falls within range-1, but starts before    range-2 and ends after new-range. */
end_comment

begin_function
specifier|static
name|void
name|delete_subtree
parameter_list|(
name|range_index_t
modifier|*
name|ndx
parameter_list|,
name|range_index_node_t
modifier|*
name|node
parameter_list|)
block|{
if|if
condition|(
name|node
operator|!=
name|NULL
condition|)
block|{
name|delete_subtree
argument_list|(
name|ndx
argument_list|,
name|node
operator|->
name|left
argument_list|)
expr_stmt|;
name|delete_subtree
argument_list|(
name|ndx
argument_list|,
name|node
operator|->
name|right
argument_list|)
expr_stmt|;
name|free_range_index_node
argument_list|(
name|ndx
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|clean_tree
parameter_list|(
name|range_index_t
modifier|*
name|ndx
parameter_list|,
name|apr_size_t
name|limit
parameter_list|)
block|{
name|apr_size_t
name|top_offset
init|=
name|limit
operator|+
literal|1
decl_stmt|;
name|range_index_node_t
modifier|*
modifier|*
name|nodep
init|=
operator|&
name|ndx
operator|->
name|tree
operator|->
name|right
decl_stmt|;
while|while
condition|(
operator|*
name|nodep
operator|!=
name|NULL
condition|)
block|{
name|range_index_node_t
modifier|*
specifier|const
name|node
init|=
operator|*
name|nodep
decl_stmt|;
name|apr_size_t
specifier|const
name|offset
init|=
operator|(
name|node
operator|->
name|right
operator|!=
name|NULL
operator|&&
name|node
operator|->
name|right
operator|->
name|offset
operator|<
name|top_offset
condition|?
name|node
operator|->
name|right
operator|->
name|offset
else|:
name|top_offset
operator|)
decl_stmt|;
if|if
condition|(
name|node
operator|->
name|limit
operator|<=
name|limit
operator|||
operator|(
name|node
operator|->
name|offset
operator|<
name|limit
operator|&&
name|offset
operator|<
name|limit
operator|)
condition|)
block|{
operator|*
name|nodep
operator|=
name|node
operator|->
name|right
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|delete_subtree
argument_list|(
name|ndx
argument_list|,
name|node
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|top_offset
operator|=
name|node
operator|->
name|offset
expr_stmt|;
name|nodep
operator|=
operator|&
name|node
operator|->
name|left
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Add a range [OFFSET, LIMIT) into NDX. If NDX already contains a    range that encloses [OFFSET, LIMIT), do nothing. Otherwise, remove    all ranges from NDX that are superseded by the new range.    NOTE: The range index must be splayed to OFFSET! */
end_comment

begin_function
specifier|static
name|void
name|insert_range
parameter_list|(
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
name|limit
parameter_list|,
name|apr_size_t
name|target_offset
parameter_list|,
name|range_index_t
modifier|*
name|ndx
parameter_list|)
block|{
name|range_index_node_t
modifier|*
name|node
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|ndx
operator|->
name|tree
operator|==
name|NULL
condition|)
block|{
name|node
operator|=
name|alloc_range_index_node
argument_list|(
name|ndx
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
name|ndx
operator|->
name|tree
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|offset
operator|==
name|ndx
operator|->
name|tree
operator|->
name|offset
operator|&&
name|limit
operator|>
name|ndx
operator|->
name|tree
operator|->
name|limit
condition|)
block|{
name|ndx
operator|->
name|tree
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|ndx
operator|->
name|tree
operator|->
name|target_offset
operator|=
name|target_offset
expr_stmt|;
name|clean_tree
argument_list|(
name|ndx
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|>
name|ndx
operator|->
name|tree
operator|->
name|offset
operator|&&
name|limit
operator|>
name|ndx
operator|->
name|tree
operator|->
name|limit
condition|)
block|{
comment|/* We have to make the same sort of checks as clean_tree()              does for superseded ranges. Have to merge these someday. */
specifier|const
name|svn_boolean_t
name|insert_range_p
init|=
operator|(
operator|!
name|ndx
operator|->
name|tree
operator|->
name|next
operator|||
name|ndx
operator|->
name|tree
operator|->
name|limit
operator|<
name|ndx
operator|->
name|tree
operator|->
name|next
operator|->
name|offset
operator|||
name|limit
operator|>
name|ndx
operator|->
name|tree
operator|->
name|next
operator|->
name|limit
operator|)
decl_stmt|;
if|if
condition|(
name|insert_range_p
condition|)
block|{
comment|/* Again, we have to check if the new node and the one                  to the left of the root override root's range. */
if|if
condition|(
name|ndx
operator|->
name|tree
operator|->
name|prev
operator|&&
name|ndx
operator|->
name|tree
operator|->
name|prev
operator|->
name|limit
operator|>
name|offset
condition|)
block|{
comment|/* Replace the data in the splayed node. */
name|ndx
operator|->
name|tree
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|ndx
operator|->
name|tree
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|ndx
operator|->
name|tree
operator|->
name|target_offset
operator|=
name|target_offset
expr_stmt|;
block|}
else|else
block|{
comment|/* Insert the range to the right of the splayed node. */
name|node
operator|=
name|alloc_range_index_node
argument_list|(
name|ndx
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|node
operator|->
name|next
operator|=
name|ndx
operator|->
name|tree
operator|->
name|next
operator|)
operator|!=
name|NULL
condition|)
name|node
operator|->
name|next
operator|->
name|prev
operator|=
name|node
expr_stmt|;
name|ndx
operator|->
name|tree
operator|->
name|next
operator|=
name|node
expr_stmt|;
name|node
operator|->
name|prev
operator|=
name|ndx
operator|->
name|tree
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|ndx
operator|->
name|tree
operator|->
name|right
expr_stmt|;
name|ndx
operator|->
name|tree
operator|->
name|right
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|ndx
operator|->
name|tree
expr_stmt|;
name|ndx
operator|->
name|tree
operator|=
name|node
expr_stmt|;
block|}
name|clean_tree
argument_list|(
name|ndx
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Ignore the range */
empty_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|<
name|ndx
operator|->
name|tree
operator|->
name|offset
condition|)
block|{
name|assert
argument_list|(
name|ndx
operator|->
name|tree
operator|->
name|left
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* Insert the range left of the splayed node */
name|node
operator|=
name|alloc_range_index_node
argument_list|(
name|ndx
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
name|node
operator|->
name|left
operator|=
name|node
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
name|node
operator|->
name|right
operator|=
name|node
operator|->
name|next
operator|=
name|ndx
operator|->
name|tree
expr_stmt|;
name|ndx
operator|->
name|tree
operator|=
name|node
operator|->
name|next
operator|->
name|prev
operator|=
name|node
expr_stmt|;
name|clean_tree
argument_list|(
name|ndx
argument_list|,
name|limit
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Ignore the range */
empty_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/* Juggling with lists of ranges. */
end_comment

begin_comment
comment|/* Allocate a node and add it to the range list. LIST is the head of    the range list, TAIL is the last node in the list. NDX holds the    freelist; OFFSET, LIMIT and KIND are node data. */
end_comment

begin_function
specifier|static
name|range_list_node_t
modifier|*
name|alloc_range_list
parameter_list|(
name|range_list_node_t
modifier|*
modifier|*
name|list
parameter_list|,
name|range_list_node_t
modifier|*
modifier|*
name|tail
parameter_list|,
name|range_index_t
modifier|*
name|ndx
parameter_list|,
name|enum
name|range_kind
name|kind
parameter_list|,
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
name|limit
parameter_list|,
name|apr_size_t
name|target_offset
parameter_list|)
block|{
name|range_list_node_t
modifier|*
specifier|const
name|node
init|=
name|alloc_block
argument_list|(
name|ndx
operator|->
name|pool
argument_list|,
operator|&
name|ndx
operator|->
name|free_list
argument_list|)
decl_stmt|;
name|node
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|node
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
name|node
operator|->
name|limit
operator|=
name|limit
expr_stmt|;
name|node
operator|->
name|target_offset
operator|=
name|target_offset
expr_stmt|;
if|if
condition|(
operator|*
name|list
operator|==
name|NULL
condition|)
block|{
name|node
operator|->
name|prev
operator|=
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|list
operator|=
operator|*
name|tail
operator|=
name|node
expr_stmt|;
block|}
else|else
block|{
name|node
operator|->
name|prev
operator|=
operator|*
name|tail
expr_stmt|;
name|node
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|(
operator|*
name|tail
operator|)
operator|->
name|next
operator|=
name|node
expr_stmt|;
operator|*
name|tail
operator|=
name|node
expr_stmt|;
block|}
return|return
operator|*
name|list
return|;
block|}
end_function

begin_comment
comment|/* Free a range list. LIST is the head of the list, NDX holds the freelist. */
end_comment

begin_function
specifier|static
name|void
name|free_range_list
parameter_list|(
name|range_list_node_t
modifier|*
name|list
parameter_list|,
name|range_index_t
modifier|*
name|ndx
parameter_list|)
block|{
while|while
condition|(
name|list
condition|)
block|{
name|range_list_node_t
modifier|*
specifier|const
name|node
init|=
name|list
decl_stmt|;
name|list
operator|=
name|node
operator|->
name|next
expr_stmt|;
name|free_block
argument_list|(
name|node
argument_list|,
operator|&
name|ndx
operator|->
name|free_list
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Based on the data in NDX, build a list of ranges that cover    [OFFSET, LIMIT) in the "virtual" source data.    NOTE: The range index must be splayed to OFFSET! */
end_comment

begin_function
specifier|static
name|range_list_node_t
modifier|*
name|build_range_list
parameter_list|(
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
name|limit
parameter_list|,
name|range_index_t
modifier|*
name|ndx
parameter_list|)
block|{
name|range_list_node_t
modifier|*
name|range_list
init|=
name|NULL
decl_stmt|;
name|range_list_node_t
modifier|*
name|last_range
init|=
name|NULL
decl_stmt|;
name|range_index_node_t
modifier|*
name|node
init|=
name|ndx
operator|->
name|tree
decl_stmt|;
while|while
condition|(
name|offset
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|node
operator|==
name|NULL
condition|)
return|return
name|alloc_range_list
argument_list|(
operator|&
name|range_list
argument_list|,
operator|&
name|last_range
argument_list|,
name|ndx
argument_list|,
name|range_from_source
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
return|;
if|if
condition|(
name|offset
operator|<
name|node
operator|->
name|offset
condition|)
block|{
if|if
condition|(
name|limit
operator|<=
name|node
operator|->
name|offset
condition|)
return|return
name|alloc_range_list
argument_list|(
operator|&
name|range_list
argument_list|,
operator|&
name|last_range
argument_list|,
name|ndx
argument_list|,
name|range_from_source
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
return|;
else|else
block|{
name|alloc_range_list
argument_list|(
operator|&
name|range_list
argument_list|,
operator|&
name|last_range
argument_list|,
name|ndx
argument_list|,
name|range_from_source
argument_list|,
name|offset
argument_list|,
name|node
operator|->
name|offset
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|node
operator|->
name|offset
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* TODO: (Potential optimization) Investigate if it would              make sense to forbid short range_from_target lengths              (this comment originally said "shorter than, say,              VD_KEY_SIZE (see vdelta.c)", but Subversion no longer              uses vdelta). */
if|if
condition|(
name|offset
operator|>=
name|node
operator|->
name|limit
condition|)
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
else|else
block|{
specifier|const
name|apr_size_t
name|target_offset
init|=
name|offset
operator|-
name|node
operator|->
name|offset
operator|+
name|node
operator|->
name|target_offset
decl_stmt|;
if|if
condition|(
name|limit
operator|<=
name|node
operator|->
name|limit
condition|)
return|return
name|alloc_range_list
argument_list|(
operator|&
name|range_list
argument_list|,
operator|&
name|last_range
argument_list|,
name|ndx
argument_list|,
name|range_from_target
argument_list|,
name|offset
argument_list|,
name|limit
argument_list|,
name|target_offset
argument_list|)
return|;
else|else
block|{
name|alloc_range_list
argument_list|(
operator|&
name|range_list
argument_list|,
operator|&
name|last_range
argument_list|,
name|ndx
argument_list|,
name|range_from_target
argument_list|,
name|offset
argument_list|,
name|node
operator|->
name|limit
argument_list|,
name|target_offset
argument_list|)
expr_stmt|;
name|offset
operator|=
name|node
operator|->
name|limit
expr_stmt|;
name|node
operator|=
name|node
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* A range's offset isn't smaller than its limit? Impossible! */
name|SVN_ERR_MALFUNCTION_NO_RETURN
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy the instructions from WINDOW that define the range [OFFSET,    LIMIT) in WINDOW's target stream to TARGET_OFFSET in the window    represented by BUILD_BATON. HINT is a position in the instructions    array that helps finding the position for OFFSET. A safe default    is 0. Use NDX to find the instructions in WINDOW. Allocate space    in BUILD_BATON from POOL. */
end_comment

begin_function
specifier|static
name|void
name|copy_source_ops
parameter_list|(
name|apr_size_t
name|offset
parameter_list|,
name|apr_size_t
name|limit
parameter_list|,
name|apr_size_t
name|target_offset
parameter_list|,
name|apr_size_t
name|hint
parameter_list|,
name|svn_txdelta__ops_baton_t
modifier|*
name|build_baton
parameter_list|,
specifier|const
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
specifier|const
name|offset_index_t
modifier|*
name|ndx
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|op_ndx
init|=
name|search_offset_index
argument_list|(
name|ndx
argument_list|,
name|offset
argument_list|,
name|hint
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
operator|++
name|op_ndx
control|)
block|{
specifier|const
name|svn_txdelta_op_t
modifier|*
specifier|const
name|op
init|=
operator|&
name|window
operator|->
name|ops
index|[
name|op_ndx
index|]
decl_stmt|;
specifier|const
name|apr_size_t
modifier|*
specifier|const
name|off
init|=
operator|&
name|ndx
operator|->
name|offs
index|[
name|op_ndx
index|]
decl_stmt|;
name|apr_size_t
name|fix_offset
decl_stmt|;
name|apr_size_t
name|fix_limit
decl_stmt|;
if|if
condition|(
name|off
index|[
literal|0
index|]
operator|>=
name|limit
condition|)
break|break;
name|fix_offset
operator|=
operator|(
name|offset
operator|>
name|off
index|[
literal|0
index|]
condition|?
name|offset
operator|-
name|off
index|[
literal|0
index|]
else|:
literal|0
operator|)
expr_stmt|;
name|fix_limit
operator|=
operator|(
name|off
index|[
literal|1
index|]
operator|>
name|limit
condition|?
name|off
index|[
literal|1
index|]
operator|-
name|limit
else|:
literal|0
operator|)
expr_stmt|;
comment|/* It would be extremely weird if the fixed-up op had zero length. */
name|assert
argument_list|(
name|fix_offset
operator|+
name|fix_limit
operator|<
name|op
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|action_code
operator|!=
name|svn_txdelta_target
condition|)
block|{
comment|/* Delta ops that don't depend on the virtual target can be              copied to the composite unchanged. */
specifier|const
name|char
modifier|*
specifier|const
name|new_data
init|=
operator|(
name|op
operator|->
name|action_code
operator|==
name|svn_txdelta_new
condition|?
operator|(
name|window
operator|->
name|new_data
operator|->
name|data
operator|+
name|op
operator|->
name|offset
operator|+
name|fix_offset
operator|)
else|:
name|NULL
operator|)
decl_stmt|;
name|svn_txdelta__insert_op
argument_list|(
name|build_baton
argument_list|,
name|op
operator|->
name|action_code
argument_list|,
name|op
operator|->
name|offset
operator|+
name|fix_offset
argument_list|,
name|op
operator|->
name|length
operator|-
name|fix_offset
operator|-
name|fix_limit
argument_list|,
name|new_data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* The source of a target copy must start before the current              offset in the (virtual) target stream. */
name|assert
argument_list|(
name|op
operator|->
name|offset
operator|<
name|off
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|offset
operator|+
name|op
operator|->
name|length
operator|-
name|fix_limit
operator|<=
name|off
index|[
literal|0
index|]
condition|)
block|{
comment|/* The recursion _must_ end, otherwise the delta has                  circular references, and that is not possible. */
name|copy_source_ops
argument_list|(
name|op
operator|->
name|offset
operator|+
name|fix_offset
argument_list|,
name|op
operator|->
name|offset
operator|+
name|op
operator|->
name|length
operator|-
name|fix_limit
argument_list|,
name|target_offset
argument_list|,
name|op_ndx
argument_list|,
name|build_baton
argument_list|,
name|window
argument_list|,
name|ndx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is an overlapping target copy.                  The idea here is to transpose the pattern, then generate                  another overlapping copy. */
specifier|const
name|apr_size_t
name|ptn_length
init|=
name|off
index|[
literal|0
index|]
operator|-
name|op
operator|->
name|offset
decl_stmt|;
specifier|const
name|apr_size_t
name|ptn_overlap
init|=
name|fix_offset
operator|%
name|ptn_length
decl_stmt|;
name|apr_size_t
name|fix_off
init|=
name|fix_offset
decl_stmt|;
name|apr_size_t
name|tgt_off
init|=
name|target_offset
decl_stmt|;
name|assert
argument_list|(
name|ptn_length
operator|>
name|ptn_overlap
argument_list|)
expr_stmt|;
comment|/* ### FIXME: ptn_overlap is unsigned, so the if() condition                  below is always true!  Either it should be '> 0', or the                  code block should be unconditional.  See also r842362. */
if|if
condition|(
name|ptn_overlap
operator|>=
literal|0
condition|)
block|{
comment|/* Issue second subrange in the pattern. */
specifier|const
name|apr_size_t
name|length
init|=
name|MIN
argument_list|(
name|op
operator|->
name|length
operator|-
name|fix_off
operator|-
name|fix_limit
argument_list|,
name|ptn_length
operator|-
name|ptn_overlap
argument_list|)
decl_stmt|;
name|copy_source_ops
argument_list|(
name|op
operator|->
name|offset
operator|+
name|ptn_overlap
argument_list|,
name|op
operator|->
name|offset
operator|+
name|ptn_overlap
operator|+
name|length
argument_list|,
name|tgt_off
argument_list|,
name|op_ndx
argument_list|,
name|build_baton
argument_list|,
name|window
argument_list|,
name|ndx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fix_off
operator|+=
name|length
expr_stmt|;
name|tgt_off
operator|+=
name|length
expr_stmt|;
block|}
name|assert
argument_list|(
name|fix_off
operator|+
name|fix_limit
operator|<=
name|op
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptn_overlap
operator|>
literal|0
operator|&&
name|fix_off
operator|+
name|fix_limit
operator|<
name|op
operator|->
name|length
condition|)
block|{
comment|/* Issue the first subrange in the pattern. */
specifier|const
name|apr_size_t
name|length
init|=
name|MIN
argument_list|(
name|op
operator|->
name|length
operator|-
name|fix_off
operator|-
name|fix_limit
argument_list|,
name|ptn_overlap
argument_list|)
decl_stmt|;
name|copy_source_ops
argument_list|(
name|op
operator|->
name|offset
argument_list|,
name|op
operator|->
name|offset
operator|+
name|length
argument_list|,
name|tgt_off
argument_list|,
name|op_ndx
argument_list|,
name|build_baton
argument_list|,
name|window
argument_list|,
name|ndx
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|fix_off
operator|+=
name|length
expr_stmt|;
name|tgt_off
operator|+=
name|length
expr_stmt|;
block|}
name|assert
argument_list|(
name|fix_off
operator|+
name|fix_limit
operator|<=
name|op
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|fix_off
operator|+
name|fix_limit
operator|<
name|op
operator|->
name|length
condition|)
block|{
comment|/* Now multiply the pattern */
name|svn_txdelta__insert_op
argument_list|(
name|build_baton
argument_list|,
name|svn_txdelta_target
argument_list|,
name|tgt_off
operator|-
name|ptn_length
argument_list|,
name|op
operator|->
name|length
operator|-
name|fix_off
operator|-
name|fix_limit
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Adjust the target offset for the next op in the list. */
name|target_offset
operator|+=
name|op
operator|->
name|length
operator|-
name|fix_offset
operator|-
name|fix_limit
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ==================================================================== */
end_comment

begin_comment
comment|/* Bringing it all together. */
end_comment

begin_function
name|svn_txdelta_window_t
modifier|*
name|svn_txdelta_compose_windows
parameter_list|(
specifier|const
name|svn_txdelta_window_t
modifier|*
name|window_A
parameter_list|,
specifier|const
name|svn_txdelta_window_t
modifier|*
name|window_B
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta__ops_baton_t
name|build_baton
init|=
block|{
literal|0
block|}
decl_stmt|;
name|svn_txdelta_window_t
modifier|*
name|composite
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|offset_index_t
modifier|*
name|offset_index
init|=
name|create_offset_index
argument_list|(
name|window_A
argument_list|,
name|subpool
argument_list|)
decl_stmt|;
name|range_index_t
modifier|*
name|range_index
init|=
name|create_range_index
argument_list|(
name|subpool
argument_list|)
decl_stmt|;
name|apr_size_t
name|target_offset
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Read the description of the delta composition algorithm in      notes/fs-improvements.txt before going any further.      You have been warned. */
name|build_baton
operator|.
name|new_data
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|window_B
operator|->
name|num_ops
condition|;
operator|++
name|i
control|)
block|{
specifier|const
name|svn_txdelta_op_t
modifier|*
specifier|const
name|op
init|=
operator|&
name|window_B
operator|->
name|ops
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|op
operator|->
name|action_code
operator|!=
name|svn_txdelta_source
condition|)
block|{
comment|/* Delta ops that don't depend on the source can be copied              to the composite unchanged. */
specifier|const
name|char
modifier|*
specifier|const
name|new_data
init|=
operator|(
name|op
operator|->
name|action_code
operator|==
name|svn_txdelta_new
condition|?
name|window_B
operator|->
name|new_data
operator|->
name|data
operator|+
name|op
operator|->
name|offset
else|:
name|NULL
operator|)
decl_stmt|;
name|svn_txdelta__insert_op
argument_list|(
operator|&
name|build_baton
argument_list|,
name|op
operator|->
name|action_code
argument_list|,
name|op
operator|->
name|offset
argument_list|,
name|op
operator|->
name|length
argument_list|,
name|new_data
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* NOTE: Remember that `offset' and `limit' refer to              positions in window_B's _source_ stream, which is the              same as window_A's _target_ stream! */
specifier|const
name|apr_size_t
name|offset
init|=
name|op
operator|->
name|offset
decl_stmt|;
specifier|const
name|apr_size_t
name|limit
init|=
name|op
operator|->
name|offset
operator|+
name|op
operator|->
name|length
decl_stmt|;
name|range_list_node_t
modifier|*
name|range_list
decl_stmt|,
modifier|*
name|range
decl_stmt|;
name|apr_size_t
name|tgt_off
init|=
name|target_offset
decl_stmt|;
name|splay_range_index
argument_list|(
name|offset
argument_list|,
name|range_index
argument_list|)
expr_stmt|;
name|range_list
operator|=
name|build_range_list
argument_list|(
name|offset
argument_list|,
name|limit
argument_list|,
name|range_index
argument_list|)
expr_stmt|;
for|for
control|(
name|range
operator|=
name|range_list
init|;
name|range
condition|;
name|range
operator|=
name|range
operator|->
name|next
control|)
block|{
if|if
condition|(
name|range
operator|->
name|kind
operator|==
name|range_from_target
condition|)
name|svn_txdelta__insert_op
argument_list|(
operator|&
name|build_baton
argument_list|,
name|svn_txdelta_target
argument_list|,
name|range
operator|->
name|target_offset
argument_list|,
name|range
operator|->
name|limit
operator|-
name|range
operator|->
name|offset
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
name|copy_source_ops
argument_list|(
name|range
operator|->
name|offset
argument_list|,
name|range
operator|->
name|limit
argument_list|,
name|tgt_off
argument_list|,
literal|0
argument_list|,
operator|&
name|build_baton
argument_list|,
name|window_A
argument_list|,
name|offset_index
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|tgt_off
operator|+=
name|range
operator|->
name|limit
operator|-
name|range
operator|->
name|offset
expr_stmt|;
block|}
name|assert
argument_list|(
name|tgt_off
operator|==
name|target_offset
operator|+
name|op
operator|->
name|length
argument_list|)
expr_stmt|;
name|free_range_list
argument_list|(
name|range_list
argument_list|,
name|range_index
argument_list|)
expr_stmt|;
name|insert_range
argument_list|(
name|offset
argument_list|,
name|limit
argument_list|,
name|target_offset
argument_list|,
name|range_index
argument_list|)
expr_stmt|;
block|}
comment|/* Remember the new offset in the would-be target stream. */
name|target_offset
operator|+=
name|op
operator|->
name|length
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|composite
operator|=
name|svn_txdelta__make_window
argument_list|(
operator|&
name|build_baton
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|composite
operator|->
name|sview_offset
operator|=
name|window_A
operator|->
name|sview_offset
expr_stmt|;
name|composite
operator|->
name|sview_len
operator|=
name|window_A
operator|->
name|sview_len
expr_stmt|;
name|composite
operator|->
name|tview_len
operator|=
name|window_B
operator|->
name|tview_len
expr_stmt|;
return|return
name|composite
return|;
block|}
end_function

end_unit

