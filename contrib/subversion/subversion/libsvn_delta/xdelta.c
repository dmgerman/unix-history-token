begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * xdelta.c:  xdelta generator.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<apr_general.h>
end_include

begin_comment
comment|/* for APR_INLINE */
end_comment

begin_include
include|#
directive|include
file|<apr_hash.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"delta.h"
end_include

begin_escape
end_escape

begin_comment
comment|/* This is pseudo-adler32. It is adler32 without the prime modulus.    The idea is borrowed from monotone, and is a translation of the C++    code.  Graydon Hoare, the author of the original code, gave his    explicit permission to use it under these terms at 8:02pm on    Friday, February 11th, 2005.  */
end_comment

begin_comment
comment|/* Size of the blocks we compute checksums for. This was chosen out of    thin air.  Monotone used 64, xdelta1 used 64, rsync uses 128.    However, later optimizations assume it to be 256 or less.  */
end_comment

begin_define
define|#
directive|define
name|MATCH_BLOCKSIZE
value|64
end_define

begin_comment
comment|/* "no" / "invalid" / "unused" value for positions within the delta windows  */
end_comment

begin_define
define|#
directive|define
name|NO_POSITION
value|((apr_uint32_t)-1)
end_define

begin_comment
comment|/* Feed C_IN into the adler32 checksum and remove C_OUT at the same time.  * This function may (and will) only be called for characters that are  * MATCH_BLOCKSIZE positions apart.  *  * Please note that the lower 16 bits cannot overflow in neither direction.  * Therefore, we don't need to split the value into separate values for  * sum(char) and sum(sum(char)).  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|apr_uint32_t
name|adler32_replace
parameter_list|(
name|apr_uint32_t
name|adler32
parameter_list|,
specifier|const
name|char
name|c_out
parameter_list|,
specifier|const
name|char
name|c_in
parameter_list|)
block|{
name|adler32
operator|-=
operator|(
name|MATCH_BLOCKSIZE
operator|*
literal|0x10000u
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|)
name|c_out
operator|)
operator|)
expr_stmt|;
name|adler32
operator|-=
operator|(
name|unsigned
name|char
operator|)
name|c_out
expr_stmt|;
name|adler32
operator|+=
operator|(
name|unsigned
name|char
operator|)
name|c_in
expr_stmt|;
return|return
name|adler32
operator|+
name|adler32
operator|*
literal|0x10000
return|;
block|}
end_function

begin_comment
comment|/* Calculate an pseudo-adler32 checksum for MATCH_BLOCKSIZE bytes starting    at DATA.  Return the checksum value.  */
end_comment

begin_function
specifier|static
name|APR_INLINE
name|apr_uint32_t
name|init_adler32
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|input
init|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|data
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|last
init|=
name|input
operator|+
name|MATCH_BLOCKSIZE
decl_stmt|;
name|apr_uint32_t
name|s1
init|=
literal|0
decl_stmt|;
name|apr_uint32_t
name|s2
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|input
operator|<
name|last
condition|;
name|input
operator|+=
literal|8
control|)
block|{
name|s1
operator|+=
name|input
index|[
literal|0
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|1
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|2
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|3
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|4
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|5
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|6
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
name|s1
operator|+=
name|input
index|[
literal|7
index|]
expr_stmt|;
name|s2
operator|+=
name|s1
expr_stmt|;
block|}
return|return
name|s2
operator|*
literal|0x10000
operator|+
name|s1
return|;
block|}
end_function

begin_comment
comment|/* Information for a block of the delta source.  The length of the    block is the smaller of MATCH_BLOCKSIZE and the difference between    the size of the source data and the position of this block. */
end_comment

begin_struct
struct|struct
name|block
block|{
name|apr_uint32_t
name|adlersum
decl_stmt|;
comment|/* Even in 64 bit systems, store only 32 bit offsets in our hash table    (our delta window size much much smaller then 4GB).    That reduces the hash table size by 50% from 32to 16KB    and makes it easier to fit into the CPU's L1 cache. */
name|apr_uint32_t
name|pos
decl_stmt|;
comment|/* NO_POSITION -> block is not used */
block|}
struct|;
end_struct

begin_comment
comment|/* A hash table, using open addressing, of the blocks of the source. */
end_comment

begin_struct
struct|struct
name|blocks
block|{
comment|/* The largest valid index of slots.      This value has an upper bound proportionate to the text delta      window size, so unless we dramatically increase the window size,      it's safe to make this a 32-bit value.  In any case, it has to be      hte same width as the block position index, (struct      block).pos. */
name|apr_uint32_t
name|max
decl_stmt|;
comment|/* Source buffer that the positions in SLOTS refer to. */
specifier|const
name|char
modifier|*
name|data
decl_stmt|;
comment|/* The vector of blocks.  A pos value of NO_POSITION represents an unused      slot. */
name|struct
name|block
modifier|*
name|slots
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Return a hash value calculated from the adler32 SUM, suitable for use with    our hash table. */
end_comment

begin_function
specifier|static
name|apr_uint32_t
name|hash_func
parameter_list|(
name|apr_uint32_t
name|sum
parameter_list|)
block|{
comment|/* Since the adl32 checksum have a bad distribution for the 11th to 16th      bits when used for our small block size, we add some bits from the      other half of the checksum. */
return|return
name|sum
operator|^
operator|(
name|sum
operator|>>
literal|12
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Insert a block with the checksum ADLERSUM at position POS in the source    data into the table BLOCKS.  Ignore true duplicates, i.e. blocks with    actually the same content. */
end_comment

begin_function
specifier|static
name|void
name|add_block
parameter_list|(
name|struct
name|blocks
modifier|*
name|blocks
parameter_list|,
name|apr_uint32_t
name|adlersum
parameter_list|,
name|apr_uint32_t
name|pos
parameter_list|)
block|{
name|apr_uint32_t
name|h
init|=
name|hash_func
argument_list|(
name|adlersum
argument_list|)
operator|&
name|blocks
operator|->
name|max
decl_stmt|;
comment|/* This will terminate, since we know that we will not fill the table. */
for|for
control|(
init|;
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|pos
operator|!=
name|NO_POSITION
condition|;
name|h
operator|=
operator|(
name|h
operator|+
literal|1
operator|)
operator|&
name|blocks
operator|->
name|max
control|)
if|if
condition|(
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|adlersum
operator|==
name|adlersum
condition|)
if|if
condition|(
name|memcmp
argument_list|(
name|blocks
operator|->
name|data
operator|+
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|pos
argument_list|,
name|blocks
operator|->
name|data
operator|+
name|pos
argument_list|,
name|MATCH_BLOCKSIZE
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|adlersum
operator|=
name|adlersum
expr_stmt|;
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|pos
operator|=
name|pos
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find a block in BLOCKS with the checksum ADLERSUM and matching the content    at DATA, returning its position in the source data.  If there is no such    block, return NO_POSITION. */
end_comment

begin_function
specifier|static
name|apr_uint32_t
name|find_block
parameter_list|(
specifier|const
name|struct
name|blocks
modifier|*
name|blocks
parameter_list|,
name|apr_uint32_t
name|adlersum
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|)
block|{
name|apr_uint32_t
name|h
init|=
name|hash_func
argument_list|(
name|adlersum
argument_list|)
operator|&
name|blocks
operator|->
name|max
decl_stmt|;
for|for
control|(
init|;
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|pos
operator|!=
name|NO_POSITION
condition|;
name|h
operator|=
operator|(
name|h
operator|+
literal|1
operator|)
operator|&
name|blocks
operator|->
name|max
control|)
if|if
condition|(
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|adlersum
operator|==
name|adlersum
condition|)
if|if
condition|(
name|memcmp
argument_list|(
name|blocks
operator|->
name|data
operator|+
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|pos
argument_list|,
name|data
argument_list|,
name|MATCH_BLOCKSIZE
argument_list|)
operator|==
literal|0
condition|)
return|return
name|blocks
operator|->
name|slots
index|[
name|h
index|]
operator|.
name|pos
return|;
return|return
name|NO_POSITION
return|;
block|}
end_function

begin_comment
comment|/* Initialize the matches table from DATA of size DATALEN.  This goes    through every block of MATCH_BLOCKSIZE bytes in the source and    checksums it, inserting the result into the BLOCKS table.  */
end_comment

begin_function
specifier|static
name|void
name|init_blocks_table
parameter_list|(
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|datalen
parameter_list|,
name|struct
name|blocks
modifier|*
name|blocks
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|nblocks
decl_stmt|;
name|apr_size_t
name|wnslots
init|=
literal|1
decl_stmt|;
name|apr_uint32_t
name|nslots
decl_stmt|;
name|apr_uint32_t
name|i
decl_stmt|;
comment|/* Be pessimistic about the block count. */
name|nblocks
operator|=
name|datalen
operator|/
name|MATCH_BLOCKSIZE
operator|+
literal|1
expr_stmt|;
comment|/* Find nearest larger power of two. */
while|while
condition|(
name|wnslots
operator|<=
name|nblocks
condition|)
name|wnslots
operator|*=
literal|2
expr_stmt|;
comment|/* Double the number of slots to avoid a too high load. */
name|wnslots
operator|*=
literal|2
expr_stmt|;
comment|/* Narrow the number of slots to 32 bits, which is the size of the      block position index in the hash table.      Sanity check: On 64-bit platforms, apr_size_t is likely to be      larger than apr_uint32_t. Make sure that the number of slots      actually fits into blocks->max.  It's safe to use a hard assert      here, because the largest possible value for nslots is      proportional to the text delta window size and is therefore much      smaller than the range of an apr_uint32_t.  If we ever happen to      increase the window size too much, this assertion will get      triggered by the test suite. */
name|nslots
operator|=
operator|(
name|apr_uint32_t
operator|)
name|wnslots
expr_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|wnslots
operator|==
name|nslots
argument_list|)
expr_stmt|;
name|blocks
operator|->
name|max
operator|=
name|nslots
operator|-
literal|1
expr_stmt|;
name|blocks
operator|->
name|data
operator|=
name|data
expr_stmt|;
name|blocks
operator|->
name|slots
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|nslots
operator|*
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|blocks
operator|->
name|slots
operator|)
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nslots
condition|;
operator|++
name|i
control|)
block|{
comment|/* Avoid using an indeterminate value in the lookup. */
name|blocks
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|adlersum
operator|=
literal|0
expr_stmt|;
name|blocks
operator|->
name|slots
index|[
name|i
index|]
operator|.
name|pos
operator|=
name|NO_POSITION
expr_stmt|;
block|}
comment|/* If there is an odd block at the end of the buffer, we will      not use that shorter block for deltification (only indirectly      as an extension of some previous block). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|+
name|MATCH_BLOCKSIZE
operator|<=
name|datalen
condition|;
name|i
operator|+=
name|MATCH_BLOCKSIZE
control|)
name|add_block
argument_list|(
name|blocks
argument_list|,
name|init_adler32
argument_list|(
name|data
operator|+
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the lowest position at which A and B differ. If no difference  * can be found in the first MAX_LEN characters, MAX_LEN will be returned.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|match_length
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|apr_size_t
name|max_len
parameter_list|)
block|{
name|apr_size_t
name|pos
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* Chunky processing is so much faster ...    *    * We can't make this work on architectures that require aligned access    * because A and B will probably have different alignment. So, skipping    * the first few chars until alignment is reached is not an option.    */
for|for
control|(
init|;
name|pos
operator|+
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
operator|<=
name|max_len
condition|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
control|)
if|if
condition|(
operator|*
operator|(
specifier|const
name|apr_size_t
operator|*
operator|)
operator|(
name|a
operator|+
name|pos
operator|)
operator|!=
operator|*
operator|(
specifier|const
name|apr_size_t
operator|*
operator|)
operator|(
name|b
operator|+
name|pos
operator|)
condition|)
break|break;
endif|#
directive|endif
for|for
control|(
init|;
name|pos
operator|<
name|max_len
condition|;
operator|++
name|pos
control|)
if|if
condition|(
name|a
index|[
name|pos
index|]
operator|!=
name|b
index|[
name|pos
index|]
condition|)
break|break;
return|return
name|pos
return|;
block|}
end_function

begin_comment
comment|/* Return the number of bytes before A and B that don't differ.  If no  * difference can be found in the first MAX_LEN characters,  MAX_LEN will  * be returned.  Please note that A-MAX_LEN and B-MAX_LEN must both be  * valid addresses.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|reverse_match_length
parameter_list|(
specifier|const
name|char
modifier|*
name|a
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|apr_size_t
name|max_len
parameter_list|)
block|{
name|apr_size_t
name|pos
init|=
literal|0
decl_stmt|;
if|#
directive|if
name|SVN_UNALIGNED_ACCESS_IS_OK
comment|/* Chunky processing is so much faster ...    *    * We can't make this work on architectures that require aligned access    * because A and B will probably have different alignment. So, skipping    * the first few chars until alignment is reached is not an option.    */
for|for
control|(
name|pos
operator|=
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
init|;
name|pos
operator|<=
name|max_len
condition|;
name|pos
operator|+=
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
control|)
if|if
condition|(
operator|*
operator|(
specifier|const
name|apr_size_t
operator|*
operator|)
operator|(
name|a
operator|-
name|pos
operator|)
operator|!=
operator|*
operator|(
specifier|const
name|apr_size_t
operator|*
operator|)
operator|(
name|b
operator|-
name|pos
operator|)
condition|)
break|break;
name|pos
operator|-=
sizeof|sizeof
argument_list|(
name|apr_size_t
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* If we find a mismatch at -pos, pos-1 characters matched.    */
while|while
condition|(
operator|++
name|pos
operator|<=
name|max_len
condition|)
if|if
condition|(
name|a
index|[
literal|0
operator|-
name|pos
index|]
operator|!=
name|b
index|[
literal|0
operator|-
name|pos
index|]
condition|)
return|return
name|pos
operator|-
literal|1
return|;
comment|/* No mismatch found -> at least MAX_LEN matching chars.    */
return|return
name|max_len
return|;
block|}
end_function

begin_comment
comment|/* Try to find a match for the target data B in BLOCKS, and then    extend the match as long as data in A and B at the match position    continues to match.  We set the position in A we ended up in (in    case we extended it backwards) in APOSP and update the corresponding    position within B given in BPOSP. PENDING_INSERT_START sets the    lower limit to BPOSP.    Return number of matching bytes starting at ASOP.  Return 0 if    no match has been found.  */
end_comment

begin_function
specifier|static
name|apr_size_t
name|find_match
parameter_list|(
specifier|const
name|struct
name|blocks
modifier|*
name|blocks
parameter_list|,
specifier|const
name|apr_uint32_t
name|rolling
parameter_list|,
specifier|const
name|char
modifier|*
name|a
parameter_list|,
name|apr_size_t
name|asize
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|apr_size_t
name|bsize
parameter_list|,
name|apr_size_t
modifier|*
name|bposp
parameter_list|,
name|apr_size_t
modifier|*
name|aposp
parameter_list|,
name|apr_size_t
name|pending_insert_start
parameter_list|)
block|{
name|apr_size_t
name|apos
decl_stmt|,
name|bpos
init|=
operator|*
name|bposp
decl_stmt|;
name|apr_size_t
name|delta
decl_stmt|,
name|max_delta
decl_stmt|;
name|apos
operator|=
name|find_block
argument_list|(
name|blocks
argument_list|,
name|rolling
argument_list|,
name|b
operator|+
name|bpos
argument_list|)
expr_stmt|;
comment|/* See if we have a match.  */
if|if
condition|(
name|apos
operator|==
name|NO_POSITION
condition|)
return|return
literal|0
return|;
comment|/* Extend the match forward as far as possible */
name|max_delta
operator|=
name|asize
operator|-
name|apos
operator|-
name|MATCH_BLOCKSIZE
operator|<
name|bsize
operator|-
name|bpos
operator|-
name|MATCH_BLOCKSIZE
condition|?
name|asize
operator|-
name|apos
operator|-
name|MATCH_BLOCKSIZE
else|:
name|bsize
operator|-
name|bpos
operator|-
name|MATCH_BLOCKSIZE
expr_stmt|;
name|delta
operator|=
name|match_length
argument_list|(
name|a
operator|+
name|apos
operator|+
name|MATCH_BLOCKSIZE
argument_list|,
name|b
operator|+
name|bpos
operator|+
name|MATCH_BLOCKSIZE
argument_list|,
name|max_delta
argument_list|)
expr_stmt|;
comment|/* See if we can extend backwards (max MATCH_BLOCKSIZE-1 steps because A's      content has been sampled only every MATCH_BLOCKSIZE positions).  */
while|while
condition|(
name|apos
operator|>
literal|0
operator|&&
name|bpos
operator|>
name|pending_insert_start
operator|&&
name|a
index|[
name|apos
operator|-
literal|1
index|]
operator|==
name|b
index|[
name|bpos
operator|-
literal|1
index|]
condition|)
block|{
operator|--
name|apos
expr_stmt|;
operator|--
name|bpos
expr_stmt|;
operator|++
name|delta
expr_stmt|;
block|}
operator|*
name|aposp
operator|=
name|apos
expr_stmt|;
operator|*
name|bposp
operator|=
name|bpos
expr_stmt|;
return|return
name|MATCH_BLOCKSIZE
operator|+
name|delta
return|;
block|}
end_function

begin_comment
comment|/* Utility for compute_delta() that compares the range B[START,BSIZE) with  * the range of similar size before A[ASIZE]. Create corresponding copy and  * insert operations.  *  * BUILD_BATON and POOL will be passed through from compute_delta().  */
end_comment

begin_function
specifier|static
name|void
name|store_delta_trailer
parameter_list|(
name|svn_txdelta__ops_baton_t
modifier|*
name|build_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|a
parameter_list|,
name|apr_size_t
name|asize
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|apr_size_t
name|bsize
parameter_list|,
name|apr_size_t
name|start
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_size_t
name|end_match
decl_stmt|;
name|apr_size_t
name|max_len
init|=
name|asize
operator|>
operator|(
name|bsize
operator|-
name|start
operator|)
condition|?
name|bsize
operator|-
name|start
else|:
name|asize
decl_stmt|;
if|if
condition|(
name|max_len
operator|==
literal|0
condition|)
return|return;
name|end_match
operator|=
name|reverse_match_length
argument_list|(
name|a
operator|+
name|asize
argument_list|,
name|b
operator|+
name|bsize
argument_list|,
name|max_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_match
operator|<=
literal|4
condition|)
name|end_match
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bsize
operator|-
name|start
operator|>
name|end_match
condition|)
name|svn_txdelta__insert_op
argument_list|(
name|build_baton
argument_list|,
name|svn_txdelta_new
argument_list|,
name|start
argument_list|,
name|bsize
operator|-
name|start
operator|-
name|end_match
argument_list|,
name|b
operator|+
name|start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_match
condition|)
name|svn_txdelta__insert_op
argument_list|(
name|build_baton
argument_list|,
name|svn_txdelta_source
argument_list|,
name|asize
operator|-
name|end_match
argument_list|,
name|end_match
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Compute a delta from A to B using xdelta.     The basic xdelta algorithm is as follows:     1. Go through the source data, checksumming every MATCH_BLOCKSIZE       block of bytes using adler32, and inserting the checksum into a       match table with the position of the match.    2. Go through the target byte by byte, seeing if that byte starts a       match that we have in the match table.       2a. If so, try to extend the match as far as possible both           forwards and backwards, and then insert a source copy           operation into the delta ops builder for the match.       2b. If not, insert the byte as new data using an insert delta op.     Our implementation doesn't immediately insert "insert" operations,    it waits until we have another copy, or we are done.  The reasoning    is twofold:     1. Otherwise, we would just be building a ton of 1 byte insert       operations    2. So that we can extend a source match backwards into a pending      insert operation, and possibly remove the need for the insert      entirely.  This can happen due to stream alignment. */
end_comment

begin_function
specifier|static
name|void
name|compute_delta
parameter_list|(
name|svn_txdelta__ops_baton_t
modifier|*
name|build_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|a
parameter_list|,
name|apr_size_t
name|asize
parameter_list|,
specifier|const
name|char
modifier|*
name|b
parameter_list|,
name|apr_size_t
name|bsize
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|blocks
name|blocks
decl_stmt|;
name|apr_uint32_t
name|rolling
decl_stmt|;
name|apr_size_t
name|lo
init|=
literal|0
decl_stmt|,
name|pending_insert_start
init|=
literal|0
decl_stmt|;
comment|/* Optimization: directly compare window starts. If more than 4    * bytes match, we can immediately create a matching windows.    * Shorter sequences result in a net data increase. */
name|lo
operator|=
name|match_length
argument_list|(
name|a
argument_list|,
name|b
argument_list|,
name|asize
operator|>
name|bsize
condition|?
name|bsize
else|:
name|asize
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|lo
operator|>
literal|4
operator|)
operator|||
operator|(
name|lo
operator|==
name|bsize
operator|)
condition|)
block|{
name|svn_txdelta__insert_op
argument_list|(
name|build_baton
argument_list|,
name|svn_txdelta_source
argument_list|,
literal|0
argument_list|,
name|lo
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|pending_insert_start
operator|=
name|lo
expr_stmt|;
block|}
else|else
name|lo
operator|=
literal|0
expr_stmt|;
comment|/* If the size of the target is smaller than the match blocksize, just      insert the entire target.  */
if|if
condition|(
operator|(
name|bsize
operator|-
name|lo
operator|<
name|MATCH_BLOCKSIZE
operator|)
operator|||
operator|(
name|asize
operator|<
name|MATCH_BLOCKSIZE
operator|)
condition|)
block|{
name|store_delta_trailer
argument_list|(
name|build_baton
argument_list|,
name|a
argument_list|,
name|asize
argument_list|,
name|b
argument_list|,
name|bsize
argument_list|,
name|lo
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Initialize the matches table.  */
name|init_blocks_table
argument_list|(
name|a
argument_list|,
name|asize
argument_list|,
operator|&
name|blocks
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Initialize our rolling checksum.  */
name|rolling
operator|=
name|init_adler32
argument_list|(
name|b
operator|+
name|lo
argument_list|)
expr_stmt|;
while|while
condition|(
name|lo
operator|<
name|bsize
condition|)
block|{
name|apr_size_t
name|matchlen
init|=
literal|0
decl_stmt|;
name|apr_size_t
name|apos
decl_stmt|;
if|if
condition|(
name|lo
operator|+
name|MATCH_BLOCKSIZE
operator|<=
name|bsize
condition|)
name|matchlen
operator|=
name|find_match
argument_list|(
operator|&
name|blocks
argument_list|,
name|rolling
argument_list|,
name|a
argument_list|,
name|asize
argument_list|,
name|b
argument_list|,
name|bsize
argument_list|,
operator|&
name|lo
argument_list|,
operator|&
name|apos
argument_list|,
name|pending_insert_start
argument_list|)
expr_stmt|;
comment|/* If we didn't find a real match, insert the byte at the target          position into the pending insert.  */
if|if
condition|(
name|matchlen
operator|==
literal|0
condition|)
block|{
comment|/* move block one position forward. Short blocks at the end of              the buffer cannot be used as the beginning of a new match */
if|if
condition|(
name|lo
operator|+
name|MATCH_BLOCKSIZE
operator|<
name|bsize
condition|)
name|rolling
operator|=
name|adler32_replace
argument_list|(
name|rolling
argument_list|,
name|b
index|[
name|lo
index|]
argument_list|,
name|b
index|[
name|lo
operator|+
name|MATCH_BLOCKSIZE
index|]
argument_list|)
expr_stmt|;
name|lo
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* store the sequence of B that is between the matches */
if|if
condition|(
name|lo
operator|-
name|pending_insert_start
operator|>
literal|0
condition|)
name|svn_txdelta__insert_op
argument_list|(
name|build_baton
argument_list|,
name|svn_txdelta_new
argument_list|,
literal|0
argument_list|,
name|lo
operator|-
name|pending_insert_start
argument_list|,
name|b
operator|+
name|pending_insert_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* the match borders on the previous op. Maybe, we found a                * match that is better than / overlapping the previous one. */
name|apr_size_t
name|len
init|=
name|reverse_match_length
argument_list|(
name|a
operator|+
name|apos
argument_list|,
name|b
operator|+
name|lo
argument_list|,
name|apos
operator|<
name|lo
condition|?
name|apos
else|:
name|lo
argument_list|)
decl_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|svn_txdelta__remove_copy
argument_list|(
name|build_baton
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|apos
operator|-=
name|len
expr_stmt|;
name|matchlen
operator|+=
name|len
expr_stmt|;
name|lo
operator|-=
name|len
expr_stmt|;
block|}
block|}
comment|/* Reset the pending insert start to immediately after the              match. */
name|lo
operator|+=
name|matchlen
expr_stmt|;
name|pending_insert_start
operator|=
name|lo
expr_stmt|;
name|svn_txdelta__insert_op
argument_list|(
name|build_baton
argument_list|,
name|svn_txdelta_source
argument_list|,
name|apos
argument_list|,
name|matchlen
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
comment|/* Calculate the Adler32 sum for the first block behind the match.            * Ignore short buffers at the end of B.            */
if|if
condition|(
name|lo
operator|+
name|MATCH_BLOCKSIZE
operator|<=
name|bsize
condition|)
name|rolling
operator|=
name|init_adler32
argument_list|(
name|b
operator|+
name|lo
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* If we still have an insert pending at the end, throw it in.  */
name|store_delta_trailer
argument_list|(
name|build_baton
argument_list|,
name|a
argument_list|,
name|asize
argument_list|,
name|b
argument_list|,
name|bsize
argument_list|,
name|pending_insert_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_txdelta__xdelta
parameter_list|(
name|svn_txdelta__ops_baton_t
modifier|*
name|build_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
name|source_len
parameter_list|,
name|apr_size_t
name|target_len
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/*  We should never be asked to compute something when the source_len is 0;       we just use a single insert op there (and rely on zlib for       compression). */
name|assert
argument_list|(
name|source_len
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|compute_delta
argument_list|(
name|build_baton
argument_list|,
name|data
argument_list|,
name|source_len
argument_list|,
name|data
operator|+
name|source_len
argument_list|,
name|target_len
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

