begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * compat.c :  Wrappers and callbacks for compatibility.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|"svn_types.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_sorts.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_delta_private.h"
end_include

begin_struct
struct|struct
name|file_rev_handler_wrapper_baton
block|{
name|void
modifier|*
name|baton
decl_stmt|;
name|svn_file_rev_handler_old_t
name|handler
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements svn_file_rev_handler_t. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|file_rev_handler_wrapper
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|rev
parameter_list|,
name|apr_hash_t
modifier|*
name|rev_props
parameter_list|,
name|svn_boolean_t
name|result_of_merge
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|delta_handler
parameter_list|,
name|void
modifier|*
modifier|*
name|delta_baton
parameter_list|,
name|apr_array_header_t
modifier|*
name|prop_diffs
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_rev_handler_wrapper_baton
modifier|*
name|fwb
init|=
name|baton
decl_stmt|;
if|if
condition|(
name|fwb
operator|->
name|handler
condition|)
return|return
name|fwb
operator|->
name|handler
argument_list|(
name|fwb
operator|->
name|baton
argument_list|,
name|path
argument_list|,
name|rev
argument_list|,
name|rev_props
argument_list|,
name|delta_handler
argument_list|,
name|delta_baton
argument_list|,
name|prop_diffs
argument_list|,
name|pool
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_compat_wrap_file_rev_handler
parameter_list|(
name|svn_file_rev_handler_t
modifier|*
name|handler2
parameter_list|,
name|void
modifier|*
modifier|*
name|handler2_baton
parameter_list|,
name|svn_file_rev_handler_old_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|file_rev_handler_wrapper_baton
modifier|*
name|fwb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fwb
argument_list|)
argument_list|)
decl_stmt|;
comment|/* Set the user provided old format callback in the baton. */
name|fwb
operator|->
name|baton
operator|=
name|handler_baton
expr_stmt|;
name|fwb
operator|->
name|handler
operator|=
name|handler
expr_stmt|;
operator|*
name|handler2_baton
operator|=
name|fwb
expr_stmt|;
operator|*
name|handler2
operator|=
name|file_rev_handler_wrapper
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* The following code maps the calls to a traditional delta editor to an  * Editorv2 editor.  It does this by keeping track of a lot of state, and  * then communicating that state to Ev2 upon closure of the file or dir (or  * edit).  Note that Ev2 calls add_symlink() and alter_symlink() are not  * present in the delta editor paradigm, so we never call them.  *  * The general idea here is that we have to see *all* the actions on a node's  * parent before we can process that node, which means we need to buffer a  * large amount of information in the dir batons, and then process it in the  * close_directory() handler.  *  * There are a few ways we alter the callback stream.  One is when unlocking  * paths.  To tell a client a path should be unlocked, the server sends a  * prop-del for the SVN_PROP_ENTRY_LOCK_TOKEN property.  This causes problems,  * since the client doesn't have this property in the first place, but the  * deletion has side effects (unlike deleting a non-existent regular property  * would).  To solve this, we introduce *another* function into the API, not  * a part of the Ev2 callbacks, but a companion which is used to register  * the unlock of a path.  See ev2_change_file_prop() for implemenation  * details.  */
end_comment

begin_struct
struct|struct
name|ev2_edit_baton
block|{
name|svn_editor_t
modifier|*
name|editor
decl_stmt|;
name|apr_hash_t
modifier|*
name|changes
decl_stmt|;
comment|/* REPOS_RELPATH -> struct change_node  */
name|apr_array_header_t
modifier|*
name|path_order
decl_stmt|;
name|int
name|paths_processed
decl_stmt|;
comment|/* For calculating relpaths from Ev1 copyfrom urls. */
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_relpath
decl_stmt|;
name|apr_pool_t
modifier|*
name|edit_pool
decl_stmt|;
name|struct
name|svn_delta__extra_baton
modifier|*
name|exb
decl_stmt|;
name|svn_boolean_t
name|closed
decl_stmt|;
name|svn_boolean_t
modifier|*
name|found_abs_paths
decl_stmt|;
comment|/* Did we strip an incoming '/' from the                                      paths?  */
name|svn_delta_fetch_props_func_t
name|fetch_props_func
decl_stmt|;
name|void
modifier|*
name|fetch_props_baton
decl_stmt|;
name|svn_delta_fetch_base_func_t
name|fetch_base_func
decl_stmt|;
name|void
modifier|*
name|fetch_base_baton
decl_stmt|;
name|svn_delta__unlock_func_t
name|do_unlock
decl_stmt|;
name|void
modifier|*
name|unlock_baton
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ev2_dir_baton
block|{
name|struct
name|ev2_edit_baton
modifier|*
name|eb
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|base_revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_relpath
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ev2_file_baton
block|{
name|struct
name|ev2_edit_baton
modifier|*
name|eb
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|svn_revnum_t
name|base_revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|delta_base
decl_stmt|;
block|}
struct|;
end_struct

begin_enum
enum|enum
name|restructure_action_t
block|{
name|RESTRUCTURE_NONE
init|=
literal|0
block|,
name|RESTRUCTURE_ADD
block|,
comment|/* add the node, maybe replacing. maybe copy  */
name|RESTRUCTURE_ADD_ABSENT
block|,
comment|/* add an absent node, possibly replacing  */
name|RESTRUCTURE_DELETE
comment|/* delete this node  */
block|}
enum|;
end_enum

begin_comment
comment|/* Records everything about how this node is to be changed.  */
end_comment

begin_struct
struct|struct
name|change_node
block|{
comment|/* what kind of (tree) restructure is occurring at this node?  */
name|enum
name|restructure_action_t
name|action
decl_stmt|;
name|svn_node_kind_t
name|kind
decl_stmt|;
comment|/* the NEW kind of this node  */
comment|/* We need two revisions: one to specify the revision we are altering,      and a second to specify the revision to delete/replace. These are      mutually exclusive, but they need to be separate to ensure we don't      confuse the operation on this node. For example, we may delete a      node and replace it we use DELETING for REPLACES_REV, and ignore      the value placed into CHANGING when properties were set/changed      on the new node. Or we simply change a node (setting CHANGING),      and DELETING remains SVN_INVALID_REVNUM, indicating we are not      attempting to replace a node.  */
name|svn_revnum_t
name|changing
decl_stmt|;
name|svn_revnum_t
name|deleting
decl_stmt|;
name|apr_hash_t
modifier|*
name|props
decl_stmt|;
comment|/* new/final set of props to apply  */
specifier|const
name|char
modifier|*
name|contents_abspath
decl_stmt|;
comment|/* file containing new fulltext  */
name|svn_checksum_t
modifier|*
name|checksum
decl_stmt|;
comment|/* checksum of new fulltext  */
comment|/* If COPYFROM_PATH is not NULL, then copy PATH@REV to this node.      RESTRUCTURE must be RESTRUCTURE_ADD.  */
specifier|const
name|char
modifier|*
name|copyfrom_path
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
decl_stmt|;
comment|/* Record whether an incoming propchange unlocked this node.  */
name|svn_boolean_t
name|unlock
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|struct
name|change_node
modifier|*
name|locate_change
parameter_list|(
name|struct
name|ev2_edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|)
block|{
name|struct
name|change_node
modifier|*
name|change
init|=
name|svn_hash_gets
argument_list|(
name|eb
operator|->
name|changes
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|change
operator|!=
name|NULL
condition|)
return|return
name|change
return|;
comment|/* Shift RELPATH into the proper pool, and record the observed order.  */
name|relpath
operator|=
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|edit_pool
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|eb
operator|->
name|path_order
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|relpath
expr_stmt|;
comment|/* Return an empty change. Callers will tweak as needed.  */
name|change
operator|=
name|apr_pcalloc
argument_list|(
name|eb
operator|->
name|edit_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|change
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|->
name|changing
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|change
operator|->
name|deleting
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|eb
operator|->
name|changes
argument_list|,
name|relpath
argument_list|,
name|change
argument_list|)
expr_stmt|;
return|return
name|change
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_propedit
parameter_list|(
name|struct
name|ev2_edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|change_node
modifier|*
name|change
init|=
name|locate_change
argument_list|(
name|eb
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|kind
operator|==
name|svn_node_unknown
operator|||
name|change
operator|->
name|kind
operator|==
name|kind
argument_list|)
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
comment|/* We're now changing the node. Record the revision.  */
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|change
operator|->
name|changing
argument_list|)
operator|||
name|change
operator|->
name|changing
operator|==
name|base_revision
argument_list|)
expr_stmt|;
name|change
operator|->
name|changing
operator|=
name|base_revision
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|props
operator|==
name|NULL
condition|)
block|{
comment|/* Fetch the original set of properties. We'll apply edits to create          the new/target set of properties.           If this is a copied/moved now, then the original properties come          from there. If the node has been added, it starts with empty props.          Otherwise, we get the properties from BASE.  */
if|if
condition|(
name|change
operator|->
name|copyfrom_path
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|fetch_props_func
argument_list|(
operator|&
name|change
operator|->
name|props
argument_list|,
name|eb
operator|->
name|fetch_props_baton
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_ADD
condition|)
name|change
operator|->
name|props
operator|=
name|apr_hash_make
argument_list|(
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|fetch_props_func
argument_list|(
operator|&
name|change
operator|->
name|props
argument_list|,
name|eb
operator|->
name|fetch_props_baton
argument_list|,
name|relpath
argument_list|,
name|base_revision
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
name|svn_hash_sets
argument_list|(
name|change
operator|->
name|props
argument_list|,
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|svn_hash_sets
argument_list|(
name|change
operator|->
name|props
argument_list|,
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|edit_pool
argument_list|,
name|name
argument_list|)
argument_list|,
name|svn_string_dup
argument_list|(
name|value
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Find all the paths which are immediate children of PATH and return their    basenames in a list. */
end_comment

begin_function
specifier|static
name|apr_array_header_t
modifier|*
name|get_children
parameter_list|(
name|struct
name|ev2_edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_array_header_t
modifier|*
name|children
init|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|child
decl_stmt|;
comment|/* Find potential children. */
name|child
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|path
argument_list|,
name|repos_relpath
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|child
operator|||
operator|!
operator|*
name|child
condition|)
continue|continue;
comment|/* If we have a path separator, it's a deep child, so just ignore it.          ### Is there an API we should be using for this? */
if|if
condition|(
name|strchr
argument_list|(
name|child
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
name|APR_ARRAY_PUSH
argument_list|(
name|children
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|child
expr_stmt|;
block|}
return|return
name|children
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|process_actions
parameter_list|(
name|struct
name|ev2_edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
specifier|const
name|struct
name|change_node
modifier|*
name|change
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_hash_t
modifier|*
name|props
init|=
name|NULL
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
init|=
name|NULL
decl_stmt|;
name|svn_checksum_t
modifier|*
name|checksum
init|=
name|NULL
decl_stmt|;
name|svn_node_kind_t
name|kind
init|=
name|svn_node_unknown
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|unlock
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|do_unlock
argument_list|(
name|eb
operator|->
name|unlock_baton
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
block|{
comment|/* If the action was left as RESTRUCTURE_DELETE, then a          replacement is not occurring. Just do the delete and bail.  */
name|SVN_ERR
argument_list|(
name|svn_editor_delete
argument_list|(
name|eb
operator|->
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|change
operator|->
name|deleting
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No further work possible on this node.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_ADD_ABSENT
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_editor_add_absent
argument_list|(
name|eb
operator|->
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|change
operator|->
name|kind
argument_list|,
name|change
operator|->
name|deleting
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No further work possible on this node.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|change
operator|->
name|contents_abspath
operator|!=
name|NULL
condition|)
block|{
comment|/* We can only set text on files. */
comment|/* ### validate we aren't overwriting KIND?  */
name|kind
operator|=
name|svn_node_file
expr_stmt|;
comment|/* ### the checksum might be in CHANGE->CHECKSUM  */
name|SVN_ERR
argument_list|(
name|svn_io_file_checksum2
argument_list|(
operator|&
name|checksum
argument_list|,
name|change
operator|->
name|contents_abspath
argument_list|,
name|svn_checksum_sha1
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|contents
argument_list|,
name|change
operator|->
name|contents_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|change
operator|->
name|props
operator|!=
name|NULL
condition|)
block|{
comment|/* ### validate we aren't overwriting KIND?  */
name|kind
operator|=
name|change
operator|->
name|kind
expr_stmt|;
name|props
operator|=
name|change
operator|->
name|props
expr_stmt|;
block|}
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_ADD
condition|)
block|{
comment|/* An add might be a replace. Grab the revnum we're replacing.  */
name|svn_revnum_t
name|replaces_rev
init|=
name|change
operator|->
name|deleting
decl_stmt|;
name|kind
operator|=
name|change
operator|->
name|kind
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|copyfrom_path
operator|!=
name|NULL
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_editor_copy
argument_list|(
name|eb
operator|->
name|editor
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|repos_relpath
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fall through to possibly make changes post-copy.  */
block|}
else|else
block|{
comment|/* If no properties were defined, then use an empty set.  */
if|if
condition|(
name|props
operator|==
name|NULL
condition|)
name|props
operator|=
name|apr_hash_make
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|children
decl_stmt|;
name|children
operator|=
name|get_children
argument_list|(
name|eb
argument_list|,
name|repos_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_add_directory
argument_list|(
name|eb
operator|->
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|children
argument_list|,
name|props
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* If this file was added, but apply_txdelta() was not                  called (ie. no CONTENTS_ABSPATH), then we're adding                  an empty file.  */
if|if
condition|(
name|change
operator|->
name|contents_abspath
operator|==
name|NULL
condition|)
block|{
name|contents
operator|=
name|svn_stream_empty
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|svn_checksum_empty_checksum
argument_list|(
name|svn_checksum_sha1
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_editor_add_file
argument_list|(
name|eb
operator|->
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|,
name|props
argument_list|,
name|replaces_rev
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* No further work possible on this node.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
block|}
if|#
directive|if
literal|0
comment|/* There *should* be work for this node. But it seems that isn't true      in some cases. Future investigation...  */
block|SVN_ERR_ASSERT(props || contents);
endif|#
directive|endif
if|if
condition|(
name|props
operator|||
name|contents
condition|)
block|{
comment|/* Changes to properties or content should have indicated the revision          it was intending to change.           Oop. Not true. The node may be locally-added.  */
if|#
directive|if
literal|0
block|SVN_ERR_ASSERT(SVN_IS_VALID_REVNUM(change->changing));
endif|#
directive|endif
comment|/* ### we need to gather up the target set of children  */
if|if
condition|(
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|svn_editor_alter_directory
argument_list|(
name|eb
operator|->
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|change
operator|->
name|changing
argument_list|,
name|NULL
argument_list|,
name|props
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_editor_alter_file
argument_list|(
name|eb
operator|->
name|editor
argument_list|,
name|repos_relpath
argument_list|,
name|change
operator|->
name|changing
argument_list|,
name|props
argument_list|,
name|checksum
argument_list|,
name|contents
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|run_ev2_actions
parameter_list|(
name|struct
name|ev2_edit_baton
modifier|*
name|eb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
decl_stmt|;
name|iterpool
operator|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Possibly pick up where we left off. Ocassionally, we do some of these      as part of close_edit() and then some more as part of abort_edit()  */
for|for
control|(
init|;
name|eb
operator|->
name|paths_processed
operator|<
name|eb
operator|->
name|path_order
operator|->
name|nelts
condition|;
operator|++
name|eb
operator|->
name|paths_processed
control|)
block|{
specifier|const
name|char
modifier|*
name|repos_relpath
init|=
name|APR_ARRAY_IDX
argument_list|(
name|eb
operator|->
name|path_order
argument_list|,
name|eb
operator|->
name|paths_processed
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|struct
name|change_node
modifier|*
name|change
init|=
name|svn_hash_gets
argument_list|(
name|eb
operator|->
name|changes
argument_list|,
name|repos_relpath
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|process_actions
argument_list|(
name|eb
argument_list|,
name|repos_relpath
argument_list|,
name|change
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|map_to_repos_relpath
parameter_list|(
name|struct
name|ev2_edit_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|path_or_url
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path_or_url
argument_list|)
condition|)
block|{
return|return
name|svn_uri_skip_ancestor
argument_list|(
name|eb
operator|->
name|repos_root
argument_list|,
name|path_or_url
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
else|else
block|{
return|return
name|svn_relpath_join
argument_list|(
name|eb
operator|->
name|base_relpath
argument_list|,
name|path_or_url
index|[
literal|0
index|]
operator|==
literal|'/'
condition|?
name|path_or_url
operator|+
literal|1
else|:
name|path_or_url
argument_list|,
name|result_pool
argument_list|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_set_target_revision
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
if|if
condition|(
name|eb
operator|->
name|exb
operator|->
name|target_revision
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|exb
operator|->
name|target_revision
argument_list|(
name|eb
operator|->
name|exb
operator|->
name|baton
argument_list|,
name|target_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_open_root
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|root_baton
parameter_list|)
block|{
name|struct
name|ev2_dir_baton
modifier|*
name|db
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ev2_edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|db
operator|->
name|eb
operator|=
name|eb
expr_stmt|;
name|db
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|edit_pool
argument_list|,
name|eb
operator|->
name|base_relpath
argument_list|)
expr_stmt|;
name|db
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
operator|*
name|root_baton
operator|=
name|db
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|exb
operator|->
name|start_edit
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|exb
operator|->
name|start_edit
argument_list|(
name|eb
operator|->
name|exb
operator|->
name|baton
argument_list|,
name|base_revision
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_delete_entry
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|svn_revnum_t
name|base_revision
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|locate_change
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|revision
argument_list|)
condition|)
name|base_revision
operator|=
name|revision
expr_stmt|;
else|else
name|base_revision
operator|=
name|pb
operator|->
name|base_revision
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_NONE
argument_list|)
expr_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_DELETE
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|change
operator|->
name|deleting
argument_list|)
operator|||
name|change
operator|->
name|deleting
operator|==
name|base_revision
argument_list|)
expr_stmt|;
name|change
operator|->
name|deleting
operator|=
name|base_revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_add_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
comment|/* ### fix this?  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|result_pool
decl_stmt|;
name|struct
name|ev2_dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|ev2_dir_baton
modifier|*
name|cb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|cb
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|locate_change
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
comment|/* ### assert that RESTRUCTURE is NONE or DELETE?  */
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|cb
operator|->
name|eb
operator|=
name|pb
operator|->
name|eb
expr_stmt|;
name|cb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
name|cb
operator|->
name|base_revision
operator|=
name|pb
operator|->
name|base_revision
expr_stmt|;
operator|*
name|child_baton
operator|=
name|cb
expr_stmt|;
if|if
condition|(
operator|!
name|copyfrom_path
condition|)
block|{
if|if
condition|(
name|pb
operator|->
name|copyfrom_relpath
condition|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_relpath_basename
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|cb
operator|->
name|copyfrom_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|copyfrom_relpath
argument_list|,
name|name
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|cb
operator|->
name|copyfrom_rev
operator|=
name|pb
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A copy */
name|change
operator|->
name|copyfrom_path
operator|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|copyfrom_path
argument_list|,
name|pb
operator|->
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_revision
expr_stmt|;
name|cb
operator|->
name|copyfrom_relpath
operator|=
name|change
operator|->
name|copyfrom_path
expr_stmt|;
name|cb
operator|->
name|copyfrom_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_open_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|child_baton
parameter_list|)
block|{
comment|/* ### fix this?  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|result_pool
decl_stmt|;
name|struct
name|ev2_dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
name|struct
name|ev2_dir_baton
modifier|*
name|db
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|db
operator|->
name|eb
operator|=
name|pb
operator|->
name|eb
expr_stmt|;
name|db
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
name|db
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|copyfrom_relpath
condition|)
block|{
comment|/* We are inside a copy. */
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_relpath_basename
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|db
operator|->
name|copyfrom_relpath
operator|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|copyfrom_relpath
argument_list|,
name|name
argument_list|,
name|result_pool
argument_list|)
expr_stmt|;
name|db
operator|->
name|copyfrom_rev
operator|=
name|pb
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
operator|*
name|child_baton
operator|=
name|db
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_change_dir_prop
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_dir_baton
modifier|*
name|db
init|=
name|dir_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|apply_propedit
argument_list|(
name|db
operator|->
name|eb
argument_list|,
name|db
operator|->
name|path
argument_list|,
name|svn_node_dir
argument_list|,
name|db
operator|->
name|base_revision
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_close_directory
parameter_list|(
name|void
modifier|*
name|dir_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_absent_directory
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|locate_change
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
comment|/* ### assert that RESTRUCTURE is NONE or DELETE?  */
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD_ABSENT
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_add_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|copyfrom_path
parameter_list|,
name|svn_revnum_t
name|copyfrom_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
comment|/* ### fix this?  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|result_pool
decl_stmt|;
name|struct
name|ev2_file_baton
modifier|*
name|fb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ev2_dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|locate_change
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
comment|/* ### assert that RESTRUCTURE is NONE or DELETE?  */
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|fb
operator|->
name|eb
operator|=
name|pb
operator|->
name|eb
expr_stmt|;
name|fb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
name|fb
operator|->
name|base_revision
operator|=
name|pb
operator|->
name|base_revision
expr_stmt|;
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
if|if
condition|(
operator|!
name|copyfrom_path
condition|)
block|{
comment|/* Don't bother fetching the base, as in an add we don't have a base. */
name|fb
operator|->
name|delta_base
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
comment|/* A copy */
name|change
operator|->
name|copyfrom_path
operator|=
name|map_to_repos_relpath
argument_list|(
name|fb
operator|->
name|eb
argument_list|,
name|copyfrom_path
argument_list|,
name|fb
operator|->
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|copyfrom_revision
expr_stmt|;
name|SVN_ERR
argument_list|(
name|fb
operator|->
name|eb
operator|->
name|fetch_base_func
argument_list|(
operator|&
name|fb
operator|->
name|delta_base
argument_list|,
name|fb
operator|->
name|eb
operator|->
name|fetch_base_baton
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_open_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|void
modifier|*
modifier|*
name|file_baton
parameter_list|)
block|{
comment|/* ### fix this?  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|result_pool
decl_stmt|;
name|struct
name|ev2_file_baton
modifier|*
name|fb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fb
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|ev2_dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|fb
operator|->
name|eb
operator|=
name|pb
operator|->
name|eb
expr_stmt|;
name|fb
operator|->
name|path
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
name|fb
operator|->
name|base_revision
operator|=
name|base_revision
expr_stmt|;
if|if
condition|(
name|pb
operator|->
name|copyfrom_relpath
condition|)
block|{
comment|/* We're in a copied directory, so the delta base is going to be          based up on the copy source. */
specifier|const
name|char
modifier|*
name|name
init|=
name|svn_relpath_basename
argument_list|(
name|relpath
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|copyfrom_relpath
init|=
name|svn_relpath_join
argument_list|(
name|pb
operator|->
name|copyfrom_relpath
argument_list|,
name|name
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|fb
operator|->
name|eb
operator|->
name|fetch_base_func
argument_list|(
operator|&
name|fb
operator|->
name|delta_base
argument_list|,
name|fb
operator|->
name|eb
operator|->
name|fetch_base_baton
argument_list|,
name|copyfrom_relpath
argument_list|,
name|pb
operator|->
name|copyfrom_rev
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|SVN_ERR
argument_list|(
name|fb
operator|->
name|eb
operator|->
name|fetch_base_func
argument_list|(
operator|&
name|fb
operator|->
name|delta_base
argument_list|,
name|fb
operator|->
name|eb
operator|->
name|fetch_base_baton
argument_list|,
name|relpath
argument_list|,
name|base_revision
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|file_baton
operator|=
name|fb
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|handler_baton
block|{
name|svn_txdelta_window_handler_t
name|apply_handler
decl_stmt|;
name|void
modifier|*
name|apply_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|source
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|handler_baton
modifier|*
name|hb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|err
operator|=
name|hb
operator|->
name|apply_handler
argument_list|(
name|window
argument_list|,
name|hb
operator|->
name|apply_baton
argument_list|)
expr_stmt|;
if|if
condition|(
name|window
operator|!=
name|NULL
operator|&&
operator|!
name|err
condition|)
return|return
name|SVN_NO_ERROR
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|hb
operator|->
name|source
argument_list|)
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|hb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_apply_textdelta
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|base_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|struct
name|ev2_file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|handler_pool
init|=
name|svn_pool_create
argument_list|(
name|fb
operator|->
name|eb
operator|->
name|edit_pool
argument_list|)
decl_stmt|;
name|struct
name|handler_baton
modifier|*
name|hb
init|=
name|apr_pcalloc
argument_list|(
name|handler_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|hb
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
decl_stmt|;
name|svn_stream_t
modifier|*
name|target
decl_stmt|;
comment|/* ### fix this. for now, we know this has a "short" lifetime.  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|handler_pool
decl_stmt|;
name|change
operator|=
name|locate_change
argument_list|(
name|fb
operator|->
name|eb
argument_list|,
name|fb
operator|->
name|path
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|contents_abspath
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
name|change
operator|->
name|changing
argument_list|)
operator|||
name|change
operator|->
name|changing
operator|==
name|fb
operator|->
name|base_revision
argument_list|)
expr_stmt|;
name|change
operator|->
name|changing
operator|=
name|fb
operator|->
name|base_revision
expr_stmt|;
if|if
condition|(
operator|!
name|fb
operator|->
name|delta_base
condition|)
name|hb
operator|->
name|source
operator|=
name|svn_stream_empty
argument_list|(
name|handler_pool
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|hb
operator|->
name|source
argument_list|,
name|fb
operator|->
name|delta_base
argument_list|,
name|handler_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|target
argument_list|,
operator|&
name|change
operator|->
name|contents_abspath
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|fb
operator|->
name|eb
operator|->
name|edit_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_txdelta_apply
argument_list|(
name|hb
operator|->
name|source
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|handler_pool
argument_list|,
operator|&
name|hb
operator|->
name|apply_handler
argument_list|,
operator|&
name|hb
operator|->
name|apply_baton
argument_list|)
expr_stmt|;
name|hb
operator|->
name|pool
operator|=
name|handler_pool
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|hb
expr_stmt|;
operator|*
name|handler
operator|=
name|window_handler
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_change_file_prop
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|svn_string_t
modifier|*
name|value
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_file_baton
modifier|*
name|fb
init|=
name|file_baton
decl_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
name|SVN_PROP_ENTRY_LOCK_TOKEN
argument_list|)
operator|&&
name|value
operator|==
name|NULL
condition|)
block|{
comment|/* We special case the lock token propery deletion, which is the          server's way of telling the client to unlock the path. */
comment|/* ### this duplicates much of apply_propedit(). fix in future.  */
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|fb
operator|->
name|eb
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|locate_change
argument_list|(
name|fb
operator|->
name|eb
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
name|change
operator|->
name|unlock
operator|=
name|TRUE
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|apply_propedit
argument_list|(
name|fb
operator|->
name|eb
argument_list|,
name|fb
operator|->
name|path
argument_list|,
name|svn_node_file
argument_list|,
name|fb
operator|->
name|base_revision
argument_list|,
name|name
argument_list|,
name|value
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_close_file
parameter_list|(
name|void
modifier|*
name|file_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|text_checksum
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_absent_file
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_dir_baton
modifier|*
name|pb
init|=
name|parent_baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
init|=
name|map_to_repos_relpath
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|path
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|locate_change
argument_list|(
name|pb
operator|->
name|eb
argument_list|,
name|relpath
argument_list|)
decl_stmt|;
comment|/* ### assert that RESTRUCTURE is NONE or DELETE?  */
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD_ABSENT
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_close_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|run_ev2_actions
argument_list|(
name|edit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|closed
operator|=
name|TRUE
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_editor_complete
argument_list|(
name|eb
operator|->
name|editor
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|ev2_abort_edit
parameter_list|(
name|void
modifier|*
name|edit_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|ev2_edit_baton
modifier|*
name|eb
init|=
name|edit_baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|run_ev2_actions
argument_list|(
name|edit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eb
operator|->
name|closed
condition|)
return|return
name|svn_error_trace
argument_list|(
name|svn_editor_abort
argument_list|(
name|eb
operator|->
name|editor
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return a svn_delta_editor_t * in DEDITOR, with an accompanying baton in  * DEDITOR_BATON, which will drive EDITOR.  These will both be  * allocated in RESULT_POOL, which may become large and long-lived;  * SCRATCH_POOL is used for temporary allocations.  *  * The other parameters are as follows:  *  - UNLOCK_FUNC / UNLOCK_BATON: A callback / baton which will be called  *         when an unlocking action is received.  *  - FOUND_ABS_PATHS: A pointer to a boolean flag which will be set if  *         this shim determines that it is receiving absolute paths.  *  - FETCH_PROPS_FUNC / FETCH_PROPS_BATON: A callback / baton pair which  *         will be used by the shim handlers if they need to determine the  *         existing properties on a  path.  *  - FETCH_BASE_FUNC / FETCH_BASE_BATON: A callback / baton pair which will  *         be used by the shims handlers if they need to determine the base  *         text of a path.  It should only be invoked for files.  *  - EXB: An 'extra baton' which is used to communicate between the shims.  *         Its callbacks should be invoked at the appropriate time by this  *         shim.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_delta__delta_from_editor
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|deditor
parameter_list|,
name|void
modifier|*
modifier|*
name|dedit_baton
parameter_list|,
name|svn_editor_t
modifier|*
name|editor
parameter_list|,
name|svn_delta__unlock_func_t
name|unlock_func
parameter_list|,
name|void
modifier|*
name|unlock_baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|found_abs_paths
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root
parameter_list|,
specifier|const
name|char
modifier|*
name|base_relpath
parameter_list|,
name|svn_delta_fetch_props_func_t
name|fetch_props_func
parameter_list|,
name|void
modifier|*
name|fetch_props_baton
parameter_list|,
name|svn_delta_fetch_base_func_t
name|fetch_base_func
parameter_list|,
name|void
modifier|*
name|fetch_base_baton
parameter_list|,
name|struct
name|svn_delta__extra_baton
modifier|*
name|exb
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Static 'cause we don't want it to be on the stack. */
specifier|static
name|svn_delta_editor_t
name|delta_editor
init|=
block|{
name|ev2_set_target_revision
block|,
name|ev2_open_root
block|,
name|ev2_delete_entry
block|,
name|ev2_add_directory
block|,
name|ev2_open_directory
block|,
name|ev2_change_dir_prop
block|,
name|ev2_close_directory
block|,
name|ev2_absent_directory
block|,
name|ev2_add_file
block|,
name|ev2_open_file
block|,
name|ev2_apply_textdelta
block|,
name|ev2_change_file_prop
block|,
name|ev2_close_file
block|,
name|ev2_absent_file
block|,
name|ev2_close_edit
block|,
name|ev2_abort_edit
block|}
decl_stmt|;
name|struct
name|ev2_edit_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|base_relpath
condition|)
name|base_relpath
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|base_relpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|base_relpath
operator|+=
literal|1
expr_stmt|;
name|eb
operator|->
name|editor
operator|=
name|editor
expr_stmt|;
name|eb
operator|->
name|changes
operator|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|path_order
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|edit_pool
operator|=
name|pool
expr_stmt|;
name|eb
operator|->
name|found_abs_paths
operator|=
name|found_abs_paths
expr_stmt|;
operator|*
name|eb
operator|->
name|found_abs_paths
operator|=
name|FALSE
expr_stmt|;
name|eb
operator|->
name|exb
operator|=
name|exb
expr_stmt|;
name|eb
operator|->
name|repos_root
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|repos_root
argument_list|)
expr_stmt|;
name|eb
operator|->
name|base_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|base_relpath
argument_list|)
expr_stmt|;
name|eb
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|eb
operator|->
name|fetch_props_baton
operator|=
name|fetch_props_baton
expr_stmt|;
name|eb
operator|->
name|fetch_base_func
operator|=
name|fetch_base_func
expr_stmt|;
name|eb
operator|->
name|fetch_base_baton
operator|=
name|fetch_base_baton
expr_stmt|;
name|eb
operator|->
name|do_unlock
operator|=
name|unlock_func
expr_stmt|;
name|eb
operator|->
name|unlock_baton
operator|=
name|unlock_baton
expr_stmt|;
operator|*
name|dedit_baton
operator|=
name|eb
expr_stmt|;
operator|*
name|deditor
operator|=
operator|&
name|delta_editor
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* ### note the similarity to struct change_node. these structures will    ### be combined in the future.  */
end_comment

begin_struct
struct|struct
name|operation
block|{
comment|/* ### leave these two here for now. still used.  */
name|svn_revnum_t
name|base_revision
decl_stmt|;
name|void
modifier|*
name|baton
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|editor_baton
block|{
specifier|const
name|svn_delta_editor_t
modifier|*
name|deditor
decl_stmt|;
name|void
modifier|*
name|dedit_baton
decl_stmt|;
name|svn_delta_fetch_kind_func_t
name|fetch_kind_func
decl_stmt|;
name|void
modifier|*
name|fetch_kind_baton
decl_stmt|;
name|svn_delta_fetch_props_func_t
name|fetch_props_func
decl_stmt|;
name|void
modifier|*
name|fetch_props_baton
decl_stmt|;
name|struct
name|operation
name|root
decl_stmt|;
name|svn_boolean_t
modifier|*
name|make_abs_paths
decl_stmt|;
specifier|const
name|char
modifier|*
name|repos_root
decl_stmt|;
specifier|const
name|char
modifier|*
name|base_relpath
decl_stmt|;
comment|/* REPOS_RELPATH -> struct change_node *  */
name|apr_hash_t
modifier|*
name|changes
decl_stmt|;
name|apr_pool_t
modifier|*
name|edit_pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Insert a new change for RELPATH, or return an existing one.  */
end_comment

begin_function
specifier|static
name|struct
name|change_node
modifier|*
name|insert_change
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|apr_hash_t
modifier|*
name|changes
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|result_pool
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
decl_stmt|;
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|changes
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|!=
name|NULL
condition|)
return|return
name|change
return|;
name|result_pool
operator|=
name|apr_hash_pool_get
argument_list|(
name|changes
argument_list|)
expr_stmt|;
comment|/* Return an empty change. Callers will tweak as needed.  */
name|change
operator|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|change
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|->
name|changing
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|change
operator|->
name|deleting
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|changes
argument_list|,
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|relpath
argument_list|)
argument_list|,
name|change
argument_list|)
expr_stmt|;
return|return
name|change
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_directory_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_directory_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|change
operator|->
name|deleting
operator|=
name|replaces_rev
expr_stmt|;
name|change
operator|->
name|props
operator|=
name|svn_prop_hash_dup
argument_list|(
name|props
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_file_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_file_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_filename
decl_stmt|;
name|svn_stream_t
modifier|*
name|tmp_stream
decl_stmt|;
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
comment|/* We may need to re-checksum these contents */
if|if
condition|(
operator|!
operator|(
name|checksum
operator|&&
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_md5
operator|)
condition|)
name|contents
operator|=
name|svn_stream_checksummed2
argument_list|(
name|contents
argument_list|,
operator|&
name|md5_checksum
argument_list|,
name|NULL
argument_list|,
name|svn_checksum_md5
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|md5_checksum
operator|=
operator|(
name|svn_checksum_t
operator|*
operator|)
name|checksum
expr_stmt|;
comment|/* Spool the contents to a tempfile, and provide that to the driver. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tmp_stream
argument_list|,
operator|&
name|tmp_filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|tmp_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|change
operator|->
name|deleting
operator|=
name|replaces_rev
expr_stmt|;
name|change
operator|->
name|props
operator|=
name|svn_prop_hash_dup
argument_list|(
name|props
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
name|change
operator|->
name|contents_abspath
operator|=
name|tmp_filename
expr_stmt|;
name|change
operator|->
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|md5_checksum
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_symlink_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_symlink_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
if|#
directive|if
literal|0
block|struct editor_baton *eb = baton;   struct change_node *change = insert_change(relpath, eb->changes);    change->action = RESTRUCTURE_ADD;   change->kind = svn_node_symlink;   change->deleting = replaces_rev;   change->props = svn_prop_hash_dup(props, eb->edit_pool);
comment|/* ### target  */
endif|#
directive|endif
name|SVN__NOT_IMPLEMENTED
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_add_absent_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|add_absent_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_node_kind_t
name|kind
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD_ABSENT
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|kind
expr_stmt|;
name|change
operator|->
name|deleting
operator|=
name|replaces_rev
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_directory_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_directory_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|children
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
comment|/* ### should we verify the kind is truly a directory?  */
comment|/* ### do we need to do anything with CHILDREN?  */
comment|/* Note: this node may already have information in CHANGE as a result      of an earlier copy/move operation.  */
name|change
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
name|change
operator|->
name|changing
operator|=
name|revision
expr_stmt|;
name|change
operator|->
name|props
operator|=
name|svn_prop_hash_dup
argument_list|(
name|props
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_file_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_file_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|svn_checksum_t
modifier|*
name|checksum
parameter_list|,
name|svn_stream_t
modifier|*
name|contents
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|tmp_filename
decl_stmt|;
name|svn_stream_t
modifier|*
name|tmp_stream
decl_stmt|;
name|svn_checksum_t
modifier|*
name|md5_checksum
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
comment|/* ### should we verify the kind is truly a file?  */
if|if
condition|(
name|contents
condition|)
block|{
comment|/* We may need to re-checksum these contents */
if|if
condition|(
operator|!
operator|(
name|checksum
operator|&&
name|checksum
operator|->
name|kind
operator|==
name|svn_checksum_md5
operator|)
condition|)
name|contents
operator|=
name|svn_stream_checksummed2
argument_list|(
name|contents
argument_list|,
operator|&
name|md5_checksum
argument_list|,
name|NULL
argument_list|,
name|svn_checksum_md5
argument_list|,
name|TRUE
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|md5_checksum
operator|=
operator|(
name|svn_checksum_t
operator|*
operator|)
name|checksum
expr_stmt|;
comment|/* Spool the contents to a tempfile, and provide that to the driver. */
name|SVN_ERR
argument_list|(
name|svn_stream_open_unique
argument_list|(
operator|&
name|tmp_stream
argument_list|,
operator|&
name|tmp_filename
argument_list|,
name|NULL
argument_list|,
name|svn_io_file_del_on_pool_cleanup
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_copy3
argument_list|(
name|contents
argument_list|,
name|tmp_stream
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Note: this node may already have information in CHANGE as a result      of an earlier copy/move operation.  */
name|change
operator|->
name|kind
operator|=
name|svn_node_file
expr_stmt|;
name|change
operator|->
name|changing
operator|=
name|revision
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|change
operator|->
name|props
operator|=
name|svn_prop_hash_dup
argument_list|(
name|props
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|contents
operator|!=
name|NULL
condition|)
block|{
name|change
operator|->
name|contents_abspath
operator|=
name|tmp_filename
expr_stmt|;
name|change
operator|->
name|checksum
operator|=
name|svn_checksum_dup
argument_list|(
name|md5_checksum
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_alter_symlink_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|alter_symlink_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_hash_t
modifier|*
name|props
parameter_list|,
specifier|const
name|char
modifier|*
name|target
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
comment|/* ### should we verify the kind is truly a symlink?  */
comment|/* ### do something  */
name|SVN__NOT_IMPLEMENTED
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_delete_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|delete_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|relpath
parameter_list|,
name|svn_revnum_t
name|revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_DELETE
expr_stmt|;
comment|/* change->kind = svn_node_unknown;  */
name|change
operator|->
name|deleting
operator|=
name|revision
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_copy_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|copy_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|svn_revnum_t
name|src_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|dst_relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD
expr_stmt|;
comment|/* change->kind = svn_node_unknown;  */
name|change
operator|->
name|deleting
operator|=
name|replaces_rev
expr_stmt|;
name|change
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|edit_pool
argument_list|,
name|src_relpath
argument_list|)
expr_stmt|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|src_revision
expr_stmt|;
comment|/* We need the source's kind to know whether to call add_directory()      or add_file() later on.  */
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|fetch_kind_func
argument_list|(
operator|&
name|change
operator|->
name|kind
argument_list|,
name|eb
operator|->
name|fetch_kind_baton
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: this node may later have alter_*() called on it.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_move_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|move_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|src_relpath
parameter_list|,
name|svn_revnum_t
name|src_revision
parameter_list|,
specifier|const
name|char
modifier|*
name|dst_relpath
parameter_list|,
name|svn_revnum_t
name|replaces_rev
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|struct
name|change_node
modifier|*
name|change
decl_stmt|;
comment|/* Remap a move into a DELETE + COPY.  */
name|change
operator|=
name|insert_change
argument_list|(
name|src_relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
expr_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_DELETE
expr_stmt|;
comment|/* change->kind = svn_node_unknown;  */
name|change
operator|->
name|deleting
operator|=
name|src_revision
expr_stmt|;
name|change
operator|=
name|insert_change
argument_list|(
name|dst_relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
expr_stmt|;
name|change
operator|->
name|action
operator|=
name|RESTRUCTURE_ADD
expr_stmt|;
comment|/* change->kind = svn_node_unknown;  */
name|change
operator|->
name|deleting
operator|=
name|replaces_rev
expr_stmt|;
name|change
operator|->
name|copyfrom_path
operator|=
name|apr_pstrdup
argument_list|(
name|eb
operator|->
name|edit_pool
argument_list|,
name|src_relpath
argument_list|)
expr_stmt|;
name|change
operator|->
name|copyfrom_rev
operator|=
name|src_revision
expr_stmt|;
comment|/* We need the source's kind to know whether to call add_directory()      or add_file() later on.  */
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|fetch_kind_func
argument_list|(
operator|&
name|change
operator|->
name|kind
argument_list|,
name|eb
operator|->
name|fetch_kind_baton
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Note: this node may later have alter_*() called on it.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_rotate_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|rotate_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|relpaths
parameter_list|,
specifier|const
name|apr_array_header_t
modifier|*
name|revisions
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|SVN__NOT_IMPLEMENTED
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|count_components
parameter_list|(
specifier|const
name|char
modifier|*
name|relpath
parameter_list|)
block|{
name|int
name|count
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash
init|=
name|strchr
argument_list|(
name|relpath
argument_list|,
literal|'/'
argument_list|)
decl_stmt|;
while|while
condition|(
name|slash
operator|!=
name|NULL
condition|)
block|{
operator|++
name|count
expr_stmt|;
name|slash
operator|=
name|strchr
argument_list|(
name|slash
operator|+
literal|1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
block|}
return|return
name|count
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|sort_deletes_first
parameter_list|(
specifier|const
name|svn_sort__item_t
modifier|*
name|item1
parameter_list|,
specifier|const
name|svn_sort__item_t
modifier|*
name|item2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|relpath1
init|=
name|item1
operator|->
name|key
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath2
init|=
name|item2
operator|->
name|key
decl_stmt|;
specifier|const
name|struct
name|change_node
modifier|*
name|change1
init|=
name|item1
operator|->
name|value
decl_stmt|;
specifier|const
name|struct
name|change_node
modifier|*
name|change2
init|=
name|item2
operator|->
name|value
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash1
decl_stmt|;
specifier|const
name|char
modifier|*
name|slash2
decl_stmt|;
name|ptrdiff_t
name|len1
decl_stmt|;
name|ptrdiff_t
name|len2
decl_stmt|;
comment|/* Force the root to always sort first. Otherwise, it may look like a      sibling of its children (no slashes), and could get sorted *after*      any children that get deleted.  */
if|if
condition|(
operator|*
name|relpath1
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
name|relpath2
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
comment|/* Are these two items siblings? The 'if' statement tests if they are      siblings in the root directory, or that slashes were found in both      paths, that the length of the paths to those slashes match, and that      the path contents up to those slashes also match.  */
name|slash1
operator|=
name|strrchr
argument_list|(
name|relpath1
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|slash2
operator|=
name|strrchr
argument_list|(
name|relpath2
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|slash1
operator|==
name|NULL
operator|&&
name|slash2
operator|==
name|NULL
operator|)
operator|||
operator|(
name|slash1
operator|!=
name|NULL
operator|&&
name|slash2
operator|!=
name|NULL
operator|&&
operator|(
name|len1
operator|=
name|slash1
operator|-
name|relpath1
operator|)
operator|==
operator|(
name|len2
operator|=
name|slash2
operator|-
name|relpath2
operator|)
operator|&&
name|memcmp
argument_list|(
name|relpath1
argument_list|,
name|relpath2
argument_list|,
name|len1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|change1
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
block|{
if|if
condition|(
name|change2
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
block|{
comment|/* If both items are being deleted, then we don't care about                  the order. State they are equal.  */
return|return
literal|0
return|;
block|}
comment|/* ITEM1 is being deleted. Sort it before the surviving item.  */
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|change2
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
comment|/* ITEM2 is being deleted. Sort it before the surviving item.  */
return|return
literal|1
return|;
comment|/* Normally, we don't care about the ordering of two siblings. However,          if these siblings are directories, then we need to provide an          ordering so that the quicksort algorithm will further sort them          relative to the maybe-directory's children.           Without this additional ordering, we could see that A/B/E and A/B/F          are equal. And then A/B/E/child is sorted before A/B/F. But since          E and F are "equal", A/B/E could arrive *after* A/B/F and after the          A/B/E/child node.  */
comment|/* FALLTHROUGH */
block|}
comment|/* Paths-to-be-deleted with fewer components always sort earlier.       For example, gamma will sort before E/alpha.       Without this test, E/alpha lexicographically sorts before gamma,      but gamma sorts before E when gamma is to be deleted. This kind of      ordering would place E/alpha before E. Not good.       With this test, gamma sorts before E/alpha. E and E/alpha are then      sorted by svn_path_compare_paths() (which places E before E/alpha).  */
if|if
condition|(
name|change1
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
operator|||
name|change2
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
block|{
name|int
name|count1
init|=
name|count_components
argument_list|(
name|relpath1
argument_list|)
decl_stmt|;
name|int
name|count2
init|=
name|count_components
argument_list|(
name|relpath2
argument_list|)
decl_stmt|;
if|if
condition|(
name|count1
operator|<
name|count2
operator|&&
name|change1
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|count1
operator|>
name|count2
operator|&&
name|change2
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
return|return
literal|1
return|;
block|}
comment|/* Use svn_path_compare_paths() to get correct depth-based ordering.  */
return|return
name|svn_path_compare_paths
argument_list|(
name|relpath1
argument_list|,
name|relpath2
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|apr_array_header_t
modifier|*
name|get_sorted_paths
parameter_list|(
name|apr_hash_t
modifier|*
name|changes
parameter_list|,
specifier|const
name|char
modifier|*
name|base_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
specifier|const
name|apr_array_header_t
modifier|*
name|items
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Construct a sorted array of svn_sort__item_t structs. Within a given      directory, nodes that are to be deleted will appear first.  */
name|items
operator|=
name|svn_sort__hash
argument_list|(
name|changes
argument_list|,
name|sort_deletes_first
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
comment|/* Build a new array with just the paths, trimmed to relative paths for      the Ev1 drive.  */
name|paths
operator|=
name|apr_array_make
argument_list|(
name|scratch_pool
argument_list|,
name|items
operator|->
name|nelts
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|items
operator|->
name|nelts
init|;
name|i
operator|--
condition|;
control|)
block|{
specifier|const
name|svn_sort__item_t
modifier|*
name|item
decl_stmt|;
name|item
operator|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|items
argument_list|,
name|i
argument_list|,
specifier|const
name|svn_sort__item_t
argument_list|)
expr_stmt|;
name|APR_ARRAY_IDX
argument_list|(
name|paths
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|svn_relpath_skip_ancestor
argument_list|(
name|base_relpath
argument_list|,
name|item
operator|->
name|key
argument_list|)
expr_stmt|;
block|}
comment|/* We didn't use PUSH, so set the proper number of elements.  */
name|paths
operator|->
name|nelts
operator|=
name|items
operator|->
name|nelts
expr_stmt|;
return|return
name|paths
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|drive_ev1_props
parameter_list|(
specifier|const
name|struct
name|editor_baton
modifier|*
name|eb
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_relpath
parameter_list|,
specifier|const
name|struct
name|change_node
modifier|*
name|change
parameter_list|,
name|void
modifier|*
name|node_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|iterpool
init|=
name|svn_pool_create
argument_list|(
name|scratch_pool
argument_list|)
decl_stmt|;
name|apr_hash_t
modifier|*
name|old_props
decl_stmt|;
name|apr_array_header_t
modifier|*
name|propdiffs
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* If there are no properties to install, then just exit.  */
if|if
condition|(
name|change
operator|->
name|props
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
if|if
condition|(
name|change
operator|->
name|copyfrom_path
condition|)
block|{
comment|/* The pristine properties are from the copy/move source.  */
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|fetch_props_func
argument_list|(
operator|&
name|old_props
argument_list|,
name|eb
operator|->
name|fetch_props_baton
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|change
operator|->
name|copyfrom_rev
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_ADD
condition|)
block|{
comment|/* Locally-added nodes have no pristine properties.           Note: we can use iterpool; this hash only needs to survive to          the propdiffs call, and there are no contents to preserve.  */
name|old_props
operator|=
name|apr_hash_make
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Fetch the pristine properties for whatever we're editing.  */
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|fetch_props_func
argument_list|(
operator|&
name|old_props
argument_list|,
name|eb
operator|->
name|fetch_props_baton
argument_list|,
name|repos_relpath
argument_list|,
name|change
operator|->
name|changing
argument_list|,
name|scratch_pool
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_prop_diffs
argument_list|(
operator|&
name|propdiffs
argument_list|,
name|change
operator|->
name|props
argument_list|,
name|old_props
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|propdiffs
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
comment|/* Note: the array returned by svn_prop_diffs() is an array of          actual structures, not pointers to them. */
specifier|const
name|svn_prop_t
modifier|*
name|prop
init|=
operator|&
name|APR_ARRAY_IDX
argument_list|(
name|propdiffs
argument_list|,
name|i
argument_list|,
name|svn_prop_t
argument_list|)
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|change_dir_prop
argument_list|(
name|node_baton
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|change_file_prop
argument_list|(
name|node_baton
argument_list|,
name|prop
operator|->
name|name
argument_list|,
name|prop
operator|->
name|value
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Handle the funky unlock protocol. Note: only possibly on files.  */
if|if
condition|(
name|change
operator|->
name|unlock
condition|)
block|{
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|kind
operator|==
name|svn_node_file
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|change_file_prop
argument_list|(
name|node_baton
argument_list|,
name|SVN_PROP_ENTRY_LOCK_TOKEN
argument_list|,
name|NULL
argument_list|,
name|iterpool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|iterpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Conforms to svn_delta_path_driver_cb_func_t  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|apply_change
parameter_list|(
name|void
modifier|*
modifier|*
name|dir_baton
parameter_list|,
name|void
modifier|*
name|parent_baton
parameter_list|,
name|void
modifier|*
name|callback_baton
parameter_list|,
specifier|const
name|char
modifier|*
name|ev1_relpath
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
comment|/* ### fix this?  */
name|apr_pool_t
modifier|*
name|scratch_pool
init|=
name|result_pool
decl_stmt|;
specifier|const
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|callback_baton
decl_stmt|;
specifier|const
name|struct
name|change_node
modifier|*
name|change
decl_stmt|;
specifier|const
name|char
modifier|*
name|relpath
decl_stmt|;
name|void
modifier|*
name|file_baton
init|=
name|NULL
decl_stmt|;
comment|/* Typically, we are not creating new directory batons.  */
operator|*
name|dir_baton
operator|=
name|NULL
expr_stmt|;
name|relpath
operator|=
name|svn_relpath_join
argument_list|(
name|eb
operator|->
name|base_relpath
argument_list|,
name|ev1_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|change
operator|=
name|svn_hash_gets
argument_list|(
name|eb
operator|->
name|changes
argument_list|,
name|relpath
argument_list|)
expr_stmt|;
comment|/* The callback should only be called for paths in CHANGES.  */
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* Are we editing the root of the tree?  */
if|if
condition|(
name|parent_baton
operator|==
name|NULL
condition|)
block|{
comment|/* The root was opened in start_edit_func()  */
operator|*
name|dir_baton
operator|=
name|eb
operator|->
name|root
operator|.
name|baton
expr_stmt|;
comment|/* Only property edits are allowed on the root.  */
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_NONE
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|drive_ev1_props
argument_list|(
name|eb
argument_list|,
name|relpath
argument_list|,
name|change
argument_list|,
operator|*
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No further action possible for the root.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_DELETE
condition|)
block|{
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|delete_entry
argument_list|(
name|ev1_relpath
argument_list|,
name|change
operator|->
name|deleting
argument_list|,
name|parent_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No futher action possible for this node.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* If we're not deleting this node, then we should know its kind.  */
name|SVN_ERR_ASSERT
argument_list|(
name|change
operator|->
name|kind
operator|!=
name|svn_node_unknown
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_ADD_ABSENT
condition|)
block|{
if|if
condition|(
name|change
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|absent_directory
argument_list|(
name|ev1_relpath
argument_list|,
name|parent_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|absent_file
argument_list|(
name|ev1_relpath
argument_list|,
name|parent_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* No further action possible for this node.  */
return|return
name|SVN_NO_ERROR
return|;
block|}
comment|/* RESTRUCTURE_NONE or RESTRUCTURE_ADD  */
if|if
condition|(
name|change
operator|->
name|action
operator|==
name|RESTRUCTURE_ADD
condition|)
block|{
specifier|const
name|char
modifier|*
name|copyfrom_url
init|=
name|NULL
decl_stmt|;
name|svn_revnum_t
name|copyfrom_rev
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
comment|/* Do we have an old node to delete first?  */
if|if
condition|(
name|SVN_IS_VALID_REVNUM
argument_list|(
name|change
operator|->
name|deleting
argument_list|)
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|delete_entry
argument_list|(
name|ev1_relpath
argument_list|,
name|change
operator|->
name|deleting
argument_list|,
name|parent_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Are we copying the node from somewhere?  */
if|if
condition|(
name|change
operator|->
name|copyfrom_path
condition|)
block|{
if|if
condition|(
name|eb
operator|->
name|repos_root
condition|)
name|copyfrom_url
operator|=
name|svn_path_url_add_component2
argument_list|(
name|eb
operator|->
name|repos_root
argument_list|,
name|change
operator|->
name|copyfrom_path
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
else|else
name|copyfrom_url
operator|=
name|change
operator|->
name|copyfrom_path
expr_stmt|;
comment|/* Make this an FS path by prepending "/" */
if|if
condition|(
name|copyfrom_url
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
name|copyfrom_url
operator|=
name|apr_pstrcat
argument_list|(
name|scratch_pool
argument_list|,
literal|"/"
argument_list|,
name|copyfrom_url
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|copyfrom_rev
operator|=
name|change
operator|->
name|copyfrom_rev
expr_stmt|;
block|}
if|if
condition|(
name|change
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|add_directory
argument_list|(
name|ev1_relpath
argument_list|,
name|parent_baton
argument_list|,
name|copyfrom_url
argument_list|,
name|copyfrom_rev
argument_list|,
name|result_pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|add_file
argument_list|(
name|ev1_relpath
argument_list|,
name|parent_baton
argument_list|,
name|copyfrom_url
argument_list|,
name|copyfrom_rev
argument_list|,
name|result_pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|change
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|open_directory
argument_list|(
name|ev1_relpath
argument_list|,
name|parent_baton
argument_list|,
name|change
operator|->
name|changing
argument_list|,
name|result_pool
argument_list|,
name|dir_baton
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|open_file
argument_list|(
name|ev1_relpath
argument_list|,
name|parent_baton
argument_list|,
name|change
operator|->
name|changing
argument_list|,
name|result_pool
argument_list|,
operator|&
name|file_baton
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Apply any properties in CHANGE to the node.  */
if|if
condition|(
name|change
operator|->
name|kind
operator|==
name|svn_node_dir
condition|)
name|SVN_ERR
argument_list|(
name|drive_ev1_props
argument_list|(
name|eb
argument_list|,
name|relpath
argument_list|,
name|change
argument_list|,
operator|*
name|dir_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|drive_ev1_props
argument_list|(
name|eb
argument_list|,
name|relpath
argument_list|,
name|change
argument_list|,
name|file_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|change
operator|->
name|contents_abspath
condition|)
block|{
name|svn_txdelta_window_handler_t
name|handler
decl_stmt|;
name|void
modifier|*
name|handler_baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|contents
decl_stmt|;
comment|/* ### would be nice to have a BASE_CHECKSUM, but hey: this is the          ### shim code...  */
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|apply_textdelta
argument_list|(
name|file_baton
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|,
operator|&
name|handler
argument_list|,
operator|&
name|handler_baton
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_open_readonly
argument_list|(
operator|&
name|contents
argument_list|,
name|change
operator|->
name|contents_abspath
argument_list|,
name|scratch_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* ### it would be nice to send a true txdelta here, but whatever.  */
name|SVN_ERR
argument_list|(
name|svn_txdelta_send_stream
argument_list|(
name|contents
argument_list|,
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|NULL
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_close
argument_list|(
name|contents
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|file_baton
condition|)
block|{
specifier|const
name|char
modifier|*
name|digest
init|=
name|svn_checksum_to_cstring
argument_list|(
name|change
operator|->
name|checksum
argument_list|,
name|scratch_pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|close_file
argument_list|(
name|file_baton
argument_list|,
name|digest
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|drive_changes
parameter_list|(
specifier|const
name|struct
name|editor_baton
modifier|*
name|eb
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|change_node
modifier|*
name|change
decl_stmt|;
specifier|const
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
comment|/* If we never opened a root baton, then the caller aborted the editor      before it even began. There is nothing to do. Bail.  */
if|if
condition|(
name|eb
operator|->
name|root
operator|.
name|baton
operator|==
name|NULL
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* We need to make the path driver believe we want to make changes to      the root. Otherwise, it will attempt an open_root(), which we already      did in start_edit_func(). We can forge up a change record, if one      does not already exist.  */
name|change
operator|=
name|insert_change
argument_list|(
name|eb
operator|->
name|base_relpath
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
expr_stmt|;
name|change
operator|->
name|kind
operator|=
name|svn_node_dir
expr_stmt|;
comment|/* No property changes (tho they might exist from a real change).  */
comment|/* Get a sorted list of Ev1-relative paths.  */
name|paths
operator|=
name|get_sorted_paths
argument_list|(
name|eb
operator|->
name|changes
argument_list|,
name|eb
operator|->
name|base_relpath
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta_path_driver2
argument_list|(
name|eb
operator|->
name|deditor
argument_list|,
name|eb
operator|->
name|dedit_baton
argument_list|,
name|paths
argument_list|,
name|FALSE
argument_list|,
name|apply_change
argument_list|,
operator|(
name|void
operator|*
operator|)
name|eb
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_complete_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|complete_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Drive the tree we've created. */
name|err
operator|=
name|drive_changes
argument_list|(
name|eb
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
block|{
name|err
operator|=
name|svn_error_compose_create
argument_list|(
name|err
argument_list|,
name|eb
operator|->
name|deditor
operator|->
name|close_edit
argument_list|(
name|eb
operator|->
name|dedit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|abort_edit
argument_list|(
name|eb
operator|->
name|dedit_baton
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements svn_editor_cb_abort_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|abort_cb
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_error_t
modifier|*
name|err2
decl_stmt|;
comment|/* We still need to drive anything we collected in the editor to this      point. */
comment|/* Drive the tree we've created. */
name|err
operator|=
name|drive_changes
argument_list|(
name|eb
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
name|err2
operator|=
name|eb
operator|->
name|deditor
operator|->
name|abort_edit
argument_list|(
name|eb
operator|->
name|dedit_baton
argument_list|,
name|scratch_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err2
condition|)
block|{
if|if
condition|(
name|err
condition|)
name|svn_error_clear
argument_list|(
name|err2
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|err2
expr_stmt|;
block|}
return|return
name|svn_error_trace
argument_list|(
name|err
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|start_edit_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_revnum_t
name|base_revision
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|eb
operator|->
name|root
operator|.
name|base_revision
operator|=
name|base_revision
expr_stmt|;
comment|/* For some Ev1 editors (such as the repos commit editor), the root must      be open before can invoke any callbacks. The open_root() call sets up      stuff (eg. open an FS txn) which will be needed.  */
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|open_root
argument_list|(
name|eb
operator|->
name|dedit_baton
argument_list|,
name|eb
operator|->
name|root
operator|.
name|base_revision
argument_list|,
name|eb
operator|->
name|edit_pool
argument_list|,
operator|&
name|eb
operator|->
name|root
operator|.
name|baton
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|target_revision_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_revnum_t
name|target_revision
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|SVN_ERR
argument_list|(
name|eb
operator|->
name|deditor
operator|->
name|set_target_revision
argument_list|(
name|eb
operator|->
name|dedit_baton
argument_list|,
name|target_revision
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|do_unlock
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
block|{
comment|/* PATH is REPOS_RELPATH  */
name|struct
name|change_node
modifier|*
name|change
init|=
name|insert_change
argument_list|(
name|path
argument_list|,
name|eb
operator|->
name|changes
argument_list|)
decl_stmt|;
comment|/* We will need to propagate a deletion of SVN_PROP_ENTRY_LOCK_TOKEN  */
name|change
operator|->
name|unlock
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Return an svn_editor_t * in EDITOR_P which will drive  * DEDITOR/DEDIT_BATON.  EDITOR_P is allocated in RESULT_POOL, which may  * become large and long-lived; SCRATCH_POOL is used for temporary  * allocations.  *  * The other parameters are as follows:  *  - EXB: An 'extra_baton' used for passing information between the coupled  *         shims.  This includes actions like 'start edit' and 'set target'.  *         As this shim receives these actions, it provides the extra baton  *         to its caller.  *  - UNLOCK_FUNC / UNLOCK_BATON: A callback / baton pair which a caller  *         can use to notify this shim that a path should be unlocked (in the  *         'svn lock' sense).  As this shim receives this action, it provides  *         this callback / baton to its caller.  *  - SEND_ABS_PATHS: A pointer which will be set prior to this edit (but  *         not necessarily at the invocation of editor_from_delta()),and  *         which indicates whether incoming paths should be expected to  *         be absolute or relative.  *  - CANCEL_FUNC / CANCEL_BATON: The usual; folded into the produced editor.  *  - FETCH_KIND_FUNC / FETCH_KIND_BATON: A callback / baton pair which will  *         be used by the shim handlers if they need to determine the kind of  *         a path.  *  - FETCH_PROPS_FUNC / FETCH_PROPS_BATON: A callback / baton pair which  *         will be used by the shim handlers if they need to determine the  *         existing properties on a path.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_delta__editor_from_delta
parameter_list|(
name|svn_editor_t
modifier|*
modifier|*
name|editor_p
parameter_list|,
name|struct
name|svn_delta__extra_baton
modifier|*
modifier|*
name|exb
parameter_list|,
name|svn_delta__unlock_func_t
modifier|*
name|unlock_func
parameter_list|,
name|void
modifier|*
modifier|*
name|unlock_baton
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|deditor
parameter_list|,
name|void
modifier|*
name|dedit_baton
parameter_list|,
name|svn_boolean_t
modifier|*
name|send_abs_paths
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root
parameter_list|,
specifier|const
name|char
modifier|*
name|base_relpath
parameter_list|,
name|svn_cancel_func_t
name|cancel_func
parameter_list|,
name|void
modifier|*
name|cancel_baton
parameter_list|,
name|svn_delta_fetch_kind_func_t
name|fetch_kind_func
parameter_list|,
name|void
modifier|*
name|fetch_kind_baton
parameter_list|,
name|svn_delta_fetch_props_func_t
name|fetch_props_func
parameter_list|,
name|void
modifier|*
name|fetch_props_baton
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_editor_t
modifier|*
name|editor
decl_stmt|;
specifier|static
specifier|const
name|svn_editor_cb_many_t
name|editor_cbs
init|=
block|{
name|add_directory_cb
block|,
name|add_file_cb
block|,
name|add_symlink_cb
block|,
name|add_absent_cb
block|,
name|alter_directory_cb
block|,
name|alter_file_cb
block|,
name|alter_symlink_cb
block|,
name|delete_cb
block|,
name|copy_cb
block|,
name|move_cb
block|,
name|rotate_cb
block|,
name|complete_cb
block|,
name|abort_cb
block|}
decl_stmt|;
name|struct
name|editor_baton
modifier|*
name|eb
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|svn_delta__extra_baton
modifier|*
name|extra_baton
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|extra_baton
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|base_relpath
condition|)
name|base_relpath
operator|=
literal|""
expr_stmt|;
elseif|else
if|if
condition|(
name|base_relpath
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
name|base_relpath
operator|+=
literal|1
expr_stmt|;
name|eb
operator|->
name|deditor
operator|=
name|deditor
expr_stmt|;
name|eb
operator|->
name|dedit_baton
operator|=
name|dedit_baton
expr_stmt|;
name|eb
operator|->
name|edit_pool
operator|=
name|result_pool
expr_stmt|;
name|eb
operator|->
name|repos_root
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|repos_root
argument_list|)
expr_stmt|;
name|eb
operator|->
name|base_relpath
operator|=
name|apr_pstrdup
argument_list|(
name|result_pool
argument_list|,
name|base_relpath
argument_list|)
expr_stmt|;
name|eb
operator|->
name|changes
operator|=
name|apr_hash_make
argument_list|(
name|result_pool
argument_list|)
expr_stmt|;
name|eb
operator|->
name|fetch_kind_func
operator|=
name|fetch_kind_func
expr_stmt|;
name|eb
operator|->
name|fetch_kind_baton
operator|=
name|fetch_kind_baton
expr_stmt|;
name|eb
operator|->
name|fetch_props_func
operator|=
name|fetch_props_func
expr_stmt|;
name|eb
operator|->
name|fetch_props_baton
operator|=
name|fetch_props_baton
expr_stmt|;
name|eb
operator|->
name|root
operator|.
name|base_revision
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
name|eb
operator|->
name|make_abs_paths
operator|=
name|send_abs_paths
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_create
argument_list|(
operator|&
name|editor
argument_list|,
name|eb
argument_list|,
name|cancel_func
argument_list|,
name|cancel_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_editor_setcb_many
argument_list|(
name|editor
argument_list|,
operator|&
name|editor_cbs
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|editor_p
operator|=
name|editor
expr_stmt|;
operator|*
name|unlock_func
operator|=
name|do_unlock
expr_stmt|;
operator|*
name|unlock_baton
operator|=
name|eb
expr_stmt|;
name|extra_baton
operator|->
name|start_edit
operator|=
name|start_edit_func
expr_stmt|;
name|extra_baton
operator|->
name|target_revision
operator|=
name|target_revision_func
expr_stmt|;
name|extra_baton
operator|->
name|baton
operator|=
name|eb
expr_stmt|;
operator|*
name|exb
operator|=
name|extra_baton
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_delta_shim_callbacks_t
modifier|*
name|svn_delta_shim_callbacks_default
parameter_list|(
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|)
block|{
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
init|=
name|apr_pcalloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|shim_callbacks
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|shim_callbacks
return|;
block|}
end_function

begin_comment
comment|/* To enable editor shims throughout Subversion, ENABLE_EV2_SHIMS should be  * defined.  This can be done manually, or by providing `--enable-ev2-shims'  * to `configure'.  */
end_comment

begin_function
name|svn_error_t
modifier|*
name|svn_editor__insert_shims
parameter_list|(
specifier|const
name|svn_delta_editor_t
modifier|*
modifier|*
name|deditor_out
parameter_list|,
name|void
modifier|*
modifier|*
name|dedit_baton_out
parameter_list|,
specifier|const
name|svn_delta_editor_t
modifier|*
name|deditor_in
parameter_list|,
name|void
modifier|*
name|dedit_baton_in
parameter_list|,
specifier|const
name|char
modifier|*
name|repos_root
parameter_list|,
specifier|const
name|char
modifier|*
name|base_relpath
parameter_list|,
name|svn_delta_shim_callbacks_t
modifier|*
name|shim_callbacks
parameter_list|,
name|apr_pool_t
modifier|*
name|result_pool
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
ifndef|#
directive|ifndef
name|ENABLE_EV2_SHIMS
comment|/* Shims disabled, just copy the editor and baton directly. */
operator|*
name|deditor_out
operator|=
name|deditor_in
expr_stmt|;
operator|*
name|dedit_baton_out
operator|=
name|dedit_baton_in
expr_stmt|;
else|#
directive|else
comment|/* Use our shim APIs to create an intermediate svn_editor_t, and then      wrap that again back into a svn_delta_editor_t.  This introduces      a lot of overhead. */
name|svn_editor_t
modifier|*
name|editor
decl_stmt|;
comment|/* The "extra baton" is a set of functions and a baton which allows the      shims to communicate additional events to each other.      svn_delta__editor_from_delta() returns a pointer to this baton, which      svn_delta__delta_from_editor() should then store. */
name|struct
name|svn_delta__extra_baton
modifier|*
name|exb
decl_stmt|;
comment|/* The reason this is a pointer is that we don't know the appropriate      value until we start receiving paths.  So process_actions() sets the      flag, which drive_tree() later consumes. */
name|svn_boolean_t
modifier|*
name|found_abs_paths
init|=
name|apr_palloc
argument_list|(
name|result_pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|found_abs_paths
argument_list|)
argument_list|)
decl_stmt|;
name|svn_delta__unlock_func_t
name|unlock_func
decl_stmt|;
name|void
modifier|*
name|unlock_baton
decl_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|shim_callbacks
operator|->
name|fetch_kind_func
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|shim_callbacks
operator|->
name|fetch_props_func
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR_ASSERT
argument_list|(
name|shim_callbacks
operator|->
name|fetch_base_func
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta__editor_from_delta
argument_list|(
operator|&
name|editor
argument_list|,
operator|&
name|exb
argument_list|,
operator|&
name|unlock_func
argument_list|,
operator|&
name|unlock_baton
argument_list|,
name|deditor_in
argument_list|,
name|dedit_baton_in
argument_list|,
name|found_abs_paths
argument_list|,
name|repos_root
argument_list|,
name|base_relpath
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|shim_callbacks
operator|->
name|fetch_kind_func
argument_list|,
name|shim_callbacks
operator|->
name|fetch_baton
argument_list|,
name|shim_callbacks
operator|->
name|fetch_props_func
argument_list|,
name|shim_callbacks
operator|->
name|fetch_baton
argument_list|,
name|result_pool
argument_list|,
name|scratch_pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_delta__delta_from_editor
argument_list|(
name|deditor_out
argument_list|,
name|dedit_baton_out
argument_list|,
name|editor
argument_list|,
name|unlock_func
argument_list|,
name|unlock_baton
argument_list|,
name|found_abs_paths
argument_list|,
name|repos_root
argument_list|,
name|base_relpath
argument_list|,
name|shim_callbacks
operator|->
name|fetch_props_func
argument_list|,
name|shim_callbacks
operator|->
name|fetch_baton
argument_list|,
name|shim_callbacks
operator|->
name|fetch_base_func
argument_list|,
name|shim_callbacks
operator|->
name|fetch_baton
argument_list|,
name|exb
argument_list|,
name|result_pool
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

