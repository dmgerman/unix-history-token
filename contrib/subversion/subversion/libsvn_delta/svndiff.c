begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svndiff.c -- Encoding and decoding svndiff-format deltas.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"svn_delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_io.h"
end_include

begin_include
include|#
directive|include
file|"delta.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_error_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_delta_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_string_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_dep_compat.h"
end_include

begin_comment
comment|/* ----- Text delta to svndiff ----- */
end_comment

begin_comment
comment|/* We make one of these and get it passed back to us in calls to the    window handler.  We only use it to record the write function and    baton passed to svn_txdelta_to_svndiff3().  */
end_comment

begin_struct
struct|struct
name|encoder_baton
block|{
name|svn_stream_t
modifier|*
name|output
decl_stmt|;
name|svn_boolean_t
name|header_done
decl_stmt|;
name|int
name|version
decl_stmt|;
name|int
name|compression_level
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This is at least as big as the largest size for a single instruction. */
end_comment

begin_define
define|#
directive|define
name|MAX_INSTRUCTION_LEN
value|(2*SVN__MAX_ENCODED_UINT_LEN+1)
end_define

begin_comment
comment|/* This is at least as big as the largest possible instructions    section: in theory, the instructions could be SVN_DELTA_WINDOW_SIZE    1-byte copy-from-source instructions (though this is very unlikely). */
end_comment

begin_define
define|#
directive|define
name|MAX_INSTRUCTION_SECTION_LEN
value|(SVN_DELTA_WINDOW_SIZE*MAX_INSTRUCTION_LEN)
end_define

begin_comment
comment|/* Append an encoded integer to a string.  */
end_comment

begin_function
specifier|static
name|void
name|append_encoded_int
parameter_list|(
name|svn_stringbuf_t
modifier|*
name|header
parameter_list|,
name|svn_filesize_t
name|val
parameter_list|)
block|{
name|unsigned
name|char
name|buf
index|[
name|SVN__MAX_ENCODED_UINT_LEN
index|]
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|SVN_ERR_ASSERT_NO_RETURN
argument_list|(
name|val
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|svn__encode_uint
argument_list|(
name|buf
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|val
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|header
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|buf
argument_list|,
name|p
operator|-
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|send_simple_insertion_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|struct
name|encoder_baton
modifier|*
name|eb
parameter_list|)
block|{
name|unsigned
name|char
name|headers
index|[
literal|4
operator|+
literal|5
operator|*
name|SVN__MAX_ENCODED_UINT_LEN
operator|+
name|MAX_INSTRUCTION_LEN
index|]
decl_stmt|;
name|unsigned
name|char
name|ibuf
index|[
name|MAX_INSTRUCTION_LEN
index|]
decl_stmt|;
name|unsigned
name|char
modifier|*
name|header_current
decl_stmt|;
name|apr_size_t
name|header_len
decl_stmt|;
name|apr_size_t
name|ip_len
decl_stmt|,
name|i
decl_stmt|;
name|apr_size_t
name|len
init|=
name|window
operator|->
name|new_data
operator|->
name|len
decl_stmt|;
comment|/* there is only one target copy op. It must span the whole window */
name|assert
argument_list|(
name|window
operator|->
name|ops
index|[
literal|0
index|]
operator|.
name|action_code
operator|==
name|svn_txdelta_new
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|window
operator|->
name|ops
index|[
literal|0
index|]
operator|.
name|length
operator|==
name|window
operator|->
name|tview_len
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|window
operator|->
name|ops
index|[
literal|0
index|]
operator|.
name|offset
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* write stream header if necessary */
if|if
condition|(
operator|!
name|eb
operator|->
name|header_done
condition|)
block|{
name|eb
operator|->
name|header_done
operator|=
name|TRUE
expr_stmt|;
name|headers
index|[
literal|0
index|]
operator|=
literal|'S'
expr_stmt|;
name|headers
index|[
literal|1
index|]
operator|=
literal|'V'
expr_stmt|;
name|headers
index|[
literal|2
index|]
operator|=
literal|'N'
expr_stmt|;
name|headers
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|eb
operator|->
name|version
expr_stmt|;
name|header_current
operator|=
name|headers
operator|+
literal|4
expr_stmt|;
block|}
else|else
block|{
name|header_current
operator|=
name|headers
expr_stmt|;
block|}
comment|/* Encode the action code and length.  */
if|if
condition|(
name|window
operator|->
name|tview_len
operator|>>
literal|6
operator|==
literal|0
condition|)
block|{
name|ibuf
index|[
literal|0
index|]
operator|=
call|(
name|unsigned
name|char
call|)
argument_list|(
name|window
operator|->
name|tview_len
operator|+
operator|(
literal|0x2
operator|<<
literal|6
operator|)
argument_list|)
expr_stmt|;
name|ip_len
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ibuf
index|[
literal|0
index|]
operator|=
operator|(
literal|0x2
operator|<<
literal|6
operator|)
expr_stmt|;
name|ip_len
operator|=
name|svn__encode_uint
argument_list|(
name|ibuf
operator|+
literal|1
argument_list|,
name|window
operator|->
name|tview_len
argument_list|)
operator|-
name|ibuf
expr_stmt|;
block|}
comment|/* encode the window header.  Please note that the source window may    * have content despite not being used for deltification. */
name|header_current
operator|=
name|svn__encode_uint
argument_list|(
name|header_current
argument_list|,
operator|(
name|apr_uint64_t
operator|)
name|window
operator|->
name|sview_offset
argument_list|)
expr_stmt|;
name|header_current
operator|=
name|svn__encode_uint
argument_list|(
name|header_current
argument_list|,
name|window
operator|->
name|sview_len
argument_list|)
expr_stmt|;
name|header_current
operator|=
name|svn__encode_uint
argument_list|(
name|header_current
argument_list|,
name|window
operator|->
name|tview_len
argument_list|)
expr_stmt|;
name|header_current
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|ip_len
expr_stmt|;
comment|/* 1 instruction */
name|header_current
operator|=
name|svn__encode_uint
argument_list|(
operator|&
name|header_current
index|[
literal|1
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* append instructions (1 to a handful of bytes) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ip_len
condition|;
operator|++
name|i
control|)
name|header_current
index|[
name|i
index|]
operator|=
name|ibuf
index|[
name|i
index|]
expr_stmt|;
name|header_len
operator|=
name|header_current
operator|-
name|headers
operator|+
name|ip_len
expr_stmt|;
comment|/* Write out the window.  */
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|headers
argument_list|,
operator|&
name|header_len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|window
operator|->
name|new_data
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|window_handler
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|encoder_baton
modifier|*
name|eb
init|=
name|baton
decl_stmt|;
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|instructions
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|i1
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|header
decl_stmt|;
specifier|const
name|svn_string_t
modifier|*
name|newdata
decl_stmt|;
name|unsigned
name|char
name|ibuf
index|[
name|MAX_INSTRUCTION_LEN
index|]
decl_stmt|,
modifier|*
name|ip
decl_stmt|;
specifier|const
name|svn_txdelta_op_t
modifier|*
name|op
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
comment|/* use specialized code if there is no source */
if|if
condition|(
name|window
operator|&&
operator|!
name|window
operator|->
name|src_ops
operator|&&
name|window
operator|->
name|num_ops
operator|==
literal|1
operator|&&
operator|!
name|eb
operator|->
name|version
condition|)
return|return
name|svn_error_trace
argument_list|(
name|send_simple_insertion_window
argument_list|(
name|window
argument_list|,
name|eb
argument_list|)
argument_list|)
return|;
comment|/* Make sure we write the header.  */
if|if
condition|(
operator|!
name|eb
operator|->
name|header_done
condition|)
block|{
name|char
name|svnver
index|[
literal|4
index|]
init|=
block|{
literal|'S'
block|,
literal|'V'
block|,
literal|'N'
block|,
literal|'\0'
block|}
decl_stmt|;
name|len
operator|=
literal|4
expr_stmt|;
name|svnver
index|[
literal|3
index|]
operator|=
operator|(
name|char
operator|)
name|eb
operator|->
name|version
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|svnver
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|header_done
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|window
operator|==
name|NULL
condition|)
block|{
name|svn_stream_t
modifier|*
name|output
init|=
name|eb
operator|->
name|output
decl_stmt|;
comment|/* We're done; clean up.           We clean our pool first. Given that the output stream was passed          TO us, we'll assume it has a longer lifetime, and that it will not          be affected by our pool destruction.           The contrary point of view (close the stream first): that could          tell our user that everything related to the output stream is done,          and a cleanup of the user pool should occur. However, that user          pool could include the subpool we created for our work (eb->pool),          which would then make our call to svn_pool_destroy() puke.        */
name|svn_pool_destroy
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_stream_close
argument_list|(
name|output
argument_list|)
return|;
block|}
comment|/* create the necessary data buffers */
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|eb
operator|->
name|pool
argument_list|)
expr_stmt|;
name|instructions
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|i1
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|header
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
expr_stmt|;
comment|/* Encode the instructions.  */
for|for
control|(
name|op
operator|=
name|window
operator|->
name|ops
init|;
name|op
operator|<
name|window
operator|->
name|ops
operator|+
name|window
operator|->
name|num_ops
condition|;
name|op
operator|++
control|)
block|{
comment|/* Encode the action code and length.  */
name|ip
operator|=
name|ibuf
expr_stmt|;
switch|switch
condition|(
name|op
operator|->
name|action_code
condition|)
block|{
case|case
name|svn_txdelta_source
case|:
operator|*
name|ip
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|svn_txdelta_target
case|:
operator|*
name|ip
operator|=
operator|(
literal|0x1
operator|<<
literal|6
operator|)
expr_stmt|;
break|break;
case|case
name|svn_txdelta_new
case|:
operator|*
name|ip
operator|=
operator|(
literal|0x2
operator|<<
literal|6
operator|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|op
operator|->
name|length
operator|>>
literal|6
operator|==
literal|0
condition|)
operator|*
name|ip
operator|++
operator||=
operator|(
name|unsigned
name|char
operator|)
name|op
operator|->
name|length
expr_stmt|;
else|else
name|ip
operator|=
name|svn__encode_uint
argument_list|(
name|ip
operator|+
literal|1
argument_list|,
name|op
operator|->
name|length
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|action_code
operator|!=
name|svn_txdelta_new
condition|)
name|ip
operator|=
name|svn__encode_uint
argument_list|(
name|ip
argument_list|,
name|op
operator|->
name|offset
argument_list|)
expr_stmt|;
name|svn_stringbuf_appendbytes
argument_list|(
name|instructions
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|ibuf
argument_list|,
name|ip
operator|-
name|ibuf
argument_list|)
expr_stmt|;
block|}
comment|/* Encode the header.  */
name|append_encoded_int
argument_list|(
name|header
argument_list|,
name|window
operator|->
name|sview_offset
argument_list|)
expr_stmt|;
name|append_encoded_int
argument_list|(
name|header
argument_list|,
name|window
operator|->
name|sview_len
argument_list|)
expr_stmt|;
name|append_encoded_int
argument_list|(
name|header
argument_list|,
name|window
operator|->
name|tview_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|version
operator|==
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|instructions
argument_list|,
name|i1
argument_list|,
name|eb
operator|->
name|compression_level
argument_list|)
argument_list|)
expr_stmt|;
name|instructions
operator|=
name|i1
expr_stmt|;
block|}
name|append_encoded_int
argument_list|(
name|header
argument_list|,
name|instructions
operator|->
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|eb
operator|->
name|version
operator|==
literal|1
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|compressed
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|original
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|original
operator|->
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|window
operator|->
name|new_data
operator|->
name|data
expr_stmt|;
comment|/* won't be modified */
name|original
operator|->
name|len
operator|=
name|window
operator|->
name|new_data
operator|->
name|len
expr_stmt|;
name|original
operator|->
name|blocksize
operator|=
name|window
operator|->
name|new_data
operator|->
name|len
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn__compress
argument_list|(
name|original
argument_list|,
name|compressed
argument_list|,
name|eb
operator|->
name|compression_level
argument_list|)
argument_list|)
expr_stmt|;
name|newdata
operator|=
name|svn_stringbuf__morph_into_string
argument_list|(
name|compressed
argument_list|)
expr_stmt|;
block|}
else|else
name|newdata
operator|=
name|window
operator|->
name|new_data
expr_stmt|;
name|append_encoded_int
argument_list|(
name|header
argument_list|,
name|newdata
operator|->
name|len
argument_list|)
expr_stmt|;
comment|/* Write out the window.  */
name|len
operator|=
name|header
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|header
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|instructions
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|instructions
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|instructions
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|newdata
operator|->
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|=
name|newdata
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_write
argument_list|(
name|eb
operator|->
name|output
argument_list|,
name|newdata
operator|->
name|data
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|void
name|svn_txdelta_to_svndiff3
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|,
name|svn_stream_t
modifier|*
name|output
parameter_list|,
name|int
name|svndiff_version
parameter_list|,
name|int
name|compression_level
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|struct
name|encoder_baton
modifier|*
name|eb
decl_stmt|;
name|eb
operator|=
name|apr_palloc
argument_list|(
name|subpool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|eb
argument_list|)
argument_list|)
expr_stmt|;
name|eb
operator|->
name|output
operator|=
name|output
expr_stmt|;
name|eb
operator|->
name|header_done
operator|=
name|FALSE
expr_stmt|;
name|eb
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|eb
operator|->
name|version
operator|=
name|svndiff_version
expr_stmt|;
name|eb
operator|->
name|compression_level
operator|=
name|compression_level
expr_stmt|;
operator|*
name|handler
operator|=
name|window_handler
expr_stmt|;
operator|*
name|handler_baton
operator|=
name|eb
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_txdelta_to_svndiff2
parameter_list|(
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|,
name|svn_stream_t
modifier|*
name|output
parameter_list|,
name|int
name|svndiff_version
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_txdelta_to_svndiff3
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|output
argument_list|,
name|svndiff_version
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|svn_txdelta_to_svndiff
parameter_list|(
name|svn_stream_t
modifier|*
name|output
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|svn_txdelta_window_handler_t
modifier|*
name|handler
parameter_list|,
name|void
modifier|*
modifier|*
name|handler_baton
parameter_list|)
block|{
name|svn_txdelta_to_svndiff3
argument_list|(
name|handler
argument_list|,
name|handler_baton
argument_list|,
name|output
argument_list|,
literal|0
argument_list|,
name|SVN_DELTA_COMPRESSION_LEVEL_DEFAULT
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* ----- svndiff to text delta ----- */
end_comment

begin_comment
comment|/* An svndiff parser object.  */
end_comment

begin_struct
struct|struct
name|decode_baton
block|{
comment|/* Once the svndiff parser has enough data buffered to create a      "window", it passes this window to the caller's consumer routine.  */
name|svn_txdelta_window_handler_t
name|consumer_func
decl_stmt|;
name|void
modifier|*
name|consumer_baton
decl_stmt|;
comment|/* Pool to create subpools from; each developing window will be a      subpool.  */
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
comment|/* The current subpool which contains our current window-buffer.  */
name|apr_pool_t
modifier|*
name|subpool
decl_stmt|;
comment|/* The actual svndiff data buffer, living within subpool.  */
name|svn_stringbuf_t
modifier|*
name|buffer
decl_stmt|;
comment|/* The offset and size of the last source view, so that we can check      to make sure the next one isn't sliding backwards.  */
name|svn_filesize_t
name|last_sview_offset
decl_stmt|;
name|apr_size_t
name|last_sview_len
decl_stmt|;
comment|/* We have to discard four bytes at the beginning for the header.      This field keeps track of how many of those bytes we have read.  */
name|apr_size_t
name|header_bytes
decl_stmt|;
comment|/* Do we want an error to occur when we close the stream that      indicates we didn't send the whole svndiff data?  If you plan to      not transmit the whole svndiff data stream, you will want this to      be FALSE. */
name|svn_boolean_t
name|error_on_early_close
decl_stmt|;
comment|/* svndiff version in use by delta.  */
name|unsigned
name|char
name|version
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Wrapper aroung svn__deencode_uint taking a file size as *VAL. */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|decode_file_offset
parameter_list|(
name|svn_filesize_t
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
name|apr_uint64_t
name|temp
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|result
init|=
name|svn__decode_uint
argument_list|(
operator|&
name|temp
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
decl_stmt|;
operator|*
name|val
operator|=
operator|(
name|svn_filesize_t
operator|)
name|temp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Same as above, only decode into a size variable. */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|decode_size
parameter_list|(
name|apr_size_t
modifier|*
name|val
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
name|apr_uint64_t
name|temp
init|=
literal|0
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|result
init|=
name|svn__decode_uint
argument_list|(
operator|&
name|temp
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
decl_stmt|;
if|if
condition|(
name|temp
operator|>
name|APR_SIZE_MAX
condition|)
return|return
name|NULL
return|;
operator|*
name|val
operator|=
operator|(
name|apr_size_t
operator|)
name|temp
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* Decode an instruction into OP, returning a pointer to the text    after the instruction.  Note that if the action code is    svn_txdelta_new, the offset field of *OP will not be set.  */
end_comment

begin_function
specifier|static
specifier|const
name|unsigned
name|char
modifier|*
name|decode_instruction
parameter_list|(
name|svn_txdelta_op_t
modifier|*
name|op
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|)
block|{
name|apr_size_t
name|c
decl_stmt|;
name|apr_size_t
name|action
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|end
condition|)
return|return
name|NULL
return|;
comment|/* We need this more than once */
name|c
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Decode the instruction selector.  */
name|action
operator|=
operator|(
name|c
operator|>>
literal|6
operator|)
operator|&
literal|0x3
expr_stmt|;
if|if
condition|(
name|action
operator|>=
literal|0x3
condition|)
return|return
name|NULL
return|;
comment|/* This relies on enum svn_delta_action values to match and never to be      redefined. */
name|op
operator|->
name|action_code
operator|=
operator|(
expr|enum
name|svn_delta_action
operator|)
operator|(
name|action
operator|)
expr_stmt|;
comment|/* Decode the length and offset.  */
name|op
operator|->
name|length
operator|=
name|c
operator|&
literal|0x3f
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|length
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|decode_size
argument_list|(
operator|&
name|op
operator|->
name|length
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
if|if
condition|(
name|action
operator|!=
name|svn_txdelta_new
condition|)
block|{
name|p
operator|=
name|decode_size
argument_list|(
operator|&
name|op
operator|->
name|offset
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
block|}
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* Count the instructions in the range [P..END-1] and make sure they    are valid for the given window lengths.  Return an error if the    instructions are invalid; otherwise set *NINST to the number of    instructions.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|count_and_verify_instructions
parameter_list|(
name|int
modifier|*
name|ninst
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|end
parameter_list|,
name|apr_size_t
name|sview_len
parameter_list|,
name|apr_size_t
name|tview_len
parameter_list|,
name|apr_size_t
name|new_len
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|svn_txdelta_op_t
name|op
decl_stmt|;
name|apr_size_t
name|tpos
init|=
literal|0
decl_stmt|,
name|npos
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
block|{
name|p
operator|=
name|decode_instruction
argument_list|(
operator|&
name|op
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
comment|/* Detect any malformed operations from the instruction stream. */
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid diff stream: insn %d cannot be decoded"
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op
operator|.
name|length
operator|==
literal|0
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid diff stream: insn %d has length zero"
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
elseif|else
if|if
condition|(
name|op
operator|.
name|length
operator|>
name|tview_len
operator|-
name|tpos
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid diff stream: insn %d overflows the target view"
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
switch|switch
condition|(
name|op
operator|.
name|action_code
condition|)
block|{
case|case
name|svn_txdelta_source
case|:
if|if
condition|(
name|op
operator|.
name|length
operator|>
name|sview_len
operator|-
name|op
operator|.
name|offset
operator|||
name|op
operator|.
name|offset
operator|>
name|sview_len
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid diff stream: "
literal|"[src] insn %d overflows the source view"
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
break|break;
case|case
name|svn_txdelta_target
case|:
if|if
condition|(
name|op
operator|.
name|offset
operator|>=
name|tpos
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid diff stream: "
literal|"[tgt] insn %d starts beyond the target view position"
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
break|break;
case|case
name|svn_txdelta_new
case|:
if|if
condition|(
name|op
operator|.
name|length
operator|>
name|new_len
operator|-
name|npos
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid diff stream: "
literal|"[new] insn %d overflows the new data section"
argument_list|)
argument_list|,
name|n
argument_list|)
return|;
name|npos
operator|+=
name|op
operator|.
name|length
expr_stmt|;
break|break;
block|}
name|tpos
operator|+=
name|op
operator|.
name|length
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|tpos
operator|!=
name|tview_len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Delta does not fill the target window"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|npos
operator|!=
name|new_len
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_OPS
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Delta does not contain enough new data"
argument_list|)
argument_list|)
return|;
operator|*
name|ninst
operator|=
name|n
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|zlib_decode
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|in
parameter_list|,
name|apr_size_t
name|inLen
parameter_list|,
name|svn_stringbuf_t
modifier|*
name|out
parameter_list|,
name|apr_size_t
name|limit
parameter_list|)
block|{
comment|/* construct a fake string buffer as parameter to svn__decompress.      This is fine as that function never writes to it. */
name|svn_stringbuf_t
name|compressed
decl_stmt|;
name|compressed
operator|.
name|pool
operator|=
name|NULL
expr_stmt|;
name|compressed
operator|.
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|in
expr_stmt|;
name|compressed
operator|.
name|len
operator|=
name|inLen
expr_stmt|;
name|compressed
operator|.
name|blocksize
operator|=
name|inLen
operator|+
literal|1
expr_stmt|;
return|return
name|svn__decompress
argument_list|(
operator|&
name|compressed
argument_list|,
name|out
argument_list|,
name|limit
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given the five integer fields of a window header and a pointer to    the remainder of the window contents, fill in a delta window    structure *WINDOW.  New allocations will be performed in POOL;    the new_data field of *WINDOW will refer directly to memory pointed    to by DATA. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|decode_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
name|window
parameter_list|,
name|svn_filesize_t
name|sview_offset
parameter_list|,
name|apr_size_t
name|sview_len
parameter_list|,
name|apr_size_t
name|tview_len
parameter_list|,
name|apr_size_t
name|inslen
parameter_list|,
name|apr_size_t
name|newlen
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|,
name|unsigned
name|int
name|version
parameter_list|)
block|{
specifier|const
name|unsigned
name|char
modifier|*
name|insend
decl_stmt|;
name|int
name|ninst
decl_stmt|;
name|apr_size_t
name|npos
decl_stmt|;
name|svn_txdelta_op_t
modifier|*
name|ops
decl_stmt|,
modifier|*
name|op
decl_stmt|;
name|svn_string_t
modifier|*
name|new_data
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|new_data
argument_list|)
argument_list|)
decl_stmt|;
name|window
operator|->
name|sview_offset
operator|=
name|sview_offset
expr_stmt|;
name|window
operator|->
name|sview_len
operator|=
name|sview_len
expr_stmt|;
name|window
operator|->
name|tview_len
operator|=
name|tview_len
expr_stmt|;
name|insend
operator|=
name|data
operator|+
name|inslen
expr_stmt|;
if|if
condition|(
name|version
operator|==
literal|1
condition|)
block|{
name|svn_stringbuf_t
modifier|*
name|instout
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|ndout
init|=
name|svn_stringbuf_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|zlib_decode
argument_list|(
name|insend
argument_list|,
name|newlen
argument_list|,
name|ndout
argument_list|,
name|SVN_DELTA_WINDOW_SIZE
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|zlib_decode
argument_list|(
name|data
argument_list|,
name|insend
operator|-
name|data
argument_list|,
name|instout
argument_list|,
name|MAX_INSTRUCTION_SECTION_LEN
argument_list|)
argument_list|)
expr_stmt|;
name|newlen
operator|=
name|ndout
operator|->
name|len
expr_stmt|;
name|data
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|instout
operator|->
name|data
expr_stmt|;
name|insend
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|instout
operator|->
name|data
operator|+
name|instout
operator|->
name|len
expr_stmt|;
name|new_data
operator|->
name|data
operator|=
operator|(
specifier|const
name|char
operator|*
operator|)
name|ndout
operator|->
name|data
expr_stmt|;
name|new_data
operator|->
name|len
operator|=
name|newlen
expr_stmt|;
block|}
else|else
block|{
comment|/* Copy the data because an svn_string_t must have the invariant          data[len]=='\0'. */
name|char
modifier|*
name|buf
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|newlen
operator|+
literal|1
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|buf
argument_list|,
name|insend
argument_list|,
name|newlen
argument_list|)
expr_stmt|;
name|buf
index|[
name|newlen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|new_data
operator|->
name|data
operator|=
name|buf
expr_stmt|;
name|new_data
operator|->
name|len
operator|=
name|newlen
expr_stmt|;
block|}
comment|/* Count the instructions and make sure they are all valid.  */
name|SVN_ERR
argument_list|(
name|count_and_verify_instructions
argument_list|(
operator|&
name|ninst
argument_list|,
name|data
argument_list|,
name|insend
argument_list|,
name|sview_len
argument_list|,
name|tview_len
argument_list|,
name|newlen
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Allocate a buffer for the instructions and decode them. */
name|ops
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|ninst
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|ops
argument_list|)
argument_list|)
expr_stmt|;
name|npos
operator|=
literal|0
expr_stmt|;
name|window
operator|->
name|src_ops
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|op
operator|=
name|ops
init|;
name|op
operator|<
name|ops
operator|+
name|ninst
condition|;
name|op
operator|++
control|)
block|{
name|data
operator|=
name|decode_instruction
argument_list|(
name|op
argument_list|,
name|data
argument_list|,
name|insend
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|action_code
operator|==
name|svn_txdelta_source
condition|)
operator|++
name|window
operator|->
name|src_ops
expr_stmt|;
elseif|else
if|if
condition|(
name|op
operator|->
name|action_code
operator|==
name|svn_txdelta_new
condition|)
block|{
name|op
operator|->
name|offset
operator|=
name|npos
expr_stmt|;
name|npos
operator|+=
name|op
operator|->
name|length
expr_stmt|;
block|}
block|}
name|SVN_ERR_ASSERT
argument_list|(
name|data
operator|==
name|insend
argument_list|)
expr_stmt|;
name|window
operator|->
name|ops
operator|=
name|ops
expr_stmt|;
name|window
operator|->
name|num_ops
operator|=
name|ninst
expr_stmt|;
name|window
operator|->
name|new_data
operator|=
name|new_data
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
name|SVNDIFF_V0
index|[]
init|=
block|{
literal|'S'
block|,
literal|'V'
block|,
literal|'N'
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|SVNDIFF_V1
index|[]
init|=
block|{
literal|'S'
block|,
literal|'V'
block|,
literal|'N'
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SVNDIFF_HEADER_SIZE
value|(sizeof(SVNDIFF_V0))
end_define

begin_function
specifier|static
name|svn_error_t
modifier|*
name|write_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|decode_baton
modifier|*
name|db
init|=
operator|(
expr|struct
name|decode_baton
operator|*
operator|)
name|baton
decl_stmt|;
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|svn_filesize_t
name|sview_offset
decl_stmt|;
name|apr_size_t
name|sview_len
decl_stmt|,
name|tview_len
decl_stmt|,
name|inslen
decl_stmt|,
name|newlen
decl_stmt|,
name|remaining
decl_stmt|;
name|apr_size_t
name|buflen
init|=
operator|*
name|len
decl_stmt|;
comment|/* Chew up four bytes at the beginning for the header.  */
if|if
condition|(
name|db
operator|->
name|header_bytes
operator|<
name|SVNDIFF_HEADER_SIZE
condition|)
block|{
name|apr_size_t
name|nheader
init|=
name|SVNDIFF_HEADER_SIZE
operator|-
name|db
operator|->
name|header_bytes
decl_stmt|;
if|if
condition|(
name|nheader
operator|>
name|buflen
condition|)
name|nheader
operator|=
name|buflen
expr_stmt|;
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|SVNDIFF_V0
operator|+
name|db
operator|->
name|header_bytes
argument_list|,
name|nheader
argument_list|)
operator|==
literal|0
condition|)
name|db
operator|->
name|version
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|memcmp
argument_list|(
name|buffer
argument_list|,
name|SVNDIFF_V1
operator|+
name|db
operator|->
name|header_bytes
argument_list|,
name|nheader
argument_list|)
operator|==
literal|0
condition|)
name|db
operator|->
name|version
operator|=
literal|1
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_INVALID_HEADER
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff has invalid header"
argument_list|)
argument_list|)
return|;
name|buflen
operator|-=
name|nheader
expr_stmt|;
name|buffer
operator|+=
name|nheader
expr_stmt|;
name|db
operator|->
name|header_bytes
operator|+=
name|nheader
expr_stmt|;
block|}
comment|/* Concatenate the old with the new.  */
name|svn_stringbuf_appendbytes
argument_list|(
name|db
operator|->
name|buffer
argument_list|,
name|buffer
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
comment|/* We have a buffer of svndiff data that might be good for:       a) an integral number of windows' worth of data - this is a         trivial case.  Make windows from our data and ship them off.       b) a non-integral number of windows' worth of data - we shall         consume the integral portion of the window data, and then         somewhere in the following loop the decoding of the svndiff         data will run out of stuff to decode, and will simply return         SVN_NO_ERROR, anxiously awaiting more data.   */
while|while
condition|(
literal|1
condition|)
block|{
name|apr_pool_t
modifier|*
name|newpool
decl_stmt|;
name|svn_txdelta_window_t
name|window
decl_stmt|;
comment|/* Read the header, if we have enough bytes for that.  */
name|p
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|db
operator|->
name|buffer
operator|->
name|data
expr_stmt|;
name|end
operator|=
operator|(
specifier|const
name|unsigned
name|char
operator|*
operator|)
name|db
operator|->
name|buffer
operator|->
name|data
operator|+
name|db
operator|->
name|buffer
operator|->
name|len
expr_stmt|;
name|p
operator|=
name|decode_file_offset
argument_list|(
operator|&
name|sview_offset
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|decode_size
argument_list|(
operator|&
name|sview_len
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|decode_size
argument_list|(
operator|&
name|tview_len
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|decode_size
argument_list|(
operator|&
name|inslen
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
name|p
operator|=
name|decode_size
argument_list|(
operator|&
name|newlen
argument_list|,
name|p
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|tview_len
operator|>
name|SVN_DELTA_WINDOW_SIZE
operator|||
name|sview_len
operator|>
name|SVN_DELTA_WINDOW_SIZE
operator|||
comment|/* for svndiff1, newlen includes the original length */
name|newlen
operator|>
name|SVN_DELTA_WINDOW_SIZE
operator|+
name|SVN__MAX_ENCODED_UINT_LEN
operator|||
name|inslen
operator|>
name|MAX_INSTRUCTION_SECTION_LEN
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_CORRUPT_WINDOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff contains a too-large window"
argument_list|)
argument_list|)
return|;
comment|/* Check for integer overflow.  */
if|if
condition|(
name|sview_offset
operator|<
literal|0
operator|||
name|inslen
operator|+
name|newlen
operator|<
name|inslen
operator|||
name|sview_len
operator|+
name|tview_len
operator|<
name|sview_len
operator|||
operator|(
name|apr_size_t
operator|)
name|sview_offset
operator|+
name|sview_len
operator|<
operator|(
name|apr_size_t
operator|)
name|sview_offset
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_CORRUPT_WINDOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff contains corrupt window header"
argument_list|)
argument_list|)
return|;
comment|/* Check for source windows which slide backwards.  */
if|if
condition|(
name|sview_len
operator|>
literal|0
operator|&&
operator|(
name|sview_offset
operator|<
name|db
operator|->
name|last_sview_offset
operator|||
operator|(
name|sview_offset
operator|+
name|sview_len
operator|<
name|db
operator|->
name|last_sview_offset
operator|+
name|db
operator|->
name|last_sview_len
operator|)
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_BACKWARD_VIEW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff has backwards-sliding source views"
argument_list|)
argument_list|)
return|;
comment|/* Wait for more data if we don't have enough bytes for the          whole window.  */
if|if
condition|(
call|(
name|apr_size_t
call|)
argument_list|(
name|end
operator|-
name|p
argument_list|)
operator|<
name|inslen
operator|+
name|newlen
condition|)
return|return
name|SVN_NO_ERROR
return|;
comment|/* Decode the window and send it off. */
name|SVN_ERR
argument_list|(
name|decode_window
argument_list|(
operator|&
name|window
argument_list|,
name|sview_offset
argument_list|,
name|sview_len
argument_list|,
name|tview_len
argument_list|,
name|inslen
argument_list|,
name|newlen
argument_list|,
name|p
argument_list|,
name|db
operator|->
name|subpool
argument_list|,
name|db
operator|->
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|db
operator|->
name|consumer_func
argument_list|(
operator|&
name|window
argument_list|,
name|db
operator|->
name|consumer_baton
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make a new subpool and buffer, saving aside the remaining          data in the old buffer.  */
name|newpool
operator|=
name|svn_pool_create
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
name|p
operator|+=
name|inslen
operator|+
name|newlen
expr_stmt|;
name|remaining
operator|=
name|db
operator|->
name|buffer
operator|->
name|data
operator|+
name|db
operator|->
name|buffer
operator|->
name|len
operator|-
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
expr_stmt|;
name|db
operator|->
name|buffer
operator|=
name|svn_stringbuf_ncreate
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|p
argument_list|,
name|remaining
argument_list|,
name|newpool
argument_list|)
expr_stmt|;
comment|/* Remember the offset and length of the source view for next time.  */
name|db
operator|->
name|last_sview_offset
operator|=
name|sview_offset
expr_stmt|;
name|db
operator|->
name|last_sview_len
operator|=
name|sview_len
expr_stmt|;
comment|/* We've copied stuff out of the old pool. Toss that pool and use          our new pool.          ### might be nice to avoid the copy and just use svn_pool_clear          ### to get rid of whatever the "other stuff" is. future project...       */
name|svn_pool_destroy
argument_list|(
name|db
operator|->
name|subpool
argument_list|)
expr_stmt|;
name|db
operator|->
name|subpool
operator|=
name|newpool
expr_stmt|;
block|}
comment|/* At this point we processed all integral windows and DB->BUFFER is empty      or contains partially read window header.      Check that unprocessed data is not larger that theoretical maximum      window header size. */
if|if
condition|(
name|db
operator|->
name|buffer
operator|->
name|len
operator|>
literal|5
operator|*
name|SVN__MAX_ENCODED_UINT_LEN
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_CORRUPT_WINDOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff contains a too-large window header"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Minimal svn_stream_t write handler, doing nothing */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|noop_write_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|buffer
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|close_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
name|struct
name|decode_baton
modifier|*
name|db
init|=
operator|(
expr|struct
name|decode_baton
operator|*
operator|)
name|baton
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
comment|/* Make sure that we're at a plausible end of stream, returning an      error if we are expected to do so.  */
if|if
condition|(
operator|(
name|db
operator|->
name|error_on_early_close
operator|)
operator|&&
operator|(
name|db
operator|->
name|header_bytes
operator|<
literal|4
operator|||
name|db
operator|->
name|buffer
operator|->
name|len
operator|!=
literal|0
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_UNEXPECTED_END
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of svndiff input"
argument_list|)
argument_list|)
return|;
comment|/* Tell the window consumer that we're done, and clean up.  */
name|err
operator|=
name|db
operator|->
name|consumer_func
argument_list|(
name|NULL
argument_list|,
name|db
operator|->
name|consumer_baton
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|db
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|err
return|;
block|}
end_function

begin_function
name|svn_stream_t
modifier|*
name|svn_txdelta_parse_svndiff
parameter_list|(
name|svn_txdelta_window_handler_t
name|handler
parameter_list|,
name|void
modifier|*
name|handler_baton
parameter_list|,
name|svn_boolean_t
name|error_on_early_close
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|struct
name|decode_baton
modifier|*
name|db
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|db
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|stream
decl_stmt|;
name|db
operator|->
name|consumer_func
operator|=
name|handler
expr_stmt|;
name|db
operator|->
name|consumer_baton
operator|=
name|handler_baton
expr_stmt|;
name|db
operator|->
name|pool
operator|=
name|subpool
expr_stmt|;
name|db
operator|->
name|subpool
operator|=
name|svn_pool_create
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|db
operator|->
name|buffer
operator|=
name|svn_stringbuf_create_empty
argument_list|(
name|db
operator|->
name|subpool
argument_list|)
expr_stmt|;
name|db
operator|->
name|last_sview_offset
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|last_sview_len
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|header_bytes
operator|=
literal|0
expr_stmt|;
name|db
operator|->
name|error_on_early_close
operator|=
name|error_on_early_close
expr_stmt|;
name|stream
operator|=
name|svn_stream_create
argument_list|(
name|db
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|handler
operator|!=
name|svn_delta_noop_window_handler
condition|)
block|{
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|write_handler
argument_list|)
expr_stmt|;
name|svn_stream_set_close
argument_list|(
name|stream
argument_list|,
name|close_handler
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* And else we just ignore everything as efficiently as we can.          by only hooking a no-op handler */
name|svn_stream_set_write
argument_list|(
name|stream
argument_list|,
name|noop_write_handler
argument_list|)
expr_stmt|;
block|}
return|return
name|stream
return|;
block|}
end_function

begin_comment
comment|/* Routines for reading one svndiff window at a time. */
end_comment

begin_comment
comment|/* Read one byte from STREAM into *BYTE. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_one_byte
parameter_list|(
name|unsigned
name|char
modifier|*
name|byte
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|char
name|c
decl_stmt|;
name|apr_size_t
name|len
init|=
literal|1
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
operator|&
name|c
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_UNEXPECTED_END
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of svndiff input"
argument_list|)
argument_list|)
return|;
operator|*
name|byte
operator|=
operator|(
name|unsigned
name|char
operator|)
name|c
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read and decode one integer from STREAM into *SIZE.    Increment *BYTE_COUNTER by the number of chars we have read. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_one_size
parameter_list|(
name|apr_size_t
modifier|*
name|size
parameter_list|,
name|apr_size_t
modifier|*
name|byte_counter
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
operator|*
name|size
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_one_byte
argument_list|(
operator|&
name|c
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|++
operator|*
name|byte_counter
expr_stmt|;
operator|*
name|size
operator|=
operator|(
operator|*
name|size
operator|<<
literal|7
operator|)
operator||
operator|(
name|c
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|&
literal|0x80
operator|)
condition|)
break|break;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Read a window header from STREAM and check it for integer overflow. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|read_window_header
parameter_list|(
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|svn_filesize_t
modifier|*
name|sview_offset
parameter_list|,
name|apr_size_t
modifier|*
name|sview_len
parameter_list|,
name|apr_size_t
modifier|*
name|tview_len
parameter_list|,
name|apr_size_t
modifier|*
name|inslen
parameter_list|,
name|apr_size_t
modifier|*
name|newlen
parameter_list|,
name|apr_size_t
modifier|*
name|header_len
parameter_list|)
block|{
name|unsigned
name|char
name|c
decl_stmt|;
comment|/* Read the source view offset by hand, since it's not an apr_size_t. */
operator|*
name|header_len
operator|=
literal|0
expr_stmt|;
operator|*
name|sview_offset
operator|=
literal|0
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|SVN_ERR
argument_list|(
name|read_one_byte
argument_list|(
operator|&
name|c
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
operator|++
operator|*
name|header_len
expr_stmt|;
operator|*
name|sview_offset
operator|=
operator|(
operator|*
name|sview_offset
operator|<<
literal|7
operator|)
operator||
operator|(
name|c
operator|&
literal|0x7f
operator|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|c
operator|&
literal|0x80
operator|)
condition|)
break|break;
block|}
comment|/* Read the four size fields. */
name|SVN_ERR
argument_list|(
name|read_one_size
argument_list|(
name|sview_len
argument_list|,
name|header_len
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_one_size
argument_list|(
name|tview_len
argument_list|,
name|header_len
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_one_size
argument_list|(
name|inslen
argument_list|,
name|header_len
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|read_one_size
argument_list|(
name|newlen
argument_list|,
name|header_len
argument_list|,
name|stream
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|tview_len
operator|>
name|SVN_DELTA_WINDOW_SIZE
operator|||
operator|*
name|sview_len
operator|>
name|SVN_DELTA_WINDOW_SIZE
operator|||
comment|/* for svndiff1, newlen includes the original length */
operator|*
name|newlen
operator|>
name|SVN_DELTA_WINDOW_SIZE
operator|+
name|SVN__MAX_ENCODED_UINT_LEN
operator|||
operator|*
name|inslen
operator|>
name|MAX_INSTRUCTION_SECTION_LEN
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_CORRUPT_WINDOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff contains a too-large window"
argument_list|)
argument_list|)
return|;
comment|/* Check for integer overflow.  */
if|if
condition|(
operator|*
name|sview_offset
operator|<
literal|0
operator|||
operator|*
name|inslen
operator|+
operator|*
name|newlen
operator|<
operator|*
name|inslen
operator|||
operator|*
name|sview_len
operator|+
operator|*
name|tview_len
operator|<
operator|*
name|sview_len
operator|||
operator|(
name|apr_size_t
operator|)
operator|*
name|sview_offset
operator|+
operator|*
name|sview_len
operator|<
operator|(
name|apr_size_t
operator|)
operator|*
name|sview_offset
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_CORRUPT_WINDOW
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Svndiff contains corrupt window header"
argument_list|)
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_read_svndiff_window
parameter_list|(
name|svn_txdelta_window_t
modifier|*
modifier|*
name|window
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|int
name|svndiff_version
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_filesize_t
name|sview_offset
decl_stmt|;
name|apr_size_t
name|sview_len
decl_stmt|,
name|tview_len
decl_stmt|,
name|inslen
decl_stmt|,
name|newlen
decl_stmt|,
name|len
decl_stmt|,
name|header_len
decl_stmt|;
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_window_header
argument_list|(
name|stream
argument_list|,
operator|&
name|sview_offset
argument_list|,
operator|&
name|sview_len
argument_list|,
operator|&
name|tview_len
argument_list|,
operator|&
name|inslen
argument_list|,
operator|&
name|newlen
argument_list|,
operator|&
name|header_len
argument_list|)
argument_list|)
expr_stmt|;
name|len
operator|=
name|inslen
operator|+
name|newlen
expr_stmt|;
name|buf
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_read_full
argument_list|(
name|stream
argument_list|,
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
name|inslen
operator|+
name|newlen
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_SVNDIFF_UNEXPECTED_END
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Unexpected end of svndiff input"
argument_list|)
argument_list|)
return|;
operator|*
name|window
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|*
name|window
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|decode_window
argument_list|(
operator|*
name|window
argument_list|,
name|sview_offset
argument_list|,
name|sview_len
argument_list|,
name|tview_len
argument_list|,
name|inslen
argument_list|,
name|newlen
argument_list|,
name|buf
argument_list|,
name|pool
argument_list|,
name|svndiff_version
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta_skip_svndiff_window
parameter_list|(
name|apr_file_t
modifier|*
name|file
parameter_list|,
name|int
name|svndiff_version
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|stream
init|=
name|svn_stream_from_aprfile2
argument_list|(
name|file
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_filesize_t
name|sview_offset
decl_stmt|;
name|apr_size_t
name|sview_len
decl_stmt|,
name|tview_len
decl_stmt|,
name|inslen
decl_stmt|,
name|newlen
decl_stmt|,
name|header_len
decl_stmt|;
name|apr_off_t
name|offset
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_window_header
argument_list|(
name|stream
argument_list|,
operator|&
name|sview_offset
argument_list|,
operator|&
name|sview_len
argument_list|,
operator|&
name|tview_len
argument_list|,
operator|&
name|inslen
argument_list|,
operator|&
name|newlen
argument_list|,
operator|&
name|header_len
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|inslen
operator|+
name|newlen
expr_stmt|;
return|return
name|svn_io_file_seek
argument_list|(
name|file
argument_list|,
name|APR_CUR
argument_list|,
operator|&
name|offset
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_function
name|svn_error_t
modifier|*
name|svn_txdelta__read_raw_window_len
parameter_list|(
name|apr_size_t
modifier|*
name|window_len
parameter_list|,
name|svn_stream_t
modifier|*
name|stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_filesize_t
name|sview_offset
decl_stmt|;
name|apr_size_t
name|sview_len
decl_stmt|,
name|tview_len
decl_stmt|,
name|inslen
decl_stmt|,
name|newlen
decl_stmt|,
name|header_len
decl_stmt|;
name|SVN_ERR
argument_list|(
name|read_window_header
argument_list|(
name|stream
argument_list|,
operator|&
name|sview_offset
argument_list|,
operator|&
name|sview_len
argument_list|,
operator|&
name|tview_len
argument_list|,
operator|&
name|inslen
argument_list|,
operator|&
name|newlen
argument_list|,
operator|&
name|header_len
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|window_len
operator|=
name|inslen
operator|+
name|newlen
operator|+
name|header_len
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

end_unit

