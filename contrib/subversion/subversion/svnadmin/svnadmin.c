begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * svnadmin.c: Subversion server administration tool main file.  *  * ====================================================================  *    Licensed to the Apache Software Foundation (ASF) under one  *    or more contributor license agreements.  See the NOTICE file  *    distributed with this work for additional information  *    regarding copyright ownership.  The ASF licenses this file  *    to you under the Apache License, Version 2.0 (the  *    "License"); you may not use this file except in compliance  *    with the License.  You may obtain a copy of the License at  *  *      http://www.apache.org/licenses/LICENSE-2.0  *  *    Unless required by applicable law or agreed to in writing,  *    software distributed under the License is distributed on an  *    "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY  *    KIND, either express or implied.  See the License for the  *    specific language governing permissions and limitations  *    under the License.  * ====================================================================  */
end_comment

begin_include
include|#
directive|include
file|<apr_file_io.h>
end_include

begin_include
include|#
directive|include
file|<apr_signal.h>
end_include

begin_include
include|#
directive|include
file|"svn_hash.h"
end_include

begin_include
include|#
directive|include
file|"svn_pools.h"
end_include

begin_include
include|#
directive|include
file|"svn_cmdline.h"
end_include

begin_include
include|#
directive|include
file|"svn_error.h"
end_include

begin_include
include|#
directive|include
file|"svn_opt.h"
end_include

begin_include
include|#
directive|include
file|"svn_utf.h"
end_include

begin_include
include|#
directive|include
file|"svn_subst.h"
end_include

begin_include
include|#
directive|include
file|"svn_dirent_uri.h"
end_include

begin_include
include|#
directive|include
file|"svn_path.h"
end_include

begin_include
include|#
directive|include
file|"svn_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_repos.h"
end_include

begin_include
include|#
directive|include
file|"svn_cache_config.h"
end_include

begin_include
include|#
directive|include
file|"svn_version.h"
end_include

begin_include
include|#
directive|include
file|"svn_props.h"
end_include

begin_include
include|#
directive|include
file|"svn_time.h"
end_include

begin_include
include|#
directive|include
file|"svn_user.h"
end_include

begin_include
include|#
directive|include
file|"svn_xml.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_opt_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_subr_private.h"
end_include

begin_include
include|#
directive|include
file|"private/svn_cmdline_private.h"
end_include

begin_include
include|#
directive|include
file|"svn_private_config.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*** Code. ***/
end_comment

begin_comment
comment|/* A flag to see if we've been cancelled by the client or not. */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|sig_atomic_t
name|cancelled
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* A signal handler to support cancellation. */
end_comment

begin_function
specifier|static
name|void
name|signal_handler
parameter_list|(
name|int
name|signum
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|signum
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|cancelled
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* A helper to set up the cancellation signal handlers. */
end_comment

begin_function
specifier|static
name|void
name|setup_cancellation_signals
parameter_list|(
name|void
function_decl|(
modifier|*
name|handler
function_decl|)
parameter_list|(
name|int
name|signum
parameter_list|)
parameter_list|)
block|{
name|apr_signal
argument_list|(
name|SIGINT
argument_list|,
name|handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGBREAK
comment|/* SIGBREAK is a Win32 specific signal generated by ctrl-break. */
name|apr_signal
argument_list|(
name|SIGBREAK
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGHUP
name|apr_signal
argument_list|(
name|SIGHUP
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGTERM
name|apr_signal
argument_list|(
name|SIGTERM
argument_list|,
name|handler
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Our cancellation callback. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_cancel
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|)
block|{
if|if
condition|(
name|cancelled
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CANCELLED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Caught signal"
argument_list|)
argument_list|)
return|;
else|else
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Custom filesystem warning function. */
end_comment

begin_function
specifier|static
name|void
name|warning_func
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|svn_error_t
modifier|*
name|err
parameter_list|)
block|{
if|if
condition|(
operator|!
name|err
condition|)
return|return;
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
argument_list|,
literal|"svnadmin: "
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Helper to open a repository and set a warning func (so we don't  * SEGFAULT when libsvn_fs's default handler gets run).  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|open_repos
parameter_list|(
name|svn_repos_t
modifier|*
modifier|*
name|repos
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* construct FS configuration parameters: enable caches for r/o data */
name|apr_hash_t
modifier|*
name|fs_config
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_DELTAS
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_FULLTEXTS
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_REVPROPS
argument_list|,
literal|"2"
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FSFS_CACHE_NS
argument_list|,
name|svn_uuid_generate
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* now, open the requested repository */
name|SVN_ERR
argument_list|(
name|svn_repos_open2
argument_list|(
name|repos
argument_list|,
name|path
argument_list|,
name|fs_config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_set_warning_func
argument_list|(
name|svn_repos_fs
argument_list|(
operator|*
name|repos
argument_list|)
argument_list|,
name|warning_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Version compatibility check */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|check_lib_versions
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
specifier|const
name|svn_version_checklist_t
name|checklist
index|[]
init|=
block|{
block|{
literal|"svn_subr"
block|,
name|svn_subr_version
block|}
block|,
block|{
literal|"svn_repos"
block|,
name|svn_repos_version
block|}
block|,
block|{
literal|"svn_fs"
block|,
name|svn_fs_version
block|}
block|,
block|{
literal|"svn_delta"
block|,
name|svn_delta_version
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
name|SVN_VERSION_DEFINE
argument_list|(
name|my_version
argument_list|)
expr_stmt|;
return|return
name|svn_ver_check_list2
argument_list|(
operator|&
name|my_version
argument_list|,
name|checklist
argument_list|,
name|svn_ver_equal
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Subcommands. **/
end_comment

begin_decl_stmt
specifier|static
name|svn_opt_subcommand_t
name|subcommand_crashtest
decl_stmt|,
name|subcommand_create
decl_stmt|,
name|subcommand_deltify
decl_stmt|,
name|subcommand_dump
decl_stmt|,
name|subcommand_freeze
decl_stmt|,
name|subcommand_help
decl_stmt|,
name|subcommand_hotcopy
decl_stmt|,
name|subcommand_load
decl_stmt|,
name|subcommand_list_dblogs
decl_stmt|,
name|subcommand_list_unused_dblogs
decl_stmt|,
name|subcommand_lock
decl_stmt|,
name|subcommand_lslocks
decl_stmt|,
name|subcommand_lstxns
decl_stmt|,
name|subcommand_pack
decl_stmt|,
name|subcommand_recover
decl_stmt|,
name|subcommand_rmlocks
decl_stmt|,
name|subcommand_rmtxns
decl_stmt|,
name|subcommand_setlog
decl_stmt|,
name|subcommand_setrevprop
decl_stmt|,
name|subcommand_setuuid
decl_stmt|,
name|subcommand_unlock
decl_stmt|,
name|subcommand_upgrade
decl_stmt|,
name|subcommand_verify
decl_stmt|;
end_decl_stmt

begin_enum
enum|enum
name|svnadmin__cmdline_options_t
block|{
name|svnadmin__version
init|=
name|SVN_OPT_FIRST_LONGOPT_ID
block|,
name|svnadmin__incremental
block|,
name|svnadmin__deltas
block|,
name|svnadmin__ignore_uuid
block|,
name|svnadmin__force_uuid
block|,
name|svnadmin__fs_type
block|,
name|svnadmin__parent_dir
block|,
name|svnadmin__bdb_txn_nosync
block|,
name|svnadmin__bdb_log_keep
block|,
name|svnadmin__config_dir
block|,
name|svnadmin__bypass_hooks
block|,
name|svnadmin__bypass_prop_validation
block|,
name|svnadmin__use_pre_commit_hook
block|,
name|svnadmin__use_post_commit_hook
block|,
name|svnadmin__use_pre_revprop_change_hook
block|,
name|svnadmin__use_post_revprop_change_hook
block|,
name|svnadmin__clean_logs
block|,
name|svnadmin__wait
block|,
name|svnadmin__pre_1_4_compatible
block|,
name|svnadmin__pre_1_5_compatible
block|,
name|svnadmin__pre_1_6_compatible
block|,
name|svnadmin__compatible_version
block|}
enum|;
end_enum

begin_comment
comment|/* Option codes and descriptions.  *  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|apr_getopt_option_t
name|options_table
index|[]
init|=
block|{
block|{
literal|"help"
block|,
literal|'h'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
name|NULL
block|,
literal|'?'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show help on a subcommand"
argument_list|)
block|}
block|,
block|{
literal|"version"
block|,
name|svnadmin__version
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"show program version information"
argument_list|)
block|}
block|,
block|{
literal|"revision"
block|,
literal|'r'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify revision number ARG (or X:Y range)"
argument_list|)
block|}
block|,
block|{
literal|"transaction"
block|,
literal|'t'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"specify transaction name ARG"
argument_list|)
block|}
block|,
block|{
literal|"incremental"
block|,
name|svnadmin__incremental
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"dump or hotcopy incrementally"
argument_list|)
block|}
block|,
block|{
literal|"deltas"
block|,
name|svnadmin__deltas
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"use deltas in dump output"
argument_list|)
block|}
block|,
block|{
literal|"bypass-hooks"
block|,
name|svnadmin__bypass_hooks
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"bypass the repository hook system"
argument_list|)
block|}
block|,
block|{
literal|"bypass-prop-validation"
block|,
name|svnadmin__bypass_prop_validation
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"bypass property validation logic"
argument_list|)
block|}
block|,
block|{
literal|"quiet"
block|,
literal|'q'
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"no progress (only errors) to stderr"
argument_list|)
block|}
block|,
block|{
literal|"ignore-uuid"
block|,
name|svnadmin__ignore_uuid
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"ignore any repos UUID found in the stream"
argument_list|)
block|}
block|,
block|{
literal|"force-uuid"
block|,
name|svnadmin__force_uuid
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"set repos UUID to that found in stream, if any"
argument_list|)
block|}
block|,
block|{
literal|"fs-type"
block|,
name|svnadmin__fs_type
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"type of repository: 'fsfs' (default) or 'bdb'"
argument_list|)
block|}
block|,
block|{
literal|"parent-dir"
block|,
name|svnadmin__parent_dir
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"load at specified directory in repository"
argument_list|)
block|}
block|,
block|{
literal|"bdb-txn-nosync"
block|,
name|svnadmin__bdb_txn_nosync
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"disable fsync at transaction commit [Berkeley DB]"
argument_list|)
block|}
block|,
block|{
literal|"bdb-log-keep"
block|,
name|svnadmin__bdb_log_keep
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"disable automatic log file removal [Berkeley DB]"
argument_list|)
block|}
block|,
block|{
literal|"config-dir"
block|,
name|svnadmin__config_dir
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"read user configuration files from directory ARG"
argument_list|)
block|}
block|,
block|{
literal|"clean-logs"
block|,
name|svnadmin__clean_logs
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"remove redundant Berkeley DB log files\n"
literal|"                             from source repository [Berkeley DB]"
argument_list|)
block|}
block|,
block|{
literal|"use-pre-commit-hook"
block|,
name|svnadmin__use_pre_commit_hook
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"call pre-commit hook before committing revisions"
argument_list|)
block|}
block|,
block|{
literal|"use-post-commit-hook"
block|,
name|svnadmin__use_post_commit_hook
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"call post-commit hook after committing revisions"
argument_list|)
block|}
block|,
block|{
literal|"use-pre-revprop-change-hook"
block|,
name|svnadmin__use_pre_revprop_change_hook
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"call hook before changing revision property"
argument_list|)
block|}
block|,
block|{
literal|"use-post-revprop-change-hook"
block|,
name|svnadmin__use_post_revprop_change_hook
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"call hook after changing revision property"
argument_list|)
block|}
block|,
block|{
literal|"wait"
block|,
name|svnadmin__wait
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"wait instead of exit if the repository is in\n"
literal|"                             use by another process"
argument_list|)
block|}
block|,
block|{
literal|"pre-1.4-compatible"
block|,
name|svnadmin__pre_1_4_compatible
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"deprecated; see --compatible-version"
argument_list|)
block|}
block|,
block|{
literal|"pre-1.5-compatible"
block|,
name|svnadmin__pre_1_5_compatible
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"deprecated; see --compatible-version"
argument_list|)
block|}
block|,
block|{
literal|"pre-1.6-compatible"
block|,
name|svnadmin__pre_1_6_compatible
block|,
literal|0
block|,
name|N_
argument_list|(
literal|"deprecated; see --compatible-version"
argument_list|)
block|}
block|,
block|{
literal|"memory-cache-size"
block|,
literal|'M'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"size of the extra in-memory cache in MB used to\n"
literal|"                             minimize redundant operations. Default: 16.\n"
literal|"                             [used for FSFS repositories only]"
argument_list|)
block|}
block|,
block|{
literal|"compatible-version"
block|,
name|svnadmin__compatible_version
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"use repository format compatible with Subversion\n"
literal|"                             version ARG (\"1.5.5\", \"1.7\", etc.)"
argument_list|)
block|}
block|,
block|{
literal|"file"
block|,
literal|'F'
block|,
literal|1
block|,
name|N_
argument_list|(
literal|"read repository paths from file ARG"
argument_list|)
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Array of available subcommands.  * The entire list must be terminated with an entry of nulls.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|cmd_table
index|[]
init|=
block|{
block|{
literal|"crashtest"
block|,
name|subcommand_crashtest
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin crashtest REPOS_PATH\n\n"
literal|"Open the repository at REPOS_PATH, then abort, thus simulating\n"
literal|"a process that crashes while holding an open repository handle.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"create"
block|,
name|subcommand_create
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin create REPOS_PATH\n\n"
literal|"Create a new, empty repository at REPOS_PATH.\n"
argument_list|)
block|,
block|{
name|svnadmin__bdb_txn_nosync
block|,
name|svnadmin__bdb_log_keep
block|,
name|svnadmin__config_dir
block|,
name|svnadmin__fs_type
block|,
name|svnadmin__compatible_version
block|,
name|svnadmin__pre_1_4_compatible
block|,
name|svnadmin__pre_1_5_compatible
block|,
name|svnadmin__pre_1_6_compatible
block|}
block|}
block|,
block|{
literal|"deltify"
block|,
name|subcommand_deltify
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin deltify [-r LOWER[:UPPER]] REPOS_PATH\n\n"
literal|"Run over the requested revision range, performing predecessor delti-\n"
literal|"fication on the paths changed in those revisions.  Deltification in\n"
literal|"essence compresses the repository by only storing the differences or\n"
literal|"delta from the preceding revision.  If no revisions are specified,\n"
literal|"this will simply deltify the HEAD revision.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
literal|'q'
block|,
literal|'M'
block|}
block|}
block|,
block|{
literal|"dump"
block|,
name|subcommand_dump
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin dump REPOS_PATH [-r LOWER[:UPPER] [--incremental]]\n\n"
literal|"Dump the contents of filesystem to stdout in a 'dumpfile'\n"
literal|"portable format, sending feedback to stderr.  Dump revisions\n"
literal|"LOWER rev through UPPER rev.  If no revisions are given, dump all\n"
literal|"revision trees.  If only LOWER is given, dump that one revision tree.\n"
literal|"If --incremental is passed, the first revision dumped will describe\n"
literal|"only the paths changed in that revision; otherwise it will describe\n"
literal|"every path present in the repository as of that revision.  (In either\n"
literal|"case, the second and subsequent revisions, if any, describe only paths\n"
literal|"changed in those revisions.)\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
name|svnadmin__incremental
block|,
name|svnadmin__deltas
block|,
literal|'q'
block|,
literal|'M'
block|}
block|}
block|,
block|{
literal|"freeze"
block|,
name|subcommand_freeze
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: 1. svnadmin freeze REPOS_PATH PROGRAM [ARG...]\n"
literal|"               2. svnadmin freeze -F FILE PROGRAM [ARG...]\n\n"
literal|"1. Run PROGRAM passing ARGS while holding a write-lock on REPOS_PATH.\n"
literal|"\n"
literal|"2. Like 1 except all repositories listed in FILE are locked. The file\n"
literal|"   format is repository paths separated by newlines.  Repositories are\n"
literal|"   locked in the same order as they are listed in the file.\n"
argument_list|)
block|,
block|{
literal|'F'
block|}
block|}
block|,
block|{
literal|"help"
block|,
name|subcommand_help
block|,
block|{
literal|"?"
block|,
literal|"h"
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin help [SUBCOMMAND...]\n\n"
literal|"Describe the usage of this program or its subcommands.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"hotcopy"
block|,
name|subcommand_hotcopy
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin hotcopy REPOS_PATH NEW_REPOS_PATH\n\n"
literal|"Make a hot copy of a repository.\n"
literal|"If --incremental is passed, data which already exists at the destination\n"
literal|"is not copied again.  Incremental mode is implemented for FSFS repositories.\n"
argument_list|)
block|,
block|{
name|svnadmin__clean_logs
block|,
name|svnadmin__incremental
block|}
block|}
block|,
block|{
literal|"list-dblogs"
block|,
name|subcommand_list_dblogs
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin list-dblogs REPOS_PATH\n\n"
literal|"List all Berkeley DB log files.\n\n"
literal|"WARNING: Modifying or deleting logfiles which are still in use\n"
literal|"will cause your repository to be corrupted.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"list-unused-dblogs"
block|,
name|subcommand_list_unused_dblogs
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin list-unused-dblogs REPOS_PATH\n\n"
literal|"List unused Berkeley DB log files.\n\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"load"
block|,
name|subcommand_load
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin load REPOS_PATH\n\n"
literal|"Read a 'dumpfile'-formatted stream from stdin, committing\n"
literal|"new revisions into the repository's filesystem.  If the repository\n"
literal|"was previously empty, its UUID will, by default, be changed to the\n"
literal|"one specified in the stream.  Progress feedback is sent to stdout.\n"
literal|"If --revision is specified, limit the loaded revisions to only those\n"
literal|"in the dump stream whose revision numbers match the specified range.\n"
argument_list|)
block|,
block|{
literal|'q'
block|,
literal|'r'
block|,
name|svnadmin__ignore_uuid
block|,
name|svnadmin__force_uuid
block|,
name|svnadmin__use_pre_commit_hook
block|,
name|svnadmin__use_post_commit_hook
block|,
name|svnadmin__parent_dir
block|,
name|svnadmin__bypass_prop_validation
block|,
literal|'M'
block|}
block|}
block|,
block|{
literal|"lock"
block|,
name|subcommand_lock
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin lock REPOS_PATH PATH USERNAME COMMENT-FILE [TOKEN]\n\n"
literal|"Lock PATH by USERNAME setting comments from COMMENT-FILE.\n"
literal|"If provided, use TOKEN as lock token.  Use --bypass-hooks to avoid\n"
literal|"triggering the pre-lock and post-lock hook scripts.\n"
argument_list|)
block|,
block|{
name|svnadmin__bypass_hooks
block|}
block|}
block|,
block|{
literal|"lslocks"
block|,
name|subcommand_lslocks
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin lslocks REPOS_PATH [PATH-IN-REPOS]\n\n"
literal|"Print descriptions of all locks on or under PATH-IN-REPOS (which,\n"
literal|"if not provided, is the root of the repository).\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"lstxns"
block|,
name|subcommand_lstxns
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin lstxns REPOS_PATH\n\n"
literal|"Print the names of all uncommitted transactions.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"pack"
block|,
name|subcommand_pack
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin pack REPOS_PATH\n\n"
literal|"Possibly compact the repository into a more efficient storage model.\n"
literal|"This may not apply to all repositories, in which case, exit.\n"
argument_list|)
block|,
block|{
literal|'q'
block|}
block|}
block|,
block|{
literal|"recover"
block|,
name|subcommand_recover
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin recover REPOS_PATH\n\n"
literal|"Run the recovery procedure on a repository.  Do this if you've\n"
literal|"been getting errors indicating that recovery ought to be run.\n"
literal|"Berkeley DB recovery requires exclusive access and will\n"
literal|"exit if the repository is in use by another process.\n"
argument_list|)
block|,
block|{
name|svnadmin__wait
block|}
block|}
block|,
block|{
literal|"rmlocks"
block|,
name|subcommand_rmlocks
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin rmlocks REPOS_PATH LOCKED_PATH...\n\n"
literal|"Unconditionally remove lock from each LOCKED_PATH.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"rmtxns"
block|,
name|subcommand_rmtxns
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin rmtxns REPOS_PATH TXN_NAME...\n\n"
literal|"Delete the named transaction(s).\n"
argument_list|)
block|,
block|{
literal|'q'
block|}
block|}
block|,
block|{
literal|"setlog"
block|,
name|subcommand_setlog
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin setlog REPOS_PATH -r REVISION FILE\n\n"
literal|"Set the log-message on revision REVISION to the contents of FILE.  Use\n"
literal|"--bypass-hooks to avoid triggering the revision-property-related hooks\n"
literal|"(for example, if you do not want an email notification sent\n"
literal|"from your post-revprop-change hook, or because the modification of\n"
literal|"revision properties has not been enabled in the pre-revprop-change\n"
literal|"hook).\n\n"
literal|"NOTE: Revision properties are not versioned, so this command will\n"
literal|"overwrite the previous log message.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
name|svnadmin__bypass_hooks
block|}
block|}
block|,
block|{
literal|"setrevprop"
block|,
name|subcommand_setrevprop
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin setrevprop REPOS_PATH -r REVISION NAME FILE\n\n"
literal|"Set the property NAME on revision REVISION to the contents of FILE. Use\n"
literal|"--use-pre-revprop-change-hook/--use-post-revprop-change-hook to trigger\n"
literal|"the revision property-related hooks (for example, if you want an email\n"
literal|"notification sent from your post-revprop-change hook).\n\n"
literal|"NOTE: Revision properties are not versioned, so this command will\n"
literal|"overwrite the previous value of the property.\n"
argument_list|)
block|,
block|{
literal|'r'
block|,
name|svnadmin__use_pre_revprop_change_hook
block|,
name|svnadmin__use_post_revprop_change_hook
block|}
block|}
block|,
block|{
literal|"setuuid"
block|,
name|subcommand_setuuid
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin setuuid REPOS_PATH [NEW_UUID]\n\n"
literal|"Reset the repository UUID for the repository located at REPOS_PATH.  If\n"
literal|"NEW_UUID is provided, use that as the new repository UUID; otherwise,\n"
literal|"generate a brand new UUID for the repository.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"unlock"
block|,
name|subcommand_unlock
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin unlock REPOS_PATH LOCKED_PATH USERNAME TOKEN\n\n"
literal|"Unlock LOCKED_PATH (as USERNAME) after verifying that the token\n"
literal|"associated with the lock matches TOKEN.  Use --bypass-hooks to avoid\n"
literal|"triggering the pre-unlock and post-unlock hook scripts.\n"
argument_list|)
block|,
block|{
name|svnadmin__bypass_hooks
block|}
block|}
block|,
block|{
literal|"upgrade"
block|,
name|subcommand_upgrade
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin upgrade REPOS_PATH\n\n"
literal|"Upgrade the repository located at REPOS_PATH to the latest supported\n"
literal|"schema version.\n\n"
literal|"This functionality is provided as a convenience for repository\n"
literal|"administrators who wish to make use of new Subversion functionality\n"
literal|"without having to undertake a potentially costly full repository dump\n"
literal|"and load operation.  As such, the upgrade performs only the minimum\n"
literal|"amount of work needed to accomplish this while still maintaining the\n"
literal|"integrity of the repository.  It does not guarantee the most optimized\n"
literal|"repository state as a dump and subsequent load would.\n"
argument_list|)
block|,
block|{
literal|0
block|}
block|}
block|,
block|{
literal|"verify"
block|,
name|subcommand_verify
block|,
block|{
literal|0
block|}
block|,
name|N_
argument_list|(
literal|"usage: svnadmin verify REPOS_PATH\n\n"
literal|"Verify the data stored in the repository.\n"
argument_list|)
block|,
block|{
literal|'t'
block|,
literal|'r'
block|,
literal|'q'
block|,
literal|'M'
block|}
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|,
name|NULL
block|,
block|{
literal|0
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Baton for passing option/argument state to a subcommand function. */
end_comment

begin_struct
struct|struct
name|svnadmin_opt_state
block|{
specifier|const
name|char
modifier|*
name|repository_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_type
decl_stmt|;
comment|/* --fs-type */
name|svn_boolean_t
name|pre_1_4_compatible
decl_stmt|;
comment|/* --pre-1.4-compatible */
name|svn_boolean_t
name|pre_1_5_compatible
decl_stmt|;
comment|/* --pre-1.5-compatible */
name|svn_boolean_t
name|pre_1_6_compatible
decl_stmt|;
comment|/* --pre-1.6-compatible */
name|svn_version_t
modifier|*
name|compatible_version
decl_stmt|;
comment|/* --compatible-version */
name|svn_opt_revision_t
name|start_revision
decl_stmt|,
name|end_revision
decl_stmt|;
comment|/* -r X[:Y] */
specifier|const
name|char
modifier|*
name|txn_id
decl_stmt|;
comment|/* -t TXN */
name|svn_boolean_t
name|help
decl_stmt|;
comment|/* --help or -? */
name|svn_boolean_t
name|version
decl_stmt|;
comment|/* --version */
name|svn_boolean_t
name|incremental
decl_stmt|;
comment|/* --incremental */
name|svn_boolean_t
name|use_deltas
decl_stmt|;
comment|/* --deltas */
name|svn_boolean_t
name|use_pre_commit_hook
decl_stmt|;
comment|/* --use-pre-commit-hook */
name|svn_boolean_t
name|use_post_commit_hook
decl_stmt|;
comment|/* --use-post-commit-hook */
name|svn_boolean_t
name|use_pre_revprop_change_hook
decl_stmt|;
comment|/* --use-pre-revprop-change-hook */
name|svn_boolean_t
name|use_post_revprop_change_hook
decl_stmt|;
comment|/* --use-post-revprop-change-hook */
name|svn_boolean_t
name|quiet
decl_stmt|;
comment|/* --quiet */
name|svn_boolean_t
name|bdb_txn_nosync
decl_stmt|;
comment|/* --bdb-txn-nosync */
name|svn_boolean_t
name|bdb_log_keep
decl_stmt|;
comment|/* --bdb-log-keep */
name|svn_boolean_t
name|clean_logs
decl_stmt|;
comment|/* --clean-logs */
name|svn_boolean_t
name|bypass_hooks
decl_stmt|;
comment|/* --bypass-hooks */
name|svn_boolean_t
name|wait
decl_stmt|;
comment|/* --wait */
name|svn_boolean_t
name|bypass_prop_validation
decl_stmt|;
comment|/* --bypass-prop-validation */
name|enum
name|svn_repos_load_uuid
name|uuid_action
decl_stmt|;
comment|/* --ignore-uuid,                                                        --force-uuid */
name|apr_uint64_t
name|memory_cache_size
decl_stmt|;
comment|/* --memory-cache-size M */
specifier|const
name|char
modifier|*
name|parent_dir
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|filedata
decl_stmt|;
comment|/* --file */
specifier|const
name|char
modifier|*
name|config_dir
decl_stmt|;
comment|/* Overriding Configuration Directory */
block|}
struct|;
end_struct

begin_comment
comment|/* Set *REVNUM to the revision specified by REVISION (or to    SVN_INVALID_REVNUM if that has the type 'unspecified'),    possibly making use of the YOUNGEST revision number in REPOS. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|get_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|revnum
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|revision
parameter_list|,
name|svn_revnum_t
name|youngest
parameter_list|,
name|svn_repos_t
modifier|*
name|repos
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_number
condition|)
operator|*
name|revnum
operator|=
name|revision
operator|->
name|value
operator|.
name|number
expr_stmt|;
elseif|else
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_head
condition|)
operator|*
name|revnum
operator|=
name|youngest
expr_stmt|;
elseif|else
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_date
condition|)
name|SVN_ERR
argument_list|(
name|svn_repos_dated_revision
argument_list|(
name|revnum
argument_list|,
name|repos
argument_list|,
name|revision
operator|->
name|value
operator|.
name|date
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|revision
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
operator|*
name|revnum
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
else|else
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision specifier"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|*
name|revnum
operator|>
name|youngest
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Revisions must not be greater than the youngest revision (%ld)"
argument_list|)
argument_list|,
name|youngest
argument_list|)
return|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *PATH to an internal-style, UTF8-encoded, local dirent path    allocated from POOL and parsed from raw command-line argument ARG. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|target_arg_to_dirent
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|dirent
parameter_list|,
specifier|const
name|char
modifier|*
name|arg
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|path
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|path
argument_list|,
name|arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|path
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
literal|"Path '%s' is not a local path"
argument_list|,
name|path
argument_list|)
return|;
operator|*
name|dirent
operator|=
name|svn_dirent_internal_style
argument_list|(
name|path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Parse the remaining command-line arguments from OS, returning them    in a new array *ARGS (allocated from POOL) and optionally verifying    that we got the expected number thereof.  If MIN_EXPECTED is not    negative, return an error if the function would return fewer than    MIN_EXPECTED arguments.  If MAX_EXPECTED is not negative, return an    error if the function would return more than MAX_EXPECTED    arguments.     As a special case, when MIN_EXPECTED and MAX_EXPECTED are both 0,    allow ARGS to be NULL.  */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|parse_args
parameter_list|(
name|apr_array_header_t
modifier|*
modifier|*
name|args
parameter_list|,
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|int
name|min_expected
parameter_list|,
name|int
name|max_expected
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|int
name|num_args
init|=
name|os
condition|?
operator|(
name|os
operator|->
name|argc
operator|-
name|os
operator|->
name|ind
operator|)
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|min_expected
operator|||
name|max_expected
condition|)
name|SVN_ERR_ASSERT
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|min_expected
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|num_args
operator|<
name|min_expected
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_INSUFFICIENT_ARGS
argument_list|,
literal|0
argument_list|,
literal|"Not enough arguments"
argument_list|)
return|;
if|if
condition|(
operator|(
name|max_expected
operator|>=
literal|0
operator|)
operator|&&
operator|(
name|num_args
operator|>
name|max_expected
operator|)
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
literal|"Too many arguments"
argument_list|)
return|;
if|if
condition|(
name|args
condition|)
block|{
operator|*
name|args
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|num_args
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_args
condition|)
while|while
condition|(
name|os
operator|->
name|ind
operator|<
name|os
operator|->
name|argc
condition|)
name|APR_ARRAY_PUSH
argument_list|(
operator|*
name|args
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_crashtest
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR_MALFUNCTION
argument_list|()
expr_stmt|;
comment|/* merely silence a compiler warning (this will never be executed) */
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_create
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|apr_hash_t
modifier|*
name|fs_config
init|=
name|apr_hash_make
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_BDB_TXN_NOSYNC
argument_list|,
operator|(
name|opt_state
operator|->
name|bdb_txn_nosync
condition|?
literal|"1"
else|:
literal|"0"
operator|)
argument_list|)
expr_stmt|;
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_BDB_LOG_AUTOREMOVE
argument_list|,
operator|(
name|opt_state
operator|->
name|bdb_log_keep
condition|?
literal|"0"
else|:
literal|"1"
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|fs_type
condition|)
block|{
comment|/* With 1.8 we are announcing that BDB is deprecated.  No support        * has been removed and it will continue to work until some future        * date.  The purpose here is to discourage people from creating        * new BDB repositories which they will need to dump/load into        * FSFS or some new FS type in the future. */
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|opt_state
operator|->
name|fs_type
argument_list|,
name|SVN_FS_TYPE_BDB
argument_list|)
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"%swarning:"
literal|" The \"%s\" repository back-end is deprecated,"
literal|" consider using \"%s\" instead.\n"
argument_list|)
argument_list|,
literal|"svnadmin: "
argument_list|,
name|SVN_FS_TYPE_BDB
argument_list|,
name|SVN_FS_TYPE_FSFS
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_FS_TYPE
argument_list|,
name|opt_state
operator|->
name|fs_type
argument_list|)
expr_stmt|;
block|}
comment|/* Prior to 1.8, we had explicit options to specify compatibility      with a handful of prior Subversion releases. */
if|if
condition|(
name|opt_state
operator|->
name|pre_1_4_compatible
condition|)
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_4_COMPATIBLE
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|pre_1_5_compatible
condition|)
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_5_COMPATIBLE
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|pre_1_6_compatible
condition|)
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_6_COMPATIBLE
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
comment|/* In 1.8, we figured out that we didn't have to keep extending this      madness indefinitely. */
if|if
condition|(
name|opt_state
operator|->
name|compatible_version
condition|)
block|{
if|if
condition|(
operator|!
name|svn_version__at_least
argument_list|(
name|opt_state
operator|->
name|compatible_version
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_4_COMPATIBLE
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_version__at_least
argument_list|(
name|opt_state
operator|->
name|compatible_version
argument_list|,
literal|1
argument_list|,
literal|5
argument_list|,
literal|0
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_5_COMPATIBLE
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_version__at_least
argument_list|(
name|opt_state
operator|->
name|compatible_version
argument_list|,
literal|1
argument_list|,
literal|6
argument_list|,
literal|0
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_6_COMPATIBLE
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|svn_version__at_least
argument_list|(
name|opt_state
operator|->
name|compatible_version
argument_list|,
literal|1
argument_list|,
literal|8
argument_list|,
literal|0
argument_list|)
condition|)
name|svn_hash_sets
argument_list|(
name|fs_config
argument_list|,
name|SVN_FS_CONFIG_PRE_1_8_COMPATIBLE
argument_list|,
literal|"1"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|opt_state
operator|->
name|compatible_version
operator|&&
operator|!
name|svn_version__at_least
argument_list|(
name|opt_state
operator|->
name|compatible_version
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
comment|/* ### TODO: this NULL check hard-codes knowledge of the library's                    default fs-type value */
operator|&&
operator|(
name|opt_state
operator|->
name|fs_type
operator|==
name|NULL
operator|||
operator|!
name|strcmp
argument_list|(
name|opt_state
operator|->
name|fs_type
argument_list|,
name|SVN_FS_TYPE_FSFS
argument_list|)
operator|)
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Repositories compatible with 1.0.x must use "
literal|"--fs-type=bdb"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|svn_repos_create
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|fs_config
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_fs_set_warning_func
argument_list|(
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
argument_list|,
name|warning_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_deltify
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_revnum_t
name|start
init|=
name|SVN_INVALID_REVNUM
decl_stmt|,
name|end
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|,
name|revision
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the revision numbers at which to start and end. */
name|SVN_ERR
argument_list|(
name|get_revnum
argument_list|(
operator|&
name|start
argument_list|,
operator|&
name|opt_state
operator|->
name|start_revision
argument_list|,
name|youngest
argument_list|,
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_revnum
argument_list|(
operator|&
name|end
argument_list|,
operator|&
name|opt_state
operator|->
name|end_revision
argument_list|,
name|youngest
argument_list|,
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in implied revisions if necessary. */
if|if
condition|(
name|start
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|start
operator|=
name|youngest
expr_stmt|;
if|if
condition|(
name|end
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|end
operator|=
name|start
expr_stmt|;
if|if
condition|(
name|start
operator|>
name|end
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"First revision cannot be higher than second"
argument_list|)
argument_list|)
return|;
comment|/* Loop over the requested revision range, performing the      predecessor deltification on paths changed in each. */
for|for
control|(
name|revision
operator|=
name|start
init|;
name|revision
operator|<=
name|end
condition|;
name|revision
operator|++
control|)
block|{
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|check_cancel
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|subpool
argument_list|,
name|_
argument_list|(
literal|"Deltifying revision %ld..."
argument_list|)
argument_list|,
name|revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_deltify_revision
argument_list|(
name|fs
argument_list|,
name|revision
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|subpool
argument_list|,
name|_
argument_list|(
literal|"done.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Implementation of svn_repos_notify_func_t to wrap the output to a    response stream for svn_repos_dump_fs2() and svn_repos_verify_fs() */
end_comment

begin_function
specifier|static
name|void
name|repos_notify_handler
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|svn_repos_notify_t
modifier|*
name|notify
parameter_list|,
name|apr_pool_t
modifier|*
name|scratch_pool
parameter_list|)
block|{
name|svn_stream_t
modifier|*
name|feedback_stream
init|=
name|baton
decl_stmt|;
name|apr_size_t
name|len
decl_stmt|;
switch|switch
condition|(
name|notify
operator|->
name|action
condition|)
block|{
case|case
name|svn_repos_notify_warning
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"WARNING 0x%04x: %s\n"
argument_list|,
name|notify
operator|->
name|warning
argument_list|,
name|notify
operator|->
name|warning_str
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_dump_rev_end
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"* Dumped revision %ld.\n"
argument_list|)
argument_list|,
name|notify
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_verify_rev_end
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"* Verified revision %ld.\n"
argument_list|)
argument_list|,
name|notify
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_verify_rev_structure
case|:
if|if
condition|(
name|notify
operator|->
name|revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"* Verifying repository metadata ...\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"* Verifying metadata at revision %ld ...\n"
argument_list|)
argument_list|,
name|notify
operator|->
name|revision
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_pack_shard_start
case|:
block|{
specifier|const
name|char
modifier|*
name|shardstr
init|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|notify
operator|->
name|shard
argument_list|)
decl_stmt|;
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Packing revisions in shard %s..."
argument_list|)
argument_list|,
name|shardstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|svn_repos_notify_pack_shard_end
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_puts
argument_list|(
name|feedback_stream
argument_list|,
name|_
argument_list|(
literal|"done.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_pack_shard_start_revprop
case|:
block|{
specifier|const
name|char
modifier|*
name|shardstr
init|=
name|apr_psprintf
argument_list|(
name|scratch_pool
argument_list|,
literal|"%"
name|APR_INT64_T_FMT
argument_list|,
name|notify
operator|->
name|shard
argument_list|)
decl_stmt|;
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Packing revprops in shard %s..."
argument_list|)
argument_list|,
name|shardstr
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|svn_repos_notify_pack_shard_end_revprop
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_puts
argument_list|(
name|feedback_stream
argument_list|,
name|_
argument_list|(
literal|"done.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_load_txn_committed
case|:
if|if
condition|(
name|notify
operator|->
name|old_revision
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"\n------- Committed revision %ld>>>\n\n"
argument_list|)
argument_list|,
name|notify
operator|->
name|new_revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"\n------- Committed new rev %ld"
literal|" (loaded from original rev %ld"
literal|")>>>\n\n"
argument_list|)
argument_list|,
name|notify
operator|->
name|new_revision
argument_list|,
name|notify
operator|->
name|old_revision
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return;
case|case
name|svn_repos_notify_load_node_start
case|:
block|{
switch|switch
condition|(
name|notify
operator|->
name|node_action
condition|)
block|{
case|case
name|svn_node_action_change
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"     * editing path : %s ..."
argument_list|)
argument_list|,
name|notify
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_delete
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"     * deleting path : %s ..."
argument_list|)
argument_list|,
name|notify
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_add
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"     * adding path : %s ..."
argument_list|)
argument_list|,
name|notify
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svn_node_action_replace
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"     * replacing path : %s ..."
argument_list|)
argument_list|,
name|notify
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return;
case|case
name|svn_repos_notify_load_node_done
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
literal|"%s"
argument_list|,
name|_
argument_list|(
literal|" done.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_load_copied_node
case|:
name|len
operator|=
literal|9
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_stream_write
argument_list|(
name|feedback_stream
argument_list|,
literal|"COPIED..."
argument_list|,
operator|&
name|len
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_load_txn_start
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"<<< Started new transaction, based on "
literal|"original revision %ld\n"
argument_list|)
argument_list|,
name|notify
operator|->
name|old_revision
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_load_skipped_rev
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"<<< Skipped original revision %ld\n"
argument_list|)
argument_list|,
name|notify
operator|->
name|old_revision
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_load_normalized_mergeinfo
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|" removing '\\r' from %s ..."
argument_list|)
argument_list|,
name|SVN_PROP_MERGEINFO
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_mutex_acquired
case|:
comment|/* Enable cancellation signal handlers. */
name|setup_cancellation_signals
argument_list|(
name|signal_handler
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_recover_start
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_printf
argument_list|(
name|feedback_stream
argument_list|,
name|scratch_pool
argument_list|,
name|_
argument_list|(
literal|"Repository lock acquired.\n"
literal|"Please wait; recovering the"
literal|" repository may take some time...\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
case|case
name|svn_repos_notify_upgrade_start
case|:
name|svn_error_clear
argument_list|(
name|svn_stream_puts
argument_list|(
name|feedback_stream
argument_list|,
name|_
argument_list|(
literal|"Repository lock acquired.\n"
literal|"Please wait; upgrading the"
literal|" repository may take some time...\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
default|default:
return|return;
block|}
block|}
end_function

begin_comment
comment|/* Baton for recode_write(). */
end_comment

begin_struct
struct|struct
name|recode_write_baton
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|FILE
modifier|*
name|out
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* This implements the 'svn_write_fn_t' interface.     Write DATA to ((struct recode_write_baton *) BATON)->out, in the    console encoding, using svn_cmdline_fprintf().  DATA is a    UTF8-encoded C string, therefore ignore LEN.     ### This recoding mechanism might want to be abstracted into    ### svn_io.h or svn_cmdline.h, if it proves useful elsewhere. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|recode_write
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
specifier|const
name|char
modifier|*
name|data
parameter_list|,
name|apr_size_t
modifier|*
name|len
parameter_list|)
block|{
name|struct
name|recode_write_baton
modifier|*
name|rwb
init|=
name|baton
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|rwb
operator|->
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_cmdline_fputs
argument_list|(
name|data
argument_list|,
name|rwb
operator|->
name|out
argument_list|,
name|rwb
operator|->
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Create a stream, to write to STD_STREAM, that uses recode_write()    to perform UTF-8 to console encoding translation. */
end_comment

begin_function
specifier|static
name|svn_stream_t
modifier|*
name|recode_stream_create
parameter_list|(
name|FILE
modifier|*
name|std_stream
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|recode_write_baton
modifier|*
name|std_stream_rwb
init|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|recode_write_baton
argument_list|)
argument_list|)
decl_stmt|;
name|svn_stream_t
modifier|*
name|rw_stream
init|=
name|svn_stream_create
argument_list|(
name|std_stream_rwb
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|std_stream_rwb
operator|->
name|pool
operator|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
expr_stmt|;
name|std_stream_rwb
operator|->
name|out
operator|=
name|std_stream
expr_stmt|;
name|svn_stream_set_write
argument_list|(
name|rw_stream
argument_list|,
name|recode_write
argument_list|)
expr_stmt|;
return|return
name|rw_stream
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_dump
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdout_stream
decl_stmt|;
name|svn_revnum_t
name|lower
init|=
name|SVN_INVALID_REVNUM
decl_stmt|,
name|upper
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|;
name|svn_stream_t
modifier|*
name|progress_stream
init|=
name|NULL
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the revision numbers at which to start and end. */
name|SVN_ERR
argument_list|(
name|get_revnum
argument_list|(
operator|&
name|lower
argument_list|,
operator|&
name|opt_state
operator|->
name|start_revision
argument_list|,
name|youngest
argument_list|,
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_revnum
argument_list|(
operator|&
name|upper
argument_list|,
operator|&
name|opt_state
operator|->
name|end_revision
argument_list|,
name|youngest
argument_list|,
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in implied revisions if necessary. */
if|if
condition|(
name|lower
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
name|youngest
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|upper
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
name|upper
operator|=
name|lower
expr_stmt|;
block|}
if|if
condition|(
name|lower
operator|>
name|upper
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"First revision cannot be higher than second"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Progress feedback goes to STDERR, unless they asked to suppress it. */
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|progress_stream
operator|=
name|recode_stream_create
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_dump_fs3
argument_list|(
name|repos
argument_list|,
name|stdout_stream
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
name|opt_state
operator|->
name|incremental
argument_list|,
name|opt_state
operator|->
name|use_deltas
argument_list|,
operator|!
name|opt_state
operator|->
name|quiet
condition|?
name|repos_notify_handler
else|:
name|NULL
argument_list|,
name|progress_stream
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_struct
struct|struct
name|freeze_baton_t
block|{
specifier|const
name|char
modifier|*
name|command
decl_stmt|;
specifier|const
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
name|int
name|status
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Implements svn_repos_freeze_func_t */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|freeze_body
parameter_list|(
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|freeze_baton_t
modifier|*
name|b
init|=
name|baton
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
name|apr_file_t
modifier|*
name|infile
decl_stmt|,
modifier|*
name|outfile
decl_stmt|,
modifier|*
name|errfile
decl_stmt|;
name|apr_err
operator|=
name|apr_file_open_stdin
argument_list|(
operator|&
name|infile
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stdin"
argument_list|)
return|;
name|apr_err
operator|=
name|apr_file_open_stdout
argument_list|(
operator|&
name|outfile
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stdout"
argument_list|)
return|;
name|apr_err
operator|=
name|apr_file_open_stderr
argument_list|(
operator|&
name|errfile
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|apr_err
condition|)
return|return
name|svn_error_wrap_apr
argument_list|(
name|apr_err
argument_list|,
literal|"Can't open stderr"
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_io_run_cmd
argument_list|(
name|NULL
argument_list|,
name|b
operator|->
name|command
argument_list|,
name|b
operator|->
name|args
argument_list|,
operator|&
name|b
operator|->
name|status
argument_list|,
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|infile
argument_list|,
name|outfile
argument_list|,
name|errfile
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_freeze
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|paths
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|struct
name|freeze_baton_t
name|b
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_parse_all_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
operator|->
name|nelts
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"No program provided"
argument_list|)
argument_list|)
return|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|filedata
condition|)
block|{
comment|/* One repository on the command line. */
name|paths
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|APR_ARRAY_PUSH
argument_list|(
name|paths
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
operator|=
name|opt_state
operator|->
name|repository_path
expr_stmt|;
block|}
else|else
block|{
comment|/* All repositories in filedata. */
name|paths
operator|=
name|svn_cstring_split
argument_list|(
name|opt_state
operator|->
name|filedata
operator|->
name|data
argument_list|,
literal|"\n"
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
name|b
operator|.
name|command
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|b
operator|.
name|args
operator|=
name|apr_palloc
argument_list|(
name|pool
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|args
operator|->
name|nelts
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|nelts
condition|;
operator|++
name|i
control|)
name|b
operator|.
name|args
index|[
name|i
index|]
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|b
operator|.
name|args
index|[
name|args
operator|->
name|nelts
index|]
operator|=
name|NULL
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_freeze
argument_list|(
name|paths
argument_list|,
name|freeze_body
argument_list|,
operator|&
name|b
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make any non-zero status visible to the user. */
if|if
condition|(
name|b
operator|.
name|status
condition|)
name|exit
argument_list|(
name|b
operator|.
name|status
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_help
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
specifier|const
name|char
modifier|*
name|header
init|=
name|_
argument_list|(
literal|"general usage: svnadmin SUBCOMMAND REPOS_PATH  [ARGS& OPTIONS ...]\n"
literal|"Type 'svnadmin help<subcommand>' for help on a specific subcommand.\n"
literal|"Type 'svnadmin --version' to see the program version and FS modules.\n"
literal|"\n"
literal|"Available subcommands:\n"
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_desc_start
init|=
name|_
argument_list|(
literal|"The following repository back-end (FS) modules are available:\n\n"
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|version_footer
decl_stmt|;
name|version_footer
operator|=
name|svn_stringbuf_create
argument_list|(
name|fs_desc_start
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_print_modules
argument_list|(
name|version_footer
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_print_help4
argument_list|(
name|os
argument_list|,
literal|"svnadmin"
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|version
else|:
name|FALSE
argument_list|,
name|opt_state
condition|?
name|opt_state
operator|->
name|quiet
else|:
name|FALSE
argument_list|,
comment|/*###opt_state ? opt_state->verbose :*/
name|FALSE
argument_list|,
name|version_footer
operator|->
name|data
argument_list|,
name|header
argument_list|,
name|cmd_table
argument_list|,
name|options_table
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* Set *REVNUM to the revision number of a numeric REV, or to    SVN_INVALID_REVNUM if REV is unspecified. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|optrev_to_revnum
parameter_list|(
name|svn_revnum_t
modifier|*
name|revnum
parameter_list|,
specifier|const
name|svn_opt_revision_t
modifier|*
name|opt_rev
parameter_list|)
block|{
if|if
condition|(
name|opt_rev
operator|->
name|kind
operator|==
name|svn_opt_revision_number
condition|)
block|{
operator|*
name|revnum
operator|=
name|opt_rev
operator|->
name|value
operator|.
name|number
expr_stmt|;
if|if
condition|(
operator|!
name|SVN_IS_VALID_REVNUM
argument_list|(
operator|*
name|revnum
argument_list|)
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Invalid revision number (%ld) specified"
argument_list|)
argument_list|,
operator|*
name|revnum
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|opt_rev
operator|->
name|kind
operator|==
name|svn_opt_revision_unspecified
condition|)
block|{
operator|*
name|revnum
operator|=
name|SVN_INVALID_REVNUM
expr_stmt|;
block|}
else|else
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Non-numeric revision specified"
argument_list|)
argument_list|)
return|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_load
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_revnum_t
name|lower
init|=
name|SVN_INVALID_REVNUM
decl_stmt|,
name|upper
init|=
name|SVN_INVALID_REVNUM
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdin_stream
decl_stmt|,
modifier|*
name|stdout_stream
init|=
name|NULL
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Find the revision numbers at which to start and end.  We only      support a limited set of revision kinds: number and unspecified. */
name|SVN_ERR
argument_list|(
name|optrev_to_revnum
argument_list|(
operator|&
name|lower
argument_list|,
operator|&
name|opt_state
operator|->
name|start_revision
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|optrev_to_revnum
argument_list|(
operator|&
name|upper
argument_list|,
operator|&
name|opt_state
operator|->
name|end_revision
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fill in implied revisions if necessary. */
if|if
condition|(
operator|(
name|upper
operator|==
name|SVN_INVALID_REVNUM
operator|)
operator|&&
operator|(
name|lower
operator|!=
name|SVN_INVALID_REVNUM
operator|)
condition|)
block|{
name|upper
operator|=
name|lower
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|upper
operator|!=
name|SVN_INVALID_REVNUM
operator|)
operator|&&
operator|(
name|lower
operator|==
name|SVN_INVALID_REVNUM
operator|)
condition|)
block|{
name|lower
operator|=
name|upper
expr_stmt|;
block|}
comment|/* Ensure correct range ordering. */
if|if
condition|(
name|lower
operator|>
name|upper
condition|)
block|{
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"First revision cannot be higher than second"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Read the stream from STDIN.  Users can redirect a file. */
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdin
argument_list|(
operator|&
name|stdin_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Progress feedback goes to STDOUT, unless they asked to suppress it. */
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|stdout_stream
operator|=
name|recode_stream_create
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_repos_load_fs4
argument_list|(
name|repos
argument_list|,
name|stdin_stream
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
name|opt_state
operator|->
name|uuid_action
argument_list|,
name|opt_state
operator|->
name|parent_dir
argument_list|,
name|opt_state
operator|->
name|use_pre_commit_hook
argument_list|,
name|opt_state
operator|->
name|use_post_commit_hook
argument_list|,
operator|!
name|opt_state
operator|->
name|bypass_prop_validation
argument_list|,
name|opt_state
operator|->
name|quiet
condition|?
name|NULL
else|:
name|repos_notify_handler
argument_list|,
name|stdout_stream
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_BAD_PROPERTY_VALUE
condition|)
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Invalid property value found in "
literal|"dumpstream; consider repairing the source "
literal|"or using --bypass-prop-validation while "
literal|"loading."
argument_list|)
argument_list|)
return|;
return|return
name|err
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_lstxns
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|apr_array_header_t
modifier|*
name|txns
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_list_transactions
argument_list|(
operator|&
name|txns
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop, printing revisions. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|txns
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|txns
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_recover
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_revnum_t
name|youngest_rev
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdout_stream
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore default signal handlers until after we have acquired the    * exclusive lock so that the user interrupt before we actually    * touch the repository. */
name|setup_cancellation_signals
argument_list|(
name|SIG_DFL
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_repos_recover4
argument_list|(
name|opt_state
operator|->
name|repository_path
argument_list|,
name|TRUE
argument_list|,
name|repos_notify_handler
argument_list|,
name|stdout_stream
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
operator|!
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
return|return
name|err
return|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|wait
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_LOCKED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to get exclusive repository "
literal|"access; perhaps another process\n"
literal|"such as httpd, svnserve or svn "
literal|"has it open?"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Waiting on repository lock; perhaps"
literal|" another process has it open?\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_recover4
argument_list|(
name|opt_state
operator|->
name|repository_path
argument_list|,
name|FALSE
argument_list|,
name|repos_notify_handler
argument_list|,
name|stdout_stream
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"\nRecovery completed.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Since db transactions may have been replayed, it's nice to tell      people what the latest revision is.  It also proves that the      recovery actually worked. */
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest_rev
argument_list|,
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"The latest repos revision is %ld.\n"
argument_list|)
argument_list|,
name|youngest_rev
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|list_dblogs
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|svn_boolean_t
name|only_unused
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|logfiles
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_db_logfiles
argument_list|(
operator|&
name|logfiles
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|only_unused
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Loop, printing log files.  We append the log paths to the      repository path, making sure to return everything to the native      style before printing. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|logfiles
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|log_utf8
decl_stmt|;
name|log_utf8
operator|=
name|svn_dirent_join
argument_list|(
name|opt_state
operator|->
name|repository_path
argument_list|,
name|APR_ARRAY_IDX
argument_list|(
name|logfiles
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|log_utf8
operator|=
name|svn_dirent_local_style
argument_list|(
name|log_utf8
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
literal|"%s\n"
argument_list|,
name|log_utf8
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_list_dblogs
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|SVN_ERR
argument_list|(
name|list_dblogs
argument_list|(
name|os
argument_list|,
name|baton
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_list_unused_dblogs
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|list_dblogs
argument_list|(
name|os
argument_list|,
name|baton
argument_list|,
name|TRUE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_rmtxns
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt_parse_all_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
comment|/* All the rest of the arguments are transaction names. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|txn_name
init|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|txn_name_utf8
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|txn_name_utf8
argument_list|,
name|txn_name
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Try to open the txn.  If that succeeds, try to abort it. */
name|err
operator|=
name|svn_fs_open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|txn_name_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_fs_abort_txn
argument_list|(
name|txn
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
comment|/* If either the open or the abort of the txn fails because that          transaction is dead, just try to purge the thing.  Else,          there was either an error worth reporting, or not error at          all.  */
if|if
condition|(
name|err
operator|&&
operator|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_TRANSACTION_DEAD
operator|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_fs_purge_txn
argument_list|(
name|fs
argument_list|,
name|txn_name_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
block|}
comment|/* If we had a real from the txn open, abort, or purge, we clear          that error and just report to the user that we had an issue          with this particular txn. */
if|if
condition|(
name|err
condition|)
block|{
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
comment|/* non-fatal */
argument_list|,
literal|"svnadmin: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|subpool
argument_list|,
name|_
argument_list|(
literal|"Transaction '%s' removed.\n"
argument_list|)
argument_list|,
name|txn_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* A helper for the 'setrevprop' and 'setlog' commands.  Expects    OPT_STATE->use_pre_revprop_change_hook and    OPT_STATE->use_post_revprop_change_hook to be set appropriately. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|set_revprop
parameter_list|(
specifier|const
name|char
modifier|*
name|prop_name
parameter_list|,
specifier|const
name|char
modifier|*
name|filename
parameter_list|,
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_string_t
modifier|*
name|prop_value
init|=
name|svn_string_create_empty
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|file_contents
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|file_contents
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prop_value
operator|->
name|data
operator|=
name|file_contents
operator|->
name|data
expr_stmt|;
name|prop_value
operator|->
name|len
operator|=
name|file_contents
operator|->
name|len
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_subst_translate_string2
argument_list|(
operator|&
name|prop_value
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|prop_value
argument_list|,
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Open the filesystem  */
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If we are bypassing the hooks system, we just hit the filesystem      directly. */
name|SVN_ERR
argument_list|(
name|svn_repos_fs_change_rev_prop4
argument_list|(
name|repos
argument_list|,
name|opt_state
operator|->
name|start_revision
operator|.
name|value
operator|.
name|number
argument_list|,
name|NULL
argument_list|,
name|prop_name
argument_list|,
name|NULL
argument_list|,
name|prop_value
argument_list|,
name|opt_state
operator|->
name|use_pre_revprop_change_hook
argument_list|,
name|opt_state
operator|->
name|use_post_revprop_change_hook
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_setrevprop
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|prop_name
decl_stmt|,
modifier|*
name|filename
decl_stmt|;
comment|/* Expect two more arguments: NAME FILE */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
literal|2
argument_list|,
literal|2
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|prop_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|filename
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|target_arg_to_dirent
argument_list|(
operator|&
name|filename
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_number
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision"
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|opt_state
operator|->
name|end_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Only one revision allowed"
argument_list|)
argument_list|)
return|;
return|return
name|set_revprop
argument_list|(
name|prop_name
argument_list|,
name|filename
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_setuuid
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
specifier|const
name|char
modifier|*
name|uuid
init|=
name|NULL
decl_stmt|;
comment|/* Expect zero or one more arguments: [UUID] */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|->
name|nelts
operator|==
literal|1
condition|)
name|uuid
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
return|return
name|svn_fs_set_uuid
argument_list|(
name|fs
argument_list|,
name|uuid
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_setlog
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
comment|/* Expect one more argument: FILE */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|filename
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|target_arg_to_dirent
argument_list|(
operator|&
name|filename
argument_list|,
name|filename
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_number
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Missing revision"
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|opt_state
operator|->
name|end_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Only one revision allowed"
argument_list|)
argument_list|)
return|;
comment|/* set_revprop() responds only to pre-/post-revprop-change opts. */
if|if
condition|(
operator|!
name|opt_state
operator|->
name|bypass_hooks
condition|)
block|{
name|opt_state
operator|->
name|use_pre_revprop_change_hook
operator|=
name|TRUE
expr_stmt|;
name|opt_state
operator|->
name|use_post_revprop_change_hook
operator|=
name|TRUE
expr_stmt|;
block|}
return|return
name|set_revprop
argument_list|(
name|SVN_PROP_REVISION_LOG
argument_list|,
name|filename
argument_list|,
name|opt_state
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements 'svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_pack
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_stream_t
modifier|*
name|progress_stream
init|=
name|NULL
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Progress feedback goes to STDOUT, unless they asked to suppress it. */
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|progress_stream
operator|=
name|recode_stream_create
argument_list|(
name|stdout
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_error_trace
argument_list|(
name|svn_repos_fs_pack2
argument_list|(
name|repos
argument_list|,
operator|!
name|opt_state
operator|->
name|quiet
condition|?
name|repos_notify_handler
else|:
name|NULL
argument_list|,
name|progress_stream
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_verify
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_revnum_t
name|youngest
decl_stmt|,
name|lower
decl_stmt|,
name|upper
decl_stmt|;
name|svn_stream_t
modifier|*
name|progress_stream
init|=
name|NULL
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|txn_id
operator|&&
operator|(
name|opt_state
operator|->
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|||
name|opt_state
operator|->
name|end_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
operator|)
condition|)
block|{
return|return
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"--revision (-r) and --transaction (-t) "
literal|"are mutually exclusive"
argument_list|)
argument_list|)
return|;
block|}
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_youngest_rev
argument_list|(
operator|&
name|youngest
argument_list|,
name|fs
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Usage 2. */
if|if
condition|(
name|opt_state
operator|->
name|txn_id
condition|)
block|{
name|svn_fs_txn_t
modifier|*
name|txn
decl_stmt|;
name|svn_fs_root_t
modifier|*
name|root
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_open_txn
argument_list|(
operator|&
name|txn
argument_list|,
name|fs
argument_list|,
name|opt_state
operator|->
name|txn_id
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_txn_root
argument_list|(
operator|&
name|root
argument_list|,
name|txn
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_verify_root
argument_list|(
name|root
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
else|else
comment|/* Usage 1. */
empty_stmt|;
comment|/* Find the revision numbers at which to start and end. */
name|SVN_ERR
argument_list|(
name|get_revnum
argument_list|(
operator|&
name|lower
argument_list|,
operator|&
name|opt_state
operator|->
name|start_revision
argument_list|,
name|youngest
argument_list|,
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|get_revnum
argument_list|(
operator|&
name|upper
argument_list|,
operator|&
name|opt_state
operator|->
name|end_revision
argument_list|,
name|youngest
argument_list|,
name|repos
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|upper
operator|==
name|SVN_INVALID_REVNUM
condition|)
block|{
name|upper
operator|=
name|lower
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|opt_state
operator|->
name|quiet
condition|)
name|progress_stream
operator|=
name|recode_stream_create
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|)
expr_stmt|;
return|return
name|svn_repos_verify_fs2
argument_list|(
name|repos
argument_list|,
name|lower
argument_list|,
name|upper
argument_list|,
operator|!
name|opt_state
operator|->
name|quiet
condition|?
name|repos_notify_handler
else|:
name|NULL
argument_list|,
name|progress_stream
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
name|svn_error_t
modifier|*
name|subcommand_hotcopy
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
specifier|const
name|char
modifier|*
name|new_repos_path
decl_stmt|;
comment|/* Expect one more argument: NEW_REPOS_PATH */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|new_repos_path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|target_arg_to_dirent
argument_list|(
operator|&
name|new_repos_path
argument_list|,
name|new_repos_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|svn_repos_hotcopy2
argument_list|(
name|opt_state
operator|->
name|repository_path
argument_list|,
name|new_repos_path
argument_list|,
name|opt_state
operator|->
name|clean_logs
argument_list|,
name|opt_state
operator|->
name|incremental
argument_list|,
name|check_cancel
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_lock
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_access_t
modifier|*
name|access
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|comment_file_name
decl_stmt|;
name|svn_stringbuf_t
modifier|*
name|file_contents
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_path_utf8
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_token
init|=
name|NULL
decl_stmt|;
comment|/* Expect three more arguments: PATH USERNAME COMMENT-FILE */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
literal|3
argument_list|,
literal|4
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock_path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|username
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|comment_file_name
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|2
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* Expect one more optional argument: TOKEN */
if|if
condition|(
name|args
operator|->
name|nelts
operator|==
literal|4
condition|)
name|lock_token
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|3
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|target_arg_to_dirent
argument_list|(
operator|&
name|comment_file_name
argument_list|,
name|comment_file_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
comment|/* Create an access context describing the user. */
name|SVN_ERR
argument_list|(
name|svn_fs_create_access
argument_list|(
operator|&
name|access
argument_list|,
name|username
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Attach the access context to the filesystem. */
name|SVN_ERR
argument_list|(
name|svn_fs_set_access
argument_list|(
name|fs
argument_list|,
name|access
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
name|file_contents
argument_list|,
name|comment_file_name
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|lock_path_utf8
argument_list|,
name|lock_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|bypass_hooks
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|fs
argument_list|,
name|lock_path_utf8
argument_list|,
name|lock_token
argument_list|,
name|file_contents
operator|->
name|data
argument_list|,
comment|/* comment */
literal|0
argument_list|,
comment|/* is_dav_comment */
literal|0
argument_list|,
comment|/* no expiration time. */
name|SVN_INVALID_REVNUM
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_repos_fs_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|repos
argument_list|,
name|lock_path_utf8
argument_list|,
name|lock_token
argument_list|,
name|file_contents
operator|->
name|data
argument_list|,
comment|/* comment */
literal|0
argument_list|,
comment|/* is_dav_comment */
literal|0
argument_list|,
comment|/* no expiration time. */
name|SVN_INVALID_REVNUM
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"'%s' locked by user '%s'.\n"
argument_list|)
argument_list|,
name|lock_path
argument_list|,
name|username
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_lslocks
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|apr_array_header_t
modifier|*
name|targets
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
specifier|const
name|char
modifier|*
name|fs_path
init|=
literal|"/"
decl_stmt|;
name|apr_hash_t
modifier|*
name|locks
decl_stmt|;
name|apr_hash_index_t
modifier|*
name|hi
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_opt__args_to_target_array
argument_list|(
operator|&
name|targets
argument_list|,
name|os
argument_list|,
name|apr_array_make
argument_list|(
name|pool
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
specifier|const
name|char
operator|*
argument_list|)
argument_list|)
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|targets
operator|->
name|nelts
operator|>
literal|1
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"Too many arguments given"
argument_list|)
argument_list|)
return|;
if|if
condition|(
name|targets
operator|->
name|nelts
condition|)
name|fs_path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|targets
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch all locks on or below the root directory. */
name|SVN_ERR
argument_list|(
name|svn_repos_fs_get_locks2
argument_list|(
operator|&
name|locks
argument_list|,
name|repos
argument_list|,
name|fs_path
argument_list|,
name|svn_depth_infinity
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|hi
operator|=
name|apr_hash_first
argument_list|(
name|pool
argument_list|,
name|locks
argument_list|)
init|;
name|hi
condition|;
name|hi
operator|=
name|apr_hash_next
argument_list|(
name|hi
argument_list|)
control|)
block|{
specifier|const
name|char
modifier|*
name|cr_date
decl_stmt|,
modifier|*
name|exp_date
init|=
literal|""
decl_stmt|;
specifier|const
name|char
modifier|*
name|path
init|=
name|svn__apr_hash_index_key
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
init|=
name|svn__apr_hash_index_val
argument_list|(
name|hi
argument_list|)
decl_stmt|;
name|int
name|comment_lines
init|=
literal|0
decl_stmt|;
name|cr_date
operator|=
name|svn_time_to_human_cstring
argument_list|(
name|lock
operator|->
name|creation_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|expiration_date
condition|)
name|exp_date
operator|=
name|svn_time_to_human_cstring
argument_list|(
name|lock
operator|->
name|expiration_date
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|lock
operator|->
name|comment
condition|)
name|comment_lines
operator|=
name|svn_cstring_count_newlines
argument_list|(
name|lock
operator|->
name|comment
argument_list|)
operator|+
literal|1
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Path: %s\n"
argument_list|)
argument_list|,
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"UUID Token: %s\n"
argument_list|)
argument_list|,
name|lock
operator|->
name|token
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Owner: %s\n"
argument_list|)
argument_list|,
name|lock
operator|->
name|owner
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Created: %s\n"
argument_list|)
argument_list|,
name|cr_date
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Expires: %s\n"
argument_list|)
argument_list|,
name|exp_date
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|Q_
argument_list|(
literal|"Comment (%i line):\n%s\n\n"
argument_list|,
literal|"Comment (%i lines):\n%s\n\n"
argument_list|,
name|comment_lines
argument_list|)
argument_list|,
name|comment_lines
argument_list|,
name|lock
operator|->
name|comment
condition|?
name|lock
operator|->
name|comment
else|:
literal|""
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_rmlocks
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_access_t
modifier|*
name|access
decl_stmt|;
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
decl_stmt|;
name|apr_pool_t
modifier|*
name|subpool
init|=
name|svn_pool_create
argument_list|(
name|pool
argument_list|)
decl_stmt|;
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
comment|/* svn_fs_unlock() demands that some username be associated with the      filesystem, so just use the UID of the person running 'svnadmin'.*/
name|username
operator|=
name|svn_user_get_name
argument_list|(
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|username
condition|)
name|username
operator|=
literal|"administrator"
expr_stmt|;
comment|/* Create an access context describing the current user. */
name|SVN_ERR
argument_list|(
name|svn_fs_create_access
argument_list|(
operator|&
name|access
argument_list|,
name|username
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Attach the access context to the filesystem. */
name|SVN_ERR
argument_list|(
name|svn_fs_set_access
argument_list|(
name|fs
argument_list|,
name|access
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Parse out any options. */
name|SVN_ERR
argument_list|(
name|svn_opt_parse_all_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Our usage requires at least one FS path. */
if|if
condition|(
name|args
operator|->
name|nelts
operator|==
literal|0
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
literal|0
argument_list|,
name|_
argument_list|(
literal|"No paths to unlock provided"
argument_list|)
argument_list|)
return|;
comment|/* All the rest of the arguments are paths from which to remove locks. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|args
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|lock_path
init|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
name|i
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_path_utf8
decl_stmt|;
name|svn_lock_t
modifier|*
name|lock
decl_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|lock_path_utf8
argument_list|,
name|lock_path
argument_list|,
name|subpool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Fetch the path's svn_lock_t. */
name|err
operator|=
name|svn_fs_get_lock
argument_list|(
operator|&
name|lock
argument_list|,
name|fs
argument_list|,
name|lock_path_utf8
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|move_on
goto|;
if|if
condition|(
operator|!
name|lock
condition|)
block|{
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|subpool
argument_list|,
name|_
argument_list|(
literal|"Path '%s' isn't locked.\n"
argument_list|)
argument_list|,
name|lock_path
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Now forcibly destroy the lock. */
name|err
operator|=
name|svn_fs_unlock
argument_list|(
name|fs
argument_list|,
name|lock_path_utf8
argument_list|,
name|lock
operator|->
name|token
argument_list|,
literal|1
comment|/* force */
argument_list|,
name|subpool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|move_on
goto|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|subpool
argument_list|,
name|_
argument_list|(
literal|"Removed lock on '%s'.\n"
argument_list|)
argument_list|,
name|lock
operator|->
name|path
argument_list|)
argument_list|)
expr_stmt|;
name|move_on
label|:
if|if
condition|(
name|err
condition|)
block|{
comment|/* Print the error, but move on to the next lock. */
name|svn_handle_error2
argument_list|(
name|err
argument_list|,
name|stderr
argument_list|,
name|FALSE
comment|/* non-fatal */
argument_list|,
literal|"svnadmin: "
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|svn_pool_clear
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
block|}
name|svn_pool_destroy
argument_list|(
name|subpool
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_unlock
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_repos_t
modifier|*
name|repos
decl_stmt|;
name|svn_fs_t
modifier|*
name|fs
decl_stmt|;
name|svn_fs_access_t
modifier|*
name|access
decl_stmt|;
name|apr_array_header_t
modifier|*
name|args
decl_stmt|;
specifier|const
name|char
modifier|*
name|username
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_path
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_path_utf8
decl_stmt|;
specifier|const
name|char
modifier|*
name|lock_token
init|=
name|NULL
decl_stmt|;
comment|/* Expect three more arguments: PATH USERNAME TOKEN */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
operator|&
name|args
argument_list|,
name|os
argument_list|,
literal|3
argument_list|,
literal|3
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|lock_path
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|0
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|username
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|1
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|lock_token
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|args
argument_list|,
literal|2
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
comment|/* Open the repos/FS, and associate an access context containing      USERNAME. */
name|SVN_ERR
argument_list|(
name|open_repos
argument_list|(
operator|&
name|repos
argument_list|,
name|opt_state
operator|->
name|repository_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|fs
operator|=
name|svn_repos_fs
argument_list|(
name|repos
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_create_access
argument_list|(
operator|&
name|access
argument_list|,
name|username
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_fs_set_access
argument_list|(
name|fs
argument_list|,
name|access
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|lock_path_utf8
argument_list|,
name|lock_path
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|opt_state
operator|->
name|bypass_hooks
condition|)
name|SVN_ERR
argument_list|(
name|svn_fs_unlock
argument_list|(
name|fs
argument_list|,
name|lock_path_utf8
argument_list|,
name|lock_token
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|SVN_ERR
argument_list|(
name|svn_repos_fs_unlock
argument_list|(
name|repos
argument_list|,
name|lock_path_utf8
argument_list|,
name|lock_token
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"'%s' unlocked by user '%s'.\n"
argument_list|)
argument_list|,
name|lock_path
argument_list|,
name|username
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_comment
comment|/* This implements `svn_opt_subcommand_t'. */
end_comment

begin_function
specifier|static
name|svn_error_t
modifier|*
name|subcommand_upgrade
parameter_list|(
name|apr_getopt_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|baton
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|struct
name|svnadmin_opt_state
modifier|*
name|opt_state
init|=
name|baton
decl_stmt|;
name|svn_stream_t
modifier|*
name|stdout_stream
decl_stmt|;
comment|/* Expect no more arguments. */
name|SVN_ERR
argument_list|(
name|parse_args
argument_list|(
name|NULL
argument_list|,
name|os
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_stream_for_stdout
argument_list|(
operator|&
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Restore default signal handlers. */
name|setup_cancellation_signals
argument_list|(
name|SIG_DFL
argument_list|)
expr_stmt|;
name|err
operator|=
name|svn_repos_upgrade2
argument_list|(
name|opt_state
operator|->
name|repository_path
argument_list|,
name|TRUE
argument_list|,
name|repos_notify_handler
argument_list|,
name|stdout_stream
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
if|if
condition|(
name|APR_STATUS_IS_EAGAIN
argument_list|(
name|err
operator|->
name|apr_err
argument_list|)
condition|)
block|{
name|svn_error_clear
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|err
operator|=
name|SVN_NO_ERROR
expr_stmt|;
if|if
condition|(
operator|!
name|opt_state
operator|->
name|wait
condition|)
return|return
name|svn_error_create
argument_list|(
name|SVN_ERR_REPOS_LOCKED
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Failed to get exclusive repository "
literal|"access; perhaps another process\n"
literal|"such as httpd, svnserve or svn "
literal|"has it open?"
argument_list|)
argument_list|)
return|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"Waiting on repository lock; perhaps"
literal|" another process has it open?\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_repos_upgrade2
argument_list|(
name|opt_state
operator|->
name|repository_path
argument_list|,
name|FALSE
argument_list|,
name|repos_notify_handler
argument_list|,
name|stdout_stream
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_FS_UNSUPPORTED_UPGRADE
condition|)
block|{
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Upgrade of this repository's underlying versioned "
literal|"filesystem is not supported; consider "
literal|"dumping and loading the data elsewhere"
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_REPOS_UNSUPPORTED_UPGRADE
condition|)
block|{
return|return
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Upgrade of this repository is not supported; consider "
literal|"dumping and loading the data elsewhere"
argument_list|)
argument_list|)
return|;
block|}
block|}
name|SVN_ERR
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|SVN_ERR
argument_list|(
name|svn_cmdline_printf
argument_list|(
name|pool
argument_list|,
name|_
argument_list|(
literal|"\nUpgrade completed.\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|SVN_NO_ERROR
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/** Main. **/
end_comment

begin_comment
comment|/* Report and clear the error ERR, and return EXIT_FAILURE. */
end_comment

begin_define
define|#
directive|define
name|EXIT_ERROR
parameter_list|(
name|err
parameter_list|)
define|\
value|svn_cmdline_handle_exit_error(err, NULL, "svnadmin: ")
end_define

begin_comment
comment|/* A redefinition of the public SVN_INT_ERR macro, that suppresses the  * error message if it is SVN_ERR_IO_PIPE_WRITE_ERROR, amd with the  * program name 'svnadmin' instead of 'svn'. */
end_comment

begin_undef
undef|#
directive|undef
name|SVN_INT_ERR
end_undef

begin_define
define|#
directive|define
name|SVN_INT_ERR
parameter_list|(
name|expr
parameter_list|)
define|\
value|do {                                                           \     svn_error_t *svn_err__temp = (expr);                         \     if (svn_err__temp)                                           \       return EXIT_ERROR(svn_err__temp);                          \   } while (0)
end_define

begin_function
specifier|static
name|int
name|sub_main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|apr_pool_t
modifier|*
name|pool
parameter_list|)
block|{
name|svn_error_t
modifier|*
name|err
decl_stmt|;
name|apr_status_t
name|apr_err
decl_stmt|;
specifier|const
name|svn_opt_subcommand_desc2_t
modifier|*
name|subcommand
init|=
name|NULL
decl_stmt|;
name|struct
name|svnadmin_opt_state
name|opt_state
init|=
block|{
literal|0
block|}
decl_stmt|;
name|apr_getopt_t
modifier|*
name|os
decl_stmt|;
name|int
name|opt_id
decl_stmt|;
name|apr_array_header_t
modifier|*
name|received_opts
decl_stmt|;
name|int
name|i
decl_stmt|;
name|svn_boolean_t
name|dash_F_arg
init|=
name|FALSE
decl_stmt|;
name|received_opts
operator|=
name|apr_array_make
argument_list|(
name|pool
argument_list|,
name|SVN_OPT_MAX_OPTIONS
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Check library versions */
name|SVN_INT_ERR
argument_list|(
name|check_lib_versions
argument_list|()
argument_list|)
expr_stmt|;
comment|/* Initialize the FS library. */
name|SVN_INT_ERR
argument_list|(
name|svn_fs_initialize
argument_list|(
name|pool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<=
literal|1
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Initialize opt_state. */
name|opt_state
operator|.
name|start_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_state
operator|.
name|end_revision
operator|.
name|kind
operator|=
name|svn_opt_revision_unspecified
expr_stmt|;
name|opt_state
operator|.
name|memory_cache_size
operator|=
name|svn_cache_config_get
argument_list|()
operator|->
name|cache_size
expr_stmt|;
comment|/* Parse options. */
name|SVN_INT_ERR
argument_list|(
name|svn_cmdline__getopt_init
argument_list|(
operator|&
name|os
argument_list|,
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|->
name|interleave
operator|=
literal|1
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
specifier|const
name|char
modifier|*
name|opt_arg
decl_stmt|;
specifier|const
name|char
modifier|*
name|utf8_opt_arg
decl_stmt|;
comment|/* Parse the next option. */
name|apr_err
operator|=
name|apr_getopt_long
argument_list|(
name|os
argument_list|,
name|options_table
argument_list|,
operator|&
name|opt_id
argument_list|,
operator|&
name|opt_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|APR_STATUS_IS_EOF
argument_list|(
name|apr_err
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|apr_err
condition|)
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
comment|/* Stash the option code in an array before parsing it. */
name|APR_ARRAY_PUSH
argument_list|(
name|received_opts
argument_list|,
name|int
argument_list|)
operator|=
name|opt_id
expr_stmt|;
switch|switch
condition|(
name|opt_id
condition|)
block|{
case|case
literal|'r'
case|:
block|{
if|if
condition|(
name|opt_state
operator|.
name|start_revision
operator|.
name|kind
operator|!=
name|svn_opt_revision_unspecified
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Multiple revision arguments encountered; "
literal|"try '-r N:M' instead of '-r N -r M'"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|svn_opt_parse_revision
argument_list|(
operator|&
operator|(
name|opt_state
operator|.
name|start_revision
operator|)
argument_list|,
operator|&
operator|(
name|opt_state
operator|.
name|end_revision
operator|)
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Syntax error in revision argument '%s'"
argument_list|)
argument_list|,
name|utf8_opt_arg
argument_list|)
expr_stmt|;
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
block|}
break|break;
case|case
literal|'t'
case|:
name|opt_state
operator|.
name|txn_id
operator|=
name|opt_arg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|opt_state
operator|.
name|quiet
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
case|case
literal|'?'
case|:
name|opt_state
operator|.
name|help
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|opt_state
operator|.
name|memory_cache_size
operator|=
literal|0x100000
operator|*
name|apr_strtoi64
argument_list|(
name|opt_arg
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_stringbuf_from_file2
argument_list|(
operator|&
operator|(
name|opt_state
operator|.
name|filedata
operator|)
argument_list|,
name|utf8_opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|dash_F_arg
operator|=
name|TRUE
expr_stmt|;
case|case
name|svnadmin__version
case|:
name|opt_state
operator|.
name|version
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__incremental
case|:
name|opt_state
operator|.
name|incremental
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__deltas
case|:
name|opt_state
operator|.
name|use_deltas
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__ignore_uuid
case|:
name|opt_state
operator|.
name|uuid_action
operator|=
name|svn_repos_load_uuid_ignore
expr_stmt|;
break|break;
case|case
name|svnadmin__force_uuid
case|:
name|opt_state
operator|.
name|uuid_action
operator|=
name|svn_repos_load_uuid_force
expr_stmt|;
break|break;
case|case
name|svnadmin__pre_1_4_compatible
case|:
name|opt_state
operator|.
name|pre_1_4_compatible
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__pre_1_5_compatible
case|:
name|opt_state
operator|.
name|pre_1_5_compatible
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__pre_1_6_compatible
case|:
name|opt_state
operator|.
name|pre_1_6_compatible
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__compatible_version
case|:
block|{
name|svn_version_t
name|latest
init|=
block|{
name|SVN_VER_MAJOR
block|,
name|SVN_VER_MINOR
block|,
name|SVN_VER_PATCH
block|,
name|NULL
block|}
decl_stmt|;
name|svn_version_t
modifier|*
name|compatible_version
decl_stmt|;
comment|/* Parse the version string which carries our target              compatibility. */
name|SVN_INT_ERR
argument_list|(
name|svn_version__parse_version_string
argument_list|(
operator|&
name|compatible_version
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* We can't create repository with a version older than 1.0.0.  */
if|if
condition|(
operator|!
name|svn_version__at_least
argument_list|(
name|compatible_version
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot create pre-1.0-compatible "
literal|"repositories"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
comment|/* We can't create repository with a version newer than what              the running version of Subversion supports. */
if|if
condition|(
operator|!
name|svn_version__at_least
argument_list|(
operator|&
name|latest
argument_list|,
name|compatible_version
operator|->
name|major
argument_list|,
name|compatible_version
operator|->
name|minor
argument_list|,
name|compatible_version
operator|->
name|patch
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_UNSUPPORTED_FEATURE
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Cannot guarantee compatibility "
literal|"beyond the current running version "
literal|"(%s)"
argument_list|)
argument_list|,
name|SVN_VER_NUM
argument_list|)
expr_stmt|;
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
name|opt_state
operator|.
name|compatible_version
operator|=
name|compatible_version
expr_stmt|;
block|}
break|break;
case|case
name|svnadmin__fs_type
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_state
operator|.
name|fs_type
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnadmin__parent_dir
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|opt_state
operator|.
name|parent_dir
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|.
name|parent_dir
operator|=
name|svn_dirent_internal_style
argument_list|(
name|opt_state
operator|.
name|parent_dir
argument_list|,
name|pool
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnadmin__use_pre_commit_hook
case|:
name|opt_state
operator|.
name|use_pre_commit_hook
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__use_post_commit_hook
case|:
name|opt_state
operator|.
name|use_post_commit_hook
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__use_pre_revprop_change_hook
case|:
name|opt_state
operator|.
name|use_pre_revprop_change_hook
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__use_post_revprop_change_hook
case|:
name|opt_state
operator|.
name|use_post_revprop_change_hook
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__bdb_txn_nosync
case|:
name|opt_state
operator|.
name|bdb_txn_nosync
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__bdb_log_keep
case|:
name|opt_state
operator|.
name|bdb_log_keep
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__bypass_hooks
case|:
name|opt_state
operator|.
name|bypass_hooks
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__bypass_prop_validation
case|:
name|opt_state
operator|.
name|bypass_prop_validation
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__clean_logs
case|:
name|opt_state
operator|.
name|clean_logs
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|svnadmin__config_dir
case|:
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|utf8_opt_arg
argument_list|,
name|opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|opt_state
operator|.
name|config_dir
operator|=
name|apr_pstrdup
argument_list|(
name|pool
argument_list|,
name|svn_dirent_canonicalize
argument_list|(
name|utf8_opt_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|svnadmin__wait
case|:
name|opt_state
operator|.
name|wait
operator|=
name|TRUE
expr_stmt|;
break|break;
default|default:
block|{
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
comment|/* close `switch' */
block|}
comment|/* close `while' */
comment|/* If the user asked for help, then the rest of the arguments are      the names of subcommands to get help on (if any), or else they're      just typos/mistakes.  Whatever the case, the subcommand to      actually run is subcommand_help(). */
if|if
condition|(
name|opt_state
operator|.
name|help
condition|)
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
literal|"help"
argument_list|)
expr_stmt|;
comment|/* If we're not running the `help' subcommand, then look for a      subcommand in the first argument. */
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
if|if
condition|(
name|opt_state
operator|.
name|version
condition|)
block|{
comment|/* Use the "help" subcommand to handle the "--version" option. */
specifier|static
specifier|const
name|svn_opt_subcommand_desc2_t
name|pseudo_cmd
init|=
block|{
literal|"--version"
block|,
name|subcommand_help
block|,
block|{
literal|0
block|}
block|,
literal|""
block|,
block|{
name|svnadmin__version
block|,
comment|/* must accept its own option */
literal|'q'
block|,
comment|/* --quiet */
block|}
block|}
decl_stmt|;
name|subcommand
operator|=
operator|&
name|pseudo_cmd
expr_stmt|;
block|}
else|else
block|{
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"subcommand argument required\n"
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|first_arg
init|=
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
decl_stmt|;
name|subcommand
operator|=
name|svn_opt_get_canonical_subcommand2
argument_list|(
name|cmd_table
argument_list|,
name|first_arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|==
name|NULL
condition|)
block|{
specifier|const
name|char
modifier|*
name|first_arg_utf8
decl_stmt|;
name|SVN_INT_ERR
argument_list|(
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|first_arg_utf8
argument_list|,
name|first_arg
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Unknown subcommand: '%s'\n"
argument_list|)
argument_list|,
name|first_arg_utf8
argument_list|)
argument_list|)
expr_stmt|;
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
block|}
comment|/* Every subcommand except `help' and `freeze' with '-F' require a      second argument -- the repository path.  Parse it out here and      store it in opt_state. */
if|if
condition|(
operator|!
operator|(
name|subcommand
operator|->
name|cmd_func
operator|==
name|subcommand_help
operator|||
operator|(
name|subcommand
operator|->
name|cmd_func
operator|==
name|subcommand_freeze
operator|&&
name|dash_F_arg
operator|)
operator|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|repos_path
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|os
operator|->
name|ind
operator|>=
name|os
operator|->
name|argc
condition|)
block|{
name|err
operator|=
name|svn_error_create
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"Repository argument required"
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
operator|(
name|err
operator|=
name|svn_utf_cstring_to_utf8
argument_list|(
operator|&
name|repos_path
argument_list|,
name|os
operator|->
name|argv
index|[
name|os
operator|->
name|ind
operator|++
index|]
argument_list|,
name|pool
argument_list|)
operator|)
condition|)
block|{
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
if|if
condition|(
name|svn_path_is_url
argument_list|(
name|repos_path
argument_list|)
condition|)
block|{
name|err
operator|=
name|svn_error_createf
argument_list|(
name|SVN_ERR_CL_ARG_PARSING_ERROR
argument_list|,
name|NULL
argument_list|,
name|_
argument_list|(
literal|"'%s' is a URL when it should be a "
literal|"local path"
argument_list|)
argument_list|,
name|repos_path
argument_list|)
expr_stmt|;
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
name|opt_state
operator|.
name|repository_path
operator|=
name|svn_dirent_internal_style
argument_list|(
name|repos_path
argument_list|,
name|pool
argument_list|)
expr_stmt|;
block|}
comment|/* Check that the subcommand wasn't passed any inappropriate options. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|received_opts
operator|->
name|nelts
condition|;
name|i
operator|++
control|)
block|{
name|opt_id
operator|=
name|APR_ARRAY_IDX
argument_list|(
name|received_opts
argument_list|,
name|i
argument_list|,
name|int
argument_list|)
expr_stmt|;
comment|/* All commands implicitly accept --help, so just skip over this          when we see it. Note that we don't want to include this option          in their "accepted options" list because it would be awfully          redundant to display it in every commands' help text. */
if|if
condition|(
name|opt_id
operator|==
literal|'h'
operator|||
name|opt_id
operator|==
literal|'?'
condition|)
continue|continue;
if|if
condition|(
operator|!
name|svn_opt_subcommand_takes_option3
argument_list|(
name|subcommand
argument_list|,
name|opt_id
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
specifier|const
name|char
modifier|*
name|optstr
decl_stmt|;
specifier|const
name|apr_getopt_option_t
modifier|*
name|badopt
init|=
name|svn_opt_get_option_from_code2
argument_list|(
name|opt_id
argument_list|,
name|options_table
argument_list|,
name|subcommand
argument_list|,
name|pool
argument_list|)
decl_stmt|;
name|svn_opt_format_option
argument_list|(
operator|&
name|optstr
argument_list|,
name|badopt
argument_list|,
name|FALSE
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|subcommand
operator|->
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
name|SVN_INT_ERR
argument_list|(
name|subcommand_help
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pool
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|svn_error_clear
argument_list|(
name|svn_cmdline_fprintf
argument_list|(
name|stderr
argument_list|,
name|pool
argument_list|,
name|_
argument_list|(
literal|"Subcommand '%s' doesn't accept option '%s'\n"
literal|"Type 'svnadmin help %s' for usage.\n"
argument_list|)
argument_list|,
name|subcommand
operator|->
name|name
argument_list|,
name|optstr
argument_list|,
name|subcommand
operator|->
name|name
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|EXIT_FAILURE
return|;
block|}
block|}
comment|/* Set up our cancellation support. */
name|setup_cancellation_signals
argument_list|(
name|signal_handler
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGPIPE
comment|/* Disable SIGPIPE generation for the platforms that have it. */
name|apr_signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGXFSZ
comment|/* Disable SIGXFSZ generation for the platforms that have it, otherwise    * working with large files when compiled against an APR that doesn't have    * large file support will crash the program, which is uncool. */
name|apr_signal
argument_list|(
name|SIGXFSZ
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Configure FSFS caches for maximum efficiency with svnadmin.    * Also, apply the respective command line parameters, if given. */
block|{
name|svn_cache_config_t
name|settings
init|=
operator|*
name|svn_cache_config_get
argument_list|()
decl_stmt|;
name|settings
operator|.
name|cache_size
operator|=
name|opt_state
operator|.
name|memory_cache_size
expr_stmt|;
name|settings
operator|.
name|single_threaded
operator|=
name|TRUE
expr_stmt|;
name|svn_cache_config_set
argument_list|(
operator|&
name|settings
argument_list|)
expr_stmt|;
block|}
comment|/* Run the subcommand. */
name|err
operator|=
call|(
modifier|*
name|subcommand
operator|->
name|cmd_func
call|)
argument_list|(
name|os
argument_list|,
operator|&
name|opt_state
argument_list|,
name|pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* For argument-related problems, suggest using the 'help'          subcommand. */
if|if
condition|(
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_INSUFFICIENT_ARGS
operator|||
name|err
operator|->
name|apr_err
operator|==
name|SVN_ERR_CL_ARG_PARSING_ERROR
condition|)
block|{
name|err
operator|=
name|svn_error_quick_wrap
argument_list|(
name|err
argument_list|,
name|_
argument_list|(
literal|"Try 'svnadmin help' for more info"
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
else|else
block|{
comment|/* Ensure that everything is written to stdout, so the user will          see any print errors. */
name|err
operator|=
name|svn_cmdline_fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
return|return
name|EXIT_ERROR
argument_list|(
name|err
argument_list|)
return|;
block|}
return|return
name|EXIT_SUCCESS
return|;
block|}
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|apr_pool_t
modifier|*
name|pool
decl_stmt|;
name|int
name|exit_code
decl_stmt|;
comment|/* Initialize the app. */
if|if
condition|(
name|svn_cmdline_init
argument_list|(
literal|"svnadmin"
argument_list|,
name|stderr
argument_list|)
operator|!=
name|EXIT_SUCCESS
condition|)
return|return
name|EXIT_FAILURE
return|;
comment|/* Create our top-level pool.  Use a separate mutexless allocator,    * given this application is single threaded.    */
name|pool
operator|=
name|apr_allocator_owner_get
argument_list|(
name|svn_pool_create_allocator
argument_list|(
name|FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|exit_code
operator|=
name|sub_main
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|pool
argument_list|)
expr_stmt|;
name|svn_pool_destroy
argument_list|(
name|pool
argument_list|)
expr_stmt|;
return|return
name|exit_code
return|;
block|}
end_function

end_unit

